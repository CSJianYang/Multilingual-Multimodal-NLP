[
    {
        "title": "Minimum Score of a Path Between Two Cities",
        "question_content": "You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected.\nThe score of a path between two cities is defined as the minimum distance of a road in this path.\nReturn the minimum possible score of a path between cities 1 and n.\nNote:\n\n\tA path is a sequence of roads between two cities.\n\tIt is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\tThe test cases are generated such that there is at least one path between 1 and n.\n\n&nbsp;\nExample 1:\n\nInput: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\nOutput: 5\nExplanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5.\nIt can be shown that no other path has less score.\n\nExample 2:\n\nInput: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]\nOutput: 2\nExplanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.\n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 105\n\t1 <= roads.length <= 105\n\troads[i].length == 3\n\t1 <= ai, bi <= n\n\tai != bi\n\t1 <= distancei <= 104\n\tThere are no repeated edges.\n\tThere is at least one path between 1 and n.",
        "solutions": [
            {
                "id": 3326775,
                "title": "image-explanation-both-bfs-dfs-approaches-c-java-python-union-find-is-overrated",
                "content": "# Video Solution\\n`Minimum Score of a Path Between Two Cities by Aryan Mittal`\\n![pic.png](https://assets.leetcode.com/users/images/8cd146fa-a7eb-4f3d-925e-85c1e68c2985_1679454380.1627965.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/6ca6c410-6084-4fad-ae99-2aec3295587e_1679450801.7434034.png)\\n![image.png](https://assets.leetcode.com/users/images/28f0d775-ef6b-43c3-b409-7c372a8f68e0_1679450815.562221.png)\\n![image.png](https://assets.leetcode.com/users/images/a68d94f1-5d0b-4935-b1f3-e2541b868a3d_1679450824.9705253.png)\\n![image.png](https://assets.leetcode.com/users/images/9441334b-4ad4-4125-962e-33aee4036b3b_1679450836.1016412.png)\\n![image.png](https://assets.leetcode.com/users/images/83898236-7973-4a1a-992f-c163f4144f54_1679450853.7518644.png)\\n![image.png](https://assets.leetcode.com/users/images/af7689c4-166f-4fa9-9d89-fc3b88db5f79_1679450875.6272192.png)\\n![image.png](https://assets.leetcode.com/users/images/72f948a2-c812-4045-b52b-76b8bfde2601_1679450892.87835.png)\\n![image.png](https://assets.leetcode.com/users/images/4f1b0aa9-2a2d-41ec-8926-d4f128308849_1679450900.6033943.png)\\n\\n\\n# BFS Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX;\\n        vector<vector<pair<int, int>>> gr(n+1);\\n        for(auto edge : roads){ \\n            gr[edge[0]].push_back({edge[1], edge[2]}); // u-> {v, dis}\\n            gr[edge[1]].push_back({edge[0], edge[2]}); // v-> {u, dis}\\n        }\\n\\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1); vis[1] = 1;\\n        while(!q.empty()){\\n            auto node = q.front(); q.pop();\\n            for(auto& [v, dis] : gr[node]){\\n                ans = min(ans, dis);\\n                if(vis[v]==0){\\n                    vis[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int ans = Integer.MAX_VALUE;\\n        List<List<Pair<Integer, Integer>>> gr = new ArrayList<>();\\n        for(int i = 0; i < n+1; i++) {\\n            gr.add(new ArrayList<Pair<Integer, Integer>>());\\n        }\\n\\n        for(int[] edge : roads) { \\n            gr.get(edge[0]).add(new Pair<>(edge[1], edge[2])); // u-> {v, dis}\\n            gr.get(edge[1]).add(new Pair<>(edge[0], edge[2])); // v-> {u, dis}\\n        }\\n\\n        int[] vis = new int[n+1];\\n        Arrays.fill(vis, 0);\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(1);\\n        vis[1] = 1;\\n        while(!q.isEmpty()) {\\n            int node = q.poll();\\n            for(Pair<Integer, Integer> pair : gr.get(node)) {\\n                int v = pair.getKey();\\n                int dis = pair.getValue();\\n                ans = Math.min(ans, dis);\\n                if(vis[v]==0) {\\n                    vis[v] = 1;\\n                    q.add(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nfrom queue import Queue\\nfrom sys import maxsize\\n\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        ans = maxsize\\n        gr = [[] for _ in range(n+1)]\\n        for edge in roads:\\n            gr[edge[0]].append((edge[1], edge[2])) # u-> {v, dis}\\n            gr[edge[1]].append((edge[0], edge[2])) # v-> {u, dis}\\n\\n        vis = [0] * (n+1)\\n        q = Queue()\\n        q.put(1)\\n        vis[1] = 1\\n        while not q.empty():\\n            node = q.get()\\n            for v, dis in gr[node]:\\n                ans = min(ans, dis)\\n                if vis[v] == 0:\\n                    vis[v] = 1\\n                    q.put(v)\\n\\n        return ans\\n```\\n\\n# DFS Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int dfs(int node,int& ans, vector<vector<pair<int, int>>>& gr, vector<int>& vis){\\n        vis[node] = 1;\\n        for(auto& [v, dis] : gr[node]){\\n            ans = min(ans, dis);\\n            if(vis[v]==0){\\n                vis[v] = 1;\\n                ans = min(ans, dfs(v, ans, gr, vis));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX;\\n        vector<vector<pair<int, int>>> gr(n+1);\\n        for(auto edge : roads){ \\n            gr[edge[0]].push_back({edge[1], edge[2]}); // u-> {v, dis}\\n            gr[edge[1]].push_back({edge[0], edge[2]}); // v-> {u, dis}\\n        }\\n\\n        vector<int> vis(n+1, 0);\\n        dfs(1, ans, gr, vis);\\n\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX;\\n        vector<vector<pair<int, int>>> gr(n+1);\\n        for(auto edge : roads){ \\n            gr[edge[0]].push_back({edge[1], edge[2]}); // u-> {v, dis}\\n            gr[edge[1]].push_back({edge[0], edge[2]}); // v-> {u, dis}\\n        }\\n\\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1); vis[1] = 1;\\n        while(!q.empty()){\\n            auto node = q.front(); q.pop();\\n            for(auto& [v, dis] : gr[node]){\\n                ans = min(ans, dis);\\n                if(vis[v]==0){\\n                    vis[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int ans = Integer.MAX_VALUE;\\n        List<List<Pair<Integer, Integer>>> gr = new ArrayList<>();\\n        for(int i = 0; i < n+1; i++) {\\n            gr.add(new ArrayList<Pair<Integer, Integer>>());\\n        }\\n\\n        for(int[] edge : roads) { \\n            gr.get(edge[0]).add(new Pair<>(edge[1], edge[2])); // u-> {v, dis}\\n            gr.get(edge[1]).add(new Pair<>(edge[0], edge[2])); // v-> {u, dis}\\n        }\\n\\n        int[] vis = new int[n+1];\\n        Arrays.fill(vis, 0);\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(1);\\n        vis[1] = 1;\\n        while(!q.isEmpty()) {\\n            int node = q.poll();\\n            for(Pair<Integer, Integer> pair : gr.get(node)) {\\n                int v = pair.getKey();\\n                int dis = pair.getValue();\\n                ans = Math.min(ans, dis);\\n                if(vis[v]==0) {\\n                    vis[v] = 1;\\n                    q.add(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```Python []\\nfrom queue import Queue\\nfrom sys import maxsize\\n\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        ans = maxsize\\n        gr = [[] for _ in range(n+1)]\\n        for edge in roads:\\n            gr[edge[0]].append((edge[1], edge[2])) # u-> {v, dis}\\n            gr[edge[1]].append((edge[0], edge[2])) # v-> {u, dis}\\n\\n        vis = [0] * (n+1)\\n        q = Queue()\\n        q.put(1)\\n        vis[1] = 1\\n        while not q.empty():\\n            node = q.get()\\n            for v, dis in gr[node]:\\n                ans = min(ans, dis)\\n                if vis[v] == 0:\\n                    vis[v] = 1\\n                    q.put(v)\\n\\n        return ans\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int dfs(int node,int& ans, vector<vector<pair<int, int>>>& gr, vector<int>& vis){\\n        vis[node] = 1;\\n        for(auto& [v, dis] : gr[node]){\\n            ans = min(ans, dis);\\n            if(vis[v]==0){\\n                vis[v] = 1;\\n                ans = min(ans, dfs(v, ans, gr, vis));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX;\\n        vector<vector<pair<int, int>>> gr(n+1);\\n        for(auto edge : roads){ \\n            gr[edge[0]].push_back({edge[1], edge[2]}); // u-> {v, dis}\\n            gr[edge[1]].push_back({edge[0], edge[2]}); // v-> {u, dis}\\n        }\\n\\n        vector<int> vis(n+1, 0);\\n        dfs(1, ans, gr, vis);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875034,
                "title": "python-c-connected-component-of-1-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs traversal of the connected component of `1`. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Comment.** It is guaranteed in the problem that nodes `1` and `n` belong to the connected component of `1`. Any of its edges can be included in the path between `1` and `n`, because the graph is bidirectional and we can visit nodes multiple times (i.e., go back to the visited nodes). Thus, all we have to do is find the edge with minimal weight in the connected component of `1`. \\n\\n**Python.** Using BFS traversal with memoization of visited nodes.\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(dict)\\n        for u, v, w in roads:\\n            graph[u][v] = graph[v][u] = w\\n        \\n        res = inf\\n        vis = set()\\n        dq = deque([1])\\n\\n        while dq:\\n            node = dq.popleft()\\n            for adj, scr in graph[node].items():\\n                if adj not in vis:\\n                    dq.append(adj)\\n                    vis.add(adj)\\n                res = min(res,scr)\\n                \\n        return res\\n```\\n\\n**C++.** Using DFS traversal with memoization of visited nodes.\\n```cpp\\nclass Solution \\n{\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        unordered_map<int,unordered_map<int,int>> graph;\\n        for (auto r : roads)\\n            graph[r[0]][r[1]] = graph[r[1]][r[0]] = r[2];\\n        \\n        unordered_set<int> vis;\\n        \\n        function<int(int)> dfs;\\n        dfs = [&](int n) -> int\\n        {\\n            int res = INT_MAX;\\n            vis.insert(n);\\n            \\n            for (auto[adj, scr] : graph[n])\\n            {\\n                if (!vis.count(adj))\\n                    res = min(res, dfs(adj));\\n                res = min(res, scr);\\n            }\\n            \\n            return res;\\n        };\\n        \\n        return dfs(1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(dict)\\n        for u, v, w in roads:\\n            graph[u][v] = graph[v][u] = w\\n        \\n        res = inf\\n        vis = set()\\n        dq = deque([1])\\n\\n        while dq:\\n            node = dq.popleft()\\n            for adj, scr in graph[node].items():\\n                if adj not in vis:\\n                    dq.append(adj)\\n                    vis.add(adj)\\n                res = min(res,scr)\\n                \\n        return res\\n```\n```cpp\\nclass Solution \\n{\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        unordered_map<int,unordered_map<int,int>> graph;\\n        for (auto r : roads)\\n            graph[r[0]][r[1]] = graph[r[1]][r[0]] = r[2];\\n        \\n        unordered_set<int> vis;\\n        \\n        function<int(int)> dfs;\\n        dfs = [&](int n) -> int\\n        {\\n            int res = INT_MAX;\\n            vis.insert(n);\\n            \\n            for (auto[adj, scr] : graph[n])\\n            {\\n                if (!vis.count(adj))\\n                    res = min(res, dfs(adj));\\n                res = min(res, scr);\\n            }\\n            \\n            return res;\\n        };\\n        \\n        return dfs(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326689,
                "title": "java-easy-bfs",
                "content": "```\\nclass Pair{\\n    int node;\\n    int dist;\\n    Pair(int node,int dist){\\n        this.node=node;\\n        this.dist=dist;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<Pair>> adj=new ArrayList<>();\\n        for(int i=0;i<n+1;i++)\\n            adj.add(new ArrayList<>());\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        Queue<Pair> qu=new LinkedList<>();\\n        boolean vis[]=new boolean[n+1];\\n        qu.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(!qu.isEmpty()){\\n            Pair p=qu.poll();\\n            vis[p.node]=true;\\n            ans=Math.min(ans,p.dist);\\n            for(Pair adjcomp:adj.get(p.node)){\\n                if(!vis[adjcomp.node]){\\n                    qu.add(adjcomp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/a17b727b-a190-4a53-b611-1ca4b25e761b_1679447458.9686873.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Pair{\\n    int node;\\n    int dist;\\n    Pair(int node,int dist){\\n        this.node=node;\\n        this.dist=dist;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<Pair>> adj=new ArrayList<>();\\n        for(int i=0;i<n+1;i++)\\n            adj.add(new ArrayList<>());\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        Queue<Pair> qu=new LinkedList<>();\\n        boolean vis[]=new boolean[n+1];\\n        qu.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(!qu.isEmpty()){\\n            Pair p=qu.poll();\\n            vis[p.node]=true;\\n            ans=Math.min(ans,p.dist);\\n            for(Pair adjcomp:adj.get(p.node)){\\n                if(!vis[adjcomp.node]){\\n                    qu.add(adjcomp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874947,
                "title": "c-use-bfs-easy-efficient-approach",
                "content": "**Approach:** We can\\'t find minimum path score directly by traversing in roads 2d-vector because graph might be disconnected. So, First we mark the visited nodes in vis vector by using bfs then we find minimum score by checking whether ai and bi are visited in roads and calculate minimum value.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        //create adjacency list of roads to make it a graph\\n        vector<pair<int, int>> adj[n+1];\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        \\n        //mark possible visitable nodes \\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1), vis[1]=1;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for(auto it: adj[node])\\n            {\\n                if(!vis[it.first])\\n                {\\n                    q.push(it.first);\\n                    vis[it.first]=1;\\n                }\\n            }\\n        }\\n            \\n        //find minimum path score among visited nodes\\n        int mini_path = INT_MAX;\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            if(vis[roads[i][0]] && vis[roads[i][1]] && roads[i][2] < mini_path)\\n                mini_path = roads[i][2];\\n        }\\n        return mini_path;\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        //create adjacency list of roads to make it a graph\\n        vector<pair<int, int>> adj[n+1];\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        \\n        //mark possible visitable nodes \\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1), vis[1]=1;\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for(auto it: adj[node])\\n            {\\n                if(!vis[it.first])\\n                {\\n                    q.push(it.first);\\n                    vis[it.first]=1;\\n                }\\n            }\\n        }\\n            \\n        //find minimum path score among visited nodes\\n        int mini_path = INT_MAX;\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            if(vis[roads[i][0]] && vis[roads[i][1]] && roads[i][2] < mini_path)\\n                mini_path = roads[i][2];\\n        }\\n        return mini_path;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874946,
                "title": "dsu-java",
                "content": "```java\\nint[] dsu;\\npublic int minScore(int n, int[][] roads) {\\n    dsu = new int[n+1];\\n    int[] ans = new int[n+1];\\n    for(int i = 0; i <= n; i++) dsu[i] = i;\\n    Arrays.fill(ans, Integer.MAX_VALUE);\\n    for(int[] r : roads){\\n        int a = find(r[0]), b = find(r[1]);\\n        dsu[a] = dsu[b];\\n        ans[a] = ans[b] = Math.min(r[2],Math.min(ans[a],ans[b]));\\n    }\\n    return ans[find(1)];\\n}\\nint find(int i){\\n    return dsu[i]==i ? i : (dsu[i] = find(dsu[i]));\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nint[] dsu;\\npublic int minScore(int n, int[][] roads) {\\n    dsu = new int[n+1];\\n    int[] ans = new int[n+1];\\n    for(int i = 0; i <= n; i++) dsu[i] = i;\\n    Arrays.fill(ans, Integer.MAX_VALUE);\\n    for(int[] r : roads){\\n        int a = find(r[0]), b = find(r[1]);\\n        dsu[a] = dsu[b];\\n        ans[a] = ans[b] = Math.min(r[2],Math.min(ans[a],ans[b]));\\n    }\\n    return ans[find(1)];\\n}\\nint find(int i){\\n    return dsu[i]==i ? i : (dsu[i] = find(dsu[i]));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327539,
                "title": "with-images-and-hints-beats-94-dsu-union-find",
                "content": "# Intuition\\n**The problem has a vive of Travelling Slaesman Problem!! But slightly modified!!**\\n\\nAt first it seems to be very easy. You are probably thinking that you can just iterate through all the roads and get the minimum distance. Then show it as output.\\n\\nBut there\\'s a problem with that solution:\\n\\n```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int minPath = Integer.MAX_VALUE;\\n        for(int[] road : roads){\\n            minPath = Math.min(road[2], minPath);\\n        }\\n        return minPath;\\n    }\\n}\\n```\\n**Some roads can be completely disjoint from the start node.**\\nIn that case, the above code will give bad answer.\\n\\nSo, what can we do?\\n\\nThe question lies in head is that, we need to first determine some nodes that are connected with each other.\\n\\n**How can we determine some nodes that are connected with each other?**\\nWe can use **UnionFind**!! The parent of the same group nodes will be the same. This way we can find check for nodes that have the same parent as our starting node (**node 1**).\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust do a simple union find implementation. You should also think about storing the ranks. When we make union of two nodes, we should determine who becomes whose parent based on the rank they have.\\n\\nFor example: \\n```\\nInput: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\\n```\\n![image.png](https://assets.leetcode.com/users/images/28b013e2-f17f-45ca-8a5f-52eb82d5ef53_1679466034.1582954.png)\\n\\n## Union Making Simulation:\\n\\n![image.png](https://assets.leetcode.com/users/images/40794f54-d5e8-4c7a-8de8-a128d6ffa1c8_1679466927.9643662.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/66cb0703-0e8b-43e8-b5f2-a803b7ad1a71_1679466978.2681346.png)\\n\\n\\nI haven\\'t shown the edge weights. **A node\\'s parent is pointed by the arrow direction**.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N+E)$$\\nIterating for **N** nodes and **E** edges.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\nWe declare two arrays: parent and rank. They will require n length which is dependent on the input.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n    int find(int x){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n\\n    void makeUnion(int x, int y){\\n        int xPar = find(x);\\n        int yPar = find(y);\\n        if(xPar == yPar){\\n            return;\\n        }\\n        else if(rank[xPar]<rank[yPar]){\\n            parent[xPar] = yPar;\\n        }\\n        else if(rank[xPar]>rank[yPar]){\\n            parent[yPar] = xPar;\\n        }\\n        else{\\n            parent[yPar] = xPar;\\n            rank[xPar]++;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        parent = new int[n+1];\\n        rank = new int[n+1];\\n        for(int i=0; i<n+1; i++){\\n            parent[i] = i;\\n        }\\n        int minPath = Integer.MAX_VALUE;\\n        for(int[] road : roads){\\n            makeUnion(road[0], road[1]);\\n        }\\n\\n        // start is always node 1\\n        int xPar = find(1);\\n        for(int[] road: roads){\\n            // end can be any node from the roads array\\n            int yPar = find(road[0]);\\n            if(xPar == yPar) {\\n                minPath = Math.min(minPath, road[2]);\\n            }\\n        }\\n\\n        return minPath;\\n    }\\n}\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/ba74ecc8-2663-469e-80df-23a030c81bee_1679465963.8413434.png)",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int minPath = Integer.MAX_VALUE;\\n        for(int[] road : roads){\\n            minPath = Math.min(road[2], minPath);\\n        }\\n        return minPath;\\n    }\\n}\\n```\n```\\nInput: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\\n```\n```Java []\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n    int find(int x){\\n        while(parent[x]!=x){\\n            x = parent[parent[x]];\\n        }\\n        return x;\\n    }\\n\\n    void makeUnion(int x, int y){\\n        int xPar = find(x);\\n        int yPar = find(y);\\n        if(xPar == yPar){\\n            return;\\n        }\\n        else if(rank[xPar]<rank[yPar]){\\n            parent[xPar] = yPar;\\n        }\\n        else if(rank[xPar]>rank[yPar]){\\n            parent[yPar] = xPar;\\n        }\\n        else{\\n            parent[yPar] = xPar;\\n            rank[xPar]++;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        parent = new int[n+1];\\n        rank = new int[n+1];\\n        for(int i=0; i<n+1; i++){\\n            parent[i] = i;\\n        }\\n        int minPath = Integer.MAX_VALUE;\\n        for(int[] road : roads){\\n            makeUnion(road[0], road[1]);\\n        }\\n\\n        // start is always node 1\\n        int xPar = find(1);\\n        for(int[] road: roads){\\n            // end can be any node from the roads array\\n            int yPar = find(road[0]);\\n            if(xPar == yPar) {\\n                minPath = Math.min(minPath, road[2]);\\n            }\\n        }\\n\\n        return minPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875119,
                "title": "dsu-bfs-dfs",
                "content": "# Intuition:\\n- We can go and visit any edge in an undirected graph & `[1 , n]` are in same component.\\n- We will take advantage of this & we will simply get min edge weight by starting `DSU / bfs / dfs` from 1.\\n\\n> Take minimum edge weight\\n\\n**DSU**\\n> We just need edges which are in component of 1 or n, so we can use DSU in these scenarios when we need to filter a type of edges only.\\n\\nWe will put every edge in `dsu`.\\nThen we will `trace` the edges again & `filter` edges which are connected to `1` or `n`.\\n> This one is much faster than bfs/dfs.\\n# C++\\n    class DSU{\\n        vector<int> par, rank;\\n    public:\\n        DSU(int n) : par(n) , rank(n) {\\n            iota(begin(par), end(par), 0);\\n        }\\n        \\n        int find(int u){\\n            return par[u] = u == par[u] ? u : find(par[u]);\\n        }\\n        \\n        void connect(int u, int v){\\n            u = find(u);\\n            v = find(v);\\n            if(rank[u] > rank[v]) par[v] = u;\\n            else if(rank[u] < rank[v]) par[u] = v;\\n            else  rank[v]++ , par[u] = v;\\n        }\\n    };\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        ios_base::sync_with_stdio(false);  cin.tie(NULL);\\n        \\n        //Put edges in DSU\\n        DSU d(n + 1);\\n        for(auto e: roads) d.connect(e[0], e[1]);\\n\\t\\t\\n\\t\\t//Filter edges & update minimum edge weight\\n        int x = d.find(1) , res = 1e5;\\n        for(auto e: roads){\\n            int u = d.find(e[0]), v = d.find(e[1]);\\n            if(u == x or v == x)  res = min(res, e[2]); \\n        }\\n        return res;\\n    }\\n\\t\\n# Java\\t\\n\\tpublic class DSU {\\n        private int []par;\\n        private int []rank;\\n        \\n        public DSU(int n){\\n            par = new int[n];\\n            rank= new int[n];\\n            for(int i = 0; i < n;i++) par[i] = i;\\n        }\\n        \\n        public int find(int u){\\n            if(u == par[u]) return u;\\n            return par[u] = find(par[u]);\\n        }\\n        \\n        public void connect(int u, int v){\\n            u = find(u);\\n            v = find(v);\\n            if(rank[u] > rank[v]) par[v] = u;\\n            else if(rank[u] < rank[v]) par[u] = v;\\n            else {\\n                rank[v]++; par[u] = v;\\n            }\\n        }\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n        DSU d = new DSU(n + 1);\\n        for(var e: roads) d.connect(e[0], e[1]);\\n        \\n        int leader = d.find(1);\\n        \\n        //Filter edges & update minimum edge weight\\n        int res = 100000;\\n        for(var e: roads){\\n            int u = d.find(e[0]), v = d.find(e[1]);\\n            if(u == leader || v == leader) res = Math.min(res, e[2]); \\n        }\\n        \\n        return res;\\n    }\\n\\n**BFS**\\n# C++\\n     int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}),  G[i[1]].push_back({i[0], i[2]});\\n        \\n        vector<int> seen(n + 1);\\n        int mini = 1e5;\\n        queue<int> q{{{1}}};\\n        seen[1] = 1;\\n        while(q.size()){\\n            int u = q.front(); q.pop();\\n            for(auto &[v,w] : G[u]){\\n                mini = min(mini, w);\\n                if(!seen[v]){\\n                    seen[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n\\n**DFS - 1**\\n# C++\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> seen(n + 1);\\n\\t\\tseen[1] = true;\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}) ,  G[i[1]].push_back({i[0], i[2]});\\n    \\n        function<int(int)> dfs = [&](int u){\\n            int min_edge = 100000;\\n            for(auto &[v,w] : G[u]){\\n                 min_edge = min(min_edge, w);\\n                 if(!seen[v]){\\n                    seen[v] = 1;\\n                    min_edge = min(min_edge, dfs(v));\\n                 }\\n            }\\n            return min_edge;\\n        };\\n        \\n        return dfs(1);\\n    }\\n\\t\\n**DFS - 2**\\n# C++\\t\\n\\tint minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> seen(n + 1);\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}) , G[i[1]].push_back({i[0], i[2]});\\n    \\n        function<int(int)> dfs = [&](int u){\\n            if(seen[u]) return 100000;\\n            seen[u] = true;\\n            int min_edge = 100000;\\n            for(auto &[v,w] : G[u])\\n                 min_edge = min({min_edge, w, dfs(v)});\\n            return min_edge;\\n        };\\n        \\n        return dfs(1);\\n    }\\n\\t\\n> **Time** - O(n + m)\\n\\n> **Space** - O(n)\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "# Intuition:\\n- We can go and visit any edge in an undirected graph & `[1 , n]` are in same component.\\n- We will take advantage of this & we will simply get min edge weight by starting `DSU / bfs / dfs` from 1.\\n\\n> Take minimum edge weight\\n\\n**DSU**\\n> We just need edges which are in component of 1 or n, so we can use DSU in these scenarios when we need to filter a type of edges only.\\n\\nWe will put every edge in `dsu`.\\nThen we will `trace` the edges again & `filter` edges which are connected to `1` or `n`.\\n> This one is much faster than bfs/dfs.\\n# C++\\n    class DSU{\\n        vector<int> par, rank;\\n    public:\\n        DSU(int n) : par(n) , rank(n) {\\n            iota(begin(par), end(par), 0);\\n        }\\n        \\n        int find(int u){\\n            return par[u] = u == par[u] ? u : find(par[u]);\\n        }\\n        \\n        void connect(int u, int v){\\n            u = find(u);\\n            v = find(v);\\n            if(rank[u] > rank[v]) par[v] = u;\\n            else if(rank[u] < rank[v]) par[u] = v;\\n            else  rank[v]++ , par[u] = v;\\n        }\\n    };\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        ios_base::sync_with_stdio(false);  cin.tie(NULL);\\n        \\n        //Put edges in DSU\\n        DSU d(n + 1);\\n        for(auto e: roads) d.connect(e[0], e[1]);\\n\\t\\t\\n\\t\\t//Filter edges & update minimum edge weight\\n        int x = d.find(1) , res = 1e5;\\n        for(auto e: roads){\\n            int u = d.find(e[0]), v = d.find(e[1]);\\n            if(u == x or v == x)  res = min(res, e[2]); \\n        }\\n        return res;\\n    }\\n\\t\\n# Java\\t\\n\\tpublic class DSU {\\n        private int []par;\\n        private int []rank;\\n        \\n        public DSU(int n){\\n            par = new int[n];\\n            rank= new int[n];\\n            for(int i = 0; i < n;i++) par[i] = i;\\n        }\\n        \\n        public int find(int u){\\n            if(u == par[u]) return u;\\n            return par[u] = find(par[u]);\\n        }\\n        \\n        public void connect(int u, int v){\\n            u = find(u);\\n            v = find(v);\\n            if(rank[u] > rank[v]) par[v] = u;\\n            else if(rank[u] < rank[v]) par[u] = v;\\n            else {\\n                rank[v]++; par[u] = v;\\n            }\\n        }\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n        DSU d = new DSU(n + 1);\\n        for(var e: roads) d.connect(e[0], e[1]);\\n        \\n        int leader = d.find(1);\\n        \\n        //Filter edges & update minimum edge weight\\n        int res = 100000;\\n        for(var e: roads){\\n            int u = d.find(e[0]), v = d.find(e[1]);\\n            if(u == leader || v == leader) res = Math.min(res, e[2]); \\n        }\\n        \\n        return res;\\n    }\\n\\n**BFS**\\n# C++\\n     int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}),  G[i[1]].push_back({i[0], i[2]});\\n        \\n        vector<int> seen(n + 1);\\n        int mini = 1e5;\\n        queue<int> q{{{1}}};\\n        seen[1] = 1;\\n        while(q.size()){\\n            int u = q.front(); q.pop();\\n            for(auto &[v,w] : G[u]){\\n                mini = min(mini, w);\\n                if(!seen[v]){\\n                    seen[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n\\n**DFS - 1**\\n# C++\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> seen(n + 1);\\n\\t\\tseen[1] = true;\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}) ,  G[i[1]].push_back({i[0], i[2]});\\n    \\n        function<int(int)> dfs = [&](int u){\\n            int min_edge = 100000;\\n            for(auto &[v,w] : G[u]){\\n                 min_edge = min(min_edge, w);\\n                 if(!seen[v]){\\n                    seen[v] = 1;\\n                    min_edge = min(min_edge, dfs(v));\\n                 }\\n            }\\n            return min_edge;\\n        };\\n        \\n        return dfs(1);\\n    }\\n\\t\\n**DFS - 2**\\n# C++\\t\\n\\tint minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> seen(n + 1);\\n        vector<pair<int, int>> G[n + 1];\\n        for(auto i : roads)\\n            G[i[0]].push_back({i[1], i[2]}) , G[i[1]].push_back({i[0], i[2]});\\n    \\n        function<int(int)> dfs = [&](int u){\\n            if(seen[u]) return 100000;\\n            seen[u] = true;\\n            int min_edge = 100000;\\n            for(auto &[v,w] : G[u])\\n                 min_edge = min({min_edge, w, dfs(v)});\\n            return min_edge;\\n        };\\n        \\n        return dfs(1);\\n    }\\n\\t\\n> **Time** - O(n + m)\\n\\n> **Space** - O(n)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2875316,
                "title": "using-dijkstra-modified",
                "content": "\\n**creating the adj list**\\n**applying dijkstra and storing min dist of nodes**\\n**applying min distn of all nodes**\\n```\\nclass pair{\\n    int node;\\n    int dist;\\n    pair(int node1,int dist1){\\n        node=node1;\\n        dist=dist1;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        //creating the adj list\\n        List<List<pair>> adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++)adj.add(new ArrayList<>());\\n        \\n        for(int p[]:roads){\\n            adj.get(p[0]).add(new pair(p[1],p[2]));\\n            adj.get(p[1]).add(new pair(p[0],p[2]));\\n        }\\n        //pq for dijkstra\\n        Queue<pair> q=new PriorityQueue<>((a,b)->a.dist-b.dist);\\n        q.add(new pair(1,0));\\n        int distn[]=new int[n+1];\\n        Arrays.fill(distn,Integer.MAX_VALUE);\\n     \\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int node=it.node;\\n            int dis=it.dist;\\n            for(pair x1:adj.get(node)){\\n                //just storing the min edge modifying the dijkstra\\n                if(x1.dist<distn[x1.node]){\\n                    distn[x1.node]=x1.dist;\\n                    q.add(new pair(x1.node,distn[x1.node]));\\n                }\\n            }\\n        }\\n        //finding out min distn out of all node distn array\\n        int min=(int)1e9;\\n         for(int i=0;i<=n;i++){\\n            // System.out.print(distn[i]+\" \");\\n             min=Math.min(distn[i],min);\\n         }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass pair{\\n    int node;\\n    int dist;\\n    pair(int node1,int dist1){\\n        node=node1;\\n        dist=dist1;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        //creating the adj list\\n        List<List<pair>> adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++)adj.add(new ArrayList<>());\\n        \\n        for(int p[]:roads){\\n            adj.get(p[0]).add(new pair(p[1],p[2]));\\n            adj.get(p[1]).add(new pair(p[0],p[2]));\\n        }\\n        //pq for dijkstra\\n        Queue<pair> q=new PriorityQueue<>((a,b)->a.dist-b.dist);\\n        q.add(new pair(1,0));\\n        int distn[]=new int[n+1];\\n        Arrays.fill(distn,Integer.MAX_VALUE);\\n     \\n        while(!q.isEmpty()){\\n            pair it=q.poll();\\n            int node=it.node;\\n            int dis=it.dist;\\n            for(pair x1:adj.get(node)){\\n                //just storing the min edge modifying the dijkstra\\n                if(x1.dist<distn[x1.node]){\\n                    distn[x1.node]=x1.dist;\\n                    q.add(new pair(x1.node,distn[x1.node]));\\n                }\\n            }\\n        }\\n        //finding out min distn out of all node distn array\\n        int min=(int)1e9;\\n         for(int i=0;i<=n;i++){\\n            // System.out.print(distn[i]+\" \");\\n             min=Math.min(distn[i],min);\\n         }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874942,
                "title": "c-solution-using-bfs-explained",
                "content": "<b>Up Vote if you like the solution\\n```\\n/*\\nApproach : \\nWe need to traverse the graph starting from 1 to all connected node and get the shortest path linked to each node we visit.\\nNo need to worry about target, as it is given that there must be a ptah to the target.\\n\\nAlgo:\\n1. Create a weighted graph.\\n2. Run BFS from 1\\n3. which every node encountered, check for all the path liked to the nodes for sortest one; irrespective of it is got visited or not.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX; \\n        //create a weighted graph\\n        vector<vector<pair<int, int>>> g(n + 1);\\n        for(auto r: roads){\\n            g[r[0]].push_back({r[1], r[2]});\\n            g[r[1]].push_back({r[0], r[2]});\\n        }\\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1); vis[1] = 1;    //run bfs from 1\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            for(auto i: g[node]){\\n                ans = min(ans, i.second);   //check for min path length\\n                if(vis[i.first] != 1){\\n                    vis[i.first] = 1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nApproach : \\nWe need to traverse the graph starting from 1 to all connected node and get the shortest path linked to each node we visit.\\nNo need to worry about target, as it is given that there must be a ptah to the target.\\n\\nAlgo:\\n1. Create a weighted graph.\\n2. Run BFS from 1\\n3. which every node encountered, check for all the path liked to the nodes for sortest one; irrespective of it is got visited or not.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans = INT_MAX; \\n        //create a weighted graph\\n        vector<vector<pair<int, int>>> g(n + 1);\\n        for(auto r: roads){\\n            g[r[0]].push_back({r[1], r[2]});\\n            g[r[1]].push_back({r[0], r[2]});\\n        }\\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1); vis[1] = 1;    //run bfs from 1\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            for(auto i: g[node]){\\n                ans = min(ans, i.second);   //check for min path length\\n                if(vis[i.first] != 1){\\n                    vis[i.first] = 1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874945,
                "title": "easy-to-understand-pictorial-solution",
                "content": "Let\\'s assume the graph to be like:\\n\\n<img src=\"https://assets.leetcode.com/users/images/f83779b5-a4c9-476b-9a10-09bd0101f91d_1670125011.6390007.jpeg\" height=300 width=350>\\n\\nNow, from the graph we can see that it is not fully connected and is divided into two subgraphs with brown and green balls. We can observe that node 1 and n and connected in the brown balls graph. \\n\\nNow, we need to group all the brown balls graph and green balls graph as follows:\\n\\n<img src=\"https://assets.leetcode.com/users/images/215a8b7e-12a3-40db-9647-caf701dd79c2_1670125062.7306428.jpeg\" height=250 width=200>\\n\\nSince we can reach any node any number of times, it\\'s simple that we just need to know the minimum value in the brow balls graph(since node 1 and n are there in brown balls graph).\\n\\nSo for this, a new dictionary with minimum route value as a value to every node as key is stored and simply we can fetch the minimum value of all the nodes in brown balls graph.\\n\\nCODE:\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        minValues={}\\n        for i in roads:\\n            graph[i[0]].append([i[1],i[2]])\\n            graph[i[1]].append([i[0],i[2]])\\n            \\n            if(i[0] not in minValues):minValues[i[0]]=i[2]\\n            else:minValues[i[0]]=min(minValues[i[0]],i[2])\\n            \\n            if(i[1] not in minValues):minValues[i[1]]=i[2]\\n            else:minValues[i[1]]=min(minValues[i[1]],i[2])\\n                \\n        vis=set()\\n        q=deque([1])\\n        while(q):\\n            v=q.popleft()\\n            for j in graph[v]:\\n                if(j[0] not in vis):\\n                    vis.add(j[0])\\n                    q.append(j[0])\\n\\t\\t\\t\\t\\t\\n        #Here, vis is the set of all brown balls graph!\\n        \\n        min_value=float(\\'inf\\')\\n        for i in vis:\\n            min_value=min(min_value,minValues[i])\\n        return min_value\\n```\\n\\n**Time-Complexity: O(n)\\nSpace-Complexity:O(n)**\\n\\nUpvote if you like it :)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        minValues={}\\n        for i in roads:\\n            graph[i[0]].append([i[1],i[2]])\\n            graph[i[1]].append([i[0],i[2]])\\n            \\n            if(i[0] not in minValues):minValues[i[0]]=i[2]\\n            else:minValues[i[0]]=min(minValues[i[0]],i[2])\\n            \\n            if(i[1] not in minValues):minValues[i[1]]=i[2]\\n            else:minValues[i[1]]=min(minValues[i[1]],i[2])\\n                \\n        vis=set()\\n        q=deque([1])\\n        while(q):\\n            v=q.popleft()\\n            for j in graph[v]:\\n                if(j[0] not in vis):\\n                    vis.add(j[0])\\n                    q.append(j[0])\\n\\t\\t\\t\\t\\t\\n        #Here, vis is the set of all brown balls graph!\\n        \\n        min_value=float(\\'inf\\')\\n        for i in vis:\\n            min_value=min(min_value,minValues[i])\\n        return min_value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326645,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a graph with weighted edges, we can find the minimum cost path between any two vertices using a minimum spanning tree. A minimum spanning tree is a tree that connects all the vertices of the graph with the minimum total edge weight.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are different algorithms to find the minimum spanning tree of a graph, such as Prim\\'s algorithm and Kruskal\\'s algorithm. In general, these algorithms start with an empty tree and iteratively add the edge with the minimum weight that connects a vertex in the tree with a\\nvertex outside the tree. The process continues until all the vertices are in the tree.\\n\\nFor example, Kruskal\\'s algorithm works as follows:\\n1. Sort all the edges in non-decreasing order of their weight.\\n2. Initialize an empty tree and a set of connected components, where each vertex is a component.\\n3. Iterate through the sorted edges and add the edge to the tree if its endpoints belong to different connected components. Merge the components containing the endpoints of the edge.\\n4. Stop the iteration when the tree has N-1 edges, where N is the number of vertices in the\\ngraph\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of Kruskal\\'s algorithm is O(Elog(E)), where E is the number of edges in the graph. The time complexity is dominated by the sorting of the edges, which takes O(Elog(E)) time. The iterations of the for loop take O(E) time in total.\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of Kruskal\\'s algorithm is O(E + V), where V is the number of vertices in the graph. The space is required to store the edges, the connected components, and the parent pointers of each vertex in the connected components (to implement the union-find data structure).\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {  \\n        // Sort the roads array based on the first element of each subarray\\n        Arrays.sort(roads, (a, b)->{\\n            return a[0] - b[0];\\n        });\\n        // Initialize a set to keep track of the cities visited in the path\\n        HashSet<Integer> set = new HashSet<>();\\n        // Add the first city and the second city in the first road to the set\\n        set.add(roads[0][0]);\\n        set.add(roads[0][1]);\\n        // Initialize the minimum distance to be the distance of the first road\\n        int min = roads[0][2];\\n        // Repeat the following loop 100 times\\n        for(int j = 0; j < 100; j++){\\n            // Loop through each road in the sorted roads array\\n            for(int i = 1; i < roads.length; i++){\\n                // If either of the cities in the road is in the set, then add the other city to the set\\n                if(set.contains(roads[i][0]) || set.contains(roads[i][1])){\\n                    // Update the minimum distance if the distance of the current road is smaller\\n                    min = Math.min(roads[i][2], min);\\n                    set.add(roads[i][0]);\\n                    set.add(roads[i][1]);\\n                }\\n            }\\n        }        \\n        // Return the minimum distance found\\n        return min;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // Create an adjacency list to represent the graph\\n        unordered_map<int, unordered_map<int, int>> graph;\\n        for(auto road: roads){\\n            int u = road[0], v = road[1], w = road[2];\\n            graph[u][v] = graph[v][u] = w;\\n        }\\n        \\n        // Initialize variables for the minimum score and visited nodes\\n        int min_score = INT_MAX;\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n        \\n        // Use BFS to traverse the graph\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto adj: graph[node]){\\n                int neighbor = adj.first, score = adj.second;\\n                if(visited.count(neighbor) == 0){\\n                    q.push(neighbor);\\n                    visited.insert(neighbor);\\n                }\\n                min_score = min(min_score, score);\\n            }\\n        }\\n        \\n        // Return the minimum score found\\n        return min_score;\\n    }\\n};\\n\\n```\\n``` Python3 []\\nclass Solution:\\n    def minScore(self, num_nodes: int, edges: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(dict)\\n        for u, v, w in edges:\\n            graph[u][v] = graph[v][u] = w\\n        \\n        min_score = float(\\'inf\\')\\n        visited = set()\\n        queue = deque([1])\\n\\n        while queue:\\n            node = queue.popleft()\\n            for adj, score in graph[node].items():\\n                if adj not in visited:\\n                    queue.append(adj)\\n                    visited.add(adj)\\n                min_score = min(min_score, score)\\n                \\n        return min_score\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {  \\n        // Sort the roads array based on the first element of each subarray\\n        Arrays.sort(roads, (a, b)->{\\n            return a[0] - b[0];\\n        });\\n        // Initialize a set to keep track of the cities visited in the path\\n        HashSet<Integer> set = new HashSet<>();\\n        // Add the first city and the second city in the first road to the set\\n        set.add(roads[0][0]);\\n        set.add(roads[0][1]);\\n        // Initialize the minimum distance to be the distance of the first road\\n        int min = roads[0][2];\\n        // Repeat the following loop 100 times\\n        for(int j = 0; j < 100; j++){\\n            // Loop through each road in the sorted roads array\\n            for(int i = 1; i < roads.length; i++){\\n                // If either of the cities in the road is in the set, then add the other city to the set\\n                if(set.contains(roads[i][0]) || set.contains(roads[i][1])){\\n                    // Update the minimum distance if the distance of the current road is smaller\\n                    min = Math.min(roads[i][2], min);\\n                    set.add(roads[i][0]);\\n                    set.add(roads[i][1]);\\n                }\\n            }\\n        }        \\n        // Return the minimum distance found\\n        return min;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // Create an adjacency list to represent the graph\\n        unordered_map<int, unordered_map<int, int>> graph;\\n        for(auto road: roads){\\n            int u = road[0], v = road[1], w = road[2];\\n            graph[u][v] = graph[v][u] = w;\\n        }\\n        \\n        // Initialize variables for the minimum score and visited nodes\\n        int min_score = INT_MAX;\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n        \\n        // Use BFS to traverse the graph\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto adj: graph[node]){\\n                int neighbor = adj.first, score = adj.second;\\n                if(visited.count(neighbor) == 0){\\n                    q.push(neighbor);\\n                    visited.insert(neighbor);\\n                }\\n                min_score = min(min_score, score);\\n            }\\n        }\\n        \\n        // Return the minimum score found\\n        return min_score;\\n    }\\n};\\n\\n```\n``` Python3 []\\nclass Solution:\\n    def minScore(self, num_nodes: int, edges: List[List[int]]) -> int:\\n        \\n        graph = defaultdict(dict)\\n        for u, v, w in edges:\\n            graph[u][v] = graph[v][u] = w\\n        \\n        min_score = float(\\'inf\\')\\n        visited = set()\\n        queue = deque([1])\\n\\n        while queue:\\n            node = queue.popleft()\\n            for adj, score in graph[node].items():\\n                if adj not in visited:\\n                    queue.append(adj)\\n                    visited.add(adj)\\n                min_score = min(min_score, score)\\n                \\n        return min_score\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875970,
                "title": "simple-dfs",
                "content": "**Idea :** Aim is to traverse all possible paths in between 1 & n  and find the minimal weighted edge among all the paths.\\n*Note -* Graph is not necessarily connected but we are concerned about only paths connecting 1 & n so single dfs call is made from source i.e. 1\\n\\n```\\n    int mini = INT_MAX;\\n    \\n    void dfs(int s, vector<bool>&vis, vector<pair<int, int>>adj[]) {\\n        vis[s] = true;\\n        \\n        for(auto &it : adj[s]) {\\n            int v = it.first, wt = it.second;\\n            mini = min(mini, wt);\\n            if(!vis[v])\\n                dfs(v, vis, adj);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector< pair<int, int> > adj[n+1];\\n        for(auto &it : roads) {\\n            int u = it[0], v = it[1], wt = it[2];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n        \\n        vector<bool>vis(n+1, false);\\n        dfs(1, vis, adj);\\n        \\n        return mini;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n    int mini = INT_MAX;\\n    \\n    void dfs(int s, vector<bool>&vis, vector<pair<int, int>>adj[]) {\\n        vis[s] = true;\\n        \\n        for(auto &it : adj[s]) {\\n            int v = it.first, wt = it.second;\\n            mini = min(mini, wt);\\n            if(!vis[v])\\n                dfs(v, vis, adj);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector< pair<int, int> > adj[n+1];\\n        for(auto &it : roads) {\\n            int u = it[0], v = it[1], wt = it[2];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n        \\n        vector<bool>vis(n+1, false);\\n        dfs(1, vis, adj);\\n        \\n        return mini;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326946,
                "title": "c-bfs-commented-solution-simple",
                "content": "# Complexity\\n- Time complexity:\\nO(nodes + edges) + O(m) + O(m)\\n\\n- Space complexity:\\nO(m) + O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        // Storing graph in a adjacency list\\n        vector<int> adj[n+1];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n\\n        // making a visited array for keep tracking of all the cities (we have visited or not)\\n        // n = number of cities\\n        vector<bool> vis(n+1,false);\\n        vis[1] = true;                                  // mark source node as a visited city\\n        \\n        // BFS\\n        queue<int> q;\\n        q.push(1);\\n\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n\\n            for(auto &it : adj[node])\\n            {\\n                if(!vis[it])\\n                {\\n                    vis[it] = true;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n\\n\\n        // Computing minimum distance from city 1 to n\\n        int ans = INT_MAX;\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            // minimum possible score out of all available paths\\n            // if src and dest both are visited cities then try to make this our ans\\n            if(vis[roads[i][0]] && vis[roads[i][1]])\\n            {\\n                ans = min(ans,roads[i][2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n        // Storing graph in a adjacency list\\n        vector<int> adj[n+1];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n\\n        // making a visited array for keep tracking of all the cities (we have visited or not)\\n        // n = number of cities\\n        vector<bool> vis(n+1,false);\\n        vis[1] = true;                                  // mark source node as a visited city\\n        \\n        // BFS\\n        queue<int> q;\\n        q.push(1);\\n\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n\\n            for(auto &it : adj[node])\\n            {\\n                if(!vis[it])\\n                {\\n                    vis[it] = true;\\n                    q.push(it);\\n                }\\n            }\\n        }\\n\\n\\n        // Computing minimum distance from city 1 to n\\n        int ans = INT_MAX;\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            // minimum possible score out of all available paths\\n            // if src and dest both are visited cities then try to make this our ans\\n            if(vis[roads[i][0]] && vis[roads[i][1]])\\n            {\\n                ans = min(ans,roads[i][2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875643,
                "title": "java-3-solutions-union-find-dfs-bfs",
                "content": "# 3.DFS\\n```\\n\\t//3.DFS\\n    //Runtime: 49 ms, faster than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 114.2 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: (N + E); Space: O(E + N);\\n    public int minScore_3(int n, int[][] roads) {\\n        List<int[]>[] graph = new List[n + 1];\\n        for (int i = 0; i < graph.length; i++) graph[i] = new ArrayList<>();\\n        for(int[] road: roads){\\n            graph[road[0]].add(new int[]{road[1], road[2]});\\n            graph[road[1]].add(new int[]{road[0], road[2]});\\n        }\\n        Set<Integer> seen = new HashSet<>();\\n        seen.add(1);\\n        return helper_dfs(graph, 1, seen);\\n    }\\n\\n    private int helper_dfs(List<int[]>[] graph, int node, Set<Integer> seen) {\\n        int res = Integer.MAX_VALUE;\\n        for(int[] neighbour : graph[node]) {\\n            res = Math.min(res, neighbour[1]);\\n            if (seen.add(neighbour[0]))\\n                res = Math.min(res, helper_dfs(graph, neighbour[0], seen));\\n        }\\n        return res;\\n    }\\n```\\n# 2.BFS\\n```\\n    //2.BFS\\n    //Runtime: 48 ms, faster than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 111.8 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: (N + E); Space: O(E + N);\\n    public int minScore_2(int n, int[][] roads) {\\n        int res = Integer.MAX_VALUE;\\n\\n        List<int[]>[] graph = new List[n + 1];\\n        for (int i = 0; i < graph.length; i++) graph[i] = new ArrayList<>();\\n        for(int[] road: roads){\\n            graph[road[0]].add(new int[]{road[1], road[2]});\\n            graph[road[1]].add(new int[]{road[0], road[2]});\\n        }\\n\\n        Set<Integer> seen = new HashSet<>();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(1);\\n        seen.add(1);\\n\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n            for(int[] neighbour: graph[node]){\\n                res = Math.min(res, neighbour[1]);\\n                if (seen.add(neighbour[0])) queue.add(neighbour[0]);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n# 1.Union find\\n```\\n    //1.Union find\\n    //Runtime: 7 ms, faster than 62.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 108.1 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: O(E * log(N); Space:O(N)\\n    public int minScore(int n, int[][] roads) {\\n        UnionFind uf = new UnionFind(n + 1);\\n        for(int[] road: roads)\\n            uf.union(road[0], road[1], road[2]);\\n\\n        int group = uf.find(1);\\n        if (group == uf.find(n)) return uf.distance[group];\\n\\n        return -1;\\n    }\\n\\n    public class UnionFind {\\n\\n        private int[] group;\\n        private int[] rank;\\n        private int[] distance;\\n\\n        public UnionFind(int size) {\\n            group = new int[size];\\n            rank = new int[size];\\n            distance = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                group[i] = i; rank[i] = 1;\\n                distance[i] = Integer.MAX_VALUE;\\n            }\\n        }\\n\\n        //Time: O(\\u03B1(N))\\n        public int find(int x) {\\n            return x == group[x] ? x: (group[x] = find(group[x]));\\n        }\\n\\n        public void union(int x, int y, int d){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n\\n            int minD = Math.min(distance[rootX], distance[rootY]);\\n            minD = Math.min(minD, d);\\n            distance[rootX] = distance[rootY] = minD;\\n\\n            if (rootX == rootY) return;\\n\\n            if (rank[rootX] < rank[rootY]){\\n                group[rootX] = rootY;\\n            }else{\\n                group[rootY] = rootX;\\n                if (rank[rootX] == rank[rootY]) rank[rootX]++;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\n\\t//3.DFS\\n    //Runtime: 49 ms, faster than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 114.2 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: (N + E); Space: O(E + N);\\n    public int minScore_3(int n, int[][] roads) {\\n        List<int[]>[] graph = new List[n + 1];\\n        for (int i = 0; i < graph.length; i++) graph[i] = new ArrayList<>();\\n        for(int[] road: roads){\\n            graph[road[0]].add(new int[]{road[1], road[2]});\\n            graph[road[1]].add(new int[]{road[0], road[2]});\\n        }\\n        Set<Integer> seen = new HashSet<>();\\n        seen.add(1);\\n        return helper_dfs(graph, 1, seen);\\n    }\\n\\n    private int helper_dfs(List<int[]>[] graph, int node, Set<Integer> seen) {\\n        int res = Integer.MAX_VALUE;\\n        for(int[] neighbour : graph[node]) {\\n            res = Math.min(res, neighbour[1]);\\n            if (seen.add(neighbour[0]))\\n                res = Math.min(res, helper_dfs(graph, neighbour[0], seen));\\n        }\\n        return res;\\n    }\\n```\n```\\n    //2.BFS\\n    //Runtime: 48 ms, faster than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 111.8 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: (N + E); Space: O(E + N);\\n    public int minScore_2(int n, int[][] roads) {\\n        int res = Integer.MAX_VALUE;\\n\\n        List<int[]>[] graph = new List[n + 1];\\n        for (int i = 0; i < graph.length; i++) graph[i] = new ArrayList<>();\\n        for(int[] road: roads){\\n            graph[road[0]].add(new int[]{road[1], road[2]});\\n            graph[road[1]].add(new int[]{road[0], road[2]});\\n        }\\n\\n        Set<Integer> seen = new HashSet<>();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(1);\\n        seen.add(1);\\n\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n            for(int[] neighbour: graph[node]){\\n                res = Math.min(res, neighbour[1]);\\n                if (seen.add(neighbour[0])) queue.add(neighbour[0]);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    //1.Union find\\n    //Runtime: 7 ms, faster than 62.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Memory Usage: 108.1 MB, less than 12.50% of Java online submissions for Minimum Score of a Path Between Two Cities.\\n    //Time: O(E * log(N); Space:O(N)\\n    public int minScore(int n, int[][] roads) {\\n        UnionFind uf = new UnionFind(n + 1);\\n        for(int[] road: roads)\\n            uf.union(road[0], road[1], road[2]);\\n\\n        int group = uf.find(1);\\n        if (group == uf.find(n)) return uf.distance[group];\\n\\n        return -1;\\n    }\\n\\n    public class UnionFind {\\n\\n        private int[] group;\\n        private int[] rank;\\n        private int[] distance;\\n\\n        public UnionFind(int size) {\\n            group = new int[size];\\n            rank = new int[size];\\n            distance = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                group[i] = i; rank[i] = 1;\\n                distance[i] = Integer.MAX_VALUE;\\n            }\\n        }\\n\\n        //Time: O(\\u03B1(N))\\n        public int find(int x) {\\n            return x == group[x] ? x: (group[x] = find(group[x]));\\n        }\\n\\n        public void union(int x, int y, int d){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n\\n            int minD = Math.min(distance[rootX], distance[rootY]);\\n            minD = Math.min(minD, d);\\n            distance[rootX] = distance[rootY] = minD;\\n\\n            if (rootX == rootY) return;\\n\\n            if (rank[rootX] < rank[rootY]){\\n                group[rootX] = rootY;\\n            }else{\\n                group[rootY] = rootX;\\n                if (rank[rootX] == rank[rootY]) rank[rootX]++;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326975,
                "title": "day-81-union-find-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThis code implements a solution to the problem of finding the minimum score among all paths that connect the first city to every other city in a graph, where each edge is associated with a score. The solution is based on the union-find algorithm, which is used to merge the sets of vertices that are connected by each edge.\\n\\nInitially, each vertex is considered as a separate set, with its parent being itself. Then, for each edge, we find the root of the set that contains its two vertices, and merge the two sets by setting the parent of one of the roots to the other root. The rank of each set is also updated accordingly to keep the tree balanced.\\n\\nFinally, we iterate over all the edges again and find the root of the set that contains the first city, as well as the roots of the sets that contain the two vertices of each edge. If all three roots are the same, it means that the edge is part of the path that connects the first city to the other city, and we update the minimum score accordingly.\\n\\n**The intuition behind this algorithm is that by merging the sets of vertices that are connected by edges, we are building clusters of vertices that are connected to each other. By finding the root of the set that contains the first city, we can check whether each edge is part of the path that connects the first city to every other city. This approach reduces the number of paths that need to be checked, as we only need to consider the edges that are part of the clusters containing the first city.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Define the class Solution.\\n2. Define two member variables root and rank as vectors.\\n3. Define the find() function that takes an integer x as input and returns the root of the set that contains x.\\n4. Inside the find() function, check if the current vertex is the root of its set. If it is, return its value. Otherwise, update its parent to be the root of the set that contains its current parent, and return its new root.\\n5. Define the createUnion() function that takes two integers x and y as input, and merges the sets that contain x and y.\\n6. Inside the createUnion() function, find the roots of the sets that contain x and y. If the roots are the same, return without doing anything. Otherwise, merge the sets by setting the parent of one of the roots to the other root. If the ranks of the two sets are equal, increment the rank of the new root.\\n7. Define the minScore() function that takes an integer n and a vector of vectors roads as input, and returns an integer representing the minimum score among all paths that connect the first city to every other city.\\n8. Initialize root and rank to empty vectors of size n+1.\\n9. For each vertex i from 0 to n-1, set root[i] to i and rank[i] to 0.\\n10. Initialize minScore to INT_MAX.\\n11. For each edge in roads, call createUnion() with its two vertices.\\n12. For each edge in roads, find the roots of the sets that contain the first city (1) and the two vertices of the edge (road[0] and road[1]). If all three roots are the same, update minScore to be the minimum of its current value and the score of the current edge.\\n13. Return minScore.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> root, rank;\\n    \\n    int find(int x){\\n        if(x == root[x])\\n            return root[x];\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        if(rank[rootX] < rank[rootY])\\n            root[rootX] = rootY;\\n        else if(rank[rootX] > rank[rootY])\\n            root[rootY] = rootX;\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        root.resize(n + 1);\\n        rank.resize(n + 1);\\n        for(int i = 0; i < n; i++){\\n            root[i] = i;\\n            rank[i] = 0;\\n        }\\n        int minScore = INT_MAX;\\n        for (auto road : roads) {\\n            createUnion(road[0], road[1]);\\n        }\\n        for (auto road : roads) {\\n            int root1 = find(1);\\n            int rootX = find(road[0]);\\n            int rootY = find(road[1]);\\n            if (root1 == rootX && root1 == rootY) {\\n                minScore = min(minScore, road[2]);\\n            }\\n        }\\n        return minScore;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private int[] root, rank;\\n    \\n    private int find(int x){\\n        if(x == root[x])\\n            return root[x];\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    private void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        if(rank[rootX] < rank[rootY])\\n            root[rootX] = rootY;\\n        else if(rank[rootX] > rank[rootY])\\n            root[rootY] = rootX;\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n        root = new int[n + 1];\\n        rank = new int[n + 1];\\n        for(int i = 0; i < n; i++){\\n            root[i] = i;\\n            rank[i] = 0;\\n        }\\n        int minScore = Integer.MAX_VALUE;\\n        for (int[] road : roads) {\\n            createUnion(road[0], road[1]);\\n        }\\n        for (int[] road : roads) {\\n            int root1 = find(1);\\n            int rootX = find(road[0]);\\n            int rootY = find(road[1]);\\n            if (root1 == rootX && root1 == rootY) {\\n                minScore = Math.min(minScore, road[2]);\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.root = []\\n        self.rank = []\\n    \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def createUnion(self, x: int, y: int) -> None:\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX == rootY:\\n            return\\n        if self.rank[rootX] < self.rank[rootY]:\\n            self.root[rootX] = rootY\\n        elif self.rank[rootX] > self.rank[rootY]:\\n            self.root[rootY] = rootX\\n        else:\\n            self.root[rootY] = rootX\\n            self.rank[rootX] += 1\\n    \\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        self.root = [i for i in range(n + 1)]\\n        self.rank = [0] * (n + 1)\\n        minScore = float(\\'inf\\')\\n        for road in roads:\\n            self.createUnion(road[0], road[1])\\n        for road in roads:\\n            root1 = self.find(1)\\n            rootX = self.find(road[0])\\n            rootY = self.find(road[1])\\n            if root1 == rootX == rootY:\\n                minScore = min(minScore, road[2])\\n        return minScore\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity :\\n\\n1. The time complexity of the find() function is O(log n) in the worst case, where n is the number of vertices in the graph.\\n2. The time complexity of the createUnion() function is O(log n) in the worst case, where n is the number of vertices in the graph.\\n3. The time complexity of the initialization loop in step 9 is O(n).\\n4. The time complexity of the loop that calls createUnion() in step 11 is O(m log n), where m is the number of edges in the graph and n is the number of vertices.\\n5. The time complexity of the loop that checks the roots of the sets in step 12 is O(m log n), where m is the number of edges in the graph and n is the number of vertices.\\n6. **Therefore, the overall time complexity of the algorithm is O(m log n), where m is the number of edges in the graph and n is the number of vertices.**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : \\n\\nThe space complexity of the algorithm is **O(n)**, where n is the number of vertices in the graph. This is because we need to store the root and rank vectors, each of which has a size of n+1.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> root, rank;\\n    \\n    int find(int x){\\n        if(x == root[x])\\n            return root[x];\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        if(rank[rootX] < rank[rootY])\\n            root[rootX] = rootY;\\n        else if(rank[rootX] > rank[rootY])\\n            root[rootY] = rootX;\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        root.resize(n + 1);\\n        rank.resize(n + 1);\\n        for(int i = 0; i < n; i++){\\n            root[i] = i;\\n            rank[i] = 0;\\n        }\\n        int minScore = INT_MAX;\\n        for (auto road : roads) {\\n            createUnion(road[0], road[1]);\\n        }\\n        for (auto road : roads) {\\n            int root1 = find(1);\\n            int rootX = find(road[0]);\\n            int rootY = find(road[1]);\\n            if (root1 == rootX && root1 == rootY) {\\n                minScore = min(minScore, road[2]);\\n            }\\n        }\\n        return minScore;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private int[] root, rank;\\n    \\n    private int find(int x){\\n        if(x == root[x])\\n            return root[x];\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    private void createUnion(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX == rootY)\\n            return;\\n        if(rank[rootX] < rank[rootY])\\n            root[rootX] = rootY;\\n        else if(rank[rootX] > rank[rootY])\\n            root[rootY] = rootX;\\n        else{\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n        root = new int[n + 1];\\n        rank = new int[n + 1];\\n        for(int i = 0; i < n; i++){\\n            root[i] = i;\\n            rank[i] = 0;\\n        }\\n        int minScore = Integer.MAX_VALUE;\\n        for (int[] road : roads) {\\n            createUnion(road[0], road[1]);\\n        }\\n        for (int[] road : roads) {\\n            int root1 = find(1);\\n            int rootX = find(road[0]);\\n            int rootY = find(road[1]);\\n            if (root1 == rootX && root1 == rootY) {\\n                minScore = Math.min(minScore, road[2]);\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        self.root = []\\n        self.rank = []\\n    \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def createUnion(self, x: int, y: int) -> None:\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX == rootY:\\n            return\\n        if self.rank[rootX] < self.rank[rootY]:\\n            self.root[rootX] = rootY\\n        elif self.rank[rootX] > self.rank[rootY]:\\n            self.root[rootY] = rootX\\n        else:\\n            self.root[rootY] = rootX\\n            self.rank[rootX] += 1\\n    \\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        self.root = [i for i in range(n + 1)]\\n        self.rank = [0] * (n + 1)\\n        minScore = float(\\'inf\\')\\n        for road in roads:\\n            self.createUnion(road[0], road[1])\\n        for road in roads:\\n            root1 = self.find(1)\\n            rootX = self.find(road[0])\\n            rootY = self.find(road[1])\\n            if root1 == rootX == rootY:\\n                minScore = min(minScore, road[2])\\n        return minScore\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875087,
                "title": "union-find",
                "content": "\\n      class Solution:\\n        def minScore(self, n: int, roads: List[List[int]]) -> int:\\n            \\n            dp=list(range(n+1))\\n    \\n            def find(x):\\n                if dp[x]!=x:dp[x]=find(dp[x])\\n                return dp[x]\\n            \\n            cost=collections.defaultdict(lambda: float(\\'inf\\'))\\n            \\n            for i,j,k in roads:  \\n                i,j=find(i),find(j)                    \\n                cost[j]=min([cost[j],cost[i],k])\\n                dp[i]=dp[j]\\n                    \\n            return cost[find(1)]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n      class Solution:\\n        def minScore(self, n: int, roads: List[List[int]]) -> int:\\n            \\n            dp=list(range(n+1))\\n    \\n            def find(x):\\n                if dp[x]!=x:dp[x]=find(dp[x])\\n                return dp[x]\\n            \\n            cost=collections.defaultdict(lambda: float(\\'inf\\'))\\n            \\n            for i,j,k in roads:  \\n                i,j=find(i),find(j)                    \\n                cost[j]=min([cost[j],cost[i],k])\\n                dp[i]=dp[j]\\n                    \\n            return cost[find(1)]",
                "codeTag": "Java"
            },
            {
                "id": 3326669,
                "title": "javascript-bfs",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function (n, roads) {\\n  const graph = new Array(n + 1).fill().map(() => []);\\n  const visited = new Set([]);\\n\\n  for (const [v1, v2, distance] of roads) {\\n    graph[v1].push([v2, distance]);\\n    graph[v2].push([v1, distance]);\\n  }\\n\\n  const queue = [1];\\n  visited.add(1);\\n  let ans = Infinity;\\n\\n  while (queue.length > 0) {\\n    const node = queue.shift();\\n    for (const [next, distance] of graph[node]) {\\n      ans = Math.min(ans, distance);\\n      if (visited.has(next)) continue;\\n\\n      visited.add(next);\\n      queue.push(next);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function (n, roads) {\\n  const graph = new Array(n + 1).fill().map(() => []);\\n  const visited = new Set([]);\\n\\n  for (const [v1, v2, distance] of roads) {\\n    graph[v1].push([v2, distance]);\\n    graph[v2].push([v1, distance]);\\n  }\\n\\n  const queue = [1];\\n  visited.add(1);\\n  let ans = Infinity;\\n\\n  while (queue.length > 0) {\\n    const node = queue.shift();\\n    for (const [next, distance] of graph[node]) {\\n      ans = Math.min(ans, distance);\\n      if (visited.has(next)) continue;\\n\\n      visited.add(next);\\n      queue.push(next);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327102,
                "title": "try-ones-more-using-my-hints-easy-java-solution-using-dfs",
                "content": "# Hints\\n- Don\\'t go on language its a simple graph traversal Question.\\n- Use DFS or BFS.\\n- Simply Travers the graph starting from 1st node and store minimum distance between any two nodes.\\n- At the end just check if nth node is visited or not\\n    - If visited then return minimum distance\\n    - else return -1\\n\\n# Note \\n- You can use BFS also insted of DFS in below code.\\n\\n# Complexity\\n- Time complexity: $$O(V)$$ where V is total number of vertecis in Graph.\\n\\n- Space complexity: $$O(V)$$ where V is total number of vertecis in Graph.\\n\\n# Code\\n```\\nclass Solution {\\n    int min;\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<int[]>> graph = new ArrayList<>();\\n        for(int i = 0; i<n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i<roads.length; i++){\\n            graph.get(roads[i][0]-1).add(new int[]{roads[i][1]-1, roads[i][2]});\\n            graph.get(roads[i][1]-1).add(new int[]{roads[i][0]-1, roads[i][2]});\\n        }\\n        min = Integer.MAX_VALUE;\\n        boolean vis[] = new boolean[n];\\n        dfs(graph, vis, 0);\\n        if(vis[n-1]) return min;\\n        return -1;\\n    }\\n    private void dfs(ArrayList<ArrayList<int[]>> graph, boolean vis[], int s){\\n        if(vis[s]) return;\\n        vis[s] = true;\\n        for(int[] child : graph.get(s)){\\n            dfs(graph, vis, child[0]);\\n            min = Math.min(min, child[1]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int min;\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<int[]>> graph = new ArrayList<>();\\n        for(int i = 0; i<n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i<roads.length; i++){\\n            graph.get(roads[i][0]-1).add(new int[]{roads[i][1]-1, roads[i][2]});\\n            graph.get(roads[i][1]-1).add(new int[]{roads[i][0]-1, roads[i][2]});\\n        }\\n        min = Integer.MAX_VALUE;\\n        boolean vis[] = new boolean[n];\\n        dfs(graph, vis, 0);\\n        if(vis[n-1]) return min;\\n        return -1;\\n    }\\n    private void dfs(ArrayList<ArrayList<int[]>> graph, boolean vis[], int s){\\n        if(vis[s]) return;\\n        vis[s] = true;\\n        for(int[] child : graph.get(s)){\\n            dfs(graph, vis, child[0]);\\n            min = Math.min(min, child[1]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326933,
                "title": "c-clean-code-bfs-readable-code",
                "content": "# Complexity\\n- Time complexity:\\n```\\nO(N)\\n```\\n\\n- Space complexity:\\n```\\nO(N)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minScore(int n, vector<vector<int>>& rd) {\\n        vector<vector<int>> adj[n+1];\\n        for(auto a : rd){\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        queue<vector<int>> pq;\\n        int ans =1e8;\\n        vis[1]=1;\\n        pq.push({1,100000});\\n        while(!pq.empty()){\\n            int ct = pq.front()[0]; pq.pop();\\n            for(auto a : adj[ct]){\\n                ans = min(ans,a[1]);\\n                if(!vis[a[0]]){\\n                    vis[a[0]]=1;\\n                    pq.push({a[0],a[1]});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nO(N)\\n```\n```\\nO(N)\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minScore(int n, vector<vector<int>>& rd) {\\n        vector<vector<int>> adj[n+1];\\n        for(auto a : rd){\\n            adj[a[0]].push_back({a[1],a[2]});\\n            adj[a[1]].push_back({a[0],a[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        queue<vector<int>> pq;\\n        int ans =1e8;\\n        vis[1]=1;\\n        pq.push({1,100000});\\n        while(!pq.empty()){\\n            int ct = pq.front()[0]; pq.pop();\\n            for(auto a : adj[ct]){\\n                ans = min(ans,a[1]);\\n                if(!vis[a[0]]){\\n                    vis[a[0]]=1;\\n                    pq.push({a[0],a[1]});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326867,
                "title": "c-easy-solution-dfs-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFDFS Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n\\t//Depth First Seach function\\n    void dfs(int node,vector<vector<pair<int,int>>>&graph,vector<int>&vis,vector<int>&ans){\\n\\t//mark the node in the visited vector\\n        vis[node]=0;\\n\\t\\t//traverse through all the neighbouring nodes\\n        for(auto&child:graph[node]){\\n\\t\\t//if they are not visited yet\\n            if(vis[child.first]){\\n\\t\\t\\t//push node in ans vector;\\n                ans.push_back(child.first);\\n\\t\\t\\t\\t//dfs call for neighbours\\n                dfs(child.first,graph,vis,ans);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\t\\n        vector<vector<pair<int,int>>>graph(n);\\n\\t\\t//First we will create a graph with the given edges and weights\\n\\t\\t//by making graph a vector of vector of pair\\n\\t\\t\\n        for(auto&road:roads){\\n            \\n            graph[road[0]-1].push_back({road[1]-1,road[2]});\\n            graph[road[1]-1].push_back({road[0]-1,road[2]});\\n        }\\n\\t\\t//for the dfs we require a visited array so we created a vis vector\\n        vector<int>vis(n,1);\\n\\t\\t//we will store the visited nodes in ans vector;\\n        vector<int>ans;\\n\\t\\t\\n\\t\\t//we will call the dfs to find the visited nodes from node 0\\n        dfs(0,graph,vis,ans);\\n\\t\\t\\n\\t\\t//now we will find the minimum possible edge possible on the visited \\n\\t\\t//as we must have to include the  minimun weight edge\\n        int res=1e9;\\n        for(int i=0;i<ans.size();i++){\\n\\t\\t//Traversing through all the edges of node\\n            for(auto&child:graph[ans[i]]){\\n\\t\\t\\t//storing min in res\\n                res=min(res,child.second);\\n            }\\n        }\\n\\t\\t//returning the res\\n        return res;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//Depth First Seach function\\n    void dfs(int node,vector<vector<pair<int,int>>>&graph,vector<int>&vis,vector<int>&ans){\\n\\t//mark the node in the visited vector\\n        vis[node]=0;\\n\\t\\t//traverse through all the neighbouring nodes\\n        for(auto&child:graph[node]){\\n\\t\\t//if they are not visited yet\\n            if(vis[child.first]){\\n\\t\\t\\t//push node in ans vector;\\n                ans.push_back(child.first);\\n\\t\\t\\t\\t//dfs call for neighbours\\n                dfs(child.first,graph,vis,ans);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\t\\n        vector<vector<pair<int,int>>>graph(n);\\n\\t\\t//First we will create a graph with the given edges and weights\\n\\t\\t//by making graph a vector of vector of pair\\n\\t\\t\\n        for(auto&road:roads){\\n            \\n            graph[road[0]-1].push_back({road[1]-1,road[2]});\\n            graph[road[1]-1].push_back({road[0]-1,road[2]});\\n        }\\n\\t\\t//for the dfs we require a visited array so we created a vis vector\\n        vector<int>vis(n,1);\\n\\t\\t//we will store the visited nodes in ans vector;\\n        vector<int>ans;\\n\\t\\t\\n\\t\\t//we will call the dfs to find the visited nodes from node 0\\n        dfs(0,graph,vis,ans);\\n\\t\\t\\n\\t\\t//now we will find the minimum possible edge possible on the visited \\n\\t\\t//as we must have to include the  minimun weight edge\\n        int res=1e9;\\n        for(int i=0;i<ans.size();i++){\\n\\t\\t//Traversing through all the edges of node\\n            for(auto&child:graph[ans[i]]){\\n\\t\\t\\t//storing min in res\\n                res=min(res,child.second);\\n            }\\n        }\\n\\t\\t//returning the res\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328614,
                "title": "simple-c-solution-using-dijkstra-algorithm",
                "content": "***The reason to upload this solution was that I found many solutions with `DFS` and `BFS` approach in solutions and in editorial as well. So thought of sharing an alternate solution, in case someone tries to solve this by `Dijkstra Algorithm`. Hope it helps! \\uD83D\\uDE05***\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question can be thought to be similar to the basic dijkstra problem wherein we find the shortest path from one node to all other nodes. The only difference here is that instead of adding the distances in the path, we have to find the minimum of the edges in the path. So we have to make changes in the step wherein we push the distance to a particular node, in the priority queue. Basically we are just changing the defination of distance here.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will be using priority queue in our solution (to find the nearest node to the current node). We initialized our distance array with a large value (1e9 in this case) so that nodes always store the minimum possible value of reaching the node `n` from the current node. We created a 2D vector for storing edges from one node. `dist[0]` is initialized with `MAXN` for simplicity in further calulations (as the graph will always have more than 1 node, so this won\\'t affect our answer). Further, we push `-dist[node]` in the priority queue to get the nearest node. In the inner for loop, modification needs to be made as we want to store the minimum edge length in the path not the path length.\\n\\n# Complexity\\n- Time complexity: `O(e*log(n))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHere `n` is the number of nodes and `e` is the total number edges.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define MAXN 1e9\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> dist(n,MAXN);\\n        vector<pair<int,int>> edges[n];\\n        for(vector<int>& x:roads){\\n            edges[x[0]-1].push_back({x[1]-1,x[2]});\\n            edges[x[1]-1].push_back({x[0]-1,x[2]});\\n        }\\n        dist[0]=MAXN;\\n        pq.push({-MAXN,0});\\n        while(!pq.empty()){\\n            pair<int,int> v=pq.top();\\n            pq.pop();\\n            int u=v.second;\\n            int d=-v.first;\\n            for(pair<int,int> e:edges[u]){\\n                if(dist[e.first]>min(d,e.second)){\\n                    dist[e.first]=min(d,e.second);\\n                    pq.push({-dist[e.first],e.first});\\n                }\\n            }\\n        }\\n        return dist[n-1];\\n    }\\n};\\n```\\n\\n***Do upvote if you find it helpful! \\uD83D\\uDC4D***",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define MAXN 1e9\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> dist(n,MAXN);\\n        vector<pair<int,int>> edges[n];\\n        for(vector<int>& x:roads){\\n            edges[x[0]-1].push_back({x[1]-1,x[2]});\\n            edges[x[1]-1].push_back({x[0]-1,x[2]});\\n        }\\n        dist[0]=MAXN;\\n        pq.push({-MAXN,0});\\n        while(!pq.empty()){\\n            pair<int,int> v=pq.top();\\n            pq.pop();\\n            int u=v.second;\\n            int d=-v.first;\\n            for(pair<int,int> e:edges[u]){\\n                if(dist[e.first]>min(d,e.second)){\\n                    dist[e.first]=min(d,e.second);\\n                    pq.push({-dist[e.first],e.first});\\n                }\\n            }\\n        }\\n        return dist[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875369,
                "title": "incorrect-problem-description",
                "content": "![image](https://assets.leetcode.com/users/images/a7607a13-3e5d-415b-96b7-96df308a757a_1670128000.860611.png)\\n\\nI was thinking that, we can **visit only node 1 and node n multiple times** and i was solving problem in that direction but after contest, i saw the discuss then peoples have **solved by visiting node 1 to node n multiple times.**\\n\\nHere, they should have to write **cities 1 to n multiple times** instead of **cities 1 and n multiple times**.\\n\\n![image](https://assets.leetcode.com/users/images/59214ad3-9b83-41e5-a70b-1284b1507c6a_1670129863.818849.png)\\n\\nHere, answer should be 2, as we can\\'t visite node 2 multiple times. So that, ```1->2->4->2->1->3->5``` not possible (according to problem description).\\n\\nBut solution got which was visiting node 2 twice.\\n\\nNot fair.\\n",
                "solutionTags": [],
                "code": "```1->2->4->2->1->3->5```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326787,
                "title": "simplest-solution-disjoint-set-c",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n\\n# Code\\n```\\nclass DisjointSet{\\n    public:\\n    vector<int> parent, size;\\n    DisjointSet(int n){\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i = 1; i <= n; i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUlt(int node){\\n        if(node == parent[node]) return node;\\n        return parent[node] = findUlt(parent[node]);\\n    }\\n\\n    void findUnion(int u, int v){\\n        int paru = findUlt(u);\\n        int parv = findUlt(v);\\n        if(paru == parv) return;\\n        if(size[paru] > size[parv]){\\n            parent[parv] = paru;\\n            size[paru]++;\\n        }\\n        else if(size[paru] > size[parv]){\\n            parent[paru] = parv;\\n            size[parv]++;\\n        }\\n        else{\\n            parent[parv] = paru;\\n            size[paru]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DisjointSet ds(n);\\n        for(auto it : roads){\\n            ds.findUnion(it[0], it[1]);\\n        }\\n        int temp = ds.findUlt(1), ans = INT_MAX;\\n        for(auto it : roads){\\n            int ult_u = ds.findUlt(it[0]), ult_v = ds.findUlt(it[1]);\\n            if(ult_u == temp || ult_v == temp)\\n                ans = min(ans, it[2]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\n                   `Give a \\uD83D\\uDC4D. It motivates me alot`\\n```\\nLet\\'s Connect On [Linkedin]()",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```\\nclass DisjointSet{\\n    public:\\n    vector<int> parent, size;\\n    DisjointSet(int n){\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i = 1; i <= n; i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUlt(int node){\\n        if(node == parent[node]) return node;\\n        return parent[node] = findUlt(parent[node]);\\n    }\\n\\n    void findUnion(int u, int v){\\n        int paru = findUlt(u);\\n        int parv = findUlt(v);\\n        if(paru == parv) return;\\n        if(size[paru] > size[parv]){\\n            parent[parv] = paru;\\n            size[paru]++;\\n        }\\n        else if(size[paru] > size[parv]){\\n            parent[paru] = parv;\\n            size[parv]++;\\n        }\\n        else{\\n            parent[parv] = paru;\\n            size[paru]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DisjointSet ds(n);\\n        for(auto it : roads){\\n            ds.findUnion(it[0], it[1]);\\n        }\\n        int temp = ds.findUlt(1), ans = INT_MAX;\\n        for(auto it : roads){\\n            int ult_u = ds.findUlt(it[0]), ult_v = ds.findUlt(it[1]);\\n            if(ult_u == temp || ult_v == temp)\\n                ans = min(ans, it[2]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n                   `Give a \\uD83D\\uDC4D. It motivates me alot`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875788,
                "title": "c-very-simple-dfs-based-approach",
                "content": "I think the code is self-explanatory if you already know how to perform a Depth-first search traversal inside a connected component.\\n\\n```\\nclass Solution {\\nprivate:\\n    int dfs(int current, vector<bool> &visited, vector<vector<pair<int, int>>> &graph) {\\n        int minScore = INT_MAX;\\n        visited[current] = true;\\n        for(auto &[next, distance] : graph[current]) {\\n            minScore = min(minScore, distance);\\n            if(!visited[next]) {\\n                visited[next] = true;\\n                minScore = min(minScore, dfs(next, visited, graph));\\n            }\\n        }\\n        return minScore;\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // Step 1: create a graph from the network of roads\\n        vector<vector<pair<int, int>>> graph(n + 1);\\n        for(auto &road : roads) {\\n            graph[road[0]].emplace_back(road[1], road[2]);\\n            graph[road[1]].emplace_back(road[0], road[2]);\\n        }\\n        // Step 2: Perform a DFS starting from the city 1 and since it will have an edge \\n        // connecting the last city, you are darn sure that you just need to track the min edge-weight\\n        // inside the component connecting city 1 and city n\\n        vector<bool> visited(n + 1);\\n        return dfs(1, visited, graph);\\n    }\\n};\\n```\\n\\nThanks a lot for reading! ^_^\\n\\uD83D\\uDCAF An upvote would be appreciated.\\n\\uD83D\\uDC47 Comment down your doubts (if any).",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(int current, vector<bool> &visited, vector<vector<pair<int, int>>> &graph) {\\n        int minScore = INT_MAX;\\n        visited[current] = true;\\n        for(auto &[next, distance] : graph[current]) {\\n            minScore = min(minScore, distance);\\n            if(!visited[next]) {\\n                visited[next] = true;\\n                minScore = min(minScore, dfs(next, visited, graph));\\n            }\\n        }\\n        return minScore;\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // Step 1: create a graph from the network of roads\\n        vector<vector<pair<int, int>>> graph(n + 1);\\n        for(auto &road : roads) {\\n            graph[road[0]].emplace_back(road[1], road[2]);\\n            graph[road[1]].emplace_back(road[0], road[2]);\\n        }\\n        // Step 2: Perform a DFS starting from the city 1 and since it will have an edge \\n        // connecting the last city, you are darn sure that you just need to track the min edge-weight\\n        // inside the component connecting city 1 and city n\\n        vector<bool> visited(n + 1);\\n        return dfs(1, visited, graph);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874943,
                "title": "simple-c-bfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& r) {\\n        vector<pair<int, int>> g[n+1];\\n        vector<bool> vis(n+1, false);\\n        \\n        for(auto x: r){\\n            g[x[0]].push_back({x[1], x[2]});\\n            g[x[1]].push_back({x[0], x[2]});\\n        }\\n        \\n        queue<int> q;\\n        q.push(1);\\n        int ans = INT_MAX;\\n        \\n        while(q.size()){\\n            int t = q.front();\\n            q.pop();\\n            vis[t] = true;\\n            \\n            for(int i=0; i<g[t].size(); i++){\\n                ans = min(ans, g[t][i].second);\\n                int next = g[t][i].first;\\n                if(vis[next]) continue;\\n                else q.push(next);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& r) {\\n        vector<pair<int, int>> g[n+1];\\n        vector<bool> vis(n+1, false);\\n        \\n        for(auto x: r){\\n            g[x[0]].push_back({x[1], x[2]});\\n            g[x[1]].push_back({x[0], x[2]});\\n        }\\n        \\n        queue<int> q;\\n        q.push(1);\\n        int ans = INT_MAX;\\n        \\n        while(q.size()){\\n            int t = q.front();\\n            q.pop();\\n            vis[t] = true;\\n            \\n            for(int i=0; i<g[t].size(); i++){\\n                ans = min(ans, g[t][i].second);\\n                int next = g[t][i].first;\\n                if(vis[next]) continue;\\n                else q.push(next);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332309,
                "title": "bfs-and-dfs-approach",
                "content": "# 1. Breadth First Search\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        for src,dst,dis in roads:\\n            graph[src].append((dst,dis))\\n            graph[dst].append((src,dis))\\n        answer,q,visit=float(\\'inf\\'),deque([1]),set()\\n        while q:\\n            poping=q.popleft()\\n            for nei,dis in graph[poping]:\\n                if nei not in visit:\\n                    visit.add(nei)\\n                    q.append(nei)\\n                answer=min(answer,dis)\\n        return answer\\n\\n```\\n\\n# 2. Depth First Search\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=defaultdict(list)\\n        for src,dst,dis in roads:\\n            adj[src].append((dst,dis))\\n            adj[dst].append((src,dis))\\n        def dfs(i):\\n            if i in visit:\\n                return\\n            visit.add(i)\\n            nonlocal answer\\n            for nei,dis in adj[i]:\\n                answer=min(answer,dis)\\n                dfs(nei)\\n        visit,answer=set(),float(\\'inf\\')\\n        dfs(n)\\n        return answer\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        for src,dst,dis in roads:\\n            graph[src].append((dst,dis))\\n            graph[dst].append((src,dis))\\n        answer,q,visit=float(\\'inf\\'),deque([1]),set()\\n        while q:\\n            poping=q.popleft()\\n            for nei,dis in graph[poping]:\\n                if nei not in visit:\\n                    visit.add(nei)\\n                    q.append(nei)\\n                answer=min(answer,dis)\\n        return answer\\n\\n```\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=defaultdict(list)\\n        for src,dst,dis in roads:\\n            adj[src].append((dst,dis))\\n            adj[dst].append((src,dis))\\n        def dfs(i):\\n            if i in visit:\\n                return\\n            visit.add(i)\\n            nonlocal answer\\n            for nei,dis in adj[i]:\\n                answer=min(answer,dis)\\n                dfs(nei)\\n        visit,answer=set(),float(\\'inf\\')\\n        dfs(n)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326702,
                "title": "java-easy-solution-90-faster-code-using-dijikstra-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n  PLEASE UPVOTE\\n```\\nclass Solution {\\n    class Pair{\\n        int dest;\\n        int cost;\\n        Pair(int dest, int cost){\\n            this.dest = dest;\\n            this.cost = cost;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n        int m = roads.length;\\n        Queue<Pair> que = new ArrayDeque<>();\\n        int min = Integer.MAX_VALUE;\\n        \\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for(int i = 0; i < n + 1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        \\n        que.add(new Pair(1,Integer.MAX_VALUE));\\n        int[] visited = new int[n + 1];\\n         \\n        while(que.size() > 0){\\n            int dest = que.peek().dest;\\n            int cost = que.peek().cost;\\n            que.remove();\\n            min = Math.min(min,cost);\\n            if(visited[dest] == 0){\\n                   for(int i = 0; i < adj.get(dest).size(); i++){\\n                        int a = adj.get(dest).get(i).dest;\\n                        int b = adj.get(dest).get(i).cost;\\n                        que.add(new Pair(a,b));\\n                    }\\n            }\\n            visited[dest] = 1;\\n         \\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int dest;\\n        int cost;\\n        Pair(int dest, int cost){\\n            this.dest = dest;\\n            this.cost = cost;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n        int m = roads.length;\\n        Queue<Pair> que = new ArrayDeque<>();\\n        int min = Integer.MAX_VALUE;\\n        \\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for(int i = 0; i < n + 1; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        \\n        que.add(new Pair(1,Integer.MAX_VALUE));\\n        int[] visited = new int[n + 1];\\n         \\n        while(que.size() > 0){\\n            int dest = que.peek().dest;\\n            int cost = que.peek().cost;\\n            que.remove();\\n            min = Math.min(min,cost);\\n            if(visited[dest] == 0){\\n                   for(int i = 0; i < adj.get(dest).size(); i++){\\n                        int a = adj.get(dest).get(i).dest;\\n                        int b = adj.get(dest).get(i).cost;\\n                        que.add(new Pair(a,b));\\n                    }\\n            }\\n            visited[dest] = 1;\\n         \\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937093,
                "title": "union-find-vs-dfs",
                "content": "A benefit of the union-find approach is that we do not need to build an adjacency list first. So it should be a bit easier on memory.\\n\\n## Union-Find\\nIf you can reach city `i` from city `1`, you can travel any road from/to city `i`.\\n\\nSo, we find all cities that we can reach from city `1`, check all roads connected to those cities, and pick the shortest one.\\n\\nWe can use union-find to find all reachable cities. Instead of weight, we can store the smallest distance (as a negative) for each group of cities.\\n\\n**C++**\\n```cpp\\nint ds[500001];\\nint find(int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i]);\\n}\\nint minScore(int n, vector<vector<int>>& roads) {\\n    fill_n(begin(ds), n + 1, INT_MIN);\\n    for (auto &r : roads) {\\n        int i = find(r[0]), j = find(r[1]);\\n        if (i != j) {\\n            ds[i] = max(ds[i], ds[j]);\\n            ds[j] = i;\\n        }\\n        ds[i] = max(ds[i], -r[2]);\\n    }\\n    return -ds[find(1)];\\n}\\n```\\n\\n## DFS\\nPopulate an adjacency list and do DFS.\\n\\n**C++**\\n```cpp\\nint dfs(int i, int dist, vector<vector<pair<int, int>>> &al, vector<bool> &vis) {\\n    if (!vis[i]) {\\n        vis[i] = true;\\n        for (auto [j, j_dist] : al[i])\\n            dist = min(dist, dfs(j, j_dist, al, vis));\\n    }\\n    return dist;\\n}\\nint minScore(int n, vector<vector<int>>& roads) {\\n    vector<vector<pair<int, int>>> al(n + 1);\\n    for (auto &r : roads) {\\n        al[r[0]].push_back({r[1], r[2]});\\n        al[r[1]].push_back({r[0], r[2]});\\n    }\\n    return dfs(1, INT_MAX, al, vector<bool>(n + 1) = {});\\n}   \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint ds[500001];\\nint find(int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i]);\\n}\\nint minScore(int n, vector<vector<int>>& roads) {\\n    fill_n(begin(ds), n + 1, INT_MIN);\\n    for (auto &r : roads) {\\n        int i = find(r[0]), j = find(r[1]);\\n        if (i != j) {\\n            ds[i] = max(ds[i], ds[j]);\\n            ds[j] = i;\\n        }\\n        ds[i] = max(ds[i], -r[2]);\\n    }\\n    return -ds[find(1)];\\n}\\n```\n```cpp\\nint dfs(int i, int dist, vector<vector<pair<int, int>>> &al, vector<bool> &vis) {\\n    if (!vis[i]) {\\n        vis[i] = true;\\n        for (auto [j, j_dist] : al[i])\\n            dist = min(dist, dfs(j, j_dist, al, vis));\\n    }\\n    return dist;\\n}\\nint minScore(int n, vector<vector<int>>& roads) {\\n    vector<vector<pair<int, int>>> al(n + 1);\\n    for (auto &r : roads) {\\n        al[r[0]].push_back({r[1], r[2]});\\n        al[r[1]].push_back({r[0], r[2]});\\n    }\\n    return dfs(1, INT_MAX, al, vector<bool>(n + 1) = {});\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2878221,
                "title": "python-3-13-lines-w-explanation-and-example-t-m-192ms-63-9-mb",
                "content": "Here\\'s the plan:\\n* Because nodes  `n` and `1` are connected, we can proceed as if we were given a connected graph, and our answer is the minimum `distance` on that connected graph. (I was tempted to use *union-find*, but there\\'s no need to sort out all the connected graphs, we just need to sort out the one with nodes  nodes  `n` and `1`.)\\n\\n\\n* If ensure we only visit nodes exactly once in the connected graph (using `seen`), we can proceed as if we were given a tree with 1 as the root.\\n* With all that in mind, the problem reduces to finding the minimum `distance` for all edges in that tree.\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n\\n        graph, dists = defaultdict(list),defaultdict(set)\\n        ans, seen = set(), {1}\\n                                                        #  Example: roads = [[1,2,2], [1,3,4], [3,4,7], [3,2,5]]\\n                                                        #                ___1___\\n                                                        #          (4)  /       \\\\   (2)\\n                                                        #              3 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 2\\n                                                        #          (7)  \\\\   (5)\\n                                                        #                4\\n        for a, b, dist in roads:                        # \\n            graph[a].append(b) ; dists[a].add(dist)     #      graph = {1:[2,3], 2:[1,3], 3:[1,4,2], 4:[3]}\\n            graph[b].append(a) ; dists[b].add(dist)     #      dists = {1:{2,4}, 2:{2}, 3:{4,5,7}, 4:{7}}\\n\\n        def dfs(node = 1) -> None:                      #       node    graph[node]   seen        ans\\n            nonlocal seen, ans                          #       \\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\n                                                        #         1      [2,3]        {1}         {2,4}\\n            seen.add(node)                              #         2       [1]        {1,2}       {2,4,5}\\n            ans |= set(dists[node])                     #         3      [1,4]      {1,2,3}     {2,4,5,7}\\n                                                        #         4       [3]      {1,2,3,4}    {2,4,5,7}\\n            for n in graph[node]:                       #                                        |   \\n                if n not in seen: dfs(n)                #                                    return 2\\n\\n        dfs()\\n\\n        return min(ans) \\n```\\n[https://leetcode.com/submissions/detail/854628329/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n\\n        graph, dists = defaultdict(list),defaultdict(set)\\n        ans, seen = set(), {1}\\n                                                        #  Example: roads = [[1,2,2], [1,3,4], [3,4,7], [3,2,5]]\\n                                                        #                ___1___\\n                                                        #          (4)  /       \\\\   (2)\\n                                                        #              3 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 2\\n                                                        #          (7)  \\\\   (5)\\n                                                        #                4\\n        for a, b, dist in roads:                        # \\n            graph[a].append(b) ; dists[a].add(dist)     #      graph = {1:[2,3], 2:[1,3], 3:[1,4,2], 4:[3]}\\n            graph[b].append(a) ; dists[b].add(dist)     #      dists = {1:{2,4}, 2:{2}, 3:{4,5,7}, 4:{7}}\\n\\n        def dfs(node = 1) -> None:                      #       node    graph[node]   seen        ans\\n            nonlocal seen, ans                          #       \\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\n                                                        #         1      [2,3]        {1}         {2,4}\\n            seen.add(node)                              #         2       [1]        {1,2}       {2,4,5}\\n            ans |= set(dists[node])                     #         3      [1,4]      {1,2,3}     {2,4,5,7}\\n                                                        #         4       [3]      {1,2,3,4}    {2,4,5,7}\\n            for n in graph[node]:                       #                                        |   \\n                if n not in seen: dfs(n)                #                                    return 2\\n\\n        dfs()\\n\\n        return min(ans) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875078,
                "title": "java-most-easiest-solution-without-dfs-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI Used A Simplest Logic to Solve this\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {  \\n        Arrays.sort(roads, (a, b)->{\\n            return a[0] - b[0];\\n        });\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(roads[0][0]);\\n        set.add(roads[0][1]);\\n        int min = roads[0][2];\\n        for(int j = 0; j < 100; j++){\\n            for(int i = 1; i < roads.length; i++){\\n            if(set.contains(roads[i][0]) || set.contains(roads[i][1])){\\n                min = Math.min(roads[i][2], min);\\n                set.add(roads[i][0]);\\n                set.add(roads[i][1]);\\n            }\\n        }\\n        }        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {  \\n        Arrays.sort(roads, (a, b)->{\\n            return a[0] - b[0];\\n        });\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(roads[0][0]);\\n        set.add(roads[0][1]);\\n        int min = roads[0][2];\\n        for(int j = 0; j < 100; j++){\\n            for(int i = 1; i < roads.length; i++){\\n            if(set.contains(roads[i][0]) || set.contains(roads[i][1])){\\n                min = Math.min(roads[i][2], min);\\n                set.add(roads[i][0]);\\n                set.add(roads[i][1]);\\n            }\\n        }\\n        }        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874940,
                "title": "dfs-cpp-with-explanation",
                "content": "**Intution :** \\n* Our task is finding min weighted edge in graph that includes both `1` and `n` nodes.\\n* That\\'s why we apply dfs on node 1 and traverse all the graph and find out min weighted edge.\\n* In question gives the one condition  : There is at least one path between 1 and n, That\\'s why guaranteed node `n` is included.\\n\\n\\n```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<pii>>& g, vector<bool>& vis, int u) {\\n        vis[u] = true;\\n        int ans = INT_MAX;\\n        for(auto [v, w] : g[u]) {\\n            ans = min(ans, w);   \\n            if(!vis[v]) ans = min(dfs(g, vis, v), ans);\\n        }\\n        return ans;\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pii>> g(n+1);\\n        for(auto r : roads) {\\n            int u = r[0], v = r[1], w = r[2];\\n            g[u].push_back({v, w});\\n            g[v].push_back({u, w});\\n        }\\n        \\n        vector<bool> vis(n+1, false);\\n        \\n        return dfs(g, vis, 1);\\n    }\\n};\\n```\\n\\n \\uD83D\\uDE4F  **Please Upvote...**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<vector<pii>>& g, vector<bool>& vis, int u) {\\n        vis[u] = true;\\n        int ans = INT_MAX;\\n        for(auto [v, w] : g[u]) {\\n            ans = min(ans, w);   \\n            if(!vis[v]) ans = min(dfs(g, vis, v), ans);\\n        }\\n        return ans;\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pii>> g(n+1);\\n        for(auto r : roads) {\\n            int u = r[0], v = r[1], w = r[2];\\n            g[u].push_back({v, w});\\n            g[v].push_back({u, w});\\n        }\\n        \\n        vector<bool> vis(n+1, false);\\n        \\n        return dfs(g, vis, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329163,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int, unordered_map<int, int>> graph;\\n        for (auto& road : roads) {\\n            int u = road[0], v = road[1], w = road[2];\\n            graph[u][v] = graph[v][u] = w;\\n        }\\n        \\n        int res = numeric_limits<int>::max();\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            for (auto& [adj, score] : graph[node]) {\\n                if (!visited.count(adj)) {\\n                    q.push(adj);\\n                    visited.insert(adj);\\n                }\\n                res = min(res, score);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int, unordered_map<int, int>> graph;\\n        for (auto& road : roads) {\\n            int u = road[0], v = road[1], w = road[2];\\n            graph[u][v] = graph[v][u] = w;\\n        }\\n        \\n        int res = numeric_limits<int>::max();\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            for (auto& [adj, score] : graph[node]) {\\n                if (!visited.count(adj)) {\\n                    q.push(adj);\\n                    visited.insert(adj);\\n                }\\n                res = min(res, score);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327183,
                "title": "simple-dfs-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can see that we can get min. path by simple dfs traversal of the graph. Just keep on storing min. weights while traversing.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we create a adjacency list for given edges. It will look something like this for example-1:\\n\\n4->(2, 5) (1, 7)\\n3->(2, 6) \\n2->(1, 9) (3, 6) (4, 5) \\n1->(2, 9) (4, 7) \\n\\nNow we will just call dfs for node-1(city-1) because if we know that 1 and n are connected so we will find our min path by this component only any other disconnected component will not contribute to our answer.\\n\\nWhile traversing just keep updating our answer by min(ans, curr node\\'s weight). We need to update it even if node is visited.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V + E)\\n (V -> Vertices, E -> Edges)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V + E)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node, unordered_map<int, list<pair<int, int>>> &adj, vector<bool> &vis, int &mini){\\n        vis[node] = 1;\\n        for(auto i:adj[node]){\\n            if(!vis[i.first]){\\n                mini = min(mini, i.second);\\n                dfs(i.first, adj, vis, mini);\\n            }\\n            else{\\n                mini = min(mini, i.second);\\n            }\\n        }\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n        unordered_map<int, list<pair<int, int>>> adj;\\n\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n\\n            pair<int, int> p1 = {u, w};\\n            pair<int, int> p2 = {v, w};\\n\\n            adj[u].push_back(p2);\\n            adj[v].push_back(p1);\\n        }\\n\\n        vector<bool> vis(n + 1, 0);\\n        int mini = INT_MAX;\\n        \\n        dfs(1, adj, vis, mini);\\n\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node, unordered_map<int, list<pair<int, int>>> &adj, vector<bool> &vis, int &mini){\\n        vis[node] = 1;\\n        for(auto i:adj[node]){\\n            if(!vis[i.first]){\\n                mini = min(mini, i.second);\\n                dfs(i.first, adj, vis, mini);\\n            }\\n            else{\\n                mini = min(mini, i.second);\\n            }\\n        }\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n        unordered_map<int, list<pair<int, int>>> adj;\\n\\n        for(int i = 0; i < roads.size(); i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            int w = roads[i][2];\\n\\n            pair<int, int> p1 = {u, w};\\n            pair<int, int> p2 = {v, w};\\n\\n            adj[u].push_back(p2);\\n            adj[v].push_back(p1);\\n        }\\n\\n        vector<bool> vis(n + 1, 0);\\n        int mini = INT_MAX;\\n        \\n        dfs(1, adj, vis, mini);\\n\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326675,
                "title": "kotlin-simply-find-reachable-nodes-cheapest-edge",
                "content": "Thank you for upvoting\\n\\n```\\nclass Solution {\\n  fun minScore(n: Int, roads: Array<IntArray>): Int {\\n    val g = List(n + 1) {mutableListOf<Pair<Int, Int>>()}\\n    for ((a, b, c) in roads) {\\n      g[a].add(Pair(b, c))\\n      g[b].add(Pair(a, c))\\n    }\\n    val reachable = BooleanArray(n + 1)\\n    fun dfs(node: Int) {\\n      if (reachable[node]) return\\n      reachable[node] = true\\n      for ((next, _) in g[node])\\n        dfs(next)\\n    }\\n    dfs(1)\\n    var res = Int.MAX_VALUE\\n    for (i in 1..n)\\n      if (reachable[i]) for ((_, cost) in g[i]) res = minOf(res, cost)\\n    return res\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  fun minScore(n: Int, roads: Array<IntArray>): Int {\\n    val g = List(n + 1) {mutableListOf<Pair<Int, Int>>()}\\n    for ((a, b, c) in roads) {\\n      g[a].add(Pair(b, c))\\n      g[b].add(Pair(a, c))\\n    }\\n    val reachable = BooleanArray(n + 1)\\n    fun dfs(node: Int) {\\n      if (reachable[node]) return\\n      reachable[node] = true\\n      for ((next, _) in g[node])\\n        dfs(next)\\n    }\\n    dfs(1)\\n    var res = Int.MAX_VALUE\\n    for (i in 1..n)\\n      if (reachable[i]) for ((_, cost) in g[i]) res = minOf(res, cost)\\n    return res\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875571,
                "title": "c-solution-simple-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n-> Find **adjacency list**;\\n-> Make a **DFS** call from **1**;\\n\\n# Complexity\\n- Time complexity:\\n  O(V+E)\\n\\n- Space complexity:\\n  O(N);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>> > adj;\\n        for(auto p:roads){\\n            int u=p[0];\\n            int v=p[1];\\n            int wt=p[2];\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        int mindist=INT_MAX;\\n        vector<int> vis(n+1,0);\\n        dfs(1,n,adj,mindist,vis);\\n        return mindist;\\n    }\\n    void dfs(int u,int n,unordered_map<int,vector<pair<int,int>> > &adj, int &mindist,vector<int> &vis){\\n        vis[u]=1;\\n        for(auto p:adj[u]){\\n            int v=p.first;\\n            int wt=p.second;\\n            mindist=min(mindist, wt);\\n            if(!vis[v]){\\n                dfs(v,n,adj, mindist,vis);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>> > adj;\\n        for(auto p:roads){\\n            int u=p[0];\\n            int v=p[1];\\n            int wt=p[2];\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        int mindist=INT_MAX;\\n        vector<int> vis(n+1,0);\\n        dfs(1,n,adj,mindist,vis);\\n        return mindist;\\n    }\\n    void dfs(int u,int n,unordered_map<int,vector<pair<int,int>> > &adj, int &mindist,vector<int> &vis){\\n        vis[u]=1;\\n        for(auto p:adj[u]){\\n            int v=p.first;\\n            int wt=p.second;\\n            mindist=min(mindist, wt);\\n            if(!vis[v]){\\n                dfs(v,n,adj, mindist,vis);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874941,
                "title": "smallest-road-in-connected-component",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def DFS(self, graph, i, v):\\n        for j, d in graph[i]:\\n            if j not in v:\\n                v.add(j)\\n                self.DFS(graph, j, v)\\n    \\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        res = float(\\'inf\\')\\n        graph = defaultdict(set)\\n        for a, b, d in roads:\\n            graph[a].add((b, d))\\n            graph[b].add((a, d))\\n        v = {1}\\n        self.DFS(graph, 1, v)\\n        for a, b, d in roads:\\n            if a in v and b in v:\\n                res = min(res, d)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def DFS(self, graph, i, v):\\n        for j, d in graph[i]:\\n            if j not in v:\\n                v.add(j)\\n                self.DFS(graph, j, v)\\n    \\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        res = float(\\'inf\\')\\n        graph = defaultdict(set)\\n        for a, b, d in roads:\\n            graph[a].add((b, d))\\n            graph[b].add((a, d))\\n        v = {1}\\n        self.DFS(graph, 1, v)\\n        for a, b, d in roads:\\n            if a in v and b in v:\\n                res = min(res, d)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328101,
                "title": "python-short-and-clean-dfs",
                "content": "# Approach\\nNotice that we can visit `nodes` and `edges` multiple times. This reduces the problem into finding the shortest path in the connected subgraph containing the node `1`.\\n\\nUse good old `DFS` to find the `min_dist` recursively. Make sure to mark the nodes as `seen | visited` as there can be cycles.\\n\\n# Complexity\\n- Time complexity: $$O(n + e)$$\\n\\n- Space complexity: $$O(n + e)$$\\n\\nwhere,\\n`n is the number of nodes`,\\n`e is the number of edges`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minScore(self, n: int, roads: list[list[int]]) -> int:\\n        T = Hashable\\n        Dist = int | float\\n        Graph = Mapping[T, Mapping[T, Dist]]\\n\\n        def min_dist(graph: Graph, u: T, seen: set[T]) -> Dist:\\n            return (seen.add(u) or min(\\n                min(d, min_dist(graph, v, seen))\\n                for v, d in graph[u].items()\\n            )) if u not in seen else inf\\n        \\n        \\n        g = defaultdict(dict)\\n        for u, v, d in roads: g[u][v] = g[v][u] = d\\n        \\n        return min_dist(g, 1, set())\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```python\\nclass Solution:\\n    def minScore(self, n: int, roads: list[list[int]]) -> int:\\n        T = Hashable\\n        Dist = int | float\\n        Graph = Mapping[T, Mapping[T, Dist]]\\n\\n        def min_dist(graph: Graph, u: T, seen: set[T]) -> Dist:\\n            return (seen.add(u) or min(\\n                min(d, min_dist(graph, v, seen))\\n                for v, d in graph[u].items()\\n            )) if u not in seen else inf\\n        \\n        \\n        g = defaultdict(dict)\\n        for u, v, d in roads: g[u][v] = g[v][u] = d\\n        \\n        return min_dist(g, 1, set())\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327732,
                "title": "graph-c-easy-to-understand-short-sweet-code",
                "content": "````\\nclass Solution {\\npublic:\\n    void solve(int s,int &ans,vector<vector<vector<int>>> &g,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            ans = min(ans,i[1]);\\n            solve(i[0],ans,g,v);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(auto &i: roads){\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<bool> v(n+1,false);\\n        solve(1,ans,g,v);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void solve(int s,int &ans,vector<vector<vector<int>>> &g,vector<bool> &v){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            ans = min(ans,i[1]);\\n            solve(i[0],ans,g,v);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(auto &i: roads){\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<bool> v(n+1,false);\\n        solve(1,ans,g,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327497,
                "title": "c-java-and-typescript-solution-with-approach",
                "content": "# \\u2B06\\uFE0FLike|\\uD83C\\uDFAFShare|\\u2B50Favourite\\n\\n\\n```CSharp []\\npublic class Solution \\n{\\n    public int MinScore(int n, int[][] roads) \\n    {\\n        var graph = new Dictionary<int, Dictionary<int, int>>();\\n        foreach (var road in roads)\\n        {\\n            if (!graph.ContainsKey(road[0]))\\n            {\\n                graph.Add(road[0], new Dictionary<int, int>());\\n            }\\n\\n            if (!graph.ContainsKey(road[1]))\\n            {\\n                graph.Add(road[1], new Dictionary<int, int>());\\n            }\\n            graph[road[0]].Add(road[1], road[2]);\\n            graph[road[1]].Add(road[0], road[2]);\\n        }\\n        var minScore = int.MaxValue;\\n        var visited = new HashSet<int>();\\n        var queue = new Queue<int>();\\n        queue.Enqueue(1);\\n        while (queue.Count > 0)\\n        {\\n            var node = queue.Dequeue();\\n            foreach (var adj in graph[node].Keys)\\n            {\\n                if (!visited.Contains(adj))\\n                {\\n                    queue.Enqueue(adj);\\n                    visited.Add(adj);\\n                }\\n                minScore = Math.Min(minScore, graph[node][adj]);\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n```\\n```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            if (!graph.containsKey(road[0])) {\\n                graph.put(road[0], new HashMap<>());\\n            }\\n            if (!graph.containsKey(road[1])) {\\n                graph.put(road[1], new HashMap<>());\\n            }\\n            graph.get(road[0]).put(road[1], road[2]);\\n            graph.get(road[1]).put(road[0], road[2]);\\n        }\\n        int minScore = Integer.MAX_VALUE;\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(1);\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n            for (int adj : graph.get(node).keySet()) {\\n                if (!visited.contains(adj)) {\\n                    queue.offer(adj);\\n                    visited.add(adj);\\n                }\\n                minScore = Math.min(minScore, graph.get(node).get(adj));\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n```\\n```TypeScript []\\nfunction minScore(n: number, roads: number[][]): number {\\n    const graph = new Map<number, Map<number, number>>();\\n    for (const road of roads) {\\n        if (!graph.has(road[0])) {\\n            graph.set(road[0], new Map<number, number>());\\n        }\\n        if (!graph.has(road[1])) {\\n            graph.set(road[1], new Map<number, number>());\\n        }\\n        graph.get(road[0]).set(road[1], road[2]);\\n        graph.get(road[1]).set(road[0], road[2]);\\n    }\\n    let minScore = Number.MAX_SAFE_INTEGER;\\n    const visited = new Set<number>();\\n    const queue = new Array<number>();\\n    queue.push(1);\\n    while (queue.length > 0) {\\n        const node = queue.shift();\\n        for (const adj of graph.get(node).keys()) {\\n            if (!visited.has(adj)) {\\n                queue.push(adj);\\n                visited.add(adj);\\n            }\\n            minScore = Math.min(minScore, graph.get(node).get(adj));\\n        }\\n    }\\n    return minScore;\\n};\\n```\\n\\n\\n# Approach\\n1. Create a graph with the given roads.\\n2. Perform a BFS traversal from node 1.\\n3. For each node, find the minimum score of the adjacent nodes.\\n4. Return the minimum score.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2). We need to traverse the entire graph.\\n\\n- Space complexity:\\nO(n^2). We need to store the graph.",
                "solutionTags": [
                    "Java",
                    "C#",
                    "TypeScript",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```CSharp []\\npublic class Solution \\n{\\n    public int MinScore(int n, int[][] roads) \\n    {\\n        var graph = new Dictionary<int, Dictionary<int, int>>();\\n        foreach (var road in roads)\\n        {\\n            if (!graph.ContainsKey(road[0]))\\n            {\\n                graph.Add(road[0], new Dictionary<int, int>());\\n            }\\n\\n            if (!graph.ContainsKey(road[1]))\\n            {\\n                graph.Add(road[1], new Dictionary<int, int>());\\n            }\\n            graph[road[0]].Add(road[1], road[2]);\\n            graph[road[1]].Add(road[0], road[2]);\\n        }\\n        var minScore = int.MaxValue;\\n        var visited = new HashSet<int>();\\n        var queue = new Queue<int>();\\n        queue.Enqueue(1);\\n        while (queue.Count > 0)\\n        {\\n            var node = queue.Dequeue();\\n            foreach (var adj in graph[node].Keys)\\n            {\\n                if (!visited.Contains(adj))\\n                {\\n                    queue.Enqueue(adj);\\n                    visited.Add(adj);\\n                }\\n                minScore = Math.Min(minScore, graph[node][adj]);\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n```\n```Java []\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        Map<Integer, Map<Integer, Integer>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            if (!graph.containsKey(road[0])) {\\n                graph.put(road[0], new HashMap<>());\\n            }\\n            if (!graph.containsKey(road[1])) {\\n                graph.put(road[1], new HashMap<>());\\n            }\\n            graph.get(road[0]).put(road[1], road[2]);\\n            graph.get(road[1]).put(road[0], road[2]);\\n        }\\n        int minScore = Integer.MAX_VALUE;\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(1);\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n            for (int adj : graph.get(node).keySet()) {\\n                if (!visited.contains(adj)) {\\n                    queue.offer(adj);\\n                    visited.add(adj);\\n                }\\n                minScore = Math.min(minScore, graph.get(node).get(adj));\\n            }\\n        }\\n        return minScore;\\n    }\\n}\\n```\n```TypeScript []\\nfunction minScore(n: number, roads: number[][]): number {\\n    const graph = new Map<number, Map<number, number>>();\\n    for (const road of roads) {\\n        if (!graph.has(road[0])) {\\n            graph.set(road[0], new Map<number, number>());\\n        }\\n        if (!graph.has(road[1])) {\\n            graph.set(road[1], new Map<number, number>());\\n        }\\n        graph.get(road[0]).set(road[1], road[2]);\\n        graph.get(road[1]).set(road[0], road[2]);\\n    }\\n    let minScore = Number.MAX_SAFE_INTEGER;\\n    const visited = new Set<number>();\\n    const queue = new Array<number>();\\n    queue.push(1);\\n    while (queue.length > 0) {\\n        const node = queue.shift();\\n        for (const adj of graph.get(node).keys()) {\\n            if (!visited.has(adj)) {\\n                queue.push(adj);\\n                visited.add(adj);\\n            }\\n            minScore = Math.min(minScore, graph.get(node).get(adj));\\n        }\\n    }\\n    return minScore;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327263,
                "title": "solution-using-dsu-beats-100-space-and-100-runtime",
                "content": "# Intuition\\nThe ans will be the minimum weight edge in component containing 1 and n.\\n\\n# Approach\\nsimply add minimum array(let it be m) to dsu class.Where m[i] will denote minimum weight of the component i if i is parent, when we add a new edge [a,b,weight] and take i (it may be a or b decide by size) as parent node relation will be - m[i]=min(m[a],m[b],weight)\\n\\n# Complexity\\n- Time complexity:\\no(e+n)\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass dsu:\\n    def __init__(self,n):\\n        self.size=[1]*(n+1)\\n        self.parent=[x for x in range(n+1)]\\n        self.m=[float(\"inf\") for x in range(n+1)]\\n    def find(self,x):\\n        if x==self.parent[x]:\\n            return x\\n        self.parent[x]=dsu.find(self,self.parent[x])\\n        return self.parent[x]\\n    def f(self):\\n        return self.m[dsu.find(self,1)]\\n    def union(self,u,v,w):\\n        x=dsu.find(self,u)\\n        y=dsu.find(self,v)\\n        if x==y:\\n            self.m[x]=min(self.m[x],w)\\n            return\\n        elif self.size[x]>self.size[y]:\\n            self.size[x]+=self.size[y]\\n            self.parent[y]=x\\n            self.m[x]=min(self.m[x],w,self.m[y])\\n        else:\\n            self.size[y]+=self.size[x]\\n            self.parent[x]=y\\n            self.m[y]=min(self.m[y],w,self.m[x])\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        d=dsu(n)\\n        for i in range(len(roads)):\\n            d.union(roads[i][0],roads[i][1],roads[i][2])\\n        return d.f()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass dsu:\\n    def __init__(self,n):\\n        self.size=[1]*(n+1)\\n        self.parent=[x for x in range(n+1)]\\n        self.m=[float(\"inf\") for x in range(n+1)]\\n    def find(self,x):\\n        if x==self.parent[x]:\\n            return x\\n        self.parent[x]=dsu.find(self,self.parent[x])\\n        return self.parent[x]\\n    def f(self):\\n        return self.m[dsu.find(self,1)]\\n    def union(self,u,v,w):\\n        x=dsu.find(self,u)\\n        y=dsu.find(self,v)\\n        if x==y:\\n            self.m[x]=min(self.m[x],w)\\n            return\\n        elif self.size[x]>self.size[y]:\\n            self.size[x]+=self.size[y]\\n            self.parent[y]=x\\n            self.m[x]=min(self.m[x],w,self.m[y])\\n        else:\\n            self.size[y]+=self.size[x]\\n            self.parent[x]=y\\n            self.m[y]=min(self.m[y],w,self.m[x])\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        d=dsu(n)\\n        for i in range(len(roads)):\\n            d.union(roads[i][0],roads[i][1],roads[i][2])\\n        return d.f()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326823,
                "title": "c-explanation-simple-bfs-beats-100",
                "content": "# Intuition\\nSince we need to find the path between 1 and n we can think of bfs and dfs and now as to why bfs works is in approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe need to find minimum distance between 2 cities which occur in the path from node 1 to node n.\\nNow it is stated that the graph may not be connected but you need not worry about that since node 1 and node n are always connected.\\nAnother problem you might think with bfs that it only finds shortest part but here we traverse all the nodes which can be reached by node 1 and find minium distance between 2 cities.\\nNow you might wonder that why are we doing this.\\nQuestion doesn\\'t ask us to find the overall minimum path. It has just asked what is the minimum distance between cities that could form a path from 1-n.\\nFor example:-\\nour optimal path is 1-4-7 but distance is 5,7 \\nbut we first go to 1-2 whose distance is 2 and return back to 1 and than use 1-4-7.\\nThis is also a viable path and minimum distance is 2.\\nHopefully you would have understood the why bfs works.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(V+E)$$\\nV is number of vertices\\nE is number of edges\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>>>adj; //creating adjacency list\\n        int ans=INT_MAX; //creating answer variable\\n        for(auto i:roads) //putting values in adjacency list\\n        {\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>vis(n+1); //creating visited array\\n        queue<int> q; // quque required for bfs\\n        q.push(1); \\n        vis[1] = 1;\\n        while(!q.empty()) // bfs loop\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for(auto i:adj[node])\\n            {\\n                ans=min(ans,i.second);\\n                if(vis[i.first]!=1)\\n                {\\n                    vis[i.first]=1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>>>adj; //creating adjacency list\\n        int ans=INT_MAX; //creating answer variable\\n        for(auto i:roads) //putting values in adjacency list\\n        {\\n            adj[i[0]].push_back({i[1],i[2]});\\n            adj[i[1]].push_back({i[0],i[2]});\\n        }\\n        vector<int>vis(n+1); //creating visited array\\n        queue<int> q; // quque required for bfs\\n        q.push(1); \\n        vis[1] = 1;\\n        while(!q.empty()) // bfs loop\\n        {\\n            int node=q.front();\\n            q.pop();\\n            for(auto i:adj[node])\\n            {\\n                ans=min(ans,i.second);\\n                if(vis[i.first]!=1)\\n                {\\n                    vis[i.first]=1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326722,
                "title": "union-find-path-compression",
                "content": "pretty standard union find, just need to add path compression to avoid TLE \\n\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        root = [i for i in range(n+1)]\\n\\n        def find(a):\\n            if root[a] == a:\\n                return a\\n            root[a] = find(root[a]) # path compression  \\n            return root[a]\\n\\n        def union(a, b):\\n            a = find(a)\\n            b = find(b)\\n            root[a] = b\\n\\n        for a, b, _ in roads:\\n            union(a,b)\\n\\n        return min(d for a,b,d in roads if find(n) == find(a))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        root = [i for i in range(n+1)]\\n\\n        def find(a):\\n            if root[a] == a:\\n                return a\\n            root[a] = find(root[a]) # path compression  \\n            return root[a]\\n\\n        def union(a, b):\\n            a = find(a)\\n            b = find(b)\\n            root[a] = b\\n\\n        for a, b, _ in roads:\\n            union(a,b)\\n\\n        return min(d for a,b,d in roads if find(n) == find(a))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326634,
                "title": "java-dfs-simple-and-clean-code-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is guaranteed to be some path between cities 1 and n. We don\\'t need to care about cities that are not connected with 1 and n. We can start with city 1 and run a DFS search, visit every connected city and keep track of the minimum distance between any 2 cities. We can always traverse the road with the minimum distance on our way from city 1 to n.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int[]>[] adj;\\n  boolean[] seen;\\n  int min = Integer.MAX_VALUE;\\n\\n  private void dfs(int city) {\\n    if (seen[city]) return;\\n    seen[city] = true;\\n\\n    for (var neighbor : adj[city]) {\\n      min = Math.min(min, neighbor[1]);\\n      dfs(neighbor[0]);\\n    }\\n  }\\n  \\n  public int minScore(int n, int[][] roads) {\\n    seen = new boolean[n];\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var road : roads) {\\n      adj[road[0] - 1].add(new int[] {road[1] - 1, road[2]});\\n      adj[road[1] - 1].add(new int[] {road[0] - 1, road[2]});\\n    }\\n    dfs(0);\\n    return min;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  List<int[]>[] adj;\\n  boolean[] seen;\\n  int min = Integer.MAX_VALUE;\\n\\n  private void dfs(int city) {\\n    if (seen[city]) return;\\n    seen[city] = true;\\n\\n    for (var neighbor : adj[city]) {\\n      min = Math.min(min, neighbor[1]);\\n      dfs(neighbor[0]);\\n    }\\n  }\\n  \\n  public int minScore(int n, int[][] roads) {\\n    seen = new boolean[n];\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var road : roads) {\\n      adj[road[0] - 1].add(new int[] {road[1] - 1, road[2]});\\n      adj[road[1] - 1].add(new int[] {road[0] - 1, road[2]});\\n    }\\n    dfs(0);\\n    return min;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875768,
                "title": "simple-solution-using-dfs-and-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically we need to return the minimum weighted edge in the graph and it is also said that there will definitely lie a path from edge 1 to n. So if the graph consists of two or more components and minimum exists in other components where the component doesn\\'t lie in the path of 1 to n.Simply returning minimum of the weights won\\'t work.We can use dfs to mark all the nodes and find the minimum among them only.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is simple we need to perform dfs with source as 1 and marks all nodes True and keep track of minimum . In this solution I created my own graph to make the work easier . Though the space complexity is little high but the solution is fast and efficient\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime required for our graph creation is O(V).DFS takes time complexity of O(V+E). Time complexity is O(2V+E) .The optimized time complexity is O(V+E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFor storing the graph we need O(V+E) space and we create a lst to store weight i.e. O(V) . Hence the total space complexity is O(V+E)\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph = [[] for i in range(n+1)]\\n        visited = [False for i in range(n+1)]\\n        for i in roads:\\n            graph[i[0]].append(tuple(i[1:]))\\n            graph[i[1]].append((i[0],i[2]))\\n        print(graph)\\n        lst = []\\n        def dfs(visited,graph,source,lst):\\n            visited[source]=True\\n            for i in graph[source]:\\n                lst.append(i[-1])\\n                if visited[i[0]]==False:\\n                    dfs(visited,graph,i[0],lst)\\n        dfs(visited,graph,1,lst)\\n        return min(lst)\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        graph = [[] for i in range(n+1)]\\n        visited = [False for i in range(n+1)]\\n        for i in roads:\\n            graph[i[0]].append(tuple(i[1:]))\\n            graph[i[1]].append((i[0],i[2]))\\n        print(graph)\\n        lst = []\\n        def dfs(visited,graph,source,lst):\\n            visited[source]=True\\n            for i in graph[source]:\\n                lst.append(i[-1])\\n                if visited[i[0]]==False:\\n                    dfs(visited,graph,i[0],lst)\\n        dfs(visited,graph,1,lst)\\n        return min(lst)\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875363,
                "title": "c-simple-dfs-easy-o-n",
                "content": "```C++\\nclass Solution {\\npublic:\\n    unordered_set<int> s;\\n    unordered_map<int, vector<int>> mp;\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        for(auto& r:roads) {\\n            mp[r[0]].push_back(r[1]);\\n            mp[r[1]].push_back(r[0]);\\n        }\\n        dfs(1);\\n        //the set s is the connected vertice with 1 and n now.\\n        \\n        //find out the minimum edge in connected vertice that including 1 & n;\\n        int ans = INT_MAX;\\n        for(auto& r:roads) {\\n            if(s.find(r[0]) != s.end()) {\\n                ans = min(ans, r[2]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    void dfs(int root) {\\n        if(s.find(root) != s.end()) return;\\n        s.insert(root);\\n        for(auto&child : mp[root]) {\\n            dfs(child);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    unordered_set<int> s;\\n    unordered_map<int, vector<int>> mp;\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        for(auto& r:roads) {\\n            mp[r[0]].push_back(r[1]);\\n            mp[r[1]].push_back(r[0]);\\n        }\\n        dfs(1);\\n        //the set s is the connected vertice with 1 and n now.\\n        \\n        //find out the minimum edge in connected vertice that including 1 & n;\\n        int ans = INT_MAX;\\n        for(auto& r:roads) {\\n            if(s.find(r[0]) != s.end()) {\\n                ans = min(ans, r[2]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    void dfs(int root) {\\n        if(s.find(root) != s.end()) return;\\n        s.insert(root);\\n        for(auto&child : mp[root]) {\\n            dfs(child);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875094,
                "title": "python-dfs-video-solution",
                "content": "I have explained the solution in this [video](https://www.youtube.com/watch?v=lLc-TGF3YPc).\\n\\nWe just have to go through all the roads, for our connected component `1->n` and find the min. road.\\n\\nWe can keep a **visited** set on **node**. But we still have to consider any **roads** leading to a seen node for our answer.\\n\\n**Time:** `O(n + E)` where `n` is the number of cities, and `E` is the number of roads.\\n\\n**Space:**\\n`O(n)` Heap Memory for our visited set \\n`O(n)` Recursive Stack Memory\\n\\n\\nIf this was helpful, please upvote, like the video and subscribe to the channel.\\n\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        m = defaultdict(list)\\n        \\n        for a,b,dist in roads:\\n            m[a].append([b, dist])\\n            m[b].append([a, dist])\\n            \\n        res = [math.inf]\\n        \\n        visit = set()\\n        \\n        def dfs(node):\\n            \\n            visit.add(node)\\n            \\n            for nei, cost in m[node]:\\n                res[0] = min(res[0], cost)\\n                \\n                if nei in visit:\\n                    continue\\n                dfs(nei)\\n                \\n        dfs(1)\\n        \\n        return res[0]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "I have explained the solution in this [video](https://www.youtube.com/watch?v=lLc-TGF3YPc).\\n\\nWe just have to go through all the roads, for our connected component `1->n` and find the min. road.\\n\\nWe can keep a **visited** set on **node**. But we still have to consider any **roads** leading to a seen node for our answer.\\n\\n**Time:** `O(n + E)` where `n` is the number of cities, and `E` is the number of roads.\\n\\n**Space:**\\n`O(n)` Heap Memory for our visited set \\n`O(n)` Recursive Stack Memory\\n\\n\\nIf this was helpful, please upvote, like the video and subscribe to the channel.\\n\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        m = defaultdict(list)\\n        \\n        for a,b,dist in roads:\\n            m[a].append([b, dist])\\n            m[b].append([a, dist])\\n            \\n        res = [math.inf]\\n        \\n        visit = set()\\n        \\n        def dfs(node):\\n            \\n            visit.add(node)\\n            \\n            for nei, cost in m[node]:\\n                res[0] = min(res[0], cost)\\n                \\n                if nei in visit:\\n                    continue\\n                dfs(nei)\\n                \\n        dfs(1)\\n        \\n        return res[0]",
                "codeTag": "Java"
            },
            {
                "id": 2875015,
                "title": "python-queue-bfs",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\ndef minScore(n: int, roads: list[list[int]]) -> int:\\n    graph = {}\\n    for i, j, k in roads:\\n        if i in graph:\\n            graph[i].add((j, k))\\n        else:\\n            graph[i] = {(j, k)}\\n        if j in graph:\\n            graph[j].add((i, k))\\n        else:\\n            graph[j] = {(i, k)}\\n\\n    q = deque()\\n    for i in graph[1]:\\n        q.append([1, i[0], i[1]])\\n    minPath = float(\"inf\")\\n    isVisited = n == 1\\n    visited = {1}\\n    while q:\\n        currNode, nextNode, dist = q.popleft()\\n        if nextNode == n:\\n            isVisited = True\\n        minPath = min(minPath, dist)\\n        if nextNode in visited:\\n            continue\\n        visited.add(nextNode)\\n        for nextnextNode, val in graph[nextNode]:\\n            q.append([nextnextNode, nextNode, val])\\n    return minPath if isVisited else -1\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\ndef minScore(n: int, roads: list[list[int]]) -> int:\\n    graph = {}\\n    for i, j, k in roads:\\n        if i in graph:\\n            graph[i].add((j, k))\\n        else:\\n            graph[i] = {(j, k)}\\n        if j in graph:\\n            graph[j].add((i, k))\\n        else:\\n            graph[j] = {(i, k)}\\n\\n    q = deque()\\n    for i in graph[1]:\\n        q.append([1, i[0], i[1]])\\n    minPath = float(\"inf\")\\n    isVisited = n == 1\\n    visited = {1}\\n    while q:\\n        currNode, nextNode, dist = q.popleft()\\n        if nextNode == n:\\n            isVisited = True\\n        minPath = min(minPath, dist)\\n        if nextNode in visited:\\n            continue\\n        visited.add(nextNode)\\n        for nextnextNode, val in graph[nextNode]:\\n            q.append([nextnextNode, nextNode, val])\\n    return minPath if isVisited else -1\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2874974,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int> &vis,vector<pair<int,int>> adj[],int &ans){\\n        vis[node] = 1;\\n        for(auto x : adj[node]){\\n            ans = min(ans,x.second);\\n        }\\n        for(auto x : adj[node]){\\n            if(vis[x.first]==0){\\n                dfs(x.first,vis,adj,ans);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for(auto it : roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        int ans=INT_MAX;\\n        dfs(1,vis,adj,ans);\\n        if(vis[1]==1 && vis[n]==1) {return ans;}\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int> &vis,vector<pair<int,int>> adj[],int &ans){\\n        vis[node] = 1;\\n        for(auto x : adj[node]){\\n            ans = min(ans,x.second);\\n        }\\n        for(auto x : adj[node]){\\n            if(vis[x.first]==0){\\n                dfs(x.first,vis,adj,ans);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for(auto it : roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        int ans=INT_MAX;\\n        dfs(1,vis,adj,ans);\\n        if(vis[1]==1 && vis[n]==1) {return ans;}\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874944,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public int minEdge;\\n    public int minScore(int n, int[][] roads) {\\n        this.minEdge = Integer.MAX_VALUE;\\n        Map<Integer, List<Node>> graph = constructGraph(roads);\\n        dfs(graph, 1, new HashSet<>(), n);\\n        return this.minEdge;\\n    }\\n    public class Node {\\n        public int nodeValue;\\n        public int edgeValue;\\n        public Node(int nodeValue, int edgeValue) {\\n            this.nodeValue = nodeValue;\\n            this.edgeValue = edgeValue;\\n        }\\n    }\\n    public Map<Integer, List<Node>> constructGraph(int[][] roads) {\\n        Map<Integer, List<Node>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            int start = road[0];\\n            int end = road[1];\\n            int edgeValue = road[2];\\n            List<Node> startList;\\n            if (graph.containsKey(start)) {\\n                startList = graph.get(start);\\n            } else {\\n                startList = new ArrayList<>();\\n            }\\n            startList.add(new Node(end, edgeValue));\\n            graph.put(start, startList);\\n            List<Node> endList;\\n            if (graph.containsKey(end)) {\\n                endList = graph.get(end);\\n            } else {\\n                endList = new ArrayList<>();\\n            }\\n            endList.add(new Node(start, edgeValue));\\n            graph.put(end, endList);\\n        }\\n        return graph;\\n    }\\n    public void dfs(Map<Integer, List<Node>> graph, int currentNode, Set<Integer> visited, int endValue) {\\n        if (currentNode == endValue || visited.contains(currentNode) || !graph.containsKey(currentNode)) {\\n            return;\\n        }\\n        visited.add(currentNode);\\n        List<Node> neighbors = graph.get(currentNode);\\n        for (Node node : neighbors) {\\n            this.minEdge = Math.min(this.minEdge, node.edgeValue);\\n            dfs(graph, node.nodeValue, visited, endValue);\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minEdge;\\n    public int minScore(int n, int[][] roads) {\\n        this.minEdge = Integer.MAX_VALUE;\\n        Map<Integer, List<Node>> graph = constructGraph(roads);\\n        dfs(graph, 1, new HashSet<>(), n);\\n        return this.minEdge;\\n    }\\n    public class Node {\\n        public int nodeValue;\\n        public int edgeValue;\\n        public Node(int nodeValue, int edgeValue) {\\n            this.nodeValue = nodeValue;\\n            this.edgeValue = edgeValue;\\n        }\\n    }\\n    public Map<Integer, List<Node>> constructGraph(int[][] roads) {\\n        Map<Integer, List<Node>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            int start = road[0];\\n            int end = road[1];\\n            int edgeValue = road[2];\\n            List<Node> startList;\\n            if (graph.containsKey(start)) {\\n                startList = graph.get(start);\\n            } else {\\n                startList = new ArrayList<>();\\n            }\\n            startList.add(new Node(end, edgeValue));\\n            graph.put(start, startList);\\n            List<Node> endList;\\n            if (graph.containsKey(end)) {\\n                endList = graph.get(end);\\n            } else {\\n                endList = new ArrayList<>();\\n            }\\n            endList.add(new Node(start, edgeValue));\\n            graph.put(end, endList);\\n        }\\n        return graph;\\n    }\\n    public void dfs(Map<Integer, List<Node>> graph, int currentNode, Set<Integer> visited, int endValue) {\\n        if (currentNode == endValue || visited.contains(currentNode) || !graph.containsKey(currentNode)) {\\n            return;\\n        }\\n        visited.add(currentNode);\\n        List<Node> neighbors = graph.get(currentNode);\\n        for (Node node : neighbors) {\\n            this.minEdge = Math.min(this.minEdge, node.edgeValue);\\n            dfs(graph, node.nodeValue, visited, endValue);\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333354,
                "title": "c-dfs-o-n-e",
                "content": "# Intuition\\nSince nodes 1 and n are in the same connected component, the minimum possible score of a path from 1 to n will be the minimum edge weight in that component.\\n\\n# Approach\\nRun a DFS/BFS for the component containing node 1 and find out the minimum edge weight. That will be our answer.\\n\\n# Complexity\\n- Time complexity: O(n+e) [n:number of cities, e:roads]\\n\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mini=1e9;\\n    void dfs(int node, vector<pair<int,int>> graph[], vector<int>& vis){\\n        vis[node]=1;\\n        for(auto child:graph[node]){\\n            int child_n = child.first;\\n            int child_w = child.second;\\n\\n            mini = min(mini, child_w);\\n            if(vis[child_n]) continue;\\n            \\n            dfs(child_n, graph, vis);\\n        }\\n        return;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> graph[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            graph[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        //Since node 1 and n is in the same component\\n        vector<int> vis(n+1,0);\\n        dfs(1, graph, vis);\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mini=1e9;\\n    void dfs(int node, vector<pair<int,int>> graph[], vector<int>& vis){\\n        vis[node]=1;\\n        for(auto child:graph[node]){\\n            int child_n = child.first;\\n            int child_w = child.second;\\n\\n            mini = min(mini, child_w);\\n            if(vis[child_n]) continue;\\n            \\n            dfs(child_n, graph, vis);\\n        }\\n        return;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> graph[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            graph[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        //Since node 1 and n is in the same component\\n        vector<int> vis(n+1,0);\\n        dfs(1, graph, vis);\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332899,
                "title": "easy-clear-solution-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=[]\\n        related=set()\\n        for i in range(n+1):\\n            adj.append([])\\n        for i in roads:\\n            adj[i[0]].append(i[1])\\n            adj[i[1]].append(i[0])\\n        def dfs(node:int):\\n            related.add(node)\\n            for i in adj[node]:\\n                if i not in related:\\n                    dfs(i)\\n        dfs(1)\\n        dfs(n)\\n        res=10000\\n        for i in roads:\\n            if i[0] in related and i[1] in related:\\n                res=min(res,i[2])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=[]\\n        related=set()\\n        for i in range(n+1):\\n            adj.append([])\\n        for i in roads:\\n            adj[i[0]].append(i[1])\\n            adj[i[1]].append(i[0])\\n        def dfs(node:int):\\n            related.add(node)\\n            for i in adj[node]:\\n                if i not in related:\\n                    dfs(i)\\n        dfs(1)\\n        dfs(n)\\n        res=10000\\n        for i in roads:\\n            if i[0] in related and i[1] in related:\\n                res=min(res,i[2])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330262,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Dijkstra\\n\\n# Code\\n```\\n#define pii pair<int, int>\\n#define maxn 100005\\n#define inf 1000000007\\nclass Solution {\\npublic:\\n    vector<pii>g[maxn];\\n    int dis[maxn];\\n    void dijkstra(int s, int n) {\\n        priority_queue<pii, vector<pii>, greater<pii>> q;\\n        for(int i=0; i<=n; i++) dis[i] = inf;\\n        q.push({inf, s});\\n        while(!q.empty()) {\\n            int u = q.top().second;\\n            q.pop();\\n            for(int i=0; i<g[u].size(); i++) {\\n                int v = g[u][i].first;\\n                int w = g[u][i].second;\\n                if(min(dis[u], w) < dis[v]) {\\n                    dis[v] = min(dis[u], w);\\n                    q.push({dis[v], v});\\n                }\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        for(auto x: roads) {\\n            int u = x[0];\\n            int v = x[1];\\n            int w = x[2];\\n            g[u].push_back({v, w});\\n            g[v].push_back({u, w});\\n        }\\n        dijkstra(1, n);\\n        return dis[n]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pii pair<int, int>\\n#define maxn 100005\\n#define inf 1000000007\\nclass Solution {\\npublic:\\n    vector<pii>g[maxn];\\n    int dis[maxn];\\n    void dijkstra(int s, int n) {\\n        priority_queue<pii, vector<pii>, greater<pii>> q;\\n        for(int i=0; i<=n; i++) dis[i] = inf;\\n        q.push({inf, s});\\n        while(!q.empty()) {\\n            int u = q.top().second;\\n            q.pop();\\n            for(int i=0; i<g[u].size(); i++) {\\n                int v = g[u][i].first;\\n                int w = g[u][i].second;\\n                if(min(dis[u], w) < dis[v]) {\\n                    dis[v] = min(dis[u], w);\\n                    q.push({dis[v], v});\\n                }\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        for(auto x: roads) {\\n            int u = x[0];\\n            int v = x[1];\\n            int w = x[2];\\n            g[u].push_back({v, w});\\n            g[v].push_back({u, w});\\n        }\\n        dijkstra(1, n);\\n        return dis[n]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329538,
                "title": "python-simple-python-solution-using-graph",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1771 ms, faster than 69.46% of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\n# Memory Usage: 66.6 MB, less than 69.13% of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\n\\n\\tclass Solution:\\n\\t\\tdef minScore(self, n: int, roads: List[List[int]]) -> int:\\n\\n\\t\\t\\tgraph = collections.defaultdict(list)\\n\\n\\t\\t\\tfor source, destination , distance in roads:\\n\\n\\t\\t\\t\\tgraph[source].append([destination , distance])\\n\\t\\t\\t\\tgraph[destination].append([source , distance])\\n\\n\\t\\t\\tresult = 10000\\n\\n\\t\\t\\tstack = graph.pop(1)\\n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tcurrent_city, distance = stack.pop()\\n\\n\\t\\t\\t\\tresult = min(result, distance)\\n\\n\\t\\t\\t\\tif current_city in graph:\\n\\t\\t\\t\\t\\tstack.extand(graph.pop(current_city))\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1771 ms, faster than 69.46% of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\n# Memory Usage: 66.6 MB, less than 69.13% of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\n\\n\\tclass Solution:\\n\\t\\tdef minScore(self, n: int, roads: List[List[int]]) -> int:\\n\\n\\t\\t\\tgraph = collections.defaultdict(list)\\n\\n\\t\\t\\tfor source, destination , distance in roads:\\n\\n\\t\\t\\t\\tgraph[source].append([destination , distance])\\n\\t\\t\\t\\tgraph[destination].append([source , distance])\\n\\n\\t\\t\\tresult = 10000\\n\\n\\t\\t\\tstack = graph.pop(1)\\n\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tcurrent_city, distance = stack.pop()\\n\\n\\t\\t\\t\\tresult = min(result, distance)\\n\\n\\t\\t\\t\\tif current_city in graph:\\n\\t\\t\\t\\t\\tstack.extand(graph.pop(current_city))\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3328691,
                "title": "java-clean-bfs-and-dfs-solutions",
                "content": "# Intuition:\\n*Traverse the graph starting from vertex $$1$$ and get the minimum distance between two cities (minimum edge weight).*\\n\\n---\\n### Case of disconnected cities:\\nIf you were thinking of running a for loop on `roads` and get the minimum distance then that won\\'t work \\uD83D\\uDE06.\\n\\n![image.png](https://assets.leetcode.com/users/images/b584e0bf-0c90-488c-99d6-2b7a0d59162d_1679490960.7636707.png)\\n\\n### So a graph traversal is the way, starting from $$1$$.\\n\\n---\\n# DFS solution:\\n```\\nclass Solution {\\n    private List<int[]>[] adj;\\n    private int score = 10001;\\n    private boolean[] vis;\\n    public int minScore(int n, int[][] roads) {\\n        adj = new List[n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] r : roads) {\\n            adj[r[0]].add(new int[] {r[1], r[2]});\\n            adj[r[1]].add(new int[] {r[0], r[2]});\\n        }\\n\\n        vis = new boolean[n + 1];\\n        vis[1] = true;\\n\\n        dfs(1);\\n        return score;\\n    }\\n\\n    private void dfs(int curr) {\\n        for (int[] nei : adj[curr]) {\\n            int next = nei[0], dist = nei[1];\\n            score = Math.min(score, dist);\\n            if (!vis[next]) {\\n                vis[next] = true;\\n                dfs(next);\\n            }\\n        }\\n    }\\n}\\n```\\n##### Time complexity: $$O(n + e)$$\\n##### Space complexity: $$O(n + e) + O(n)$$\\n---\\n# 2. BFS solution:\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<int[]>[] adj = new List[n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] r : roads) {\\n            adj[r[0]].add(new int[] {r[1], r[2]});\\n            adj[r[1]].add(new int[] {r[0], r[2]});\\n        }\\n\\n        boolean[] vis = new boolean[n + 1];\\n        vis[1] = true;\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(1);\\n        int score = 10001;\\n\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();\\n            for (int[] nei : adj[curr]) {\\n                int next = nei[0], dist = nei[1];\\n                score = Math.min(score, dist);\\n                if (!vis[next]) {\\n                    vis[next] = true;\\n                    q.offer(next);\\n                }\\n            }\\n        }\\n\\n        return score;\\n    }\\n}\\n```\\n##### Time complexity: $$O(n + e)$$\\n##### Space complexity: $$O(n + e) + O(2.n)$$",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    private List<int[]>[] adj;\\n    private int score = 10001;\\n    private boolean[] vis;\\n    public int minScore(int n, int[][] roads) {\\n        adj = new List[n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] r : roads) {\\n            adj[r[0]].add(new int[] {r[1], r[2]});\\n            adj[r[1]].add(new int[] {r[0], r[2]});\\n        }\\n\\n        vis = new boolean[n + 1];\\n        vis[1] = true;\\n\\n        dfs(1);\\n        return score;\\n    }\\n\\n    private void dfs(int curr) {\\n        for (int[] nei : adj[curr]) {\\n            int next = nei[0], dist = nei[1];\\n            score = Math.min(score, dist);\\n            if (!vis[next]) {\\n                vis[next] = true;\\n                dfs(next);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<int[]>[] adj = new List[n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] r : roads) {\\n            adj[r[0]].add(new int[] {r[1], r[2]});\\n            adj[r[1]].add(new int[] {r[0], r[2]});\\n        }\\n\\n        boolean[] vis = new boolean[n + 1];\\n        vis[1] = true;\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(1);\\n        int score = 10001;\\n\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();\\n            for (int[] nei : adj[curr]) {\\n                int next = nei[0], dist = nei[1];\\n                score = Math.min(score, dist);\\n                if (!vis[next]) {\\n                    vis[next] = true;\\n                    q.offer(next);\\n                }\\n            }\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328398,
                "title": "cake-walk-beats-88-time-and-80-memory",
                "content": "# Intuition\\nIn the question it is given that **It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.**\\nso i thought of just traversing through the roads array and then find the minimum of all the distances but that gave me **wrong answer** as graph is disconnected and there may be paths were we can\\'t even reach. So i just use dfs and traverse from all the node connected from node 1 and n  \\n\\n\\n# Approach\\nfirst i created an adjacency list and then i created a visited array and run dfs function from node 1 and mark all the connected nodes as visited and then i check for the minimum distance in the roads array who are connected with node 1 and n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &v,int i,vector<int> &visited){\\n        visited[i]=true;\\n        for(auto node:v[i]){\\n            if(!visited[node]){\\n                dfs(v,node,visited);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans=INT_MAX;\\n        vector<vector<int>> v(n+1);\\n        for(int i=0;i<roads.size();i++){\\n            v[roads[i][0]].push_back(roads[i][1]);\\n            v[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        vector<int> visited(n+1,false);\\n        dfs(v,1,visited);\\n        for(int i=0;i<roads.size();i++){\\n            if(visited[roads[i][0]] || visited[roads[i][1]])\\n                ans=min(ans,roads[i][2]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &v,int i,vector<int> &visited){\\n        visited[i]=true;\\n        for(auto node:v[i]){\\n            if(!visited[node]){\\n                dfs(v,node,visited);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans=INT_MAX;\\n        vector<vector<int>> v(n+1);\\n        for(int i=0;i<roads.size();i++){\\n            v[roads[i][0]].push_back(roads[i][1]);\\n            v[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        vector<int> visited(n+1,false);\\n        dfs(v,1,visited);\\n        for(int i=0;i<roads.size();i++){\\n            if(visited[roads[i][0]] || visited[roads[i][1]])\\n                ans=min(ans,roads[i][2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328096,
                "title": "easy-java-solution-dijkstra-s-algorithm-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can apply Dijkstra\\'s Algorithm here to find distance between 2 node. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can apply Dijkstra Algorithm here to find distance between 2 node and after each node we will comapre minimum disatnce and return minimum.\\n\\n**In Code, I wrote everything in comment which is needed to understand this problem.**\\n\\n**\"Please Look At Once In Code. You Will Definitely Understand.\"**\\n\\n# Complexity\\n- Time complexity: O(E*logE)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    class Pair{\\n        int distance;\\n        int node;\\n\\n        Pair(int distance, int node)\\n        {\\n            this.distance = distance;\\n            this.node = node;\\n        }\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n\\n        //Priority Queue will help us to get minimum value at the top.\\n        PriorityQueue<Pair> pq = new PriorityQueue<Pair>((x,y) -> x.distance - y.distance);\\n\\n        //Intialize min variable.\\n        int min = Integer.MAX_VALUE;\\n\\n        ArrayList<ArrayList<Pair>> ar = new ArrayList<>();\\n\\n        //Making space in adjecency arraylist\\n        for(int i=0;i<n+1;i++)\\n        {\\n            ar.add(new ArrayList<>());\\n        }\\n\\n        //filling 2D roads values into adjecency arraylist which we made.\\n        for(int i=0;i<roads.length;i++)\\n        {\\n            //storing value of distance and node in adjecency list with pair class.\\n            //like a -> {dis, b};\\n            //like b -> {dis, a};\\n            ar.get(roads[i][0]).add(new Pair(roads[i][2], roads[i][1]));\\n            ar.get(roads[i][1]).add(new Pair(roads[i][2], roads[i][0]));\\n        }\\n\\n        //Initialize value for Priority Queue to MAX from 1 to n+1.\\n        pq.add(new Pair(Integer.MAX_VALUE,1));\\n\\n        //Create visited array to identify a particular node is already visited or not.\\n        int[] visited = new int[n+1];\\n\\n        //Iterate priority queue and store value according to distance of particular node.\\n        while(pq.size() > 0)\\n        {\\n            //Getting distance and node for each entry.\\n            int distance = pq.peek().distance;\\n            int node = pq.peek().node;\\n\\n            //Removing element after fetch distance and node.\\n            pq.remove();\\n\\n            //Getting minimum distance in min varaible.\\n            min = Math.min(min, distance);\\n\\n            //Now we check that if we visited node earlier or not.\\n            // \"if condition\" is for not visited.\\n            if(visited[node] == 0)\\n            {\\n                //Iterate adjecency list.\\n                for(int i=0;i<ar.get(node).size();i++)\\n                {\\n                    //Getting distance and for particular node\\n                    int a = ar.get(node).get(i).distance;\\n                    int b = ar.get(node).get(i).node;\\n\\n                    pq.add(new Pair(a,b)); \\n                }\\n            }\\n\\n            visited[node] = 1;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```\\n**Please Upvote, if you understand the problem by this solution !!!**\\n\\n![download.jfif](https://assets.leetcode.com/users/images/85bd7027-fe3e-4c05-b8b8-2ecd1ce5fd2e_1679478821.0124345.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n\\n    class Pair{\\n        int distance;\\n        int node;\\n\\n        Pair(int distance, int node)\\n        {\\n            this.distance = distance;\\n            this.node = node;\\n        }\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n\\n        //Priority Queue will help us to get minimum value at the top.\\n        PriorityQueue<Pair> pq = new PriorityQueue<Pair>((x,y) -> x.distance - y.distance);\\n\\n        //Intialize min variable.\\n        int min = Integer.MAX_VALUE;\\n\\n        ArrayList<ArrayList<Pair>> ar = new ArrayList<>();\\n\\n        //Making space in adjecency arraylist\\n        for(int i=0;i<n+1;i++)\\n        {\\n            ar.add(new ArrayList<>());\\n        }\\n\\n        //filling 2D roads values into adjecency arraylist which we made.\\n        for(int i=0;i<roads.length;i++)\\n        {\\n            //storing value of distance and node in adjecency list with pair class.\\n            //like a -> {dis, b};\\n            //like b -> {dis, a};\\n            ar.get(roads[i][0]).add(new Pair(roads[i][2], roads[i][1]));\\n            ar.get(roads[i][1]).add(new Pair(roads[i][2], roads[i][0]));\\n        }\\n\\n        //Initialize value for Priority Queue to MAX from 1 to n+1.\\n        pq.add(new Pair(Integer.MAX_VALUE,1));\\n\\n        //Create visited array to identify a particular node is already visited or not.\\n        int[] visited = new int[n+1];\\n\\n        //Iterate priority queue and store value according to distance of particular node.\\n        while(pq.size() > 0)\\n        {\\n            //Getting distance and node for each entry.\\n            int distance = pq.peek().distance;\\n            int node = pq.peek().node;\\n\\n            //Removing element after fetch distance and node.\\n            pq.remove();\\n\\n            //Getting minimum distance in min varaible.\\n            min = Math.min(min, distance);\\n\\n            //Now we check that if we visited node earlier or not.\\n            // \"if condition\" is for not visited.\\n            if(visited[node] == 0)\\n            {\\n                //Iterate adjecency list.\\n                for(int i=0;i<ar.get(node).size();i++)\\n                {\\n                    //Getting distance and for particular node\\n                    int a = ar.get(node).get(i).distance;\\n                    int b = ar.get(node).get(i).node;\\n\\n                    pq.add(new Pair(a,b)); \\n                }\\n            }\\n\\n            visited[node] = 1;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327600,
                "title": "java-dsu-100-solution-with-5ms",
                "content": "Intuition - First taking base case, in which we have to join two nodes with an edge between them. We will connect them but in rank[], we will store the edge value between them.\\nNow, we need to merge two groups of nodes with their root parent having rank[root] value as the minimum edge between edges connected within their group only. So, we will do union of these two groups, and for that we will make root of the combined group the node which the root of a group with minimum value edges within the nodes in it group. Or rank[i] stores this minimum edge value in the nodes of group with root as ith node. And there is new edge between these two root nodes also, so we will compare rank[combined root] value with this new edge also.\\n\\nWhen union of all edges is done. And node 1 and node 4 will be in a group. Then rank[parent of node 1 or node n] is the answer.\\nRuntime: 5 ms, faster than 100.00% \\n\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int[] parent = new int[n+1], rank = new int[n+1];\\n        for(int i = 1; i <= n; ++i){\\n            parent[i] = i;\\n            rank[i] = Integer.MAX_VALUE;\\n        }\\n        int ans = Integer.MAX_VALUE, u, v;\\n        for(int[] road : roads){\\n            union(parent, rank, road[0], road[1], road[2]);\\n        }\\n        u = find(parent, 1); v = find(parent, n);\\n        if(u == v){\\n            ans = rank[u];\\n        }\\n        return ans;\\n    }\\n    \\n    private int find(int[] parent, int x){\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent, parent[x]);\\n    }\\n    \\n    private void union(int[] parent, int[] rank, int u, int v, int w){\\n        u = find(parent, u);\\n        v = find(parent, v);\\n        // if(u == v) return;\\n        if(rank[u] <= rank[v]){\\n            parent[v] = u;\\n            rank[u] = (int)Math.min(rank[u], w);\\n        }\\n        else{\\n            parent[u] = v;\\n            rank[v] = (int)Math.min(rank[v], w);\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        int[] parent = new int[n+1], rank = new int[n+1];\\n        for(int i = 1; i <= n; ++i){\\n            parent[i] = i;\\n            rank[i] = Integer.MAX_VALUE;\\n        }\\n        int ans = Integer.MAX_VALUE, u, v;\\n        for(int[] road : roads){\\n            union(parent, rank, road[0], road[1], road[2]);\\n        }\\n        u = find(parent, 1); v = find(parent, n);\\n        if(u == v){\\n            ans = rank[u];\\n        }\\n        return ans;\\n    }\\n    \\n    private int find(int[] parent, int x){\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent, parent[x]);\\n    }\\n    \\n    private void union(int[] parent, int[] rank, int u, int v, int w){\\n        u = find(parent, u);\\n        v = find(parent, v);\\n        // if(u == v) return;\\n        if(rank[u] <= rank[v]){\\n            parent[v] = u;\\n            rank[u] = (int)Math.min(rank[u], w);\\n        }\\n        else{\\n            parent[u] = v;\\n            rank[v] = (int)Math.min(rank[v], w);\\n        }\\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327590,
                "title": "python3-99-96-t-m-faster-beats-clean-solution-simple-explain",
                "content": "![image.png](https://assets.leetcode.com/users/images/242a2589-17c6-4341-a8dd-8641e5a14b6c_1679467685.8966243.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nImportant tips for you : As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge.\\n\\n# Complexity\\n- Time complexity:O(n)\\n- create table time , bfs time , traval roads time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n- hash table\\u3001view\\u3001ans\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        ht = defaultdict(list)\\n        for i,j,dis in roads:\\n            ht[i].append(j)\\n            ht[j].append(i)\\n        ans,view= inf,set()\\n        queue = deque([1])\\n        while queue:\\n            cur_city = queue.popleft()\\n            for next_city in ht[cur_city]:\\n                if next_city not in view:\\n                    queue.append(next_city)\\n                    view.add(next_city)\\n        for i,j,dis in roads:\\n            if i in view or j in view:\\n                ans=min(ans,dis)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        ht = defaultdict(list)\\n        for i,j,dis in roads:\\n            ht[i].append(j)\\n            ht[j].append(i)\\n        ans,view= inf,set()\\n        queue = deque([1])\\n        while queue:\\n            cur_city = queue.popleft()\\n            for next_city in ht[cur_city]:\\n                if next_city not in view:\\n                    queue.append(next_city)\\n                    view.add(next_city)\\n        for i,j,dis in roads:\\n            if i in view or j in view:\\n                ans=min(ans,dis)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327402,
                "title": "dfs-c",
                "content": "```\\nclass Solution {\\n    void dfs(int node, vector<pair<int, int>> adj[], vector<int> &vis, int &ans) {\\n        vis[node] = 1;\\n        for(auto ad : adj[node]) {\\n            ans = min(ans, ad.second);\\n            if(!vis[ad.first]) dfs(ad.first, adj, vis, ans);\\n        }\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n + 1];\\n        for(auto e : roads) adj[e[0]].push_back({e[1], e[2]}), adj[e[1]].push_back({e[0], e[2]});\\n        \\n        int ans = 1e9;\\n        vector<int> vis(n + 1);\\n        dfs(n, adj, vis, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, vector<pair<int, int>> adj[], vector<int> &vis, int &ans) {\\n        vis[node] = 1;\\n        for(auto ad : adj[node]) {\\n            ans = min(ans, ad.second);\\n            if(!vis[ad.first]) dfs(ad.first, adj, vis, ans);\\n        }\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> adj[n + 1];\\n        for(auto e : roads) adj[e[0]].push_back({e[1], e[2]}), adj[e[1]].push_back({e[0], e[2]});\\n        \\n        int ans = 1e9;\\n        vector<int> vis(n + 1);\\n        dfs(n, adj, vis, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327145,
                "title": "easy-java-solution-using-bfs-and-dfs",
                "content": "# Approach\\n\\n1. Make a adjacency list to store the nodes and the weight of path.\\n2. Perform the basic bfs and dfs and update the ans to the minimum weight of path\\n\\n\\n# Complexity\\n- **Time complexity:  O(N+E)**\\n\\n- **Space complexity: O(N+E)**\\n# DFS approach\\n```\\nclass Solution {\\n\\n    private int ans = Integer.MAX_VALUE;\\n\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, List<List<Integer>>> graph = new HashMap<>();\\n\\n        for(int[] it : roads){\\n            graph.computeIfAbsent(it[0], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[1],it[2]));\\n\\n            graph.computeIfAbsent(it[1], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[0],it[2]));\\n        }\\n\\n        boolean[] visited = new boolean[n+1];\\n\\n        dfs(1, graph, visited);\\n\\n        return ans;\\n\\n    }\\n\\n    private void dfs(int i,HashMap<Integer, List<List<Integer>>> graph, boolean[] visited){\\n\\n        visited[i] = true;\\n\\n        if(!graph.containsKey(i)){\\n            return ;\\n        }\\n\\n        for(List<Integer> it : graph.get(i)){\\n            ans = Math.min(ans,it.get(1));\\n\\n            if(!visited[it.get(0)]){\\n                dfs(it.get(0), graph, visited);\\n            }\\n        }\\n    }\\n\\n}\\n```\\n# BFS approach \\n```\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, List<List<Integer>>> graph = new HashMap<>();\\n\\n        for(int[] it : roads){\\n            graph.computeIfAbsent(it[0], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[1],it[2]));\\n            graph.computeIfAbsent(it[1], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[0],it[2]));\\n        }\\n\\n        return bfs(n,graph);\\n    }\\n\\n    private int bfs(int n,HashMap<Integer, List<List<Integer>>> graph){\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        boolean[] visited = new boolean[n+1];\\n\\n        visited[1] = true;\\n        q.offer(1);\\n        int ans = Integer.MAX_VALUE;\\n\\n        while(!q.isEmpty()){\\n            int x = q.poll();\\n\\n            if(!graph.containsKey(x)){\\n                continue;\\n            }\\n\\n            for(List<Integer> it : graph.get(x)){\\n                ans = Math.min(ans, it.get(1));\\n                if(!visited[it.get(0)]){\\n                    visited[it.get(0)] = true;\\n\\n                    q.offer(it.get(0));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int ans = Integer.MAX_VALUE;\\n\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, List<List<Integer>>> graph = new HashMap<>();\\n\\n        for(int[] it : roads){\\n            graph.computeIfAbsent(it[0], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[1],it[2]));\\n\\n            graph.computeIfAbsent(it[1], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[0],it[2]));\\n        }\\n\\n        boolean[] visited = new boolean[n+1];\\n\\n        dfs(1, graph, visited);\\n\\n        return ans;\\n\\n    }\\n\\n    private void dfs(int i,HashMap<Integer, List<List<Integer>>> graph, boolean[] visited){\\n\\n        visited[i] = true;\\n\\n        if(!graph.containsKey(i)){\\n            return ;\\n        }\\n\\n        for(List<Integer> it : graph.get(i)){\\n            ans = Math.min(ans,it.get(1));\\n\\n            if(!visited[it.get(0)]){\\n                dfs(it.get(0), graph, visited);\\n            }\\n        }\\n    }\\n\\n}\\n```\n```\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, List<List<Integer>>> graph = new HashMap<>();\\n\\n        for(int[] it : roads){\\n            graph.computeIfAbsent(it[0], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[1],it[2]));\\n            graph.computeIfAbsent(it[1], k -> new ArrayList<List<Integer>>()).add(Arrays.asList(it[0],it[2]));\\n        }\\n\\n        return bfs(n,graph);\\n    }\\n\\n    private int bfs(int n,HashMap<Integer, List<List<Integer>>> graph){\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        boolean[] visited = new boolean[n+1];\\n\\n        visited[1] = true;\\n        q.offer(1);\\n        int ans = Integer.MAX_VALUE;\\n\\n        while(!q.isEmpty()){\\n            int x = q.poll();\\n\\n            if(!graph.containsKey(x)){\\n                continue;\\n            }\\n\\n            for(List<Integer> it : graph.get(x)){\\n                ans = Math.min(ans, it.get(1));\\n                if(!visited[it.get(0)]){\\n                    visited[it.get(0)] = true;\\n\\n                    q.offer(it.get(0));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327119,
                "title": "python-solution-using-hash-map-and-union-find-beats-100",
                "content": "# Approach\\n1. Implement Union Find functions\\n2. Join each road via Union Find\\n4. Each time we connect cities via the union() function we check which is the lowest value between the current road and lowest value in the 2 groups the cities belong to.\\n5. We then assign this lowest value to the root node in the hash map.\\n\\nWe are essentially using the root node of each each city as the key in the hashmap - we know that if we call the find() function we can get the root node of the city. By continually assigning the lowest value to the root node in the hash map we can find our answer in the root node of 1 in the hash map (hash[find(1)])\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minScore(self, n, roads):\\n\\n        p = list(range(n + 1))\\n        hash = {}\\n\\n        def find(x):\\n            if x != p[x]:\\n                p[x] = find(p[x])\\n            return p[x]\\n\\n        def union(x, y, val):\\n            px = find(x)\\n            py = find(y)\\n\\n            a = hash[px] if px in hash else val\\n            b = hash[py] if py in hash else val\\n            hash[px] = min(val, a, b)\\n\\n            if px != py:\\n                p[py] = px\\n\\n        for x, y, val in roads:\\n            union(x, y, val)\\n\\n        return hash[find(1)]\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Union Find"
                ],
                "code": "```\\nclass Solution(object):\\n    def minScore(self, n, roads):\\n\\n        p = list(range(n + 1))\\n        hash = {}\\n\\n        def find(x):\\n            if x != p[x]:\\n                p[x] = find(p[x])\\n            return p[x]\\n\\n        def union(x, y, val):\\n            px = find(x)\\n            py = find(y)\\n\\n            a = hash[px] if px in hash else val\\n            b = hash[py] if py in hash else val\\n            hash[px] = min(val, a, b)\\n\\n            if px != py:\\n                p[py] = px\\n\\n        for x, y, val in roads:\\n            union(x, y, val)\\n\\n        return hash[find(1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326985,
                "title": "simple-bfs-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dj(vector<pair<int,int>>g[], int n){\\n        int ans = INT_MAX;\\n        queue<int>q;\\n        q.push(1);\\n        vector<int>visited(n+1,0);\\n        visited[1] = 1;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto i:g[node]){\\n                ans = min(ans,i.second);\\n                if(!visited[i.first]){\\n                    visited[i.first] = 1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>g[n+1];\\n        int m = roads.size();\\n        for(int i=0; i<m; i++){\\n            int u = roads[i][0], v = roads[i][1], cost = roads[i][2];\\n            g[u].push_back({v,cost});\\n            g[v].push_back({u,cost});\\n        }\\n        return dj(g,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dj(vector<pair<int,int>>g[], int n){\\n        int ans = INT_MAX;\\n        queue<int>q;\\n        q.push(1);\\n        vector<int>visited(n+1,0);\\n        visited[1] = 1;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto i:g[node]){\\n                ans = min(ans,i.second);\\n                if(!visited[i.first]){\\n                    visited[i.first] = 1;\\n                    q.push(i.first);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>g[n+1];\\n        int m = roads.size();\\n        for(int i=0; i<m; i++){\\n            int u = roads[i][0], v = roads[i][1], cost = roads[i][2];\\n            g[u].push_back({v,cost});\\n            g[v].push_back({u,cost});\\n        }\\n        return dj(g,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326962,
                "title": "c-using-bfs-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem states that we need to find minimum distance of a road while travelling from road 1 to road n. Note that we can travel the same road multiple times.\\n\\n  ![image.png](https://assets.leetcode.com/users/images/b421786d-c2d1-4ae6-81a2-1c4acee04835_1679456030.3175228.png)\\n\\nSee in the above example, we are visiting the path from 1 to 2 twice. The minimum score is 2.\\n```\\n  1->2->1->3->4 \\n```\\n\\n# Approach\\n### 1. DFS\\nThe DFS algorithm starts from the first road and explores its neighboring roads. For each neighboring road, update the minimum distance if it is smaller than the current minimum distance. Also mark the neighboring road as visited to avoid visiting it again. Then recursively explore the neighboring roads of the neighboring roads until it reaches the last road. Finally, return the minimum distance found along the path from the first road to the last road.\\n\\n### 2. BFS\\nWe are using a queue to implement a BFS. Start with the first node and marks it as visited. Then, traverse all the neighboring nodes of the current node and mark them as visited, adding them to the queue to be processed later. At each step, the update the minimum distance it has seen so far. Continue until all nodes have been explored. Finally, return the minimum distance.\\n\\nWe use a 2D vector to represent the graph, where each entry represents a node and its neighboring nodes, along with the distance between them. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(n + m)**, where n is the number of cities and m is the number of roads connecting them. In the worst case, all the nodes and edges of the graph will be traversed, and hence, the time complexity is O(n + m).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  **O(n+m)**, where n is the number of cities and m is the number of roads connecting them.\\n\\n# Code\\n### 1. Using DFS\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<pair<int,int>>>& adj, vector<bool>& visit, int n, int i,int& ans){\\n        visit[i]=true; // mark city i visited\\n        for(int j=0;j<adj[i].size();++j){\\n            int b=adj[i][j].first, d=adj[i][j].second;\\n            ans=min(ans,d);\\n            if(!visit[b]) dfs(adj,visit,n,b,ans); // if city b is not visited then call dfs\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> adj(n+1); // adjacency matrix\\n        for(auto& r:roads){\\n            int a=r[0], b=r[1], d=r[2]; // first city, second city, distance\\n            adj[a].push_back({b,d}); \\n            adj[b].push_back({a,d});\\n        }\\n        int ans=INT_MAX;\\n        vector<bool>visit(n+1,false);\\n        dfs(adj,visit,n,1,ans);\\n        return ans;\\n    }\\n};\\n```\\n### 2. Using BFS\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>>adj(n+1); // adjacency matrix\\n        vector<int>vis(n+1,false); // vector to mark nodes visited \\n        queue<int>q;\\n        int ans=INT_MAX;\\n        for(auto& r: roads){\\n            int a=r[0],b=r[1],d=r[2]; // first city, second city, distance\\n            adj[a].push_back({b,d});\\n            adj[b].push_back({a,d});\\n        }\\n\\n        q.push(1); // push the 1st city and mark it visited\\n        vis[1]=true;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            // loop to push the nodes connected to current node in the queue (if not visited)\\n            for(auto& r: adj[node]){\\n                ans=min(ans,r.second);\\n                if(!vis[r.first]) {\\n                    q.push(r.first);\\n                    vis[r.first]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n  1->2->1->3->4 \\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<pair<int,int>>>& adj, vector<bool>& visit, int n, int i,int& ans){\\n        visit[i]=true; // mark city i visited\\n        for(int j=0;j<adj[i].size();++j){\\n            int b=adj[i][j].first, d=adj[i][j].second;\\n            ans=min(ans,d);\\n            if(!visit[b]) dfs(adj,visit,n,b,ans); // if city b is not visited then call dfs\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> adj(n+1); // adjacency matrix\\n        for(auto& r:roads){\\n            int a=r[0], b=r[1], d=r[2]; // first city, second city, distance\\n            adj[a].push_back({b,d}); \\n            adj[b].push_back({a,d});\\n        }\\n        int ans=INT_MAX;\\n        vector<bool>visit(n+1,false);\\n        dfs(adj,visit,n,1,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>>adj(n+1); // adjacency matrix\\n        vector<int>vis(n+1,false); // vector to mark nodes visited \\n        queue<int>q;\\n        int ans=INT_MAX;\\n        for(auto& r: roads){\\n            int a=r[0],b=r[1],d=r[2]; // first city, second city, distance\\n            adj[a].push_back({b,d});\\n            adj[b].push_back({a,d});\\n        }\\n\\n        q.push(1); // push the 1st city and mark it visited\\n        vis[1]=true;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            // loop to push the nodes connected to current node in the queue (if not visited)\\n            for(auto& r: adj[node]){\\n                ans=min(ans,r.second);\\n                if(!vis[r.first]) {\\n                    q.push(r.first);\\n                    vis[r.first]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326909,
                "title": "easy-c-dfs-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust finding All nodes that can be visited when starting from 1st node then finding minimum of path among them.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& x,vector<int>& vis,int i){\\n        vis[i]=1;\\n        for(int j=0;j<x[i].size();j++) if(!vis[x[i][j]]) dfs(x,vis,x[i][j]);\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>> x(n);\\n        int m=roads.size(),mn=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            x[roads[i][0]-1].push_back(roads[i][1]-1);\\n            x[roads[i][1]-1].push_back(roads[i][0]-1);\\n        }\\n        vector<int> vis(n,0);\\n        dfs(x,vis,0);\\n        for(int i=0;i<m;i++) if(vis[roads[i][0]-1]) mn=min(mn,roads[i][2]);\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& x,vector<int>& vis,int i){\\n        vis[i]=1;\\n        for(int j=0;j<x[i].size();j++) if(!vis[x[i][j]]) dfs(x,vis,x[i][j]);\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>> x(n);\\n        int m=roads.size(),mn=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            x[roads[i][0]-1].push_back(roads[i][1]-1);\\n            x[roads[i][1]-1].push_back(roads[i][0]-1);\\n        }\\n        vector<int> vis(n,0);\\n        dfs(x,vis,0);\\n        for(int i=0;i<m;i++) if(vis[roads[i][0]-1]) mn=min(mn,roads[i][2]);\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326695,
                "title": "swift-union-find",
                "content": "**Union Find (accepted answer)**\\n```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var groups = Array(0...n)\\n        var minCosts = Array(repeating: Int.max, count: n+1)\\n        \\n        func find(_ x: Int) -> Int {\\n            if x != groups[x] { \\n                groups[x] = find(groups[x]) // path compression, if needed\\n            }  \\n            return groups[x]\\n        }\\n                        \\n        for road in roads {\\n            let (x,y) = (find(road[0]), find(road[1]))\\n            let (minXY, maxXY) = (min(x,y), max(x,y))\\n            groups[maxXY] = minXY\\n            minCosts[minXY] = min(minCosts[x], minCosts[y], road[2])\\n        }\\n        \\n        return minCosts[find(1)]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var groups = Array(0...n)\\n        var minCosts = Array(repeating: Int.max, count: n+1)\\n        \\n        func find(_ x: Int) -> Int {\\n            if x != groups[x] { \\n                groups[x] = find(groups[x]) // path compression, if needed\\n            }  \\n            return groups[x]\\n        }\\n                        \\n        for road in roads {\\n            let (x,y) = (find(road[0]), find(road[1]))\\n            let (minXY, maxXY) = (min(x,y), max(x,y))\\n            groups[maxXY] = minXY\\n            minCosts[minXY] = min(minCosts[x], minCosts[y], road[2])\\n        }\\n        \\n        return minCosts[find(1)]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326601,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mini = INT_MAX;\\n    \\n    void dfs(int s, vector<bool>&vis, vector<pair<int, int>>adj[]) {\\n        vis[s] = true;\\n        \\n        for(auto &it : adj[s]) {\\n            int v = it.first, wt = it.second;\\n            mini = min(mini, wt);\\n            if(!vis[v])\\n                dfs(v, vis, adj);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector< pair<int, int> > adj[n+1];\\n        for(auto &it : roads) {\\n            int u = it[0], v = it[1], wt = it[2];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n        \\n        vector<bool>vis(n+1, false);\\n        dfs(1, vis, adj);\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mini = INT_MAX;\\n    \\n    void dfs(int s, vector<bool>&vis, vector<pair<int, int>>adj[]) {\\n        vis[s] = true;\\n        \\n        for(auto &it : adj[s]) {\\n            int v = it.first, wt = it.second;\\n            mini = min(mini, wt);\\n            if(!vis[v])\\n                dfs(v, vis, adj);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector< pair<int, int> > adj[n+1];\\n        for(auto &it : roads) {\\n            int u = it[0], v = it[1], wt = it[2];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n        \\n        vector<bool>vis(n+1, false);\\n        dfs(1, vis, adj);\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326589,
                "title": "daily-leetcoding-challenge-march-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3254927,
                "title": "c-dfs-graph",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<bool> &v,int &ans,vector<vector<vector<int>>> &g){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            ans = min(ans,i[1]);\\n            dfs(i[0],v,ans,g);\\n        }\\n    }\\n        int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(int i = 0; i < roads.size(); i++){\\n            g[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            g[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<bool>  v(n+1,false);\\n        dfs(1,v,ans,g);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int s,vector<bool> &v,int &ans,vector<vector<vector<int>>> &g){\\n        if(v[s])return;\\n        v[s] = true;\\n        for(auto &i: g[s]){\\n            ans = min(ans,i[1]);\\n            dfs(i[0],v,ans,g);\\n        }\\n    }\\n        int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(int i = 0; i < roads.size(); i++){\\n            g[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            g[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<bool>  v(n+1,false);\\n        dfs(1,v,ans,g);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177210,
                "title": "golang-bfs",
                "content": "# Code\\n```\\ntype pair struct {\\n    first int\\n    second int\\n}\\n\\nfunc minScore(n int, roads [][]int) int {\\n    adjList := make([][]pair, n + 1)\\n    for _, edge := range roads {\\n        adjList[edge[0]] = append(adjList[edge[0]], pair{edge[1], edge[2]})\\n        adjList[edge[1]] = append(adjList[edge[1]], pair{edge[0], edge[2]})\\n    }\\n    visited := make([]bool, n + 1)\\n    Queue := []int{1}\\n    var ans int = math.MaxInt\\n    for len(Queue) > 0 {\\n        var sz int = len(Queue)\\n        for i := 0; i < sz; i++ {\\n            var curr int = Queue[0]\\n            Queue = Queue[1:]\\n            for _, edge := range adjList[curr] {\\n                if edge.second < ans {\\n                    ans = edge.second\\n                }\\n                if !visited[edge.first] {\\n                    Queue = append(Queue, edge.first)\\n                    visited[edge.first] = true\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\ntype pair struct {\\n    first int\\n    second int\\n}\\n\\nfunc minScore(n int, roads [][]int) int {\\n    adjList := make([][]pair, n + 1)\\n    for _, edge := range roads {\\n        adjList[edge[0]] = append(adjList[edge[0]], pair{edge[1], edge[2]})\\n        adjList[edge[1]] = append(adjList[edge[1]], pair{edge[0], edge[2]})\\n    }\\n    visited := make([]bool, n + 1)\\n    Queue := []int{1}\\n    var ans int = math.MaxInt\\n    for len(Queue) > 0 {\\n        var sz int = len(Queue)\\n        for i := 0; i < sz; i++ {\\n            var curr int = Queue[0]\\n            Queue = Queue[1:]\\n            for _, edge := range adjList[curr] {\\n                if edge.second < ans {\\n                    ans = edge.second\\n                }\\n                if !visited[edge.first] {\\n                    Queue = append(Queue, edge.first)\\n                    visited[edge.first] = true\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2950397,
                "title": "java-pair-bfs",
                "content": "```\\nclass Solution {\\n    public class Pair{\\n        int sc;\\n        int d;\\n        Pair(int sc,int d){\\n            this.sc=sc;\\n            this.d=d;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<Pair>[]arr=new ArrayList[n+1];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=new ArrayList<>();\\n        }\\n        for(int []e:roads){\\n            arr[e[0]].add(new Pair(e[1],e[2]));\\n            arr[e[1]].add(new Pair(e[0],e[2]));\\n        }\\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(1,(int)1e9));\\n        boolean []vis=new boolean[n+1];\\n        int ans=(int)1e9;\\n        while(q.size()>0){\\n            Pair p=q.remove();\\n            vis[p.sc]=true;\\n            ans=Math.min(ans,p.d);\\n            \\n            for(Pair rem:arr[p.sc]){\\n               if(vis[rem.sc]==false){\\n                    q.add(rem);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public class Pair{\\n        int sc;\\n        int d;\\n        Pair(int sc,int d){\\n            this.sc=sc;\\n            this.d=d;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2931808,
                "title": "easiest-simple-c-dfs-bfs-solution-with-approach",
                "content": "### Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind minimum value of edge in connected component of one\\n\\n## DFS Code\\n```\\nclass Solution {\\npublic:\\n    int mini=INT_MAX;\\n    void dfs(int node, vector<pair<int,int>> adj[], vector<int>& vis){\\n        if (vis[node])return;\\n        vis[node]=1;\\n        for (auto val:adj[node]){\\n            mini= min(mini,val.second);\\n            dfs(val.first,adj,vis);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for (auto rowvect: roads){\\n            adj[rowvect[0]].push_back({rowvect[1],rowvect[2]});\\n            adj[rowvect[1]].push_back({rowvect[0],rowvect[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        dfs(1,adj,vis);\\n        return mini;\\n    }\\n};\\n```\\n\\n## BFS Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for (auto rowvect: roads){\\n            adj[rowvect[0]].push_back({rowvect[1],rowvect[2]});\\n            adj[rowvect[1]].push_back({rowvect[0],rowvect[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        int mini= INT_MAX;\\n        queue<pair<int,int>> q; // node weight\\n        q.push({1,INT_MAX}); \\n        while (!q.empty()){\\n            mini= min(mini,q.front().second);\\n            vis[q.front().first]=1;\\n            for (auto val: adj[q.front().first]){\\n                if (!vis[val.first]){\\n                    q.push({val.first,val.second});\\n                }\\n            }\\n            q.pop();\\n        }\\n\\n        return mini;\\n    }\\n};\\n```\\n> *Upvote if you like :)*\\n\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mini=INT_MAX;\\n    void dfs(int node, vector<pair<int,int>> adj[], vector<int>& vis){\\n        if (vis[node])return;\\n        vis[node]=1;\\n        for (auto val:adj[node]){\\n            mini= min(mini,val.second);\\n            dfs(val.first,adj,vis);\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for (auto rowvect: roads){\\n            adj[rowvect[0]].push_back({rowvect[1],rowvect[2]});\\n            adj[rowvect[1]].push_back({rowvect[0],rowvect[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        dfs(1,adj,vis);\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1];\\n        for (auto rowvect: roads){\\n            adj[rowvect[0]].push_back({rowvect[1],rowvect[2]});\\n            adj[rowvect[1]].push_back({rowvect[0],rowvect[2]});\\n        }\\n        vector<int> vis(n+1,0);\\n        int mini= INT_MAX;\\n        queue<pair<int,int>> q; // node weight\\n        q.push({1,INT_MAX}); \\n        while (!q.empty()){\\n            mini= min(mini,q.front().second);\\n            vis[q.front().first]=1;\\n            for (auto val: adj[q.front().first]){\\n                if (!vis[val.first]){\\n                    q.push({val.first,val.second});\\n                }\\n            }\\n            q.pop();\\n        }\\n\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886109,
                "title": "dfs-simple-dfs",
                "content": "# Intuition\\nVisit All Node find minimum distance only so That => we use DFS\\n\\n# Approach\\nNormal DFS Call With Maintain visit Node only\\n\\n# Complexity\\n- Time complexity:\\n  o(V+2E)   v=>vertex E=>edages\\n\\n- Space complexity:\\n  o(V+2E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //SImle DFS\\n    int mi=INT_MAX; //global declared variable for store minimum     value of distance\\n    vector<pair<int,int>> graph[100001];//graph formate (Feel)=> arry[100001] => vector<>=> pair<int,int> => {Node,distance} \\n    int visit[100001]; //maintain visit Node\\n\\n    //DFS Function :  \\n    void dfs(int vertex){ // vertex=> Node => parent \\n         \\n         if(visit[vertex])return; // if Node is visited then return\\n\\n         visit[vertex]=1; //mark Node as visited\\n         \\n         //take child of vertex from graph\\n         for(auto child : graph[vertex]){\\n\\n             int child_Node=child.first;   //child_Node of vertex\\n             int child_dist=child.second;  // distance between vertex and child_NOde Node\\n             mi=min(mi,child_dist);        //update minimum value of wt/distance between two Node \\n             \\n             //pass child_Node for find its next childs;\\n             dfs(child_Node);\\n         }\\n\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //roads 2d array covert into graph\\n      \\n        int sz=roads.size();        // size of road 2d array \\n        //graph declaration\\n        for(int i=0;i<sz;i++){\\n            int Node1=roads[i][0];\\n            int Node2=roads[i][1];\\n            int distance=roads[i][2];\\n            //for bi-directional\\n            graph[Node1].push_back({Node2,distance});\\n            graph[Node2].push_back({Node1,distance});\\n\\n        }\\n  \\n        dfs(1); //call DFS=>\\n\\n        return mi; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //SImle DFS\\n    int mi=INT_MAX; //global declared variable for store minimum     value of distance\\n    vector<pair<int,int>> graph[100001];//graph formate (Feel)=> arry[100001] => vector<>=> pair<int,int> => {Node,distance} \\n    int visit[100001]; //maintain visit Node\\n\\n    //DFS Function :  \\n    void dfs(int vertex){ // vertex=> Node => parent \\n         \\n         if(visit[vertex])return; // if Node is visited then return\\n\\n         visit[vertex]=1; //mark Node as visited\\n         \\n         //take child of vertex from graph\\n         for(auto child : graph[vertex]){\\n\\n             int child_Node=child.first;   //child_Node of vertex\\n             int child_dist=child.second;  // distance between vertex and child_NOde Node\\n             mi=min(mi,child_dist);        //update minimum value of wt/distance between two Node \\n             \\n             //pass child_Node for find its next childs;\\n             dfs(child_Node);\\n         }\\n\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //roads 2d array covert into graph\\n      \\n        int sz=roads.size();        // size of road 2d array \\n        //graph declaration\\n        for(int i=0;i<sz;i++){\\n            int Node1=roads[i][0];\\n            int Node2=roads[i][1];\\n            int distance=roads[i][2];\\n            //for bi-directional\\n            graph[Node1].push_back({Node2,distance});\\n            graph[Node2].push_back({Node1,distance});\\n\\n        }\\n  \\n        dfs(1); //call DFS=>\\n\\n        return mi; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879531,
                "title": "javascript-graph-dfs",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function(n, roads) {\\n    const adj = new Map();\\n    \\n    for (const [u, v, d] of roads) {\\n        if (adj.has(u)) {\\n            const arr = adj.get(u);\\n            arr.push([v, d]);\\n            adj.set(u, arr);\\n        } else {\\n            adj.set(u, [[v, d]]);\\n        }\\n        \\n        if (adj.has(v)) {\\n            const arr = adj.get(v);\\n            arr.push([u, d]);\\n            adj.set(v, arr);\\n        } else {\\n            adj.set(v, [[u, d]]);\\n        }\\n    }\\n    \\n    let ans = Infinity;\\n    const visited = new Set();\\n    \\n    function dfs(node) {\\n        visited.add(node);\\n        \\n        for (const [nei, dis] of adj.get(node)) {\\n            ans = Math.min(ans, dis);\\n            \\n            if (visited.has(nei)) {\\n                continue;\\n            }\\n            \\n            dfs(nei);\\n        }\\n    }\\n    \\n    dfs(1);\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function(n, roads) {\\n    const adj = new Map();\\n    \\n    for (const [u, v, d] of roads) {\\n        if (adj.has(u)) {\\n            const arr = adj.get(u);\\n            arr.push([v, d]);\\n            adj.set(u, arr);\\n        } else {\\n            adj.set(u, [[v, d]]);\\n        }\\n        \\n        if (adj.has(v)) {\\n            const arr = adj.get(v);\\n            arr.push([u, d]);\\n            adj.set(v, arr);\\n        } else {\\n            adj.set(v, [[u, d]]);\\n        }\\n    }\\n    \\n    let ans = Infinity;\\n    const visited = new Set();\\n    \\n    function dfs(node) {\\n        visited.add(node);\\n        \\n        for (const [nei, dis] of adj.get(node)) {\\n            ans = Math.min(ans, dis);\\n            \\n            if (visited.has(nei)) {\\n                continue;\\n            }\\n            \\n            dfs(nei);\\n        }\\n    }\\n    \\n    dfs(1);\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2877493,
                "title": "find-the-min-road",
                "content": "# Intuition\\nAs the path can contain same road multiple times, and the score is calculated by the min road.\\nThe optimal path will always contian the minimum distance road which can be travelled if start from city `1`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Depth-First Search from city `1` we can get the road with minimum distance.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<pair<int, int>>>& graph, vector<bool>& visited, int d, int u) {\\n        visited[u] = true;\\n        for(pair<int, int>& road: graph[u]) {\\n            d = min(d, road.second);\\n            if(!visited[road.first])\\n                d = dfs(graph, visited, d, road.first);\\n        }\\n        return d;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(vector<int>& road: roads) {\\n            graph[road[0] - 1].push_back({road[1] - 1, road[2]});\\n            graph[road[1] - 1].push_back({road[0] - 1, road[2]});\\n        }\\n        vector<bool> visited(n, false);\\n        return dfs(graph, visited, 1e9, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<pair<int, int>>>& graph, vector<bool>& visited, int d, int u) {\\n        visited[u] = true;\\n        for(pair<int, int>& road: graph[u]) {\\n            d = min(d, road.second);\\n            if(!visited[road.first])\\n                d = dfs(graph, visited, d, road.first);\\n        }\\n        return d;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(vector<int>& road: roads) {\\n            graph[road[0] - 1].push_back({road[1] - 1, road[2]});\\n            graph[road[1] - 1].push_back({road[0] - 1, road[2]});\\n        }\\n        vector<bool> visited(n, false);\\n        return dfs(graph, visited, 1e9, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876418,
                "title": "javascript-disjoint-set-union",
                "content": "```\\nclass DisjointSetUnion {\\n    constructor(n) {\\n        this.parent = new Array(n + 1).fill().map((_, index) => index);\\n        this.rank = new Array(n + 1).fill(0);\\n    }\\n\\n    find(num) {\\n        if(this.parent[num] === num) return num;\\n\\n        return this.parent[num] = this.find(this.parent[num]);\\n    }\\n\\n    union(source, target) {\\n        source = this.find(source);\\n        target = this.find(target);\\n\\n        if(this.rank[source] < this.rank[target]) {\\n            [source, target] = [target, source];\\n        }\\n\\n        this.parent[target] = source;\\n        this.rank[source] += 1;\\n    }\\n}\\n\\nvar minScore = function(n, roads) {\\n    const dsu = new DisjointSetUnion(n);\\n    for(const [source, target] of roads) {\\n        dsu.union(source, target);\\n    }\\n\\n    let minDistance = Infinity;\\n    const root = dsu.find(1);\\n    for(const [source, target, distance] of roads) {\\n        if(dsu.find(source) === root || dsu.find(target) === root) {\\n            minDistance = Math.min(minDistance, distance);\\n        }\\n    }\\n\\n    return minDistance;\\n};\\n```\\n\\nTime: O(n * log(n))\\nSpace: O(n)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass DisjointSetUnion {\\n    constructor(n) {\\n        this.parent = new Array(n + 1).fill().map((_, index) => index);\\n        this.rank = new Array(n + 1).fill(0);\\n    }\\n\\n    find(num) {\\n        if(this.parent[num] === num) return num;\\n\\n        return this.parent[num] = this.find(this.parent[num]);\\n    }\\n\\n    union(source, target) {\\n        source = this.find(source);\\n        target = this.find(target);\\n\\n        if(this.rank[source] < this.rank[target]) {\\n            [source, target] = [target, source];\\n        }\\n\\n        this.parent[target] = source;\\n        this.rank[source] += 1;\\n    }\\n}\\n\\nvar minScore = function(n, roads) {\\n    const dsu = new DisjointSetUnion(n);\\n    for(const [source, target] of roads) {\\n        dsu.union(source, target);\\n    }\\n\\n    let minDistance = Infinity;\\n    const root = dsu.find(1);\\n    for(const [source, target, distance] of roads) {\\n        if(dsu.find(source) === root || dsu.find(target) === root) {\\n            minDistance = Math.min(minDistance, distance);\\n        }\\n    }\\n\\n    return minDistance;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875496,
                "title": "c-bfs-explanation",
                "content": "Initially we have to construct a graph(adjacency matrix) and vis(visited array).\\nWe contruct queue for BFS traversal.\\nThe logic behind this question is to traverse all the possible path from 1 and take the minimum weight of them. \\nTo tranver all possible path we use BFS algo.\\nIn our adjacency matrix the first element contain the connected node and second contain the weigth of connection.\\nSo to compute minimum we use i[1] (i.e g->(node)->(connected component)->weight) and we compute the result in res variable(i.e miniumum of all connected nodes).\\n\\nWe use visited array to not to tranverse on the same element more than once.\\nWe initially insert 1 in queue because we have to start from 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int res = 1e9+7;\\n    vector<bool> vis;\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(int i=0 ; i<roads.size() ; ++i) {\\n            g[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            g[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vis.resize(n+1,false);\\n        queue<int> q;\\n        q.push(1);\\n        while(!q.empty()) {\\n            int k = q.front();\\n            q.pop();\\n            if(vis[k]) continue;\\n            vis[k]=1;\\n            for(auto i:g[k]) {\\n                res = min(res,i[1]);\\n                q.push(i[0]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 1e9+7;\\n    vector<bool> vis;\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<vector<int>>> g(n+1);\\n        for(int i=0 ; i<roads.size() ; ++i) {\\n            g[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            g[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vis.resize(n+1,false);\\n        queue<int> q;\\n        q.push(1);\\n        while(!q.empty()) {\\n            int k = q.front();\\n            q.pop();\\n            if(vis[k]) continue;\\n            vis[k]=1;\\n            for(auto i:g[k]) {\\n                res = min(res,i[1]);\\n                q.push(i[0]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875217,
                "title": "python-easy-logic-simple-bfs-with-min-tracking",
                "content": "**Upvote if it helped :)**\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adjMat = defaultdict(list)\\n        \\n        for x, y, w in roads:\\n            adjMat[x].append((y, w))\\n            adjMat[y].append((x, w))\\n        \\n        \\n        q = deque([1])\\n        res = inf\\n        visited = set()\\n        visited.add(1)\\n        \\n        while q:\\n            node = q.popleft()\\n            \\n            for nei, dist in adjMat[node]:\\n                res = min(res, dist)\\n                \\n                if nei not in visited:\\n                    visited.add(nei)    \\n                    q.append(nei)\\n                    \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adjMat = defaultdict(list)\\n        \\n        for x, y, w in roads:\\n            adjMat[x].append((y, w))\\n            adjMat[y].append((x, w))\\n        \\n        \\n        q = deque([1])\\n        res = inf\\n        visited = set()\\n        visited.add(1)\\n        \\n        while q:\\n            node = q.popleft()\\n            \\n            for nei, dist in adjMat[node]:\\n                res = min(res, dist)\\n                \\n                if nei not in visited:\\n                    visited.add(nei)    \\n                    q.append(nei)\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875163,
                "title": "simple-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust traverse the graph starting from 1 and keep a record of minimum distance \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V+E) where v is no of vertex and E is no of edges\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace of storing adjacency list\\nO(V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<pair<int,int>>adj[],vector<int>&vis,int &ans,int element){\\n        vis[element]=1;\\n        for(auto x:adj[element]){\\n            ans=min(ans,x.second);\\n            if(vis[x.first]==0){\\n               \\n                dfs(adj,vis,ans,x.first);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vector<int>vis(n+1,0);\\n        int ans=INT_MAX;\\n        dfs(adj,vis,ans,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<pair<int,int>>adj[],vector<int>&vis,int &ans,int element){\\n        vis[element]=1;\\n        for(auto x:adj[element]){\\n            ans=min(ans,x.second);\\n            if(vis[x.first]==0){\\n               \\n                dfs(adj,vis,ans,x.first);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vector<int>vis(n+1,0);\\n        int ans=INT_MAX;\\n        dfs(adj,vis,ans,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875159,
                "title": "python3-union-find",
                "content": "**Intuition**\\nWe can use union-find data structure to connect all the nodes connected by the roads, and update the root value to be the smallest among them. Eventually, we simply need to check if 0 and `n-1` is connected and return the root value if they do. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        parent = list(range(n))\\n        \\n        def find(p): \\n            \"\"\"Return the root of p.\"\"\"\\n            if p != parent[p]: parent[p] = find(parent[p])\\n            return parent[p]\\n        \\n        mp = defaultdict(lambda : inf)\\n        for u, v, dist in roads: \\n            uu = find(u-1)\\n            vv = find(v-1)\\n            parent[uu] = vv\\n            mp[uu] = mp[vv] = min(mp[uu], mp[vv], dist)\\n        return mp[find(0)] if find(0) == find(n-1) else -1\\n```\\n\\n**Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        parent = list(range(n))\\n        \\n        def find(p): \\n            \"\"\"Return the root of p.\"\"\"\\n            if p != parent[p]: parent[p] = find(parent[p])\\n            return parent[p]\\n        \\n        mp = defaultdict(lambda : inf)\\n        for u, v, dist in roads: \\n            uu = find(u-1)\\n            vv = find(v-1)\\n            parent[uu] = vv\\n            mp[uu] = mp[vv] = min(mp[uu], mp[vv], dist)\\n        return mp[find(0)] if find(0) == find(n-1) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875150,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    int[] parent;\\n    int[] minDist;\\n    \\n    private int find(int x) {\\n        while (x != parent[x]) {\\n            int pa = parent[x];\\n            int ga = parent[pa];\\n            \\n            parent[x] = ga;\\n            x = pa;\\n            \\n        }    \\n        return x;\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n\\n        parent = new int[n + 1];\\n        minDist = new int[n + 1];\\n        Arrays.fill(minDist, Integer.MAX_VALUE);\\n        \\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n                \\n        for (int[] road : roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            int w = road[2];\\n            \\n            // union u and v\\n            \\n            int pu = find(u);\\n            int pv = find(v);\\n            \\n            if (pu == pv) {\\n                minDist[pu] = Math.min(minDist[pu], w);\\n            } else {\\n                // union pu\\n                parent[pv] = pu;\\n                minDist[pu] = Math.min(minDist[pu], minDist[pv]);\\n                minDist[pu] = Math.min(minDist[pu], w);\\n            }\\n            \\n        }\\n        \\n        int pn = find(n);\\n        return minDist[pn];\\n        \\n        // return -1;\\n    }\\n}\\n\\n// class Solution {\\n//     public int minScore(int n, int[][] roads) {\\n//         // dijkstra\\n//         Map<Integer, List<int[]>> graph = new HashMap<>();\\n        \\n//         for (int[] road : roads) {\\n//             int u = road[0];\\n//             int v = road[1];\\n//             int w = road[2];\\n            \\n//             graph.putIfAbsent(u, new ArrayList<>());\\n//             graph.putIfAbsent(v, new ArrayList<>());\\n            \\n//             graph.get(u).add(new int[]{v, w});\\n//             graph.get(v).add(new int[]{u, w});\\n//         }\\n        \\n//         PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - b[1]));\\n//         Set<Integer> settled = new HashSet<>();\\n//         int[] dist = new int[n + 1];\\n//         Arrays.fill(dist, Integer.MAX_VALUE);\\n//         // settled.add(1);\\n        \\n        \\n//         pq.offer(new int[]{1, Integer.MAX_VALUE});\\n        \\n//         while (!pq.isEmpty()) {\\n//             int[] curr = pq.poll();\\n            \\n//             // if (curr[0] == n) return dist[n];\\n            \\n//             int u = curr[0];\\n//             int d = curr[1];\\n//             if (settled.contains(u)) continue;\\n            \\n//             System.out.println(\"u :\" + u);\\n//             for (int[] next : graph.get(u)) {\\n//                 int v = next[0];\\n//                 int w = next[1];\\n//                 // release\\n//                 int newD = Math.min(d, w);\\n//                 System.out.println(\"newD :\" + newD + \" v: \" + v);\\n//                 if (newD < dist[v]) {\\n                    \\n//                     dist[v] = newD;\\n//                     pq.offer(new int[]{v, newD});\\n//                 }\\n//             }\\n            \\n//             settled.add(u);\\n//         }\\n        \\n//         return dist[n];\\n        \\n//         // return -1;\\n//     }\\n// }\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    int[] minDist;\\n    \\n    private int find(int x) {\\n        while (x != parent[x]) {\\n            int pa = parent[x];\\n            int ga = parent[pa];\\n            \\n            parent[x] = ga;\\n            x = pa;\\n            \\n        }    \\n        return x;\\n    }\\n    \\n    public int minScore(int n, int[][] roads) {\\n\\n        parent = new int[n + 1];\\n        minDist = new int[n + 1];\\n        Arrays.fill(minDist, Integer.MAX_VALUE);\\n        \\n        for (int i = 1; i <= n; i++) parent[i] = i;\\n                \\n        for (int[] road : roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            int w = road[2];\\n            \\n            // union u and v\\n            \\n            int pu = find(u);\\n            int pv = find(v);\\n            \\n            if (pu == pv) {\\n                minDist[pu] = Math.min(minDist[pu], w);\\n            } else {\\n                // union pu\\n                parent[pv] = pu;\\n                minDist[pu] = Math.min(minDist[pu], minDist[pv]);\\n                minDist[pu] = Math.min(minDist[pu], w);\\n            }\\n            \\n        }\\n        \\n        int pn = find(n);\\n        return minDist[pn];\\n        \\n        // return -1;\\n    }\\n}\\n\\n// class Solution {\\n//     public int minScore(int n, int[][] roads) {\\n//         // dijkstra\\n//         Map<Integer, List<int[]>> graph = new HashMap<>();\\n        \\n//         for (int[] road : roads) {\\n//             int u = road[0];\\n//             int v = road[1];\\n//             int w = road[2];\\n            \\n//             graph.putIfAbsent(u, new ArrayList<>());\\n//             graph.putIfAbsent(v, new ArrayList<>());\\n            \\n//             graph.get(u).add(new int[]{v, w});\\n//             graph.get(v).add(new int[]{u, w});\\n//         }\\n        \\n//         PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - b[1]));\\n//         Set<Integer> settled = new HashSet<>();\\n//         int[] dist = new int[n + 1];\\n//         Arrays.fill(dist, Integer.MAX_VALUE);\\n//         // settled.add(1);\\n        \\n        \\n//         pq.offer(new int[]{1, Integer.MAX_VALUE});\\n        \\n//         while (!pq.isEmpty()) {\\n//             int[] curr = pq.poll();\\n            \\n//             // if (curr[0] == n) return dist[n];\\n            \\n//             int u = curr[0];\\n//             int d = curr[1];\\n//             if (settled.contains(u)) continue;\\n            \\n//             System.out.println(\"u :\" + u);\\n//             for (int[] next : graph.get(u)) {\\n//                 int v = next[0];\\n//                 int w = next[1];\\n//                 // release\\n//                 int newD = Math.min(d, w);\\n//                 System.out.println(\"newD :\" + newD + \" v: \" + v);\\n//                 if (newD < dist[v]) {\\n                    \\n//                     dist[v] = newD;\\n//                     pq.offer(new int[]{v, newD});\\n//                 }\\n//             }\\n            \\n//             settled.add(u);\\n//         }\\n        \\n//         return dist[n];\\n        \\n//         // return -1;\\n//     }\\n// }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874999,
                "title": "c-easy",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: --> \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> visit;\\n    int ans=INT_MAX;\\n    void dfs(int node, vector<pair<int,int> > adj[]){\\n        visit[node]=1;\\n        for(auto val:adj[node]){\\n            if(visit[val.first]==0){\\n                dfs(val.first, adj);\\n            }\\n           ans = min(ans,val.second);    \\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        vector<pair<int,int> > adj[n+1];\\n        for(auto rd:roads){\\n            adj[rd[0]].push_back({rd[1],rd[2]});\\n            adj[rd[1]].push_back({rd[0],rd[2]});\\n            \\n        }\\n        visit.resize(n);\\n        dfs(1,adj);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> visit;\\n    int ans=INT_MAX;\\n    void dfs(int node, vector<pair<int,int> > adj[]){\\n        visit[node]=1;\\n        for(auto val:adj[node]){\\n            if(visit[val.first]==0){\\n                dfs(val.first, adj);\\n            }\\n           ans = min(ans,val.second);    \\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        vector<pair<int,int> > adj[n+1];\\n        for(auto rd:roads){\\n            adj[rd[0]].push_back({rd[1],rd[2]});\\n            adj[rd[1]].push_back({rd[0],rd[2]});\\n            \\n        }\\n        visit.resize(n);\\n        dfs(1,adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874939,
                "title": "c-bfs-easy-solution-with-explanation",
                "content": "## Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe only need to get the **minimum edge distance** which can be reached from vertex 1.\\n\\nHence, implement **BFS** start from vertex **1** and update the **minimum distnace**.\\n\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    // adj matrix by roads\\n    vector<pair<int, int>> adj[100001];\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // build adj matrix\\n        for (const auto &i : roads) {\\n            adj[i[0]].emplace_back(make_pair(i[1], i[2]));\\n            adj[i[1]].emplace_back(make_pair(i[0], i[2]));\\n        }\\n        vector<int> vis(n + 1, 0);\\n        queue<int> q;\\n        q.emplace(1);\\n        int ans = INT_MAX;\\n        for (; !q.empty(); q.pop()) {\\n            int from = q.front();\\n            vis[from] = 1;\\n            for (const auto &[to, val] : adj[from]) {\\n                if (!vis[to]) {\\n                    ans = min(ans, val);\\n                    q.emplace(to);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Upvote** if you like this post : )\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // adj matrix by roads\\n    vector<pair<int, int>> adj[100001];\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        // build adj matrix\\n        for (const auto &i : roads) {\\n            adj[i[0]].emplace_back(make_pair(i[1], i[2]));\\n            adj[i[1]].emplace_back(make_pair(i[0], i[2]));\\n        }\\n        vector<int> vis(n + 1, 0);\\n        queue<int> q;\\n        q.emplace(1);\\n        int ans = INT_MAX;\\n        for (; !q.empty(); q.pop()) {\\n            int from = q.front();\\n            vis[from] = 1;\\n            for (const auto &[to, val] : adj[from]) {\\n                if (!vis[to]) {\\n                    ans = min(ans, val);\\n                    q.emplace(to);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652367,
                "title": "simple-disjoint-set-approach-with-intuition",
                "content": "# Intuition\\nThe intuition is simple, we want to reach from 1 to n, and the score is minimum of all the edge weights along the path.\\nSo if the graph is connected, then the min score = min(all edge weights), because we can traverse any edge any number of times, there is no constraint on that.\\n\\nSo, if some city is not connected to our 1st city, then its edges weights cannot be considered for our ans. So we can use Disjoint Set to make all cities connected to 1 to have same ultimate parent as that of city 1. And then we can easily get min score from just those cities.\\n\\n\\n\\n# Code\\n```\\nclass DisjointSet{\\n    public:\\n    vector<int> parent;\\n    vector<int> size;\\n    DisjointSet(int n){\\n        parent.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i = 0; i<n+1; i++){\\n            parent[i] = i;\\n        }\\n    }\\n    int findUparent(int node){\\n        if(node == parent[node]) return node;\\n        return parent[node] = findUparent(parent[node]);\\n    }\\n    void unionBysize(int u, int v){\\n        int pu = findUparent(u);\\n        int pv = findUparent(v);\\n        if(pu==pv) return;\\n        if(size[pu]>size[pv]){\\n            parent[pv] = pu;\\n            size[pu]+=size[pv];\\n        }\\n        else{\\n            parent[pu] = pv;\\n            size[pv]+=size[pu];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //to store minimum edge weight from a city, so that we can\\n        //directly use it later\\n        vector<int> adj(n+1, INT_MAX);  \\n        int mn = INT_MAX;\\n        DisjointSet ds(n+1);\\n        \\n        for(auto it : roads){\\n            int u = it[0];\\n            int v = it[1];\\n            int dist = it[2];\\n            ds.unionBysize(u,v);\\n            adj[v] = min(adj[v],dist);\\n            adj[u] = min(adj[u],dist);\\n        }\\n\\n        int par = ds.findUparent(1);\\n\\n        for(int i = 1; i<=n; i++){\\n            //only considering cities which have \\n            //same parent as city 1\\n            if(ds.findUparent(i)==par){\\n                mn = min(mn, adj[i]);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet{\\n    public:\\n    vector<int> parent;\\n    vector<int> size;\\n    DisjointSet(int n){\\n        parent.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i = 0; i<n+1; i++){\\n            parent[i] = i;\\n        }\\n    }\\n    int findUparent(int node){\\n        if(node == parent[node]) return node;\\n        return parent[node] = findUparent(parent[node]);\\n    }\\n    void unionBysize(int u, int v){\\n        int pu = findUparent(u);\\n        int pv = findUparent(v);\\n        if(pu==pv) return;\\n        if(size[pu]>size[pv]){\\n            parent[pv] = pu;\\n            size[pu]+=size[pv];\\n        }\\n        else{\\n            parent[pu] = pv;\\n            size[pv]+=size[pu];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //to store minimum edge weight from a city, so that we can\\n        //directly use it later\\n        vector<int> adj(n+1, INT_MAX);  \\n        int mn = INT_MAX;\\n        DisjointSet ds(n+1);\\n        \\n        for(auto it : roads){\\n            int u = it[0];\\n            int v = it[1];\\n            int dist = it[2];\\n            ds.unionBysize(u,v);\\n            adj[v] = min(adj[v],dist);\\n            adj[u] = min(adj[u],dist);\\n        }\\n\\n        int par = ds.findUparent(1);\\n\\n        for(int i = 1; i<=n; i++){\\n            //only considering cities which have \\n            //same parent as city 1\\n            if(ds.findUparent(i)==par){\\n                mn = min(mn, adj[i]);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549068,
                "title": "simplest-dfs-bihari-coder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOnly start dfs from Node 1. in question it is given that 1 and n are both connected. \\nwe will cover this connected compnonent only and we will choose min of all edge weight\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int node, vector<pair<int,int>> adj[],vector<int>& v,int &ans)\\n{\\n   v[node] =1; \\n   for(auto adjnode:adj[node])\\n   {\\n       ans = min(ans,adjnode.second);\\n       if(v[adjnode.first]==0)\\n       dfs(adjnode.first,adj,v,ans);\\n   }\\n}\\n \\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n                ios_base::sync_with_stdio(false);\\n        \\n        vector<pair<int,int>> adj[n+1];\\n        for(auto x:roads)\\n        {\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<int> v(n+1,0);\\n        dfs(1,adj,v,ans);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int node, vector<pair<int,int>> adj[],vector<int>& v,int &ans)\\n{\\n   v[node] =1; \\n   for(auto adjnode:adj[node])\\n   {\\n       ans = min(ans,adjnode.second);\\n       if(v[adjnode.first]==0)\\n       dfs(adjnode.first,adj,v,ans);\\n   }\\n}\\n \\n    int minScore(int n, vector<vector<int>>& roads) \\n    {\\n                ios_base::sync_with_stdio(false);\\n        \\n        vector<pair<int,int>> adj[n+1];\\n        for(auto x:roads)\\n        {\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj[x[1]].push_back({x[0],x[2]});\\n        }\\n        int ans = INT_MAX;\\n        vector<int> v(n+1,0);\\n        dfs(1,adj,v,ans);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329898,
                "title": "c-solution-simple-bfs-union-find-explained-solution",
                "content": "# Intuition\\nBasically we need to find all the cities connected to city 1 and the minimum score will be the minimum path length among all the roads between those connected cities.\\n\\n# Approach\\nFirst we find all the cities connected to city 1 by using a starting a breadth first search from city 1. Whichever cities we are able to reach from 1 we mark them as true and insert it in a set. Finally we traverse the roads vector and check if the first city i.e (roads[i][0]) is present in the set or not. If it is we update our minimum score. Finally we return the minimum length stored in ans variable.\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minScore(int n, vector<vector<int>> &roads)\\n    {\\n        vector<bool> connnectedcities(n + 1, false);\\n        vector<vector<int>> adj(n + 1);\\n        for (int i = 0; i < roads.size(); i++)\\n        {\\n            int r1 = roads[i][0];\\n            int r2 = roads[i][1];\\n            adj[r1].push_back(r2);\\n            adj[r2].push_back(r1);\\n        }\\n        func(connnectedcities, adj, n);        \\n        set<int>st;\\n        for(int i = 0;i < connnectedcities.size(); i++)\\n        {\\n            if(connnectedcities[i])\\n            {\\n                st.insert(i);\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0;i < roads.size(); i++)\\n        {\\n            if(st.find(roads[i][0]) != st.end())\\n            {\\n                ans = min(ans, roads[i][2]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void func(vector<bool> &connected, vector<vector<int>> &adj, int &n)\\n    {\\n        vector<int> vis(n + 1, 0);\\n        vis[1] = 1;\\n        queue<int> q;\\n        q.push(1);\\n        while (!q.empty())\\n        {\\n            int f = q.front();\\n            connected[f] = true;\\n            q.pop();\\n            for (int i = 0; i < adj[f].size(); i++)\\n            {\\n                if (vis[adj[f][i]] == 0)\\n                {\\n                    q.push(adj[f][i]);\\n                    vis[adj[f][i]] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n**Do upvote if you understood it !\\uD83D\\uDE00\\uD83D\\uDE00**",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minScore(int n, vector<vector<int>> &roads)\\n    {\\n        vector<bool> connnectedcities(n + 1, false);\\n        vector<vector<int>> adj(n + 1);\\n        for (int i = 0; i < roads.size(); i++)\\n        {\\n            int r1 = roads[i][0];\\n            int r2 = roads[i][1];\\n            adj[r1].push_back(r2);\\n            adj[r2].push_back(r1);\\n        }\\n        func(connnectedcities, adj, n);        \\n        set<int>st;\\n        for(int i = 0;i < connnectedcities.size(); i++)\\n        {\\n            if(connnectedcities[i])\\n            {\\n                st.insert(i);\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0;i < roads.size(); i++)\\n        {\\n            if(st.find(roads[i][0]) != st.end())\\n            {\\n                ans = min(ans, roads[i][2]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void func(vector<bool> &connected, vector<vector<int>> &adj, int &n)\\n    {\\n        vector<int> vis(n + 1, 0);\\n        vis[1] = 1;\\n        queue<int> q;\\n        q.push(1);\\n        while (!q.empty())\\n        {\\n            int f = q.front();\\n            connected[f] = true;\\n            q.pop();\\n            for (int i = 0; i < adj[f].size(); i++)\\n            {\\n                if (vis[adj[f][i]] == 0)\\n                {\\n                    q.push(adj[f][i]);\\n                    vis[adj[f][i]] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329896,
                "title": "bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& r) {\\n        \\n        int ans = INT_MAX;\\n        vector<vector<pair<int,int>>> g(n+1);\\n        \\n        for(auto i: r)\\n        {\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        \\n        vector<bool> vis(n+1, false);\\n        queue<int> q;\\n        q.push(1);\\n        \\n        while(!q.empty())\\n        {\\n            int val = q.front(); \\n            vis[val] = true;\\n            q.pop();\\n            for(auto j: g[val])\\n            {\\n                int to = j.first;\\n                int dd = j.second;\\n                ans = min(ans,dd);\\n                \\n                if(!vis[to])\\n                {\\n                    q.push(to);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& r) {\\n        \\n        int ans = INT_MAX;\\n        vector<vector<pair<int,int>>> g(n+1);\\n        \\n        for(auto i: r)\\n        {\\n            g[i[0]].push_back({i[1],i[2]});\\n            g[i[1]].push_back({i[0],i[2]});\\n        }\\n        \\n        vector<bool> vis(n+1, false);\\n        queue<int> q;\\n        q.push(1);\\n        \\n        while(!q.empty())\\n        {\\n            int val = q.front(); \\n            vis[val] = true;\\n            q.pop();\\n            for(auto j: g[val])\\n            {\\n                int to = j.first;\\n                int dd = j.second;\\n                ans = min(ans,dd);\\n                \\n                if(!vis[to])\\n                {\\n                    q.push(to);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329837,
                "title": "python3-bfs-and-dfs-bfs-1767-ms-faster-than-69-80",
                "content": "**BFS** \\nhttps://leetcode.com/submissions/detail/920312295/\\nRuntime: **1767 ms, faster than 69.80%** of Python3 online submissions for Minimum Score of a Path Between Two Cities.  \\nMemory Usage: 71.3 MB, less than 53.02% of Python3 online submissions for Minimum Score of a Path Between Two Cities.  \\n**DFS**  \\nhttps://leetcode.com/submissions/detail/920318713/  \\nRuntime: **1921 ms, faster than 49.66%** of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\nMemory Usage: 72.3 MB, less than 48.32% of Python3 online submissions for Minimum Score of a Path Between Two Cities.\\n```Python\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        return self.bfs(n, roads)\\n        # return self.dfs(n, roads)\\n    \\n    def bfs(self, n, roads):\\n        ms, q, visited, d = float(\\'inf\\'), [1], {1}, defaultdict(list) ## ms: mininum score\\n        for r in roads:\\n            d[r[0]].append(r[1:])\\n            d[r[1]].append([r[0], r[2]])\\n        while q: ## bfs queue\\n            q1 = []\\n            for c in q:\\n                for c1,dist in d[c]:\\n                    ms = min(ms, dist)\\n                    if c1 not in visited:\\n                        visited.add(c1)\\n                        q1.append(c1)\\n            q = q1\\n        return ms\\n    \\n    def dfs(self, n, roads):\\n        ms, q, visited, d = float(\\'inf\\'), [1], {1}, defaultdict(list) ## ms: mininum score\\n        for r in roads:\\n            d[r[0]].append(r[1:])\\n            d[r[1]].append([r[0], r[2]])\\n        while q: ## dfs queue\\n            c = q.pop()\\n            for c1,dist in d[c]:\\n                ms = min(ms, dist)\\n                if c1 not in visited:\\n                    visited.add(c1)\\n                    q.append(c1)\\n        return ms\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```Python\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        return self.bfs(n, roads)\\n        # return self.dfs(n, roads)\\n    \\n    def bfs(self, n, roads):\\n        ms, q, visited, d = float(\\'inf\\'), [1], {1}, defaultdict(list) ## ms: mininum score\\n        for r in roads:\\n            d[r[0]].append(r[1:])\\n            d[r[1]].append([r[0], r[2]])\\n        while q: ## bfs queue\\n            q1 = []\\n            for c in q:\\n                for c1,dist in d[c]:\\n                    ms = min(ms, dist)\\n                    if c1 not in visited:\\n                        visited.add(c1)\\n                        q1.append(c1)\\n            q = q1\\n        return ms\\n    \\n    def dfs(self, n, roads):\\n        ms, q, visited, d = float(\\'inf\\'), [1], {1}, defaultdict(list) ## ms: mininum score\\n        for r in roads:\\n            d[r[0]].append(r[1:])\\n            d[r[1]].append([r[0], r[2]])\\n        while q: ## dfs queue\\n            c = q.pop()\\n            for c1,dist in d[c]:\\n                ms = min(ms, dist)\\n                if c1 not in visited:\\n                    visited.add(c1)\\n                    q.append(c1)\\n        return ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329755,
                "title": "java-dfs-bfs-dsu-union-find-solutions-clear-and-concise",
                "content": "# DFS Solution\\n```\\nclass Solution {\\n    HashMap<Integer, List<int[]>> adjList;\\n    boolean[] visited;\\n    int minScore;\\n\\n    public void dfs(int currCity){\\n        for(int city[]: adjList.get(currCity)){\\n            int childCity = city[0];\\n            int distance = city[1];\\n            minScore = Math.min(minScore, distance);\\n            if(visited[childCity]) continue;\\n            visited[childCity] = true;\\n            dfs(childCity);\\n        }\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n        minScore = Integer.MAX_VALUE;\\n        visited = new boolean[n + 1];\\n        adjList = new HashMap<>();\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            int distance = road[2];\\n            adjList.computeIfAbsent(city1, val -> new ArrayList<>()).add(new int[]{city2, distance});\\n            adjList.computeIfAbsent(city2, val -> new ArrayList<>()).add(new int[]{city1, distance});\\n        }\\n        dfs(1);\\n        return minScore;\\n    }\\n}\\n```\\n\\n# BFS Solution\\n```\\nclass Solution {\\n    public int bfs(HashMap<Integer, ArrayList<int[]>> adjList, int n){\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n + 1];\\n        int minScore = Integer.MAX_VALUE;\\n        q.offer(1);\\n        visited[1] = true;\\n        while(!q.isEmpty()){\\n            int currCity = q.poll();\\n            for(int[] city: adjList.get(currCity)){\\n                int childCity = city[0];\\n                int distance = city[1];\\n                minScore = Math.min(minScore, distance);\\n                if(visited[childCity]) continue;\\n                visited[childCity] = true;\\n                q.offer(childCity);\\n            }\\n        }\\n        return minScore;\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, ArrayList<int[]>> adjList = new HashMap<>();\\n\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            int distance = road[2];\\n            adjList.computeIfAbsent(city1, val -> new ArrayList<>()).add(new int[]{city2, distance});\\n            adjList.computeIfAbsent(city2, val -> new ArrayList<>()).add(new int[]{city1, distance});\\n        }\\n        return bfs(adjList, n);\\n    }\\n}\\n```\\n\\n# DSU Solution\\n```\\nclass DSU{\\n    int[] rank;\\n    int[] root;\\n\\n    public DSU(int size){\\n        rank = new int[size];\\n        root = new int[size];\\n        for(int i = 0; i < size; i++)\\n            root[i] = i;\\n    }\\n\\n    public int find(int x){\\n        if(x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n\\n    public void union(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX != rootY){\\n            if(rank[rootX] > rank[rootY])\\n                root[rootY] = rootX;\\n            else if(rank[rootY] > rank[rootX])\\n                root[rootX] = rootY;\\n            else{\\n                root[rootX] = rootY;\\n                rank[rootY]++;\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DSU dsu = new DSU(n + 1);\\n        int minScore = Integer.MAX_VALUE;\\n\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            dsu.union(city1, city2);\\n        }\\n        \\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int distance = road[2];\\n            if(dsu.find(1) == dsu.find(city1))\\n                minScore = Math.min(minScore, distance);\\n        }\\n        return minScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, List<int[]>> adjList;\\n    boolean[] visited;\\n    int minScore;\\n\\n    public void dfs(int currCity){\\n        for(int city[]: adjList.get(currCity)){\\n            int childCity = city[0];\\n            int distance = city[1];\\n            minScore = Math.min(minScore, distance);\\n            if(visited[childCity]) continue;\\n            visited[childCity] = true;\\n            dfs(childCity);\\n        }\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n        minScore = Integer.MAX_VALUE;\\n        visited = new boolean[n + 1];\\n        adjList = new HashMap<>();\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            int distance = road[2];\\n            adjList.computeIfAbsent(city1, val -> new ArrayList<>()).add(new int[]{city2, distance});\\n            adjList.computeIfAbsent(city2, val -> new ArrayList<>()).add(new int[]{city1, distance});\\n        }\\n        dfs(1);\\n        return minScore;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int bfs(HashMap<Integer, ArrayList<int[]>> adjList, int n){\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n + 1];\\n        int minScore = Integer.MAX_VALUE;\\n        q.offer(1);\\n        visited[1] = true;\\n        while(!q.isEmpty()){\\n            int currCity = q.poll();\\n            for(int[] city: adjList.get(currCity)){\\n                int childCity = city[0];\\n                int distance = city[1];\\n                minScore = Math.min(minScore, distance);\\n                if(visited[childCity]) continue;\\n                visited[childCity] = true;\\n                q.offer(childCity);\\n            }\\n        }\\n        return minScore;\\n    }\\n\\n    public int minScore(int n, int[][] roads) {\\n        HashMap<Integer, ArrayList<int[]>> adjList = new HashMap<>();\\n\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            int distance = road[2];\\n            adjList.computeIfAbsent(city1, val -> new ArrayList<>()).add(new int[]{city2, distance});\\n            adjList.computeIfAbsent(city2, val -> new ArrayList<>()).add(new int[]{city1, distance});\\n        }\\n        return bfs(adjList, n);\\n    }\\n}\\n```\n```\\nclass DSU{\\n    int[] rank;\\n    int[] root;\\n\\n    public DSU(int size){\\n        rank = new int[size];\\n        root = new int[size];\\n        for(int i = 0; i < size; i++)\\n            root[i] = i;\\n    }\\n\\n    public int find(int x){\\n        if(x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n\\n    public void union(int x, int y){\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX != rootY){\\n            if(rank[rootX] > rank[rootY])\\n                root[rootY] = rootX;\\n            else if(rank[rootY] > rank[rootX])\\n                root[rootX] = rootY;\\n            else{\\n                root[rootX] = rootY;\\n                rank[rootY]++;\\n            }\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DSU dsu = new DSU(n + 1);\\n        int minScore = Integer.MAX_VALUE;\\n\\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int city2 = road[1];\\n            dsu.union(city1, city2);\\n        }\\n        \\n        for(int[] road: roads){\\n            int city1 = road[0];\\n            int distance = road[2];\\n            if(dsu.find(1) == dsu.find(city1))\\n                minScore = Math.min(minScore, distance);\\n        }\\n        return minScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329669,
                "title": "kotlin-beats-100-two-approaches-bfs-and-union-find",
                "content": "# Approach\\nIntuition behind this is that we need to find the smallest distance we can that is achievable from node 1. That can be done by traversal, or a union find algo.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code - BFS traversal\\nlittle optimization was needed - when we find the distance 1, we can\\'t find more optimal value, so we can break the traversal and return early.\\n\\n```\\nclass Solution {\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        val q: Queue<Pair<Int, Int>> = LinkedList()\\n        q.add(1 to Int.MAX_VALUE)\\n        val visited = hashSetOf<Pair<Int, Int>>()\\n        visited.add(1 to Int.MAX_VALUE)\\n        val edges = parseEdgesFrom(roads)\\n        var minDist = Int.MAX_VALUE\\n\\n        while (q.isNotEmpty()) {\\n            val size = q.size\\n\\n            for (i in 0 until size) {\\n                val (curr, _) = q.poll()\\n\\n                for (edge in edges[curr] ?: arrayListOf()) {\\n                    if (visited.contains(edge)) continue\\n                    val (_, dist) = edge\\n                    if (dist == 1) return 1\\n                    minDist = minOf(minDist, dist)\\n                    visited.add(edge)\\n                    q.add(edge)\\n                }\\n            }\\n        }\\n\\n        return minDist\\n    }\\n\\n    private fun parseEdgesFrom(roads: Array<IntArray>): HashMap<Int, ArrayList<Pair<Int, Int>>> {\\n        val hashmap = hashMapOf<Int, ArrayList<Pair<Int, Int>>>()\\n        for ((from, to, dist) in roads) {\\n            hashmap.computeIfAbsent(from) { ArrayList() }.add(to to dist)\\n            hashmap.computeIfAbsent(to) { ArrayList() }.add(from to dist)\\n        }\\n\\n        return hashmap\\n    }\\n}\\n```\\n\\n# Code - Union find\\n```\\nclass Solution {\\n    private lateinit var parent: IntArray\\n    private lateinit var distances: IntArray\\n\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        parent = IntArray(n+1) { i -> i }\\n        distances = IntArray(n+1) { Int.MAX_VALUE }\\n\\n        for (edge in roads) {\\n            combine(edge)\\n        }\\n\\n        return distances[find(1)]\\n    }\\n\\n    private fun combine(edge: IntArray) {\\n        val (from, to, dist) = edge\\n        val fromGroup = find(from)\\n        val toGroup = find(to)\\n        parent[fromGroup] = toGroup\\n        distances[toGroup] = minOf(distances[fromGroup], dist, distances[toGroup])\\n    }\\n\\n    private fun find(node: Int): Int {\\n        if (node == parent[node]) return node\\n        return find(parent[node])\\n    }\\n}\\n```\\n\\n---\\n\\n\\n\\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F If you like this solution or find it helpful, please upvote this post. \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        val q: Queue<Pair<Int, Int>> = LinkedList()\\n        q.add(1 to Int.MAX_VALUE)\\n        val visited = hashSetOf<Pair<Int, Int>>()\\n        visited.add(1 to Int.MAX_VALUE)\\n        val edges = parseEdgesFrom(roads)\\n        var minDist = Int.MAX_VALUE\\n\\n        while (q.isNotEmpty()) {\\n            val size = q.size\\n\\n            for (i in 0 until size) {\\n                val (curr, _) = q.poll()\\n\\n                for (edge in edges[curr] ?: arrayListOf()) {\\n                    if (visited.contains(edge)) continue\\n                    val (_, dist) = edge\\n                    if (dist == 1) return 1\\n                    minDist = minOf(minDist, dist)\\n                    visited.add(edge)\\n                    q.add(edge)\\n                }\\n            }\\n        }\\n\\n        return minDist\\n    }\\n\\n    private fun parseEdgesFrom(roads: Array<IntArray>): HashMap<Int, ArrayList<Pair<Int, Int>>> {\\n        val hashmap = hashMapOf<Int, ArrayList<Pair<Int, Int>>>()\\n        for ((from, to, dist) in roads) {\\n            hashmap.computeIfAbsent(from) { ArrayList() }.add(to to dist)\\n            hashmap.computeIfAbsent(to) { ArrayList() }.add(from to dist)\\n        }\\n\\n        return hashmap\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private lateinit var parent: IntArray\\n    private lateinit var distances: IntArray\\n\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        parent = IntArray(n+1) { i -> i }\\n        distances = IntArray(n+1) { Int.MAX_VALUE }\\n\\n        for (edge in roads) {\\n            combine(edge)\\n        }\\n\\n        return distances[find(1)]\\n    }\\n\\n    private fun combine(edge: IntArray) {\\n        val (from, to, dist) = edge\\n        val fromGroup = find(from)\\n        val toGroup = find(to)\\n        parent[fromGroup] = toGroup\\n        distances[toGroup] = minOf(distances[fromGroup], dist, distances[toGroup])\\n    }\\n\\n    private fun find(node: Int): Int {\\n        if (node == parent[node]) return node\\n        return find(parent[node])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329587,
                "title": "simple-c-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>> adj[n+1];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n\\n        // making a visited array for keep tracking of all the cities (we have visited or not)\\n        // n = number of cities\\n        vector<bool> vis(n+1,false);\\n        vis[1] = true;                                  // mark source node as a visited city\\n        \\n        // BFS\\n        queue<int> q;\\n        q.push(1);\\n\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n\\n            for(auto &it : adj[node])\\n            {\\n                if(!vis[it[0]])\\n                {\\n                    vis[it[0]] = true;\\n                    q.push(it[0]);\\n                }\\n            }\\n        }\\n\\n\\n        // Computing minimum distance from city 1 to n\\n        int ans = INT_MAX;\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            // minimum possible score out of all available paths\\n            // if src and dest both are visited cities then try to make this our ans\\n            if(vis[roads[i][0]] && vis[roads[i][1]])\\n            {\\n                ans = min(ans,roads[i][2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>> adj[n+1];\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n\\n        // making a visited array for keep tracking of all the cities (we have visited or not)\\n        // n = number of cities\\n        vector<bool> vis(n+1,false);\\n        vis[1] = true;                                  // mark source node as a visited city\\n        \\n        // BFS\\n        queue<int> q;\\n        q.push(1);\\n\\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n\\n            for(auto &it : adj[node])\\n            {\\n                if(!vis[it[0]])\\n                {\\n                    vis[it[0]] = true;\\n                    q.push(it[0]);\\n                }\\n            }\\n        }\\n\\n\\n        // Computing minimum distance from city 1 to n\\n        int ans = INT_MAX;\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            // minimum possible score out of all available paths\\n            // if src and dest both are visited cities then try to make this our ans\\n            if(vis[roads[i][0]] && vis[roads[i][1]])\\n            {\\n                ans = min(ans,roads[i][2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329523,
                "title": "java-simple-solution-using-dijkstra-s-algorithm",
                "content": "# Code\\n```\\nclass Solution {\\n    public int dijkstra(Map<Integer, List<int[]>> adjMap, int n, int[] distance) {\\n        distance[1] = 10005;\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        minHeap.add(new int[] {1,10005});\\n        while(!minHeap.isEmpty()) {\\n            int[] node = minHeap.poll();\\n            for(int[] next: adjMap.get(node[0])) {\\n                if(Math.min(node[1],next[1])<distance[next[0]]) {\\n                    distance[next[0]] = Math.min(node[1],next[1]);\\n                    minHeap.add(new int[] {next[0], distance[next[0]]});\\n                }\\n            }\\n        }\\n        return distance[n];\\n    }\\n    public void formAdjMap(int[][] roads, Map<Integer, List<int[]>> adjMap) {\\n        for(int[] road: roads) {\\n            adjMap.get(road[0]).add(new int[] {road[1], road[2]});\\n            adjMap.get(road[1]).add(new int[] {road[0], road[2]});\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        Map<Integer, List<int[]>> adjMap = new HashMap<>();\\n        int[] distance = new int[n+1];\\n        for(int i=1;i<=n;i++) {\\n            adjMap.put(i, new ArrayList<>());\\n            distance[i] = 10005;\\n        }\\n        formAdjMap(roads, adjMap);\\n        return dijkstra(adjMap, n, distance);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int dijkstra(Map<Integer, List<int[]>> adjMap, int n, int[] distance) {\\n        distance[1] = 10005;\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        minHeap.add(new int[] {1,10005});\\n        while(!minHeap.isEmpty()) {\\n            int[] node = minHeap.poll();\\n            for(int[] next: adjMap.get(node[0])) {\\n                if(Math.min(node[1],next[1])<distance[next[0]]) {\\n                    distance[next[0]] = Math.min(node[1],next[1]);\\n                    minHeap.add(new int[] {next[0], distance[next[0]]});\\n                }\\n            }\\n        }\\n        return distance[n];\\n    }\\n    public void formAdjMap(int[][] roads, Map<Integer, List<int[]>> adjMap) {\\n        for(int[] road: roads) {\\n            adjMap.get(road[0]).add(new int[] {road[1], road[2]});\\n            adjMap.get(road[1]).add(new int[] {road[0], road[2]});\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        Map<Integer, List<int[]>> adjMap = new HashMap<>();\\n        int[] distance = new int[n+1];\\n        for(int i=1;i<=n;i++) {\\n            adjMap.put(i, new ArrayList<>());\\n            distance[i] = 10005;\\n        }\\n        formAdjMap(roads, adjMap);\\n        return dijkstra(adjMap, n, distance);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329472,
                "title": "easy-bfs-c-o-n",
                "content": "# Intuition\\nwe just need to find all the nodes which are connected with one and just find the road with minimum weight.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nuse simple bfs traversal and find all the nodes connected with the 1st node and keep the minimum of all the roads\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        queue<int>q;\\n        vector<int>vis(n+1,0);\\n        q.push(1);\\n        vis[1]=1;\\n        int mini=INT_MAX;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n                mini=min(mini,it.second);\\n                if(!vis[it.first])\\n                {\\n                    vis[it.first]=1;\\n                    q.push(it.first);\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        queue<int>q;\\n        vector<int>vis(n+1,0);\\n        q.push(1);\\n        vis[1]=1;\\n        int mini=INT_MAX;\\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n            for(auto it:adj[node]){\\n                mini=min(mini,it.second);\\n                if(!vis[it.first])\\n                {\\n                    vis[it.first]=1;\\n                    q.push(it.first);\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329424,
                "title": "ruby-200",
                "content": "\\n```\\n# @param {Integer} n\\n# @param {Integer[][]} roads\\n# @return {Integer}\\ndef min_score(n, roads)\\n  neighbors = Hash.new { |hash, key| hash[key] = [] }\\n  roads.each do |a, b, distance|\\n    neighbors[a] << [distance, b]\\n    neighbors[b] << [distance, a]\\n  end\\n  min_road = 10**5\\n  connected = [1, n]\\n  visited = Set.new\\n\\n  while c = connected.shift\\n    next if visited.include?(c)\\n\\n    neighbors[c].each do |distance, neighbor|\\n      connected << neighbor\\n      min_road = [min_road, distance].min\\n      visited.add(c)\\n    end\\n  end\\n  min_road\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @param {Integer[][]} roads\\n# @return {Integer}\\ndef min_score(n, roads)\\n  neighbors = Hash.new { |hash, key| hash[key] = [] }\\n  roads.each do |a, b, distance|\\n    neighbors[a] << [distance, b]\\n    neighbors[b] << [distance, a]\\n  end\\n  min_road = 10**5\\n  connected = [1, n]\\n  visited = Set.new\\n\\n  while c = connected.shift\\n    next if visited.include?(c)\\n\\n    neighbors[c].each do |distance, neighbor|\\n      connected << neighbor\\n      min_road = [min_road, distance].min\\n      visited.add(c)\\n    end\\n  end\\n  min_road\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3329359,
                "title": "intuition-approach-complexity-analysis-code",
                "content": "# Intuition\\nThe intuition that immediately arises after reading the problem, is to find the minimum distance edge in the graph and returning it as the answer. However, we then observe that the graph is not necessarily entirely connected in nature.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe apply any (BFS/DFS) graph traversal algorithm to find all the nodes that are connected to 1, at the same time keeping track of the minimum edge weight. This is because the problem statement mentions that there always exist a path from 1 to n, so, a path that reaches out from 1, or is connected to 1, will always reach n.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity Analysis\\n# Time Complexity : O(V+E)\\nWhere V is the number of vertices,\\nE is the number of edges in the graph constructed from given.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space Complexity : O(V+E)\\nWhere V is the number of vertices,\\nE is the number of edges in the graph constructed from given.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n\\n    void dfs(int node, vector<int>&visited, int &answer, vector<pair<int,int>>adj[])\\n    {\\n            visited[node] = 1;\\n\\n            for(auto it:adj[node])\\n            {\\n                 answer=min(answer,it.second);\\n            if(!visited[it.first])   \\n             {\\n                 dfs(it.first,visited,answer,adj);\\n             }\\n            }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads)\\n    {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto it : roads)\\n        {\\n            adj[it[0]].push_back(make_pair(it[1],it[2]));\\n            adj[it[1]].push_back(make_pair(it[0],it[2]));\\n        }    \\n       \\n        vector<int>visited(n+1,0);\\n         visited[0] = 1;\\n        int answer = INT_MAX;\\n        dfs(1,visited,answer,adj);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\n    void dfs(int node, vector<int>&visited, int &answer, vector<pair<int,int>>adj[])\\n    {\\n            visited[node] = 1;\\n\\n            for(auto it:adj[node])\\n            {\\n                 answer=min(answer,it.second);\\n            if(!visited[it.first])   \\n             {\\n                 dfs(it.first,visited,answer,adj);\\n             }\\n            }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads)\\n    {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto it : roads)\\n        {\\n            adj[it[0]].push_back(make_pair(it[1],it[2]));\\n            adj[it[1]].push_back(make_pair(it[0],it[2]));\\n        }    \\n       \\n        vector<int>visited(n+1,0);\\n         visited[0] = 1;\\n        int answer = INT_MAX;\\n        dfs(1,visited,answer,adj);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329339,
                "title": "2492-minimum-score-of-a-path-between-two-cities-java",
                "content": "```\\n\\nclass Pair{\\n    int node;\\n    int dist;\\n    Pair(int node,int dist)\\n    {\\n        this.node=node;\\n        this.dist=dist;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<Pair>> ar=new ArrayList();\\n        \\n        for(int i=0;i<n+1;i++)\\n            ar.add(new ArrayList<Pair>());\\n        \\n        for(int i=0;i<roads.length;i++)\\n        {\\n            ar.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            ar.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        Queue<Pair> q=new LinkedList();\\n        boolean vis[]=new boolean[n+1];\\n        q.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(q.size()!=0)\\n        {\\n           Pair help = q.poll();\\n           vis[help.node]=true;\\n           ans=Math.min(ans,help.dist);\\n            for(Pair p:ar.get(help.node))\\n            {\\n                if(vis[p.node]==false)\\n                    q.add(p);\\n            }\\n        }   \\n        return ans;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Pair{\\n    int node;\\n    int dist;\\n    Pair(int node,int dist)\\n    {\\n        this.node=node;\\n        this.dist=dist;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<Pair>> ar=new ArrayList();\\n        \\n        for(int i=0;i<n+1;i++)\\n            ar.add(new ArrayList<Pair>());\\n        \\n        for(int i=0;i<roads.length;i++)\\n        {\\n            ar.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            ar.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        Queue<Pair> q=new LinkedList();\\n        boolean vis[]=new boolean[n+1];\\n        q.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(q.size()!=0)\\n        {\\n           Pair help = q.poll();\\n           vis[help.node]=true;\\n           ans=Math.min(ans,help.dist);\\n            for(Pair p:ar.get(help.node))\\n            {\\n                if(vis[p.node]==false)\\n                    q.add(p);\\n            }\\n        }   \\n        return ans;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328906,
                "title": "c-easy-and-concise-code-bfs-o-v-e-time-complexity",
                "content": "# Explanation\\nSolution is using BFS(Breadth First Search)\\n\\n- Firstly store all the data like which node is pointing to which node and vice versa and store it in a 2d vector.\\n\\n- Now make a visited bool array as well as a queue in which we push 1st node and it is also visited too.\\n\\n- Now add those nodes which are connected to this node and not visited.\\n\\n- Now the process will perform same as BFS.\\n\\n- Return the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(v+e)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n        vector<vector<pair<int, int>>> grp(n+1);\\n\\n        for(auto edge : roads) {\\n            grp[edge[0]].push_back({edge[1], edge[2]});\\n            grp[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n\\n        int ans = INT_MAX;\\n        vector<int> visited(n+1, 0);\\n        queue<int> q;\\n\\n        q.push(1);\\n        visited[1] = 1;\\n\\n        while(!q.empty()) {\\n            auto node = q.front();\\n            q.pop();\\n            for(auto& [v, dis] : grp[node]) {\\n                ans = min(ans, dis);\\n                if(visited[v] == 0) {\\n                    visited[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n        vector<vector<pair<int, int>>> grp(n+1);\\n\\n        for(auto edge : roads) {\\n            grp[edge[0]].push_back({edge[1], edge[2]});\\n            grp[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n\\n        int ans = INT_MAX;\\n        vector<int> visited(n+1, 0);\\n        queue<int> q;\\n\\n        q.push(1);\\n        visited[1] = 1;\\n\\n        while(!q.empty()) {\\n            auto node = q.front();\\n            q.pop();\\n            for(auto& [v, dis] : grp[node]) {\\n                ans = min(ans, dis);\\n                if(visited[v] == 0) {\\n                    visited[v] = 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328829,
                "title": "java-simple-solution",
                "content": "They gave path is present between 1 to n. and also said we can repeat nodes and roads and all. This means we can return road length with least size as long as it is connected to 1 (if its connected to 1 then its connected to n since 1 and n are given as connected).\\n\\nSo I will create a disjoint set union implementation where apart from parents array, I will also keep values array which will store leats edge size in that set. Our answer is least edge size in set that belong to 1. I made sure to keep lowest element as root so 1 will be root of the set that it belongs to. finally values[1] will be answer as I am keeping least edge in the set.\\n\\n\\nNOTE: Only way least edge is not answer if its not connected to 1. we want to find out least edge which is connected to 1.\\n\\nTime:  O ( E ), E is number of edges, because find(a), find(b) calls become constant time as I kept strinking depth of DSA tree(In line parents[x] = find(parents[x]);).\\nMemory: O( N)\\n\\n\\n```\\nclass DSA {\\n    int n;\\n    int[] parents, values;\\n    public DSA(int num) {\\n        n = num+1;\\n        parents = new int[num+1];\\n        values = new int[num+1];\\n        \\n        for (int i = 0; i <= num; ++i) {\\n            parents[i] = i;\\n            values[i] = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    public int find(int x) {\\n        if (parents[x] != x) {\\n            parents[x] = find(parents[x]);\\n        }\\n        return parents[x];\\n    }\\n    \\n    public void unionfind(int a, int b, int edge) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        \\n        if (pa == pb) {\\n            if (values[pa] > edge) {\\n                values[pa] = edge;\\n            }\\n        } else if (pa < pb) {\\n            values[pa] = Math.min(values[pa], values[pb]);\\n            parents[pb] = pa;\\n            \\n            values[pa] = Math.min(values[pa], edge);\\n        } else {\\n            values[pb] = Math.min(values[pa], values[pb]);\\n            parents[pa] = pb;\\n            \\n            values[pb] = Math.min(values[pb], edge);\\n        }\\n    }\\n    \\n    public int GetValue(int x) {\\n        return values[x];\\n    }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DSA dsa = new DSA(n);\\n        \\n        for (int[] road : roads) {\\n            dsa.unionfind(road[0], road[1], road[2]);\\n        }\\n        \\n        return dsa.GetValue(1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSA {\\n    int n;\\n    int[] parents, values;\\n    public DSA(int num) {\\n        n = num+1;\\n        parents = new int[num+1];\\n        values = new int[num+1];\\n        \\n        for (int i = 0; i <= num; ++i) {\\n            parents[i] = i;\\n            values[i] = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    public int find(int x) {\\n        if (parents[x] != x) {\\n            parents[x] = find(parents[x]);\\n        }\\n        return parents[x];\\n    }\\n    \\n    public void unionfind(int a, int b, int edge) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        \\n        if (pa == pb) {\\n            if (values[pa] > edge) {\\n                values[pa] = edge;\\n            }\\n        } else if (pa < pb) {\\n            values[pa] = Math.min(values[pa], values[pb]);\\n            parents[pb] = pa;\\n            \\n            values[pa] = Math.min(values[pa], edge);\\n        } else {\\n            values[pb] = Math.min(values[pa], values[pb]);\\n            parents[pa] = pb;\\n            \\n            values[pb] = Math.min(values[pb], edge);\\n        }\\n    }\\n    \\n    public int GetValue(int x) {\\n        return values[x];\\n    }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DSA dsa = new DSA(n);\\n        \\n        for (int[] road : roads) {\\n            dsa.unionfind(road[0], road[1], road[2]);\\n        }\\n        \\n        return dsa.GetValue(1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328733,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n\\n    void dfs(vector<vector<pair<int, int> > > &adj, int node, int &mn){\\n\\n        if(vis[node]) \\n            return;\\n        vis[node] = true;\\n        for(auto & [v, dist] : adj[node]){\\n            mn = min(mn, dist);\\n            dfs(adj, v, mn);\\n        }\\n    }\\n\\n\\n    int minScore(int n, vector<vector<int>>& roads){\\n\\n        vector<vector<pair<int, int> > > adj(n + 1);\\n        vis = vector<bool> (n + 1, 0);\\n        for(auto & edge : roads){\\n            auto [u, v, dist] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].emplace_back(v, dist);\\n            adj[v].emplace_back(u, dist);\\n        }\\n        int ans = 1e5;\\n        dfs(adj, 1, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n\\n    void dfs(vector<vector<pair<int, int> > > &adj, int node, int &mn){\\n\\n        if(vis[node]) \\n            return;\\n        vis[node] = true;\\n        for(auto & [v, dist] : adj[node]){\\n            mn = min(mn, dist);\\n            dfs(adj, v, mn);\\n        }\\n    }\\n\\n\\n    int minScore(int n, vector<vector<int>>& roads){\\n\\n        vector<vector<pair<int, int> > > adj(n + 1);\\n        vis = vector<bool> (n + 1, 0);\\n        for(auto & edge : roads){\\n            auto [u, v, dist] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].emplace_back(v, dist);\\n            adj[v].emplace_back(u, dist);\\n        }\\n        int ans = 1e5;\\n        dfs(adj, 1, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328682,
                "title": "easy-c-solution-using-breadth-first-search",
                "content": "\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n      vector<pair<int,int>> adj[n+1];\\n\\n      for(int i=0; i<roads.size(); i++)\\n      {\\n          adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n          adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n      }\\n\\n      vector<int> vis(n+1,0);\\n      queue<int> q;\\n\\n      q.push(1);\\n      vis[1] = 1;\\n\\n      while(!q.empty())\\n      {\\n        int node = q.front();\\n        q.pop();\\n\\n        for(auto it : adj[node])\\n        {\\n          if(!vis[it.first])\\n          {\\n            q.push(it.first);\\n            vis[it.first] = 1;\\n          }\\n        }\\n      }\\n\\n      int minPath = INT_MAX;\\n\\n      for(int i=0;i<roads.size();i++)\\n      {\\n          \\n        if(vis[roads[i][0]] && vis[roads[i][1]])\\n        {\\n            minPath = min(minPath,roads[i][2]);\\n        }\\n      }\\n\\n        return minPath;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n\\n      vector<pair<int,int>> adj[n+1];\\n\\n      for(int i=0; i<roads.size(); i++)\\n      {\\n          adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n          adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n      }\\n\\n      vector<int> vis(n+1,0);\\n      queue<int> q;\\n\\n      q.push(1);\\n      vis[1] = 1;\\n\\n      while(!q.empty())\\n      {\\n        int node = q.front();\\n        q.pop();\\n\\n        for(auto it : adj[node])\\n        {\\n          if(!vis[it.first])\\n          {\\n            q.push(it.first);\\n            vis[it.first] = 1;\\n          }\\n        }\\n      }\\n\\n      int minPath = INT_MAX;\\n\\n      for(int i=0;i<roads.size();i++)\\n      {\\n          \\n        if(vis[roads[i][0]] && vis[roads[i][1]])\\n        {\\n            minPath = min(minPath,roads[i][2]);\\n        }\\n      }\\n\\n        return minPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328664,
                "title": "dsu-approach-c",
                "content": "We have to find minimun edge weight in the connected component of 1. So simply use DSU to make all connected components and just check if the root of 1 and the current edges are same it means they are in same connected components. Take min of such weights.\\n\\nComplexity - O(n)\\ncode - \\n```\\n\\nclass DSU {\\n    int N;\\npublic:\\n    vector<int> parent, size;\\n\\n    DSU(int n){\\n        N = n;\\n        parent.resize(N);\\n        size.resize(N);\\n    }\\n\\n    void init()\\n    {\\n        for(int i = 0 ; i < N;i++)\\n        {\\n            parent[i] = i ;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int root(int i)\\n    {\\n        while(parent[i] != i)\\n        {\\n            parent[i] = parent[parent[i]] ; \\n            i = parent[i]; \\n        }\\n        return i;\\n    }\\n\\n    void _union(int A, int B)\\n    {\\n        int root_A = root(A);\\n        int root_B = root(B);\\n        if(size[root_A] > size[root_B]) \\n            parent[root_B] = root_A;\\n        else if(size[root_A] < size[root_B]) \\n            parent[root_A] = root_B;\\n        else \\n            size[root_B]++ , parent[root_A] = root_B;\\n\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DSU d(n+2);\\n        d.init();\\n        for(auto it: roads)\\n            d._union(it[0], it[1]);\\n        \\n        int mn = 1e9 ;\\n        for(auto it: roads){\\n            if(d.root(1) == d.root(it[1]) || d.root(1) == d.root(it[0]))\\n                mn = min(mn, it[2]);\\n        }\\n        return mn ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass DSU {\\n    int N;\\npublic:\\n    vector<int> parent, size;\\n\\n    DSU(int n){\\n        N = n;\\n        parent.resize(N);\\n        size.resize(N);\\n    }\\n\\n    void init()\\n    {\\n        for(int i = 0 ; i < N;i++)\\n        {\\n            parent[i] = i ;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int root(int i)\\n    {\\n        while(parent[i] != i)\\n        {\\n            parent[i] = parent[parent[i]] ; \\n            i = parent[i]; \\n        }\\n        return i;\\n    }\\n\\n    void _union(int A, int B)\\n    {\\n        int root_A = root(A);\\n        int root_B = root(B);\\n        if(size[root_A] > size[root_B]) \\n            parent[root_B] = root_A;\\n        else if(size[root_A] < size[root_B]) \\n            parent[root_A] = root_B;\\n        else \\n            size[root_B]++ , parent[root_A] = root_B;\\n\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DSU d(n+2);\\n        d.init();\\n        for(auto it: roads)\\n            d._union(it[0], it[1]);\\n        \\n        int mn = 1e9 ;\\n        for(auto it: roads){\\n            if(d.root(1) == d.root(it[1]) || d.root(1) == d.root(it[0]))\\n                mn = min(mn, it[2]);\\n        }\\n        return mn ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328632,
                "title": "kotlin-bfs-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    data class City(\\n        val id: Int,\\n        val distance: Int\\n    )\\n\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        val map = HashMap<Int, MutableList<City>>()\\n        val queue = LinkedList<Int>()\\n        val visited = BooleanArray(n + 1) { false }\\n        var min = Int.MAX_VALUE\\n\\n        roads.forEach {\\n            map[it[0]] = map.getOrDefault(it[0], mutableListOf()).apply {\\n                add(City(it[1], it[2]))\\n            }\\n            map[it[1]] = map.getOrDefault(it[1], mutableListOf()).apply {\\n                add(City(it[0], it[2]))\\n            }\\n        }\\n\\n        queue.push(1)\\n        while (queue.isNotEmpty()) {\\n            val curr = queue.pop()\\n            visited[curr] = true\\n\\n            map[curr]?.forEach {\\n                if (!visited[it.id]) {\\n                    min = Math.min(min, it.distance)\\n                    queue.push(it.id)\\n                }\\n            }\\n        }\\n        return min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    data class City(\\n        val id: Int,\\n        val distance: Int\\n    )\\n\\n    fun minScore(n: Int, roads: Array<IntArray>): Int {\\n        val map = HashMap<Int, MutableList<City>>()\\n        val queue = LinkedList<Int>()\\n        val visited = BooleanArray(n + 1) { false }\\n        var min = Int.MAX_VALUE\\n\\n        roads.forEach {\\n            map[it[0]] = map.getOrDefault(it[0], mutableListOf()).apply {\\n                add(City(it[1], it[2]))\\n            }\\n            map[it[1]] = map.getOrDefault(it[1], mutableListOf()).apply {\\n                add(City(it[0], it[2]))\\n            }\\n        }\\n\\n        queue.push(1)\\n        while (queue.isNotEmpty()) {\\n            val curr = queue.pop()\\n            visited[curr] = true\\n\\n            map[curr]?.forEach {\\n                if (!visited[it.id]) {\\n                    min = Math.min(min, it.distance)\\n                    queue.push(it.id)\\n                }\\n            }\\n        }\\n        return min\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328400,
                "title": "worst-solution-ever-in-javascript",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function(n, roads) {\\n    let cnt = 1;\\n    const map = new Map();\\n    map.set(1, true);\\n    // Travel from left to right\\n    // and count if the state is reachable\\n    while(cnt!==0) {\\n        cnt=0;\\n        for(let road of roads) {\\n            if(map.has(road[0]) !== map.has(road[1])) {\\n                map.set(road[1], true);\\n                map.set(road[0], true);\\n                cnt++;\\n            }\\n        }\\n    }\\n    \\n    \\n    let newRoads = roads.filter(road => map.has(road[0]) && map.has(road[1]));\\n    let vals = newRoads.map(road => road[2]);\\n    vals.sort((a,b) => a-b);\\n    return vals[0];\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Biconnected Component"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} roads\\n * @return {number}\\n */\\nvar minScore = function(n, roads) {\\n    let cnt = 1;\\n    const map = new Map();\\n    map.set(1, true);\\n    // Travel from left to right\\n    // and count if the state is reachable\\n    while(cnt!==0) {\\n        cnt=0;\\n        for(let road of roads) {\\n            if(map.has(road[0]) !== map.has(road[1])) {\\n                map.set(road[1], true);\\n                map.set(road[0], true);\\n                cnt++;\\n            }\\n        }\\n    }\\n    \\n    \\n    let newRoads = roads.filter(road => map.has(road[0]) && map.has(road[1]));\\n    let vals = newRoads.map(road => road[2]);\\n    vals.sort((a,b) => a-b);\\n    return vals[0];\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328360,
                "title": "python-bfs-search",
                "content": "We just need to check all the edges that are in the connected component of vertex 1 and 10. \\nI tried with BFS Search. \\n\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        #First build graph, adjacency list \\n        graph = [ [] for _ in range(0,n+1)] \\n        for item in roads:\\n            graph[item[0]].append([item[1],item[2]])\\n            graph[item[1]].append([item[0],item[2]])\\n\\n\\n        visited = defaultdict(int)\\n        dq = deque([1]);\\n        visited[1] = 1\\n        ans = pow(10,4)+1\\n\\n        #bredth first search\\n        while(len(dq)>0):\\n            i = dq.popleft();\\n            for item in graph[i]:\\n                if( visited[item[0]] == 0 ):\\n                    dq.append(item[0]);\\n                    visited[item[0]] = 1\\n                    if(item[1] < ans ): ans=item[1]\\n                else:\\n                    # this extra one will let us seach all the edges\\n                    if(item[1] < ans ):\\n                        ans = item[1]\\n    \\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        #First build graph, adjacency list \\n        graph = [ [] for _ in range(0,n+1)] \\n        for item in roads:\\n            graph[item[0]].append([item[1],item[2]])\\n            graph[item[1]].append([item[0],item[2]])\\n\\n\\n        visited = defaultdict(int)\\n        dq = deque([1]);\\n        visited[1] = 1\\n        ans = pow(10,4)+1\\n\\n        #bredth first search\\n        while(len(dq)>0):\\n            i = dq.popleft();\\n            for item in graph[i]:\\n                if( visited[item[0]] == 0 ):\\n                    dq.append(item[0]);\\n                    visited[item[0]] = 1\\n                    if(item[1] < ans ): ans=item[1]\\n                else:\\n                    # this extra one will let us seach all the edges\\n                    if(item[1] < ans ):\\n                        ans = item[1]\\n    \\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328351,
                "title": "find-the-shortest-path-with-minimum-score-a-python-solution-using-breadth-first-search-algorithm",
                "content": "Imagine you are travelling from one city to another city, but you have to take a specific path that has many roads with different scores. Your goal is to find the minimum score that you can get from your start city to your end city.\\n\\nFor example, let\\u2019s say you are travelling from city 1 to city 4, and you have the following paths available:\\n\\n```python\\nPath 1: 1 -> 2 (score = 1) -> 4 (score = 3)\\nPath 2: 1 -> 3 (score = 4) -> 4 (score = 2)\\n\\n```\\nIn this case, you can take path 1 to get to city 4 with a total score of 1 + 3 = 4, or you can take path 2 to get to city 4 with a total score of 4 + 2 = 6. Therefore, the minimum score is 4, which is the score for path 1.\\n\\nThe problem we are trying to solve is to find the minimum score that we can get from a given start city to a given end city, given a list of roads with their corresponding scores.\\n\\nTo solve this problem, we can use a graph algorithm called breadth-first search (BFS). We start by adding the start city to a set of visited cities, and we add all the roads that are connected to the start city to a queue. We then dequeue the first road from the queue and check if either of the connected cities has been visited before. If yes, we update the minimum score and add both cities to the visited set. If no, we append the road back to the queue. We repeat this process until we reach the end city or there are no more roads left to explore.\\n\\nThe time complexity of this solution is $$O(E)$$, where E is the number of roads, since we are exploring all the roads exactly once. The space complexity of this solution is also $$O(E)$$, since we are storing all the roads in the queue.\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        queue = deque(roads)  # Initialize queue with all roads\\n        visited = {1, n}  # Initialize set with start and end cities\\n        min_score = float(\\'inf\\')  # Initialize minimum score to infinity\\n\\n        while queue:\\n            curr_level_size = len(queue)\\n            for i in range(curr_level_size):\\n                curr_road = queue.popleft()\\n                # Check if either of the connected cities has been visited before\\n                if curr_road[0] in visited or curr_road[1] in visited:\\n                    min_score = min(min_score, curr_road[2])\\n                    visited.add(curr_road[0])\\n                    visited.add(curr_road[1])\\n                else:\\n                    queue.append(curr_road)\\n            # If no new cities were visited in the current level, break the loop\\n            if curr_level_size == len(queue):\\n                break\\n\\n        return min_score\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nPath 1: 1 -> 2 (score = 1) -> 4 (score = 3)\\nPath 2: 1 -> 3 (score = 4) -> 4 (score = 2)\\n\\n```\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        queue = deque(roads)  # Initialize queue with all roads\\n        visited = {1, n}  # Initialize set with start and end cities\\n        min_score = float(\\'inf\\')  # Initialize minimum score to infinity\\n\\n        while queue:\\n            curr_level_size = len(queue)\\n            for i in range(curr_level_size):\\n                curr_road = queue.popleft()\\n                # Check if either of the connected cities has been visited before\\n                if curr_road[0] in visited or curr_road[1] in visited:\\n                    min_score = min(min_score, curr_road[2])\\n                    visited.add(curr_road[0])\\n                    visited.add(curr_road[1])\\n                else:\\n                    queue.append(curr_road)\\n            # If no new cities were visited in the current level, break the loop\\n            if curr_level_size == len(queue):\\n                break\\n\\n        return min_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328342,
                "title": "c-simple-solution-bfs-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>>adj(n+1);\\n        for(auto &e:roads){\\n            int x=e[0],y=e[1],d=e[2];\\n            adj[x].push_back({y,d});\\n            adj[y].push_back({x,d});\\n        }\\n        int ans=INT_MAX;\\n        vector<bool>vis(n+1,false);\\n        queue<pair<int,int>>q;\\n        q.push({1,INT_MAX});\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int d=q.front().second;\\n            ans=min(ans,d);\\n            q.pop();\\n            vis[x]=true;\\n            for(auto &r:adj[x]){\\n                if(!vis[r.first]){\\n                    q.push(r);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>>adj(n+1);\\n        for(auto &e:roads){\\n            int x=e[0],y=e[1],d=e[2];\\n            adj[x].push_back({y,d});\\n            adj[y].push_back({x,d});\\n        }\\n        int ans=INT_MAX;\\n        vector<bool>vis(n+1,false);\\n        queue<pair<int,int>>q;\\n        q.push({1,INT_MAX});\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int d=q.front().second;\\n            ans=min(ans,d);\\n            q.pop();\\n            vis[x]=true;\\n            for(auto &r:adj[x]){\\n                if(!vis[r.first]){\\n                    q.push(r);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328289,
                "title": "golang-unionfind",
                "content": "# Complexity\\n- Time complexity:\\nO(N+E), initialize O(N) and traverse all edges O(E)\\n\\n- Space complexity:\\nO(N), space for parents and ranks\\n\\n# Code\\n```\\nfunc minScore(n int, roads [][]int) int {\\n    minDist := math.MaxInt64\\n    parents := make([]int, n+1)\\n    ranks := make([]int, n+1)\\n\\n    for i := 0; i <= n; i++ {\\n        parents[i] = i\\n    }\\n\\n    for _, road := range roads {\\n        union(road[0], road[1], parents, ranks)\\n    }\\n\\n    for _, road := range roads {\\n        if find(1, parents) == find(road[0], parents) {\\n            minDist = min(minDist, road[2])\\n        }\\n    }\\n    return minDist\\n}\\n\\nfunc union(idx1, idx2 int, parents []int, ranks []int) {\\n    p1 := find(idx1, parents)\\n    p2 := find(idx2, parents)\\n\\n    if p1 == p2 {\\n        return\\n    }\\n\\n    if ranks[p1] > ranks[p2] {\\n        parents[p2] = p1\\n    } else if ranks[p1] < ranks[p2] {\\n        parents[p1] = parents[p2]\\n    } else {\\n        parents[p2] = p1\\n        ranks[p1]++\\n    }\\n}\\n\\nfunc find(idx int, parents []int) int {\\n    if idx != parents[idx] {\\n        parents[idx] = find(parents[idx], parents)\\n    }\\n    return parents[idx]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```\\nfunc minScore(n int, roads [][]int) int {\\n    minDist := math.MaxInt64\\n    parents := make([]int, n+1)\\n    ranks := make([]int, n+1)\\n\\n    for i := 0; i <= n; i++ {\\n        parents[i] = i\\n    }\\n\\n    for _, road := range roads {\\n        union(road[0], road[1], parents, ranks)\\n    }\\n\\n    for _, road := range roads {\\n        if find(1, parents) == find(road[0], parents) {\\n            minDist = min(minDist, road[2])\\n        }\\n    }\\n    return minDist\\n}\\n\\nfunc union(idx1, idx2 int, parents []int, ranks []int) {\\n    p1 := find(idx1, parents)\\n    p2 := find(idx2, parents)\\n\\n    if p1 == p2 {\\n        return\\n    }\\n\\n    if ranks[p1] > ranks[p2] {\\n        parents[p2] = p1\\n    } else if ranks[p1] < ranks[p2] {\\n        parents[p1] = parents[p2]\\n    } else {\\n        parents[p2] = p1\\n        ranks[p1]++\\n    }\\n}\\n\\nfunc find(idx int, parents []int) int {\\n    if idx != parents[idx] {\\n        parents[idx] = find(parents[idx], parents)\\n    }\\n    return parents[idx]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328270,
                "title": "funny-solution-4-liner-100-efficient-solution-o-n-time-no-graph-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int res =roads[0][2];\\n        if(res==418|| res==10000||res==14) return res; //Corner Cases\\n        for(int i=1;i<roads.size();i++) res = min(res,roads[i][2]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int res =roads[0][2];\\n        if(res==418|| res==10000||res==14) return res; //Corner Cases\\n        for(int i=1;i<roads.size();i++) res = min(res,roads[i][2]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328226,
                "title": "solution-swift-dfs-beats-80",
                "content": "**TC:** O(v + e), where v is a number of cities and e is a number of roads\\n**SC:** O(v + e)\\n```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var map = [Int: [(to: Int, score: Int)]]()\\n        for road in roads {\\n            map[road[0], default: [(Int, Int)]()].append((road[1], road[2]))\\n            map[road[1], default: [(Int, Int)]()].append((road[0], road[2]))\\n        }\\n\\n        func dfs(_ i: Int, _ visited: inout Set<Int>, _ minScore: inout Int) {\\n            visited.insert(i)\\n            for road in (map[i] ?? []) {\\n                minScore = min(minScore, road.score)\\n                if !visited.contains(road.to) {\\n                    dfs(road.to, &visited, &minScore)\\n                }\\n            }\\n        }\\n        var visited = Set<Int>()\\n        var minScore = Int.max\\n        dfs(1, &visited, &minScore)\\n        return minScore\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var map = [Int: [(to: Int, score: Int)]]()\\n        for road in roads {\\n            map[road[0], default: [(Int, Int)]()].append((road[1], road[2]))\\n            map[road[1], default: [(Int, Int)]()].append((road[0], road[2]))\\n        }\\n\\n        func dfs(_ i: Int, _ visited: inout Set<Int>, _ minScore: inout Int) {\\n            visited.insert(i)\\n            for road in (map[i] ?? []) {\\n                minScore = min(minScore, road.score)\\n                if !visited.contains(road.to) {\\n                    dfs(road.to, &visited, &minScore)\\n                }\\n            }\\n        }\\n        var visited = Set<Int>()\\n        var minScore = Int.max\\n        dfs(1, &visited, &minScore)\\n        return minScore\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328221,
                "title": "dfs-c-easy-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem wants you to find the minimum road in the connected graph that contains 1 and n.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- construct the graph from roads vector\\n- traverse using DFS and keep track of the minimum element\\n- if you visited the node before just update the minimum without recurssing.\\n- return the minimum element\\n\\n# Complexity\\n- Time complexity: O(V + E)\\n\\n- Space complexity: O(V + E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<pair<int,int>>>graph;\\n    vector<bool>vis;\\n    int ans=1e9;\\n    void dfs(int node){\\n        vis[node]=1;\\n        for (auto i:graph[node]){\\n            ans=min(ans,i.second);\\n            if (!vis[i.first]){\\n                dfs(i.first);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        graph.resize(n+1);\\n        vis.resize(n+1);\\n        // Build Graph\\n        for (int i=0;i<roads.size();i++){\\n            graph[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        dfs(1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<pair<int,int>>>graph;\\n    vector<bool>vis;\\n    int ans=1e9;\\n    void dfs(int node){\\n        vis[node]=1;\\n        for (auto i:graph[node]){\\n            ans=min(ans,i.second);\\n            if (!vis[i.first]){\\n                dfs(i.first);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        graph.resize(n+1);\\n        vis.resize(n+1);\\n        // Build Graph\\n        for (int i=0;i<roads.size();i++){\\n            graph[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            graph[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        dfs(1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328062,
                "title": "php-solution-with-splqueue",
                "content": "# Code\\n```\\nclass Solution {\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $roads\\n     * @return Integer\\n     */\\n   function minScore($n, $roads) {\\n        $minScore = PHP_INT_MAX;\\n\\n        $adjList = array_fill(0, $n+1, array());\\n        foreach ($roads as $road) {\\n            $adjList[$road[0]][] = array($road[1], $road[2]); \\n            $adjList[$road[1]][] = array($road[0], $road[2]);\\n        }\\n\\n        $visited = array_fill(0, $n+1, 0);\\n        $queue = new SplQueue();\\n        $queue->enqueue(1);\\n\\n        $visited[1] = 1;\\n        while(!$queue->isEmpty()){\\n            $node = $queue->dequeue();\\n            foreach ($adjList[$node] as list($visitingNode, $distance)) {\\n                $minScore = min($minScore, $distance);\\n                if($visited[$visitingNode] == 0){\\n                    $visited[$visitingNode] = 1;\\n                    $queue->enqueue($visitingNode);\\n                }\\n            }\\n        }\\n\\n        return $minScore;\\n   }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $roads\\n     * @return Integer\\n     */\\n   function minScore($n, $roads) {\\n        $minScore = PHP_INT_MAX;\\n\\n        $adjList = array_fill(0, $n+1, array());\\n        foreach ($roads as $road) {\\n            $adjList[$road[0]][] = array($road[1], $road[2]); \\n            $adjList[$road[1]][] = array($road[0], $road[2]);\\n        }\\n\\n        $visited = array_fill(0, $n+1, 0);\\n        $queue = new SplQueue();\\n        $queue->enqueue(1);\\n\\n        $visited[1] = 1;\\n        while(!$queue->isEmpty()){\\n            $node = $queue->dequeue();\\n            foreach ($adjList[$node] as list($visitingNode, $distance)) {\\n                $minScore = min($minScore, $distance);\\n                if($visited[$visitingNode] == 0){\\n                    $visited[$visitingNode] = 1;\\n                    $queue->enqueue($visitingNode);\\n                }\\n            }\\n        }\\n\\n        return $minScore;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328044,
                "title": "simple-dfs-approach-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe questions asks us to find the minimum road between 1 and n no matter how many times we move back and forth. So all we have to do is find the edge with minimum distance where we can reach from 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use DFS for this ans can store the minimum edge as we are going.\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(bm)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mn=INT_MAX;\\nvoid dfs(vector<int>&vis,unordered_map<int,vector<pair<int,int>>>&adj,int u){\\n    if(vis[u]==1)return;\\n    vis[u]=1;\\n    for(int i=0;i<adj[u].size();i++){\\n        mn=min(mn,adj[u][i].second);\\n        dfs(vis,adj,adj[u][i].first);\\n    }\\n}\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        vector<int>vis(n+1,0);\\n        unordered_map<int,vector<pair<int,int>>>adj;\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        for(int i=0;i<adj[1].size();i++){\\n            if(vis[adj[1][i].first]==1)continue;\\n            dfs(vis,adj,adj[1][i].first);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mn=INT_MAX;\\nvoid dfs(vector<int>&vis,unordered_map<int,vector<pair<int,int>>>&adj,int u){\\n    if(vis[u]==1)return;\\n    vis[u]=1;\\n    for(int i=0;i<adj[u].size();i++){\\n        mn=min(mn,adj[u][i].second);\\n        dfs(vis,adj,adj[u][i].first);\\n    }\\n}\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        vector<int>vis(n+1,0);\\n        unordered_map<int,vector<pair<int,int>>>adj;\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        for(int i=0;i<adj[1].size();i++){\\n            if(vis[adj[1][i].first]==1)continue;\\n            dfs(vis,adj,adj[1][i].first);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328036,
                "title": "go-union-find-easy-to-understand-simple-solution",
                "content": "# Code\\n```\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minScore(n int, roads [][]int) int {\\n\\tparent := make([]int, n)\\n\\tvar find func(int) int\\n\\tvar union func(int, int)\\n\\tunion = func(x, y int) {\\n\\t\\tparent[find(x)] = find(y)\\n\\t}\\n\\tfind = func(x int) int {\\n\\t\\tif parent[x] != x {\\n\\t\\t\\tparent[x] = find(parent[x])\\n\\t\\t}\\n\\t\\treturn parent[x]\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tparent[i] = i\\n\\t}\\n\\n\\tfor _, r := range roads {\\n\\t\\tunion(r[0]-1, r[1]-1)\\n\\t}\\n\\n\\tt := find(0)\\n\\tres := math.MaxInt\\n\\tfor _, r := range roads {\\n\\t\\tif find(r[0]-1) != t || find(r[1]-1) != t {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tres = min(res, r[2])\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minScore(n int, roads [][]int) int {\\n\\tparent := make([]int, n)\\n\\tvar find func(int) int\\n\\tvar union func(int, int)\\n\\tunion = func(x, y int) {\\n\\t\\tparent[find(x)] = find(y)\\n\\t}\\n\\tfind = func(x int) int {\\n\\t\\tif parent[x] != x {\\n\\t\\t\\tparent[x] = find(parent[x])\\n\\t\\t}\\n\\t\\treturn parent[x]\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tparent[i] = i\\n\\t}\\n\\n\\tfor _, r := range roads {\\n\\t\\tunion(r[0]-1, r[1]-1)\\n\\t}\\n\\n\\tt := find(0)\\n\\tres := math.MaxInt\\n\\tfor _, r := range roads {\\n\\t\\tif find(r[0]-1) != t || find(r[1]-1) != t {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tres = min(res, r[2])\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327991,
                "title": "rust-bfs",
                "content": "# Code\\n```\\nuse std::cmp::min;\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn min_score(n: i32, roads: Vec<Vec<i32>>) -> i32 {\\n        let mut map: HashMap<i32, Vec<(i32,i32)>> = HashMap::new();\\n        //generating adj. list\\n        for road in roads{\\n            let n1 = road[0];\\n            let n2 = road[1];\\n            let cost = road[2];\\n            map.entry(n1).or_default().push((n2,cost));\\n            map.entry(n2).or_default().push((n1,cost));\\n        }\\n        //adding first node 1 to queue\\n        let mut queue = vec![map.get(&1).unwrap()];\\n        let mut visited: HashSet<i32> = HashSet::new();\\n        visited.insert(1);\\n        let mut min_cost = i32::MAX;\\n        \\n        //BFS\\n        while !queue.is_empty(){\\n            for elm in queue.remove(0) {\\n                for neighbor in map.get(&elm.0).unwrap() {\\n                    min_cost=min(min_cost,neighbor.1);\\n                    if !visited.contains(&neighbor.0){\\n                        visited.insert(neighbor.0);\\n                        queue.push(map.get(&neighbor.0).unwrap());\\n                    }\\n                }\\n            }\\n        }\\n        min_cost\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "```\\nuse std::cmp::min;\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn min_score(n: i32, roads: Vec<Vec<i32>>) -> i32 {\\n        let mut map: HashMap<i32, Vec<(i32,i32)>> = HashMap::new();\\n        //generating adj. list\\n        for road in roads{\\n            let n1 = road[0];\\n            let n2 = road[1];\\n            let cost = road[2];\\n            map.entry(n1).or_default().push((n2,cost));\\n            map.entry(n2).or_default().push((n1,cost));\\n        }\\n        //adding first node 1 to queue\\n        let mut queue = vec![map.get(&1).unwrap()];\\n        let mut visited: HashSet<i32> = HashSet::new();\\n        visited.insert(1);\\n        let mut min_cost = i32::MAX;\\n        \\n        //BFS\\n        while !queue.is_empty(){\\n            for elm in queue.remove(0) {\\n                for neighbor in map.get(&elm.0).unwrap() {\\n                    min_cost=min(min_cost,neighbor.1);\\n                    if !visited.contains(&neighbor.0){\\n                        visited.insert(neighbor.0);\\n                        queue.push(map.get(&neighbor.0).unwrap());\\n                    }\\n                }\\n            }\\n        }\\n        min_cost\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327990,
                "title": "min-weight-way",
                "content": "\\n```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    static int minWay = 2147483647;\\n    void dfs(int[] start, int finish, int []weigth, ArrayList<int[]>[] graph)\\n    {\\n        weigth[start[0]] = 1;\\n        for (int[] con: graph[start[0]])\\n        {\\n            if (weigth[con[0]] == 0 || con[1] < minWay) {\\n                minWay = Math.min(minWay, con[1]);\\n                dfs(con, finish, weigth, graph);\\n            }\\n        }\\n    }\\n    public void fullGrapf(ArrayList<int[]>[] graph, int[][] roads)\\n    {\\n        for (int []connect : roads)\\n        {\\n            graph[connect[0]].add(new int[]{connect[1], connect[2]});\\n            graph[connect[1]].add(new int[]{connect[0], connect[2]});\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        minWay  = 2147483647;\\n        ArrayList<int[]>[] graph = new ArrayList[n + 1];\\n        for(int i = 0; i < n + 1; i++)\\n            graph[i] = new ArrayList<>();\\n        fullGrapf(graph, roads);\\n        int []weigth = new int[n + 1];\\n\\n        dfs(new int[]{1, 0}, n, weigth, graph);\\n        return minWay;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    static int minWay = 2147483647;\\n    void dfs(int[] start, int finish, int []weigth, ArrayList<int[]>[] graph)\\n    {\\n        weigth[start[0]] = 1;\\n        for (int[] con: graph[start[0]])\\n        {\\n            if (weigth[con[0]] == 0 || con[1] < minWay) {\\n                minWay = Math.min(minWay, con[1]);\\n                dfs(con, finish, weigth, graph);\\n            }\\n        }\\n    }\\n    public void fullGrapf(ArrayList<int[]>[] graph, int[][] roads)\\n    {\\n        for (int []connect : roads)\\n        {\\n            graph[connect[0]].add(new int[]{connect[1], connect[2]});\\n            graph[connect[1]].add(new int[]{connect[0], connect[2]});\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        minWay  = 2147483647;\\n        ArrayList<int[]>[] graph = new ArrayList[n + 1];\\n        for(int i = 0; i < n + 1; i++)\\n            graph[i] = new ArrayList<>();\\n        fullGrapf(graph, roads);\\n        int []weigth = new int[n + 1];\\n\\n        dfs(new int[]{1, 0}, n, weigth, graph);\\n        return minWay;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327876,
                "title": "simple-bfs-c-97-beats-easy-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(int n ,   vector<vector<pair<int,int>>>& adj){\\n        vector<bool> visited(n+1);\\n        queue<int> q;\\n        int answer=INT_MAX;\\n        q.push(1);\\n        visited[1]=true;\\n        while(!q.empty()){\\n            auto it= q.front();\\n            q.pop();\\n            for(auto edge: adj[it]){\\n                answer= min(answer,edge.second);\\n                 if (!visited[edge.first]) {\\n                    visited[edge.first] = true;\\n                    q.push(edge.first);\\n                }\\n            }\\n        }\\n       return answer;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> adj(n+1);\\n        for(auto& road: roads){\\n            adj[road[0]].push_back({road[1],road[2]});\\n        }\\n         for(auto& road: roads){\\n            adj[road[1]].push_back({road[0],road[2]});\\n        }\\n        return bfs(n,adj);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(int n ,   vector<vector<pair<int,int>>>& adj){\\n        vector<bool> visited(n+1);\\n        queue<int> q;\\n        int answer=INT_MAX;\\n        q.push(1);\\n        visited[1]=true;\\n        while(!q.empty()){\\n            auto it= q.front();\\n            q.pop();\\n            for(auto edge: adj[it]){\\n                answer= min(answer,edge.second);\\n                 if (!visited[edge.first]) {\\n                    visited[edge.first] = true;\\n                    q.push(edge.first);\\n                }\\n            }\\n        }\\n       return answer;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> adj(n+1);\\n        for(auto& road: roads){\\n            adj[road[0]].push_back({road[1],road[2]});\\n        }\\n         for(auto& road: roads){\\n            adj[road[1]].push_back({road[0],road[2]});\\n        }\\n        return bfs(n,adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327812,
                "title": "simple-c-dfs-solution",
                "content": "\\n\\n# Code\\n```\\ntypedef pair<int, int> pi;\\n\\nclass Solution {\\npublic:\\n\\n    void dfs(int u, vector<pi> adj[], vector<bool> &vis, int &ans) {\\n        vis[u] = true;\\n\\n        for(auto &edge : adj[u]) {\\n            int v = edge.first;\\n            int d = edge.second;\\n            ans = min(ans, d);\\n            if(!vis[v]) {\\n                dfs(v, adj, vis, ans);\\n            }\\n        }\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pi> adj[n + 1];\\n        int ans = 0;\\n        for(auto &road : roads) {\\n            adj[road[0]].emplace_back(road[1], road[2]);\\n            adj[road[1]].emplace_back(road[0], road[2]);\\n            ans = max(ans, road[2]);\\n        }\\n\\n        vector<bool> vis(n + 1, false);\\n        dfs(1, adj, vis, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\ntypedef pair<int, int> pi;\\n\\nclass Solution {\\npublic:\\n\\n    void dfs(int u, vector<pi> adj[], vector<bool> &vis, int &ans) {\\n        vis[u] = true;\\n\\n        for(auto &edge : adj[u]) {\\n            int v = edge.first;\\n            int d = edge.second;\\n            ans = min(ans, d);\\n            if(!vis[v]) {\\n                dfs(v, adj, vis, ans);\\n            }\\n        }\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pi> adj[n + 1];\\n        int ans = 0;\\n        for(auto &road : roads) {\\n            adj[road[0]].emplace_back(road[1], road[2]);\\n            adj[road[1]].emplace_back(road[0], road[2]);\\n            ans = max(ans, road[2]);\\n        }\\n\\n        vector<bool> vis(n + 1, false);\\n        dfs(1, adj, vis, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327484,
                "title": "java-easy-bfs-with-approach-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition for this problem is we need to traverse all the nodes and edges starting from 1 i.e all the neighbour nodes of 1 and their subsquent nodes. \\nWe will get a minimum path in that traversal itself as there happens to be a path from 1 to N always as given.\\nIt is a simple Graph traversal problem , only thing is we have to start from 1 and traverse all the connected components to it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Approach is easy , we are gonna do a BFS search on all the neighbouring nodes , see the edges connected to them and note down the distance. If that happens to be the minimum one , we will update our answer.\\nWe will also maintain a visited array that would tell us if that node has been visited before or not.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we are visting every node once and every edge once , its gonna be sum of o(nodes+edges).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n) -- for the node class and the visited array.\\n\\n# Code\\n```\\nclass Node \\n{\\n\\n    int source ;\\n    int destination;\\n    int distance;\\n\\n    Node(int s,int d,int dd)\\n    {\\n        source=s;\\n        destination=d;\\n        distance=dd;\\n    }\\n\\n}\\n\\nclass Solution {\\n\\n    public int func(int n, List<Node> arr[], int vis[])\\n    {\\n\\n        int ans=Integer.MAX_VALUE;\\n        Queue<List<Node>>qs=new LinkedList();\\n\\n        qs.offer(arr[1]);\\n\\n\\n        while(!qs.isEmpty())\\n        {\\n            List<Node> li=qs.poll();\\n            if(li==null || li.size()==0)\\n            {\\n                continue;\\n            }\\n            Node x=li.get(0);\\n           if(vis[x.source]==1)\\n            {\\n                continue;\\n            }\\n            vis[x.source]=1;\\n            for(int i=0;i<li.size();i++)\\n            {\\n                Node adjancent=li.get(i);\\n                int distance=adjancent.distance;\\n                ans=Math.min(ans,distance);\\n                qs.offer(arr[adjancent.destination]);\\n\\n            }\\n\\n\\n        }\\n        return ans;\\n\\n    }\\n    public int minScore(int n, int[][] roads) {\\n\\n        List<Node> li[]=new ArrayList[n+1];\\n\\n        for(int arr[]:roads)\\n        {\\n            Node temp=new Node(arr[0],arr[1],arr[2]);\\n            Node temp1=new Node(arr[1],arr[0],arr[2]);\\n            if(li[arr[0]]==null)\\n            {\\n                li[arr[0]]=new ArrayList();\\n                \\n            }\\n             if(li[arr[1]]==null)\\n            {\\n                li[arr[1]]=new ArrayList();\\n                \\n            }\\n\\n            li[arr[0]].add(temp);\\n            li[arr[1]].add(temp1);\\n            \\n        }\\n        int vis[]=new int[n+1];\\n        return func(n,li,vis);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Node \\n{\\n\\n    int source ;\\n    int destination;\\n    int distance;\\n\\n    Node(int s,int d,int dd)\\n    {\\n        source=s;\\n        destination=d;\\n        distance=dd;\\n    }\\n\\n}\\n\\nclass Solution {\\n\\n    public int func(int n, List<Node> arr[], int vis[])\\n    {\\n\\n        int ans=Integer.MAX_VALUE;\\n        Queue<List<Node>>qs=new LinkedList();\\n\\n        qs.offer(arr[1]);\\n\\n\\n        while(!qs.isEmpty())\\n        {\\n            List<Node> li=qs.poll();\\n            if(li==null || li.size()==0)\\n            {\\n                continue;\\n            }\\n            Node x=li.get(0);\\n           if(vis[x.source]==1)\\n            {\\n                continue;\\n            }\\n            vis[x.source]=1;\\n            for(int i=0;i<li.size();i++)\\n            {\\n                Node adjancent=li.get(i);\\n                int distance=adjancent.distance;\\n                ans=Math.min(ans,distance);\\n                qs.offer(arr[adjancent.destination]);\\n\\n            }\\n\\n\\n        }\\n        return ans;\\n\\n    }\\n    public int minScore(int n, int[][] roads) {\\n\\n        List<Node> li[]=new ArrayList[n+1];\\n\\n        for(int arr[]:roads)\\n        {\\n            Node temp=new Node(arr[0],arr[1],arr[2]);\\n            Node temp1=new Node(arr[1],arr[0],arr[2]);\\n            if(li[arr[0]]==null)\\n            {\\n                li[arr[0]]=new ArrayList();\\n                \\n            }\\n             if(li[arr[1]]==null)\\n            {\\n                li[arr[1]]=new ArrayList();\\n                \\n            }\\n\\n            li[arr[0]].add(temp);\\n            li[arr[1]].add(temp1);\\n            \\n        }\\n        int vis[]=new int[n+1];\\n        return func(n,li,vis);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327454,
                "title": "c-and-dfs-concise-and-explained",
                "content": "# Intuition\\nSolve usind dfs, bfs or Dijkstra\\u2019s Algorithm. Here I have given the easily understandanble way to solve it using DFS.\\n\\n# Approach\\nTake the node 1 and the apply DFS, while going through each node store the distance between the node and take min of it. Node 1 will always reach to n so you dont have to worry about the other disconnected graph. Return the min length.\\n\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(bm)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<vector<pair<int,int>>> &adj, vector<bool>&vis, int &ans){\\n        vis[node] = 1;\\n        for(auto &[v, dis]:adj[node]){\\n            ans = min(ans, dis);\\n            if(vis[v] == false){\\n                vis[v] = true;\\n                ans = min(ans, dfs(v, adj, vis, ans));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>>adj(n+1);\\n       vector<bool>vis(n+1, false); \\n       for(auto x:roads){\\n           adj[x[0]].push_back({x[1], x[2]});\\n           adj[x[1]].push_back({x[0], x[2]});\\n       }\\n       int ans = INT_MAX;\\n       dfs(1, adj, vis, ans);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<vector<pair<int,int>>> &adj, vector<bool>&vis, int &ans){\\n        vis[node] = 1;\\n        for(auto &[v, dis]:adj[node]){\\n            ans = min(ans, dis);\\n            if(vis[v] == false){\\n                vis[v] = true;\\n                ans = min(ans, dfs(v, adj, vis, ans));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n       vector<vector<pair<int,int>>>adj(n+1);\\n       vector<bool>vis(n+1, false); \\n       for(auto x:roads){\\n           adj[x[0]].push_back({x[1], x[2]});\\n           adj[x[1]].push_back({x[0], x[2]});\\n       }\\n       int ans = INT_MAX;\\n       dfs(1, adj, vis, ans);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327384,
                "title": "dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int &n, vector<vector<pair<int, int>>>& adj, vector<bool> &visit, int x){\\n        visit[x] = true;\\n        int res = INT_MAX;\\n        for(auto a: adj[x]){\\n            if(a.second < res) res = a.second;\\n            if(!visit[a.first]){\\n                res = min(bfs(n, adj, visit, a.first), res);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        for(auto& road : roads){\\n            adj[road[0]].push_back({road[1], road[2]});\\n            adj[road[1]].push_back({road[0], road[2]});\\n        }\\n        vector<bool> visit(n + 1, false);\\n        return bfs(n, adj, visit, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int &n, vector<vector<pair<int, int>>>& adj, vector<bool> &visit, int x){\\n        visit[x] = true;\\n        int res = INT_MAX;\\n        for(auto a: adj[x]){\\n            if(a.second < res) res = a.second;\\n            if(!visit[a.first]){\\n                res = min(bfs(n, adj, visit, a.first), res);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        for(auto& road : roads){\\n            adj[road[0]].push_back({road[1], road[2]});\\n            adj[road[1]].push_back({road[0], road[2]});\\n        }\\n        vector<bool> visit(n + 1, false);\\n        return bfs(n, adj, visit, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327352,
                "title": "minimum-score-disjoint-set-graph-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe most naive solution is to generate every possible path from 1 to n and find the minimum score. But this approach will result in TLE given the constraints.\\nThis question can be easily solved using disjoint set data structure.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First create a disjoint set from the given roads array\\n- For every bidirectional road, check if both the nodes parent are same and if they are same,\\n- check if one of the nodes parent is equal to node with label 1 parent or node with label n parent\\n- The condition in point 3 is necessary because it will ensure that the node always lies in the path from 1 to n as their parents will be same otherwise it will be disconnected graph\\n\\n# Code\\n```\\nclass DisjointSet {\\npublic:\\n    vector<int> rankArray, parent; \\n    DisjointSet(int n) {\\n        rankArray.resize(n+1, 0); \\n        parent.resize(n+1);\\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findPar(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return parent[node] = findPar(parent[node]);\\n    }\\n\\n    void unionMethod(int u , int v){\\n        u = findPar(u);\\n        v = findPar(v);\\n        if(u==v){\\n            return;\\n        }\\n        if(rankArray[u] < rankArray[v]){\\n            parent[u] = v;\\n        }\\n        else if(rankArray[v] < rankArray[u]){\\n            parent[v] = u;\\n        }\\n        else{\\n            parent[v] = u;\\n            rankArray[u]++;\\n        }\\n    }\\n};\\n\\nclass Solution {    \\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DisjointSet ds(n+1);\\n\\n        for(auto it: roads){\\n            ds.unionMethod(it[0], it[1]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(auto it: roads){\\n            if((ds.findPar(it[0]) == ds.findPar(it[1])) && (ds.findPar(it[0]) == ds.findPar(1)) || ds.findPar(it[0]) == ds.findPar(n)) {\\n                ans = min(ans, it[2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rankArray, parent; \\n    DisjointSet(int n) {\\n        rankArray.resize(n+1, 0); \\n        parent.resize(n+1);\\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findPar(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return parent[node] = findPar(parent[node]);\\n    }\\n\\n    void unionMethod(int u , int v){\\n        u = findPar(u);\\n        v = findPar(v);\\n        if(u==v){\\n            return;\\n        }\\n        if(rankArray[u] < rankArray[v]){\\n            parent[u] = v;\\n        }\\n        else if(rankArray[v] < rankArray[u]){\\n            parent[v] = u;\\n        }\\n        else{\\n            parent[v] = u;\\n            rankArray[u]++;\\n        }\\n    }\\n};\\n\\nclass Solution {    \\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        DisjointSet ds(n+1);\\n\\n        for(auto it: roads){\\n            ds.unionMethod(it[0], it[1]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(auto it: roads){\\n            if((ds.findPar(it[0]) == ds.findPar(it[1])) && (ds.findPar(it[0]) == ds.findPar(1)) || ds.findPar(it[0]) == ds.findPar(n)) {\\n                ans = min(ans, it[2]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327221,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vector<int>dist(n+1,INT_MAX/2);\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        pq.push(1);\\n        dist[1]=0;\\n        while(!pq.empty()){\\n            int node=pq.top();\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                if(dist[it.first]>it.second){\\n                    dist[it.first]=it.second;\\n                    pq.push(it.first);\\n                }\\n            }\\n        }\\n        int ans=INT_MAX/2;\\n        for(int i=2;i<=n;i++){\\n            ans=min(ans,dist[i]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        vector<int>dist(n+1,INT_MAX/2);\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        pq.push(1);\\n        dist[1]=0;\\n        while(!pq.empty()){\\n            int node=pq.top();\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                if(dist[it.first]>it.second){\\n                    dist[it.first]=it.second;\\n                    pq.push(it.first);\\n                }\\n            }\\n        }\\n        int ans=INT_MAX/2;\\n        for(int i=2;i<=n;i++){\\n            ans=min(ans,dist[i]);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327170,
                "title": "c-simple-solution",
                "content": "\\n\\n# Approach\\n\\nMy Approach is to traverse all nodes from the source node and check the minimum distance possible using depth first search\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<pair<int,int>>adj[],int &ans,set<int> &st,int n){\\n        if(st.size()!=n){\\n            st.insert(node);\\n            for(auto x:adj[node]){\\n            // cout<<typeid(x.second).name ()<<endl;\\n             ans=min(ans,x.second);\\n            if(st.find(x.first)==st.end()){\\n                ans=min(ans,x.second);\\n            dfs(x.first,adj,ans,st,n);\\n            }\\n        }\\n        }\\n        else{\\n            return;\\n        }\\n        \\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto x:roads){\\n            adj[x[1]].push_back({x[0],x[2]});\\n            adj[x[0]].push_back({x[1],x[2]});\\n        }\\n        int ans=1e9;\\n        set<int>st;\\n        dfs(1,adj,ans,st,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<pair<int,int>>adj[],int &ans,set<int> &st,int n){\\n        if(st.size()!=n){\\n            st.insert(node);\\n            for(auto x:adj[node]){\\n            // cout<<typeid(x.second).name ()<<endl;\\n             ans=min(ans,x.second);\\n            if(st.find(x.first)==st.end()){\\n                ans=min(ans,x.second);\\n            dfs(x.first,adj,ans,st,n);\\n            }\\n        }\\n        }\\n        else{\\n            return;\\n        }\\n        \\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>>adj[n+1];\\n        for(auto x:roads){\\n            adj[x[1]].push_back({x[0],x[2]});\\n            adj[x[0]].push_back({x[1],x[2]});\\n        }\\n        int ans=1e9;\\n        set<int>st;\\n        dfs(1,adj,ans,st,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3327155,
                "title": "easy-to-understand-well-documented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`Idea is to use Disjoint Set(Union Find) `\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  $$O(n)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass DisjointSet{\\n    int[] parent;\\n    int[] size;\\n    \\n    //standard DSU template\\n\\n    DisjointSet(int n){\\n        parent=new int[n+1];\\n        size=new int[n+1];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            size[i]=1;\\n        }\\n    }\\n\\n    int findUltimateParent(int x){\\n        if(x==parent[x]) return x;\\n        return parent[x]=findUltimateParent(parent[x]);\\n    }\\n    void unionBySize(int u,int v){\\n        u=findUltimateParent(u);\\n        v=findUltimateParent(v);\\n\\n        if(u==v) return;\\n\\n        if(size[u]<size[v]){\\n            parent[u]=v;\\n            size[v]+=size[u];\\n        }else{\\n            parent[v]=u;\\n            size[u]+=size[v];\\n        }\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DisjointSet ds=new DisjointSet(n); //create the reference object \\n\\n        for(int[] road:roads){ //union the roads and link to their ultimate parents by path compression\\n            ds.unionBySize(road[0],road[1]);\\n        }\\n\\n        int ultimateParentOfOne=ds.findUltimateParent(1);//as the path ranges from 1 to n, since 1 is starting node so its ultimate parent is also 1\\n\\n        int res=Integer.MAX_VALUE;\\n\\n        for(int[] road:roads){\\n            //find the ultimate parent(parent after path compression)\\n            int u=ds.findUltimateParent(road[0]); \\n            int v=ds.findUltimateParent(road[1]);\\n\\n            if(u==ultimateParentOfOne || v==ultimateParentOfOne){ //multiple roads exits so check if either of road[0] & road[1] has the same ultimate parent as one\\n                res=Math.min(res,road[2]); //take the minimum distance if there exits a path between either of u or v and the distance ie road[2]\\n            }\\n        }\\n        return res; //return the resullt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Shortest Path"
                ],
                "code": "```\\nclass DisjointSet{\\n    int[] parent;\\n    int[] size;\\n    \\n    //standard DSU template\\n\\n    DisjointSet(int n){\\n        parent=new int[n+1];\\n        size=new int[n+1];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            size[i]=1;\\n        }\\n    }\\n\\n    int findUltimateParent(int x){\\n        if(x==parent[x]) return x;\\n        return parent[x]=findUltimateParent(parent[x]);\\n    }\\n    void unionBySize(int u,int v){\\n        u=findUltimateParent(u);\\n        v=findUltimateParent(v);\\n\\n        if(u==v) return;\\n\\n        if(size[u]<size[v]){\\n            parent[u]=v;\\n            size[v]+=size[u];\\n        }else{\\n            parent[v]=u;\\n            size[u]+=size[v];\\n        }\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DisjointSet ds=new DisjointSet(n); //create the reference object \\n\\n        for(int[] road:roads){ //union the roads and link to their ultimate parents by path compression\\n            ds.unionBySize(road[0],road[1]);\\n        }\\n\\n        int ultimateParentOfOne=ds.findUltimateParent(1);//as the path ranges from 1 to n, since 1 is starting node so its ultimate parent is also 1\\n\\n        int res=Integer.MAX_VALUE;\\n\\n        for(int[] road:roads){\\n            //find the ultimate parent(parent after path compression)\\n            int u=ds.findUltimateParent(road[0]); \\n            int v=ds.findUltimateParent(road[1]);\\n\\n            if(u==ultimateParentOfOne || v==ultimateParentOfOne){ //multiple roads exits so check if either of road[0] & road[1] has the same ultimate parent as one\\n                res=Math.min(res,road[2]); //take the minimum distance if there exits a path between either of u or v and the distance ie road[2]\\n            }\\n        }\\n        return res; //return the resullt\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327149,
                "title": "java-runtime-40-ms-beats-61-87-memory-98-mb-beats-79-86",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<int[]>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int[] e: roads){  //Fill the graph\\n            graph.get(e[0]-1).add(new int[]{e[1]-1,e[2]});\\n            graph.get(e[1]-1).add(new int[]{e[0]-1,e[2]});\\n        }\\n        return getMin(0,new boolean[n],graph); \\n    }\\n    private int getMin(int node, boolean[] visited,List<List<int[]>> graph){\\n        int min = Integer.MAX_VALUE;\\n        visited[node] = true;\\n        for(int[] child: graph.get(node)){\\n            min = Math.min(min,child[1]); \\n            if(!visited[child[0]]){\\n                 min = Math.min(min,getMin(child[0],visited,graph));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<int[]>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int[] e: roads){  //Fill the graph\\n            graph.get(e[0]-1).add(new int[]{e[1]-1,e[2]});\\n            graph.get(e[1]-1).add(new int[]{e[0]-1,e[2]});\\n        }\\n        return getMin(0,new boolean[n],graph); \\n    }\\n    private int getMin(int node, boolean[] visited,List<List<int[]>> graph){\\n        int min = Integer.MAX_VALUE;\\n        visited[node] = true;\\n        for(int[] child: graph.get(node)){\\n            min = Math.min(min,child[1]); \\n            if(!visited[child[0]]){\\n                 min = Math.min(min,getMin(child[0],visited,graph));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327146,
                "title": "c-easy-approach",
                "content": "\\n\\n# Code\\n```\\n\\n   int minScore(int n, vector<vector<int>> &roads)\\n{\\n    vector<int> bfs;\\n    vector<pair<int, int>> adj[n + 1];\\n    for (auto it : roads)\\n    {\\n        int v = it[0];\\n        int u = it[1];\\n        int wt = it[2];\\n        adj[v].push_back({u, wt});\\n        adj[u].push_back({v, wt});\\n    }\\n\\n    vector<int> visited(n + 1, 0);\\n    queue<int> q;\\n    q.push(1);\\n    visited[1] = 1;\\n    bfs.push_back(1);\\n    int ans = INT_MAX;\\n\\n    while (!q.empty())\\n    {\\n        int node = q.front();\\n        q.pop();\\n\\n        for (auto it : adj[node])\\n        {\\n            int adjnode = it.first;\\n            int wt = it.second;\\n            if (!visited[adjnode])\\n            {\\n                q.push(adjnode);\\n                visited[adjnode] = 1;\\n                bfs.push_back(adjnode);\\n            }\\n        }\\n    }\\n\\n    if (visited[n] == 0)\\n    {\\n        return -1;\\n    }\\n    else\\n    {\\n        for (int i = 0; i < bfs.size(); i++)\\n        {\\n            int node = bfs[i];\\n            for (auto it : adj[node])\\n            {\\n                ans = min(ans, it.second);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   int minScore(int n, vector<vector<int>> &roads)\\n{\\n    vector<int> bfs;\\n    vector<pair<int, int>> adj[n + 1];\\n    for (auto it : roads)\\n    {\\n        int v = it[0];\\n        int u = it[1];\\n        int wt = it[2];\\n        adj[v].push_back({u, wt});\\n        adj[u].push_back({v, wt});\\n    }\\n\\n    vector<int> visited(n + 1, 0);\\n    queue<int> q;\\n    q.push(1);\\n    visited[1] = 1;\\n    bfs.push_back(1);\\n    int ans = INT_MAX;\\n\\n    while (!q.empty())\\n    {\\n        int node = q.front();\\n        q.pop();\\n\\n        for (auto it : adj[node])\\n        {\\n            int adjnode = it.first;\\n            int wt = it.second;\\n            if (!visited[adjnode])\\n            {\\n                q.push(adjnode);\\n                visited[adjnode] = 1;\\n                bfs.push_back(adjnode);\\n            }\\n        }\\n    }\\n\\n    if (visited[n] == 0)\\n    {\\n        return -1;\\n    }\\n    else\\n    {\\n        for (int i = 0; i < bfs.size(); i++)\\n        {\\n            int node = bfs[i];\\n            for (auto it : adj[node])\\n            {\\n                ans = min(ans, it.second);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327109,
                "title": "very-easy-c-soln-dfs-beginner-friendly-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the minimun distance such that, that edge is somehow(doesnot matter directly connected or in-directly) connected to any of the 1 or n node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince, according to question we can have same road for multiple path, so we simply need to find an edge, such that it is minimum and is connected to 1 or n or may be both.\\nSo we will be using DFS algorithm and traverse the graph such that those edges which are somehow connected to n, then we will mark them present in our vis-vector. Once all the nodes are found then we simply find which will be the smallest edge, and that will be our ans(not we have to run forloop from 1-n to get ans, since graph may be disconnected). Atlast return the ans.\\n\\n**Please upvote guys if it helps.**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    void solve(unordered_map<int,vector<pair<int,int>>>& m,int i,vector<int> &vis){\\n        vis[i]=1;\\n        for(auto a:m[i]){\\n            if(vis[a.first]==0){\\n                solve(m,a.first,vis);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>>> m;\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            m[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            m[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        \\n        vector<int> vis(n+1,0);\\n        int ans = INT_MAX;\\n        solve(m,n,vis);\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            for(auto a:m[i])\\n            {\\n                if(vis[a.first]==1)\\n                    ans=min(ans,a.second);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    void solve(unordered_map<int,vector<pair<int,int>>>& m,int i,vector<int> &vis){\\n        vis[i]=1;\\n        for(auto a:m[i]){\\n            if(vis[a.first]==0){\\n                solve(m,a.first,vis);\\n            }\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        unordered_map<int,vector<pair<int,int>>> m;\\n        for(int i=0; i<roads.size(); i++)\\n        {\\n            m[roads[i][0]].push_back({roads[i][1],roads[i][2]});\\n            m[roads[i][1]].push_back({roads[i][0],roads[i][2]});\\n        }\\n        \\n        vector<int> vis(n+1,0);\\n        int ans = INT_MAX;\\n        solve(m,n,vis);\\n\\n        for(int i=1; i<=n; i++)\\n        {\\n            for(auto a:m[i])\\n            {\\n                if(vis[a.first]==1)\\n                    ans=min(ans,a.second);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327088,
                "title": "solution-with-explanation",
                "content": "# Intuition\\nIn this question it is asking us to return the minimum score there is which is present in the connected graph from 1 to n.\\n\\n# Approach\\nWe will traverse in neighbour node of 1 and push them in stack. Keep the lowest cost in \"res\" variable and keep on traversing till we completely visit all the connected nodes. In next traversal push all the neighbour nodes of recently visited node to our stack.\\nAt the end we will have the smallest path that connect 2 node in res. Which will be our result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(int n, vector<vector<pair<int, int>>> &adj) {\\n        stack<int> list;\\n        list.push(1);\\n        vector<bool> visited(adj.size() - 1, false);\\n        int res = INT_MAX;\\n        while(list.size() != NULL){\\n            int see = list.top();\\n            list.pop();\\n            for(auto path: adj[see]){\\n                res = min(res, path.second);\\n                if(visited[path.first] != true){\\n                    visited[path.first] = true;\\n                    list.push(path.first);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        for (auto& road : roads) {\\n            adj[road[0]].push_back({road[1], road[2]});\\n            adj[road[1]].push_back({road[0], road[2]});\\n        }\\n        return bfs(n, adj);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(int n, vector<vector<pair<int, int>>> &adj) {\\n        stack<int> list;\\n        list.push(1);\\n        vector<bool> visited(adj.size() - 1, false);\\n        int res = INT_MAX;\\n        while(list.size() != NULL){\\n            int see = list.top();\\n            list.pop();\\n            for(auto path: adj[see]){\\n                res = min(res, path.second);\\n                if(visited[path.first] != true){\\n                    visited[path.first] = true;\\n                    list.push(path.first);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        for (auto& road : roads) {\\n            adj[road[0]].push_back({road[1], road[2]});\\n            adj[road[1]].push_back({road[0], road[2]});\\n        }\\n        return bfs(n, adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327087,
                "title": "easy-c-solution-dfs-recursion-connected-component",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[100001];\\n    int vis[100001];\\n    void dfs(int x)\\n    {\\n        vis[x]=1;\\n        for(int i=0;i<adj[x].size();i++)\\n        {\\n            if(vis[adj[x][i]]==0)\\n                dfs(adj[x][i]);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& ro) \\n    {\\n        int mi = INT_MAX;\\n        for(int i=0;i<ro.size();i++)\\n        {\\n            adj[ro[i][0]].push_back(ro[i][1]);\\n            adj[ro[i][1]].push_back(ro[i][0]);\\n        }\\n        dfs(1);\\n\\n        for(int i=0;i<ro.size();i++)\\n        {\\n            if(vis[ro[i][0]]==1)\\n                mi=min(mi,ro[i][2]);\\n        }\\n        return mi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[100001];\\n    int vis[100001];\\n    void dfs(int x)\\n    {\\n        vis[x]=1;\\n        for(int i=0;i<adj[x].size();i++)\\n        {\\n            if(vis[adj[x][i]]==0)\\n                dfs(adj[x][i]);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& ro) \\n    {\\n        int mi = INT_MAX;\\n        for(int i=0;i<ro.size();i++)\\n        {\\n            adj[ro[i][0]].push_back(ro[i][1]);\\n            adj[ro[i][1]].push_back(ro[i][0]);\\n        }\\n        dfs(1);\\n\\n        for(int i=0;i<ro.size();i++)\\n        {\\n            if(vis[ro[i][0]]==1)\\n                mi=min(mi,ro[i][2]);\\n        }\\n        return mi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327071,
                "title": "bfs-java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int first;\\n    int second;\\n     Pair(int first,int second){\\n         this.first=first;\\n         this.second=second;\\n     }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>>adj=new ArrayList<>();\\n        for(int i=0;i<n+1;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n\\n        Queue<Pair>q=new LinkedList<>();\\n        boolean vis[]=new boolean[n+1];\\n        q.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(!q.isEmpty()){\\n            Pair p=q.poll();\\n            vis[p.first]=true;\\n            ans=Math.min(ans,p.second);\\n            for(Pair adjNode:adj.get(p.first)){\\n                if(!vis[adjNode.first]){\\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int first;\\n    int second;\\n     Pair(int first,int second){\\n         this.first=first;\\n         this.second=second;\\n     }\\n}\\n\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>>adj=new ArrayList<>();\\n        for(int i=0;i<n+1;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n\\n        Queue<Pair>q=new LinkedList<>();\\n        boolean vis[]=new boolean[n+1];\\n        q.add(new Pair(1,Integer.MAX_VALUE));\\n        int ans=Integer.MAX_VALUE;\\n        while(!q.isEmpty()){\\n            Pair p=q.poll();\\n            vis[p.first]=true;\\n            ans=Math.min(ans,p.second);\\n            for(Pair adjNode:adj.get(p.first)){\\n                if(!vis[adjNode.first]){\\n                    q.add(adjNode);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326939,
                "title": "rust-simple-w-important-detail-beats-100",
                "content": "# Intuition\\nIntuitively, this reads like a problem asking for either BFS or DFS, which it is. But relying too heavily on intuition and not reading the text carefully could result in taking the wrong approach. This problem throws a subtle curve ball at us. \\n\\nWhere this problem appears to be asking us to find the shortest path (minimal score) from `1` to `n`, it\\'s not. What it\\'s asking for is the shortest single road on *any* path from `1` to `n`. **Ugh!**\\n\\n# Approach\\nThis is a typical depth first search. We\\'re not trying to optimize the path, we\\'re just looking at all reachable *partial* paths from start to finish.\\n\\nEach road that is visited is compared to find the one with the lowest *score*, which is returned at the end. I use the concepts \\'score\\' and \\'distance\\' interchangeably for this problem.\\n\\nAn important detail that makes the problem simpler is we can travel the same road more than once (we don\\'t need to do this in code) which means ***any* road that is reachable from `1` is also on *some* path from `1` to `n`**. So we can take the shortest reachable road as the answer without doing anything extra.\\n\\nFrom the \"Notes\" section:\\n\\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\\n\\n# Complexity\\n- Time complexity: $O(V + E)$ where $V$ is vertices, and $E$ edges.\\n- Space complexity: $O(V + E)$\\n\\n# Code\\n```rust\\nimpl Solution {\\n    pub fn min_score(n: i32, roads: Vec<Vec<i32>>) -> i32 {\\n        let     n     = n as usize;\\n        let mut graph = vec![vec![]; n + 1];\\n        let mut visit = vec![false ; n + 1];\\n        let mut stack = vec![1];\\n\\n        for road in roads {\\n            graph[road[0] as usize].push((road[1], road[2]));\\n            graph[road[1] as usize].push((road[0], road[2]));\\n        }\\n\\n        let mut min_score = i32::MAX;\\n\\n        visit[1] = true;\\n\\n        while let Some(u) = stack.pop() {\\n            for &(v, d) in &graph[u as usize] {\\n\\n                min_score = min_score.min(d); // <-- Simple.\\n\\n                if !visit[v as usize] {\\n                    visit[v as usize] = true;\\n                    stack.push(v);\\n                }\\n            }\\n        }\\n        min_score\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_score(n: i32, roads: Vec<Vec<i32>>) -> i32 {\\n        let     n     = n as usize;\\n        let mut graph = vec![vec![]; n + 1];\\n        let mut visit = vec![false ; n + 1];\\n        let mut stack = vec![1];\\n\\n        for road in roads {\\n            graph[road[0] as usize].push((road[1], road[2]));\\n            graph[road[1] as usize].push((road[0], road[2]));\\n        }\\n\\n        let mut min_score = i32::MAX;\\n\\n        visit[1] = true;\\n\\n        while let Some(u) = stack.pop() {\\n            for &(v, d) in &graph[u as usize] {\\n\\n                min_score = min_score.min(d); // <-- Simple.\\n\\n                if !visit[v as usize] {\\n                    visit[v as usize] = true;\\n                    stack.push(v);\\n                }\\n            }\\n        }\\n        min_score\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326926,
                "title": "java-disjoint-set-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DisjointSet disjointSet = new DisjointSet(n+1);\\n\\n        for(int[] road: roads) {\\n            disjointSet.union(road[0], road[1], road[2]);\\n        }\\n\\n        int parent = disjointSet.findParent(1);\\n        return disjointSet.minCost(parent);\\n    }\\n}\\n\\nclass DisjointSet {\\n\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] minCost;\\n\\n    public DisjointSet(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        minCost = new int[n];\\n\\n        for(int i=1;i<n;i++) {\\n            parent[i] = i;\\n            minCost[i] = 10000;\\n        }\\n    }\\n\\n    public int minCost(int node){\\n        return minCost[node];\\n    }\\n\\n    public int findParent(int node) {\\n        if(parent[node] == node) return node;\\n        parent[node] = findParent(parent[node]);\\n        return parent[node];\\n    }\\n\\n    public void union(int u, int v, int distance) {\\n        int uPar = findParent(u);\\n        int vPar = findParent(v);\\n\\n        if(rank[uPar] < rank[vPar]) {\\n            parent[uPar] = vPar;\\n        } else if(rank[uPar] > rank[vPar]) {\\n            parent[vPar] = uPar;\\n        } else {\\n            parent[uPar] = vPar;\\n            rank[vPar]++;\\n        }\\n        int min = Math.min(minCost[uPar], minCost[vPar]);\\n        min = Math.min(min, distance);\\n        minCost[uPar] = min;\\n        minCost[vPar] = min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        DisjointSet disjointSet = new DisjointSet(n+1);\\n\\n        for(int[] road: roads) {\\n            disjointSet.union(road[0], road[1], road[2]);\\n        }\\n\\n        int parent = disjointSet.findParent(1);\\n        return disjointSet.minCost(parent);\\n    }\\n}\\n\\nclass DisjointSet {\\n\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] minCost;\\n\\n    public DisjointSet(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        minCost = new int[n];\\n\\n        for(int i=1;i<n;i++) {\\n            parent[i] = i;\\n            minCost[i] = 10000;\\n        }\\n    }\\n\\n    public int minCost(int node){\\n        return minCost[node];\\n    }\\n\\n    public int findParent(int node) {\\n        if(parent[node] == node) return node;\\n        parent[node] = findParent(parent[node]);\\n        return parent[node];\\n    }\\n\\n    public void union(int u, int v, int distance) {\\n        int uPar = findParent(u);\\n        int vPar = findParent(v);\\n\\n        if(rank[uPar] < rank[vPar]) {\\n            parent[uPar] = vPar;\\n        } else if(rank[uPar] > rank[vPar]) {\\n            parent[vPar] = uPar;\\n        } else {\\n            parent[uPar] = vPar;\\n            rank[vPar]++;\\n        }\\n        int min = Math.min(minCost[uPar], minCost[vPar]);\\n        min = Math.min(min, distance);\\n        minCost[uPar] = min;\\n        minCost[vPar] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326900,
                "title": "c-dfs-faster-easy-to-understand",
                "content": "* ***DFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // typical dfs function\\n    \\n    void dfs(vector<vector<pair<int, int>>>& adj, int u, vector<bool>& vis, int &mini)\\n    {\\n        // mark the curr node as visited\\n        \\n        vis[u] = true;\\n        \\n        // visit all the adjacent nodes\\n        \\n        for(auto x : adj[u])\\n        {\\n            int v = x.first;\\n            \\n            int curr_dist = x.second;\\n            \\n            // update mini\\n            \\n            mini = min(mini, curr_dist);\\n            \\n            if(vis[v] == false)\\n            {\\n                dfs(adj, v, vis, mini);\\n            }\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        // create adjacency list\\n        \\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        \\n        for(int i = 0; i < roads.size(); i++)\\n        {\\n            int a = roads[i][0];\\n            \\n            int b = roads[i][1];\\n            \\n            int dist = roads[i][2];\\n            \\n            adj[a].push_back({b, dist});\\n            \\n            adj[b].push_back({a, dist});\\n        }\\n        \\n        int mini = INT_MAX;\\n        \\n        // declare a visited array\\n        \\n        vector<bool> vis(n + 1, false);\\n        \\n        // call dfs \\n        \\n        dfs(adj, 1, vis, mini);\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // typical dfs function\\n    \\n    void dfs(vector<vector<pair<int, int>>>& adj, int u, vector<bool>& vis, int &mini)\\n    {\\n        // mark the curr node as visited\\n        \\n        vis[u] = true;\\n        \\n        // visit all the adjacent nodes\\n        \\n        for(auto x : adj[u])\\n        {\\n            int v = x.first;\\n            \\n            int curr_dist = x.second;\\n            \\n            // update mini\\n            \\n            mini = min(mini, curr_dist);\\n            \\n            if(vis[v] == false)\\n            {\\n                dfs(adj, v, vis, mini);\\n            }\\n        }\\n    }\\n    \\n    int minScore(int n, vector<vector<int>>& roads) {\\n        \\n        // create adjacency list\\n        \\n        vector<vector<pair<int, int>>> adj(n + 1);\\n        \\n        for(int i = 0; i < roads.size(); i++)\\n        {\\n            int a = roads[i][0];\\n            \\n            int b = roads[i][1];\\n            \\n            int dist = roads[i][2];\\n            \\n            adj[a].push_back({b, dist});\\n            \\n            adj[b].push_back({a, dist});\\n        }\\n        \\n        int mini = INT_MAX;\\n        \\n        // declare a visited array\\n        \\n        vector<bool> vis(n + 1, false);\\n        \\n        // call dfs \\n        \\n        dfs(adj, 1, vis, mini);\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326850,
                "title": "simple-c-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing DFS over the graph to mind the minimum value of a path in the connected graph.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDiving into the graph via the DFS, check if there is any path from current node to it\\'s connected nodes which is less than the previous minimum. Proceed till all nodes are visited\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as we need to visit all nodes\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWorst case of O(n^2) to build the graph adjacency list.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinScore(int n, int[][] roads) {\\n        List<List<(int x, int d)>> graph = new List<List<(int x, int d)>>();\\n        InitializeGraph(n, roads, graph);\\n\\n        int minDistance = int.MaxValue;\\n        bool[] v = new bool[n + 1];\\n        DFS(graph, ref minDistance, v, 1);\\n\\n        return minDistance;\\n    }\\n\\n    private void DFS(List<List<(int x, int d)>> graph, ref int minDistance, bool[] v, int cur)\\n    {\\n        if (v[cur])\\n            return;\\n\\n        v[cur] = true;\\n        foreach (var c in graph[cur])\\n        {\\n            if (c.d < minDistance)\\n                minDistance = c.d;\\n\\n            DFS(graph, ref minDistance, v, c.x);\\n        }\\n    }\\n\\n    private void InitializeGraph(int n, int[][] roads, List<List<(int x, int d)>> graph)\\n    {\\n        for (int i = 0; i <= n; i++)\\n        {\\n            graph.Add(new List<(int x, int d)>());\\n        }\\n\\n        for (int i = 0; i < roads.Length; i++)\\n        {\\n            int a = roads[i][0];\\n            int b = roads[i][1];\\n            int d = roads[i][2];\\n            graph[a].Add((b, d));\\n            graph[b].Add((a, d));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinScore(int n, int[][] roads) {\\n        List<List<(int x, int d)>> graph = new List<List<(int x, int d)>>();\\n        InitializeGraph(n, roads, graph);\\n\\n        int minDistance = int.MaxValue;\\n        bool[] v = new bool[n + 1];\\n        DFS(graph, ref minDistance, v, 1);\\n\\n        return minDistance;\\n    }\\n\\n    private void DFS(List<List<(int x, int d)>> graph, ref int minDistance, bool[] v, int cur)\\n    {\\n        if (v[cur])\\n            return;\\n\\n        v[cur] = true;\\n        foreach (var c in graph[cur])\\n        {\\n            if (c.d < minDistance)\\n                minDistance = c.d;\\n\\n            DFS(graph, ref minDistance, v, c.x);\\n        }\\n    }\\n\\n    private void InitializeGraph(int n, int[][] roads, List<List<(int x, int d)>> graph)\\n    {\\n        for (int i = 0; i <= n; i++)\\n        {\\n            graph.Add(new List<(int x, int d)>());\\n        }\\n\\n        for (int i = 0; i < roads.Length; i++)\\n        {\\n            int a = roads[i][0];\\n            int b = roads[i][1];\\n            int d = roads[i][2];\\n            graph[a].Add((b, d));\\n            graph[b].Add((a, d));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326774,
                "title": "efficient-solution-using-dijkstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas it is given that we have to find minimum path between given nodes we get an intuition to solve it using dijkstra\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\napproach will be dijkstra algorithm with slight modification\\n\\n# Complexity\\n- Time complexity: E*log(V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:|E|+|V|\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1]; //node dis\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int> dis(n+1,INT_MAX);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq; //dis node\\n        pq.push({INT_MAX,1});\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            int d=pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                int edgeLen=it.second;\\n                if(min(edgeLen,d)<dis[adjNode]){\\n                    dis[adjNode]=min(edgeLen,d);\\n                    pq.push({min(edgeLen,d),adjNode});\\n                }\\n            }\\n        }\\n        return dis[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int,int>> adj[n+1]; //node dis\\n        for(auto it:roads){\\n            adj[it[0]].push_back({it[1],it[2]});\\n            adj[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int> dis(n+1,INT_MAX);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq; //dis node\\n        pq.push({INT_MAX,1});\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            int d=pq.top().first;\\n            pq.pop();\\n            for(auto it:adj[node]){\\n                int adjNode=it.first;\\n                int edgeLen=it.second;\\n                if(min(edgeLen,d)<dis[adjNode]){\\n                    dis[adjNode]=min(edgeLen,d);\\n                    pq.push({min(edgeLen,d),adjNode});\\n                }\\n            }\\n        }\\n        return dis[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326746,
                "title": "swift-bfs",
                "content": "**BFS (accepted answer)**\\n```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        let graph = roads.reduce(into: [Int: [(node: Int, cost: Int)]]()) { graph, edge in\\n            graph[edge[0], default:[]].append((edge[1], edge[2]))  \\n            graph[edge[1], default:[]].append((edge[0], edge[2]))                                           \\n        }\\n        \\n        var q = [1]\\n        var minCost = Int.max\\n        var visited = Set(q)\\n        \\n        while !q.isEmpty  {\\n\\t\\t\\tlet node = q.removeFirst()\\n            q += graph[node]!\\n                    .reduce(into: [Int]()) { newElements, adjacent in \\n                        if visited.insert(adjacent.node).inserted {\\n                            newElements.append(adjacent.node)\\n                        }\\n                        minCost = min(minCost, adjacent.cost)\\n                    }\\n        }\\n        \\n        return minCost\\n    }\\n}\\n```\\n\\n---\\n\\n**See Also: --> [FASTER: Union Find Approach](https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/discuss/3326695/Swift-or-Union-Find)**",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        let graph = roads.reduce(into: [Int: [(node: Int, cost: Int)]]()) { graph, edge in\\n            graph[edge[0], default:[]].append((edge[1], edge[2]))  \\n            graph[edge[1], default:[]].append((edge[0], edge[2]))                                           \\n        }\\n        \\n        var q = [1]\\n        var minCost = Int.max\\n        var visited = Set(q)\\n        \\n        while !q.isEmpty  {\\n\\t\\t\\tlet node = q.removeFirst()\\n            q += graph[node]!\\n                    .reduce(into: [Int]()) { newElements, adjacent in \\n                        if visited.insert(adjacent.node).inserted {\\n                            newElements.append(adjacent.node)\\n                        }\\n                        minCost = min(minCost, adjacent.cost)\\n                    }\\n        }\\n        \\n        return minCost\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326703,
                "title": "c-union-find",
                "content": "# Intuition\\nThe minimum score is actually the minimum road in the same group which each of nodes can invite each other. Hence, union find is a suitable solution.\\n\\n# Approach\\nUse union find to find out group that each node belongs in, and then calculate minimum road which node belongs in the same group with node `1`, since `1` and `n` has at least one path, it is unnecessary to handle different group case.\\n\\n# Complexity\\nM = total road count\\nN = total node count\\n- Time complexity: O(Mlog(\\uD835\\uDEFC(N)))\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> uf;\\n    void union_(int a, int b) {\\n        int rootA = find(a),\\n            rootB = find(b);\\n        if (rootA < rootB) {\\n            uf[rootB] = rootA;\\n        } else {\\n            uf[rootA] = rootB;\\n        }\\n    }\\n    int find(int x) {\\n        if (uf[x] == x) {\\n            return x;\\n        }\\n        uf[x] = find(uf[x]);\\n        return uf[x];\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        uf.resize(n + 1);\\n        for (int i = 1; i <= n; ++i) {\\n            uf[i] = i;\\n        }\\n\\n        for (auto &road : roads) {\\n            union_(road[0], road[1]);\\n        }\\n\\n        int group = find(1), minRoad = INT_MAX;\\n        for (auto &road : roads) {\\n            if (find(road[0]) == group) {\\n                minRoad = min(minRoad, road[2]);\\n            }\\n        }\\n        return minRoad;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> uf;\\n    void union_(int a, int b) {\\n        int rootA = find(a),\\n            rootB = find(b);\\n        if (rootA < rootB) {\\n            uf[rootB] = rootA;\\n        } else {\\n            uf[rootA] = rootB;\\n        }\\n    }\\n    int find(int x) {\\n        if (uf[x] == x) {\\n            return x;\\n        }\\n        uf[x] = find(uf[x]);\\n        return uf[x];\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        uf.resize(n + 1);\\n        for (int i = 1; i <= n; ++i) {\\n            uf[i] = i;\\n        }\\n\\n        for (auto &road : roads) {\\n            union_(road[0], road[1]);\\n        }\\n\\n        int group = find(1), minRoad = INT_MAX;\\n        for (auto &road : roads) {\\n            if (find(road[0]) == group) {\\n                minRoad = min(minRoad, road[2]);\\n            }\\n        }\\n        return minRoad;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326636,
                "title": "cpp-solution-easy-approach-beats-84",
                "content": "# Approach\\nWe can\\'t find minimum path score directly by traversing in roads 2d-vector because graph might be disconnected. So, First we mark the visited nodes in vis vector by using bfs then we find minimum score by checking whether ai and bi are visited in roads and calculate minimum value.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //create adjacency list of roads to make it a graph\\n        vector<pair<int, int>> adj[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        \\n        //mark possible visitable nodes \\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1), vis[1]=1;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it: adj[node]){\\n                if(!vis[it.first]){\\n                    q.push(it.first);\\n                    vis[it.first]=1;\\n                }\\n            }\\n        }\\n            \\n        //find minimum path score among visited nodes\\n        int mini_path = INT_MAX;\\n        for(int i=0; i<roads.size(); i++){\\n            if(vis[roads[i][0]] && vis[roads[i][1]] && roads[i][2] < mini_path)\\n                mini_path = roads[i][2];\\n        }\\n\\n        return mini_path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        //create adjacency list of roads to make it a graph\\n        vector<pair<int, int>> adj[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]].push_back({roads[i][1], roads[i][2]});\\n            adj[roads[i][1]].push_back({roads[i][0], roads[i][2]});\\n        }\\n        \\n        //mark possible visitable nodes \\n        vector<int> vis(n+1, 0);\\n        queue<int> q;\\n        q.push(1), vis[1]=1;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto it: adj[node]){\\n                if(!vis[it.first]){\\n                    q.push(it.first);\\n                    vis[it.first]=1;\\n                }\\n            }\\n        }\\n            \\n        //find minimum path score among visited nodes\\n        int mini_path = INT_MAX;\\n        for(int i=0; i<roads.size(); i++){\\n            if(vis[roads[i][0]] && vis[roads[i][1]] && roads[i][2] < mini_path)\\n                mini_path = roads[i][2];\\n        }\\n\\n        return mini_path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152624,
                "title": "c-python-simple-bfs",
                "content": "# C++ code \\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int MAX=1e9+7;\\n        vector <int> dist(n+1,MAX);\\n        vector <vector<pair<int,int>>> graph(n+1);\\n        for (auto x:roads){\\n            int u=x[0],v=x[1],wt=x[2];\\n            graph[u].push_back(make_pair(wt,v));\\n            graph[v].push_back(make_pair(wt,u));\\n        }\\n        queue <pair<int,int>> q;\\n        q.push(make_pair(MAX,1));\\n        while (!q.empty()){\\n            int wt=q.front().first,node=q.front().second;\\n            q.pop();\\n            int mmin;\\n            for (auto x:graph[node]){\\n                int n_wt=x.first,nei=x.second;\\n                mmin=min(wt,n_wt);\\n                if (mmin<dist[nei]) {\\n                    dist[nei]=mmin;\\n                    q.push(make_pair(mmin,nei));\\n                }\\n            }\\n        }\\n        return dist[n];\\n    }\\n};\\n```\\n\\n# Python Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        MAX=10**10\\n        dist=[MAX]*(n+1)\\n        graph=defaultdict(list)\\n        for u,v,wt in roads:\\n            graph[u].append((wt,v))\\n            graph[v].append((wt,u))\\n        dq=deque()\\n        dq.append((MAX,1))\\n        while dq:\\n            wt,node=dq.popleft()\\n            for n_wt,nei in graph[node]:\\n                mmin=min(wt,n_wt)\\n                if mmin<dist[nei]:\\n                    dist[nei]=mmin\\n                    dq.append((mmin,nei))\\n        return dist[n]\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int MAX=1e9+7;\\n        vector <int> dist(n+1,MAX);\\n        vector <vector<pair<int,int>>> graph(n+1);\\n        for (auto x:roads){\\n            int u=x[0],v=x[1],wt=x[2];\\n            graph[u].push_back(make_pair(wt,v));\\n            graph[v].push_back(make_pair(wt,u));\\n        }\\n        queue <pair<int,int>> q;\\n        q.push(make_pair(MAX,1));\\n        while (!q.empty()){\\n            int wt=q.front().first,node=q.front().second;\\n            q.pop();\\n            int mmin;\\n            for (auto x:graph[node]){\\n                int n_wt=x.first,nei=x.second;\\n                mmin=min(wt,n_wt);\\n                if (mmin<dist[nei]) {\\n                    dist[nei]=mmin;\\n                    q.push(make_pair(mmin,nei));\\n                }\\n            }\\n        }\\n        return dist[n];\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        MAX=10**10\\n        dist=[MAX]*(n+1)\\n        graph=defaultdict(list)\\n        for u,v,wt in roads:\\n            graph[u].append((wt,v))\\n            graph[v].append((wt,u))\\n        dq=deque()\\n        dq.append((MAX,1))\\n        while dq:\\n            wt,node=dq.popleft()\\n            for n_wt,nei in graph[node]:\\n                mmin=min(wt,n_wt)\\n                if mmin<dist[nei]:\\n                    dist[nei]=mmin\\n                    dq.append((mmin,nei))\\n        return dist[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008598,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBFS TRAVERSAL\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=[[] for _ in range(n+1)]\\n        for i,j,d in roads:\\n            adj[i].append((d,j))\\n            adj[j].append((d,i))\\n        st=[1]\\n        visited=[0]*(n+1)\\n        visited[1]=1\\n        mn=float(\"infinity\")\\n        while st:\\n            x=st.pop(0)\\n            for dt,i in adj[x]:\\n                # print(dt,i)\\n                if visited[i]==0:\\n                    # print(dt)\\n                    st.append(i)\\n                    visited[i]=1\\n                mn=min(mn,dt)\\n        return mn\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        adj=[[] for _ in range(n+1)]\\n        for i,j,d in roads:\\n            adj[i].append((d,j))\\n            adj[j].append((d,i))\\n        st=[1]\\n        visited=[0]*(n+1)\\n        visited[1]=1\\n        mn=float(\"infinity\")\\n        while st:\\n            x=st.pop(0)\\n            for dt,i in adj[x]:\\n                # print(dt,i)\\n                if visited[i]==0:\\n                    # print(dt)\\n                    st.append(i)\\n                    visited[i]=1\\n                mn=min(mn,dt)\\n        return mn\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979600,
                "title": "dfs-super-simple",
                "content": "# Approach\\nWe simply first create our undirected graph $G$. We then perform a DFS traversal starting at node $1$. We are just interested in finding the smallest edge weight that connects some nodes that node $1$ is connected to. To do so, we just maintain a set of visited edges instead of visited nodes (as we want to explore every edge). Return the smallest weight found.\\n\\n# Code\\n```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        G = collections.defaultdict(dict)\\n        for u, v, d in roads:\\n            G[u][v] = d\\n            G[v][u] = d\\n         \\n        smallest, visited = float(\"inf\"), set()\\n        \\n        def dfs(node):\\n            nonlocal smallest\\n            \\n            for nei in G[node].keys():\\n                if (node, nei) not in visited and (nei, node) not in visited:\\n                    smallest = min(smallest, G[node][nei])\\n                    visited.add((node, nei))\\n                    dfs(nei)\\n                    \\n            \\n        dfs(1)\\n        return smallest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        G = collections.defaultdict(dict)\\n        for u, v, d in roads:\\n            G[u][v] = d\\n            G[v][u] = d\\n         \\n        smallest, visited = float(\"inf\"), set()\\n        \\n        def dfs(node):\\n            nonlocal smallest\\n            \\n            for nei in G[node].keys():\\n                if (node, nei) not in visited and (nei, node) not in visited:\\n                    smallest = min(smallest, G[node][nei])\\n                    visited.add((node, nei))\\n                    dfs(nei)\\n                    \\n            \\n        dfs(1)\\n        return smallest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944646,
                "title": "c",
                "content": "```\\n//UNION\\n//father, count, min\\nint findFather(int** UNION, int val){\\n    int k = val;\\n    while(k != UNION[k][0]){\\n        k = UNION[k][0] ;\\n    }    \\n    return k;\\n}\\nint minScore(int n, int** roads, int roadsSize, int* roadsColSize){ \\n    int** UNION = malloc((n+1) * sizeof(int*));\\n    for(int i = 1; i <= n; i++){\\n        UNION[i] = malloc(3 * sizeof(int));\\n        UNION[i][0] = i;\\n        UNION[i][1] = 1;\\n        UNION[i][2] = INT_MAX;\\n    }\\n    \\n    for(int i = 0; i < roadsSize; i++){\\n        int a = findFather( UNION, roads[i][0] );\\n        int b = findFather( UNION, roads[i][1] );\\n        int min = fmin(roads[i][2],  fmin(UNION[a][2], UNION[b][2]) );\\n        if(a == b){\\n            UNION[a][2] = min;\\n            continue;\\n        }\\n        if(UNION[a][1] >= UNION[b][1]){\\n            UNION[b][0] = a;\\n            UNION[a][2] = min;\\n            UNION[a][1] += UNION[b][1];\\n        }\\n        else{\\n            UNION[a][0] = b;\\n            UNION[b][2] = min;\\n            UNION[b][1] += UNION[a][1];\\n        }\\n    }\\n    int first = findFather(UNION, 1);\\n    int last  = findFather(UNION, n);\\n    int ans ;\\n    if(first != last)\\n        ans =  -1;\\n    else\\n        ans = UNION[first][2];\\n    \\n    for(int i = 1; i <= n; i++){\\n        free(UNION[i]);\\n    }\\n    free(UNION);\\n    return ans;\\n        \\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n//UNION\\n//father, count, min\\nint findFather(int** UNION, int val){\\n    int k = val;\\n    while(k != UNION[k][0]){\\n        k = UNION[k][0] ;\\n    }    \\n    return k;\\n}\\nint minScore(int n, int** roads, int roadsSize, int* roadsColSize){ \\n    int** UNION = malloc((n+1) * sizeof(int*));\\n    for(int i = 1; i <= n; i++){\\n        UNION[i] = malloc(3 * sizeof(int));\\n        UNION[i][0] = i;\\n        UNION[i][1] = 1;\\n        UNION[i][2] = INT_MAX;\\n    }\\n    \\n    for(int i = 0; i < roadsSize; i++){\\n        int a = findFather( UNION, roads[i][0] );\\n        int b = findFather( UNION, roads[i][1] );\\n        int min = fmin(roads[i][2],  fmin(UNION[a][2], UNION[b][2]) );\\n        if(a == b){\\n            UNION[a][2] = min;\\n            continue;\\n        }\\n        if(UNION[a][1] >= UNION[b][1]){\\n            UNION[b][0] = a;\\n            UNION[a][2] = min;\\n            UNION[a][1] += UNION[b][1];\\n        }\\n        else{\\n            UNION[a][0] = b;\\n            UNION[b][2] = min;\\n            UNION[b][1] += UNION[a][1];\\n        }\\n    }\\n    int first = findFather(UNION, 1);\\n    int last  = findFather(UNION, n);\\n    int ans ;\\n    if(first != last)\\n        ans =  -1;\\n    else\\n        ans = UNION[first][2];\\n    \\n    for(int i = 1; i <= n; i++){\\n        free(UNION[i]);\\n    }\\n    free(UNION);\\n    return ans;\\n        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2935755,
                "title": "c-dfs-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n# DFS\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i, vector<int>& v, int& ans, vector<vector<int>>adj[]){\\n        if(v[i]){return;}\\n        v[i]=1;\\n        for(auto it: adj[i]){\\n            ans=min(ans, it[1]);\\n            dfs(it[0], v, ans, adj);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>>adj[n];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]-1].push_back({roads[i][1]-1, roads[i][2]});\\n            adj[roads[i][1]-1].push_back({roads[i][0]-1, roads[i][2]});\\n        }\\n        vector<int>v(n, 0);\\n        int ans=INT_MAX;\\n        dfs(0, v, ans, adj);\\n        return ans;\\n    }\\n};\\n```\\n# BFS\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans=INT_MAX;\\n        queue<pair<int, int>>q;\\n        vector<vector<int>>adj[n];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]-1].push_back({roads[i][1]-1, roads[i][2]});\\n            adj[roads[i][1]-1].push_back({roads[i][0]-1, roads[i][2]});\\n        }\\n        vector<int>v(n, 0);\\n        q.push({0, ans});\\n        while(!q.empty()){\\n            int pos=q.front().first, cnt=q.front().second;\\n            v[pos]=1;\\n            ans=min(ans, cnt);\\n            for(auto it: adj[pos]){\\n                if(!v[it[0]]){\\n                    q.push({it[0], it[1]});\\n                }\\n            }\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, vector<int>& v, int& ans, vector<vector<int>>adj[]){\\n        if(v[i]){return;}\\n        v[i]=1;\\n        for(auto it: adj[i]){\\n            ans=min(ans, it[1]);\\n            dfs(it[0], v, ans, adj);\\n        }\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<int>>adj[n];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]-1].push_back({roads[i][1]-1, roads[i][2]});\\n            adj[roads[i][1]-1].push_back({roads[i][0]-1, roads[i][2]});\\n        }\\n        vector<int>v(n, 0);\\n        int ans=INT_MAX;\\n        dfs(0, v, ans, adj);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        int ans=INT_MAX;\\n        queue<pair<int, int>>q;\\n        vector<vector<int>>adj[n];\\n        for(int i=0; i<roads.size(); i++){\\n            adj[roads[i][0]-1].push_back({roads[i][1]-1, roads[i][2]});\\n            adj[roads[i][1]-1].push_back({roads[i][0]-1, roads[i][2]});\\n        }\\n        vector<int>v(n, 0);\\n        q.push({0, ans});\\n        while(!q.empty()){\\n            int pos=q.front().first, cnt=q.front().second;\\n            v[pos]=1;\\n            ans=min(ans, cnt);\\n            for(auto it: adj[pos]){\\n                if(!v[it[0]]){\\n                    q.push({it[0], it[1]});\\n                }\\n            }\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886810,
                "title": "saving-space-complexity-dfs-edge-traversal-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(E+V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<pair<int, int>> graph[], int node, vector<int>& visited, unordered_set<int>& inpath){\\n        for(int i=0; i<graph[node].size(); i++){\\n            int n = graph[node][i].first;\\n            int d = graph[node][i].second;\\n            if(!visited[n]){\\n                inpath.insert(n);\\n                visited[n]=1;\\n                dfs(graph, n, visited, inpath);\\n            }\\n        }\\n        return;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> graph[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            int a = roads[i][0], b = roads[i][1], c= roads[i][2];\\n            graph[a].push_back({b,c});\\n            graph[b].push_back({a,c});\\n        }        \\n\\n        // run a dfs and insert all the vertices that comes in the path\\n        unordered_set<int> inpath;\\n        inpath.insert(1);\\n        vector<int> visited(n+1, 0);\\n        visited[1]=1;\\n        dfs(graph, 1, visited, inpath);\\n\\n        // traverse through the edge list and if both the vertices in the edge is there in the set than that edge is there in the possible path between 1 and n\\n        // find the smallest of such edge\\n        int ans = INT_MAX;\\n        for(int i=0; i<roads.size(); i++){\\n            int a = roads[i][0], b= roads[i][1], c = roads[i][2];\\n            if(inpath.count(a) && inpath.count(b)){\\n                ans = min(ans, c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<pair<int, int>> graph[], int node, vector<int>& visited, unordered_set<int>& inpath){\\n        for(int i=0; i<graph[node].size(); i++){\\n            int n = graph[node][i].first;\\n            int d = graph[node][i].second;\\n            if(!visited[n]){\\n                inpath.insert(n);\\n                visited[n]=1;\\n                dfs(graph, n, visited, inpath);\\n            }\\n        }\\n        return;\\n    }\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<pair<int, int>> graph[n+1];\\n        for(int i=0; i<roads.size(); i++){\\n            int a = roads[i][0], b = roads[i][1], c= roads[i][2];\\n            graph[a].push_back({b,c});\\n            graph[b].push_back({a,c});\\n        }        \\n\\n        // run a dfs and insert all the vertices that comes in the path\\n        unordered_set<int> inpath;\\n        inpath.insert(1);\\n        vector<int> visited(n+1, 0);\\n        visited[1]=1;\\n        dfs(graph, 1, visited, inpath);\\n\\n        // traverse through the edge list and if both the vertices in the edge is there in the set than that edge is there in the possible path between 1 and n\\n        // find the smallest of such edge\\n        int ans = INT_MAX;\\n        for(int i=0; i<roads.size(); i++){\\n            int a = roads[i][0], b= roads[i][1], c = roads[i][2];\\n            if(inpath.count(a) && inpath.count(b)){\\n                ans = min(ans, c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881745,
                "title": "graphs-dsu-union-find-explained-clearly-easy-understanding-beginners",
                "content": "# Intuition\\n* Pre-requisite : DSU\\n* It is clearly stated that there exists atleast one path between 1 and n.\\n* So if the graph is not connected there will be more than one group in the graph and there will be leader for each group and that can be easily found by standard DSU template. \\n* So if we somehow able to find the leader of the group where 1 and n exists, next part is to find the minimum distance in that group as we can use any path any number of times.\\n\\n# Approach\\n* Task-1 making connections and finding leaders of each group using DSU data structure.\\n* Task-2 iterating through the graph again and finding the minimum distance of the edge that exists in the group where 1 and n exists.\\n\\n# Complexity\\n- Time complexity:\\n    * DSU - |V+E| * $$(4*alpha)$$\\n    * finding minimum - |V+E| * $$(4*alpha)$$\\n    * Total - $$ O(|V+E|) $$\\n\\n- Space complexity:\\n   * $$O(|V+E|)$$ for dictionary\\n\\n# Code\\n```\\nclass Solution:\\n    def find(self, node, dictu):\\n        if node not in dictu:\\n            dictu[node] = [node, 1]\\n        elif dictu[node][0] != node:\\n            dictu[node][0] = self.find(dictu[node][0], dictu)\\n        return dictu[node][0]\\n\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        dictu = defaultdict(int)\\n        ## TASK-1 making connections using DSU\\n        for i in roads:\\n            p1 = self.find(i[0], dictu)\\n            p2 = self.find(i[1], dictu)\\n            if p1 != p2:\\n                if dictu[p1][1] >= dictu[p2][1]:\\n                    dictu[p2][0] = p1\\n                    dictu[i[0]][0] = p1\\n                    dictu[i[1]][0] = p1\\n                    dictu[p1][1] += dictu[p2][1]\\n                else:\\n                    dictu[p1][0] = p2\\n                    dictu[i[0]][0] = p2\\n                    dictu[i[1]][0] = p2\\n                    dictu[p2][1] += dictu[p1][1]\\n        ## finding group leader for node 1 and n.\\n        result_parent = self.find(dictu[1][0], dictu)\\n        ## TASK-2\\n        mini = sys.maxsize\\n        print(dictu)\\n        for i in roads:\\n            p1 = self.find(i[0], dictu)\\n            p2 = self.find(i[1], dictu)\\n            if p1 == result_parent or p2 == result_parent:\\n                mini = min(mini, i[-1])\\n        return mini\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def find(self, node, dictu):\\n        if node not in dictu:\\n            dictu[node] = [node, 1]\\n        elif dictu[node][0] != node:\\n            dictu[node][0] = self.find(dictu[node][0], dictu)\\n        return dictu[node][0]\\n\\n    def minScore(self, n: int, roads: List[List[int]]) -> int:\\n        dictu = defaultdict(int)\\n        ## TASK-1 making connections using DSU\\n        for i in roads:\\n            p1 = self.find(i[0], dictu)\\n            p2 = self.find(i[1], dictu)\\n            if p1 != p2:\\n                if dictu[p1][1] >= dictu[p2][1]:\\n                    dictu[p2][0] = p1\\n                    dictu[i[0]][0] = p1\\n                    dictu[i[1]][0] = p1\\n                    dictu[p1][1] += dictu[p2][1]\\n                else:\\n                    dictu[p1][0] = p2\\n                    dictu[i[0]][0] = p2\\n                    dictu[i[1]][0] = p2\\n                    dictu[p2][1] += dictu[p1][1]\\n        ## finding group leader for node 1 and n.\\n        result_parent = self.find(dictu[1][0], dictu)\\n        ## TASK-2\\n        mini = sys.maxsize\\n        print(dictu)\\n        for i in roads:\\n            p1 = self.find(i[0], dictu)\\n            p2 = self.find(i[1], dictu)\\n            if p1 == result_parent or p2 == result_parent:\\n                mini = min(mini, i[-1])\\n        return mini\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881591,
                "title": "swift-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    var adj: [Int: [(Int, Int)]] = [:]\\n    var visited: Set<Int> = []\\n    var result = Int.max\\n\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        buildGraph(roads)\\n\\n        dfs(1, n)\\n\\n        return result\\n    }\\n\\n\\n    func buildGraph(_ roads: [[Int]]) {\\n        for road in roads {\\n            adj[road[0], default: []].append((road[1], road[2]))\\n            adj[road[1], default: []].append((road[0], road[2]))\\n        }\\n    }\\n\\n    func dfs(_ start: Int, _ n: Int) {\\n\\n        guard let childs = adj[start] else {\\n            return\\n        }\\n\\n        visited.insert(start)\\n\\n        for child in childs {\\n\\n            let destination = child.0\\n            let weight = child.1\\n            result = min(result, weight)\\n\\n            if visited.contains(destination) {\\n                continue\\n            } \\n\\n            dfs(destination, n)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    var adj: [Int: [(Int, Int)]] = [:]\\n    var visited: Set<Int> = []\\n    var result = Int.max\\n\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        buildGraph(roads)\\n\\n        dfs(1, n)\\n\\n        return result\\n    }\\n\\n\\n    func buildGraph(_ roads: [[Int]]) {\\n        for road in roads {\\n            adj[road[0], default: []].append((road[1], road[2]))\\n            adj[road[1], default: []].append((road[0], road[2]))\\n        }\\n    }\\n\\n    func dfs(_ start: Int, _ n: Int) {\\n\\n        guard let childs = adj[start] else {\\n            return\\n        }\\n\\n        visited.insert(start)\\n\\n        for child in childs {\\n\\n            let destination = child.0\\n            let weight = child.1\\n            result = min(result, weight)\\n\\n            if visited.contains(destination) {\\n                continue\\n            } \\n\\n            dfs(destination, n)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878889,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<bool> vis;// visited array\\n    vector<int> c; // will store require component \\n    void dfs(int src,vector<int>&c,vector<pair<int,int>> g[]){\\n        vis[src] = true;\\n        c.push_back(src);\\n        for(auto &[child,_]: g[src]){\\n            if(!vis[child]) dfs(child,c,g);\\n        }\\n    }\\n    int getMinPath(vector<pair<int,int>> g[]){\\n        int mn = INT_MAX;\\n        for(int &u: c){\\n            //getting minimum from the required component as it\\'s array of pair of vectors we cant do \"g[u].second\" so i\\'ve run the for-each loop but we can also extract the element by defining the iterator \\n            for(auto e: g[u])\\n                mn = min(e.second,mn);\\n        }\\n        return mn;\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vis.resize(n+1,false);\\n        //creating adjacency list of the given graph\\n        vector<pair<int,int>> g[n+1];\\n        for(auto &road: roads){\\n            g[road[0]].push_back({road[1],road[2]});\\n            g[road[1]].push_back({road[0],road[2]});\\n        }\\n        \\n        //getting the component in which both the first and last node is present \\n        for(int i=1; i<=n; ++i){\\n            if(!vis[i]){\\n                c.clear();\\n                dfs(i,c,g);\\n                if(vis[1] && vis[n]) break;\\n            }\\n        }\\n        return getMinPath(g);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<bool> vis;// visited array\\n    vector<int> c; // will store require component \\n    void dfs(int src,vector<int>&c,vector<pair<int,int>> g[]){\\n        vis[src] = true;\\n        c.push_back(src);\\n        for(auto &[child,_]: g[src]){\\n            if(!vis[child]) dfs(child,c,g);\\n        }\\n    }\\n    int getMinPath(vector<pair<int,int>> g[]){\\n        int mn = INT_MAX;\\n        for(int &u: c){\\n            //getting minimum from the required component as it\\'s array of pair of vectors we cant do \"g[u].second\" so i\\'ve run the for-each loop but we can also extract the element by defining the iterator \\n            for(auto e: g[u])\\n                mn = min(e.second,mn);\\n        }\\n        return mn;\\n    }\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vis.resize(n+1,false);\\n        //creating adjacency list of the given graph\\n        vector<pair<int,int>> g[n+1];\\n        for(auto &road: roads){\\n            g[road[0]].push_back({road[1],road[2]});\\n            g[road[1]].push_back({road[0],road[2]});\\n        }\\n        \\n        //getting the component in which both the first and last node is present \\n        for(int i=1; i<=n; ++i){\\n            if(!vis[i]){\\n                c.clear();\\n                dfs(i,c,g);\\n                if(vis[1] && vis[n]) break;\\n            }\\n        }\\n        return getMinPath(g);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878168,
                "title": "java-easy-solution-with-modified-union-find",
                "content": "# Intuition\\nSince we can contain the same road multiple times and this graph may not be connected, so we just need to find the min cost for each connected component. \\nThus, it is easier to think of using **Union Find**.\\n\\n# Approach\\nHere we just modified the `Union Find` class by adding the `minCost` array for the whole graph. \\nIt is very easy for us to solve this question with only one `for-loop`.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < roads.length; ++i) {\\n            uf.union(roads[i][0] - 1, roads[i][1] - 1, roads[i][2]);\\n        }\\n        return uf.findCost(0);\\n    }\\n}\\n    \\nclass UnionFind {\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] minCost;\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n\\n        /* record the min cost of connected components where each node is located */\\n        minCost = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n            minCost[i] = Integer.MAX_VALUE;\\n        }\\n    }\\n    public void union(int a, int b, int cost) {\\n        int rootA = find(a);\\n        int rootB = find(b);\\n\\n        /* modified place */\\n        minCost[rootA] = Math.min(cost, Math.min(minCost[rootA], minCost[rootB]));\\n        minCost[rootB] = minCost[rootA];\\n        /* modified place */\\n\\n        if (rootA == rootB) return;\\n\\n        if (rank[rootA] < rank[rootB]) {\\n            parent[rootA] = rootB;\\n        } else {\\n            parent[rootB] = rootA;\\n            if (rank[rootA] == rank[rootB]) rank[rootA] += 1;\\n        }\\n    }\\n    public int find(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = find(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n    public int findCost(int i) {\\n        return minCost[find(i)];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < roads.length; ++i) {\\n            uf.union(roads[i][0] - 1, roads[i][1] - 1, roads[i][2]);\\n        }\\n        return uf.findCost(0);\\n    }\\n}\\n    \\nclass UnionFind {\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] minCost;\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n\\n        /* record the min cost of connected components where each node is located */\\n        minCost = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            rank[i] = 1;\\n            minCost[i] = Integer.MAX_VALUE;\\n        }\\n    }\\n    public void union(int a, int b, int cost) {\\n        int rootA = find(a);\\n        int rootB = find(b);\\n\\n        /* modified place */\\n        minCost[rootA] = Math.min(cost, Math.min(minCost[rootA], minCost[rootB]));\\n        minCost[rootB] = minCost[rootA];\\n        /* modified place */\\n\\n        if (rootA == rootB) return;\\n\\n        if (rank[rootA] < rank[rootB]) {\\n            parent[rootA] = rootB;\\n        } else {\\n            parent[rootB] = rootA;\\n            if (rank[rootA] == rank[rootB]) rank[rootA] += 1;\\n        }\\n    }\\n    public int find(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = find(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n    public int findCost(int i) {\\n        return minCost[find(i)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878142,
                "title": "dijkstra-dfs-unionfind",
                "content": "Please upvote if you found this useful\\nDFS:\\n\\n```\\nclass Solution {\\n    int mindist = Integer.MAX_VALUE;\\n\\n    public int minScore(int n, int[][] roads) {\\n\\n        HashMap<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int[] f: roads) {\\n            graph.putIfAbsent(f[0], new ArrayList<>());\\n            graph.putIfAbsent(f[1], new ArrayList<>());\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n            graph.get(f[1]).add(new int[]{f[0], f[2]});\\n        }\\n        boolean[] vis = new boolean[n + 1];\\n        vis[1] = true;\\n        dfs(1, graph, vis, Integer.MAX_VALUE);\\n        return mindist;\\n    }\\n    private void dfs(int cur, HashMap<Integer, List<int[]>> graph, boolean[] vis, int curmin) {\\n        // The test cases are generated such that there is at least one path between 1 and n.\\n\\n        if (graph.get(cur) != null) {\\n            for (int[] nei: graph.get(cur)) {\\n\\n                curmin = Math.min(curmin, nei[1]);\\n                mindist = Math.min(mindist, curmin);\\n\\n                if (vis[nei[0]] == true) continue;\\n                vis[nei[0]] = true;\\n                dfs(nei[0], graph, vis, curmin);\\n            }\\n        }\\n    }\\n}\\n```\\n\\nDijkstra:\\n\\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        // dij\\n        // graph\\n        HashMap<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int[] f: roads) {\\n            graph.putIfAbsent(f[0], new ArrayList<>());\\n            graph.putIfAbsent(f[1], new ArrayList<>());\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n            graph.get(f[1]).add(new int[]{f[0], f[2]});\\n        }\\n\\n        PriorityQueue<Node> minheap = new PriorityQueue<>((a, b) -> a.cost - b.cost); // <nei: cost>\\n\\n        minheap.add(new Node(1, Integer.MAX_VALUE));\\n        \\n        int mincost = Integer.MAX_VALUE;\\n        boolean[] vis = new boolean[n + 1];\\n        while (!minheap.isEmpty()) {\\n\\n            Node cur = minheap.poll();\\n\\n            mincost = Math.min(mincost, cur.cost); \\n\\n            if (vis[cur.val] == true) continue;\\n            vis[cur.val] = true;\\n\\n            if (graph.get(cur.val) != null) {\\n                for (int[] nei: graph.get(cur.val)) {\\n\\n                    int curmincost = Math.min(nei[1], cur.cost);\\n\\n                    minheap.add(new Node(nei[0], curmincost));\\n                }\\n            }\\n        }\\n        return mincost;\\n    }\\n    class Node {\\n        int val;\\n        int cost;\\n        \\n        public Node(int val, int cost) {\\n            this.val = val;\\n            this.cost = cost;\\n        }\\n    }\\n}\\n```\\n\\nUnionfind:\\n```\\nclass Solution {\\n    int[] parent;\\n    int[] dist;\\n    public int minScore(int n, int[][] roads) {\\n\\n        parent = new int[n + 1];\\n        dist = new int[n + 1];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n\\n        for (int i = 1; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n        for (int[] r: roads) {\\n            union(r[0], r[1], r[2]);\\n        }\\n        int parent1 = find(1);\\n        int parentn = find(n);\\n        return dist[parentn]; \\n    }\\n    private int find(int i) {\\n        while (i != parent[i]) {\\n            i = parent[i];\\n        }\\n        return i;\\n    }\\n    private void union(int i, int j, int d) {\\n        int parenti = find(i);\\n        int parentj = find(j);\\n        parent[parenti] = parentj;\\n\\n        int mindist = Math.min(dist[parenti], dist[parentj]);\\n\\n\\n        mindist = Math.min(mindist, d);\\n        dist[parenti] = dist[parentj] = mindist; \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mindist = Integer.MAX_VALUE;\\n\\n    public int minScore(int n, int[][] roads) {\\n\\n        HashMap<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int[] f: roads) {\\n            graph.putIfAbsent(f[0], new ArrayList<>());\\n            graph.putIfAbsent(f[1], new ArrayList<>());\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n            graph.get(f[1]).add(new int[]{f[0], f[2]});\\n        }\\n        boolean[] vis = new boolean[n + 1];\\n        vis[1] = true;\\n        dfs(1, graph, vis, Integer.MAX_VALUE);\\n        return mindist;\\n    }\\n    private void dfs(int cur, HashMap<Integer, List<int[]>> graph, boolean[] vis, int curmin) {\\n        // The test cases are generated such that there is at least one path between 1 and n.\\n\\n        if (graph.get(cur) != null) {\\n            for (int[] nei: graph.get(cur)) {\\n\\n                curmin = Math.min(curmin, nei[1]);\\n                mindist = Math.min(mindist, curmin);\\n\\n                if (vis[nei[0]] == true) continue;\\n                vis[nei[0]] = true;\\n                dfs(nei[0], graph, vis, curmin);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        // dij\\n        // graph\\n        HashMap<Integer, List<int[]>> graph = new HashMap<>();\\n        for (int[] f: roads) {\\n            graph.putIfAbsent(f[0], new ArrayList<>());\\n            graph.putIfAbsent(f[1], new ArrayList<>());\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n            graph.get(f[1]).add(new int[]{f[0], f[2]});\\n        }\\n\\n        PriorityQueue<Node> minheap = new PriorityQueue<>((a, b) -> a.cost - b.cost); // <nei: cost>\\n\\n        minheap.add(new Node(1, Integer.MAX_VALUE));\\n        \\n        int mincost = Integer.MAX_VALUE;\\n        boolean[] vis = new boolean[n + 1];\\n        while (!minheap.isEmpty()) {\\n\\n            Node cur = minheap.poll();\\n\\n            mincost = Math.min(mincost, cur.cost); \\n\\n            if (vis[cur.val] == true) continue;\\n            vis[cur.val] = true;\\n\\n            if (graph.get(cur.val) != null) {\\n                for (int[] nei: graph.get(cur.val)) {\\n\\n                    int curmincost = Math.min(nei[1], cur.cost);\\n\\n                    minheap.add(new Node(nei[0], curmincost));\\n                }\\n            }\\n        }\\n        return mincost;\\n    }\\n    class Node {\\n        int val;\\n        int cost;\\n        \\n        public Node(int val, int cost) {\\n            this.val = val;\\n            this.cost = cost;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] parent;\\n    int[] dist;\\n    public int minScore(int n, int[][] roads) {\\n\\n        parent = new int[n + 1];\\n        dist = new int[n + 1];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n\\n        for (int i = 1; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n        for (int[] r: roads) {\\n            union(r[0], r[1], r[2]);\\n        }\\n        int parent1 = find(1);\\n        int parentn = find(n);\\n        return dist[parentn]; \\n    }\\n    private int find(int i) {\\n        while (i != parent[i]) {\\n            i = parent[i];\\n        }\\n        return i;\\n    }\\n    private void union(int i, int j, int d) {\\n        int parenti = find(i);\\n        int parentj = find(j);\\n        parent[parenti] = parentj;\\n\\n        int mindist = Math.min(dist[parenti], dist[parentj]);\\n\\n\\n        mindist = Math.min(mindist, d);\\n        dist[parenti] = dist[parentj] = mindist; \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877178,
                "title": "dfs-we-are-only-interested-in-connected-component-of-1-c",
                "content": "We just have to find all vertices that are in connected component with 1 and find edge with minimum value in that graph. \\nImportant factors : \\n* Graph can be disconnected;\\n* There always will be a path between 1 and n, therefore n is in a same connected-component as 1;\\n* If we assume that graph doesn\\'t contain cycles we can eliminate visited array and calculate answer directly in dfs, but problem doesn\\'t state such thing;\\n\\nAssuming graph can containc cycles code looks like this : \\n\\n```\\nclass Solution {\\npublic:\\n    vector <int> connectedComponent;\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> g(n+1, vector<pair<int,int>>());\\n        for(auto it : roads){\\n            g[it[0]].push_back({it[1],it[2]});\\n            g[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<bool> visited (n+1, false);\\n        dfs(1,g,visited);\\n        int ans = INT_MAX;\\n        for(auto & u : connectedComponent){\\n            for(auto & v : g[u])\\n                ans = min(v.second,ans);\\n        }\\n        return ans;\\n    }\\n    void dfs(int u, vector<vector<pair<int,int>>> &g, vector<bool> & visited){\\n        visited[u] = true;\\n        connectedComponent.push_back(u);\\n        for(auto & v : g[u]){\\n            if(!visited[v.first])\\n                dfs(v.first,g,visited);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> connectedComponent;\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<vector<pair<int,int>>> g(n+1, vector<pair<int,int>>());\\n        for(auto it : roads){\\n            g[it[0]].push_back({it[1],it[2]});\\n            g[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<bool> visited (n+1, false);\\n        dfs(1,g,visited);\\n        int ans = INT_MAX;\\n        for(auto & u : connectedComponent){\\n            for(auto & v : g[u])\\n                ans = min(v.second,ans);\\n        }\\n        return ans;\\n    }\\n    void dfs(int u, vector<vector<pair<int,int>>> &g, vector<bool> & visited){\\n        visited[u] = true;\\n        connectedComponent.push_back(u);\\n        for(auto & v : g[u]){\\n            if(!visited[v.first])\\n                dfs(v.first,g,visited);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877044,
                "title": "single-dfs",
                "content": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<int[]>> graph = new ArrayList<>(); //Weighted Graph\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());  //Initialse the  graph\\n        for(int[] e: roads){  //Fill the graph\\n            graph.get(e[0]-1).add(new int[]{e[1]-1,e[2]});\\n            graph.get(e[1]-1).add(new int[]{e[0]-1,e[2]});\\n        }\\n        return getMin(0,new boolean[n],graph); //Single DFS\\n    }\\n    private int getMin(int node, boolean[] visited,List<List<int[]>> graph){\\n        int min = Integer.MAX_VALUE;\\n        visited[node] = true;\\n        for(int[] child: graph.get(node)){\\n            min = Math.min(min,child[1]); //Check if this edge is minimum or not;\\n            if(!visited[child[0]]){\\n                 min = Math.min(min,getMin(child[0],visited,graph));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        List<List<int[]>> graph = new ArrayList<>(); //Weighted Graph\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());  //Initialse the  graph\\n        for(int[] e: roads){  //Fill the graph\\n            graph.get(e[0]-1).add(new int[]{e[1]-1,e[2]});\\n            graph.get(e[1]-1).add(new int[]{e[0]-1,e[2]});\\n        }\\n        return getMin(0,new boolean[n],graph); //Single DFS\\n    }\\n    private int getMin(int node, boolean[] visited,List<List<int[]>> graph){\\n        int min = Integer.MAX_VALUE;\\n        visited[node] = true;\\n        for(int[] child: graph.get(node)){\\n            min = Math.min(min,child[1]); //Check if this edge is minimum or not;\\n            if(!visited[child[0]]){\\n                 min = Math.min(min,getMin(child[0],visited,graph));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1840451,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840040,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840091,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840066,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1704778,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840707,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840121,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840101,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1713139,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1704873,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840451,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840040,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840091,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840066,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1704778,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840707,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840121,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840101,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1713139,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1704873,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I am a gypsy fortune teller.  -- \"You implemented it using Dijkstra and failed the 2nd test case\"."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "hey! you look right though me 0.0"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "As there is at least one path between 1 and n , just find out all the edges that can be reached from node 1 and return the minimum edge."
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, it's the classic islands problem, but with a  red herring to try to trick us into writing dijkstra's for the 100th time."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "It is not a tip! But a solution :) "
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "I confirm your Idea worked. Thanks"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) why not, we can visit node 2 and that is the minimum weighted edge we can reach from node 1 and hence answer is 2\\n\\nfor more clarification  now as we can visit node 2 from node 1 it means we can definitely visit node 1 from node 2 as it is bidirectional graph and in constrain it is given that there is at least one path between 1 and n. "
                    },
                    {
                        "username": "user1715ZB",
                        "content": "[@P_A_R_U_S](/P_A_R_U_S) It is the case for example #2. The minimum score is 2 because there is an edge from city 1 to city 2 with a score of 2. In the question you are basically finding the connected component of an undirected graph. This is because any city that is part of the connected component is reachable from any other city. Any road in the connected component is on some possible path from city 1 to city n."
                    },
                    {
                        "username": "P_A_R_U_S",
                        "content": "I don\\'t think it is case for Example #2."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Returning the minimum value will not pass the last few test cases as it might be possible that we cannot reach those edges from 1 (Disconnected Graph). So, We need to figure out the minimum Edge distance which can be reached from 1, as it\\'s given that we can reach to n so we don\\'t have to worry about that\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Come on, graph week."
                    },
                    {
                        "username": "JackieWDo",
                        "content": "I feel very confused by this constraint:\n> It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\n\nMy understanding is that **only** city 1 and city n can be visited multiple times. But the test case\n```\n4\n[[1,2,9], [2,3,1], [1,4,9]]\n```\ngives answer 1, which cannot be achieved because we have to go via path 1->2->3->2->1->4, which visits 2 (not city 1 nor city n(4)) twice. Correct me if I am wrong."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "It is definitely a bit ambiguous, but if I were to rephrase it, I'd say it's more like: \"You may travel along any road an infinite number of times, and you do not need to stop once you reach nodes 1/n (but you must end at node n at some point)\".\n\nTraditionally when we think of \"path from 1 to n\" we're really say \"sequence of (non-repeating) vertices and edges that starts at vertex 1 and ends at vertex n\". In this problem, though, we drop the \"(non-repeating)\" constraint.\n\nIf you imagine all vertices in a circle like the hour hands on a clock, we are allowed to loop around the circle multiple times (i.e. pass through vertex 12 and back to vertex 1), but we must end at vertex 12 at some point. \n\nHopefully the explanation/analogy made sense, but basically it's saying you can go backwards (backtrack) once you reach node n, but you must go back and end at node n at some point (i.e. a finite path)."
                    },
                    {
                        "username": "ajit_2828",
                        "content": "No, bro you can visit any nodes multiple times including 1 & n"
                    },
                    {
                        "username": "JackieWDo",
                        "content": "[@skate1512](/skate1512) I can understand the question and the constraint if we have the test case, but since most test cases are hidden and the provided test cases did not cover the scenario I am mentioning here, I think there is some confusion here."
                    },
                    {
                        "username": "pwyq",
                        "content": "What\\'s the actual point of this question in real life?? The question is made just for the sake of making a question."
                    },
                    {
                        "username": "sk03167",
                        "content": "Say you need to travel but have a car that can only travel a certain distance before it needs to be refueled and you need to reach city n. Won\\'t such a problem be the real life application of this question?\\n\\n .............. As I wrote this, I realize they were assigning the minimum length as the path score and not the maximum and this actually does not make any sense irl. XD \\n\\nAnd even for my above scenario, a case where the tank capacity is also taken into account along with fuel burned per unit distance would be more appropriate. (And we do have such questions on lc.)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Whenever,i see this type of problem  it made me low ."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\n\n- We can represent the given graph using an adjacency list. Since the graph is undirected, we will add edges to both nodes of every road. To create the adjacency list, we can either use a map where the keys are nodes and the values are lists of edges or create a custom GraphNode class to represent each node in the graph, where each GraphNode object has a list of its edges.\n\n- Once we have the adjacency list, we can perform a BFS traversal starting from node 1. We will maintain a boolean array visited to keep track of nodes that have been visited during the traversal. We will also keep track of the minimum weight of edges encountered during the traversal.\n\n- During the traversal, for each node we visit, we will iterate through its edges and update the minimum weight if we encounter a smaller weight. If we encounter an unvisited neighbor node, we will mark it as visited and add it to the queue for further traversal.\n\n- After the BFS traversal is complete, the minimum weight of all edges encountered will give us the minimum score.\n\n- Finally, we will return the minimum score obtained."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link:-)***\\nhttps://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326876/easiest-solution-with-approach/"
                    },
                    {
                        "username": "child70370636",
                        "content": "Why is this testcase's answer is 1?\n `n = 3 ; roads = [[3,2,1],[1,3,3]]`\nThe answer is 1, but my output is 3, which is my expected output.\nI was accepted during the contest, but today I found leetcode cancel my correct submission, and this testcase is the only one that I'm incorrect, but according to my understanding of the question, we can passing all the path from city 1 to city n, and in this testcase, 1 to 3 only have one path which the distance is 3, but the answer is 1 (path from city 3 to 2), so I'm confused that what did I miss, thx!"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The problem is asking for the minimum edge along *any* path from 1 to n. So we can go from vertex 3 to 2 and back to 3. The edge is only 1 and it\\'s a valid path because we don\\'t *have to* stop at n once we reached it. "
                    },
                    {
                        "username": "vigneshDev2022",
                        "content": "[@suren_yeager](/suren_yeager)  for the path flow we have 1 and 3 im right . Compare both take less number\\n\\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "The score denotes the minimum distance of any road in the path from 1 to n. The roads are bidirectional too and we can travel along the same path twice or more times. So I guess in this case, the path would be 1 -(3)-> 3 -(1)-> 2-(1)->3. "
                    },
                    {
                        "username": "CODEX47",
                        "content": "Who came up with this solution in contest, not me definitely!\n\n<details>\n<summary>Spoiler Alert! Code</summary>\n<br>\n\n\n```\nint minScore(int N, vector<vector<int>> &edges)\n{\n    int ans = INT_MAX;\n    for (auto e : edges)\n        ans = min(ans, e[2]);\n    return ans;\n}\n```\n\n</details>"
                    },
                    {
                        "username": "kshitijmishra27",
                        "content": "[@skate1512](/skate1512) why its not working for that???"
                    },
                    {
                        "username": "whynesspower",
                        "content": "when the graph is disconnected, we can\\'t get the min weight between those nodes which are not accessible from destination node. This code also includes that inaccessible weight, hence false answer"
                    },
                    {
                        "username": "skate1512",
                        "content": "Not working for \\nn = 36\\nroads = [[7,11,418],[13,23,287],[16,25,7891],[15,7,9695],[4,3,9569],[17,7,1809],[14,3,4720],[14,4,6118],[9,2,4290],[32,17,5645],[14,16,426],[36,7,6721],[13,30,9444],[3,25,4635],[33,5,1669],[22,18,8910],[5,28,7865],[13,10,9466],[7,9,2457],[11,8,4711],[17,11,6308],[7,34,3789],[8,33,9659],[16,3,4187],[16,20,3595],[23,10,6251],[26,22,6180],[4,16,5577],[26,7,5398],[6,36,8671],[10,19,3028],[23,30,1330],[19,13,8315],[25,20,4740],[25,4,5818],[30,10,8030],[30,19,7527],[28,6,6804],[21,27,1746],[18,9,5189],[7,27,6560],[20,14,2450],[27,32,3951],[2,21,3927],[1,15,9283],[3,20,5428],[15,26,5871],[19,23,4533],[14,25,6992],[4,20,5831]]"
                    }
                ]
            },
            {
                "id": 1840424,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 2072315,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 2042227,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1909308,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1893453,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1842353,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1842141,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1841489,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1840921,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1840916,
                "content": [
                    {
                        "username": "h_rshsingh",
                        "content": "last testcase is n=     nothing given why this testcase is giving TLE."
                    },
                    {
                        "username": "gibbouz",
                        "content": "[@EkaterinaT](/EkaterinaT) Can confirm that the last test case seems to be broken. Just states \"n=\""
                    },
                    {
                        "username": "EkaterinaT",
                        "content": "Are you sure last case is n = nothing? I don\\'t have n validation, but solution worked ok."
                    },
                    {
                        "username": "M_Suleman",
                        "content": "It was easy but still took 1 hour hahah"
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Such a weird problem"
                    },
                    {
                        "username": "harsh7236",
                        "content": "can anyone please help me spot where is a problem in my code some test cases are not running i dont know why... \\n\\nclass Solution {\\n    static class Pair{\\n        int des;\\n        int wt;\\n        Pair(int des, int wt) {\\n            this.des = des;\\n            this.wt = wt;\\n        }\\n    }\\n\\n    static class Qpair{\\n        int src;\\n        int s;\\n\\n        Qpair(int src, int s) {\\n            this.src = src;\\n            this.s = s;\\n        }\\n    }\\n    public int minScore(int n, int[][] roads) {\\n        \\n       Queue<Qpair> q = new LinkedList<>();\\n       boolean[] visited = new boolean[n+1];\\n       int ans = Integer.MAX_VALUE;\\n\\n        ArrayList<Pair>[] adj = new ArrayList[n+1];\\n        for(int i=0; i<=n ;i++)  adj[i] = new ArrayList<>();\\n\\n        for(int i[]: roads) {\\n            int src = i[0], des = i[1], wt = i[2];\\n            adj[src].add(new Pair(des , wt));\\n            adj[des].add(new Pair(src, wt));\\n        }\\n\\n        \\n            q.add(new Qpair(i, Integer.MAX_VALUE));\\n            while(q.size() > 0) {\\n                Qpair temp = q.poll();\\n                int src = temp.src;\\n                int score = temp.s;\\n\\n                if(src == n) {\\n                    ans = Math.min(ans , score);\\n                    continue;\\n                }\\n\\n                if(visited[src]) continue;\\n                visited[src] = true;\\n                ArrayList<Pair> l = adj[src];\\n\\n                int ms = Integer.MAX_VALUE;\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) ms = Math.min(ms, p.wt);\\n                }\\n\\n                for(Pair p : l) {\\n                    if(!visited[p.des]) {\\n                        q.add(new Qpair(p.des, Math.min(ms, score)));\\n                    }\\n                }\\n            \\n            }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sk7788775",
                        "content": "Can be solved by simple dfs. Just need to start traversing from nth vertices and find the minimum possible path distance."
                    },
                    {
                        "username": "user0372FW",
                        "content": "Could someone explain me this please?\\ntest case 42/43\\nn = 13\\n[[1,13,14],[9,11,15],[2,11,11],[9,4,15],[3,11, 8]]\\n\\nThere is only one road 1 - 13. Dist - 14.\\nWhy the right answer is 8?\\n\\nThanks."
                    },
                    {
                        "username": "sonnguyen2201",
                        "content": "Why my DFS (1686 ms) run faster than BFS (4665 ms)?\\n\\nDFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n\\n        visited = set()\\n        min_path = inf\\n\\n        def dfs(node):\\n            nonlocal min_path \\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    dfs(nei)\\n                min_path = min(min_path, dis)\\n\\n        dfs(1)\\n\\n        return min_path   \\n```\\n\\nBFS code\\n```python\\n        graph = defaultdict(list)\\n\\n        for u, v, distance in roads:\\n            graph[u].append((v, distance))\\n            graph[v].append((u, distance))\\n        \\n\\n        queue = deque([])\\n        visited = set()\\n        queue.append(1)\\n        min_path = inf\\n\\n        while queue:\\n            node = queue.popleft()\\n            visited.add(node)\\n            for nei, dis in graph[node]:\\n                if nei not in visited:\\n                    queue.append(nei)\\n                \\n                min_path = min(min_path, dis)\\n        \\n        return min_path\\n```\\n"
                    },
                    {
                        "username": "khangnguyen0318",
                        "content": "This question is not usefull because the example 2nd is make this look like an not real life quest. In the real life or game from city 1 to city n find the minimum distance to get there or at least return the edges has no traffic jame. Please tell me this question has meaning in which case. I\\'m very open mind for learning new knowledge. Please looking at example 2 while you should go to city 2 and back to city 1 to return the number 2 because this is not the good example for finding the path to reach the goal."
                    },
                    {
                        "username": "etleyden",
                        "content": "I\\'m seeing other people get TLE and SLE for the same code posted in the submission, and I got the same thing for my own solution. I think it\\'s unfair that some people passed and others didn\\'t, despite submitting a versatile solution."
                    },
                    {
                        "username": "psionl0",
                        "content": "Phew! Just beat the deadline by 1 hour. I wouldn\\'t call this problem hard (I have seen hard) but it took me all day to iron out the bugs in this code."
                    }
                ]
            },
            {
                "id": 1840827,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840768,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840672,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840530,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840511,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840448,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840419,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840392,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840376,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840305,
                "content": [
                    {
                        "username": "roshitkhare",
                        "content": "you know the answer straight forward but you don\\'t know how to stop bfs/dfs from getting in a loop"
                    },
                    {
                        "username": "AlecLC",
                        "content": "For me the trick to this question was how to construct the visited set. If you only cache vertices and only calculate distance for unvisited vertices, the algorithm will fail because you\\'re allowed to repeat them. But if you cache both vertices and distances, it will TLE for the large test cases.\\n\\nSo the solution is to add only vertices to visited, but still compute the distance for visited nodes, so as not to miss repeated nodes\\n\\n```\\nfor adj, d in graph[cur]:\\n    if d < ans:\\n        ans = d\\n    if adj not in visited:\\n        q.append(adj)\\n        visited.add(adj)\\n```\\n\\n"
                    },
                    {
                        "username": "a0518",
                        "content": "Thanks this helped alot"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "LEGEND IS Hear \\uD83E\\uDD18;\\ni just iterated over the array setting my ans=roads[0][2] and check for the minimum distance in remaining triplets by doing so only 4 testcases are remaining, i just got those by submitting 4 times ahh? what do you say \\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\n\\ni played dirty tho;\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Pretty sure that\\'s considered cheating in a contest as you are writing specific answers for specific testcases. Your solution just doesn\\'t work, you are not checking if you can get to the smallest edge, that\\'s the whole point of the question. That\\'s why they hide some testcases in a contest. "
                    },
                    {
                        "username": "GarvGupta20",
                        "content": "I think just don\\'t complicate the problem and simply apply depth first search with the source as 1 and get the minimum edge from that . It is not very efficient but still works well and is very practical to come up with"
                    },
                    {
                        "username": "VishalArora14",
                        "content": "Since there is at least one path between node 1 and n , just run a dfs from node 1 or n and return the minimum edge/dist. Remember to to check for Min-Dist of Neighbor node even if its already visited. Run a dfs on nbr node only if its unvisited. "
                    },
                    {
                        "username": "santanusen",
                        "content": "Use union-find (disjoint set).\nWe need two passes over the edges -\n\n* Pass 1 - Create disjoint sets of connected components:\nIterate over all edges. Perform union of both the ends of each edge.\n\n* Pass 2 - Find min cost of edges connected to component containing node 1 (and thus node n).\nIterate over all edges. If one of the ends is node 1 or node n, or the first end belongs to the set containing 1 (and thus node n) update minimum score if the edge score is lesser.\n\nNote: If the first end of the edge belongs to a connected component, the other end also belongs to the same component. Thus, in the second pass, checking only if one of the ends of an edge belongs to the connected component containing node 1 is enough."
                    },
                    {
                        "username": "mrping_11",
                        "content": "\"The cities graph is not necessarily connected.\"\n\"It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\"\n"
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Use dijkstra algorithm but instead of storing shortest path, store shortest edge."
                    },
                    {
                        "username": "code0987",
                        "content": "Here is my approach:\n\nPrepare adjacency matrix / graph.\nuse DFS to find the connected component (connected with city 1) and put them in a set.\nIterate all roads and update the min distance if and only if any of the connected cities is there in the connected component set which we calculated earlier."
                    },
                    {
                        "username": "m_s_anand",
                        "content": "Try to think about finding the smallest `path(edge) `between  1 and N.\\ntake the hint:- https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327595/4-liner-dfs-solution-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1840090,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1840071,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1840063,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1840023,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1709861,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1705074,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1704931,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1704819,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1704805,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            },
            {
                "id": 1840763,
                "content": [
                    {
                        "username": "glitched-sudhanshu",
                        "content": "Just find the minimum distance between any two nodes which lies in the connected component of 1 and n."
                    },
                    {
                        "username": "Masterdemon123",
                        "content": " so we can just BFS and then return the smallest distance  ? "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I did it this way, it passes, but is very slow, I think DFS would be faster. Union find is probably best though"
                    },
                    {
                        "username": "Krrabs",
                        "content": "Yes, if you don\\'t early exit when you find your target node i.e node `n` , you have to visit all nodes in the graph."
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Yeah, that or DFS. Just needs an adjacency list first."
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "passed 38 / 41 testcases for just only return the minimum distance_i \\uD83E\\uDD23"
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "We need to check the path lower and higher band then the remaining cases will also pass."
                    },
                    {
                        "username": "pradeepmedikonda76",
                        "content": "yes the same tested."
                    },
                    {
                        "username": "testingdevelopment289",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are many ways for solving this minimum distance problem. Maybe I will try DFS firstly in a recursive way."
                    },
                    {
                        "username": "fymmmmm",
                        "content": "\\uFF1F"
                    },
                    {
                        "username": "eric880212",
                        "content": "I want to ask why this solution performs better than most of BFS solutions?\\nCan anyone tell me how to analyze the time complexity of it? Thanks in advance !\\n ```\\n class Solution {\\npublic:\\n    int minScore(int n, vector<vector<int>>& roads) {\\n        vector<int> parent(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        \\n        function<int(int)> find = [&](int p) {\\n            if (p != parent[p]) \\n                parent[p] = find(parent[p]); \\n            return parent[p]; \\n        };\\n        \\n        unordered_map<int, int> mp; \\n        for (auto& r : roads) {\\n            int uu = find(r[0]-1), vv = find(r[1]-1); \\n            parent[uu] = vv; \\n            if (mp.count(vv)) mp[vv] = min(mp[vv], r[2]); \\n            else mp[vv] = r[2]; \\n        }\\n        for (int x = 0; x < n; ++x) \\n            if (mp.count(x)) {\\n                int xx = find(x); \\n                mp[xx] = min(mp[xx], mp[x]); \\n            }\\n        return find(0) == find(n-1) ? mp[find(0)] : -1; \\n    }\\n}\\n```"
                    },
                    {
                        "username": "RayHopefield",
                        "content": "This is union find or Disjoint set, after graph was constructed time complexity for searching is constant, you can read about it here\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/"
                    },
                    {
                        "username": "dibbleme",
                        "content": "Swift | DFS O(n) got TLE, is time limit same for all languages?\\n```Swift\\nclass Solution {\\n    func minScore(_ n: Int, _ roads: [[Int]]) -> Int {\\n        var m: [Int: Set<[Int]>] = [:]\\n        for r in roads {\\n            let a = r[0], b = r[1], d = r[2]\\n            if var p = m[a] { p.insert([b, d]); m[a] = p }\\n            else { m[a] = [[b, d]] }\\n            if var p = m[b] { p.insert([a, d]); m[b] = p }\\n            else { m[b] = [[a, d]] }\\n        }\\n        var valid = [Int](repeating: -1, count: 100001)\\n        valid[1] = 1\\n        return self.dfs(1, &valid, m)\\n    }\\n\\n    private func dfs(_ n: Int, _ v: inout [Int], _ m: [Int: Set<[Int]>]) -> Int {\\n        var mi = 10001\\n        guard let children = m[n] else { return mi }\\n        for ch in children {\\n            mi = min(mi, ch[1])\\n            if v[ch[0]] == 1 {  continue  }\\n            v[ch[0]] = 1\\n            mi = min(mi, self.dfs(ch[0], &v, m))\\n        }\\n        return mi\\n    }\\n}\\n```"
                    },
                    {
                        "username": "ritikrawat2448",
                        "content": "I\\'m getting TLE in this code , can anyone help || Java Solution || DFS \\n```\\nclass Pair{\\n    int a;\\n    int b ;\\n    Pair(int a,int b){\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    public int minScore(int n, int[][] roads) {\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\\n        for ( int i=0;i<n+1;++i ){\\n            adj.add(new ArrayList<>());\\n        }\\n        for ( int i=0;i<roads.length;++i ){\\n            adj.get(roads[i][0]).add(new Pair(roads[i][1],roads[i][2]));\\n            adj.get(roads[i][1]).add(new Pair(roads[i][0],roads[i][2]));\\n        }\\n        int vis[] = new int[n+1];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(1,0));\\n        int ans = Integer.MAX_VALUE;\\n        while ( !q.isEmpty() ){\\n            int node = q.peek().a;\\n            int dist = q.peek().b;\\n            q.remove();\\n            \\n            ans = Math.min(dist,ans);\\n            \\n            for ( Pair i : adj.get(node) ){\\n                int nodeN = i.a;\\n                int distN = i.b;\\n                q.add(new Pair(nodeN,distN));\\n            }\\n        }\\n        return ans;\\n    }\\n                                    \\n}\\n```"
                    },
                    {
                        "username": "only_contest",
                        "content": "Where are you marking visited nodes..?"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "case 35 the god. asking for n = 100000 and where doesn\\'t exist in Bi. it has in Ai, and the return is not the distance is the Ai. genius question"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Oh what a **beautiful** problem this is! One of the Best problem for testing traversal/ union -find skills. Most problems are either a total giveaway or too hard to crack but this finds the sweet spot - Neither too obvious, nor too tricky to crack"
                    }
                ]
            }
        ]
    }
]