[
    {
        "title": "Append K Integers With Minimal Sum",
        "question_content": "You are given an integer array nums and an integer k. Append k unique positive integers that do not appear in nums to nums such that the resulting total sum is minimum.\nReturn the sum of the k integers appended to nums.\n&nbsp;\nExample 1:\n\nInput: nums = [1,4,25,10,25], k = 2\nOutput: 5\nExplanation: The two unique positive integers that do not appear in nums which we append are 2 and 3.\nThe resulting sum of nums is 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70, which is the minimum.\nThe sum of the two integers appended is 2 + 3 = 5, so we return 5.\nExample 2:\n\nInput: nums = [5,6], k = 6\nOutput: 25\nExplanation: The six unique positive integers that do not appear in nums which we append are 1, 2, 3, 4, 7, and 8.\nThe resulting sum of nums is 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36, which is the minimum. \nThe sum of the six integers appended is 1 + 2 + 3 + 4 + 7 + 8 = 25, so we return 25.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109\n\t1 <= k <= 108",
        "solutions": [
            {
                "id": 1823630,
                "title": "n-n-1-2",
                "content": "What a tricky problem. We sort numbers, and then swipe the range from 1 to 10^9, appending numbers that do not appear in the array.\\n    \\nHowever, this will cause TLE, since `k` can be very large.\\n\\nWhat we can do is to compute the minimal possible sum as `k * (k + 1) / 2)`. Then, we go through *unique* numbers in the array, and substitute all numbers less than, or equal `k`, with increasing numbers greater than `k`.\\n\\n**C++**\\n```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = (long long)k * (k + 1) / 2;\\n    for (int n : set<int>(begin(nums), end(nums)))\\n        if (n <= k)\\n            res += (++k) - n;\\n    return res;\\n}\\n```\\n#### Optimized Version\\nHere we use in-place heap, and exit early if there are no more numbers `<= k`. Compared to the above, the runtime is improved by ~100 ms.\\n**C++**\\n```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = (long long)k * (k + 1) / 2, last = 0;\\n    make_heap(begin(nums), end(nums), greater<int>());\\n    while (!nums.empty() && nums.front() <= k) {\\n        int n = nums.front();\\n        pop_heap(begin(nums), end(nums), greater<int>()); nums.pop_back();\\n        if (n != last) \\n            res += (++k) - n;\\n        last = n;\\n    }\\n    return res;\\n}\\n```\\n#### Original Solution\\nSame idea, but longer/less efficient. We use gaps between sorted numbers to compute the sum.\\n**C++**\\n```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = 0, cur = 1;\\n    nums.push_back(INT_MAX);\\n    sort(begin(nums), end(nums));\\n    for (int i = 0; k > 0 && i < nums.size(); ++i) {\\n        int take = max(0, min(k, nums[i] - (int)cur));\\n        res += (cur + take) * (cur + take - 1) / 2 - cur * (cur - 1) / 2;\\n        k -= take;\\n        cur = (long long)nums[i] + 1;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = (long long)k * (k + 1) / 2;\\n    for (int n : set<int>(begin(nums), end(nums)))\\n        if (n <= k)\\n            res += (++k) - n;\\n    return res;\\n}\\n```\n```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = (long long)k * (k + 1) / 2, last = 0;\\n    make_heap(begin(nums), end(nums), greater<int>());\\n    while (!nums.empty() && nums.front() <= k) {\\n        int n = nums.front();\\n        pop_heap(begin(nums), end(nums), greater<int>()); nums.pop_back();\\n        if (n != last) \\n            res += (++k) - n;\\n        last = n;\\n    }\\n    return res;\\n}\\n```\n```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = 0, cur = 1;\\n    nums.push_back(INT_MAX);\\n    sort(begin(nums), end(nums));\\n    for (int i = 0; k > 0 && i < nums.size(); ++i) {\\n        int take = max(0, min(k, nums[i] - (int)cur));\\n        res += (cur + take) * (cur + take - 1) / 2 - cur * (cur - 1) / 2;\\n        k -= take;\\n        cur = (long long)nums[i] + 1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823621,
                "title": "python-explanation-with-pictures",
                "content": "\\n\\n#### Assume that the gaps between integers in **A** are empty cells, one for each unique integer.\\n\\nIn order to get the minimum sum, we need to fill the empty cell in ascending order.\\nFor example.\\n![image](https://assets.leetcode.com/users/images/4e1d73b8-aa58-4870-8d19-39b50887d165_1646539263.724971.png)\\n\\nWe definitely don\\'t want to fill these cells one by one.\\n\\n<br/> \\n\\n#### Any better approaches than brute force?\\nWe can find the first integer (**A[i]** for example) in A, such that **A[i]** has enough empty cells on its left. Thus the total sum equals **(k + i)\\\\*(k + i + 1)/2 - sum(A[:i])** , where the second term equals the sum of numbers in A which are smaller than **A[i]**. \\n\\nTake the picture below as an example, assume k = 5, cells 1-8 are filled with either the original integers from **A** or the inserted integers. \\n\\n![image](https://assets.leetcode.com/users/images/de59a9b2-9e7a-4da8-878d-0988efbbf34e_1646573178.3445907.png)\\n\\n#### How to find the first **A[i]**?\\n\\nGiven an input array with unique integers ```A```, how many empty cells to the left of ```A[i]```?\\n![image](https://assets.leetcode.com/users/images/7f03f823-936e-45de-b09b-f2d25c37091f_1646539267.3917396.png)\\n\\nWe can find the first integer in ```A``` that has enough empty cells for ```k``` numbers, with brute-force iteration.\\n> More specifically: \\n> - A[0] = 2 and has 1 empty cell to its left.\\n> - A[1] = 4 and has 2 empty cells to its left.\\n> - A[2] = 7 and has 4 empty cells to its left.\\n> - ... \\n> - A[3] = 10 and has 6 empty cells to its left which are enough to hold k(5) numbers.\\n> - A[3] is the **first integer** in A that has enough empty cells on its left.\\n\\n![image](https://assets.leetcode.com/users/images/37f1ef96-b3d5-4c06-8fd4-1eb6ce79ed9e_1646539270.4645138.png)\\n\\nWe won\\'t use linear time iteration, but use Binary Search to locate this integer in logarithmic time (doesnt affect the overall time complexity)\\n\\n**(The binary search is NOT necessary, we can just iterate over all A[i]\\'s until we find the first valid i. \\nThanks to whoever corrected me. \\nPlease also refer to [votrubac\\'s solution](https://leetcode.com/problems/append-k-integers-with-minimal-sum/discuss/1823630/n-*-(n-%2B-1)-2) or other top solutions!)**\\n\\n<details>\\n<summary> Original binary search (NOT necessary) </summary>  \\n![image](https://assets.leetcode.com/users/images/9b085225-7433-426e-bd41-24957a89cfae_1646539273.7650201.png)\\n\\nIf the A[middle] has less than k empty cells on its left, we move on to the right half, otherwise, we move on to the left half.\\n\\n</details>  \\n    \\n<br/> \\n<br/> \\n  \\n    \\n\\t\\n#### What to do when we find the A[i]?\\n\\nRecall the second picture:\\n>  - We want to insert 5 integers.\\n> - A[3] = 10 is the **first integer** having enough(>=5) empty cells on its left.\\n> - There are **3** elements in A which is smaller than 10 (Since A[3] = 10).\\n> - **3+5=8**, thus, integers 1 - 8 are filled by either original elements from A, or the inserted integers.\\n> - The inserted sum equals: **1+2+...+8 - sum(A[:3])**\\n> \\n\\n![image](https://assets.leetcode.com/users/images/15ebfbbb-1d6a-4514-bac9-ba29419d943e_1646573464.2276042.png)\\n\\n#### Some Tips\\n- **A** might contain duplicate numbers, get the unique integers first.\\n- If the largest element in **A** doesn\\'t have enough cells on its left, it equals that we filled every integer from 1 to k + len(A), then the total sum equals: 1+2+3+...+(k+len(A)) - sum(A).\\n\\n```\\ndef minimalKSum(self, A: List[int], k: int) -> int:\\n        A = sorted(list(set(A)))\\n        n = len(A)\\n        \\n        if A[n - 1] <= k + n:\\n            return (k + n) * (k + n + 1) // 2 - sum(A)\\n\\n        lft, rgt = 0, n - 1\\n        while rgt > lft:\\n            mid = (lft + rgt) // 2\\n            if A[mid] - mid <= k:\\n                lft = mid + 1\\n            else:\\n                rgt = mid\\n\\n        return (k + lft) * (k + lft + 1) // 2 - sum(A[:lft])\\n```\\n\\n",
                "solutionTags": [],
                "code": "```A```\n```A[i]```\n```A```\n```k```\n```\\ndef minimalKSum(self, A: List[int], k: int) -> int:\\n        A = sorted(list(set(A)))\\n        n = len(A)\\n        \\n        if A[n - 1] <= k + n:\\n            return (k + n) * (k + n + 1) // 2 - sum(A)\\n\\n        lft, rgt = 0, n - 1\\n        while rgt > lft:\\n            mid = (lft + rgt) // 2\\n            if A[mid] - mid <= k:\\n                lft = mid + 1\\n            else:\\n                rgt = mid\\n\\n        return (k + lft) * (k + lft + 1) // 2 - sum(A[:lft])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823746,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        sort(nums.begin(), nums.end());\\n        long long s = 0;\\n        int i = 0;\\n        int prev = 0;\\n        while(k>0 && i<nums.size()){\\n            int len = nums[i] - prev - 1;\\n            if(len>k) len = k;\\n            if(len>0){\\n                long long int start = prev;\\n                long long int end = start + len;\\n                long long int sum = (end*(end+1))/2 - (start*(start+1))/2;\\n                s += sum;\\n                k -= len;\\n            }\\n            prev = nums[i]; i++;\\n        }\\n        if(k>0){\\n            long long int start = prev;\\n            long long int end = start + k;\\n            long long int sum = (end*(end+1))/2 - (start*(start+1))/2;\\n            s += sum;\\n        }\\n        return s;\\n    }\\n};\\n```\\n*If you like the solution, please Upvote \\uD83D\\uDC4D!!*",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        sort(nums.begin(), nums.end());\\n        long long s = 0;\\n        int i = 0;\\n        int prev = 0;\\n        while(k>0 && i<nums.size()){\\n            int len = nums[i] - prev - 1;\\n            if(len>k) len = k;\\n            if(len>0){\\n                long long int start = prev;\\n                long long int end = start + len;\\n                long long int sum = (end*(end+1))/2 - (start*(start+1))/2;\\n                s += sum;\\n                k -= len;\\n            }\\n            prev = nums[i]; i++;\\n        }\\n        if(k>0){\\n            long long int start = prev;\\n            long long int end = start + k;\\n            long long int sum = (end*(end+1))/2 - (start*(start+1))/2;\\n            s += sum;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823848,
                "title": "java-solution-use-n-n-1-2",
                "content": "\\n        Arrays.sort(nums);\\n        Set<Integer> set = new HashSet<>();\\n        long sum = 0;\\n        \\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;        \\n            }            \\n            set.add(num);\\n        }\\n        \\n        long res = (long)(1 + k) * k / 2 - sum;\\n        return res;        \\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "\\n        Arrays.sort(nums);\\n        Set<Integer> set = new HashSet<>();\\n        long sum = 0;\\n        \\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;        \\n            }            \\n            set.add(num);\\n        }\\n        \\n        long res = (long)(1 + k) * k / 2 - sum;\\n        return res;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1823619,
                "title": "c-sorting-o-nlogn-time",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Sorting\\n\\n**Intuition**: Sort the array. Traverse from left to right, sum up the missing numbers between `A[i-1]` and `A[i]` until we\\'ve used `k` missing numbers.\\n\\n**Algorithm**:\\n\\nFor a given `A[i]`, the previous number `prev` is `A[i-1]` or `0` if `A[i-1]` doesn\\'t exist.\\n\\nThere are `cnt = min(k, max(0, A[i] - prev - 1))` missing numbers inbetween, i.e. from `prev+1` to `prev+cnt`. The sum of these numbers is `(prev+1 + prev+cnt) * cnt / 2`.\\n\\nIf there are still `k` missing numbers after traversing the array, the rest of the missing numbers are `A[N-1]+1` to `A[N-1]+k`. The sum of them is `(A[N-1]+1 + A[N-1]+k) * k / 2`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/append-k-integers-with-minimal-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& A, int k) {\\n        sort(begin(A), end(A));\\n        long ans = 0, N = A.size();\\n        for (int i = 0; i < N && k; ++i) {\\n            long prev = i == 0 ? 0 : A[i - 1]; // the previous number\\n            long cnt = min((long)k, max((long)0, A[i] - prev - 1)); // the count of missing numbers between `prev` and `A[i]`\\n            k -= cnt; // use these `cnt` missing numbers\\n            ans += (long)(prev + 1 + prev + cnt) * cnt / 2; // sum of these `cnt` missing numbers `[prev+1, prev+cnt]`.\\n        }\\n        if (k > 0) ans += ((long)A.back() + 1 + A.back() + k) * k / 2; // If there are still missing numbers, add the sum of numbers`[A.back()+1, A.back()+k]` to answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/append-k-integers-with-minimal-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& A, int k) {\\n        sort(begin(A), end(A));\\n        long ans = 0, N = A.size();\\n        for (int i = 0; i < N && k; ++i) {\\n            long prev = i == 0 ? 0 : A[i - 1]; // the previous number\\n            long cnt = min((long)k, max((long)0, A[i] - prev - 1)); // the count of missing numbers between `prev` and `A[i]`\\n            k -= cnt; // use these `cnt` missing numbers\\n            ans += (long)(prev + 1 + prev + cnt) * cnt / 2; // sum of these `cnt` missing numbers `[prev+1, prev+cnt]`.\\n        }\\n        if (k > 0) ans += ((long)A.back() + 1 + A.back() + k) * k / 2; // If there are still missing numbers, add the sum of numbers`[A.back()+1, A.back()+k]` to answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823867,
                "title": "problem-there-s-a-bigint-problem-with-javascript-updated-js-can-pass-now",
                "content": "For the test case `[1000000000] 1000000000`, the output should be `500000000500000001`. But in JS, we can\\'t have such a big number during general calculation.\\n\\nI know we could use `BigInt`, and I did it also. But, no matter I return the final BigInt `500000000500000001n` or I convert it into string `500000000500000001`, the judge will always show my answer is `500000000500000000` and tell me it\\'s wrong. __Seems like the judge always try to convert the result into a general number in JS.__\\n\\nAfter several times, I finally have to implement this in another language... T_T\\n\\nTo fix this, the solution is easy, for this problem in JS judge, it could try to __accept the `BigInt` result__.\\n\\nThe core strategy is simple, but maybe next time judge could try to think about such big number testcase in JS more.\\nI guess the purpose for this problem is not to ask us to implement our own bigint calculation in JS, haha\\n\\n- - -\\n\\nUPDATE:\\n\\nI\\'ve submitted this problem to [official github repo here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6632).\\n\\n- - -\\n\\nUPDATE:\\n\\nThe test cases have been updated - added a limitation. So right now, we could use JS to make this problem AC.\\n\\nThe core strategy is:\\n- assume all the numbers from 1 to `k` is unused, so we could get the init `sum`\\n- count the numbers smaller than `k` in `nums` and minus them from `sum`\\n- add new numbers from `k + 1` to meets the count `k` (take care of the new number is in `nums`)\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst minimalKSum = (nums, k) => {\\n  const set = new Set(nums);\\n  let sum = (1 + k) * k / 2;\\n  let more = 0;\\n  nums = Array.from(set)\\n  for (const n of nums) {\\n    n <= k && (++more, sum -= n);\\n  }\\n  while (more > 0) {\\n    !set.has(++k) && (sum += k, --more);\\n  }\\n  return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst minimalKSum = (nums, k) => {\\n  const set = new Set(nums);\\n  let sum = (1 + k) * k / 2;\\n  let more = 0;\\n  nums = Array.from(set)\\n  for (const n of nums) {\\n    n <= k && (++more, sum -= n);\\n  }\\n  while (more > 0) {\\n    !set.has(++k) && (sum += k, --more);\\n  }\\n  return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823675,
                "title": "c-sum-of-first-k-natural-numbers-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long ans=(long(k)*(long(k+1)))/2;\\n        // be sure to use unique numbers in nums\\n        unordered_set<int>st(nums.begin(),nums.end());\\n        nums.clear();\\n        for(auto &i:st)\\n            nums.push_back(i);\\n        // sort nums\\n        sort(begin(nums),end(nums));\\n        int sz=nums.size();\\n        // iterate over the array\\n        for(int i=0;i<sz;i++){\\n            // if you have added a number in nums that was already present in nums then remove that and add next candidate that is k+1\\n          if(nums[i]<=k ){\\n                ans-=nums[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it thelps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long ans=(long(k)*(long(k+1)))/2;\\n        // be sure to use unique numbers in nums\\n        unordered_set<int>st(nums.begin(),nums.end());\\n        nums.clear();\\n        for(auto &i:st)\\n            nums.push_back(i);\\n        // sort nums\\n        sort(begin(nums),end(nums));\\n        int sz=nums.size();\\n        // iterate over the array\\n        for(int i=0;i<sz;i++){\\n            // if you have added a number in nums that was already present in nums then remove that and add next candidate that is k+1\\n          if(nums[i]<=k ){\\n                ans-=nums[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823808,
                "title": "java-python-3-two-methods-w-brief-explanation-and-analysis",
                "content": "**Method 1:**\\nSort and Track low missing bound and compute the arithmetic sequence.\\n\\n1. Sort the input;\\n2. Starting from `1` as the lower bound of the missing range, then based on current `num` and `k`, determine current missing upper bound `hi`; Compute the subtotal in [lo, hi] and add it to `ans`.\\n```java\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        long ans = 0, lo = 1;\\n        for (int num : nums) {\\n            if (num > lo) {\\n                long hi = Math.min(num - 1, lo + k - 1);\\n                int cnt = (int)(hi - lo + 1);\\n                ans += (lo + hi) * cnt / 2;\\n                k -= cnt;\\n                if (k == 0) {\\n                    return ans;\\n                }\\n            } \\n            lo = num + 1;\\n        }\\n        if (k > 0) {\\n            ans += (lo + lo + k - 1) * k / 2;\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans, lo = 0, 1\\n        cnt = 0\\n        for num in sorted(nums):\\n            if num > lo:\\n                hi = min(num - 1, k - 1 + lo)\\n                cnt = hi - lo + 1\\n                ans += (lo + hi) * cnt // 2 \\n                k -= cnt\\n                if k == 0:\\n                    return ans\\n            lo = num + 1\\n        if k > 0:\\n            ans += (lo + lo + k - 1) * k // 2\\n        return ans\\n```\\n\\n----\\n\\n**Method 2:**\\n\\nStart from the sum of `1` to `k`, `ans`, then traverse the sorted distinct numbers of input array, `nums`; whenever find a `num` not greater than `k`, we need to deduct it from `ans` and add `++k`.\\n\\n\\n```java\\n    public long minimalKSum(int[] nums, int k) {\\n        long ans = k * (k + 1L) / 2;\\n        TreeSet<Integer> unique = new TreeSet<>();\\n        for (int num : nums) {\\n            unique.add(num);\\n        }\\n        while (!unique.isEmpty()) {\\n            int first = unique.pollFirst();\\n            if (k >= first) {\\n                ans += ++k - first;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n```python\\nfrom sortedcontainers import SortedSet\\n\\nclass class:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = k * (k + 1) // 2\\n        for num in SortedSet(nums):\\n            if k >= num:\\n                k += 1\\n                ans += k - num\\n        return ans\\n```\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(n)` - including sorting space, where `n = nums.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        long ans = 0, lo = 1;\\n        for (int num : nums) {\\n            if (num > lo) {\\n                long hi = Math.min(num - 1, lo + k - 1);\\n                int cnt = (int)(hi - lo + 1);\\n                ans += (lo + hi) * cnt / 2;\\n                k -= cnt;\\n                if (k == 0) {\\n                    return ans;\\n                }\\n            } \\n            lo = num + 1;\\n        }\\n        if (k > 0) {\\n            ans += (lo + lo + k - 1) * k / 2;\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans, lo = 0, 1\\n        cnt = 0\\n        for num in sorted(nums):\\n            if num > lo:\\n                hi = min(num - 1, k - 1 + lo)\\n                cnt = hi - lo + 1\\n                ans += (lo + hi) * cnt // 2 \\n                k -= cnt\\n                if k == 0:\\n                    return ans\\n            lo = num + 1\\n        if k > 0:\\n            ans += (lo + lo + k - 1) * k // 2\\n        return ans\\n```\n```java\\n    public long minimalKSum(int[] nums, int k) {\\n        long ans = k * (k + 1L) / 2;\\n        TreeSet<Integer> unique = new TreeSet<>();\\n        for (int num : nums) {\\n            unique.add(num);\\n        }\\n        while (!unique.isEmpty()) {\\n            int first = unique.pollFirst();\\n            if (k >= first) {\\n                ans += ++k - first;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\nfrom sortedcontainers import SortedSet\\n\\nclass class:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = k * (k + 1) // 2\\n        for num in SortedSet(nums):\\n            if k >= num:\\n                k += 1\\n                ans += k - num\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823958,
                "title": "idea-explained-with-example-sort-and-count-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is pretty straightforward. Since we need to get sum as minimal,\\n\\n* We have to choose smallest element first\\n* And in order to get smallest elements, we need to sort `nums` first.\\n* Then we append element that are between say **`(prev, curr)`** (exclusive).\\n* In this way, we can get smallest element first. (starting from 0)\\n* We need to take care of case when all elements in array are finished,\\n\\t* And we have few elements left to append.\\n\\t* In this case we append element starting from prev till remaining number of elements.\\n\\n\\n\\t\\t\\t\\tEx:  nums = [5, 6], k = 6\\n\\n\\t\\t\\t\\t\\t -> prev here is 0, starting point\\n\\n\\t\\t\\t\\t1. i=0 , k = 6, prev = 0, curr = 5, diff = 5-0-1 = 4\\n\\t\\t\\t\\t\\t-> thus we choose element b/w (0, 5) i.e { 1,2,3,4 }.\\n\\t\\t\\t\\t\\t\\t-> sum = 1+2+3+4 = 10\\n\\t\\t\\t\\t\\t\\t-> k = k - diff = 6 - 4 = 2\\n\\t\\t\\t\\t\\t\\t-> prev = 5\\n\\n\\t\\t\\t\\t2. i =1, k = 2, prev = 5, curr = 6, diff = -1, \\n\\t\\t\\t\\t\\t-> since diff is negative, we cannot get elements b/w (5, 6)\\n\\t\\t\\t\\t\\t-> update, prev = 6\\n\\n\\t\\t\\t\\tNow, we have no elements in nums left, and k is also not 0,\\n\\t\\t\\t\\tSo we need to add k = 2, more element from prev\\n\\t\\t\\t\\t\\ti.e (6, 6+3) = (6, 9) => {7, 8}\\n\\n\\t\\t\\t\\t\\t-> sum = 10 + 7 + 8 = 25\\n\\t\\t\\t\\n# Code :\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        // Sort array so that we can get smaller elements first\\n        sort(begin(nums), end(nums));\\n        \\n        long long sum = 0;\\n        \\n        // Previous element that we encountered\\n        int prev = 0, curr = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            \\n            curr = nums[i];\\n            \\n            // Get the difference b/w prev and current \\n            // So that we can append elements that are in between them\\n            long long diff = (curr - prev - 1);\\n            \\n            // If prev and current are same then just skip\\n            if(diff <= 0) {\\n                prev = curr;\\n                continue;\\n            }\\n            \\n            // If there are more available elements b/w prev and current\\n            // Then we just take closest k element from prev.\\n            // And leave remaining as it is\\n            if(diff > k) {\\n                diff = k;\\n                curr = prev + k + 1;\\n            }\\n            \\n            // Get the sum of all elements b/w prev and current\\n            // Since it is AP series, we can use direct formula\\n            sum += (diff * 1LL * (curr + prev) / 2);\\n            \\n            // Update previous to current\\n            prev = curr;\\n            \\n            // Update count of how many more element we need to append \\n            k -= diff;\\n            \\n            if(k == 0) break;\\n        }\\n        \\n        // Case : When we have reached the end of array \\n        // And still we have some more element left to append\\n        if(k) {\\n            sum += (k * 1LL * (2 * prev + k + 1) / 2);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(NlogN + N)`, N is size of `nums` array\\n\\t* To sort the array first\\n\\t* And then iterate over to get sum \\n\\n* Space : `O(1)`\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        // Sort array so that we can get smaller elements first\\n        sort(begin(nums), end(nums));\\n        \\n        long long sum = 0;\\n        \\n        // Previous element that we encountered\\n        int prev = 0, curr = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            \\n            curr = nums[i];\\n            \\n            // Get the difference b/w prev and current \\n            // So that we can append elements that are in between them\\n            long long diff = (curr - prev - 1);\\n            \\n            // If prev and current are same then just skip\\n            if(diff <= 0) {\\n                prev = curr;\\n                continue;\\n            }\\n            \\n            // If there are more available elements b/w prev and current\\n            // Then we just take closest k element from prev.\\n            // And leave remaining as it is\\n            if(diff > k) {\\n                diff = k;\\n                curr = prev + k + 1;\\n            }\\n            \\n            // Get the sum of all elements b/w prev and current\\n            // Since it is AP series, we can use direct formula\\n            sum += (diff * 1LL * (curr + prev) / 2);\\n            \\n            // Update previous to current\\n            prev = curr;\\n            \\n            // Update count of how many more element we need to append \\n            k -= diff;\\n            \\n            if(k == 0) break;\\n        }\\n        \\n        // Case : When we have reached the end of array \\n        // And still we have some more element left to append\\n        if(k) {\\n            sum += (k * 1LL * (2 * prev + k + 1) / 2);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825862,
                "title": "easiest-solution-very-short-code-cpp",
                "content": "1.  We only need to get the minimum sum of k values need to be inserted.\\n2.  We will use n*(n+1)/2 to calculate the sum upto k values.\\n3.  We will delete the value that is present in the array and add the next k+1 value to the sum.\\n4.  We have to handle the duplicate value case So we will use Set.\\n5.  Set will sort the array and give the unique elements in it. \\n\\n``` \\nlong long minimalKSum(vector<int>& nums, int k) {     \\n        set<int>s(nums.begin(),nums.end());\\n        long long ans = (long(k)*(long(k+1)))/2; \\n        for(auto i:s){\\n            if(i<=k){ \\n            ans+=k+1;\\n            ans-=i;\\n            k++;\\n          }\\n            else  \\n                break;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKE AND USE CODE.  ; )**",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` \\nlong long minimalKSum(vector<int>& nums, int k) {     \\n        set<int>s(nums.begin(),nums.end());\\n        long long ans = (long(k)*(long(k+1)))/2; \\n        for(auto i:s){\\n            if(i<=k){ \\n            ans+=k+1;\\n            ans-=i;\\n            k++;\\n          }\\n            else  \\n                break;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823628,
                "title": "python3-swap",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/bb5647e856ff11b072f9c51a140e0f243c100171) for solutions of weekly 283.\\n\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = k*(k+1)//2\\n        prev = -inf \\n        for x in sorted(nums): \\n            if prev < x: \\n                if x <= k: \\n                    k += 1\\n                    ans += k - x\\n                else: break\\n                prev = x\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = k*(k+1)//2\\n        prev = -inf \\n        for x in sorted(nums): \\n            if prev < x: \\n                if x <= k: \\n                    k += 1\\n                    ans += k - x\\n                else: break\\n                prev = x\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179086,
                "title": "clearly-explained-shortest-min-heap-solution",
                "content": "1. Get the sum of first k natural numbers \\n \\n2.  make a min heap , insert nums in the heap\\n \\n3.  now if the smallest number in heap is less than or equal to k ,we need to delete that number from our sum and add some greater value\\n \\n4.  subtract top from sum and after incrementing k , add the new value of k to sum \\n \\n example : nums=[1,3,5] , k=4\\n \\n sum = 1+2+3+4= (4*(4+1))/2 = 10 \\n \\n but here 1 is in nums so we need to subtract 1  from sum and add (k+1)\\n k=k+1 -> k=5\\n sum=sum-1+5 -> sum= 10-1+5 = 14\\n \\n now , top of heap is 3 \\n k=5+1=6\\n sum=14-3+6=17\\n \\n now , top of the heap is 5\\n k=6+1=7\\n sum=17-5+7=19\\n \\n answer is 19 . \\n\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long sum=((long long)k*(k+1))/2;\\n        \\n        \\n        for(int x:nums){\\n            pq.push(x);\\n        }\\n        \\n        while(!pq.empty() && k>=pq.top()){\\n            \\n            k=k+1;\\n            int temp=pq.top();\\n            pq.pop();\\n            while(!pq.empty() && temp==pq.top()){\\n                pq.pop();\\n            }\\n            sum=sum-temp+k;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n**I\\'m new here . Please UPVOTE if you like my solution , DOWNVOTE otherwise **",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long sum=((long long)k*(k+1))/2;\\n        \\n        \\n        for(int x:nums){\\n            pq.push(x);\\n        }\\n        \\n        while(!pq.empty() && k>=pq.top()){\\n            \\n            k=k+1;\\n            int temp=pq.top();\\n            pq.pop();\\n            while(!pq.empty() && temp==pq.top()){\\n                pq.pop();\\n            }\\n            sum=sum-temp+k;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824492,
                "title": "python-explanation-sort-and-add",
                "content": "**Idea:** \\n* As we need samllest sum possible we need to choose smallest numbers that we can add.\\n* To get smallest numbers we need to sort `nums` first.\\n* Then append the numbers which are between suppose `(prev,curr)` or `(nums[i],nums[i+1])`.\\n* This way we can get smallest numbers possible.\\n* Now we need to take care of case when all numbers in array/list is finished but we still need to append some numbers.\\n* Now in this case we will append numbers starting from `prev` till remaining numbers.\\n\\n**Example:**\\nFirst Case:\\n```\\nnums = [1,4,25,10,25], k = 2\\nSo let\\'s first sort nums.\\nnums=[1,4,10,25,25]\\n\\nNow prev=0    # starting point\\ncurr=nums[0]=1 \\nNow there is no number betwenn (prev,curr) that we can add in array/list.\\nSo, move curr to next elemnt of nums and prev to curr.\\n\\nprev=1\\ncurr=4\\n(prev,curr)=2,3\\nsum=2+3=5\\nSo add 2 and 3. Now k become 0 so stop the process.\\n\\nAnd return sum.\\n```\\n\\nSecond case:\\n```\\nnums = [5,6], k = 6\\nso let\\'s first sort nums.\\nnums=[5,6]\\n\\nNow prev=0     # starting point\\ncurr=nums[0]=5\\n(prev,curr)=1,2,3,4\\nsum=1+2+3+4=10\\nk=2\\nAs k is not 0 continue the process.\\n\\nNow prev=curr=5\\ncurr=nums[1]=6\\nNow there is no number betwenn (prev,curr) that we can add in array/list.\\n\\nnow prev=curr=6\\nbut now we finished all numbers of nums. but still we need to add two more numbers.\\nwe do not have number to update curr.\\n\\nSo, now start from prev and continue adding numbers untill k becomes zero.\\nnumbers=7,8\\n\\nsum=sum+7+8\\n   =10+7+8\\n   =25\\n\\nand k=0\\nreturn sum\\n```\\n\\n**Note:**\\nWe can\\'t just iterate from all numbers between prev and curr to find sum of added number. As it might give TLE. So we can use formula for sum of Arithmetic Progression. As number between prev and curr will be in Arithmetic Progression with difference 1.\\n\\n**Formula for sum of AP:**\\n```\\nFormula 1: n/2(a + l)\\nwhere,\\nn = number of terms\\na=first term\\nl=last term\\n\\nFormula 2:  n/2[2a + (n \\u2212 1) \\xD7 d]\\nWhere, \\nn = number of terms\\na=first term\\nd=difference between two term\\n```\\n\\nWe will be using this formula to find sum betwenn (prev,curr).\\n\\n**Code:**\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        curr=prev=0   # intialize both curr and prev  \\n        nums.sort()    # sort the nums\\n        sum=0     \\n        for i in range(n):\\n            curr=nums[i]     # make curr equal to prev\\n            diff=curr-(prev+1)    # find if there is any numbers in (prev,curr)\\n            if diff<=0:      # if no then update prev and continue \\n                prev=curr\\n                continue\\n            if diff>k:       # if yes then if number between (prev,curr) is more then k \\n                diff=k   # then we will consider first k numbers only\\n                curr=prev+1+k # update curr to last number that we will add to use formula 1 of A.P.\\n            sum+=(diff*(curr+prev)//2)  # formula 1 of A.P.\\n            prev=curr  # update prev to curr\\n            k-=diff   # update k\\n            if k==0:   # if k is 0 then return\\n                break\\n        if k:  # second case  # we have finish nums but wnat to add more numbers\\n            sum+=(k*(2*prev+k+1)//2)   # use formual 2 of A.P. we take d=1\\n        return sum\\n```\\nUpvote if you find it helpful :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nnums = [1,4,25,10,25], k = 2\\nSo let\\'s first sort nums.\\nnums=[1,4,10,25,25]\\n\\nNow prev=0    # starting point\\ncurr=nums[0]=1 \\nNow there is no number betwenn (prev,curr) that we can add in array/list.\\nSo, move curr to next elemnt of nums and prev to curr.\\n\\nprev=1\\ncurr=4\\n(prev,curr)=2,3\\nsum=2+3=5\\nSo add 2 and 3. Now k become 0 so stop the process.\\n\\nAnd return sum.\\n```\n```\\nnums = [5,6], k = 6\\nso let\\'s first sort nums.\\nnums=[5,6]\\n\\nNow prev=0     # starting point\\ncurr=nums[0]=5\\n(prev,curr)=1,2,3,4\\nsum=1+2+3+4=10\\nk=2\\nAs k is not 0 continue the process.\\n\\nNow prev=curr=5\\ncurr=nums[1]=6\\nNow there is no number betwenn (prev,curr) that we can add in array/list.\\n\\nnow prev=curr=6\\nbut now we finished all numbers of nums. but still we need to add two more numbers.\\nwe do not have number to update curr.\\n\\nSo, now start from prev and continue adding numbers untill k becomes zero.\\nnumbers=7,8\\n\\nsum=sum+7+8\\n   =10+7+8\\n   =25\\n\\nand k=0\\nreturn sum\\n```\n```\\nFormula 1: n/2(a + l)\\nwhere,\\nn = number of terms\\na=first term\\nl=last term\\n\\nFormula 2:  n/2[2a + (n \\u2212 1) \\xD7 d]\\nWhere, \\nn = number of terms\\na=first term\\nd=difference between two term\\n```\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        curr=prev=0   # intialize both curr and prev  \\n        nums.sort()    # sort the nums\\n        sum=0     \\n        for i in range(n):\\n            curr=nums[i]     # make curr equal to prev\\n            diff=curr-(prev+1)    # find if there is any numbers in (prev,curr)\\n            if diff<=0:      # if no then update prev and continue \\n                prev=curr\\n                continue\\n            if diff>k:       # if yes then if number between (prev,curr) is more then k \\n                diff=k   # then we will consider first k numbers only\\n                curr=prev+1+k # update curr to last number that we will add to use formula 1 of A.P.\\n            sum+=(diff*(curr+prev)//2)  # formula 1 of A.P.\\n            prev=curr  # update prev to curr\\n            k-=diff   # update k\\n            if k==0:   # if k is 0 then return\\n                break\\n        if k:  # second case  # we have finish nums but wnat to add more numbers\\n            sum+=(k*(2*prev+k+1)//2)   # use formual 2 of A.P. we take d=1\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823649,
                "title": "python-solution-using-ap-sum-explained",
                "content": "**Idea Used:**\\nHere we use the idea of adding the sum of values that exist b/w all consecutive values until we expire all k given to us. \\n\\n**Steps:**\\n\\n1. Sort the numbers and add 0 to the start and 2000000001 to the end of the list.\\n2. Now go through all the n values of nums\\n3. For each iteration select ith value as start and i+1th value as end\\n4. In the current iteration we will be adding values b/w start and end as long as k does\\'nt expire\\n5. If start == end then continue\\n6. Now we sill be using the values start+1, start+2 ... end -2, end-1. We would not use the values start and end themselves.\\n7. We know that sum of consecutive integers is given by the AP formula with `d = 1`\\n8. Add this sum to the result and remove the number of integers used from k\\n\\n**Why I added 0 and 2000000001:**\\nSince the +ve integers start from 1, and it is not certain that the list might start from 1. We should manually take care of the smallest elements to add so as to minimize the possible sum. So I added 0 to allow it to blend in with the algorithm perfectly.\\nThe reason I added 2000000001 is to prevent ourselves from running out of +ve numbers even when all k havent expired\\n\\n**Formula for sum in AP (arithmetic progression)**\\nThe sum of given AP `a, a+d, a+2d, a+3d ... a+(i-1)d ... a+(n-1)d` is:\\n`S = n/2[2a + (n \\u2212 1) \\xD7 d]` where a is the first term and n is the total number of terms in AP\\n*In our case since we will be dealing with consecutive numbers `d = 1`*\\n\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res = 0\\n        nums.insert(0, 0)\\n        nums.append(2000000001)\\n        n = len(nums)\\n        for i in range(n-1):\\n            start = nums[i] # This is the lowerbound for current iteration\\n            end = nums[i+1] # This is the higherbound for current iteration\\n            if start == end:\\n                continue\\n            a = start + 1 # Starting value is lowerbound + 1\\n            n = min(end - start - 1, k) # Since the total number possible b/w start and end might be more than the k numbers left, so always choose the minimum.\\n            v = (n*(2*a + n - 1))//2 # n/2[2a + (n-1)d] with d = 1\\n            res += v # Add the sum of elements selected into res\\n            k -= n # n number of k\\'s expired, thus k decrements\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res = 0\\n        nums.insert(0, 0)\\n        nums.append(2000000001)\\n        n = len(nums)\\n        for i in range(n-1):\\n            start = nums[i] # This is the lowerbound for current iteration\\n            end = nums[i+1] # This is the higherbound for current iteration\\n            if start == end:\\n                continue\\n            a = start + 1 # Starting value is lowerbound + 1\\n            n = min(end - start - 1, k) # Since the total number possible b/w start and end might be more than the k numbers left, so always choose the minimum.\\n            v = (n*(2*a + n - 1))//2 # n/2[2a + (n-1)d] with d = 1\\n            res += v # Add the sum of elements selected into res\\n            k -= n # n number of k\\'s expired, thus k decrements\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823674,
                "title": "arithmetic-progression-explained-with-example-clean-code-with-comment",
                "content": "So first I came up with this approach during contest,\\nStart from 1 and keep adding the first k-missing integers into results, but it would cost O(k) time at most.\\n\\n**For example :**\\nnums[1,100000]  and k = 1e9\\nSo in this case we will be adding 1e9-2 elements. So intution behind O(k) will give TLE because k is very large.\\n\\nSo, let\\'s think again what we did which cause TLE.\\nSuppose,\\nnums[i] =  x\\nnums[i+1] = y\\n\\nx<y than atmost y-x-1 element we can add it right? Now we break the problem i.e. from going i-th index to i+1\\'th index it would be cost sum[x+1....y). Now is there any way to get this sum fastly?\\n1. Since we can jump from i-th point to i+1\\'th point only when x<=y. And problem description is not intreseted with order so let\\'s short it.\\n2. Now we did sorting. So we know that from going i-th index to i+1\\'th index { sum[x+1....y) } all the element will be contigues elements. So we know that how max element we can add into this gap and we can get the sum easily using sum of AP series. i.e.\\n\\t\\t*(n/2)*[2*a+(n-1)*d]*\\n\\t\\t*  Where \\'n\\' will be nums[i+1]-nums[i] for every i index.\\n\\t\\t*  \\'a\\' will be the first element( we\\'ll start adding from nums[i]+1 so a=nums[i]+1).\\n\\t\\t*  \\'d\\' will be 1 because for min sum we\\'ll keep adding continuos elements.\\n```\\nclass Solution {\\npublic:\\n    long long getApSum(long long a, long long n, long long d) {\\n        return  ((2*a+(n-1)*d)*n)/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        \\n        // To use first element also. Like if nums start with 5 than we can add [1,2,3,4]\\n        nums.push_back(0);\\n        sort(nums.begin(), nums.end());\\n        \\n        // Keep adding till k\\n        for(int i=0;i<nums.size()-1 && k>0;i++) {\\n            \\n            // Get the length of AP which can be added.\\n            int n = nums[i+1]-nums[i]-1;\\n            \\n            // If we can\\'t add any element, for example [12,12] or [11,12].\\n            if(n<=0) continue;\\n            \\n            // If we have option to add much more than needed. For example [1,12] and k is 5. So we need only 5 element to add.\\n            if(k<n) n=k;\\n            k-= n;\\n            \\n            // Get the sum of n AP elements who\\'s first element is nums[i]+1 and keep difference of 1.\\n            res += getApSum(nums[i]+1, n, 1);\\n        }\\n        \\n        // If still we k to add element than add continuous k element from nums.back()+1.\\n        // For example : nums[1,2] and k=5 So we need add [3,4,5,6,7].\\n        if(k>0) {\\n            res+= getApSum(nums.back()+1, k, 1);\\n        }\\n        return res;\\n    }\\n};\\n```\\t\\n\\n# Time Complexity :\\n**It\\'s O(N*log N), Since we are just doing sorting. Getting N-element AP sum takes constant time.**\\n# Space Complexity :\\n**Since we are not using any extra space. So it\\'s constant space.**\\n\\n**Please upvote if it helps you.**\\n*Happy Coding :)*",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getApSum(long long a, long long n, long long d) {\\n        return  ((2*a+(n-1)*d)*n)/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        \\n        // To use first element also. Like if nums start with 5 than we can add [1,2,3,4]\\n        nums.push_back(0);\\n        sort(nums.begin(), nums.end());\\n        \\n        // Keep adding till k\\n        for(int i=0;i<nums.size()-1 && k>0;i++) {\\n            \\n            // Get the length of AP which can be added.\\n            int n = nums[i+1]-nums[i]-1;\\n            \\n            // If we can\\'t add any element, for example [12,12] or [11,12].\\n            if(n<=0) continue;\\n            \\n            // If we have option to add much more than needed. For example [1,12] and k is 5. So we need only 5 element to add.\\n            if(k<n) n=k;\\n            k-= n;\\n            \\n            // Get the sum of n AP elements who\\'s first element is nums[i]+1 and keep difference of 1.\\n            res += getApSum(nums[i]+1, n, 1);\\n        }\\n        \\n        // If still we k to add element than add continuous k element from nums.back()+1.\\n        // For example : nums[1,2] and k=5 So we need add [3,4,5,6,7].\\n        if(k>0) {\\n            res+= getApSum(nums.back()+1, k, 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466741,
                "title": "easy-explained-python-solution-faster-than-99",
                "content": "the idea is to find the last (biggest) number we gonna add to the list, by incrementing k by 1 each time we find a smaller number than it in the sorted list.\\nafter that, we calculate the sum from 1 to the last added number, and remove the sum of the existing numbers (removable_sum).\\nfor example, if k was 50 and the list contains 20 and 25, then k will become 52, and we calculate the sum of the 52 first numbers, then we remove 20 + 25 because they were already existing.\\n```python\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n\\tnums = list(set(nums))  # to remove duplicated numbers\\n\\tnums.sort()  # sorting the new list\\n\\tlast_term = k\\n\\tremovable_sum = 0\\n\\tfor num in nums :\\n\\t\\tif (num <= last_term) :  # if the current number is in the range of the k first numbers\\n\\t\\t\\tlast_term += 1  # we increment the last number we\\'re going to add\\n\\t\\t\\tremovable_sum += num  # adding the current number the sum of existing numbers\\n\\t\\telse :\\n\\t\\t\\tbreak  # if we found the k th number we break the loop\\n\\tsomme = (last_term * (1 + last_term) / 2) - removable_sum  # we calculate the sum of the arithmetic sequence minus the sum of the existing numbers\\n\\treturn int(somme)\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```python\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n\\tnums = list(set(nums))  # to remove duplicated numbers\\n\\tnums.sort()  # sorting the new list\\n\\tlast_term = k\\n\\tremovable_sum = 0\\n\\tfor num in nums :\\n\\t\\tif (num <= last_term) :  # if the current number is in the range of the k first numbers\\n\\t\\t\\tlast_term += 1  # we increment the last number we\\'re going to add\\n\\t\\t\\tremovable_sum += num  # adding the current number the sum of existing numbers\\n\\t\\telse :\\n\\t\\t\\tbreak  # if we found the k th number we break the loop\\n\\tsomme = (last_term * (1 + last_term) / 2) - removable_sum  # we calculate the sum of the arithmetic sequence minus the sum of the existing numbers\\n\\treturn int(somme)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1824336,
                "title": "o-nlogn-easy-solution-with-explaination",
                "content": "As the constraints are high (<= 10^9) this problem will give either TLE or MLE if we go through each and every element in this range.\\n\\nWhat we can do is calculate sum of first k consecutive integers initially.\\nThen if we find that element in the array, we would delete it and append a new max possible number.\\n\\nEx:\\narr: 2 3 5 7 10\\nk: 4\\nHere, \\nsum = 1 + 2 + 3 + 4 = 4 * 5 / 2 = 10\\nlast = 5\\nans (should be) = 1 + 4 + 6 + 8 = 19\\n```\\nfor(i = 0 to size - 1)\\n{\\n\\tif(element_already_present_in_array)\\n\\t{\\n\\t\\tsum -= element;\\n\\t\\tsum += last_element;\\n\\t}\\n}\\n```\\ni = 0 sum -= 2; sum += 5;  // sum = 13\\ni = 1 sum -= 3; sum += 6; // sum = 16\\ni = 2 sum -= 5; sum += 7; // sum = 18\\ni = 3 sum -= 7; sum += 8; // sum = 19\\ni = 4 do nothing as the element is greater than last max element which was needed\\n\\n**CODE:**\\n```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n        long long sum = (long long)k * (k + 1) / 2;\\n\\t\\tlong long last = k + 1;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if(i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            \\n            if(nums[i] < last)\\n            {\\n                sum -= nums[i];\\n                sum += last++;\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nfor(i = 0 to size - 1)\\n{\\n\\tif(element_already_present_in_array)\\n\\t{\\n\\t\\tsum -= element;\\n\\t\\tsum += last_element;\\n\\t}\\n}\\n```\n```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n        long long sum = (long long)k * (k + 1) / 2;\\n\\t\\tlong long last = k + 1;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if(i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            \\n            if(nums[i] < last)\\n            {\\n                sum -= nums[i];\\n                sum += last++;\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2877936,
                "title": "python-math-solution-with-explanation",
                "content": "\\n# Approach\\nThe general idea is like: if element in array is <=k, we need to expand k to k+1 to make get first k element not in the array possible. If the element <=k, we need to sum them together, so the final result is k*(k+1)//2-sum of the appeared element.\\n\\nDetail is as follows:\\nFirst let the element in the array be distinct.Then sort it, it is important because if we don\\'t sort it, we may encounter some issue like this: we get an array [6,5], k=5, we found that 5 is <=k, so we expand k to k+1, which is 6, but actually 6 appears in the array so we can\\'t use it.\\nAfter this, we set object sums to sum all element which is <=k in the array, and then iterate the array, if element <=k: k+=1, sums+=nums[i].\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums=list(set(nums))\\n        nums.sort()\\n        # print(nums)\\n        n=len(nums)\\n        sums=0\\n        for i in range(n):\\n            if nums[i]<=k:\\n                k+=1\\n                sums+=nums[i]\\n                # print(k,nums[i],sums)\\n        res=k*(k+1)//2-sums\\n        return res\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums=list(set(nums))\\n        nums.sort()\\n        # print(nums)\\n        n=len(nums)\\n        sums=0\\n        for i in range(n):\\n            if nums[i]<=k:\\n                k+=1\\n                sums+=nums[i]\\n                # print(k,nums[i],sums)\\n        res=k*(k+1)//2-sums\\n        return res\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827071,
                "title": "java-easy-to-understand-solution",
                "content": "Steps:\\n1. Push all elements in `nums` to sort **elements** and **remove duplicates**\\n2. Calculate the sum of all elements upto **k**\\n3. Subtract all the elements from `sum` that are present in treeset and are `<= k` [Keep a `count` for the elements]\\n4. Start from `k + 1` and do the below till `count > 0`\\n\\ti. if an element is not present in treeset, then add it to `sum`\\n\\tii. decrement `count` by 1\\n5. Return `sum`\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Integer> set = new TreeSet<Integer>();\\n        for (int n : nums)                               \\n            set.add(n);\\n        long sum = ((long)(k + 1) * (long)k) / 2;     \\n        int count = 0;                                \\n        for (Integer i : set) {\\n            if (i > k)                      \\n                break;\\n            else {\\n                sum -= i;                              \\n                count++;                              \\n            }                                          \\n        }\\n        int i = k + 1;                              \\n        while (count > 0) {\\n            if (!set.contains(i)) {\\n                sum += i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Integer> set = new TreeSet<Integer>();\\n        for (int n : nums)                               \\n            set.add(n);\\n        long sum = ((long)(k + 1) * (long)k) / 2;     \\n        int count = 0;                                \\n        for (Integer i : set) {\\n            if (i > k)                      \\n                break;\\n            else {\\n                sum -= i;                              \\n                count++;                              \\n            }                                          \\n        }\\n        int i = k + 1;                              \\n        while (count > 0) {\\n            if (!set.contains(i)) {\\n                sum += i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823927,
                "title": "python-o-nlogn-solution-with-n-n-1-2-range-sum",
                "content": "My first approach was the naive **O(n + k)** time but due to the large magnitude of k I was experiencing TLE.\\n\\n**New Approach: O(nlogn)**\\n\\n1) Sort nums: (The intution is that the \"gaps\" between adjacent sorted elements is space where we can add our k items\"\\n2) Define range sum n (n+1) / 2\\n3) Iterate through these \"gaps\" and add the range sum to the solution. If the gap is larger than remaining k skip to next step.\\n4) Once the gaps have been exhausted compute and add the range sum from the end to the end+remaining k\\n5) Return this sum!\\n\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \\n        # define range sum\\n        def range_sum(start, stop, step=1):\\n            number_of_terms = (stop - start) // step\\n            sum_of_extrema = start + (stop - step)\\n            return number_of_terms * sum_of_extrema // 2\\n        \\n        nums = list(set(nums)) # remove repeats\\n        nums.sort() # O(nlogn)\\n        \\n        # total sum\\n        sol = 0\\n        \\n        prev = 0\\n        ptr = 0\\n        \\n        while k > 0:\\n            if ptr < len(nums):\\n                # potential window to add nums\\n                gap = nums[ptr] - prev - 1\\n                \\n                sol += range_sum(prev+1, min(nums[ptr], prev+k+1)) # add range sum O(1)\\n                \\n                k -= gap\\n                prev = nums[ptr]\\n                ptr += 1\\n            else: # draw numbers after all numbers in the list\\n                sol += range_sum(prev+1, prev + remaining + 1)\\n                k = 0\\n        \\n        return sol\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \\n        # define range sum\\n        def range_sum(start, stop, step=1):\\n            number_of_terms = (stop - start) // step\\n            sum_of_extrema = start + (stop - step)\\n            return number_of_terms * sum_of_extrema // 2\\n        \\n        nums = list(set(nums)) # remove repeats\\n        nums.sort() # O(nlogn)\\n        \\n        # total sum\\n        sol = 0\\n        \\n        prev = 0\\n        ptr = 0\\n        \\n        while k > 0:\\n            if ptr < len(nums):\\n                # potential window to add nums\\n                gap = nums[ptr] - prev - 1\\n                \\n                sol += range_sum(prev+1, min(nums[ptr], prev+k+1)) # add range sum O(1)\\n                \\n                k -= gap\\n                prev = nums[ptr]\\n                ptr += 1\\n            else: # draw numbers after all numbers in the list\\n                sol += range_sum(prev+1, prev + remaining + 1)\\n                k = 0\\n        \\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336830,
                "title": "with-proper-intuition-approach-and-comments-c",
                "content": "# Intuition\\nTrying brute force approaches ie traversing all the numbers is not possible as the range of numbers is 10^9. And definitely it will give TLE.\\n\\nAlso even if we get the numbers to append, we cannot traverse them all to calculate their sum.\\n\\n# Approach\\nHere main concept is using the formula ((n)*(n+1))/2 and to get the lowest possible numbers that do not occur in array\\n\\n1. We can sort the array \\n2. We must attempt to take numbers that are in between consecutive elements of the given array\\n3. thereby we will calculate their sum and also reduce the value of k.\\n\\nWe will do this process till either we make our k=0 or we have traversed the whole array.\\n\\nIf suppose k!=0 and we have scanned whole array then simply we have to take numbers just bigger than the last element of the array.\\n\\n# Complexity\\n- Time complexity:\\nMajor complexity will in sorting the array so O(NlogN)\\nN is size of given array.\\n\\n- Space complexity:\\nWe have stored nothing so O(1).\\n\\n\\n**Please like if this post was helpful to you**\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    long long minimalKSum(vector<int> &nums, int k)\\n    {\\n        long long sum = 0, num = 0;\\n        int ind = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        while (k > 0 && ind < nums.size())\\n        {\\n\\n            long long n = nums[ind] - num - 1;\\n            if (n >= 0)\\n            {\\n                long long a;\\n                if (k >= n)  // if k>=n we will take whole n\\n                {\\n                    k = k - n;\\n                    a = nums[ind] - 1;\\n                }\\n\\n                else if (k < n)  // if k<n , then we only take required value of k\\n                {\\n                    a = num + k;\\n                    k = 0;\\n                }\\n\\n                if (a >= num) \\n                {\\n                    // here we want sum of elements in between a and num\\n                    sum += ((a * (a + 1)) / 2) - ((num * (num + 1)) / 2);\\n                }\\n            }\\n\\n            num = nums[ind];\\n            ind++;\\n        }\\n\\n        // this will be useful when we have traversed whole array\\n        long long a = k + nums.back();\\n        long long last = nums.back();\\n\\n        sum += ((a * (a + 1)) / 2) - ((last * (last + 1)) / 2);\\n\\n        return sum;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution\\n{\\npublic:\\n    long long minimalKSum(vector<int> &nums, int k)\\n    {\\n        long long sum = 0, num = 0;\\n        int ind = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        while (k > 0 && ind < nums.size())\\n        {\\n\\n            long long n = nums[ind] - num - 1;\\n            if (n >= 0)\\n            {\\n                long long a;\\n                if (k >= n)  // if k>=n we will take whole n\\n                {\\n                    k = k - n;\\n                    a = nums[ind] - 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3263034,
                "title": "c-easy-to-understand-t-o-nlog-n-space-o-1",
                "content": "-> first we sort the array \\n-> then we add/append elements in  array which are missing  in the range 1 2 3 . . . till kth missing element \\n-> then we check if nums[i+1]-nums[i] >1 , means  ...missing elements are present .\\n-> for finding sum we\\'ll use formula  of finding sum of an AP : ( (first term+last term) * total term )/2\\n\\n```\\nclass Solution\\n{\\n    public:\\n        long long minimalKSum(vector<int> &nums, int kk)\\n        {\\n            long long k=(kk*1ll);\\n            sort(nums.begin(),nums.end());\\n            long long ans = 0;\\n            int n = nums.size();\\n            long long  strt = (nums[0]*1ll);\\n            if (strt > k)\\n            {\\n                return (k *(k + 1)) / 2;\\n            }\\n            else\\n            {\\n                ans += (strt *(strt - 1)) / 2;\\n                k -= (strt - 1);\\n                    long long a;\\n                    long long b;\\n                for (int i = 0; i < n - 1; i++)\\n                {\\n                    a=(nums[i]*1ll);\\n                    b=(nums[i+1]*1ll);\\n                    if (b - a > 1)\\n                    {\\n                        long long  missing = b -a - 1;\\n                        if (missing >= k)\\n                        {\\n                           \\t// sum of k terms of an AP : ((a+(a+(k-1)*d))*k)/2\\n                            ans += ((a + 1 + ((a + 1 + (k - 1)))) *k) / 2;\\n                            k = 0;\\n                            return ans;\\n                        }\\n                        else\\n                        {\\n                            ans += ((a + 1 + (a + 1 + (missing - 1))) *missing) / 2;\\n                            k -= missing;\\n                        }\\n                    }\\n                }\\n\\n                if (k > 0)\\n                {\\n                   long long c=(nums[n-1]*1ll);\\n                    ans += ((c + 1 + (c + 1 + (k - 1))) *k) / 2;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        long long minimalKSum(vector<int> &nums, int kk)\\n        {\\n            long long k=(kk*1ll);\\n            sort(nums.begin(),nums.end());\\n            long long ans = 0;\\n            int n = nums.size();\\n            long long  strt = (nums[0]*1ll);\\n            if (strt > k)\\n            {\\n                return (k *(k + 1)) / 2;\\n            }\\n            else\\n            {\\n                ans += (strt *(strt - 1)) / 2;\\n                k -= (strt - 1);\\n                    long long a;\\n                    long long b;\\n                for (int i = 0; i < n - 1; i++)\\n                {\\n                    a=(nums[i]*1ll);\\n                    b=(nums[i+1]*1ll);\\n                    if (b - a > 1)\\n                    {\\n                        long long  missing = b -a - 1;\\n                        if (missing >= k)\\n                        {\\n                           \\t// sum of k terms of an AP : ((a+(a+(k-1)*d))*k)/2\\n                            ans += ((a + 1 + ((a + 1 + (k - 1)))) *k) / 2;\\n                            k = 0;\\n                            return ans;\\n                        }\\n                        else\\n                        {\\n                            ans += ((a + 1 + (a + 1 + (missing - 1))) *missing) / 2;\\n                            k -= missing;\\n                        }\\n                    }\\n                }\\n\\n                if (k > 0)\\n                {\\n                   long long c=(nums[n-1]*1ll);\\n                    ans += ((c + 1 + (c + 1 + (k - 1))) *k) / 2;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157339,
                "title": "easy-solution-o-n-log-n-c-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1:- sort the given array\\nStep 2 :- insert array values in set for remove duplicate values\\nStep 3 :- store k in n vriable an increase it untill (value of set <  n)\\nelse \\n    break;\\nStep 4:- then find the sum of n numbers using (n*n+1)/2 formula \\nStep 5 :- then remove all those integer value which is less than n and store in set;\\nStep 6 : return sum ;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& arr, int k) {\\n        int i=0;\\n         \\n        // Sort the given array\\n         sort(arr.begin(),arr.end());\\n         set<int> st;\\n        //Insert array values in set for remove duplicate values\\n         for(int i=0;i<arr.size();i++)\\n            st.insert(arr[i]);\\n         //Store k in n vriable an increase it untill (value of set <  n)\\n            long long  n = k; \\n            for(auto it : st){\\n             if(it <= n ){\\n                 n++;\\n             }else{\\n                 break;\\n             }\\n         }\\n        //Then find the sum of n numbers using (n*n+1)/2 formula \\n         long long  ans = (n*(n+1))/2;\\n        //Then remove all those integer value which is less than n and store in set;\\n         for(auto it: st){\\n             if(it <= n){\\n                 ans -= it;\\n             }\\n         }\\n    //Return sum\\n     return ans;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/4b23221b-1c7d-4f1d-865d-53e48109291c_1675795769.9495366.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& arr, int k) {\\n        int i=0;\\n         \\n        // Sort the given array\\n         sort(arr.begin(),arr.end());\\n         set<int> st;\\n        //Insert array values in set for remove duplicate values\\n         for(int i=0;i<arr.size();i++)\\n            st.insert(arr[i]);\\n         //Store k in n vriable an increase it untill (value of set <  n)\\n            long long  n = k; \\n            for(auto it : st){\\n             if(it <= n ){\\n                 n++;\\n             }else{\\n                 break;\\n             }\\n         }\\n        //Then find the sum of n numbers using (n*n+1)/2 formula \\n         long long  ans = (n*(n+1))/2;\\n        //Then remove all those integer value which is less than n and store in set;\\n         for(auto it: st){\\n             if(it <= n){\\n                 ans -= it;\\n             }\\n         }\\n    //Return sum\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852599,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long res = (long)(1+k)*k/2;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n            set.add(num);\\n        }\\n        int next = k+1;\\n        for(int num: set){\\n            if(num <= k){\\n                while(set.contains(next)){ //Check N times at most for double loop\\n                    next++;\\n                }\\n                res+=next-num;\\n                next++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long res = (long)(1+k)*k/2;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n            set.add(num);\\n        }\\n        int next = k+1;\\n        for(int num: set){\\n            if(num <= k){\\n                while(set.contains(next)){ //Check N times at most for double loop\\n                    next++;\\n                }\\n                res+=next-num;\\n                next++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826920,
                "title": "simple-c-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& v, int k) {\\n   \\n        set<int> st;\\n        for(auto it : v) st.insert(it);\\n        ll l = 1, sum = 0, r;\\n        for(auto it : st) {\\n            r = it;\\n            if(k > (r-l)) k -= (r-l);     // If k is greater than (r-l) we will take all the elements between (r, l)\\n            else break;                   // Else we will break our loop\\n            \\n            sum += (r*(r-1))/2 - (l*(l-1))/2; // Adding sum of (r-l) elements into our answer\\n            l = r+1;                      // Updating l\\n        }\\n        \\n        r = l+k;       // Taking all the remaining elements if anyone\\n        sum += (r*(r-1))/2 - (l*(l-1))/2;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& v, int k) {\\n   \\n        set<int> st;\\n        for(auto it : v) st.insert(it);\\n        ll l = 1, sum = 0, r;\\n        for(auto it : st) {\\n            r = it;\\n            if(k > (r-l)) k -= (r-l);     // If k is greater than (r-l) we will take all the elements between (r, l)\\n            else break;                   // Else we will break our loop\\n            \\n            sum += (r*(r-1))/2 - (l*(l-1))/2; // Adding sum of (r-l) elements into our answer\\n            l = r+1;                      // Updating l\\n        }\\n        \\n        r = l+k;       // Taking all the remaining elements if anyone\\n        sum += (r*(r-1))/2 - (l*(l-1))/2;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825788,
                "title": "javascript-three-attempts-and-stuck-frustration-galore-updated",
                "content": "So this was the second problem in contest 283, an easier medium.  \\nOn first read, it seemed easy, too easy, and I got a TLE.\\nbasically starting at 1, add numbers, skipping numbers that are already in the nums input, and going till u have k numbers.  Summing those numbers.\\n\\n```\\nvar minimalKSum2 = function(nums, k) {\\n  let sum = 0;\\n  let cur = 1;\\n  let max = Math.max(...nums);\\n  nums = new Set(nums);\\n  while (k) {\\n    if (cur>max || !nums.has(cur)) {\\n      k--;\\n      sum += cur;\\n    }\\n    cur++;\\n  }\\n  return sum;\\n};\\n```\\nThat wasn\\'t fast enough, so I tried using a hash for a direct lookup, thinking it would be more efficient than the set.\\n\\n```\\n\\nvar minimalKSum3 = function(nums, k) {\\n  let set = {};\\n  for (let num of nums) set[num] = 1;\\n  let sum = 0;\\n  let cur = 1;\\n  //let max = Math.max(...nums);\\n  //nums = new Set(nums);\\n  while (k) {\\n    if (!set[cur]) {\\n      k--;\\n      sum += cur;\\n    }\\n    cur++;\\n  }\\n  return sum;\\n};\\n```\\nfinally I realized that Id have to try something different.  a little suprised since that was an easier medium.  But ok, let me use the summation trick of (n*(n+1))/2 than go back and subtract num elements and add k+1 additional elemement to ensure that I still return the correct number of results.\\n\\nThe problem was that no matter what, I would fail for one of the test cases:\\n[1000000000]\\n1000000000\\n\\nno matter what, I couldn\\'t get the number to work, even adding manually to my total.\\nI just checked the problem just now, and seems that they have reduced the max number, it\\'s now with one less zero.\\n\\nShame on LC for not checking that before the competition.  Because it was only the second problem, I was stuck on it and only completed the easy one.  Also frustrating as it\\'s part of a competition and I have no way of knowing if it was just me or what was happening during the competition.\\n\\nAnyway, sa la vi.  at least now I know that LC comp questions can be flawed and I\\'ll know next time to skip it after a time and at least try next questions.\\n\\n```\\nvar minimalKSum = function(nums, k) {\\n  let total = (k*(k+1))/2;\\n    \\n  nums = Array.from(new Set(nums));\\n  nums.sort((a,b)=>a-b); \\n  for (let num of nums) {\\n    if (num<=k) {\\n      k++;\\n      console.log(total-1)\\n      total=total-num+k;\\n      console.log(total+1)\\n    }\\n    else\\n      break;\\n  }\\n  return total;\\n}\\n```\\n\\nLC has updated the inputs as mentioned and running the exact same code as last night now results in an accepted answer:\\n![image](https://assets.leetcode.com/users/images/0cb3ddf3-d584-47e5-83f7-2409fc47cb63_1646583213.9288075.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimalKSum2 = function(nums, k) {\\n  let sum = 0;\\n  let cur = 1;\\n  let max = Math.max(...nums);\\n  nums = new Set(nums);\\n  while (k) {\\n    if (cur>max || !nums.has(cur)) {\\n      k--;\\n      sum += cur;\\n    }\\n    cur++;\\n  }\\n  return sum;\\n};\\n```\n```\\n\\nvar minimalKSum3 = function(nums, k) {\\n  let set = {};\\n  for (let num of nums) set[num] = 1;\\n  let sum = 0;\\n  let cur = 1;\\n  //let max = Math.max(...nums);\\n  //nums = new Set(nums);\\n  while (k) {\\n    if (!set[cur]) {\\n      k--;\\n      sum += cur;\\n    }\\n    cur++;\\n  }\\n  return sum;\\n};\\n```\n```\\nvar minimalKSum = function(nums, k) {\\n  let total = (k*(k+1))/2;\\n    \\n  nums = Array.from(new Set(nums));\\n  nums.sort((a,b)=>a-b); \\n  for (let num of nums) {\\n    if (num<=k) {\\n      k++;\\n      console.log(total-1)\\n      total=total-num+k;\\n      console.log(total+1)\\n    }\\n    else\\n      break;\\n  }\\n  return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824321,
                "title": "python-sorting-n-log-n-solution-simple-maths",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        mid=min(k,nums[0]-1)\\n        ans=((mid+1)*(mid))//2\\n        k-=mid\\n        for i in range(1,len(nums)):\\n            if(k==0):\\n                break\\n            if(nums[i]-nums[i-1]>1):\\n                mid=min(nums[i]-nums[i-1]-1,k)\\n                k-=mid\\n                ans+=(((nums[i-1]+mid+1)*(nums[i-1]+mid))//2)-(((nums[i-1]+1)*(nums[i-1]))//2)\\n        ans+=(((nums[len(nums)-1]+k+1)*(nums[len(nums)-1]+k))//2)-(((nums[len(nums)-1]+1)*(nums[len(nums)-1]))//2)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        mid=min(k,nums[0]-1)\\n        ans=((mid+1)*(mid))//2\\n        k-=mid\\n        for i in range(1,len(nums)):\\n            if(k==0):\\n                break\\n            if(nums[i]-nums[i-1]>1):\\n                mid=min(nums[i]-nums[i-1]-1,k)\\n                k-=mid\\n                ans+=(((nums[i-1]+mid+1)*(nums[i-1]+mid))//2)-(((nums[i-1]+1)*(nums[i-1]))//2)\\n        ans+=(((nums[len(nums)-1]+k+1)*(nums[len(nums)-1]+k))//2)-(((nums[len(nums)-1]+1)*(nums[len(nums)-1]))//2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824281,
                "title": "c-easy-to-understand-math",
                "content": "```\\n long long minimalKSum(vector<int>& nums, int k) {\\n        long ans=(long(k)*(long(k+1)))/2;\\n        unordered_set<int>st(nums.begin(),nums.end());\\n        vector<int> dup;\\n        for(auto it:st)\\n            dup.push_back(it);\\n        sort(dup.begin(),dup.end());\\n        int n=dup.size();\\n        for(int i=0;i<n;i++){\\n          if(dup[i]<=k ){\\n                ans-=dup[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n long long minimalKSum(vector<int>& nums, int k) {\\n        long ans=(long(k)*(long(k+1)))/2;\\n        unordered_set<int>st(nums.begin(),nums.end());\\n        vector<int> dup;\\n        for(auto it:st)\\n            dup.push_back(it);\\n        sort(dup.begin(),dup.end());\\n        int n=dup.size();\\n        for(int i=0;i<n;i++){\\n          if(dup[i]<=k ){\\n                ans-=dup[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1824073,
                "title": "understand-this-solution-in-one-go-python3-easy-nlogn-approach",
                "content": "Approach: Greedily Accumulate all numbers from [min(1,min(nums)) to max(nums)+k] till K count is satisfied.\\n**The list is sorted** \\n* 0 is added at the front to accumulate values from 1 to min(nums)  \\n* Get the sum of numbers between the range (nums[i],nums[i+1]) for i in range(0,N-1)\\n* max(nums)+k is appended at last to get values in range [max(nums),max(nums)+k]\\n*The sum of numbers between a range can be easily calculated by the formula (n(n+1))//2 in O(1)\\nHence the time complexity is O(N(Log(N)))*\\nPlease Upvote if you understood the approach and the solution:)\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()                       # For Accumulating all values between two adjacent numbers in sorted List\\n        ss=0                              # Sum Variable\\n        i=0\\n        j=1\\n        nums.insert(0,0)                  # Greedily adding the value from 0 to min(nums)\\n        nums.append(nums[-1]+k+1)         # Dealing Insufficiency in k value from max(nums) to max(nums)+k (if needed)\\n\\n        def ch(n):                        # function for sum of first n natural numbers\\n            return (n*(n+1))//2       \\n        while k>0 and j<len(nums):\\n            if nums[j]-nums[i]>=2 and nums[j]-nums[i]-1<=k:  # case1: when the count of numbers between two range can\\'t satisfy the k value. \\n                ss+=ch(nums[j]-1)-ch(nums[i])                # summing up the numbers within the range\\n                k-=nums[j]-nums[i]-1                         # updating k value\\n                j+=1\\n                i+=1\\n            elif nums[j]-nums[i]-1>k:                        # case2: when the count of numbers between two range can satisfy the k value.\\n                ss+=ch(nums[i]+k)-ch(nums[i])                # summing up the numbers within the range nums[i]+k and nums[i] \\n                k=0                                          # since there are excess count of satisfying numbers in that range (making k==0 as we gotthedesired)\\n                break                                     \\n            else:                                            # if nums[i+1]-nums[i]==1 we cant get any number between for our sum\\n                i+=1\\n                j+=1\\n        return ss\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()                       # For Accumulating all values between two adjacent numbers in sorted List\\n        ss=0                              # Sum Variable\\n        i=0\\n        j=1\\n        nums.insert(0,0)                  # Greedily adding the value from 0 to min(nums)\\n        nums.append(nums[-1]+k+1)         # Dealing Insufficiency in k value from max(nums) to max(nums)+k (if needed)\\n\\n        def ch(n):                        # function for sum of first n natural numbers\\n            return (n*(n+1))//2       \\n        while k>0 and j<len(nums):\\n            if nums[j]-nums[i]>=2 and nums[j]-nums[i]-1<=k:  # case1: when the count of numbers between two range can\\'t satisfy the k value. \\n                ss+=ch(nums[j]-1)-ch(nums[i])                # summing up the numbers within the range\\n                k-=nums[j]-nums[i]-1                         # updating k value\\n                j+=1\\n                i+=1\\n            elif nums[j]-nums[i]-1>k:                        # case2: when the count of numbers between two range can satisfy the k value.\\n                ss+=ch(nums[i]+k)-ch(nums[i])                # summing up the numbers within the range nums[i]+k and nums[i] \\n                k=0                                          # since there are excess count of satisfying numbers in that range (making k==0 as we gotthedesired)\\n                break                                     \\n            else:                                            # if nums[i+1]-nums[i]==1 we cant get any number between for our sum\\n                i+=1\\n                j+=1\\n        return ss\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823651,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Long> ts = new TreeSet<>();\\n        for(int num:nums)\\n            ts.add((long)num);\\n\\n        long prev = 0;\\n        long sum = 0;\\n        for(long num: ts){\\n            if(num==1)\\n            {\\n                prev = num;\\n                continue;\\n            }\\n            \\n            if((num)-prev>k){\\n              num = prev+k+1;  \\n            }\\n            k -= ((num-1)-prev);\\n            sum+= ((num-1)*(num)/2)-(prev*(prev+1)/2);\\n            if(k==0)\\n                return sum;\\n            \\n            prev = num;\\n        }\\n        \\n        if(k!=0){\\n        long upper = prev+k+1; \\n        sum+=    (upper*(upper-1)/2)-(prev*(prev+1)/2);\\n        }\\n       return sum;     \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Long> ts = new TreeSet<>();\\n        for(int num:nums)\\n            ts.add((long)num);\\n\\n        long prev = 0;\\n        long sum = 0;\\n        for(long num: ts){\\n            if(num==1)\\n            {\\n                prev = num;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1823597,
                "title": "c-binary-search",
                "content": "- Find a numver x using binary search such that there are y less numbers in nums so that y + k = x;\\n- then x *(x+1)/2 - sum of y numbers is the ans\\n```\\nclass Solution {\\npublic:\\n    int find(int x, vector<int>& nums) {\\n        int l = 0, r = nums.size();\\n        while(l < r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] <= x) {\\n                l = m+1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return r;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long ret = 0;\\n        vector<int> v;\\n\\t\\t// sort the numbers so that we can binary search\\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n\\t\\t// remove repeating numbers\\n        v.push_back(nums[0]);\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] != nums[i-1]) v.push_back(nums[i]);\\n        }\\n\\t\\t\\n\\t\\t// binary search\\n        long long l = 1, r = 10000000000;\\n        int count = 0;\\n        while(l < r) {\\n            long long m = l + (r-l)/2;\\n\\t\\t\\t// binary search on nums to find count of numbers less than mid\\n            count = find(m, v);\\n            if(m - count < k) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// find ans using sum of n numbers by reducing the numbers present in nums\\n        for(int i = 0; i < count; i++) ret -= v[i];\\n        ret += r * (r+1) /2;\\n       \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int x, vector<int>& nums) {\\n        int l = 0, r = nums.size();\\n        while(l < r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] <= x) {\\n                l = m+1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return r;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long ret = 0;\\n        vector<int> v;\\n\\t\\t// sort the numbers so that we can binary search\\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n\\t\\t// remove repeating numbers\\n        v.push_back(nums[0]);\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] != nums[i-1]) v.push_back(nums[i]);\\n        }\\n\\t\\t\\n\\t\\t// binary search\\n        long long l = 1, r = 10000000000;\\n        int count = 0;\\n        while(l < r) {\\n            long long m = l + (r-l)/2;\\n\\t\\t\\t// binary search on nums to find count of numbers less than mid\\n            count = find(m, v);\\n            if(m - count < k) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// find ans using sum of n numbers by reducing the numbers present in nums\\n        for(int i = 0; i < count; i++) ret -= v[i];\\n        ret += r * (r+1) /2;\\n       \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691921,
                "title": "easy-solution-o-n-log-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n\\t\\t\\n\\t\\t// map is used to get the unique values only\\n        unordered_map<int,int>hash; \\n\\t\\t\\n        long long sum = 0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] <= k && hash[nums[i]] == 0){ \\n                k++;\\n                sum -= nums[i];\\n                hash[nums[i]] = 1;\\n            }\\n        }\\n        sum += (long long)k * (k+1) /2;\\n        return sum;\\n    }\\n};\\n```\\n: )    \\uD83D\\uDC4D   : )",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n\\t\\t\\n\\t\\t// map is used to get the unique values only\\n        unordered_map<int,int>hash; \\n\\t\\t\\n        long long sum = 0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] <= k && hash[nums[i]] == 0){ \\n                k++;\\n                sum -= nums[i];\\n                hash[nums[i]] = 1;\\n            }\\n        }\\n        sum += (long long)k * (k+1) /2;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665676,
                "title": "c-o-nlogn-time-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sum(long long l, long long r){\\n        return r*(r+1)/2 - (l)*(l-1)/2;\\n    }\\n    long long minimalKSum(vector<int>& a, int k) {\\n        sort(a.begin(), a.end()); // 1,4,10,25,25\\n        long long x = 1;\\n        long long ans = 0;\\n        for(int i = 0; i<a.size() && k>0; ++i){\\n            long long d = a[i] - x;\\n            if(d>0){\\n                if(d>k){            // [4,5], k = 2\\n                    ans += sum(x, x+k-1);\\n                    k = 0;\\n                } else{\\n                    ans += sum(x, a[i]-1);\\n                    k = k-d;\\n                }\\n            }\\n            x = a[i]+1;\\n        }\\n        if(k>0)       // for case [5,6] , k=6\\n            ans += sum(a[a.size()-1]+1, a[a.size()-1]+k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sum(long long l, long long r){\\n        return r*(r+1)/2 - (l)*(l-1)/2;\\n    }\\n    long long minimalKSum(vector<int>& a, int k) {\\n        sort(a.begin(), a.end()); // 1,4,10,25,25\\n        long long x = 1;\\n        long long ans = 0;\\n        for(int i = 0; i<a.size() && k>0; ++i){\\n            long long d = a[i] - x;\\n            if(d>0){\\n                if(d>k){            // [4,5], k = 2\\n                    ans += sum(x, x+k-1);\\n                    k = 0;\\n                } else{\\n                    ans += sum(x, a[i]-1);\\n                    k = k-d;\\n                }\\n            }\\n            x = a[i]+1;\\n        }\\n        if(k>0)       // for case [5,6] , k=6\\n            ans += sum(a[a.size()-1]+1, a[a.size()-1]+k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630820,
                "title": "one-liner-in-java",
                "content": "**UPVOTE PLEASE**\\n```\\npublic long minimalKSum(int[] nums, int k) {  long  res = (long )k * (k + 1) / 2;\\n    for (int n : new TreeSet<>(Arrays.stream(nums).boxed().toList())) if (n <= k) res += (++k) - n;  return res;  }\\n```\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\npublic long minimalKSum(int[] nums, int k) {  long  res = (long )k * (k + 1) / 2;\\n    for (int n : new TreeSet<>(Arrays.stream(nums).boxed().toList())) if (n <= k) res += (++k) - n;  return res;  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497128,
                "title": "c-map-easy-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long minimalKSum(vector<int>& nums, int k) {\\n\\n\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\tfor(auto i:nums)\\n\\t\\t\\t\\tmp[i]++;\\n\\n\\t\\t\\tlong long start=1,ans=0;\\n\\t\\t\\tfor(auto x:mp){\\n\\n\\t\\t\\t\\tlong long l=start;\\n\\t\\t\\t\\tlong long r=x.first;\\n\\n\\t\\t\\t\\tif(k>(r-l))\\n\\t\\t\\t\\t\\tk-=(r-l);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tans+=((r)*(r-1))/2-((l)*(l-1))/2;\\n\\t\\t\\t\\tstart=x.first+1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong long l=start;\\n\\t\\t\\tlong long r=start+k;\\n\\n\\t\\t\\tans+=((r)*(r-1))/2-((l)*(l-1))/2;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long minimalKSum(vector<int>& nums, int k) {\\n\\n\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\tfor(auto i:nums)\\n\\t\\t\\t\\tmp[i]++;\\n\\n\\t\\t\\tlong long start=1,ans=0;\\n\\t\\t\\tfor(auto x:mp){\\n\\n\\t\\t\\t\\tlong long l=start;\\n\\t\\t\\t\\tlong long r=x.first;\\n\\n\\t\\t\\t\\tif(k>(r-l))\\n\\t\\t\\t\\t\\tk-=(r-l);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tans+=((r)*(r-1))/2-((l)*(l-1))/2;\\n\\t\\t\\t\\tstart=x.first+1;\\n\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2470842,
                "title": "c-9-lines-only-o-nlogn-time-o-1-space",
                "content": "```c++\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        long long missing = 1, res = 0;\\n        for (auto num: nums) {\\n            while ( missing < num ) {\\n                res += missing++;\\n                if (!k--) return res;\\n            }\\n            missing = num + 1;\\n        }\\n        while (k--) res += missing++;\\n        return res ;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        long long missing = 1, res = 0;\\n        for (auto num: nums) {\\n            while ( missing < num ) {\\n                res += missing++;\\n                if (!k--) return res;\\n            }\\n            missing = num + 1;\\n        }\\n        while (k--) res += missing++;\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339179,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // fill gaps\\n        long result = 0;\\n        long c = 1;\\n        for (int i : nums) {\\n            if (i > c) {\\n                while (c < i && k > 0) {\\n                    result += c;\\n                    c++;\\n                    k--;\\n                }\\n            }\\n            c = i+1;\\n        }\\n        \\n        // add the left overs\\n        while (k > 0) {\\n            result += c;\\n            c++;\\n            k--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\nI\\'m not good at time complexity, I assume it should be `O(n+k)` where `n` is the length of the `nums`. Correct me if I\\'m wrong",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // fill gaps\\n        long result = 0;\\n        long c = 1;\\n        for (int i : nums) {\\n            if (i > c) {\\n                while (c < i && k > 0) {\\n                    result += c;\\n                    c++;\\n                    k--;\\n                }\\n            }\\n            c = i+1;\\n        }\\n        \\n        // add the left overs\\n        while (k > 0) {\\n            result += c;\\n            c++;\\n            k--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226100,
                "title": "java-solution-using-sum-of-n-natural-numbers",
                "content": "***Time Complexity***: O(NlogN) because I\\'m using sorting algorithm.\\n***Space Complexity***: O(1) to O(N) based on the sorting algorithm applied.\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        int p = 0;\\n        long res = (long)k*((long)k+1)/2;\\n        Arrays.sort(nums);\\n        for(int i=0 ;i<nums.length ;i++) {\\n            if(p != nums[i] && k >= nums[i]) {\\n                res -= nums[i];\\n                res += ++k;\\n            }\\n            else if(k < nums[i]) {\\n                break;\\n            }\\n            p = nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\n***If you like please upvote***",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        int p = 0;\\n        long res = (long)k*((long)k+1)/2;\\n        Arrays.sort(nums);\\n        for(int i=0 ;i<nums.length ;i++) {\\n            if(p != nums[i] && k >= nums[i]) {\\n                res -= nums[i];\\n                res += ++k;\\n            }\\n            else if(k < nums[i]) {\\n                break;\\n            }\\n            p = nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082888,
                "title": "sharing-my-c-intuitive-code-and-approach",
                "content": "The idea is to consider sum of first `k` terms and then traverse through the array to avoid the numbers which we can\\'t use. To do so, we have to increase our `k` by 1. But at the same time, we have to keep in check that the number we are removing gotta be `within` the range of `k`.\\n\\nFor that, we will first sort the array and remove the duplicates (by using `set`).\\nAnd then, we apply `if(nums[i]<=k) k++`\\n\\nIn the event of `nums[i]>k`, simple means that we have reached a point where we are safely having `k` values without having any number that is in the array.\\n\\nWe will keep sum of all these numbers that we have surpassed and the updated, effective `k`.\\n\\nLastly, we calcuate sum upto `k` terms and subtract the sum of skipped numbers.\\n\\nNote: while applying the formula `(n*(n+1))/2`, watchout for integer overflow. Typecast properly.\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    ll minimalKSum(vector<int>& nums, int k){\\n        ll sum=0;\\n        set<int> st;\\n        for(auto c:nums) st.insert(c);\\n        auto it=st.begin();\\n        while(it!=st.end()){\\n            if(*it<=k) k++;\\n            else break;\\n            sum+=(*it);\\n            it++;\\n        }\\n        ll res=(ll)k*(k+1)/2 -sum;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    ll minimalKSum(vector<int>& nums, int k){\\n        ll sum=0;\\n        set<int> st;\\n        for(auto c:nums) st.insert(c);\\n        auto it=st.begin();\\n        while(it!=st.end()){\\n            if(*it<=k) k++;\\n            else break;\\n            sum+=(*it);\\n            it++;\\n        }\\n        ll res=(ll)k*(k+1)/2 -sum;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036478,
                "title": "python-two-approaches-explained-with-notes-78-faster",
                "content": "```\\n/*\\n    Approach 1: we can create a sum of nums array\\n    and start iterating from 1, ...\\n    if we find the element in nums, we don\\'t consider in the sum\\n    else include in the sum. \\n    We repeat the above step until we have collected the sum of k elements\\n    return the sum\\n    This is a straight forward appraoch which will give TLE when k is large\\n*/\\n```\\nImplementation: \\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        count = 0 \\n        ans_sum = 0\\n        i = 1\\n        num_set = set(nums)\\n        while count < k:\\n            if i not in num_set:\\n                ans_sum+=i\\n                count+=1\\n            i+=1\\n        return ans_sum\\n```\\nUnfortunately the above approach will give TLE\\n\\n\\n```\\n/*\\n    Approach 2: minimal sum we can get for k elmeents would be k * (k+1) / 2\\n    now sort the nums array\\n    and see, if cur_element <= k, that means, we have to exclude that element from sum and\\n    add (k+1) element to the sum to get the minimal sum\\n    repeat the above step until current element of array > k or end of array is reached\\n*/\\n```\\nImplementation: \\n\\n```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n\\tans_sum = k * (k+1) / 2\\n\\tnext_val = k+1\\n\\tnums.sort()\\n\\tfor i, num in enumerate(nums):\\n\\t\\tif i and nums[i] == nums[i-1]:\\n\\t\\t\\tcontinue\\n\\t\\tif num > k:\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tans_sum = ans_sum - num + next_val\\n\\t\\t\\tk+=1\\n\\t\\t\\tnext_val+=1\\n\\treturn int(ans_sum)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n/*\\n    Approach 1: we can create a sum of nums array\\n    and start iterating from 1, ...\\n    if we find the element in nums, we don\\'t consider in the sum\\n    else include in the sum. \\n    We repeat the above step until we have collected the sum of k elements\\n    return the sum\\n    This is a straight forward appraoch which will give TLE when k is large\\n*/\\n```\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        count = 0 \\n        ans_sum = 0\\n        i = 1\\n        num_set = set(nums)\\n        while count < k:\\n            if i not in num_set:\\n                ans_sum+=i\\n                count+=1\\n            i+=1\\n        return ans_sum\\n```\n```\\n/*\\n    Approach 2: minimal sum we can get for k elmeents would be k * (k+1) / 2\\n    now sort the nums array\\n    and see, if cur_element <= k, that means, we have to exclude that element from sum and\\n    add (k+1) element to the sum to get the minimal sum\\n    repeat the above step until current element of array > k or end of array is reached\\n*/\\n```\n```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n\\tans_sum = k * (k+1) / 2\\n\\tnext_val = k+1\\n\\tnums.sort()\\n\\tfor i, num in enumerate(nums):\\n\\t\\tif i and nums[i] == nums[i-1]:\\n\\t\\t\\tcontinue\\n\\t\\tif num > k:\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tans_sum = ans_sum - num + next_val\\n\\t\\t\\tk+=1\\n\\t\\t\\tnext_val+=1\\n\\treturn int(ans_sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911208,
                "title": "following-the-hints-with-python-o-nlogn",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        s = k * (k+1) // 2\\n        nums.sort()\\n        visited = set()\\n        for num in nums:\\n            if num <= k and num not in visited:\\n                s -= num   # num is smaller than k, so remove it from final sum\\n                s += k + 1 # assume that k + 1 is available and add it to the final sum instantly\\n                k = k + 1  # the k\\'th largest element (of k smallest) has changed\\n                visited.add(num)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        s = k * (k+1) // 2\\n        nums.sort()\\n        visited = set()\\n        for num in nums:\\n            if num <= k and num not in visited:\\n                s -= num   # num is smaller than k, so remove it from final sum\\n                s += k + 1 # assume that k + 1 is available and add it to the final sum instantly\\n                k = k + 1  # the k\\'th largest element (of k smallest) has changed\\n                visited.add(num)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826262,
                "title": "c-my-own-most-efficient-solution-o-nlog-n-time-o-1-space-solution-beats-every-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long s = 0;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0 ;i<n;++i){\\n            if(i==0){\\n                if(nums[i]<=k){\\n                    s+=nums[i];\\n                    k++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            else{\\n                if(nums[i]==nums[i-1])continue;\\n                if(nums[i]>k)break;\\n                s+=nums[i];\\n                k++;\\n            }\\n        }\\n        \\n         long long ans = ((long long)k*(k+1))/2 - s;        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long s = 0;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0 ;i<n;++i){\\n            if(i==0){\\n                if(nums[i]<=k){\\n                    s+=nums[i];\\n                    k++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            else{\\n                if(nums[i]==nums[i-1])continue;\\n                if(nums[i]>k)break;\\n                s+=nums[i];\\n                k++;\\n            }\\n        }\\n        \\n         long long ans = ((long long)k*(k+1))/2 - s;        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825456,
                "title": "easy-c-faster-than-100-sum-of-n-natural-number-technique",
                "content": "**Sum of n terms of AP = n/2[2a + (n \\u2013 1)d]**\\n```\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int t;\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        t=k;\\n        int i;\\n        for( i=0;i<nums.size();i++){\\n            if(t==0)break;\\n            if(i==0){\\n                solve(1,nums[i]-1);\\n            }else{\\n                solve(nums[i-1]+1,nums[i]-(nums[i-1]+1));\\n            }\\n        }\\n        if(t>0){\\n            solve(nums[nums.size()-1]+1,t);\\n        }\\n       return ans;\\n    }\\n    void solve(int a,int n){\\n        if(n<0)return;\\n        if(t<=n){\\n            ans=ans+((long long)(double)t/2.0)*(a+a+(t-1));\\n            t=0;\\n            return;\\n        }\\n        else {\\n            ans=ans+((long long)(double)n/2.0)*(a+a+(n-1));\\n            t=t-n;\\n        }\\n        return;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long ans=0;\\n    int t;\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        t=k;\\n        int i;\\n        for( i=0;i<nums.size();i++){\\n            if(t==0)break;\\n            if(i==0){\\n                solve(1,nums[i]-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1825006,
                "title": "c-eaziest-guaranteed-72ms-faster-than-100-simple-maths-explained",
                "content": "I am using the simple arithmetic progression formula to calculate the sum of the elements.\\n\\n![image](https://assets.leetcode.com/users/images/93e779e3-340d-456f-8f1b-d4b6bc416d11_1646561450.3565602.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/4a53c274-b26f-42e7-93c2-8285e7df5bd9_1646561210.4232166.png)\\nHere difference will  be 1.\\nArray needs to be sorted before we start perfoming the operation. We are using mod=1e19+7 , to prevent integer overflows encountered while multiplication\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        unsigned long long ans=0ll;\\n      sort(nums.begin(),nums.end());\\n       unsigned long long mod=1e19+7;\\n        \\n      if(nums[0]-1>k) //If one minus the first element of the sorted array is greater than \\'k\\'     \\n         return k%mod*((k+1)%mod)/2;\\n        \\n        int n=nums[0]-1;//no of elements between 1 and the first element of the array\\n        ans=(n%mod*(n+1)%mod)/2;\\n        k-=n;\\n        \\n      // cout<<ans<<\" \"<<k<<\"\\\\n\";      \\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums[i-1])//Prevent Duplicates\\n                continue;\\n            n=nums[i]-nums[i-1]-1;//number of elements between current and previous elements\\n          //  cout<<k<<\" \"<<n;            \\n             if(k<=0)\\n                return ans;\\n            if(k>=n)//if \\'k\\' is greater than number of elements between current and previous elements THEN we find the sum of those elements\\n            {\\n            ans+=(n%mod*((2*(nums[i-1]+1)%mod)+(n-1))%mod)/2;\\n            k-=n;\\n            }\\n            else\\n            {\\n                ans+=(k%mod*(2*(nums[i-1]+1)+(k-1))%mod)/2;//Finding thesum of the laast remaining \\'k\\' elements\\n                k=0;\\n            }\\n        } \\n        //\\'k\\' still might not be 0 so we find sum of \\'k\\' elements with starting element equal to 1+last element of sorted array\\n        ans+=(k%mod*(2*(nums.back()+1)+(k-1))%mod)/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        unsigned long long ans=0ll;\\n      sort(nums.begin(),nums.end());\\n       unsigned long long mod=1e19+7;\\n        \\n      if(nums[0]-1>k) //If one minus the first element of the sorted array is greater than \\'k\\'     \\n         return k%mod*((k+1)%mod)/2;\\n        \\n        int n=nums[0]-1;//no of elements between 1 and the first element of the array\\n        ans=(n%mod*(n+1)%mod)/2;\\n        k-=n;\\n        \\n      // cout<<ans<<\" \"<<k<<\"\\\\n\";      \\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums[i-1])//Prevent Duplicates\\n                continue;\\n            n=nums[i]-nums[i-1]-1;//number of elements between current and previous elements\\n          //  cout<<k<<\" \"<<n;            \\n             if(k<=0)\\n                return ans;\\n            if(k>=n)//if \\'k\\' is greater than number of elements between current and previous elements THEN we find the sum of those elements\\n            {\\n            ans+=(n%mod*((2*(nums[i-1]+1)%mod)+(n-1))%mod)/2;\\n            k-=n;\\n            }\\n            else\\n            {\\n                ans+=(k%mod*(2*(nums[i-1]+1)+(k-1))%mod)/2;//Finding thesum of the laast remaining \\'k\\' elements\\n                k=0;\\n            }\\n        } \\n        //\\'k\\' still might not be 0 so we find sum of \\'k\\' elements with starting element equal to 1+last element of sorted array\\n        ans+=(k%mod*(2*(nums.back()+1)+(k-1))%mod)/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1824271,
                "title": "o-nums-length-solution-no-sorting",
                "content": "After my first few tries end up TLE, I find this approach that takes ```O(nums.length)``` time. As ```1<=nums.length<=10^5``` and ```1<=k,nums[i]<=10^9```, this approach should be faster than ```O(k)``` and ```O(nums[i])``` approaches and past all test cases.\\nMy idea is that the maximum possible integer to append is ```maxnum = k+nums.length```, then we can take the integers from ```1``` to ```maxnum``` as our first guess. Of course we would have more integers than needed at this time, but we have to delete some integers according to the rule. We traverse ```nums``` to delete integers from our guess, then we delete integers from big to small until only ```k``` integers left.\\n```\\n#include <unordered_set>\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        unordered_set<int> freq;\\n        long long maxnum = k+nums.size(); // maximum possible integer to be appended\\n        long long sum = (1+maxnum)*maxnum/2; // calculate the sum and subtract from it later\\n        int count = maxnum; // currently we have count integers, which is more than we need\\n        for(auto num: nums){\\n            if(freq.find(num)==freq.end()){\\n                freq.insert(num);\\n                if(num<=maxnum){ // need to delete num from our candidate integers\\n                    sum -= num;\\n                    count --;\\n                }\\n            }\\n        }\\n\\t\\t// delete integers from big to small until only k integers left\\n        // goes into while loop at most nums.length time, when all nums[i]>maxnum\\n        int i = maxnum;\\n        while(\\n            if(freq.find(i)==freq.end()){\\n                sum -= i;\\n                count --;\\n            }\\n            i --;\\n        }\\n        return sum;\\n    }\\n};\\n```\\nWe traverse ```nums``` for one time, and goes into the while loop no more than ```nums.length``` time.  No sorting is needed, the time complexity should be ```O(nums.length)```. Also the space complexicy is ```O(nums.length)``` since we keeps a set of nums for quick query.",
                "solutionTags": [
                    "C"
                ],
                "code": "```O(nums.length)```\n```1<=nums.length<=10^5```\n```1<=k,nums[i]<=10^9```\n```O(k)```\n```O(nums[i])```\n```maxnum = k+nums.length```\n```1```\n```maxnum```\n```nums```\n```k```\n```\\n#include <unordered_set>\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        unordered_set<int> freq;\\n        long long maxnum = k+nums.size(); // maximum possible integer to be appended\\n        long long sum = (1+maxnum)*maxnum/2; // calculate the sum and subtract from it later\\n        int count = maxnum; // currently we have count integers, which is more than we need\\n        for(auto num: nums){\\n            if(freq.find(num)==freq.end()){\\n                freq.insert(num);\\n                if(num<=maxnum){ // need to delete num from our candidate integers\\n                    sum -= num;\\n                    count --;\\n                }\\n            }\\n        }\\n\\t\\t// delete integers from big to small until only k integers left\\n        // goes into while loop at most nums.length time, when all nums[i]>maxnum\\n        int i = maxnum;\\n        while(\\n            if(freq.find(i)==freq.end()){\\n                sum -= i;\\n                count --;\\n            }\\n            i --;\\n        }\\n        return sum;\\n    }\\n};\\n```\n```nums```\n```nums.length```\n```O(nums.length)```\n```O(nums.length)```",
                "codeTag": "C++"
            },
            {
                "id": 1824064,
                "title": "easy-approach-with-explanation-easy-to-understand-and-implement-sorting-c",
                "content": "**Intitution**\\n\\nIf there is not any element from 1 to K result would be k*(k+1)/2.\\nNow we just have to iterate on element on array to see if some element from 1 to K is present in array, If that is the case we have to remove that element from array and add k+1 to the result(k is increasing by 1 everytime)..\\n\\n**Approach**\\n\\nOnce that is figured approach is easy.\\nSort the array and keep new K in cur variable\\n\\n```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n        \\n        unsigned long long int res=((long long int)k*(long long int)(k+1))/2;\\n        int cur=k+1;\\n        map<int,int> mp;\\n        sort(nums.begin(),nums.end());\\n        for(int i:nums){\\n            if(mp[i]!=1 && i<cur){\\n                res-=i;\\n                res+=cur;                \\n                cur++;\\n            }\\n            mp[i]=1;\\n        }\\n        return res;              \\n    }\\n\\t\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "**Intitution**\\n\\nIf there is not any element from 1 to K result would be k*(k+1)/2.\\nNow we just have to iterate on element on array to see if some element from 1 to K is present in array, If that is the case we have to remove that element from array and add k+1 to the result(k is increasing by 1 everytime)..\\n\\n**Approach**\\n\\nOnce that is figured approach is easy.\\nSort the array and keep new K in cur variable\\n\\n```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n        \\n        unsigned long long int res=((long long int)k*(long long int)(k+1))/2;\\n        int cur=k+1;\\n        map<int,int> mp;\\n        sort(nums.begin(),nums.end());\\n        for(int i:nums){\\n            if(mp[i]!=1 && i<cur){\\n                res-=i;\\n                res+=cur;                \\n                cur++;\\n            }\\n            mp[i]=1;\\n        }\\n        return res;              \\n    }\\n\\t\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1823853,
                "title": "python-got-wrong-answer-for-one-testcase-while-java-works-fine",
                "content": "Can anyone explain that why my python code results in a wrong answer for this testcase while the same Java solution works fine?\\n![image](https://assets.leetcode.com/users/images/b69a925b-e0c7-4acb-beb2-5791f8c559d7_1646539808.074062.png)\\npython:\\n```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n    nums.append(10 ** 10)\\n    nums.sort()\\n    pre = 0\\n    ans = 0\\n    for i in nums:\\n        if i >= pre + 1:\\n            ran = i - pre - 1\\n            if ran >= k:\\n                # sum up pre + 1 to pre + k\\n                ans += (pre + 1 + pre + k) * k / 2\\n                break\\n            else:\\n                ans += (pre + 1 + i - 1) * (i - 1 - pre) / 2\\n                k -= i - 1 - pre\\n        pre = i\\n    return int(ans)\\n```\\njava:\\n```\\npublic long minimalKSum(int[] nums, int k) {\\n    Arrays.sort(nums);\\n    long pre = 0;\\n    long ans = 0;\\n    for (long i : nums) {\\n        if (i >= pre + 1) {\\n            long ran = i - pre - 1;\\n            if (ran >= k) {\\n                ans += k == 1? pre + 1 : (pre + 1 + pre + k) * k / 2;\\n                k = 0;\\n                break;\\n            } else {\\n                ans += (pre + 1 + i - 1) * (i - 1 - pre) / 2;\\n                k -= i - 1 - pre;\\n            }\\n        }\\n        pre = i;\\n    }\\n    if (k > 0) {\\n        ans += k == 1? pre + 1 : (pre + 1 + pre + k) * k / 2;\\n    }\\n    return ans;\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n    nums.append(10 ** 10)\\n    nums.sort()\\n    pre = 0\\n    ans = 0\\n    for i in nums:\\n        if i >= pre + 1:\\n            ran = i - pre - 1\\n            if ran >= k:\\n                # sum up pre + 1 to pre + k\\n                ans += (pre + 1 + pre + k) * k / 2\\n                break\\n            else:\\n                ans += (pre + 1 + i - 1) * (i - 1 - pre) / 2\\n                k -= i - 1 - pre\\n        pre = i\\n    return int(ans)\\n```\n```\\npublic long minimalKSum(int[] nums, int k) {\\n    Arrays.sort(nums);\\n    long pre = 0;\\n    long ans = 0;\\n    for (long i : nums) {\\n        if (i >= pre + 1) {\\n            long ran = i - pre - 1;\\n            if (ran >= k) {\\n                ans += k == 1? pre + 1 : (pre + 1 + pre + k) * k / 2;\\n                k = 0;\\n                break;\\n            } else {\\n                ans += (pre + 1 + i - 1) * (i - 1 - pre) / 2;\\n                k -= i - 1 - pre;\\n            }\\n        }\\n        pre = i;\\n    }\\n    if (k > 0) {\\n        ans += k == 1? pre + 1 : (pre + 1 + pre + k) * k / 2;\\n    }\\n    return ans;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823831,
                "title": "weekly-contest-283-approach-using-sorting-easy-understandable-code-o-n-log-n",
                "content": "Please give a upvote if you like this solutions. Comment if you didn\\'t get it.\\n\\nThe given problem asks to find the sum of **K elements** that are not present in the array and have a **minimum sum**. This problem can be solved by observing that **we can choose first K missing elements from the array** to the resultant sum.\\n\\nFor **finding** the first **K missing elements**, we can solve by the following approach:\\n\\n1. [Sort the given array](https://leetcode.com/tag/sorting/).\\n2. Since sorting the given array will all elements in increasing order. We can use this order to **find the possible missing elements between two consecutive elements** and choose those elements in the resultant sum.\\n3. The above step can be repeated until we get our K missing elements.\\n\\nBelow is the implementation of the above approach:\\n\\n```\\nclass Solution {\\n\\n    // Finds the sum of number in the range\\n    // [X, Y]\\n    long long findSum(int X, int Y)\\n    {\\n        long long int sumMax = 1LL * Y * (Y + 1) / 2;\\n        long long int sumMin = 1LL * X * (X - 1) / 2;\\n        return sumMax - sumMin;\\n    }\\n\\npublic:\\n    long long minimalKSum(vector<int>& nums, int K)\\n    {\\n        long long sum = 0;\\n        int N = nums.size(), previous = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        for (auto& it : nums) {\\n            int diff = it - previous;\\n\\n            // If the consecutive Difference is\\n            // greater than 1, then we can choose\\n            // some elements for the resultant sum\\n            if (diff > 1) {\\n\\n                // If the difference is K, then we can\\n\\t\\t\\t\\t// choose only K - 1 elements\\n\\n                // For Eg: from the range [4, 8]\\n                // we can choose only 3 elements,\\n                // but the difference is 4(8 - 4).\\n                // next one element can be chosen\\n                // in next iteration\\n                if (K == diff) {\\n                    sum += findSum(previous + 1, previous + K - 1);\\n                    K = 1;\\n                }\\n                else if (diff > K) {\\n                    sum += findSum(previous + 1, previous + K);\\n                    K = 0;\\n                    break;\\n                }\\n                else {\\n                    sum += findSum(previous + 1, it - 1);\\n                    K -= (diff - 1);\\n                }\\n            }\\n            previous = it;\\n        }\\n\\n        // If still K is remaining, then choose the\\n        // element from [nums[N - 1], 10^9]\\n        if (K) {\\n            int lastElement = nums[N - 1];\\n            sum += findSum(lastElement + 1, lastElement + K);\\n        }\\n        return sum;\\n    }\\n};\\n```\\n***Time Complexity:** O(N(log N))\\n**Space Complexity:** O(1)*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Finds the sum of number in the range\\n    // [X, Y]\\n    long long findSum(int X, int Y)\\n    {\\n        long long int sumMax = 1LL * Y * (Y + 1) / 2;\\n        long long int sumMin = 1LL * X * (X - 1) / 2;\\n        return sumMax - sumMin;\\n    }\\n\\npublic:\\n    long long minimalKSum(vector<int>& nums, int K)\\n    {\\n        long long sum = 0;\\n        int N = nums.size(), previous = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        for (auto& it : nums) {\\n            int diff = it - previous;\\n\\n            // If the consecutive Difference is\\n            // greater than 1, then we can choose\\n            // some elements for the resultant sum\\n            if (diff > 1) {\\n\\n                // If the difference is K, then we can\\n\\t\\t\\t\\t// choose only K - 1 elements\\n\\n                // For Eg: from the range [4, 8]\\n                // we can choose only 3 elements,\\n                // but the difference is 4(8 - 4).\\n                // next one element can be chosen\\n                // in next iteration\\n                if (K == diff) {\\n                    sum += findSum(previous + 1, previous + K - 1);\\n                    K = 1;\\n                }\\n                else if (diff > K) {\\n                    sum += findSum(previous + 1, previous + K);\\n                    K = 0;\\n                    break;\\n                }\\n                else {\\n                    sum += findSum(previous + 1, it - 1);\\n                    K -= (diff - 1);\\n                }\\n            }\\n            previous = it;\\n        }\\n\\n        // If still K is remaining, then choose the\\n        // element from [nums[N - 1], 10^9]\\n        if (K) {\\n            int lastElement = nums[N - 1];\\n            sum += findSum(lastElement + 1, lastElement + K);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823754,
                "title": "c-simple",
                "content": "```cpp\\n    typedef long long LL;\\n    LL sum(LL l, LL r) {\\n        return (l + r) * (r - l + 1) / 2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        LL ans = 0;\\n\\t\\t// We will add 0 and 2e9 in nums vector so that we can handle edge cases inside array\\n        nums.push_back(0);\\n        nums.push_back(2e9);\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for (int i = 0; i < n && k; i++) {\\n            LL c = nums[i + 1] - nums[i] - 1;\\n            if (c <= 0) {\\n                continue;\\n            }\\n            if (c > k) {\\n                c = k;\\n            }\\n            ans += sum(nums[i] + 1, nums[i] + c);\\n            k -= c;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    typedef long long LL;\\n    LL sum(LL l, LL r) {\\n        return (l + r) * (r - l + 1) / 2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        LL ans = 0;\\n\\t\\t// We will add 0 and 2e9 in nums vector so that we can handle edge cases inside array\\n        nums.push_back(0);\\n        nums.push_back(2e9);\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for (int i = 0; i < n && k; i++) {\\n            LL c = nums[i + 1] - nums[i] - 1;\\n            if (c <= 0) {\\n                continue;\\n            }\\n            if (c > k) {\\n                c = k;\\n            }\\n            ans += sum(nums[i] + 1, nums[i] + c);\\n            k -= c;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823734,
                "title": "java-easy-solution-o-n-time-space-complexity",
                "content": "\\n\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n\\t    // used to get rid of overflow when ans = k*(k+1)/2 - ans;\\n        long k = (long) K;\\n        Long sum = 0l;\\n        int count = K;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n\\t\\t\\t// !set.contains(num) handles duplicates\\n            if(!set.contains(num) && 1<=num && num<=k){\\n                sum += (long) num;\\n                count -= 1;\\n            }\\n            set.add(num);\\n        }\\n        long ans = k*(k+1)/2 - sum;\\n        for(int i=K+1; count<k; i++){\\n            if(!set.contains(i)){\\n                ans += i;\\n                count++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n\\t    // used to get rid of overflow when ans = k*(k+1)/2 - ans;\\n        long k = (long) K;\\n        Long sum = 0l;\\n        int count = K;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n\\t\\t\\t// !set.contains(num) handles duplicates\\n            if(!set.contains(num) && 1<=num && num<=k){\\n                sum += (long) num;\\n                count -= 1;\\n            }\\n            set.add(num);\\n        }\\n        long ans = k*(k+1)/2 - sum;\\n        for(int i=K+1; count<k; i++){\\n            if(!set.contains(i)){\\n                ans += i;\\n                count++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823679,
                "title": "python3-simple-solution",
                "content": "\\nSimple Brute force solution with set\\n\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        l = set(nums)\\n        count, res = 1, 0\\n\\t\\t\\n        while k>0:\\n            if count not in l:\\n                res+=count\\n                k = k-1\\n            count+=1\\n        \\n        return res\\n\\t\\t\\nThis will show TLE\\n\\n\\n**Improved Solution**\\n\\t\\t\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        count, res = 1, 0\\n        \\n        x = nums[0]-1\\n        if k <= x:\\n            return k*(k+1)//2\\n        \\n        res += x*(x+1)//2\\n        k = k-x\\n        \\n        for i in range(len(nums)-1):\\n            diff = nums[i+1]-nums[i]-1\\n            if diff<=0:\\n                continue\\n\\t\\t\\t\\t\\n            temp = nums[i]*(nums[i]+1)//2\\n            \\n            if k<=diff:\\n                a = nums[i]+k\\n                res += ((a*(a+1)//2) - (temp))\\n                return res\\n            else:\\n                k = k-diff\\n                a = nums[i]+diff\\n                res += ((a*(a+1)//2) - (temp))\\n        \\n        if k>0:\\n            r = nums[-1]\\n            s = r+k\\n            res += s*(s+1)//2 - r*(r+1)//2\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\nSimple Brute force solution with set\\n\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        l = set(nums)\\n        count, res = 1, 0\\n\\t\\t\\n        while k>0:\\n            if count not in l:\\n                res+=count\\n                k = k-1\\n            count+=1\\n        \\n        return res\\n\\t\\t\\nThis will show TLE\\n\\n\\n**Improved Solution**\\n\\t\\t\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        count, res = 1, 0\\n        \\n        x = nums[0]-1\\n        if k <= x:\\n            return k*(k+1)//2\\n        \\n        res += x*(x+1)//2\\n        k = k-x\\n        \\n        for i in range(len(nums)-1):\\n            diff = nums[i+1]-nums[i]-1\\n            if diff<=0:\\n                continue\\n\\t\\t\\t\\t\\n            temp = nums[i]*(nums[i]+1)//2\\n            \\n            if k<=diff:\\n                a = nums[i]+k\\n                res += ((a*(a+1)//2) - (temp))\\n                return res\\n            else:\\n                k = k-diff\\n                a = nums[i]+diff\\n                res += ((a*(a+1)//2) - (temp))\\n        \\n        if k>0:\\n            r = nums[-1]\\n            s = r+k\\n            res += s*(s+1)//2 - r*(r+1)//2\\n            \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1823640,
                "title": "maths-c-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(begin(nums), end(nums));\\n        \\n        nums.push_back(2 * 1e9 + 1);\\n        if(nums[0] != 1){\\n            nums.insert(nums.begin(), 0);\\n        }\\n        \\n        long long sum = 0;\\n        int i = 0;\\n        \\n        while(k > 0 && i < nums.size() - 1){\\n            int n = nums[i + 1] - nums[i] - 1;\\n            if(n > 0){\\n                if(k >= n){\\n                    k -= n;\\n                    long long curr = 1LL * ((2LL * nums[i] + 1 + n) * n ) / 2;\\n                    sum += curr;\\n                }\\n                else{\\n                    long long curr = 1LL * ((2LL * nums[i] + 1 + k) * k ) / 2;\\n                    k = 0;\\n                    sum += curr;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(begin(nums), end(nums));\\n        \\n        nums.push_back(2 * 1e9 + 1);\\n        if(nums[0] != 1){\\n            nums.insert(nums.begin(), 0);\\n        }\\n        \\n        long long sum = 0;\\n        int i = 0;\\n        \\n        while(k > 0 && i < nums.size() - 1){\\n            int n = nums[i + 1] - nums[i] - 1;\\n            if(n > 0){\\n                if(k >= n){\\n                    k -= n;\\n                    long long curr = 1LL * ((2LL * nums[i] + 1 + n) * n ) / 2;\\n                    sum += curr;\\n                }\\n                else{\\n                    long long curr = 1LL * ((2LL * nums[i] + 1 + k) * k ) / 2;\\n                    k = 0;\\n                    sum += curr;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948130,
                "title": "optimized-sol-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo achieve the goal of minimizing the sum, you need to find the smallest positive integers that are not already present in the nums array. The logic behind the code is to iteratively find these missing integers and calculate their sum using the formula for the sum of consecutive integers.\\n\\nThe approach focuses on identifying gaps between existing elements in the array where new positive integers can be inserted to minimize the sum. It calculates the sum of missing integers using the sum formula for consecutive integers, updates the ranges and counts as it iterates, and finally returns the calculated answer. The provided code translates this approach into code logic.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Preprocessing:** Convert the given nums array into a set named s to efficiently identify the unique elements. This set will help you track which integers are already present in the array.\\n\\n**Sorting and Iteration:** Iterate through the unique elements of the set s, in ascending order. The idea is to find the gaps between the existing elements in the array where new positive integers can be inserted.\\n\\n**Identifying Missing Integers:** For each unique element in the set s, calculate the range of missing integers between the current element and the next element in the set. The range [start, it] represents the missing positive integers that can be inserted between start and the current unique element it.\\n\\n**Counting Missing Integers:** Check how many missing integers are there in the calculated range. If the remaining count k (how many integers you still need to append) is greater than the count of missing integers in the range, update k by subtracting the count of missing integers. Otherwise, you have found enough missing integers to append, and you can break the loop.\\n\\n**Calculating Sum of Missing Integers:** Use the formula (r*(r+1)/2) - (l*(l-1)/2) to calculate the sum of the missing integers in the range [start, it], where l is the lower bound of the range and r is the upper bound of the range. Add this sum to the cumulative answer.\\n\\n**Updating start:** Set start to be one greater than the current unique element it. This prepares the starting point for the next iteration.\\n\\n**Handling Remaining Missing Integers:** After iterating through the unique elements, you might still have some missing integers to append. Calculate the final range [start, start + k - 1] where you need to insert these remaining missing integers.\\n\\n**Calculating Sum of Remaining Missing Integers:** Use the same sum formula to calculate the sum of the remaining missing integers in the final range and add it to the cumulative answer.\\n\\n**Return Answer:** The cumulative answer obtained represents the minimum sum of k unique positive integers that need to be appended to the nums array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<int> s;\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;i++) {\\n            s.insert(nums[i]);\\n        }\\n\\n        long long ans = 0;\\n        int start = 1;\\n\\n        for(auto it : s) {\\n            long long l = start;\\n            long long r = it;\\n\\n            if(k > (r-l)) {\\n                k -= (r-l);\\n            }\\n            else \\n                break;\\n\\n            ans += (r*(r-1)/2) - (l*(l-1)/2);\\n\\n            start = r+1;\\n        }\\n\\n        long long l = start;\\n        long long r = start + k;\\n\\n        ans += (r*(r-1)/2) - (l*(l-1)/2);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<int> s;\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;i++) {\\n            s.insert(nums[i]);\\n        }\\n\\n        long long ans = 0;\\n        int start = 1;\\n\\n        for(auto it : s) {\\n            long long l = start;\\n            long long r = it;\\n\\n            if(k > (r-l)) {\\n                k -= (r-l);\\n            }\\n            else \\n                break;\\n\\n            ans += (r*(r-1)/2) - (l*(l-1)/2);\\n\\n            start = r+1;\\n        }\\n\\n        long long l = start;\\n        long long r = start + k;\\n\\n        ans += (r*(r-1)/2) - (l*(l-1)/2);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936304,
                "title": "python-o-n-time-no-sorting",
                "content": "# Intuition\\nStart with sum of `1..k` and and then modify it to take in account `nums`\\n\\n# Approach\\nConvert `nums` to *set* to get rid of repeating numbers.\\nCalculate sum of `1..k`. Loop through all `nums`.\\n`last` represents the leftmost \"hole\" that we can fill if currently considered `num` falls inside `1..k` interval.\\n\\n# Complexity\\n- Time complexity: O(len(nums))\\n- Space complexity: O(len(nums))\\n\\n# Code\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = set(nums)\\n        res, last = k * (k + 1) // 2, k\\n        for num in nums:\\n            if num <= k:\\n                last += 1\\n                while last in nums:\\n                    last += 1\\n                res += last - num\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = set(nums)\\n        res, last = k * (k + 1) // 2, k\\n        for num in nums:\\n            if num <= k:\\n                last += 1\\n                while last in nums:\\n                    last += 1\\n                res += last - num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862517,
                "title": "js-solution-slow-but-understandable-solution-with-comments",
                "content": "## 1. Sort the array in ascending numerical order;\\n## 2. Use all values \\u200B\\u200Bthat occur up to the minimum value in the array;\\n## 3. Check and use values \\u200B\\u200Bthat are in the range of the array (from the minimum value of the array to the maximum value of the array) and are not used in it;\\n## 4. Use all values \\u200B\\u200Boccurring after the maximum value in the array;\\n## 5. At each step, compare the value of the counter and \"k\".\\n\\n---\\n\\n###### Since the numbers are used first, starting from 1 to the minimum value in the array and then ascending, this amount is always the minimum.\\n\\n---\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimalKSum = function(nums, k) {\\n    let sum = 0;\\n    let count = 0;\\n    let i = 1;\\n    nums.sort((a, b) => a - b); // sort array in ascending order \\n    \\n//Use all values \\u200B\\u200Bthat are less than the minimum value in the array\\n    while (i < nums[0] & count != k){\\n        count++;\\n        sum += i;\\n        i++;\\n    } \\n\\n//Use all unused values \\u200B\\u200Bin an array\\n    if ( i >= nums[0] & i <= nums[nums.length - 1]){\\n        for (let j = 0; j < nums.length;){\\n            if (i == nums[j]) {i++; j++;}\\n            else if (i > nums[j]) j++;\\n            else {\\n                count++;\\n                sum += i;\\n                i++;\\n            }\\n            if (count == k) break;\\n        }\\n    }\\n\\n//Use all values \\u200B\\u200Bthat are greater than the maximum value in the array\\n    while (count != k){\\n        count++;\\n        sum += i;\\n        i++;\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimalKSum = function(nums, k) {\\n    let sum = 0;\\n    let count = 0;\\n    let i = 1;\\n    nums.sort((a, b) => a - b); // sort array in ascending order \\n    \\n//Use all values \\u200B\\u200Bthat are less than the minimum value in the array\\n    while (i < nums[0] & count != k){\\n        count++;\\n        sum += i;\\n        i++;\\n    } \\n\\n//Use all unused values \\u200B\\u200Bin an array\\n    if ( i >= nums[0] & i <= nums[nums.length - 1]){\\n        for (let j = 0; j < nums.length;){\\n            if (i == nums[j]) {i++; j++;}\\n            else if (i > nums[j]) j++;\\n            else {\\n                count++;\\n                sum += i;\\n                i++;\\n            }\\n            if (count == k) break;\\n        }\\n    }\\n\\n//Use all values \\u200B\\u200Bthat are greater than the maximum value in the array\\n    while (count != k){\\n        count++;\\n        sum += i;\\n        i++;\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549255,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getApSum(long long a, long long n, long long d) {\\n        return  ((2*a+(n-1)*d)*n)/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        \\n        // To use first element also. Like if nums start with 5 than we can add [1,2,3,4]\\n        nums.push_back(0);\\n        sort(nums.begin(), nums.end());\\n        \\n        // Keep adding till k\\n        for(int i=0;i<nums.size()-1 && k>0;++i) {\\n            \\n            // Get the length of AP which can be added.\\n            int n = nums[i+1]-nums[i]-1;\\n            \\n            // If we can\\'t add any element, for example [12,12] or [11,12].\\n            if(n<=0) continue;\\n            \\n            // If we have option to add much more than needed. For example [1,12] and k is 5. So we need only 5 element to add.\\n            if(k<n) n=k;\\n            k-= n;\\n            \\n            // Get the sum of n AP elements who\\'s first element is nums[i]+1 and keep difference of 1.\\n            res += getApSum(nums[i]+1, n, 1);\\n        }\\n        \\n        // If still we k to add element than add continuous k element from nums.back()+1.\\n        // For example : nums[1,2] and k=5 So we need add [3,4,5,6,7].\\n        if(k>0) {\\n            res+= getApSum(nums.back()+1, k, 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getApSum(long long a, long long n, long long d) {\\n        return  ((2*a+(n-1)*d)*n)/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        \\n        // To use first element also. Like if nums start with 5 than we can add [1,2,3,4]\\n        nums.push_back(0);\\n        sort(nums.begin(), nums.end());\\n        \\n        // Keep adding till k\\n        for(int i=0;i<nums.size()-1 && k>0;++i) {\\n            \\n            // Get the length of AP which can be added.\\n            int n = nums[i+1]-nums[i]-1;\\n            \\n            // If we can\\'t add any element, for example [12,12] or [11,12].\\n            if(n<=0) continue;\\n            \\n            // If we have option to add much more than needed. For example [1,12] and k is 5. So we need only 5 element to add.\\n            if(k<n) n=k;\\n            k-= n;\\n            \\n            // Get the sum of n AP elements who\\'s first element is nums[i]+1 and keep difference of 1.\\n            res += getApSum(nums[i]+1, n, 1);\\n        }\\n        \\n        // If still we k to add element than add continuous k element from nums.back()+1.\\n        // For example : nums[1,2] and k=5 So we need add [3,4,5,6,7].\\n        if(k>0) {\\n            res+= getApSum(nums.back()+1, k, 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380472,
                "title": "python-gauss-formula-n-n-1-2",
                "content": "```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n        count=0\\n        n=sorted(list(set(nums)))\\n        for i in range(len(n)):\\n            if n[i] <= k:\\n                count+=n[i]\\n                k+=1\\n        return k*(k+1)//2 - count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n        count=0\\n        n=sorted(list(set(nums)))\\n        for i in range(len(n)):\\n            if n[i] <= k:\\n                count+=n[i]\\n                k+=1\\n        return k*(k+1)//2 - count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2209384,
                "title": "python-o-nlogn-solution-using-sort-97-65-faster",
                "content": "A straightforward solution would be to initialize the sum with zero, search for the smallest integers that are not in `nums`, and add them to the sum. However, this approach would yield a TLE because the range we are searching within could be as big as `1e9`. \\n\\nTherefore, working within the range of `len(nums)` would be far more efficient because at most we would be working with `1e5` elements. This is why we can afford to sort and filter `nums` beforehand without getting TLE.\\n\\nThe idea behind this solution is that we initialize the sum with the sum of the first positive `k` integers, and when we find one of these integers in `nums`, we remove it from the sum (by subtracting) and add the next integer after `k`.\\n\\nAnother note is that after sorting, we can break the loop early when values become bigger than `k`, thus saving a bit more time.\\n\\n```python\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        k_sum = k * (k + 1) // 2\\n        nums = [*set(nums)]\\n        nums.sort()\\n        \\n        for num in nums:\\n            if num > k:\\n                break\\n            else:\\n                k += 1\\n                k_sum += k - num\\n                \\n        return k_sum\\n```\\n\\n![image](https://assets.leetcode.com/users/images/59e9462d-9ef2-48d6-a14a-dd101396d7d8_1656415088.6254692.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```python\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        k_sum = k * (k + 1) // 2\\n        nums = [*set(nums)]\\n        nums.sort()\\n        \\n        for num in nums:\\n            if num > k:\\n                break\\n            else:\\n                k += 1\\n                k_sum += k - num\\n                \\n        return k_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072526,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<ll> st;\\n        for(auto num:nums)\\n        {\\n            st.insert(num);\\n        }\\n        ll start=1;\\n        ll ans=0,l,r;\\n        for(auto num:st)\\n        {\\n            r=num;\\n            l=start;\\n            if(k>(r-l))\\n            {\\n                k-=(r-l);\\n                ans+=(r*(r-1))/2-(l*(l-1))/2;\\n                start=r+1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        l=start;\\n        r=l+k;\\n        ans+=(r*(r-1))/2-(l*(l-1))/2;\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<ll> st;\\n        for(auto num:nums)\\n        {\\n            st.insert(num);\\n        }\\n        ll start=1;\\n        ll ans=0,l,r;\\n        for(auto num:st)\\n        {\\n            r=num;\\n            l=start;\\n            if(k>(r-l))\\n            {\\n                k-=(r-l);\\n                ans+=(r*(r-1))/2-(l*(l-1))/2;\\n                start=r+1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        l=start;\\n        r=l+k;\\n        ans+=(r*(r-1))/2-(l*(l-1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066671,
                "title": "java-solution-sorting",
                "content": "```java \\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        int range = k;\\n        long sum=0;\\n        Arrays.sort(nums);\\n    for(int i=0;i<nums.length-1;i++)\\n    {\\n        if(nums[i]!=nums[i+1]&&nums[i]<=range)\\n        {\\n            range++; //On the occurence of a number the range is incremented by one\\n\\t\\t\\t//For eg. let k=1 & 1,2 are not present in nums but if it they are present then calculate sum of Range(1 to 3) and subtract sum of 1+2 from it.\\n            sum+=nums[i]; //counting the sum of numbers which are present in nums\\n        }\\n    } \\n    if(nums[nums.length-1]<=range)\\n    {\\n        range++;\\n        sum+=nums[nums.length-1];\\n    }\\n\\t\\n\\t//The sum of range 1 to n is calculated by the formula sum = n * (n+1) /2;\\n    long sum2 = (long)range*(range+1);\\n    sum2=sum2/2;\\n\\t//Subtracting the sum of those numbers which are present in the nums from range sum of 1 to n\\n    return sum2-sum;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        int range = k;\\n        long sum=0;\\n        Arrays.sort(nums);\\n    for(int i=0;i<nums.length-1;i++)\\n    {\\n        if(nums[i]!=nums[i+1]&&nums[i]<=range)\\n        {\\n            range++; //On the occurence of a number the range is incremented by one\\n\\t\\t\\t//For eg. let k=1 & 1,2 are not present in nums but if it they are present then calculate sum of Range(1 to 3) and subtract sum of 1+2 from it.\\n            sum+=nums[i]; //counting the sum of numbers which are present in nums\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2016424,
                "title": "easy-cpp-priority-queue-logic-observation-for-higher-k-values",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n       priority_queue<long long,vector<long long>,greater<long long>> pq;\\n        for(int i=0;i<nums.size();i++) pq.push(nums[i]);\\n        long long sum=0;\\n        long long maxi=*max_element(nums.begin(),nums.end());\\n        long long p=1;\\n        while(pq.size() && k){\\n            int x=pq.top();\\n            while(p<x && k){\\n                sum+=p;\\n                p++;\\n                k--;\\n            }\\n            p=x+1;\\n            pq.pop();\\n        }\\n        if(k){\\n           sum+=maxi*(long long)k+((long long)k*((long long)k+1))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n       priority_queue<long long,vector<long long>,greater<long long>> pq;\\n        for(int i=0;i<nums.size();i++) pq.push(nums[i]);\\n        long long sum=0;\\n        long long maxi=*max_element(nums.begin(),nums.end());\\n        long long p=1;\\n        while(pq.size() && k){\\n            int x=pq.top();\\n            while(p<x && k){\\n                sum+=p;\\n                p++;\\n                k--;\\n            }\\n            p=x+1;\\n            pq.pop();\\n        }\\n        if(k){\\n           sum+=maxi*(long long)k+((long long)k*((long long)k+1))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880637,
                "title": "c-easy-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long long k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<long long>v;\\n        v.push_back(nums[0]);\\n        for(int i =1; i<nums.size(); i++ ){\\n            if(nums[i]!=nums[i-1]){\\n                v.push_back(nums[i]);\\n                \\n            }\\n        }\\n        sort(v.begin(),v.end());\\n\\n        \\n        \\n        long long int  sum = k*((k+1))/2;\\n        for(int i = 0; i<v.size(); i++){\\n            if(v[i]<=k){\\n                k++;\\n                sum = sum - v[i] + k;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long long k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<long long>v;\\n        v.push_back(nums[0]);\\n        for(int i =1; i<nums.size(); i++ ){\\n            if(nums[i]!=nums[i-1]){\\n                v.push_back(nums[i]);\\n                \\n            }\\n        }\\n        sort(v.begin(),v.end());\\n\\n        \\n        \\n        long long int  sum = k*((k+1))/2;\\n        for(int i = 0; i<v.size(); i++){\\n            if(v[i]<=k){\\n                k++;\\n                sum = sum - v[i] + k;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874477,
                "title": "c-o-n-solution-using-hash-set",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n\\n        const int m = nums.size();\\n        \\n        unordered_set<int> filtered_nums; // unique, <= k + m\\n        for(auto num : nums)\\n        {\\n            if(num <= k + m)\\n            {\\n                filtered_nums.insert(num);\\n            }\\n        }\\n\\n        const int64_t sum_filtered = accumulate(filtered_nums.begin(), filtered_nums.end(), 0L);\\n        const int n_filtered = filtered_nums.size();\\n        \\n        int x = k + m;\\n        int64_t sum = static_cast<int64_t>(x) * (x + 1) / 2  -  sum_filtered;\\n        \\n        int count = m - n_filtered; \\n            // we need to remove this many numbers from [1, k+m] \\\\ filtered_nums\\n        while(count > 0)\\n        {\\n            if(filtered_nums.count(x) == 0)\\n            {\\n                --count, sum -= x;\\n            }\\n            \\n            --x;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n\\n        const int m = nums.size();\\n        \\n        unordered_set<int> filtered_nums; // unique, <= k + m\\n        for(auto num : nums)\\n        {\\n            if(num <= k + m)\\n            {\\n                filtered_nums.insert(num);\\n            }\\n        }\\n\\n        const int64_t sum_filtered = accumulate(filtered_nums.begin(), filtered_nums.end(), 0L);\\n        const int n_filtered = filtered_nums.size();\\n        \\n        int x = k + m;\\n        int64_t sum = static_cast<int64_t>(x) * (x + 1) / 2  -  sum_filtered;\\n        \\n        int count = m - n_filtered; \\n            // we need to remove this many numbers from [1, k+m] \\\\ filtered_nums\\n        while(count > 0)\\n        {\\n            if(filtered_nums.count(x) == 0)\\n            {\\n                --count, sum -= x;\\n            }\\n            \\n            --x;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859882,
                "title": "k-k-1-2",
                "content": "```\\nclass Solution {\\n    long mod=(long)1e18+7;\\n    public long minimalKSum(int[] nums, int k) {\\n        long tsum=0;\\n        Arrays.sort(nums);\\n        Set<Integer> set=new HashSet<>();\\n        for(int b:nums) {\\n            if(set.contains(b)) continue;\\n            else set.add(b);\\n            \\n            if(b<=k) {\\n            k++;\\n            tsum+=b;\\n            }\\n          \\n        }\\n        \\n      \\n        long msum=  (k%mod* ( k+1)%mod/2)%mod;\\n        msum-=tsum;\\n        \\n        return msum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long mod=(long)1e18+7;\\n    public long minimalKSum(int[] nums, int k) {\\n        long tsum=0;\\n        Arrays.sort(nums);\\n        Set<Integer> set=new HashSet<>();\\n        for(int b:nums) {\\n            if(set.contains(b)) continue;\\n            else set.add(b);\\n            \\n            if(b<=k) {\\n            k++;\\n            tsum+=b;\\n            }\\n          \\n        }\\n        \\n      \\n        long msum=  (k%mod* ( k+1)%mod/2)%mod;\\n        msum-=tsum;\\n        \\n        return msum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855339,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll minimalKSum(vector<int>& nums, ll K ) {\\n        sort(begin(nums),end(nums)) ;\\n        ll pick = 0 ;\\n        for(int i = 0 ; i < nums.size() ; i++ ){\\n            if(i==0 and nums[0] <= K){\\n                pick += nums[i] ;\\n                ++K ;\\n            }\\n\\t\\t\\t//handle duplicate cases also\\n            else if(i!=0 and nums[i] != nums[i-1] and nums[i] <= K ){\\n                pick += nums[i] ;\\n                ++K ;\\n            }\\n        }\\n        return (K*(K+1))/2LL - pick ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll minimalKSum(vector<int>& nums, ll K ) {\\n        sort(begin(nums),end(nums)) ;\\n        ll pick = 0 ;\\n        for(int i = 0 ; i < nums.size() ; i++ ){\\n            if(i==0 and nums[0] <= K){\\n                pick += nums[i] ;\\n                ++K ;\\n            }\\n\\t\\t\\t//handle duplicate cases also\\n            else if(i!=0 and nums[i] != nums[i-1] and nums[i] <= K ){\\n                pick += nums[i] ;\\n                ++K ;\\n            }\\n        }\\n        return (K*(K+1))/2LL - pick ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842390,
                "title": "find-and-remove-tc-o-n-log-n-sc-o-1",
                "content": "Make a set of nums so as to use only ubnique values. the minimal sum is the sum of first n natural numbers (n*(n+1)/2). We then traverse the set and remove if we have a number in the array and add the next number (k+1) to the sum.\\n```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n\\tlong long sum = (long long)k * (long long)(k+1) * 0.5;\\n\\tset<long long> st(nums.begin(), nums.end());\\n\\n\\tfor(auto& num : st) {\\n\\t\\tif(num <= k) sum += (++k - num);\\n\\t\\telse break;\\n\\t}\\n\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n\\tlong long sum = (long long)k * (long long)(k+1) * 0.5;\\n\\tset<long long> st(nums.begin(), nums.end());\\n\\n\\tfor(auto& num : st) {\\n\\t\\tif(num <= k) sum += (++k - num);\\n\\t\\telse break;\\n\\t}\\n\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841668,
                "title": "java-easiest-solution-using-n-n-1-2",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long sum = 0;\\n        for(int i=1; i<=k; i++) {\\n            sum+=i;\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++) {\\n            if(i !=0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            if(nums[i]<=k) {\\n                sum -= nums[i];\\n                k++;\\n                sum+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long sum = 0;\\n        for(int i=1; i<=k; i++) {\\n            sum+=i;\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++) {\\n            if(i !=0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            if(nums[i]<=k) {\\n                sum -= nums[i];\\n                k++;\\n                sum+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839183,
                "title": "c-sorting-tc-o-n-log-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int i=0;long long sum=0;\\n        long long curr=1;\\n        int n=nums.size();\\n        while(i<n && k>0)\\n        {\\n            if(nums[i]>curr)\\n            {\\n                if(k>=(nums[i]-curr))\\n                {\\n                    sum+=(nums[i]-curr)*(curr+nums[i]-1)/2;\\n                    k-=nums[i]-curr;\\n                }\\n                else\\n                {\\n                    sum+=k*(2*curr+k-1)/2;\\n                    k=0;\\n                }\\n                curr=nums[i]+1;\\n                i++;\\n            }\\n            else\\n            {\\n                while(i<n && nums[i]<=curr)\\n                {\\n                    curr=nums[i]+1;\\n                    i++;\\n                }\\n                if(i==n)\\n                {\\n                    sum+=k*(2*curr+k-1)/2;\\n                    k=0;\\n                }\\n            }\\n        }\\n        if(k!=0)\\n        sum+=k*(2*curr+k-1)/2;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int i=0;long long sum=0;\\n        long long curr=1;\\n        int n=nums.size();\\n        while(i<n && k>0)\\n        {\\n            if(nums[i]>curr)\\n            {\\n                if(k>=(nums[i]-curr))\\n                {\\n                    sum+=(nums[i]-curr)*(curr+nums[i]-1)/2;\\n                    k-=nums[i]-curr;\\n                }\\n                else\\n                {\\n                    sum+=k*(2*curr+k-1)/2;\\n                    k=0;\\n                }\\n                curr=nums[i]+1;\\n                i++;\\n            }\\n            else\\n            {\\n                while(i<n && nums[i]<=curr)\\n                {\\n                    curr=nums[i]+1;\\n                    i++;\\n                }\\n                if(i==n)\\n                {\\n                    sum+=k*(2*curr+k-1)/2;\\n                    k=0;\\n                }\\n            }\\n        }\\n        if(k!=0)\\n        sum+=k*(2*curr+k-1)/2;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838216,
                "title": "fast-python-solution-in-5-lines",
                "content": "Here is my 5-liner:\\n\\n```\\nclass Solution(object):\\n    def minimalKSum(self, nums, k):\\n        nums = sorted(list(set(nums)))\\n        for i in range(len(nums)):\\n            if nums[i]-1-i>=k:\\n                return (k+i)*(k+i+1)/2-sum(nums[:i])\\n        return (k+len(nums))*(k+len(nums)+1)/2-sum(nums)\\n```\\n\\nLet me go through the code with an example. \\n\\nSay, we have \\n```\\nnums=[5, 9, 5, 3]\\nk=4\\n```\\nFirst, we remove duplicates and sort the input array: \\n```\\nnums=[3, 5, 9]\\n```\\n\\nThen, we check iteratively how many vacant slots are there in front of a given `nums[i]`.\\nTo compute this, we need first to compute the total number of slots in front of `nums[i]`,\\nand to substract the  number of spaces already occupied by previous values `nums[:i]`. \\nAs there are no duplicates, there are exactly  `i` occupied slots in front of `nums[i]`. \\nIn our example, for `nums[2]=9` there are `9-1=8` slots ahead of it, with slots `3` and `5` aready occupied. \\nThis makes the total number of vacant slots ahead of `nums[i]` to be equal `nums[i]-1-i`.\\n\\nNow let\\'s look if this space is enough to accomodate `k` values.\\nOnce this is possible, `k` numbers fit snuggly around previous `nums[:i]` values.\\nFor our example, this will look like `[1][2][`**3**`][4][`**5**`][6]`.\\n\\nWhat we are asked to return is the sum of the inserted values (`sum([1,2,4,6])`).\\nFor our example, we can compute it as `sum([1,2,3,4,5,6])-sum([3,5])`.\\nIn general, there will be `k+i` numbers in total. \\nUsing the `n(n+1)/2` formula, we can write down the final expression as follows:\\n```\\n(k+i)*(k+i+1)/2-sum(nums[:i])\\n```\\n\\nSimilarly, in case we have iterated through all the values in `nums` and there is still not enough space,\\nthen `k` numbers will snug around the whole `nums` array (`i=len(nums)`).\\n(This could be illustrated with `nums=[3,5], k=4` example).\\n\\nHope this makes sense.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimalKSum(self, nums, k):\\n        nums = sorted(list(set(nums)))\\n        for i in range(len(nums)):\\n            if nums[i]-1-i>=k:\\n                return (k+i)*(k+i+1)/2-sum(nums[:i])\\n        return (k+len(nums))*(k+len(nums)+1)/2-sum(nums)\\n```\n```\\nnums=[5, 9, 5, 3]\\nk=4\\n```\n```\\nnums=[3, 5, 9]\\n```\n```\\n(k+i)*(k+i+1)/2-sum(nums[:i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836074,
                "title": "c-solution-with-comments-easy-to-understand",
                "content": "We have computed the minimal possible sum as `k * (k + 1) / 2)`. \\nAfter this, we iterated through the unique numbers in the array, and substituted `all numbers <= k`, with increasing numbers greater than k.\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        long long ans = (long long)k * (k+1) / 2; // sum of all elements till k\\n        set<int> s(nums.begin(), nums.end()); // inserting vector to set\\n        for(auto a: s) \\n        {\\n            if(a <= k) \\n            {\\n                ans += (++k) - a; \\n                // subtracting elements present in set from total sum variable (k)\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        long long ans = (long long)k * (k+1) / 2; // sum of all elements till k\\n        set<int> s(nums.begin(), nums.end()); // inserting vector to set\\n        for(auto a: s) \\n        {\\n            if(a <= k) \\n            {\\n                ans += (++k) - a; \\n                // subtracting elements present in set from total sum variable (k)\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833527,
                "title": "c-easy-explanation-with-examples",
                "content": "APPROACH\\n\\nformula to be used\\n**Sum of first n natural numbers:**\\n**n*(n+1)/2**\\n\\nInitially we compute the sum of first k natural numbers using the formula\\n**Sum = k*(k+1)/2;**\\nNow we will adjust the sum according to the values present in the array\\n\\n*we sort the original array and then traverse from left to right*\\n\\nwhenever we find a value which is less than k,,\\nwe deduct that value from total  and \\nadd k+1 to total sum(updating k to k+1)\\n\\nthere is a edge case,,\\nthat if nums[i] contains duplicate values,\\nthen we will update sum for only 1 value\\n\\n**Example:**\\n\\nnums = [4,5,6,6,8], k=10\\n\\n-- sum of first k(10) numbers is n(n+1)/2=55\\nnow if **(nums[i]<=k)** we update the sum\\n\\n---**sum=55,k=10**\\nfor i=0,\\nnums[i]=4 ,4<=10\\nsum=sum-nums[i]=55-4=51\\nk=k+1=11\\nsum=sum+k=51+11=62\\n\\n**sum=62,k=11**\\nfor i=1,\\nnums[i] = 5, 5<=11\\nsum=62-5=57\\nk++=12\\nsum+=k = 57+12=69\\n\\n**sum=69, k=12**\\nfor i=2,\\nnums[i]=6, 6<=12\\nsum=69-6=63\\nk++=13\\nsum+=k=63+13=76\\n\\n**sum=76, k=13**\\nfor i=3,\\nnums[i]=nums[i-1]=6\\ni++; continue;\\n\\n**sum=76, k=13**\\nfor i=4,\\nnums[i]=8, 8<=13\\nsum = 76-8=68\\nk++=14;\\nsum+=k = 68+14=82\\n\\n**O/P\\nsum=82**\\n\\n\\n**My Approach:**  **Time Complexity - O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long int ans=k;\\n        long long int x=k;                                                                             \\n        sort(nums.begin(),nums.end());\\n        \\n        ans = (x*(x+1))/2;  //sum of first k variables\\n        int i=0;  //pointer to traverse array\\n        while(i<nums.size() && k>=nums[i])  //checking if we dont go out of bounds and whether we need to update our sum\\n        {\\n            if(i>0 && nums[i]==nums[i-1])  //for duplicate elements\\n            {\\n                i++;continue;\\n            }\\n\\t\\t\\tk++;\\n            ans=ans-nums[i]+k;   //updating the sum\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you reached till here, then do give your suggestions and please Upvote(it really helps)**",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long int ans=k;\\n        long long int x=k;                                                                             \\n        sort(nums.begin(),nums.end());\\n        \\n        ans = (x*(x+1))/2;  //sum of first k variables\\n        int i=0;  //pointer to traverse array\\n        while(i<nums.size() && k>=nums[i])  //checking if we dont go out of bounds and whether we need to update our sum\\n        {\\n            if(i>0 && nums[i]==nums[i-1])  //for duplicate elements\\n            {\\n                i++;continue;\\n            }\\n\\t\\t\\tk++;\\n            ans=ans-nums[i]+k;   //updating the sum\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827973,
                "title": "java-sort-and-filter-taken-number",
                "content": "Sort and filter number in [1, k], and then use math\\n\\nThe trick part:\\n**If found one in [1, k], we should increase k, as we need more to fill the taken number**\\n\\nTime: O(N*log(N))\\nSpace: O(1)\\n\\n```\\nclass No2195Solution {\\n  public long minimalKSum(int[] nums, int k) {\\n    // sum of number(which means belong [1, k]) in origin array\\n    long taken = 0;\\n    Arrays.sort(nums);\\n    // remember last number to avoid duplicated number\\n    int last = 0;\\n    for (int num : nums) {\\n      if (num <= k) {\\n        // detect duplicate number\\n        if (num != last) {\\n          // found one in [1, k], so we increase k, as we need more to fill the taken number\\n          k++;\\n          taken += num;\\n        }\\n      } else {\\n        // k > num\\n        break;\\n      }\\n\\n      last = num;\\n    }\\n\\n    return (long) (k + 1) * k / 2 - taken;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass No2195Solution {\\n  public long minimalKSum(int[] nums, int k) {\\n    // sum of number(which means belong [1, k]) in origin array\\n    long taken = 0;\\n    Arrays.sort(nums);\\n    // remember last number to avoid duplicated number\\n    int last = 0;\\n    for (int num : nums) {\\n      if (num <= k) {\\n        // detect duplicate number\\n        if (num != last) {\\n          // found one in [1, k], so we increase k, as we need more to fill the taken number\\n          k++;\\n          taken += num;\\n        }\\n      } else {\\n        // k > num\\n        break;\\n      }\\n\\n      last = num;\\n    }\\n\\n    return (long) (k + 1) * k / 2 - taken;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827056,
                "title": "c-efficient-solution-in-nlogn-with-help-of-vector",
                "content": "**technique**\\n1. sort given vector and delete duplicates\\n2. minimum possible result is if first k numbers are missing ( sum of k natural numbers)\\n3. in the vector if ith element is already present in the vector which is less that k , then add k+1 and substract ith element\\n\\n```\\n\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& a, int k) \\n    {\\n        sort(a.begin(),a.end());\\n        long ans=(long(k)*(long(k+1)))/2;\\n        vector<int> v;\\n        v.push_back(a[0]);\\n        for(int i=1;i<a.size();i++)\\n            if(a[i]!=a[i-1])\\n                v.push_back(a[i]);\\n        for(int i=0;i<v.size();i++)\\n        {\\n             if(v[i]<=k ){\\n                ans-=v[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n                \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& a, int k) \\n    {\\n        sort(a.begin(),a.end());\\n        long ans=(long(k)*(long(k+1)))/2;\\n        vector<int> v;\\n        v.push_back(a[0]);\\n        for(int i=1;i<a.size();i++)\\n            if(a[i]!=a[i-1])\\n                v.push_back(a[i]);\\n        for(int i=0;i<v.size();i++)\\n        {\\n             if(v[i]<=k ){\\n                ans-=v[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n                \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826880,
                "title": "java-22ms-solution-o-1-space",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long sum = (k * (long)(k+1))/2;\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n\\t\\t   // to avoid duplicates\\n            if(i > 0 && nums[i] == nums[i-1]) continue;\\n            \\n\\t\\t\\t// if any of first k natural numbers already present in nums\\n\\t\\t\\t// subtract that from \\'sum\\' and add (k+1)th value\\n            if(nums[i] <= k){\\n                sum -= nums[i];\\n                k++;\\n                sum += k;\\n            }else break;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long sum = (k * (long)(k+1))/2;\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n\\t\\t   // to avoid duplicates\\n            if(i > 0 && nums[i] == nums[i-1]) continue;\\n            \\n\\t\\t\\t// if any of first k natural numbers already present in nums\\n\\t\\t\\t// subtract that from \\'sum\\' and add (k+1)th value\\n            if(nums[i] <= k){\\n                sum -= nums[i];\\n                k++;\\n                sum += k;\\n            }else break;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826862,
                "title": "python3-simple-math-solution",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = list(set(nums))\\n        nums.sort()\\n        total = 0\\n        \\n        for num in nums:\\n            if num <= k:\\n                k += 1\\n                total += num\\n        \\n        return k * (k + 1) // 2 - total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = list(set(nums))\\n        nums.sort()\\n        total = 0\\n        \\n        for num in nums:\\n            if num <= k:\\n                k += 1\\n                total += num\\n        \\n        return k * (k + 1) // 2 - total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826784,
                "title": "python-soln-with-the-help-of-sort-function-and-basic-sum-of-n-numbers",
                "content": "**Please Upvote if it helps**\\nFeel free to ask me question if you still cant understant. :)\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        n=len(nums)+1\\n        nums.append(0)\\n        nums.append(10**9)\\n        nums.sort()\\n        s=0       \\n        def solve(start, end):\\n            t=(end*end + end)//2 -(start*start+start)//2\\n            return t        \\n        for i in range(n):\\n            a,b=nums[i],nums[i+1]\\n            temp=b-a-1\\n            if temp>0:\\n                if temp<=k:\\n                    k-=temp\\n                    s+=solve(a, b-1)\\n                    if k <=0:\\n                        return s\\n                else:\\n                    s+=solve(a, a+k)\\n                    return s\\n        \\n```\\nTime Complexity: O(Nlog(N)) and Space Complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        n=len(nums)+1\\n        nums.append(0)\\n        nums.append(10**9)\\n        nums.sort()\\n        s=0       \\n        def solve(start, end):\\n            t=(end*end + end)//2 -(start*start+start)//2\\n            return t        \\n        for i in range(n):\\n            a,b=nums[i],nums[i+1]\\n            temp=b-a-1\\n            if temp>0:\\n                if temp<=k:\\n                    k-=temp\\n                    s+=solve(a, b-1)\\n                    if k <=0:\\n                        return s\\n                else:\\n                    s+=solve(a, a+k)\\n                    return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826194,
                "title": "java-solution-sum-of-consecutive-numbers-between-a-i-and-a-i-1",
                "content": "```\\n    public static long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int [] arr = new int [nums.length+2];\\n        arr[0] = 0;\\n        arr[arr.length - 1] = nums[nums.length - 1] + k + 1;\\n        System.arraycopy(nums, 0, arr, 1, nums.length);\\n        long sum = 0;\\n        \\n        for (int i = 1; i < arr.length && k > 0; i++) {\\n            int j = i-1;\\n            if(arr[i] == arr[j]) continue;\\n            long take = Math.min(arr[i] - (arr[j] + 1), k), n = arr[j] + take;\\n            sum = sum + (n * (n+1)/2) - (arr[j] * ((long)arr[j] + 1)/2);\\n\\t\\t    //1 + 2 + ... + n - ( 1 + 2 + ... + x ) == x + 1 + x + 2 + ... + n, n > x\\n\\t\\t\\t// =  n(n+1)/2 - x(x+1)/2\\n            k -= take;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int [] arr = new int [nums.length+2];\\n        arr[0] = 0;\\n        arr[arr.length - 1] = nums[nums.length - 1] + k + 1;\\n        System.arraycopy(nums, 0, arr, 1, nums.length);\\n        long sum = 0;\\n        \\n        for (int i = 1; i < arr.length && k > 0; i++) {\\n            int j = i-1;\\n            if(arr[i] == arr[j]) continue;\\n            long take = Math.min(arr[i] - (arr[j] + 1), k), n = arr[j] + take;\\n            sum = sum + (n * (n+1)/2) - (arr[j] * ((long)arr[j] + 1)/2);\\n\\t\\t    //1 + 2 + ... + n - ( 1 + 2 + ... + x ) == x + 1 + x + 2 + ... + n, n > x\\n\\t\\t\\t// =  n(n+1)/2 - x(x+1)/2\\n            k -= take;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825970,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n         long sum=(long)k*(k+1)/2;\\n        int count=0;\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int num:nums){\\n            if(num<=k && !set.contains(num)){\\n                sum=sum-(long)num;\\n                count++;\\n            }\\n            set.add(num);\\n        }\\n        int i=k+1;\\n        while(count>0){\\n            if(!set.contains(i)){\\n                sum+=i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n         long sum=(long)k*(k+1)/2;\\n        int count=0;\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int num:nums){\\n            if(num<=k && !set.contains(num)){\\n                sum=sum-(long)num;\\n                count++;\\n            }\\n            set.add(num);\\n        }\\n        int i=k+1;\\n        while(count>0){\\n            if(!set.contains(i)){\\n                sum+=i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825926,
                "title": "python-modified-nums-array-summing-gaps",
                "content": "\\t\\t# the first trick we use is to add 0 and max(nums) + 3*k to the  \\n\\t\\t# array nums.  this ensures that - by checking gaps between \\n\\t\\t# values in nums - we\\'ll find the lowest k pos indexes. We record\\n\\t\\t# how many values we\\'ve added with the variable cnt.\\n\\t\\tnums2 = [0] + sorted(nums) + [max(nums) + 3*k]\\n        N = len(nums2)\\n        cnt = 0 \\n        totSum = 0\\n        \\n        for ind, val in enumerate(nums2[:(N-1)]):\\n            gap = nums2[ind+1] - nums2[ind] - 1\\n            \\n\\t\\t\\t# the other tricky part is to handle the cases where\\n\\t\\t\\t# remaining k-cnt is less than or greater than the gap.\\n\\t\\t\\t# the sum of a gap is equal to the following: note \\n\\t\\t\\t# we use the fact that the sum of n digits 1...N is equal\\n\\t\\t\\t# to n*(n+1)/2 (but with height offset by val):\\n            if gap <= k - cnt and gap > 0:\\n                cnt += gap\\n                totSum += gap*val + gap*(gap+1)/2\\n                    \\n            elif gap > k - cnt:\\n                totSum += (k-cnt)*val + (k-cnt)*(k-cnt+1)/2\\n                cnt = k\\n            \\n            totSum = int(totSum)\\n            \\n            if cnt == k:\\n                return(totSum)",
                "solutionTags": [],
                "code": "\\t\\t# the first trick we use is to add 0 and max(nums) + 3*k to the  \\n\\t\\t# array nums.  this ensures that - by checking gaps between \\n\\t\\t# values in nums - we\\'ll find the lowest k pos indexes. We record\\n\\t\\t# how many values we\\'ve added with the variable cnt.\\n\\t\\tnums2 = [0] + sorted(nums) + [max(nums) + 3*k]\\n        N = len(nums2)\\n        cnt = 0 \\n        totSum = 0\\n        \\n        for ind, val in enumerate(nums2[:(N-1)]):\\n            gap = nums2[ind+1] - nums2[ind] - 1\\n            \\n\\t\\t\\t# the other tricky part is to handle the cases where\\n\\t\\t\\t# remaining k-cnt is less than or greater than the gap.\\n\\t\\t\\t# the sum of a gap is equal to the following: note \\n\\t\\t\\t# we use the fact that the sum of n digits 1...N is equal\\n\\t\\t\\t# to n*(n+1)/2 (but with height offset by val):\\n            if gap <= k - cnt and gap > 0:\\n                cnt += gap\\n                totSum += gap*val + gap*(gap+1)/2\\n                    \\n            elif gap > k - cnt:\\n                totSum += (k-cnt)*val + (k-cnt)*(k-cnt+1)/2\\n                cnt = k\\n            \\n            totSum = int(totSum)\\n            \\n            if cnt == k:\\n                return(totSum)",
                "codeTag": "Unknown"
            },
            {
                "id": 1825525,
                "title": "python-3-arithmatic-progression",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        # remove dupliate nums and sort\\n        nums = sorted(set(nums))\\n        \\n        nums = [0] + nums + [float(\"inf\")]\\n        ans = 0\\n        for i in range(1, len(nums)):\\n            # difference between two adjacent numbers\\n            diff = nums[i] - nums[i-1] - 1\\n            if diff <= 0: continue\\n            # fill in the gap from nums[i-1] + 1 to nums[i] - 1\\n            if diff < k:\\n                k -= diff\\n                ans += (nums[i-1] + 1) * diff + diff * (diff - 1) // 2\\n            # fill the first k nums from nums[i-1] + 1\\n            else:\\n                return ans + (nums[i-1] + 1) * k + k * (k - 1) // 2\\n               \\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        # remove dupliate nums and sort\\n        nums = sorted(set(nums))\\n        \\n        nums = [0] + nums + [float(\"inf\")]\\n        ans = 0\\n        for i in range(1, len(nums)):\\n            # difference between two adjacent numbers\\n            diff = nums[i] - nums[i-1] - 1\\n            if diff <= 0: continue\\n            # fill in the gap from nums[i-1] + 1 to nums[i] - 1\\n            if diff < k:\\n                k -= diff\\n                ans += (nums[i-1] + 1) * diff + diff * (diff - 1) // 2\\n            # fill the first k nums from nums[i-1] + 1\\n            else:\\n                return ans + (nums[i-1] + 1) * k + k * (k - 1) // 2\\n               \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1825373,
                "title": "java-greedy-tc-o-n",
                "content": "```\\n   // Author : Anand\\n    public long minimalKSum(int[] nums, int k) {\\n        int len = nums.length;\\n        Arrays.sort(nums);\\n        long sumK = (long) k * (k + 1) / 2;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] <= k) {\\n                if (i > 0 && nums[i] == nums[i - 1]) {\\n                } else {\\n                    sumK -= nums[i];\\n                    k++;\\n                    sumK += k;\\n                }\\n            } else break;\\n        }\\n        return sumK;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   // Author : Anand\\n    public long minimalKSum(int[] nums, int k) {\\n        int len = nums.length;\\n        Arrays.sort(nums);\\n        long sumK = (long) k * (k + 1) / 2;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] <= k) {\\n                if (i > 0 && nums[i] == nums[i - 1]) {\\n                } else {\\n                    sumK -= nums[i];\\n                    k++;\\n                    sumK += k;\\n                }\\n            } else break;\\n        }\\n        return sumK;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825215,
                "title": "intutive-approach",
                "content": "**OBSERVATION:**\\n* As we have to make the sum of k integers minimum, it will be beneficial to us if we take as small as possible k  elements and at the same time those chosen small k elements should not be present in given array.\\n* For achieving above thing, I can do 3 things very intutively to get safe from TLE\\n\\ni)- I can take elements from 1 to (smallest-1) value present in given array. Let\\'s say their count is x. Now we have to take k-x elements more. How can we take those more elements?\\n\\nii)- Now to take k-x elements, we will take as many possible values I can take between two give elements in array (subject to condition that , difference between those two adjacent digits must be >0). For this step **Your input array must be sorted**\\n\\n  Lets take an exmaple:\\n\\t nums: [5,8,10] k=9  I have to take 9 smallest values which are not present in nums\\n\\t -> By following step 1, I can take elements from 1 to 4 as they will not be present in our array\\n\\t -> Now , we have to get 9-4 i.e 5 more values\\n\\t -> We can now , take 2 values(6,7) wich are present between 5 and 8 (first 2 elements).\\n\\t -> Now we have to take 5-2 i.e 3 more values\\n\\t -> We can take 1 value (9) present between 8 and 10\\n\\t -> Now we have to take 3-1 i.e 2 more value\\n\\t \\n Now as we are not left for any more values in given array , we will take rest 2 smallest values beyond 10(Last element of array), those values are 11 and 12\\niii) So this is only our third step , we can take rest remaining values which are beyond largest value present in array\\n\\n\\n**NOTE : For taking, first few possible smallest values from1 to( minimum_ele-1) , I have inserted 0.\\nFor taking values beyond largest element, I have inserted 10^9 at last position**\\n \\n \\n \\n \\n\\n    static long long findSum(long long L , long long R){\\n\\n        return  (R*(R+1))/2 - (L*(L+1))/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(), nums.end());\\n        nums.insert(nums.begin(),0);\\n        nums.push_back(1e9);\\n        long long sum=0;\\n\\t\\t\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(k==0) break;\\n            long long possible = min(k , nums[i]-nums[i-1]-1);\\n            if(possible > 0){\\n               sum += findSum(nums[i-1] , nums[i-1]+possible);\\n               k-=possible;\\n            }\\n        }\\n       \\n        return sum;\\n        \\n    }\\n};\\n\\t \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**OBSERVATION:**\\n* As we have to make the sum of k integers minimum, it will be beneficial to us if we take as small as possible k  elements and at the same time those chosen small k elements should not be present in given array.\\n* For achieving above thing, I can do 3 things very intutively to get safe from TLE\\n\\ni)- I can take elements from 1 to (smallest-1) value present in given array. Let\\'s say their count is x. Now we have to take k-x elements more. How can we take those more elements?\\n\\nii)- Now to take k-x elements, we will take as many possible values I can take between two give elements in array (subject to condition that , difference between those two adjacent digits must be >0). For this step **Your input array must be sorted**\\n\\n  Lets take an exmaple:\\n\\t nums: [5,8,10] k=9  I have to take 9 smallest values which are not present in nums\\n\\t -> By following step 1, I can take elements from 1 to 4 as they will not be present in our array\\n\\t -> Now , we have to get 9-4 i.e 5 more values\\n\\t -> We can now , take 2 values(6,7) wich are present between 5 and 8 (first 2 elements).\\n\\t -> Now we have to take 5-2 i.e 3 more values\\n\\t -> We can take 1 value (9) present between 8 and 10\\n\\t -> Now we have to take 3-1 i.e 2 more value\\n\\t \\n Now as we are not left for any more values in given array , we will take rest 2 smallest values beyond 10(Last element of array), those values are 11 and 12\\niii) So this is only our third step , we can take rest remaining values which are beyond largest value present in array\\n\\n\\n**NOTE : For taking, first few possible smallest values from1 to( minimum_ele-1) , I have inserted 0.\\nFor taking values beyond largest element, I have inserted 10^9 at last position**\\n \\n \\n \\n \\n\\n    static long long findSum(long long L , long long R){\\n\\n        return  (R*(R+1))/2 - (L*(L+1))/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(), nums.end());\\n        nums.insert(nums.begin(),0);\\n        nums.push_back(1e9);\\n        long long sum=0;\\n\\t\\t\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(k==0) break;\\n            long long possible = min(k , nums[i]-nums[i-1]-1);\\n            if(possible > 0){\\n               sum += findSum(nums[i-1] , nums[i-1]+possible);\\n               k-=possible;\\n            }\\n        }\\n       \\n        return sum;\\n        \\n    }\\n};\\n\\t \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1825115,
                "title": "c-mathematical-solution-sum-of-ap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        // Dry Run on algorithm: \\n        \\n        // nums = [1,4,25,10,25]\\n        \\n        // Firstly, we will sort nums\\n        // nums = [1,4,10,25,25]\\n        \\n        // i = 0 and j = 0 (nums[j]=1)\\n        // Therefore, we have no digits in between \\'i\\' and nums[j]\\n        // so i = nums[j], j+=1 and sum = 0\\n        \\n        // Now, i = 1 and j = 1 (nums[j]=4)\\n        // For i =1 and nums[j]=4 \\n        // we have two digits to insert (2 and 3) \\n        // so sum of 2 and 3\\n        // is sum of Arithmatic progression \\n        // with first term, a= i+1 = 2\\n        // common difference, d = 1\\n        // no. of terms, x= nums[j]-i-1 = 2 \\n        // if k is less than x, we will set x = k (decrement k, k-=x)\\n        // sum+= (x*(2*a+x-1))/2 = 5\\n        \\n        // we will repeat the step until k is not 0\\n\\n        \\n        \\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        long long sum=0;\\n        long long i = 0;\\n        long long j = 0; // index\\n        int n = nums.size();\\n        \\n        // For this question we will use sum of arithmatic progression\\n        // if first no. \\'a\\' and comman diff is \\'d\\'\\n        // and we want sum of \\'n\\' numbers\\n        // sum = n/2(2*a+(n-1)*d)\\n        while(k)\\n        {       \\n            \\n            if(j>=n)\\n                break;\\n            if(i==nums[j]) \\n            {\\n                i=nums[j];\\n                j+=1;\\n            }\\n            \\n            else\\n            {   \\n                // x = no. of digits not in array\\n                // between nums[j] and i\\n                long long x = (nums[j]-i-1); \\n                \\n                // if k is less than x\\n                // we set x = k\\n                if(k<(nums[j]-i-1))\\n                     x=k;\\n                \\n                long a = i+1; // first term \\'a\\'\\n                \\n                sum+=(x*(2*a+x-1))/2; // sum of AP\\n                k-=x; // remove x terms\\n                i = nums[j]; // move to next element available in nums\\n                j+=1; // increment index\\n            }\\n            \\n            \\n        }\\n\\n        // if we have reached end of nums\\n        // and still we need to add sum k\\n        if(k>0)\\n        {\\n            long long x = k; // no. of terms\\n            long a = i+1; // first term\\n            sum+=(x*(2*a+x-1))/2; // sum of AP\\n        }\\n\\n        return sum;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        // Dry Run on algorithm: \\n        \\n        // nums = [1,4,25,10,25]\\n        \\n        // Firstly, we will sort nums\\n        // nums = [1,4,10,25,25]\\n        \\n        // i = 0 and j = 0 (nums[j]=1)\\n        // Therefore, we have no digits in between \\'i\\' and nums[j]\\n        // so i = nums[j], j+=1 and sum = 0\\n        \\n        // Now, i = 1 and j = 1 (nums[j]=4)\\n        // For i =1 and nums[j]=4 \\n        // we have two digits to insert (2 and 3) \\n        // so sum of 2 and 3\\n        // is sum of Arithmatic progression \\n        // with first term, a= i+1 = 2\\n        // common difference, d = 1\\n        // no. of terms, x= nums[j]-i-1 = 2 \\n        // if k is less than x, we will set x = k (decrement k, k-=x)\\n        // sum+= (x*(2*a+x-1))/2 = 5\\n        \\n        // we will repeat the step until k is not 0\\n\\n        \\n        \\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        long long sum=0;\\n        long long i = 0;\\n        long long j = 0; // index\\n        int n = nums.size();\\n        \\n        // For this question we will use sum of arithmatic progression\\n        // if first no. \\'a\\' and comman diff is \\'d\\'\\n        // and we want sum of \\'n\\' numbers\\n        // sum = n/2(2*a+(n-1)*d)\\n        while(k)\\n        {       \\n            \\n            if(j>=n)\\n                break;\\n            if(i==nums[j]) \\n            {\\n                i=nums[j];\\n                j+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1824909,
                "title": "c-n-a-an-2",
                "content": "A implementation based problem. We sort the numbers, and then sum the k smallest numbers that are not present in the array. However, this will cause TLE as k ranges from 1 <= k <= 1e9.\\n\\nWhat we can do is compute the summations from the range, start and end that is not present in the array using the basic arithmetic progression.\\n\\nWe know that the sum of A.P. where start and end is known and the common difference is 1 is computed by n * (start + end) / 2,\\nwhere n is the no. of terms.\\n\\nWe use set for storing the sorted and unique elements.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long ans = 0, start = 1;\\n        \\n        for(auto &ele : set<int>(begin(nums),end(nums))) {\\n            \\n            long long len = ele - start;      // no. of terms\\n            \\n            if(len >= k ) len = k;          // if terms exceed we make it equal to k as we only want k terms\\n                \\n            if(len > 0) {        // we only compute when there exist some terms \\n                ans += ((start + start + len-1 ) * len ) /2;            // start = start \\n                k -= len;                                               // end = start + len - 1 \\n            }\\n\\t\\t\\t\\n            start = ele + 1;             // updating the start \\n            if(k <= 0) break;           // if no terms are left we break from the loop\\n        } \\n       \\n        if(k) {                                  // if there exist some more terms after the loop ends\\n            ans+= ((start + start + k-1) * k ) /2;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long ans = 0, start = 1;\\n        \\n        for(auto &ele : set<int>(begin(nums),end(nums))) {\\n            \\n            long long len = ele - start;      // no. of terms\\n            \\n            if(len >= k ) len = k;          // if terms exceed we make it equal to k as we only want k terms\\n                \\n            if(len > 0) {        // we only compute when there exist some terms \\n                ans += ((start + start + len-1 ) * len ) /2;            // start = start \\n                k -= len;                                               // end = start + len - 1 \\n            }\\n\\t\\t\\t\\n            start = ele + 1;             // updating the start \\n            if(k <= 0) break;           // if no terms are left we break from the loop\\n        } \\n       \\n        if(k) {                                  // if there exist some more terms after the loop ends\\n            ans+= ((start + start + k-1) * k ) /2;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824884,
                "title": "java-c-simple-logic-based-code-with-explaination",
                "content": "Time Complexity :- O(n*log(n))\\n\\nJAVA Code :-\\n\\n\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, long k) {\\n        Arrays.sort(nums);  // sort the array\\n        Set<Integer> set = new HashSet<>(); // used to keep track of repeating number\\n        long ans = k*(k+1)/2;   // we assume our answer is sum of  1,2,3,4,5......(k-1),k.\\n        for(int num : nums) {\\n            if(num<=k) {    // if we added \"num\" in our answer then , we subtract and add next (k+1) value in answer\\n                if(set.contains(num)) continue; // if we found num previously then continue\\n                set.add(num);\\n                ans-=num;\\n                k++;\\n                ans+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nC++ Code :-\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long k) {\\n        sort(nums.begin(),nums.end());  // sort the array\\n        set<int> st; // used to keep track of repeating number\\n        long ans = k*(k+1)/2;   // we assume our answer is sum of  1,2,3,4,5......(k-1),k.\\n        for(int num : nums) {\\n            if(num<=k) {    // if we added \"num\" in our answer then , we subtract and add next (k+1) value in answer\\n                if(st.find(num)!=st.end()) continue; // if we found num previously then continue\\n                st.insert(num);\\n                ans-=num;\\n                k++;\\n                ans+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, long k) {\\n        Arrays.sort(nums);  // sort the array\\n        Set<Integer> set = new HashSet<>(); // used to keep track of repeating number\\n        long ans = k*(k+1)/2;   // we assume our answer is sum of  1,2,3,4,5......(k-1),k.\\n        for(int num : nums) {\\n            if(num<=k) {    // if we added \"num\" in our answer then , we subtract and add next (k+1) value in answer\\n                if(set.contains(num)) continue; // if we found num previously then continue\\n                set.add(num);\\n                ans-=num;\\n                k++;\\n                ans+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long k) {\\n        sort(nums.begin(),nums.end());  // sort the array\\n        set<int> st; // used to keep track of repeating number\\n        long ans = k*(k+1)/2;   // we assume our answer is sum of  1,2,3,4,5......(k-1),k.\\n        for(int num : nums) {\\n            if(num<=k) {    // if we added \"num\" in our answer then , we subtract and add next (k+1) value in answer\\n                if(st.find(num)!=st.end()) continue; // if we found num previously then continue\\n                st.insert(num);\\n                ans-=num;\\n                k++;\\n                ans+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824855,
                "title": "c-solution",
                "content": "Edge cases- \\nNumbers can repeat in nums.So, make sure to subtract numbers from nums only once and skip all occurrences of a number if you skip any number.\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long sum=k*(long long)(k+1)/2,i=0,x=k+1,cnt=0,pre=0;\\n        sort(nums.begin(),nums.end());\\n        set<long long> st;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>k)\\n                break;\\n            pre=st.size();\\n            st.insert(nums[i]);\\n            if((long long)st.size()==pre+1)\\n            {\\n                cnt++;\\n                sum-=nums[i];\\n            }\\n        }\\n        while(cnt>0)\\n        {\\n            if(i>=nums.size() || nums[i]!=x)\\n            {\\n                cnt--;\\n                sum+=x;\\n            }\\n            else{\\n                while(i<nums.size() && nums[i]==x)\\n                    i++;            \\n            }\\n                x++;\\n            \\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long sum=k*(long long)(k+1)/2,i=0,x=k+1,cnt=0,pre=0;\\n        sort(nums.begin(),nums.end());\\n        set<long long> st;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>k)\\n                break;\\n            pre=st.size();\\n            st.insert(nums[i]);\\n            if((long long)st.size()==pre+1)\\n            {\\n                cnt++;\\n                sum-=nums[i];\\n            }\\n        }\\n        while(cnt>0)\\n        {\\n            if(i>=nums.size() || nums[i]!=x)\\n            {\\n                cnt--;\\n                sum+=x;\\n            }\\n            else{\\n                while(i<nums.size() && nums[i]==x)\\n                    i++;            \\n            }\\n                x++;\\n            \\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824602,
                "title": "simple-solution-in-java-by-sorting",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // Find the first k unique numbers sum\\n        long ans = 0;\\n        int i = 0;\\n        long prev = 0;\\n        while(i < nums.length){\\n            if(k == 0) break;\\n            if(i >= 1 && nums[i] == nums[i-1]){\\n                i++;\\n                continue;\\n            }\\n            \\n            long numAval = nums[i] - prev - 1;\\n            long reqNum = Math.min(numAval, k);\\n            \\n            // Find the sum of the required numbers\\n            long a = prev + reqNum;\\n            ans += (a)*(a+1)/2 - (prev)*(prev+1)/2;\\n            \\n            prev = nums[i];\\n            k -= reqNum;\\n            // System.out.println(i + \" \" + nums[i] + \" \" + ans + \" \" +k);\\n            ++i;\\n        }\\n        if(k != 0){\\n            long a = prev + k;\\n            ans += (a)*(a+1)/2 - (prev)*(prev+1)/2;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // Find the first k unique numbers sum\\n        long ans = 0;\\n        int i = 0;\\n        long prev = 0;\\n        while(i < nums.length){\\n            if(k == 0) break;\\n            if(i >= 1 && nums[i] == nums[i-1]){\\n                i++;\\n                continue;\\n            }\\n            \\n            long numAval = nums[i] - prev - 1;\\n            long reqNum = Math.min(numAval, k);\\n            \\n            // Find the sum of the required numbers\\n            long a = prev + reqNum;\\n            ans += (a)*(a+1)/2 - (prev)*(prev+1)/2;\\n            \\n            prev = nums[i];\\n            k -= reqNum;\\n            // System.out.println(i + \" \" + nums[i] + \" \" + ans + \" \" +k);\\n            ++i;\\n        }\\n        if(k != 0){\\n            long a = prev + k;\\n            ans += (a)*(a+1)/2 - (prev)*(prev+1)/2;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824410,
                "title": "c-short-solution-with-explanation",
                "content": "- Initialise ```ans``` with sum of first ```k``` natural numbers\\n- Use set to use unique numbers from nums\\n- If a number was added that already existed in ```nums```, remove that and add next number ```k+1```\\n- Increment ```k```\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long ans = (long(k)*(long(k+1)))/2;        \\n        set<int>st(nums.begin(),nums.end());\\n        for(auto i:st){            \\n            if(i<=k)    ans += (1+ k++) - i;\\n            else    break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```ans```\n```k```\n```nums```\n```k+1```\n```k```\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long ans = (long(k)*(long(k+1)))/2;        \\n        set<int>st(nums.begin(),nums.end());\\n        for(auto i:st){            \\n            if(i<=k)    ans += (1+ k++) - i;\\n            else    break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824203,
                "title": "easy-to-understand-c-o-nlogn-solution",
                "content": "There are three steps involved to solve this question\\nStep-1: At first intialize the sum as k*(k+1)/2\\nStep-2: Now traverse through the array and if you find any element which has previously been included in the sum, substract it and add the next new number.\\nStep-3: Inorder to keep track of the numbers already included, I kept a variable (e)\\nAt first e is intialized to k which means at first it will check whether the element in nums array is less than k then remove it from sum and add e+1 to sum. Now after doing this increament e and repeat step-2 and step-3\\n\\nBelow in the code the purpose of first if statement is to skip the duplicate elements in the array\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n       sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            cout<<nums[i]<<\" \";\\n        long long K=k;\\n        long long count=0,e=K,sum=K*(K+1)/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n                continue;\\n            if(nums[i]<=e)\\n            {\\n                sum+=(e+1-nums[i]);\\n                e++;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\nTime complexity: O(nlogn)\\n1) For sorting->O(nlogn)\\n2) For traversing array one time->O(n)\\n\\nSpace complexity: O(1)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n       sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            cout<<nums[i]<<\" \";\\n        long long K=k;\\n        long long count=0,e=K,sum=K*(K+1)/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n                continue;\\n            if(nums[i]<=e)\\n            {\\n                sum+=(e+1-nums[i]);\\n                e++;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1824137,
                "title": "c-sorting-implementation-clean-and-concise",
                "content": "**Runtime: 155 ms, faster than 90.00% of C++ online submissions\\nMemory Usage: 65.6 MB, less than 50.00% of C++ online submissions**\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    long long sumOfNaturalNumbers(long long n)\\n    {\\n        return (n*(n+1))/2;\\n    }\\n    long long rangeSum(long long l,long long r)\\n    {\\n        if(l==r)\\n            return l;\\n        if(l>r)\\n            return 0ll;\\n        \\n        return sumOfNaturalNumbers(r)-sumOfNaturalNumbers(l-1);\\n    }\\npublic:\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int taken=0;\\n        int canTake=0;\\n        long long sum=0;\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(taken==k)\\n                break;\\n            if(i==0)\\n            {\\n               canTake=nums[i]-1;\\n               if(taken+canTake<=k)\\n               {\\n                  \\n                   sum+=(rangeSum(1,nums[i]-1));\\n                   taken+=canTake;\\n               }\\n               else\\n               {\\n                   \\n                   sum+=(rangeSum(1,k));\\n                   taken=k;\\n                   break;\\n               }\\n            }\\n            else\\n            {\\n                if(nums[i]==nums[i-1] or nums[i]==nums[i-1]+1)\\n                    continue;\\n                canTake=nums[i]-nums[i-1]-1;\\n                if(taken+canTake<=k)\\n                {\\n                   taken+=canTake;\\n                   sum+=(rangeSum(nums[i-1]+1,nums[i]-1));\\n                }\\n                else\\n                {\\n                  \\n                   sum+=(rangeSum(nums[i-1]+1,nums[i-1]+k-taken));\\n                   taken=k;\\n                   break;\\n                }\\n            }\\n           // cout<<i<<\" \"<<sum<<\" \"<<taken<<endl;\\n        }\\n        if(taken<k)\\n        {\\n            sum+=(rangeSum(nums[n-1]+1,nums[n-1]+k-taken));\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long sumOfNaturalNumbers(long long n)\\n    {\\n        return (n*(n+1))/2;\\n    }\\n    long long rangeSum(long long l,long long r)\\n    {\\n        if(l==r)\\n            return l;\\n        if(l>r)\\n            return 0ll;\\n        \\n        return sumOfNaturalNumbers(r)-sumOfNaturalNumbers(l-1);\\n    }\\npublic:\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int taken=0;\\n        int canTake=0;\\n        long long sum=0;\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(taken==k)\\n                break;\\n            if(i==0)\\n            {\\n               canTake=nums[i]-1;\\n               if(taken+canTake<=k)\\n               {\\n                  \\n                   sum+=(rangeSum(1,nums[i]-1));\\n                   taken+=canTake;\\n               }\\n               else\\n               {\\n                   \\n                   sum+=(rangeSum(1,k));\\n                   taken=k;\\n                   break;\\n               }\\n            }\\n            else\\n            {\\n                if(nums[i]==nums[i-1] or nums[i]==nums[i-1]+1)\\n                    continue;\\n                canTake=nums[i]-nums[i-1]-1;\\n                if(taken+canTake<=k)\\n                {\\n                   taken+=canTake;\\n                   sum+=(rangeSum(nums[i-1]+1,nums[i]-1));\\n                }\\n                else\\n                {\\n                  \\n                   sum+=(rangeSum(nums[i-1]+1,nums[i-1]+k-taken));\\n                   taken=k;\\n                   break;\\n                }\\n            }\\n           // cout<<i<<\" \"<<sum<<\" \"<<taken<<endl;\\n        }\\n        if(taken<k)\\n        {\\n            sum+=(rangeSum(nums[n-1]+1,nums[n-1]+k-taken));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1824079,
                "title": "python-sum-all-nums-between-a-b-using-n-n-1-2",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        def sum_between(a, b):\\n            # inclusive sum all nums between a, b\\n\\t\\t\\t# eg: 40,  41,  42,  43,  44\\n\\t\\t\\t#  =  40 + 40 + 40 + 40 + 40\\n\\t\\t\\t#          +1   +2   +3   +4\\n\\t\\t\\t#  = 40 * 5 + sum of 1 to 4\\n\\t\\t\\t# formula for sum of 1 to n: (n * (n + 1))//2\\n\\t\\t\\t\\t\\t\\t  \\n            if b < a: return 0\\n            dist = b - a + 1\\n            n = dist - 1\\n            return a * dist + (n * (n + 1))//2\\n            \\n        nums.append(0)\\n        nums.sort()\\n        res = 0\\n\\t\\t# sum between all the gaps in the list\\n        for i in range(1, len(nums)):\\n            last = nums[i-1] + 1\\n            cur = min(last + k - 1, nums[i] - 1)\\n            if last > cur: continue\\n            res += sum_between(last, cur)\\n            k -= cur-last+1\\n            if k == 0:\\n                return res\\n            \\n        # add additional\\n        res += sum_between(nums[-1] + 1, nums[-1] + k)\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        def sum_between(a, b):\\n            # inclusive sum all nums between a, b\\n\\t\\t\\t# eg: 40,  41,  42,  43,  44\\n\\t\\t\\t#  =  40 + 40 + 40 + 40 + 40\\n\\t\\t\\t#          +1   +2   +3   +4\\n\\t\\t\\t#  = 40 * 5 + sum of 1 to 4\\n\\t\\t\\t# formula for sum of 1 to n: (n * (n + 1))//2\\n\\t\\t\\t\\t\\t\\t  \\n            if b < a: return 0\\n            dist = b - a + 1\\n            n = dist - 1\\n            return a * dist + (n * (n + 1))//2\\n            \\n        nums.append(0)\\n        nums.sort()\\n        res = 0\\n\\t\\t# sum between all the gaps in the list\\n        for i in range(1, len(nums)):\\n            last = nums[i-1] + 1\\n            cur = min(last + k - 1, nums[i] - 1)\\n            if last > cur: continue\\n            res += sum_between(last, cur)\\n            k -= cur-last+1\\n            if k == 0:\\n                return res\\n            \\n        # add additional\\n        res += sum_between(nums[-1] + 1, nums[-1] + k)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824039,
                "title": "java-sorting-with-clear-explanation",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n        /*\\n            sort the array and insert k numbers between two adjacent numbers so that\\n            inserted numbers are minimum and the sum of minimum numbers will be always minimum\\n            also update k by total numbers inserted.\\n            \\n            How to calculate the sum of inserted numbers?\\n            Do i need to traverse? Nooooooo....\\n            \\n            since we are inserting unique numbers between two numbers it will be in the form of A.P.\\n            with common difference 1.\\n            \\n            Example let the sorted array be [3,7,15,19,32] and k=11\\n            so be will insert numbers in this way\\n            -> before 3 insert [1,2] sum=3;\\n            -> between 7 and 15 insert [8,9,10,11,12,13,14] sum=77\\n            -> between 15 and 19 insert [16,17]  sum=33 now k will become 0 so stop here.\\n            \\n            And that\\'s all you total sum=3+77+33 is your final answer return it.\\n        */\\n        Arrays.sort(nums);\\n        long sum=0l,prev=0l,k=K*1l;\\n        for(int i=0;i<nums.length && k>0;i++){\\n            long val1=prev+1,val2=nums[i]-1;\\n            if(val1<=val2){\\n                long n=Math.min(k,val2-val1+1);\\n                sum+=(n*(2*val1+n-1))/2;\\n                k-=Math.min(k,val2-val1+1);\\n            }\\n            prev=nums[i];\\n        }\\n        if(k>0){\\n            sum+=(k*(2*(prev+1)+k-1))/2;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n        /*\\n            sort the array and insert k numbers between two adjacent numbers so that\\n            inserted numbers are minimum and the sum of minimum numbers will be always minimum\\n            also update k by total numbers inserted.\\n            \\n            How to calculate the sum of inserted numbers?\\n            Do i need to traverse? Nooooooo....\\n            \\n            since we are inserting unique numbers between two numbers it will be in the form of A.P.\\n            with common difference 1.\\n            \\n            Example let the sorted array be [3,7,15,19,32] and k=11\\n            so be will insert numbers in this way\\n            -> before 3 insert [1,2] sum=3;\\n            -> between 7 and 15 insert [8,9,10,11,12,13,14] sum=77\\n            -> between 15 and 19 insert [16,17]  sum=33 now k will become 0 so stop here.\\n            \\n            And that\\'s all you total sum=3+77+33 is your final answer return it.\\n        */\\n        Arrays.sort(nums);\\n        long sum=0l,prev=0l,k=K*1l;\\n        for(int i=0;i<nums.length && k>0;i++){\\n            long val1=prev+1,val2=nums[i]-1;\\n            if(val1<=val2){\\n                long n=Math.min(k,val2-val1+1);\\n                sum+=(n*(2*val1+n-1))/2;\\n                k-=Math.min(k,val2-val1+1);\\n            }\\n            prev=nums[i];\\n        }\\n        if(k>0){\\n            sum+=(k*(2*(prev+1)+k-1))/2;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824016,
                "title": "easy-c-without-sorting",
                "content": "APPROCAH-1 TLE\\n1)simply mark everyone occurs in nums array as 1\\n2)take temp value as 1, and check for each next natural number in map,\\ntake c as 0\\n3)run a loop till c becmoes k, \\nif it is in map, do nothing \\nif it is not in map, add in sum variable\\n3) and whenever we encounter someone who is not in map , increase c till k\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n       map<int,int> m;\\n        \\n        for(auto &x :nums){\\n            m[x]=1;\\n        }\\n        \\n        \\n        long long sum=0;\\n        \\n        int c=0;\\n        long long temp=1;\\n        while(c<k){\\n            \\n            \\n            \\n            if(m[temp]==0){\\n                sum+=temp;\\n                c++;\\n            }\\n           \\n            temp++;\\n            \\n        }\\n        return sum;\\n        \\n    }\\n};\\n\\napproach -2 ACCEPTED\\nThink more how can we make more optimal\\nfor eg->\\n\\nnums=[5,8],  k=2\\nin approcah we are running 5 iteration till we get first one who is in map, sum=1 + 2+ 3+ 4\\nand then again 3 more iteration to reach 8, sum=1+2+3+4+6+7\\n\\n\\nsum of AP is (a+l)*n /2 , where a is first term , l is last term , n is length of AP\\n\\nso, sum can be find .\\nconsider [5,8]\\na is previous map number + 1    // a is 6\\nl is curr map number - 1          // l is 7\\nand n is difference between these these two (8-5-1) = 2\\nsum = ((curr map number -1 + previous map number +1 ) * ( curr map - prev map -1 ) ) / 2\\nso, sum =(8-1 + 5+1 )*(8-5-1) /2 is 13 which is 7+6\\n\\nyes that\\'s approach i used\\n\\nI am commenting to in code to clear\\n\\n\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int take) {\\n        \\n       map<long long,long long> m;\\n        \\n\\t\\t// making everyone visited\\n        for(auto &x :nums){\\n            m[x]=1;\\n        }\\n        \\n        long long int k=take;\\n        long long sum=0;\\n        \\n        int c=0;\\n        long long temp=1;\\n        \\n        auto it=m.begin();\\n        long long l=it->first;\\n        \\n\\t\\t// if first element in map is greater than k\\n\\t\\t// ofcourse we just need sum of firsk k natural number that\\'s it\\n\\t\\t\\n\\t\\t// if first element in map is smaller or equal to k\\n\\t\\t// we will add first ( l-1 ) natural number sum, here l is first elemt in map\\n\\t\\t// k is now required (k -(l-1)) \\n\\t\\t\\n        if(l>k){\\n            \\n            \\n            sum+= (k*(k+1))/2;\\n        \\n            return sum;\\n            \\n            \\n        }else{\\n            \\n            \\n            sum+= ( (l)*(l-1))/2;\\n            k=k-(l-1);\\n           \\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t// whatever i done above i am doing for all element of map\\n        \\n     \\n        it++;\\n        \\n        for(;it!=m.end();it++){\\n            \\n            temp=it->first;\\n            \\n          // check length of AP is greter than k, but we need only k then we add till prev+1 to next k element\\n            if(temp-l-1 > k ){\\n                \\n                long long s=l+1;\\n                sum+= ((s+l+k)*(k) )/2;     \\n                \\n              \\n                return sum;\\n                \\n            }else{\\n                \\n             \\n                sum+=(   ((temp-l-1)*(l + temp))/2  );\\n                \\n                k=k-(temp-l-1);\\n               \\n            }\\n            \\n\\t\\t\\t\\n\\t\\t\\t// making l(previous) as curr map number for next iteration \\n            l=temp;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// whenever found k is 0 , just return sum\\n               if(k==0){\\n                  \\n                   return sum;\\n               }\\n            \\n            \\n        }\\n\\t\\t\\n\\t\\t// if by whole iteration we are unable to meet k number , we have to add next k element in last element of map\\n        \\n        if(k){\\n            \\n            sum+= ((l+1+ l+k )*(k ) )/2;\\n            \\n            \\n        }\\n        \\n        \\n       \\n        \\n        return sum;\\n        \\n    }\\n};\\n```\\n```\\n\\nI HOPE YOU UNDERSTOOD \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n       map<int,int> m;\\n        \\n        for(auto &x :nums){\\n            m[x]=1;\\n        }\\n        \\n        \\n        long long sum=0;\\n        \\n        int c=0;\\n        long long temp=1;\\n        while(c<k){\\n            \\n            \\n            \\n            if(m[temp]==0){\\n                sum+=temp;\\n                c++;\\n            }\\n           \\n            temp++;\\n            \\n        }\\n        return sum;\\n        \\n    }\\n};\\n\\napproach -2 ACCEPTED\\nThink more how can we make more optimal\\nfor eg->\\n\\nnums=[5,8],  k=2\\nin approcah we are running 5 iteration till we get first one who is in map, sum=1 + 2+ 3+ 4\\nand then again 3 more iteration to reach 8, sum=1+2+3+4+6+7\\n\\n\\nsum of AP is (a+l)*n /2 , where a is first term , l is last term , n is length of AP\\n\\nso, sum can be find .\\nconsider [5,8]\\na is previous map number + 1    // a is 6\\nl is curr map number - 1          // l is 7\\nand n is difference between these these two (8-5-1) = 2\\nsum = ((curr map number -1 + previous map number +1 ) * ( curr map - prev map -1 ) ) / 2\\nso, sum =(8-1 + 5+1 )*(8-5-1) /2 is 13 which is 7+6\\n\\nyes that\\'s approach i used\\n\\nI am commenting to in code to clear\\n\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int take) {\\n        \\n       map<long long,long long> m;\\n        \\n\\t\\t// making everyone visited\\n        for(auto &x :nums){\\n            m[x]=1;\\n        }\\n        \\n        long long int k=take;\\n        long long sum=0;\\n        \\n        int c=0;\\n        long long temp=1;\\n        \\n        auto it=m.begin();\\n        long long l=it->first;\\n        \\n\\t\\t// if first element in map is greater than k\\n\\t\\t// ofcourse we just need sum of firsk k natural number that\\'s it\\n\\t\\t\\n\\t\\t// if first element in map is smaller or equal to k\\n\\t\\t// we will add first ( l-1 ) natural number sum, here l is first elemt in map\\n\\t\\t// k is now required (k -(l-1)) \\n\\t\\t\\n        if(l>k){\\n            \\n            \\n            sum+= (k*(k+1))/2;\\n        \\n            return sum;\\n            \\n            \\n        }else{\\n            \\n            \\n            sum+= ( (l)*(l-1))/2;\\n            k=k-(l-1);\\n           \\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t// whatever i done above i am doing for all element of map\\n        \\n     \\n        it++;\\n        \\n        for(;it!=m.end();it++){\\n            \\n            temp=it->first;\\n            \\n          // check length of AP is greter than k, but we need only k then we add till prev+1 to next k element\\n            if(temp-l-1 > k ){\\n                \\n                long long s=l+1;\\n                sum+= ((s+l+k)*(k) )/2;     \\n                \\n              \\n                return sum;\\n                \\n            }else{\\n                \\n             \\n                sum+=(   ((temp-l-1)*(l + temp))/2  );\\n                \\n                k=k-(temp-l-1);\\n               \\n            }\\n            \\n\\t\\t\\t\\n\\t\\t\\t// making l(previous) as curr map number for next iteration \\n            l=temp;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// whenever found k is 0 , just return sum\\n               if(k==0){\\n                  \\n                   return sum;\\n               }\\n            \\n            \\n        }\\n\\t\\t\\n\\t\\t// if by whole iteration we are unable to meet k number , we have to add next k element in last element of map\\n        \\n        if(k){\\n            \\n            sum+= ((l+1+ l+k )*(k ) )/2;\\n            \\n            \\n        }\\n        \\n        \\n       \\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824011,
                "title": "c-use-gap-between-numbers",
                "content": "Either sort the elements or store it in map. Use the gaps between adjacent numbers and add it\\'s **sum** (sum of no.s b/w the gap) to result. **Sum** can be obtainted by difference of sum of natural numbers.\\n\\nupvote if it helps\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        long long re = 0;\\n        for(int i = 0; i<nums.size();++i) mp[nums[i]]++;\\n        long long l = 1;\\n        long long t;\\n        for(auto &q:mp){\\n            t = q.first;\\n            if(k>=t-l){\\n                re+= (long long)t*(t-1)/2 - l*(l-1)/2;\\n                k-=t-l;\\n            }\\n            else{\\n                long long p = l+k;\\n                re+= (long long)p*(p-1)/2 - l*(l-1)/2;\\n                k=0;\\n            }\\n            if(k==0) break;\\n            l=t+1;\\n        }\\n        if(k){\\n            long long p = l+k;\\n            re+= (long long)p*(p-1)/2 - l*(l-1)/2;\\n            k=0;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        long long re = 0;\\n        for(int i = 0; i<nums.size();++i) mp[nums[i]]++;\\n        long long l = 1;\\n        long long t;\\n        for(auto &q:mp){\\n            t = q.first;\\n            if(k>=t-l){\\n                re+= (long long)t*(t-1)/2 - l*(l-1)/2;\\n                k-=t-l;\\n            }\\n            else{\\n                long long p = l+k;\\n                re+= (long long)p*(p-1)/2 - l*(l-1)/2;\\n                k=0;\\n            }\\n            if(k==0) break;\\n            l=t+1;\\n        }\\n        if(k){\\n            long long p = l+k;\\n            re+= (long long)p*(p-1)/2 - l*(l-1)/2;\\n            k=0;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824008,
                "title": "java-easy-solution-sort-o-n-ap-using-gap-between-2-numbers",
                "content": "1. This is similar to finding the k missing minimum positives in the given array.\\n2. Instead of adding all the required numbers one by one we can add all the numbers in a range using AP.\\n3. To simplify the process first we will be sorting the numbers in increasing order.\\n4. Iterate over all the elements in array and check how many numbers are missing between 2 elements and add all of them (or remaining k numbers) to the sum.\\nExample: nums = [1, 4, 10, 25, 25], k = 5\\nThere are 2 numbers missing between 1 and 4 so we will be adding 5 (2 + 3) to the sum. next there are 5 numbers missing from the array so we will be adding only 3 numbers (5, 6, and 7) as only 3 numbers are required after adding (2 and 3) previously.\\n5. Once we have found k missing minimum positivies, we can break from the loop and return the sum.\\n\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        long sum = 0;\\n        long a = 1;\\n        \\n        for (int num : nums) {\\n            if (num > a) {\\n                long l = Math.min(num - 1, a + k - 1);\\n                long n = l - a + 1;\\n                // AP formula for sum => n (a + l) / 2\\n                sum += n * (a + l) / 2;\\n                k -= n;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (k == 0) {\\n                    break;\\n                }\\n            }\\n            a = num + 1;\\n        }\\n        \\n        if (k > 0) {\\n            // AP formula for sum => n (2 * a + (n - 1) * d) / 2, here d is 1 and n is k\\n            sum += k * ((a << 1) + k - 1) / 2;  \\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        long sum = 0;\\n        long a = 1;\\n        \\n        for (int num : nums) {\\n            if (num > a) {\\n                long l = Math.min(num - 1, a + k - 1);\\n                long n = l - a + 1;\\n                // AP formula for sum => n (a + l) / 2\\n                sum += n * (a + l) / 2;\\n                k -= n;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (k == 0) {\\n                    break;\\n                }\\n            }\\n            a = num + 1;\\n        }\\n        \\n        if (k > 0) {\\n            // AP formula for sum => n (2 * a + (n - 1) * d) / 2, here d is 1 and n is k\\n            sum += k * ((a << 1) + k - 1) / 2;  \\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823986,
                "title": "n-2-first-element-in-the-range-last-element-in-the-range-with-priority-queue",
                "content": "instead of n*(n+1)/2 , i used n/2*(first element in the range + last element in the range) which gives the sum of all the elements in the range . And instead of sorting i used priority queue . here is my code\\n\\nhere n is the numer of numbers within the range\\n\\n   ```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    priority_queue<int,vector<int>,greater<int>> pq(nums.begin(),nums.end());\\n    long long prev=1,res=0;\\n    while(!pq.empty() && k>0)\\n    {\\n        long long curr=pq.top();pq.pop();\\n        if(prev<curr)\\n        {\\n            if(curr-prev<=k)\\n            { \\n                res+=((curr-prev)*(prev+curr-1))/2;  // curr-prev gives the number of numbers in the range and prev is the 1st number curr-1 is the last number in the range\\n                k-=curr-prev;\\n            }\\n            else break;\\n        }\\n        prev=curr+1;\\n    }\\n    res+=((k)*(prev+prev+k-1))/2;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    priority_queue<int,vector<int>,greater<int>> pq(nums.begin(),nums.end());\\n    long long prev=1,res=0;\\n    while(!pq.empty() && k>0)\\n    {\\n        long long curr=pq.top();pq.pop();\\n        if(prev<curr)\\n        {\\n            if(curr-prev<=k)\\n            { \\n                res+=((curr-prev)*(prev+curr-1))/2;  // curr-prev gives the number of numbers in the range and prev is the 1st number curr-1 is the last number in the range\\n                k-=curr-prev;\\n            }\\n            else break;\\n        }\\n        prev=curr+1;\\n    }\\n    res+=((k)*(prev+prev+k-1))/2;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823982,
                "title": "easy-to-understand-c-solution",
                "content": "**Approach** :  Since we need to add exactly k numbers and total sum after adding them has be minimum , we can add smallest first  k numbers to the array i.e 1 to k .\\nwe keep ans as sum of numbers from 1 to k.\\nBut there might some numbers in the array from 1 to k .\\nHere come\\'s the main part : \\nfirst we remove all duplicates in the array using set and keep the array sorted after removing duplicates.\\nThen we iterate through the array whenever we encounter a value in array which is present in our range of numbers we are adding , we have to subtract that number from the ans , and add the next big number .\\nex : say we want  to add 1 to 7 numbers to array but we already have 4 in array , the we remove 4 from ans and since we have add another new number which is smallest and unique we add 8.\\nthis way  we iterate through array until no value in array is in our range\\n\\n   ```\\n   long long minimalKSum(vector<int>& v, int k) {\\n        long long ans = 0;\\n        set<int> s;\\n        for(auto x : v) s.insert(x);\\n        v = vector<int>();\\n        for(auto x : s) v.push_back(x);\\n        long long end = k;\\n        int n = v.size();\\n        ans += (end * (end + 1)) / 2LL;\\n        sort(v.begin(),v.end());\\n        for(int i = 0;i < n; i++){\\n            if(end >= v[i]){\\n                ans -= v[i];\\n                end++;\\n                ans += end;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n   long long minimalKSum(vector<int>& v, int k) {\\n        long long ans = 0;\\n        set<int> s;\\n        for(auto x : v) s.insert(x);\\n        v = vector<int>();\\n        for(auto x : s) v.push_back(x);\\n        long long end = k;\\n        int n = v.size();\\n        ans += (end * (end + 1)) / 2LL;\\n        sort(v.begin(),v.end());\\n        for(int i = 0;i < n; i++){\\n            if(end >= v[i]){\\n                ans -= v[i];\\n                end++;\\n                ans += end;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823915,
                "title": "java-easy-solution",
                "content": "\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set < Integer > set = new HashSet < > ();\\n        long sum = 0;\\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;\\n            }\\n            set.add(num);\\n        }\\n\\n        long ans = (long)(1 + k) * k / 2 - sum;\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set < Integer > set = new HashSet < > ();\\n        long sum = 0;\\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;\\n            }\\n            set.add(num);\\n        }\\n\\n        long ans = (long)(1 + k) * k / 2 - sum;\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1823896,
                "title": "c-sorting-o-nlogn-time",
                "content": "```\\nclass Solution {\\npublic:\\n    long long give(long long n){\\n        long long ans=n*(n+1)/2;\\n        return ans;\\n    }\\n    long long minimalKSum(vector<int>& v, int k) {\\n        int n=v.size();\\n        v.push_back(0);\\n        sort(v.begin(),v.end());\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n          int dif=v[i+1]-v[i];\\n           \\n            if(k==0)break;\\n            if(dif<=1)continue;\\n            dif--;\\n            long long take=min(k,dif);\\n            sum+=(give(v[i]+take)-give(v[i]));\\n            k-=take;\\n        }\\n\\n        if(k!=0)sum+=(give(v[n]+k)-give(v[n]));\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long give(long long n){\\n        long long ans=n*(n+1)/2;\\n        return ans;\\n    }\\n    long long minimalKSum(vector<int>& v, int k) {\\n        int n=v.size();\\n        v.push_back(0);\\n        sort(v.begin(),v.end());\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n          int dif=v[i+1]-v[i];\\n           \\n            if(k==0)break;\\n            if(dif<=1)continue;\\n            dif--;\\n            long long take=min(k,dif);\\n            sum+=(give(v[i]+take)-give(v[i]));\\n            k-=take;\\n        }\\n\\n        if(k!=0)sum+=(give(v[n]+k)-give(v[n]));\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823893,
                "title": "c-sorting",
                "content": "~~~\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k1) {\\n      sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        if(k1==0)\\n            return ans;\\n       long long k=k1; \\n      for(int i=0;i<nums.size();i++)\\n      {\\n          if(i==0)\\n          {\\n              if(nums[i]!=1)\\n              {\\n                  if(nums[i]-1>=k)\\n                  {\\n                      ans+=(k*(k+1)/2);\\n                      k=0;\\n                      break;\\n                  }\\n                  else{\\n                      long long  sum=(nums[i]-1);\\n                      k-=(nums[i]-1);\\n                      ans+=(sum*(sum+1))/2;\\n                  }\\n              }\\n          }\\n          else{ \\n             if(nums[i]-nums[i-1]<=1)\\n                 continue;\\n             long long  first=nums[i-1];\\n             long long second=nums[i]-1;\\n             \\n              cout << second-first << endl;\\n             if(second-first>=k)\\n             {\\n                 second=first+k;\\n                 k=0;\\n             }\\n             else{\\n                 k-=(second-first);\\n             } \\n             long long sum1=first*(first+1)/2;\\n             long long sum2=second*(second+1)/2;\\n             ans+=(sum2-sum1);  \\n          }\\n          if(k==0)\\n              break;\\n      }\\n        if(k!=0)\\n        {\\n            long long first=nums[nums.size()-1];\\n            long long second=first+k;\\n            long long sum1=first*(first+1)/2;\\n             long long sum2=second*(second+1)/2;\\n             ans+=(sum2-sum1);\\n    \\n            \\n        }\\n        return ans;\\n    }\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k1) {\\n      sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        if(k1==0)\\n            return ans;\\n       long long k=k1; \\n      for(int i=0;i<nums.size();i++)\\n      {\\n          if(i==0)\\n          {\\n              if(nums[i]!=1)\\n              {\\n                  if(nums[i]-1>=k)\\n                  {\\n                      ans+=(k*(k+1)/2);\\n                      k=0;\\n                      break;\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 1823825,
                "title": "python3-sorting-one-pass-greedy-11-line-solution-explained",
                "content": "Idea:\\nPick numbers starting from 1 in order to get the minimum additional sum. Start with an initial sum `full_series = 1 + 2 + ... + k`, assuming we get to pick the first `k` numbers. However, we may actually encounter a `numbers[j], such that  numbers[j] = [1, k]`, so instead of picking `numbers[j]` in our `full_series`, we have to skip it and pick `numbers[j] + 1` instead, and shifting following numbers we pick by 1 as well.\\n\\nHow to achieve:\\nIterate through `nums` and if we meet a number `<= k`, we skip that number for adding, leaving the rest of the additional numbers (to be added) needed to be incremented by 1 (thus `k - n + 1`).\\n\\nTime Complexity: O(nlgn)\\nSpace Complexity: O(n)\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(set(nums))\\n        full_series = k * (k + 1) // 2\\n        for n in nums:\\n            if n <= k:\\n                full_series += k - n + 1\\n                k += 1\\n            else:\\n                break\\n        return full_series\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(set(nums))\\n        full_series = k * (k + 1) // 2\\n        for n in nums:\\n            if n <= k:\\n                full_series += k - n + 1\\n                k += 1\\n            else:\\n                break\\n        return full_series\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823805,
                "title": "modular-error-free-code-o-n-time-space-complexity",
                "content": "```\\n\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n        long k = (long) K;\\n        Long sum = 0l;\\n        int count = K;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n            if(!set.contains(num) && 1<=num && num<=k){\\n                sum += (long) num;\\n                count -= 1;\\n            }\\n            set.add(num);\\n        }\\n        long ans = k*(k+1)/2 - sum;\\n        System.out.println(sum+\" \"+count);\\n        for(int i=K+1; count<k; i++){\\n            if(!set.contains(i)){\\n                ans += i;\\n                count++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n\\t\\tpublic int[] uniq(int[] a)\\n\\t\\t{\\n\\t\\t\\tint n = a.length;\\n\\t\\t\\tint p = 0;\\n\\t\\t\\tfor(int i = 0;i < n;i++) {\\n\\t\\t\\t\\tif(i == 0 || a[i] != a[i-1])a[p++] = a[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn Arrays.copyOf(a, p);\\n\\t\\t}\\n\\n\\n\\t\\tpublic long minimalKSum(int[] nums, int k) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tnums = uniq(nums);\\n\\n\\t\\t\\tlong low = 0, high = 1100000000;\\n\\t\\t\\twhile(high - low > 1){\\n\\t\\t\\t\\tlong h = high+low>>1;\\n\\t\\t\\t\\tint num = lowerBound(nums, (int)h+1);\\n\\t\\t\\t\\tif((long)num+k <= h){\\n\\t\\t\\t\\t\\thigh = h;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlow = h;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong ans = (long)high*(high+1)/2;\\n\\t\\t\\tint num = lowerBound(nums, (int)high+1);\\n\\t\\t\\tfor(int i = 0;i < num;i++){\\n\\t\\t\\t\\tans -= nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tpublic int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }\\n\\t\\tpublic int lowerBound(int[] a, int l, int r, int v)\\n\\t\\t{\\n\\t\\t\\tif(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();\\n\\t\\t\\tint low = l-1, high = r;\\n\\t\\t\\twhile(high-low > 1){\\n\\t\\t\\t\\tint h = high+low>>>1;\\n\\t\\t\\t\\tif(a[h] >= v){\\n\\t\\t\\t\\t\\thigh = h;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlow = h;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn high;\\n\\t\\t}\\n\\n\\t}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n        long k = (long) K;\\n        Long sum = 0l;\\n        int count = K;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n            if(!set.contains(num) && 1<=num && num<=k){\\n                sum += (long) num;\\n                count -= 1;\\n            }\\n            set.add(num);\\n        }\\n        long ans = k*(k+1)/2 - sum;\\n        System.out.println(sum+\" \"+count);\\n        for(int i=K+1; count<k; i++){\\n            if(!set.contains(i)){\\n                ans += i;\\n                count++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n\\t\\tpublic int[] uniq(int[] a)\\n\\t\\t{\\n\\t\\t\\tint n = a.length;\\n\\t\\t\\tint p = 0;\\n\\t\\t\\tfor(int i = 0;i < n;i++) {\\n\\t\\t\\t\\tif(i == 0 || a[i] != a[i-1])a[p++] = a[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn Arrays.copyOf(a, p);\\n\\t\\t}\\n\\n\\n\\t\\tpublic long minimalKSum(int[] nums, int k) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tnums = uniq(nums);\\n\\n\\t\\t\\tlong low = 0, high = 1100000000;\\n\\t\\t\\twhile(high - low > 1){\\n\\t\\t\\t\\tlong h = high+low>>1;\\n\\t\\t\\t\\tint num = lowerBound(nums, (int)h+1);\\n\\t\\t\\t\\tif((long)num+k <= h){\\n\\t\\t\\t\\t\\thigh = h;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlow = h;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong ans = (long)high*(high+1)/2;\\n\\t\\t\\tint num = lowerBound(nums, (int)high+1);\\n\\t\\t\\tfor(int i = 0;i < num;i++){\\n\\t\\t\\t\\tans -= nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tpublic int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }\\n\\t\\tpublic int lowerBound(int[] a, int l, int r, int v)\\n\\t\\t{\\n\\t\\t\\tif(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();\\n\\t\\t\\tint low = l-1, high = r;\\n\\t\\t\\twhile(high-low > 1){\\n\\t\\t\\t\\tint h = high+low>>>1;\\n\\t\\t\\t\\tif(a[h] >= v){\\n\\t\\t\\t\\t\\thigh = h;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlow = h;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn high;\\n\\t\\t}\\n\\n\\t}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823780,
                "title": "python-o-nlogn-solution",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        start = 0\\n        nums = sorted(list(set(nums)))\\n        for i in range(len(nums)):\\n            x = nums[i]-start-1\\n            if x <= k:\\n                k -= x\\n            else:\\n                start += k\\n                return start*(start+1)//2-sum(nums[:i])\\n            start = nums[i]\\n        start += k\\n        return start*(start+1)//2-sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        start = 0\\n        nums = sorted(list(set(nums)))\\n        for i in range(len(nums)):\\n            x = nums[i]-start-1\\n            if x <= k:\\n                k -= x\\n            else:\\n                start += k\\n                return start*(start+1)//2-sum(nums[:i])\\n            start = nums[i]\\n        start += k\\n        return start*(start+1)//2-sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823763,
                "title": "short-python-solution-rolling-binary-search",
                "content": "Use Binary search. This may be called \"rolling\" binary search. \\nKeep only the unique numbers and sort them. Use binary search to find how many number are smaller than k. If all numbers are bigger than k, then we can simply use 1 to k. Otherwise, we have to give up some existing small numbers and look for bigger numbers than k. Then we increase k by the number of smaller numbers, until k is sufficiently large. \\nThe answer will be (1+k) * k // 2 - the sum of those smaller numbers in the given array. \\n\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(set(nums))\\n        prev = 0\\n        while True:\\n            idx = bisect.bisect(nums, k, prev)\\n            if idx > prev:\\n                k += idx-prev\\n                prev = idx\\n            else:\\n                break\\n        return (1+k) * k // 2 - sum(nums[:prev])\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(set(nums))\\n        prev = 0\\n        while True:\\n            idx = bisect.bisect(nums, k, prev)\\n            if idx > prev:\\n                k += idx-prev\\n                prev = idx\\n            else:\\n                break\\n        return (1+k) * k // 2 - sum(nums[:prev])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823710,
                "title": "c-sorting-with-formula-n-n-1-2",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& v, int k) {\\n        long long ans = 0;\\n        sort(v.begin(), v.end());\\n        for(int i = 0; i<v.size()&&k>0; i++){\\n            long long val = 1;\\n            if(i-1>=0){\\n                val = v[i-1];\\n            }else{\\n                if(v[i]!=1 && k>0){\\n                    ans++;k--;\\n                }\\n            }\\n            long long j = v[i]-val;\\n            if(j==0){continue;}\\n            j--;\\n            if(k>=j){\\n                ans+=(long long)((long long)(j*(j+1)/2) + (long long)(val*j));\\n            }else{\\n                long long val2 = ((long long)k*(long long)(k+1))/2;\\n                ans+=(long long)((val2) + (long long)(val*k));\\n                k=0;\\n                break;\\n            }\\n            \\n            k-=j;\\n        }\\n        long long val = v[v.size()-1]+1;\\n        if(k>0){\\n            ans+=val;\\n            k--;\\n            long long val2 = ((long long)k*(long long)(k+1))/2;\\n            ans+=(long long)(val2 + (long long)(val*k));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& v, int k) {\\n        long long ans = 0;\\n        sort(v.begin(), v.end());\\n        for(int i = 0; i<v.size()&&k>0; i++){\\n            long long val = 1;\\n            if(i-1>=0){\\n                val = v[i-1];\\n            }else{\\n                if(v[i]!=1 && k>0){\\n                    ans++;k--;\\n                }\\n            }\\n            long long j = v[i]-val;\\n            if(j==0){continue;}\\n            j--;\\n            if(k>=j){\\n                ans+=(long long)((long long)(j*(j+1)/2) + (long long)(val*j));\\n            }else{\\n                long long val2 = ((long long)k*(long long)(k+1))/2;\\n                ans+=(long long)((val2) + (long long)(val*k));\\n                k=0;\\n                break;\\n            }\\n            \\n            k-=j;\\n        }\\n        long long val = v[v.size()-1]+1;\\n        if(k>0){\\n            ans+=val;\\n            k--;\\n            long long val2 = ((long long)k*(long long)(k+1))/2;\\n            ans+=(long long)(val2 + (long long)(val*k));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823705,
                "title": "c-friendly-3-step-process",
                "content": "Idea here is based on Gauss summation formula, or whatever that called `n(n+1)/2`.\\nFor instance we have an array `[1,2,3,4,5]` to sum that array we do `1+2+3+4+5` or `5(5+1)/2`.\\n\\nSo here we first sort an array.\\n\\nThen we check three ranges and add up gauss for every range, similar to prefix sum:\\n - before first array element. Stop if first element is larger than `k`.\\n - inbetween every array element. Stop if we out of `k`.\\n - If we finished with the loop. Add the rest `k`.\\n```\\nclass Solution {\\npublic:\\n    long long gauss(long long num) {\\n        return (num*(num+1))/2;\\n    }\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        sort(nums.begin(),nums.end());\\n        \\n        // Start\\n        if (nums[0]>1) {\\n            if (nums[0]-1 >= k) {\\n                return gauss(k);\\n            } else {\\n                k -= nums[0]-1;\\n                res += gauss(nums[0]-1);\\n            }\\n        }\\n        \\n        // Mid\\n        int last = nums[0];\\n        for (int i=1; i<nums.size(); i++) {\\n            int diff = (nums[i]-1) - (nums[i-1]);\\n            if (diff>=1) {\\n                long long g1 = gauss(nums[i-1]);                \\n                if (diff >= k) {\\n                    long long g2 = gauss(nums[i-1]+k);\\n                    res += g2-g1;\\n                    return res;\\n                } else {\\n                    long long g2 = gauss(nums[i]-1);\\n                    k -= diff;\\n                    res += g2-g1;\\n                } \\n            }\\n            last=nums[i];\\n        }\\n        \\n        // End\\n        if (k>0) {\\n            long long g1 = gauss(last);\\n            long long g2 = gauss(last+k);\\n            res += g2-g1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gauss(long long num) {\\n        return (num*(num+1))/2;\\n    }\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        sort(nums.begin(),nums.end());\\n        \\n        // Start\\n        if (nums[0]>1) {\\n            if (nums[0]-1 >= k) {\\n                return gauss(k);\\n            } else {\\n                k -= nums[0]-1;\\n                res += gauss(nums[0]-1);\\n            }\\n        }\\n        \\n        // Mid\\n        int last = nums[0];\\n        for (int i=1; i<nums.size(); i++) {\\n            int diff = (nums[i]-1) - (nums[i-1]);\\n            if (diff>=1) {\\n                long long g1 = gauss(nums[i-1]);                \\n                if (diff >= k) {\\n                    long long g2 = gauss(nums[i-1]+k);\\n                    res += g2-g1;\\n                    return res;\\n                } else {\\n                    long long g2 = gauss(nums[i]-1);\\n                    k -= diff;\\n                    res += g2-g1;\\n                } \\n            }\\n            last=nums[i];\\n        }\\n        \\n        // End\\n        if (k>0) {\\n            long long g1 = gauss(last);\\n            long long g2 = gauss(last+k);\\n            res += g2-g1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823704,
                "title": "c-clean-using-map",
                "content": "\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // calculates sum from 1 to A\\n    long long sumA(long long a){\\n        if(a <= 0) return 0;\\n        return (a * (a+1)) / 2;\\n    }\\n    \\n    // calculates sum from A to B\\n    long long sumAB(long long a, long long b){\\n        if(a>b) return 0;\\n        return sumA(b) - sumA(a-1);\\n    }\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(auto it : nums) mp[it] = 1;\\n        \\n        auto it  = mp.end(); it--;\\n        long long last = it->first;\\n        \\n        // adding these two element to make sure map elements always cover num\\n        mp[0] = 1;\\n        mp[last + k + 1] = 1;\\n            \\n        auto prev = mp.begin();\\n        it  = prev; it++;\\n        \\n        long long sum = 0;\\n        \\n        // iterate the map and add the difference\\n        while( (it != mp.end()) && (k>0) ){\\n            long long x = it->first - prev->first - 1;\\n            \\n            // if gap is greate than range requried\\n            if( x > k){\\n                sum += sumAB(prev->first + 1, prev->first + 1 + k-1);\\n                k = 0;\\n            }else{  \\n                sum += sumAB(prev->first + 1, it->first - 1);\\n                k -= x;\\n            }\\n            \\n            it++; prev++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // calculates sum from 1 to A\\n    long long sumA(long long a){\\n        if(a <= 0) return 0;\\n        return (a * (a+1)) / 2;\\n    }\\n    \\n    // calculates sum from A to B\\n    long long sumAB(long long a, long long b){\\n        if(a>b) return 0;\\n        return sumA(b) - sumA(a-1);\\n    }\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(auto it : nums) mp[it] = 1;\\n        \\n        auto it  = mp.end(); it--;\\n        long long last = it->first;\\n        \\n        // adding these two element to make sure map elements always cover num\\n        mp[0] = 1;\\n        mp[last + k + 1] = 1;\\n            \\n        auto prev = mp.begin();\\n        it  = prev; it++;\\n        \\n        long long sum = 0;\\n        \\n        // iterate the map and add the difference\\n        while( (it != mp.end()) && (k>0) ){\\n            long long x = it->first - prev->first - 1;\\n            \\n            // if gap is greate than range requried\\n            if( x > k){\\n                sum += sumAB(prev->first + 1, prev->first + 1 + k-1);\\n                k = 0;\\n            }else{  \\n                sum += sumAB(prev->first + 1, it->first - 1);\\n                k -= x;\\n            }\\n            \\n            it++; prev++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823694,
                "title": "c-sort-self-expalanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        long long sum=0;\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]!=1) sum=1,k--;\\n        int prev=1;\\n        for(int i=0;i<nums.size() && k>0;i++){\\n            int curr=min(nums[i],(prev+k+1));\\n            long long midsum=(((curr-prev)*(long)(curr+prev+1))/2)-curr;\\n            if(midsum>0) sum+=midsum;\\n\\t\\t\\tk-=max(0,(curr-prev-1));\\n            prev=curr;\\n        }\\n        if(k>0){\\n            sum+=(((prev+k)-prev)*(long)(prev+k+prev+1))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        long long sum=0;\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]!=1) sum=1,k--;\\n        int prev=1;\\n        for(int i=0;i<nums.size() && k>0;i++){\\n            int curr=min(nums[i],(prev+k+1));\\n            long long midsum=(((curr-prev)*(long)(curr+prev+1))/2)-curr;\\n            if(midsum>0) sum+=midsum;\\n\\t\\t\\tk-=max(0,(curr-prev-1));\\n            prev=curr;\\n        }\\n        if(k>0){\\n            sum+=(((prev+k)-prev)*(long)(prev+k+prev+1))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823689,
                "title": "c-2195-append-k-integers-with-minimal-sum",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end()); \\n        long long ans = (long) k*(k+1)/2; \\n        for (int i = 0, prev = INT_MIN; i < nums.size(); prev = nums[i], ++i) \\n            if (prev < nums[i]) \\n                if (nums[i] <= k) ans += (++k) - nums[i]; \\n                else break; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end()); \\n        long long ans = (long) k*(k+1)/2; \\n        for (int i = 0, prev = INT_MIN; i < nums.size(); prev = nums[i], ++i) \\n            if (prev < nums[i]) \\n                if (nums[i] <= k) ans += (++k) - nums[i]; \\n                else break; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090176,
                "title": "java-sorting-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n    \\n        Arrays.sort(nums);\\n        long sum=0;\\n        long prev=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(prev==nums[i])\\n               continue;\\n\\n            long n=nums[i]-prev-1;\\n            if(n>k)\\n            n=k;\\n            sum+=(((2*(prev+1))+(n-1))*n)/2;\\n            k-=n;\\n            prev=nums[i];\\n\\n            if(k==0)\\n               return sum;\\n        }\\n\\n        if(k!=0)\\n        {\\n           long l=prev+k;\\n           sum+=((prev+1+l)*k)/2;\\n        }\\n\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n    \\n        Arrays.sort(nums);\\n        long sum=0;\\n        long prev=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(prev==nums[i])\\n               continue;\\n\\n            long n=nums[i]-prev-1;\\n            if(n>k)\\n            n=k;\\n            sum+=(((2*(prev+1))+(n-1))*n)/2;\\n            k-=n;\\n            prev=nums[i];\\n\\n            if(k==0)\\n               return sum;\\n        }\\n\\n        if(k!=0)\\n        {\\n           long l=prev+k;\\n           sum+=((prev+1+l)*k)/2;\\n        }\\n\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052181,
                "title": "c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long minimalKSum(vector<int>& nums, int k) {\\n    long long ans = 0;\\n    nums.push_back(0);\\n    sort(nums.begin(), nums.end());\\n    int i = 0, n = nums.size();\\n    while (i < n - 1 && k > 0) {\\n      if (nums[i] == nums[i + 1] || nums[i] + 1 == nums[i + 1]) {\\n        i++;\\n        continue;\\n      }\\n      long long l = nums[i] + 1, r = nums[i + 1] - 1;\\n      ans += (l + min(r, l + k - 1)) * (min(r - l + 1, (long long)k)) / 2;\\n      k -= (r - l + 1);\\n      i++;\\n    }\\n    if (k > 0) {\\n      long long l = nums.back() + 1;\\n      ans += (l + l + (k - 1)) * k / 2;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long minimalKSum(vector<int>& nums, int k) {\\n    long long ans = 0;\\n    nums.push_back(0);\\n    sort(nums.begin(), nums.end());\\n    int i = 0, n = nums.size();\\n    while (i < n - 1 && k > 0) {\\n      if (nums[i] == nums[i + 1] || nums[i] + 1 == nums[i + 1]) {\\n        i++;\\n        continue;\\n      }\\n      long long l = nums[i] + 1, r = nums[i + 1] - 1;\\n      ans += (l + min(r, l + k - 1)) * (min(r - l + 1, (long long)k)) / 2;\\n      k -= (r - l + 1);\\n      i++;\\n    }\\n    if (k > 0) {\\n      long long l = nums.back() + 1;\\n      ans += (l + l + (k - 1)) * k / 2;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013765,
                "title": "c-sorting-o-nlogn-time",
                "content": "\\n# AUTHOR: JAYESH BADGUJAR\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long find(int no){\\n        return (long long)((long long)no*(no+1))/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long sum=0;\\n        int n=nums.size();       \\n        sort(nums.begin(),nums.end());\\n        int  diff=nums[0]-1;\\n        if(diff>0){\\n            if(diff>k){\\n                sum+=find(k);\\n               k=0;\\n            }else{\\n                sum+=find(nums[0]-1);                 \\n                k-=diff;\\n            }\\n        }\\n        \\n        for(int i=1;i<nums.size();i++){\\n           if(k>0){\\n                int di=nums[i]-nums[i-1]-1;\\n                if(di>0){\\n                    if(di>k){\\n                        long long curr_sum=find(nums[i-1]+k)-find(nums[i-1]);   \\n                        k=0;\\n                        sum+=curr_sum;\\n                        break;\\n                    }else{\\n                        k-=di;\\n                        long long curr_sum=find(nums[i]-1)-find(nums[i-1]);                            \\n                        sum+=curr_sum;\\n                    }\\n                }\\n           }\\n        }\\n        if(k>0){\\n            long long curr_sum=find(nums[n-1]+k)-find(nums[n-1]);\\n            sum+=curr_sum;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long find(int no){\\n        return (long long)((long long)no*(no+1))/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long sum=0;\\n        int n=nums.size();       \\n        sort(nums.begin(),nums.end());\\n        int  diff=nums[0]-1;\\n        if(diff>0){\\n            if(diff>k){\\n                sum+=find(k);\\n               k=0;\\n            }else{\\n                sum+=find(nums[0]-1);                 \\n                k-=diff;\\n            }\\n        }\\n        \\n        for(int i=1;i<nums.size();i++){\\n           if(k>0){\\n                int di=nums[i]-nums[i-1]-1;\\n                if(di>0){\\n                    if(di>k){\\n                        long long curr_sum=find(nums[i-1]+k)-find(nums[i-1]);   \\n                        k=0;\\n                        sum+=curr_sum;\\n                        break;\\n                    }else{\\n                        k-=di;\\n                        long long curr_sum=find(nums[i]-1)-find(nums[i-1]);                            \\n                        sum+=curr_sum;\\n                    }\\n                }\\n           }\\n        }\\n        if(k>0){\\n            long long curr_sum=find(nums[n-1]+k)-find(nums[n-1]);\\n            sum+=curr_sum;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990131,
                "title": "concise-ruby-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef minimal_k_sum(nums, k)\\n  nums = nums.uniq.sort\\n  nums.unshift 0\\n  nums << nums.last + k + 1 \\n\\n  ans = 0\\n  nums.each_cons(2) do |fr, to|\\n    c = [k, to - fr - 1].min\\n    ans += c * (2 * fr + c + 1) / 2\\n\\n    k -= c\\n    return ans if k.zero?\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimal_k_sum(nums, k)\\n  nums = nums.uniq.sort\\n  nums.unshift 0\\n  nums << nums.last + k + 1 \\n\\n  ans = 0\\n  nums.each_cons(2) do |fr, to|\\n    c = [k, to - fr - 1].min\\n    ans += c * (2 * fr + c + 1) / 2\\n\\n    k -= c\\n    return ans if k.zero?\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3970258,
                "title": "using-natural-numbers-formula-caculate-numbers-l-to-r-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long getSum(int l,int r){\\n        if(l>r) return 0;\\n        if(l==r) return l;\\n        return (long)(r+l)*(r-l+1)/2;\\n    }\\n    public long minimalKSum(int[] nums, int k) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long  ans = 0;\\n        int len = nums[0]-1;\\n        if(k>=len){\\n           // System.out.println(k + \" \" + len);\\n          //  System.out.println(getSum(1,nums[0]-1));\\n            ans +=getSum(1,nums[0]-1);\\n            k-=len;\\n        }\\n        else {\\n          //  System.out.println(k + \" \" + len);\\n          //  System.out.println(getSum(1,k));\\n            ans += getSum(1,k);\\n            k=0;\\n        }\\n        for(int i =1;i<n;i++){\\n            int x = nums[i];\\n            int y = nums[i-1];\\n            if(x==y) continue;\\n            len = x-y-1;\\n            if(len==0) continue;\\n            if(k>=len){\\n              //  System.out.println(k + \" \" + len + \" \" + i);\\n                ans += getSum(y+1,x-1);\\n                k-=len;\\n                \\n            }else {\\n                ans+= getSum(y+1,y+k);\\n                k=0;\\n            }\\n        }\\n       // System.out.println(k);\\n        if(k>0) {\\n            ans += getSum(nums[n-1]+1,nums[n-1]+k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getSum(int l,int r){\\n        if(l>r) return 0;\\n        if(l==r) return l;\\n        return (long)(r+l)*(r-l+1)/2;\\n    }\\n    public long minimalKSum(int[] nums, int k) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long  ans = 0;\\n        int len = nums[0]-1;\\n        if(k>=len){\\n           // System.out.println(k + \" \" + len);\\n          //  System.out.println(getSum(1,nums[0]-1));\\n            ans +=getSum(1,nums[0]-1);\\n            k-=len;\\n        }\\n        else {\\n          //  System.out.println(k + \" \" + len);\\n          //  System.out.println(getSum(1,k));\\n            ans += getSum(1,k);\\n            k=0;\\n        }\\n        for(int i =1;i<n;i++){\\n            int x = nums[i];\\n            int y = nums[i-1];\\n            if(x==y) continue;\\n            len = x-y-1;\\n            if(len==0) continue;\\n            if(k>=len){\\n              //  System.out.println(k + \" \" + len + \" \" + i);\\n                ans += getSum(y+1,x-1);\\n                k-=len;\\n                \\n            }else {\\n                ans+= getSum(y+1,y+k);\\n                k=0;\\n            }\\n        }\\n       // System.out.println(k);\\n        if(k>0) {\\n            ans += getSum(nums[n-1]+1,nums[n-1]+k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969929,
                "title": "greedy-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res=0\\n        nums=[0]+nums\\n        for i in range(len(nums)-1):\\n            if nums[i+1]-nums[i]<=1:continue\\n            diff=(nums[i+1]-nums[i])-1\\n            if k>=diff:\\n                val=(nums[i+1]+nums[i])/2\\n                res+=val*diff\\n            else:\\n                val=(nums[i]+nums[i]+k+1)/2\\n                res+=val*k\\n            k-=diff\\n            if k<=0:break\\n        if k>0:\\n            val=((nums[-1]*2)+k+1)/2\\n            res+=val*k\\n        return int(res)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res=0\\n        nums=[0]+nums\\n        for i in range(len(nums)-1):\\n            if nums[i+1]-nums[i]<=1:continue\\n            diff=(nums[i+1]-nums[i])-1\\n            if k>=diff:\\n                val=(nums[i+1]+nums[i])/2\\n                res+=val*diff\\n            else:\\n                val=(nums[i]+nums[i]+k+1)/2\\n                res+=val*k\\n            k-=diff\\n            if k<=0:break\\n        if k>0:\\n            val=((nums[-1]*2)+k+1)/2\\n            res+=val*k\\n        return int(res)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962195,
                "title": "c-easy-just-do-it",
                "content": "\\n```\\n// FORMULA USED IS SUM BETWEEN TWO NUMBERS\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        long long miss_sum  = 0;\\n        // int miss_count = 0;\\n        int curr = 1;  \\n        for (int num : nums) {\\n            if (num > curr) {\\n                int miss_range = num - curr;\\n                int total_ele = min(miss_range, k);\\n                miss_sum += (long long) total_ele *\\n                (curr + curr + total_ele - 1) / 2;\\n                k -= total_ele;\\n                // miss_count += total_ele;\\n                if (k == 0) break;\\n            }\\n            curr = num + 1;\\n        }\\n        if (k > 0)\\n            miss_sum += (long long) k * (curr + curr + k - 1) / 2;\\n        return miss_sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// FORMULA USED IS SUM BETWEEN TWO NUMBERS\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        long long miss_sum  = 0;\\n        // int miss_count = 0;\\n        int curr = 1;  \\n        for (int num : nums) {\\n            if (num > curr) {\\n                int miss_range = num - curr;\\n                int total_ele = min(miss_range, k);\\n                miss_sum += (long long) total_ele *\\n                (curr + curr + total_ele - 1) / 2;\\n                k -= total_ele;\\n                // miss_count += total_ele;\\n                if (k == 0) break;\\n            }\\n            curr = num + 1;\\n        }\\n        if (k > 0)\\n            miss_sum += (long long) k * (curr + curr + k - 1) / 2;\\n        return miss_sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951718,
                "title": "fastest-solution-few-lines-o-n-log-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: O(N log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\\n#define ll long long\\nclass Solution {\\n   public:\\n   long long minimalKSum ( vector<int>& a , int k ) {\\n      sort ( a.begin ( ) , a.end ( ) );\\n      long long ans = 0 , p , x;\\n      rep ( i , 0 , a.size ( ) ) {\\n         x = i == 0 ? 0 : a [ i - 1 ];\\n         p = min ( ( ll ) k , a [ i ] - x - 1 );\\n         if ( k > 0 and p > 0 ) {\\n            ans += p * ( 2 * x + 1 + p ) / 2;\\n            k -= p;\\n            }\\n         }\\n      return ans + ( ll ) k * ( 2 * a.back ( ) + 1 + k ) / 2;\\n      }\\n   };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\\n#define ll long long\\nclass Solution {\\n   public:\\n   long long minimalKSum ( vector<int>& a , int k ) {\\n      sort ( a.begin ( ) , a.end ( ) );\\n      long long ans = 0 , p , x;\\n      rep ( i , 0 , a.size ( ) ) {\\n         x = i == 0 ? 0 : a [ i - 1 ];\\n         p = min ( ( ll ) k , a [ i ] - x - 1 );\\n         if ( k > 0 and p > 0 ) {\\n            ans += p * ( 2 * x + 1 + p ) / 2;\\n            k -= p;\\n            }\\n         }\\n      return ans + ( ll ) k * ( 2 * a.back ( ) + 1 + k ) / 2;\\n      }\\n   };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902059,
                "title": "simple-crisp-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<int>s(nums.begin(),nums.end());\\n        long long ans = (long(k)*(long(k+1)))/2; \\n        for(auto i:s){\\n            if(i<=k){ \\n            ans+=k+1;\\n            ans-=i;\\n            k++;\\n          }\\n            else  \\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<int>s(nums.begin(),nums.end());\\n        long long ans = (long(k)*(long(k+1)))/2; \\n        for(auto i:s){\\n            if(i<=k){ \\n            ans+=k+1;\\n            ans-=i;\\n            k++;\\n          }\\n            else  \\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814008,
                "title": "append-k-integers-with-minimal-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n    long ans = 0;\\n    Arrays.sort(nums);\\n\\n    if (nums[0] > 1) {\\n      final int l = 1;\\n      final int r = Math.min(k, nums[0] - 1);\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n      k -= r - l + 1;\\n      if (k == 0)\\n        return ans;\\n    }\\n\\n    for (int i = 0; i + 1 < nums.length; ++i) {\\n      if (nums[i] == nums[i + 1])\\n        continue;\\n      final int l = nums[i] + 1;\\n      final int r = Math.min(nums[i] + k, nums[i + 1] - 1);\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n      k -= r - l + 1;\\n      if (k == 0)\\n        return ans;\\n    }\\n\\n    if (k > 0) {\\n      final int l = nums[nums.length - 1] + 1;\\n      final int r = nums[nums.length - 1] + k;\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n    }\\n\\n    return ans;   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n    long ans = 0;\\n    Arrays.sort(nums);\\n\\n    if (nums[0] > 1) {\\n      final int l = 1;\\n      final int r = Math.min(k, nums[0] - 1);\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n      k -= r - l + 1;\\n      if (k == 0)\\n        return ans;\\n    }\\n\\n    for (int i = 0; i + 1 < nums.length; ++i) {\\n      if (nums[i] == nums[i + 1])\\n        continue;\\n      final int l = nums[i] + 1;\\n      final int r = Math.min(nums[i] + k, nums[i + 1] - 1);\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n      k -= r - l + 1;\\n      if (k == 0)\\n        return ans;\\n    }\\n\\n    if (k > 0) {\\n      final int l = nums[nums.length - 1] + 1;\\n      final int r = nums[nums.length - 1] + k;\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n    }\\n\\n    return ans;   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783366,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere I have the cocept that minimum sum of first k element is (k(k+1))/2 and then I manipulated this sum accordingly by using a set \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        long long t = (long long)k;\\n        long long sum = (t*(t+1))/2;\\n\\n        set<int> s;\\n\\n        for(int i = 0; i< n; i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n\\n        for(auto it: s)\\n        {\\n            if(it <= k)\\n            {\\n                sum -= it;\\n                k++;\\n                sum += k;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        long long t = (long long)k;\\n        long long sum = (t*(t+1))/2;\\n\\n        set<int> s;\\n\\n        for(int i = 0; i< n; i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n\\n        for(auto it: s)\\n        {\\n            if(it <= k)\\n            {\\n                sum -= it;\\n                k++;\\n                sum += k;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740457,
                "title": "easy-c-solution-which-surpasses-95-in-time-complexity-and-85-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you are standing on an element then you should have taken all the elements that comes before that into your sum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- first of all sort the array.\\n- Then initialise `sum` to 0 and `prev` to 0.\\n- Run a for loop from 0 to size of array .\\n- if(k>= nums[i]-prev-1), which means that all numbers between nums[i] and prev are to be taken into sum.\\n- if (k<nums[i]-prev-1),  then k will exhaust within nums[i] and nums[i+1].\\n- if we don\\'t find all the k numbers within the given array, we have to find them outside of it.\\n- At last return sum.$$$$$$$$$$O(n)$$$$$$$$$$\\n\\n# Complexity\\n- Time complexity:O(nlogn) + O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        ll n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        ll sum=0;\\n        ll prev=0;\\n        for(ll i=0 ; i<n ; i++)\\n        {\\n            ll a = nums[i];\\n            if(prev==a) continue;\\n            if(a-prev-1 <= k)\\n            {\\n                sum += (a*(a-1))/2;\\n                sum-= (prev*(prev+1))/2;\\n                k-=a-prev-1;\\n                \\n            }\\n            else \\n            {\\n                sum += ((prev+k) * (prev+k+1))/2;\\n                sum-= (prev*(prev+1))/2;\\n                k=0;\\n                break;\\n            }\\n            if(k==0) break;\\n\\n            prev = nums[i];            \\n        }\\n\\n        if(k!=0)\\n        {\\n            sum += ((prev+k) * (prev+k+1))/2;\\n            sum-= (prev*(prev+1))/2;\\n            k=0;\\n        }\\n       \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        ll n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        ll sum=0;\\n        ll prev=0;\\n        for(ll i=0 ; i<n ; i++)\\n        {\\n            ll a = nums[i];\\n            if(prev==a) continue;\\n            if(a-prev-1 <= k)\\n            {\\n                sum += (a*(a-1))/2;\\n                sum-= (prev*(prev+1))/2;\\n                k-=a-prev-1;\\n                \\n            }\\n            else \\n            {\\n                sum += ((prev+k) * (prev+k+1))/2;\\n                sum-= (prev*(prev+1))/2;\\n                k=0;\\n                break;\\n            }\\n            if(k==0) break;\\n\\n            prev = nums[i];            \\n        }\\n\\n        if(k!=0)\\n        {\\n            sum += ((prev+k) * (prev+k+1))/2;\\n            sum-= (prev*(prev+1))/2;\\n            k=0;\\n        }\\n       \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716503,
                "title": "easy-java-solution-sorting-greedy-only-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> set = new HashSet<>();\\n        long sum = 0;\\n        \\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;        \\n            }            \\n            set.add(num);\\n        }\\n\\n        long res = (long)(1 + k) * k / 2 - sum;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> set = new HashSet<>();\\n        long sum = 0;\\n        \\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;        \\n            }            \\n            set.add(num);\\n        }\\n\\n        long res = (long)(1 + k) * k / 2 - sum;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714135,
                "title": "masum-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<int>s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        long long ans;\\n        long long n=k;\\n        for(auto it:s)\\n        {\\n            if(it<=n)\\n            {\\n                n++;\\n            }\\n        }\\n\\n        ans=(n*(n+1))/2;\\n        for(auto it:s)\\n        {\\n            if(it<=n)\\n            {\\n                ans-=it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<int>s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        long long ans;\\n        long long n=k;\\n        for(auto it:s)\\n        {\\n            if(it<=n)\\n            {\\n                n++;\\n            }\\n        }\\n\\n        ans=(n*(n+1))/2;\\n        for(auto it:s)\\n        {\\n            if(it<=n)\\n            {\\n                ans-=it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680797,
                "title": "java-solution-using-treeset-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need to add unique **k** integers that results in minimum sum of the elements in the given array.here\\'s is the breakdown of the approach:\\n1. The minimum sum would be of first k integers.\\n2. but some of the element might present in the array already.\\n3. so count that number and add them starting from **k+1**.\\n4. i have used tree set because it stores elements in sorting order,faster storing.\\n\\n# Complexity\\n- Time complexity:`O(n log n + k log n)`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Integer> set=new TreeSet<>();\\n\\n        for(int number:nums)\\n            set.add(number);\\n        \\n        long sum=((long)k * (long)(k+1))/ 2;\\n        int count=0;\\n\\n        for(Integer i:set){\\n            if(i>k)\\n                break;\\n            else{\\n                sum-=i;\\n                count++;\\n            }\\n        }\\n        int i=k+1;\\n\\n        while(count>0){\\n            if(!set.contains(i)){\\n                sum+=i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Integer> set=new TreeSet<>();\\n\\n        for(int number:nums)\\n            set.add(number);\\n        \\n        long sum=((long)k * (long)(k+1))/ 2;\\n        int count=0;\\n\\n        for(Integer i:set){\\n            if(i>k)\\n                break;\\n            else{\\n                sum-=i;\\n                count++;\\n            }\\n        }\\n        int i=k+1;\\n\\n        while(count>0){\\n            if(!set.contains(i)){\\n                sum+=i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677199,
                "title": "smart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        unordered_set<long long> s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        long long int sum=(long long)k*(k+1);\\n        sum/=2;\\n        int t=k;\\n        unordered_set<long long>::iterator it;\\n        for(it=s.begin();it!=s.end();it++){\\n            if(*it<=k){\\n                sum-=*it;\\n                if(s.find(t+1)==s.end()){\\n                  sum+=(t+1); t++;\\n                }\\n                else{\\n                    while(s.find(t+1)!=s.end()) t++;\\n                    sum+=(t+1); t++;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        unordered_set<long long> s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        long long int sum=(long long)k*(k+1);\\n        sum/=2;\\n        int t=k;\\n        unordered_set<long long>::iterator it;\\n        for(it=s.begin();it!=s.end();it++){\\n            if(*it<=k){\\n                sum-=*it;\\n                if(s.find(t+1)==s.end()){\\n                  sum+=(t+1); t++;\\n                }\\n                else{\\n                    while(s.find(t+1)!=s.end()) t++;\\n                    sum+=(t+1); t++;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664293,
                "title": "greedy-sorting-arithmetic-progression-sum-time-o-sort-linear-scan-space-o-sort",
                "content": "class Solution(object):\\n    def minimalKSum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        nums.sort()\\n        prev = 0\\n        \\n        res = 0\\n        for n in nums:\\n            if n - prev > 1:\\n                nums_taken = min(n-prev-1, k)\\n                a = prev + 1\\n                res += (nums_taken*(2*a + nums_taken - 1))//2\\n                k -= nums_taken\\n            \\n            prev = n\\n        \\n        \\n        if k > 0:\\n            a = nums[-1] + 1\\n            res += (k*(2*a + k-1))//2\\n        \\n        return res\\n                \\n                \\n",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution(object):\\n    def minimalKSum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        nums.sort()\\n        prev = 0\\n        \\n        res = 0\\n        for n in nums:\\n            if n - prev > 1:\\n                nums_taken = min(n-prev-1, k)\\n                a = prev + 1\\n                res += (nums_taken*(2*a + nums_taken - 1))//2\\n                k -= nums_taken\\n            \\n            prev = n\\n        \\n        \\n        if k > 0:\\n            a = nums[-1] + 1\\n            res += (k*(2*a + k-1))//2\\n        \\n        return res\\n                \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 3654157,
                "title": "minimal-sum-javascript-sort-and-remove-duplicates",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimalKSum = function(nums, k) {   \\n    nums = [...new Set(nums)]\\n    nums.sort((a, b) => a - b)\\n    dif = 0    \\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] <= k) {\\n            dif -= nums[i]\\n            k ++\\n        }        \\n    }\\n    \\n    sum = k * ((k + 1) / 2) + dif\\n    \\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimalKSum = function(nums, k) {   \\n    nums = [...new Set(nums)]\\n    nums.sort((a, b) => a - b)\\n    dif = 0    \\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] <= k) {\\n            dif -= nums[i]\\n            k ++\\n        }        \\n    }\\n    \\n    sum = k * ((k + 1) / 2) + dif\\n    \\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651105,
                "title": "c-easy-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n    set<int> s(nums.begin(),nums.end());\\n    long long ans=((long long)k*((long long)k+1))/2;\\n    for(auto it:s){\\n        if(it<=k){\\n            ans+=(k+1);\\n            ans-=it;\\n            k++;\\n        } else{\\n            break;\\n        }\\n    } \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n    set<int> s(nums.begin(),nums.end());\\n    long long ans=((long long)k*((long long)k+1))/2;\\n    for(auto it:s){\\n        if(it<=k){\\n            ans+=(k+1);\\n            ans-=it;\\n            k++;\\n        } else{\\n            break;\\n        }\\n    } \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603505,
                "title": "c-easy-to-understand-solution-o-n-time-complexcity",
                "content": "# Intuition:-sum of number from 1 to n formula\\n\\n# Complexity\\n- Time complexity:-Linear\\n- Space complexity:-Constant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long long k) \\n    {\\n        long long res=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<=k)\\n            {\\n                k++;\\n                res-=nums[i];\\n                int j=i;\\n                while(j<nums.size() and nums[i]==nums[j])\\n                {\\n                    j++;\\n                }\\n                i=j-1;\\n            }\\n            i++;\\n        }\\n        res+=k*(k+1)/2;\\n        return res;\\n    }\\n};\\n- if you like ans please upvote it.\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long long k) \\n    {\\n        long long res=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<=k)\\n            {\\n                k++;\\n                res-=nums[i];\\n                int j=i;\\n                while(j<nums.size() and nums[i]==nums[j])\\n                {\\n                    j++;\\n                }\\n                i=j-1;\\n            }\\n            i++;\\n        }\\n        res+=k*(k+1)/2;\\n        return res;\\n    }\\n};\\n- if you like ans please upvote it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583949,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\n//tricky question\\n//the hint tells clearly how to approach this problem\\nclass Solution \\n{\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        //removing the duplicates\\n        sort(nums.begin(),nums.end());\\n        auto it=unique(nums.begin(),nums.end());\\n        nums.erase(it,nums.end());\\n\\n        int i,j,n;\\n        n=nums.size();\\n\\n        long long sum;\\n        sum=(1LL*k*(k+1))/2;\\n        unordered_set<int> st(nums.begin(),nums.end());\\n\\n        for(i=0,j=1;i<n && nums[i]<=k;i++)\\n        {\\n            //finding the next smallest number\\n            while(st.find(k+j)!=st.end())\\n            {\\n                j++;\\n            }\\n            \\n            sum+=k+j-nums[i];\\n            j++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//tricky question\\n//the hint tells clearly how to approach this problem\\nclass Solution \\n{\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        //removing the duplicates\\n        sort(nums.begin(),nums.end());\\n        auto it=unique(nums.begin(),nums.end());\\n        nums.erase(it,nums.end());\\n\\n        int i,j,n;\\n        n=nums.size();\\n\\n        long long sum;\\n        sum=(1LL*k*(k+1))/2;\\n        unordered_set<int> st(nums.begin(),nums.end());\\n\\n        for(i=0,j=1;i<n && nums[i]<=k;i++)\\n        {\\n            //finding the next smallest number\\n            while(st.find(k+j)!=st.end())\\n            {\\n                j++;\\n            }\\n            \\n            sum+=k+j-nums[i];\\n            j++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579915,
                "title": "simplest-possible-code-with-the-simplest-possible-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRunning a loop for k elements checking if an element is present in the given vector or not is pretty intuitive. But given the constraints, thats just not going to cut it. We have to be better. You probably might have observed (correctly) that the smallest k numbers must be selected and summed up for the answer.\\n\\nHow can we do it in the fastest way possible? A few minutes of thinking or a small peek at the `hint` will tell you that somewher  the formula for the sum of the first `n` integers will be used. Using that we can calculate the sum of the first `k` integers in `O(1)` time.\\n\\nNow how do we check which integers are already present in the given array? Begin by sorting and finding the unique integers in the array. Then remember the largest k that was taken (denoted by `maxTaken` in my case). So, for every unique number in nums that is less than `maxTaken` must have been erroneously taken in the sum. Therefore for every such occurence we remove that entry from the sum and add the number next to `maxTaken` to the sum. Keep in mind the fact that the `maxTaken` was updated and hence our loop termination condition will also be updated. Yeah, thats it i guess.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long minimalKSum(vector<int>& nums, long long k) {\\n    set<int> s(nums.begin(), nums.end());\\n    nums = vector<int>(s.begin(), s.end());\\n\\n    long long sum = k * (k + 1) / 2;\\n    long long maxTaken = k;\\n    int size = nums.size();\\n    for(int i=0; i < size && nums[i] <= maxTaken; i++){\\n      maxTaken++;\\n      sum = sum - nums[i] + maxTaken;\\n    }\\n    return sum;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long minimalKSum(vector<int>& nums, long long k) {\\n    set<int> s(nums.begin(), nums.end());\\n    nums = vector<int>(s.begin(), s.end());\\n\\n    long long sum = k * (k + 1) / 2;\\n    long long maxTaken = k;\\n    int size = nums.size();\\n    for(int i=0; i < size && nums[i] <= maxTaken; i++){\\n      maxTaken++;\\n      sum = sum - nums[i] + maxTaken;\\n    }\\n    return sum;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556459,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n         Arrays.sort(nums);\\n        long curr = 1 , res = 0;\\n        for (int i : nums){\\n            if (i>curr){\\n                while (curr<i && k>0){\\n                    res += curr;\\n                    ++curr;\\n                    --k;\\n                }\\n            }\\n            curr = i+1;\\n        }\\n        while (k>0){\\n            res += curr;\\n            ++curr;\\n            --k;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n         Arrays.sort(nums);\\n        long curr = 1 , res = 0;\\n        for (int i : nums){\\n            if (i>curr){\\n                while (curr<i && k>0){\\n                    res += curr;\\n                    ++curr;\\n                    --k;\\n                }\\n            }\\n            curr = i+1;\\n        }\\n        while (k>0){\\n            res += curr;\\n            ++curr;\\n            --k;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548225,
                "title": "100-explained-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nBy seeing the constraints it is obvious we can not iterate over k. As k is $10^8$ So iterating over k and nums will be too much time.\\nThis gives the intuition of using math that sum of first n number is $n*(n+1)/2$\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we are sorting the nums so as to get the minimum numbers in the beginning.\\nWe start temp as 1. And check for every $nums[i]$.\\nIf $temp==nums[i]$ we update temp as $nums[i]+1$.\\nNow we check if number of elements between nums[i] and temp is less than k or not. \\nIf number of elements between temp and nums[i] is less than k. We add those elements in the answer and update temp as nums[i]+1. and update k as  k - (number of elements added).\\nIf number of elements is greater than k. we add the elements from temp to temp+k-1 and update k as 0.\\n\\nThere is a case when we might end with nums array and still k is not 0. So we have to take care of this case also.\\n\\n# Complexity\\n- Time complexity: $O(nlogn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long summ(long long  start, long long end)\\n    {\\n        if(start>end) return 0;\\n        return (end*(end+1)/2 - (start-1)*(start)/2);\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n       sort(nums.begin(),nums.end());\\n       long long temp=1;\\n       long long ans=0;\\n       for(int i  =0;i<nums.size();i++)\\n       {\\n           if(nums[i]==temp) temp = nums[i]+1;\\n           else if(nums[i]-temp <k)\\n           {\\n               ans = ans + summ(temp,nums[i]-1);\\n               if(nums[i]>temp)k = k - (nums[i]-temp);\\n               temp = nums[i]+1;\\n           }\\n           else if(nums[i]-temp >=k)\\n           {\\n               ans = ans+summ(temp,temp+k-1);\\n               k=0;\\n               break;\\n           }\\n       }\\n       if(k!=0)\\n       {\\n           ans = ans+summ(temp,temp+k-1);\\n           k=0;\\n       }\\n       return ans;\\n\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long summ(long long  start, long long end)\\n    {\\n        if(start>end) return 0;\\n        return (end*(end+1)/2 - (start-1)*(start)/2);\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n       sort(nums.begin(),nums.end());\\n       long long temp=1;\\n       long long ans=0;\\n       for(int i  =0;i<nums.size();i++)\\n       {\\n           if(nums[i]==temp) temp = nums[i]+1;\\n           else if(nums[i]-temp <k)\\n           {\\n               ans = ans + summ(temp,nums[i]-1);\\n               if(nums[i]>temp)k = k - (nums[i]-temp);\\n               temp = nums[i]+1;\\n           }\\n           else if(nums[i]-temp >=k)\\n           {\\n               ans = ans+summ(temp,temp+k-1);\\n               k=0;\\n               break;\\n           }\\n       }\\n       if(k!=0)\\n       {\\n           ans = ans+summ(temp,temp+k-1);\\n           k=0;\\n       }\\n       return ans;\\n\\n         \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3545091,
                "title": "my-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {   \\npublic:\\n   // method 3 using sorting only\\n      long long minimalKSum(vector<int>& nums, int k) {\\n          int n = size(nums);\\n          ll sum = 0;\\n          sort(nums.begin(),nums.end());\\n          for(int i=0;i<n;i++){\\n              ll n1,n2,x;\\n              if(i==0){\\n                 if(k>=nums[0]) {\\n                     n1 = ((ll)nums[0]*(nums[0]-1))/2;\\n                     sum += n1;\\n                     k -= nums[0];\\n                     k++;\\n                 }\\n                 else {\\n                     n1 = ((ll)k*(k+1))/2;\\n                     sum += n1;\\n                     k = 0; \\n                     return sum;\\n                 }\\n                   \\n              }\\n              else {\\n                  if(nums[i-1]==nums[i]) continue;\\n                  if(k>nums[i]-nums[i-1]-1){\\n                      n1 = ((ll)nums[i-1]*(nums[i-1]+1))/2; \\n                  n2 = ((ll)nums[i]*(nums[i]-1))/2; \\n                  x = n2-n1;\\n                  sum += x;\\n                  k -= (nums[i]-nums[i-1]-1);\\n                  }\\n                  else {\\n                       n1 = ((ll)nums[i-1]*(nums[i-1]+1))/2; \\n                  int n3 = nums[i-1]+k;\\n                  n2 = ((ll)n3*(n3+1))/2; \\n                  x = n2-n1;\\n                  sum += x;\\n                  return sum;\\n                  }\\n              }\\n          }\\n          int x = nums[n-1]+k;\\n          if(k){\\n              ll n1 = ((ll)nums[n-1]*(nums[n-1]+1))/2;\\n              ll n2 = ((ll)x*(x+1))/2; \\n              sum += (n2-n1);\\n          }\\n\\n          return sum;\\n      }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {   \\npublic:\\n   // method 3 using sorting only\\n      long long minimalKSum(vector<int>& nums, int k) {\\n          int n = size(nums);\\n          ll sum = 0;\\n          sort(nums.begin(),nums.end());\\n          for(int i=0;i<n;i++){\\n              ll n1,n2,x;\\n              if(i==0){\\n                 if(k>=nums[0]) {\\n                     n1 = ((ll)nums[0]*(nums[0]-1))/2;\\n                     sum += n1;\\n                     k -= nums[0];\\n                     k++;\\n                 }\\n                 else {\\n                     n1 = ((ll)k*(k+1))/2;\\n                     sum += n1;\\n                     k = 0; \\n                     return sum;\\n                 }\\n                   \\n              }\\n              else {\\n                  if(nums[i-1]==nums[i]) continue;\\n                  if(k>nums[i]-nums[i-1]-1){\\n                      n1 = ((ll)nums[i-1]*(nums[i-1]+1))/2; \\n                  n2 = ((ll)nums[i]*(nums[i]-1))/2; \\n                  x = n2-n1;\\n                  sum += x;\\n                  k -= (nums[i]-nums[i-1]-1);\\n                  }\\n                  else {\\n                       n1 = ((ll)nums[i-1]*(nums[i-1]+1))/2; \\n                  int n3 = nums[i-1]+k;\\n                  n2 = ((ll)n3*(n3+1))/2; \\n                  x = n2-n1;\\n                  sum += x;\\n                  return sum;\\n                  }\\n              }\\n          }\\n          int x = nums[n-1]+k;\\n          if(k){\\n              ll n1 = ((ll)nums[n-1]*(nums[n-1]+1))/2;\\n              ll n2 = ((ll)x*(x+1))/2; \\n              sum += (n2-n1);\\n          }\\n\\n          return sum;\\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543579,
                "title": "python3-sorting-and-math",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \\n        \\n        ans=0\\n        nums=[0]+sorted(set(nums))\\n        n=len(nums)\\n        \\n        for i,val in enumerate(nums):\\n            if i+1>=n:\\n                continue\\n            \\n            diff=nums[i+1]-nums[i]-1\\n            diff=min(k,diff)\\n            \\n            a,b=nums[i],nums[i]+diff\\n            \\n            s1=a*(a+1)//2\\n            s2=b*(b+1)//2\\n            \\n            ans+=(s2-s1)\\n            k-=diff\\n            if k==0:\\n                break\\n            \\n        if k:\\n            a=nums[-1]\\n            b=nums[-1]+k\\n            s1=a*(a+1)//2\\n            s2=b*(b+1)//2\\n            ans+=(s2-s1)\\n            \\n        return ans\\n            \\n    \\n    \\n        \\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \\n        \\n        ans=0\\n        nums=[0]+sorted(set(nums))\\n        n=len(nums)\\n        \\n        for i,val in enumerate(nums):\\n            if i+1>=n:\\n                continue\\n            \\n            diff=nums[i+1]-nums[i]-1\\n            diff=min(k,diff)\\n            \\n            a,b=nums[i],nums[i]+diff\\n            \\n            s1=a*(a+1)//2\\n            s2=b*(b+1)//2\\n            \\n            ans+=(s2-s1)\\n            k-=diff\\n            if k==0:\\n                break\\n            \\n        if k:\\n            a=nums[-1]\\n            b=nums[-1]+k\\n            s1=a*(a+1)//2\\n            s2=b*(b+1)//2\\n            ans+=(s2-s1)\\n            \\n        return ans\\n            \\n    \\n    \\n        \\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533555,
                "title": "sum-first",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minimalKSum = function(nums, k) {\\n    let sum = 0;\\n    for(i=1; i<=k; i++) {\\n        sum += i;\\n    }\\n    for(n of [...new Set(nums)].sort((a,b)=>a-b)) {\\n        if (n <= k) {\\n            k++;\\n            sum = sum + k - n;\\n        } else\\n            return sum;\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimalKSum = function(nums, k) {\\n    let sum = 0;\\n    for(i=1; i<=k; i++) {\\n        sum += i;\\n    }\\n    for(n of [...new Set(nums)].sort((a,b)=>a-b)) {\\n        if (n <= k) {\\n            k++;\\n            sum = sum + k - n;\\n        } else\\n            return sum;\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533286,
                "title": "o-n-sort-then-one-pass-clear-logic",
                "content": "# Intuition\\nsort first. then add numbers between two consective element to sum until k numbers are added.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) from sorting\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    long minimalKSum(vector<int>& nums, int k) {\\n        std::sort(nums.begin(), nums.end());\\n\\n        long sum = 0;\\n        int left = 0; // use an extra number 0 as initial left end, so no need to process nums[0] specially\\n        // loop over nums, add numbers(if any) between two elements to sum\\n        for(int i = 0; i < nums.size() && k > 0; left=nums[i], i++) { // i points to right end\\n            int inBetween = nums[i] - left - 1;\\n            if (inBetween < 1) {\\n                continue;\\n            }\\n            if (inBetween > k) { \\n                break;\\n            }\\n\\n            sum += (left + nums[i]) / 2.0 * inBetween;\\n            k -= inBetween;\\n        }\\n\\n        // append numbers after the last left till k\\n        sum += (left+1 + left+k) / 2.0 * k;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    long minimalKSum(vector<int>& nums, int k) {\\n        std::sort(nums.begin(), nums.end());\\n\\n        long sum = 0;\\n        int left = 0; // use an extra number 0 as initial left end, so no need to process nums[0] specially\\n        // loop over nums, add numbers(if any) between two elements to sum\\n        for(int i = 0; i < nums.size() && k > 0; left=nums[i], i++) { // i points to right end\\n            int inBetween = nums[i] - left - 1;\\n            if (inBetween < 1) {\\n                continue;\\n            }\\n            if (inBetween > k) { \\n                break;\\n            }\\n\\n            sum += (left + nums[i]) / 2.0 * inBetween;\\n            k -= inBetween;\\n        }\\n\\n        // append numbers after the last left till k\\n        sum += (left+1 + left+k) / 2.0 * k;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3486455,
                "title": "c-95-7-memory-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* sort the array for convenience.\\n* always add the smallest possible number.\\n* whenever there is a gap between elements, or a gap before the first element, insert as many as possible.\\n* The sequence of possible added numbers per gap follows certain arithmetic relation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne variable to keep track of the \\\\#number of elements added; one variable to keep the result. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) for every multiplication; One multiplication per gap; Iterate once to find all gaps -> O(N) time.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nTwo variables, each with O(1) -> O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int added = 0;\\n        long long res = 0;\\n        if (nums[0] > 1) {\\n            int bound = min(k, nums[0]-1);\\n            added += bound;\\n            res += (long long) (1 + bound)*bound/2;\\n        }\\n        for(int i=0;i<nums.size()-1;i++) {\\n            if (nums[i+1] > nums[i]+1 && added < k) {\\n                int bound = min(k - added, nums[i+1]-nums[i]-1);\\n                added += bound;\\n                res += (long long) (nums[i] +1 +nums[i] + bound)*bound/2;\\n                \\n            }\\n            if(added >= k){\\n                return res;\\n            }\\n        }\\n        if (added < k) {\\n            int bound = k - added;\\n            res += (long long)(nums.back()+1+nums.back()+bound)*bound/2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int added = 0;\\n        long long res = 0;\\n        if (nums[0] > 1) {\\n            int bound = min(k, nums[0]-1);\\n            added += bound;\\n            res += (long long) (1 + bound)*bound/2;\\n        }\\n        for(int i=0;i<nums.size()-1;i++) {\\n            if (nums[i+1] > nums[i]+1 && added < k) {\\n                int bound = min(k - added, nums[i+1]-nums[i]-1);\\n                added += bound;\\n                res += (long long) (nums[i] +1 +nums[i] + bound)*bound/2;\\n                \\n            }\\n            if(added >= k){\\n                return res;\\n            }\\n        }\\n        if (added < k) {\\n            int bound = k - added;\\n            res += (long long)(nums.back()+1+nums.back()+bound)*bound/2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483076,
                "title": "c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public long MinimalKSum(int[] nums, int k) {\\n        Array.Sort(nums);\\n        long res = 0;\\n        int expect = 1,last = 0;\\n        for(int i = 0; i < nums.Length && k > 0;i++){\\n            int n = Math.Min(nums[i] - expect,k);\\n            if(n > 0){\\n                k-= n;\\n                last = expect + n - 1;\\n                res+= (long)((expect + last) * 0.5 * n);\\n            }\\n            expect = nums[i] + 1;\\n        }\\n        if(k > 0){\\n            last = expect + k - 1;\\n            res+= (long)((expect + last) * 0.5 * k);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimalKSum(int[] nums, int k) {\\n        Array.Sort(nums);\\n        long res = 0;\\n        int expect = 1,last = 0;\\n        for(int i = 0; i < nums.Length && k > 0;i++){\\n            int n = Math.Min(nums[i] - expect,k);\\n            if(n > 0){\\n                k-= n;\\n                last = expect + n - 1;\\n                res+= (long)((expect + last) * 0.5 * n);\\n            }\\n            expect = nums[i] + 1;\\n        }\\n        if(k > 0){\\n            last = expect + k - 1;\\n            res+= (long)((expect + last) * 0.5 * k);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458354,
                "title": "very-easy-approach-and-8-lines-code-in-c-without-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& a, int k) {\\n        long long i=0,sum=0;\\n        sort(a.begin(),a.end());\\n        while(i<a.size() && a[i]<=k)\\n        {\\n          if(i!=0 && a[i]==a[i-1]) {i++; continue;}\\n          sum-=a[i];\\n          k++;\\n          i++;\\n            \\n         }\\n        sum+=(long long )k*(k+1)/2;\\n       \\n       \\n       \\n       \\n     return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& a, int k) {\\n        long long i=0,sum=0;\\n        sort(a.begin(),a.end());\\n        while(i<a.size() && a[i]<=k)\\n        {\\n          if(i!=0 && a[i]==a[i-1]) {i++; continue;}\\n          sum-=a[i];\\n          k++;\\n          i++;\\n            \\n         }\\n        sum+=(long long )k*(k+1)/2;\\n       \\n       \\n       \\n       \\n     return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451946,
                "title": "java-clear-and-good-explanations",
                "content": "# Approach\\n1. Sort the numbers in natural order\\n2. For each num in nums\\n3. If current - prev > 1 (interval gap), determine the sum of the interval gap\\n    - EG: 3 and 8. There is a gap of 4,5,6,7 of sum 4+5+6+7.\\n4. To quickly calculate the sum of any gap apply basic math:\\n    - the sum of 4+5+6+7 = Sum(1..7) - sum (1..3).\\n    - which is n * (n+1) / 2 -> (7*8 /2) - (3 * 4 /2) = 28 - 6 = 22.\\n5. For each step, if there is a gap, calculate the interval gap size. \\nAlso, decrement k with each gap.\\n6. If K is still > 0 when reaching the end, add the missing gap to the sum. \\n\\n# Complexity\\n- Time complexity:$$O(n * log(n) + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int prev = 0, currentDiff;\\n        long missingIntervalSum = 0L;\\n        for (int num : nums) {\\n            if (k > 0) {\\n                currentDiff = Math.min(k, num - prev - 1);\\n                if (currentDiff > 0) {\\n                    missingIntervalSum += calculateInterval(prev, prev + currentDiff);\\n                    k -= currentDiff;\\n                }\\n            }\\n            prev = num;\\n        }\\n        if (k > 0) {\\n            missingIntervalSum += calculateInterval(prev, prev + k);\\n        }\\n        return missingIntervalSum;\\n    }\\n\\n    private long calculateInterval(long beforeIntervalStart, int intervalEnd) {\\n        long totalSum = (long)(intervalEnd) * (intervalEnd + 1) / 2;\\n        long before = beforeIntervalStart * (beforeIntervalStart + 1) / 2;\\n        return totalSum - before;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int prev = 0, currentDiff;\\n        long missingIntervalSum = 0L;\\n        for (int num : nums) {\\n            if (k > 0) {\\n                currentDiff = Math.min(k, num - prev - 1);\\n                if (currentDiff > 0) {\\n                    missingIntervalSum += calculateInterval(prev, prev + currentDiff);\\n                    k -= currentDiff;\\n                }\\n            }\\n            prev = num;\\n        }\\n        if (k > 0) {\\n            missingIntervalSum += calculateInterval(prev, prev + k);\\n        }\\n        return missingIntervalSum;\\n    }\\n\\n    private long calculateInterval(long beforeIntervalStart, int intervalEnd) {\\n        long totalSum = (long)(intervalEnd) * (intervalEnd + 1) / 2;\\n        long before = beforeIntervalStart * (beforeIntervalStart + 1) / 2;\\n        return totalSum - before;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448363,
                "title": "c-solution-filling-gaps",
                "content": "\\n\\n# Approach\\n- sort array\\n- insert 0 to array\\n- find gaps between two items that can be filled\\n- use gaussian sum formula and calculate the filled area\\n- check at the end if there still needs to be more additions\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinimalKSum(int[] nums, int k) {\\n        long kl = (long)k;\\n        nums = nums.Concat(new int[] { 0 }).ToArray();\\n        Array.Sort(nums);\\n        long addedNumsSum = 0;\\n\\n        for (int i=0; i<nums.Length-1; i++) {\\n            if (kl>0 && nums[i]+1<nums[i+1]) {\\n                long from = nums[i]+1;\\n                long to = Math.Min(nums[i+1], from+kl);\\n                \\n                addedNumsSum += sumRange(from, to);\\n                kl -= to-from;\\n            }\\n            if (kl<=0) {\\n                return addedNumsSum;\\n            }\\n        }\\n\\n        long fromLast = nums[nums.Length-1]+1;\\n        long toLast = fromLast+kl;\\n        addedNumsSum += sumRange(fromLast, toLast);\\n\\n        return addedNumsSum;\\n    }\\n\\n    private long sumRange(long from, long to) {\\n        return (from-1) * (to-from) + ((to-from)*(to-from+1))/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimalKSum(int[] nums, int k) {\\n        long kl = (long)k;\\n        nums = nums.Concat(new int[] { 0 }).ToArray();\\n        Array.Sort(nums);\\n        long addedNumsSum = 0;\\n\\n        for (int i=0; i<nums.Length-1; i++) {\\n            if (kl>0 && nums[i]+1<nums[i+1]) {\\n                long from = nums[i]+1;\\n                long to = Math.Min(nums[i+1], from+kl);\\n                \\n                addedNumsSum += sumRange(from, to);\\n                kl -= to-from;\\n            }\\n            if (kl<=0) {\\n                return addedNumsSum;\\n            }\\n        }\\n\\n        long fromLast = nums[nums.Length-1]+1;\\n        long toLast = fromLast+kl;\\n        addedNumsSum += sumRange(fromLast, toLast);\\n\\n        return addedNumsSum;\\n    }\\n\\n    private long sumRange(long from, long to) {\\n        return (from-1) * (to-from) + ((to-from)*(to-from+1))/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436476,
                "title": "python-sort-and-check-diff",
                "content": "# Intuition\\nsort and check diff\\n\\n# Approach\\nappend 0 and 10^9\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimalKSum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        c=0\\n        res=0\\n        nums.append(0)\\n        if 1000000000 not in nums:\\n            nums.append(1000000000)\\n        nums= list(set(nums))\\n        nums.sort()\\n        # print(nums)\\n\\n        for i in range(0, len(nums)):\\n\\n            if c + nums[i+1]-nums[i]-1> k:\\n                \\n                n= k-c\\n                res = res + n *(nums[i] + k-c + nums[i]+1)//2\\n                break\\n            else:\\n                c = c+ nums[i+1]- nums[i]-1\\n                n= nums[i+1]- nums[i]-1\\n                res = res + n*(nums[i+1]-1 + nums[i]+1) //2\\n        # print(res)\\n        return (res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimalKSum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        c=0\\n        res=0\\n        nums.append(0)\\n        if 1000000000 not in nums:\\n            nums.append(1000000000)\\n        nums= list(set(nums))\\n        nums.sort()\\n        # print(nums)\\n\\n        for i in range(0, len(nums)):\\n\\n            if c + nums[i+1]-nums[i]-1> k:\\n                \\n                n= k-c\\n                res = res + n *(nums[i] + k-c + nums[i]+1)//2\\n                break\\n            else:\\n                c = c+ nums[i+1]- nums[i]-1\\n                n= nums[i+1]- nums[i]-1\\n                res = res + n*(nums[i+1]-1 + nums[i]+1) //2\\n        # print(res)\\n        return (res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430454,
                "title": "c-beats-80-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the array first. Then continue adding elements from 1 like 1,then 2, then 3 and so on, skipping the elements that are already there in the array till total elements added equals k. It is because we need the minimum sum as possible. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose we are given the sorted array [5,8,9,9,12] and k=7. Now the elements that we require to add are 1+2+3+4+6+7+10. Since 5,8,9 are already there in the sequence so we skip it.\\nwe check the first entry in the array, here it\\'s 5.So we know we have to take the sum of elements from 1 to 4. We calculate the sum using the AP formula n*(first+last)/2 which gives result in linear time. Store the result in \"sum\" variable. Since we have already taken 4 numbers so we reduce k to 3.Then we move to the next element which is here 8. The previous entry of 8 is 5 so we have to add the numbers from 6 to 7. we add this result to the \"sum\" variable and reduce the k value by 2 to 1. Now iterate to the next variable which is 9 here. Now since the previous entry is 8 which is only 1 less than the current entry, we simply iterate to the next entry. Now the next entry is 9 here which is equal to the previous entry, so here also we just iterate to the next location.\\nThe next number in the array is 12. The previous entry is 9. There are 2 numbers lying between 9 & 12 (10,11).But we need only 1, i.e. 10. Using A.P formula a+(n-1)d, here a=10,n=k,d=1, we can get the last number upto which we have to add. After adding append the result to the sum variable.\\nIt may given that K=10. In that context,after iterating to the last location in the array, k is reduced to 2. we can see that we are still left with more 2 elements to add(13 and 14). We can predict the last no using ap formula and then append the result to the sum variable as done formerly.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->nlogn\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long sum=0,i=-1,first=1,last,size=nums.size(),s=0,n=0;\\n        sort(nums.begin(),nums.end());\\n        while(k>0 && i<size-1){\\n            if(i==-1 && nums[0]!=1){\\n                last=nums[0]-1;\\n                s=1;\\n            }\\n            else if(i>-1 && (nums[i]+1)!=nums[i+1] && nums[i]!=nums[i+1]){\\n                first=nums[i]+1;\\n                last=nums[i+1]-1;\\n                s=1;\\n            }\\n            if(s==1){\\n                n=(last-first)+1;\\n                if(k<n){\\n                  last=(first+k)-1;\\n                  sum+=(k*(last+first))/2;\\n                }\\n                else{\\n                sum+=(n*(last+first))/2;\\n                }\\n                k-=n;\\n                s=0;\\n            }\\n            i++;\\n        }\\n        if(k>0){\\n            first=nums[i]+1;\\n            last=nums[i]+k;\\n            sum+=(k*(first+last))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long sum=0,i=-1,first=1,last,size=nums.size(),s=0,n=0;\\n        sort(nums.begin(),nums.end());\\n        while(k>0 && i<size-1){\\n            if(i==-1 && nums[0]!=1){\\n                last=nums[0]-1;\\n                s=1;\\n            }\\n            else if(i>-1 && (nums[i]+1)!=nums[i+1] && nums[i]!=nums[i+1]){\\n                first=nums[i]+1;\\n                last=nums[i+1]-1;\\n                s=1;\\n            }\\n            if(s==1){\\n                n=(last-first)+1;\\n                if(k<n){\\n                  last=(first+k)-1;\\n                  sum+=(k*(last+first))/2;\\n                }\\n                else{\\n                sum+=(n*(last+first))/2;\\n                }\\n                k-=n;\\n                s=0;\\n            }\\n            i++;\\n        }\\n        if(k>0){\\n            first=nums[i]+1;\\n            last=nums[i]+k;\\n            sum+=(k*(first+last))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411841,
                "title": "python-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe get the sum of range 1 to k, this is the potential minimum sum.\\nFor each different number in nums, we deduct that number from sum and add one new to sum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1, store the sum of range(k) as s and two other variables. Left for the previous number in nums and right for k;\\n\\n2, iterate nums. If current number equals left, we do nothing as we have dealt with this already; \\n\\n3, or if current number not more than right, which means that we have added it when got s, so should deduct it from s, and add the next number of right to s, update right;\\n\\n4, or if current number is bigger than right, which means all k numbers fullfil the requirement and this is the answer;\\n\\n5, return s after the entire iteration.\\n\\nFeel free to share and discuss. :D\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        s = (k ** 2 + k) // 2\\n        left = 0\\n        right = k\\n        for i in range(len(nums)):\\n            if nums[i] == left:\\n                continue\\n            elif nums[i] <= right:\\n                left = nums[i]\\n                s -= nums[i]\\n                right += 1\\n                s += right\\n            else:\\n                return s\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        s = (k ** 2 + k) // 2\\n        left = 0\\n        right = k\\n        for i in range(len(nums)):\\n            if nums[i] == left:\\n                continue\\n            elif nums[i] <= right:\\n                left = nums[i]\\n                s -= nums[i]\\n                right += 1\\n                s += right\\n            else:\\n                return s\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367286,
                "title": "sum-n-n-1-2-java",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        // if num is added via n*(n+1)/2 then  \\n        // you remove its contribution and add k+1\\n        // and for the next number, k+1 is the new limit since we just used k+1\\n        \\n        // eg: 1,4,5 and k=3 \\n        // first sum=1+2+3 \\n        // then at 1, k was 3, we say lets add k+1 i.e 4 so, sum += 4-1 (subtract 1 since we never needed to add one but we did through k*(k+1)/2)\\n        //now when we encounter 4, k=4, it means 4 was already added, so we add 5. sum += 5-4 and k++\\n        // now when we encounter 5, k=5, it means 5 was already added, so we add 6 instead sum+=6-5 k++\\n        \\n        long sum = (long) k*(k+1)/2;\\n        int len = nums.length;\\n        \\n        Arrays.sort(nums); // [1,10,34,25,10,25,6] k=10\\n        int prev = -1;\\n\\n        for(int num: nums){\\n            if(num==prev) continue;\\n            if(num<=k){\\n                k+=1;\\n                sum+=(k-num);\\n            }\\n            prev = num;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        // if num is added via n*(n+1)/2 then  \\n        // you remove its contribution and add k+1\\n        // and for the next number, k+1 is the new limit since we just used k+1\\n        \\n        // eg: 1,4,5 and k=3 \\n        // first sum=1+2+3 \\n        // then at 1, k was 3, we say lets add k+1 i.e 4 so, sum += 4-1 (subtract 1 since we never needed to add one but we did through k*(k+1)/2)\\n        //now when we encounter 4, k=4, it means 4 was already added, so we add 5. sum += 5-4 and k++\\n        // now when we encounter 5, k=5, it means 5 was already added, so we add 6 instead sum+=6-5 k++\\n        \\n        long sum = (long) k*(k+1)/2;\\n        int len = nums.length;\\n        \\n        Arrays.sort(nums); // [1,10,34,25,10,25,6] k=10\\n        int prev = -1;\\n\\n        for(int num: nums){\\n            if(num==prev) continue;\\n            if(num<=k){\\n                k+=1;\\n                sum+=(k-num);\\n            }\\n            prev = num;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364669,
                "title": "python-bs-for-missing-num-k-1-n-n-2",
                "content": "**Update**: sorting is not needed actually\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        1. calc min sum via arithmetic sum: min_sum = (k + 1)k // 2\\n        2. remove present elements <= k from min_sum + count present nums <= k\\n        3. add k - present_in_nums elements after k\\n        \\n        ex. [1,3] k=3\\n        1. min_sum = (1 + 3) * 3 // 2 = 6\\n        2. 1 2 3, remove 1,3 -> min_sum = 2\\n        3. min_sum + 4 (which is k + 1) + 5 (which is k + 2) -> 11\\n        \"\"\"\\n\\n        nums = set(nums)\\n        min_sum = (1 + k) * k // 2\\n        last_k = k\\n        for num in nums:\\n            if num <= k:\\n                last_k += 1\\n                while last_k in nums:\\n                    last_k += 1\\n                min_sum += last_k\\n                min_sum -= num\\n        \\n        return min_sum\\n\\n```\\n---\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n\\t\\t\"\"\"\\n        1. calc min sum via arithmetic sum: min_sum = (k + 1)k // 2\\n        2. remove present elements <= k from min_sum + count present nums <= k\\n        3. add k - present_in_nums elements after k\\n        \\n        ex. [1,3] k=3\\n        1. min_sum = (1 + 3) * 3 // 2 = 6\\n        2. 1 2 3, remove 1,3 -> min_sum = 2\\n        3. min_sum + 4 (which is k + 1) + 5 (which is k + 2) -> 11\\n        \"\"\"\\n        \\n        nums.sort()\\n        min_sum = (1 + k) * k // 2\\n        prev = 0\\n        for num in nums:\\n            if prev != num and num <= k:\\n                min_sum -= num # substract existing num from nums\\n                k += 1 # increase k, which is the next missing num value\\n                min_sum += k # add replaced num with the new missing num\\n            prev = num\\n        \\n        return min_sum\\n```\\n---\\nThis is good, but overcomplicated for the problem aka wrong direction, even though TC/SC is good..\\n\\n1. Dedupe and sort `nums`\\n2. Find n = k-th missing number value  via BS on missing numbers# sequence (https://leetcode.com/problems/kth-missing-positive-number/)\\n3. Do `(n + 1) * n // 2` and substract present in the nums numbers < n\\n\\nBut before BS, let\\'s do an ordinary loop:\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        missing nums#:   4     6\\n        idx:             0     1\\n        nums:            5     8\\n        missing: 1 2 3 4   6 7   9 -> 5 + k - missing nums#\\n        \\n        missing_nums: nums[idx] - idx - 1\\n        \"\"\"\\n        nums = sorted(list(set(nums)))\\n\\n        kth_missing_num = 0\\n        for i,num in enumerate(nums):\\n            if num - i - 1 >= k: # missing nums up to i\\n                kth_missing_num = num + k - (num - i - 1) - 1\\n                break\\n        if kth_missing_num == 0: # missing num is outside of the nums\\n            num = nums[-1]\\n            i = len(nums)\\n            kth_missing_num = num + k - (num - i - 1) - 1\\n\\n        n = kth_missing_num\\n        return (n + 1) * n // 2 - sum(nums[:i - 1 + 1])\\n```\\nNow optimized with BS:\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(list(set(nums))) # dedupe and sort\\n        left = 0\\n        right = len(nums)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] - mid - 1 >= k: # find idx -  where k will be located\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        n = nums[left - 1]  + k - (nums[left - 1] - (left - 1) - 1) # extract kth value\\n        return (n + 1) * n // 2 - sum(nums[:left - 1 + 1])\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        1. calc min sum via arithmetic sum: min_sum = (k + 1)k // 2\\n        2. remove present elements <= k from min_sum + count present nums <= k\\n        3. add k - present_in_nums elements after k\\n        \\n        ex. [1,3] k=3\\n        1. min_sum = (1 + 3) * 3 // 2 = 6\\n        2. 1 2 3, remove 1,3 -> min_sum = 2\\n        3. min_sum + 4 (which is k + 1) + 5 (which is k + 2) -> 11\\n        \"\"\"\\n\\n        nums = set(nums)\\n        min_sum = (1 + k) * k // 2\\n        last_k = k\\n        for num in nums:\\n            if num <= k:\\n                last_k += 1\\n                while last_k in nums:\\n                    last_k += 1\\n                min_sum += last_k\\n                min_sum -= num\\n        \\n        return min_sum\\n\\n```\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n\\t\\t\"\"\"\\n        1. calc min sum via arithmetic sum: min_sum = (k + 1)k // 2\\n        2. remove present elements <= k from min_sum + count present nums <= k\\n        3. add k - present_in_nums elements after k\\n        \\n        ex. [1,3] k=3\\n        1. min_sum = (1 + 3) * 3 // 2 = 6\\n        2. 1 2 3, remove 1,3 -> min_sum = 2\\n        3. min_sum + 4 (which is k + 1) + 5 (which is k + 2) -> 11\\n        \"\"\"\\n        \\n        nums.sort()\\n        min_sum = (1 + k) * k // 2\\n        prev = 0\\n        for num in nums:\\n            if prev != num and num <= k:\\n                min_sum -= num # substract existing num from nums\\n                k += 1 # increase k, which is the next missing num value\\n                min_sum += k # add replaced num with the new missing num\\n            prev = num\\n        \\n        return min_sum\\n```\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        missing nums#:   4     6\\n        idx:             0     1\\n        nums:            5     8\\n        missing: 1 2 3 4   6 7   9 -> 5 + k - missing nums#\\n        \\n        missing_nums: nums[idx] - idx - 1\\n        \"\"\"\\n        nums = sorted(list(set(nums)))\\n\\n        kth_missing_num = 0\\n        for i,num in enumerate(nums):\\n            if num - i - 1 >= k: # missing nums up to i\\n                kth_missing_num = num + k - (num - i - 1) - 1\\n                break\\n        if kth_missing_num == 0: # missing num is outside of the nums\\n            num = nums[-1]\\n            i = len(nums)\\n            kth_missing_num = num + k - (num - i - 1) - 1\\n\\n        n = kth_missing_num\\n        return (n + 1) * n // 2 - sum(nums[:i - 1 + 1])\\n```\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(list(set(nums))) # dedupe and sort\\n        left = 0\\n        right = len(nums)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] - mid - 1 >= k: # find idx -  where k will be located\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        n = nums[left - 1]  + k - (nums[left - 1] - (left - 1) - 1) # extract kth value\\n        return (n + 1) * n // 2 - sum(nums[:left - 1 + 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339891,
                "title": "o-n-time-complexity-n-k-n-k-1-2-n-numbers-which-present-in-nums-and-highest-no",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can definitely say that the k numbers we need will be amongst (n+k)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the required sum of the first unique k numbers, we first find sum of first (n+k) numbers.\\nThen now we need to subtract the (n) numbers which does exist in our given nums.\\n\\nso to find these numbers we first Subtract the numbers which are common in both n+k elements and nums.\\n\\nUsed unordered_set so that same number does not subtract again.\\n\\nnow we remove leftover numbers from (n+k) numbers from backside.    \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\n        long long ans = 1ll*(n+k)*(n+k+1)/2;\\n        // now have to remove n elements\\n\\n        int cnt=0;\\n        unordered_set<int> s;\\n\\n        for(int p=0;p<n;p++)\\n        {\\n            if(s.find(nums[p])==s.end() && nums[p] <= n+k)\\n            {\\n                ans = ans-nums[p];\\n                cnt++;\\n                s.insert(nums[p]);\\n            }\\n        }\\n\\n        int j=n+k;\\n\\n        while(cnt<n)\\n        {\\n            if(s.find(j)==s.end())\\n            {\\n                cnt++;\\n                ans = ans-j;\\n            }\\n\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\n        long long ans = 1ll*(n+k)*(n+k+1)/2;\\n        // now have to remove n elements\\n\\n        int cnt=0;\\n        unordered_set<int> s;\\n\\n        for(int p=0;p<n;p++)\\n        {\\n            if(s.find(nums[p])==s.end() && nums[p] <= n+k)\\n            {\\n                ans = ans-nums[p];\\n                cnt++;\\n                s.insert(nums[p]);\\n            }\\n        }\\n\\n        int j=n+k;\\n\\n        while(cnt<n)\\n        {\\n            if(s.find(j)==s.end())\\n            {\\n                cnt++;\\n                ans = ans-j;\\n            }\\n\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339393,
                "title": "simple-o-n-k-t-c-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // fill gaps\\n        long result = 0;\\n        long c = 1;\\n        for (int i : nums) {\\n            if (i > c) {\\n                while (c < i && k > 0) {\\n                    result += c;\\n                    c++;\\n                    k--;\\n                }\\n            }\\n            c = i+1;\\n        }\\n        \\n        // add the left overs\\n        while (k > 0) {\\n            result += c;\\n            c++;\\n            k--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // fill gaps\\n        long result = 0;\\n        long c = 1;\\n        for (int i : nums) {\\n            if (i > c) {\\n                while (c < i && k > 0) {\\n                    result += c;\\n                    c++;\\n                    k--;\\n                }\\n            }\\n            c = i+1;\\n        }\\n        \\n        // add the left overs\\n        while (k > 0) {\\n            result += c;\\n            c++;\\n            k--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331576,
                "title": "c-golang-greedy-sorting",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        long long sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            while(i < n - 1 && nums[i] == nums[i + 1]) i++;\\n            if(nums[i] <= k) {\\n                k++;\\n                sum += nums[i];\\n            }\\n        }\\n        return k * 1L * (k + 1) / 2 - sum;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimalKSum(nums []int, k int) int64 {\\n    sort.Ints(nums)\\n    var n int = len(nums)\\n    var sum int64 = 0\\n    for i := 0; i < n; i++ {\\n        for i < n - 1 && nums[i] == nums[i + 1] {i++}\\n        if nums[i] <= k {\\n            k++\\n            sum += int64(nums[i])\\n        }\\n    }\\n    return int64(k * (k + 1)) / 2 - sum\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        long long sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            while(i < n - 1 && nums[i] == nums[i + 1]) i++;\\n            if(nums[i] <= k) {\\n                k++;\\n                sum += nums[i];\\n            }\\n        }\\n        return k * 1L * (k + 1) / 2 - sum;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimalKSum(nums []int, k int) int64 {\\n    sort.Ints(nums)\\n    var n int = len(nums)\\n    var sum int64 = 0\\n    for i := 0; i < n; i++ {\\n        for i < n - 1 && nums[i] == nums[i + 1] {i++}\\n        if nums[i] <= k {\\n            k++\\n            sum += int64(nums[i])\\n        }\\n    }\\n    return int64(k * (k + 1)) / 2 - sum\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564932,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            },
            {
                "id": 1567107,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            },
            {
                "id": 1671646,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            },
            {
                "id": 1570813,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            },
            {
                "id": 1576484,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            },
            {
                "id": 1912453,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            }
        ]
    },
    {
        "title": "The Number of Users That Are Eligible for Discount",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 2023621,
                "content": [
                    {
                        "username": "SandeepSubbiah",
                        "content": "CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT\\nBEGIN\\n  RETURN (\\n      # Write your MySQL query statement below.\\n      select count(user_id) from Purchases where time_stamp >= startDate and time_stamp <= endDate and amount >= minAmount\\n  );\\nEND"
                    },
                    {
                        "username": "obsidianla",
                        "content": "why the function name have to be as \"getUserIDs\"? how do we know that? "
                    },
                    {
                        "username": "endccp",
                        "content": "Great question to practice creating function but not very clear. Don\\'t even know the function name as \"getUserIDs\" until I ran the case and got an error message."
                    },
                    {
                        "username": "Shanebabe",
                        "content": "this is not easy one.take a look at solutions,do you know where the getUserIDs come from ?"
                    },
                    {
                        "username": "user6797aV",
                        "content": "THIS IS NOT CLEAR AS HELL"
                    }
                ]
            },
            {
                "id": 2006116,
                "content": [
                    {
                        "username": "SandeepSubbiah",
                        "content": "CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT\\nBEGIN\\n  RETURN (\\n      # Write your MySQL query statement below.\\n      select count(user_id) from Purchases where time_stamp >= startDate and time_stamp <= endDate and amount >= minAmount\\n  );\\nEND"
                    },
                    {
                        "username": "obsidianla",
                        "content": "why the function name have to be as \"getUserIDs\"? how do we know that? "
                    },
                    {
                        "username": "endccp",
                        "content": "Great question to practice creating function but not very clear. Don\\'t even know the function name as \"getUserIDs\" until I ran the case and got an error message."
                    },
                    {
                        "username": "Shanebabe",
                        "content": "this is not easy one.take a look at solutions,do you know where the getUserIDs come from ?"
                    },
                    {
                        "username": "user6797aV",
                        "content": "THIS IS NOT CLEAR AS HELL"
                    }
                ]
            },
            {
                "id": 1989430,
                "content": [
                    {
                        "username": "SandeepSubbiah",
                        "content": "CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT\\nBEGIN\\n  RETURN (\\n      # Write your MySQL query statement below.\\n      select count(user_id) from Purchases where time_stamp >= startDate and time_stamp <= endDate and amount >= minAmount\\n  );\\nEND"
                    },
                    {
                        "username": "obsidianla",
                        "content": "why the function name have to be as \"getUserIDs\"? how do we know that? "
                    },
                    {
                        "username": "endccp",
                        "content": "Great question to practice creating function but not very clear. Don\\'t even know the function name as \"getUserIDs\" until I ran the case and got an error message."
                    },
                    {
                        "username": "Shanebabe",
                        "content": "this is not easy one.take a look at solutions,do you know where the getUserIDs come from ?"
                    },
                    {
                        "username": "user6797aV",
                        "content": "THIS IS NOT CLEAR AS HELL"
                    }
                ]
            },
            {
                "id": 1773377,
                "content": [
                    {
                        "username": "SandeepSubbiah",
                        "content": "CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT\\nBEGIN\\n  RETURN (\\n      # Write your MySQL query statement below.\\n      select count(user_id) from Purchases where time_stamp >= startDate and time_stamp <= endDate and amount >= minAmount\\n  );\\nEND"
                    },
                    {
                        "username": "obsidianla",
                        "content": "why the function name have to be as \"getUserIDs\"? how do we know that? "
                    },
                    {
                        "username": "endccp",
                        "content": "Great question to practice creating function but not very clear. Don\\'t even know the function name as \"getUserIDs\" until I ran the case and got an error message."
                    },
                    {
                        "username": "Shanebabe",
                        "content": "this is not easy one.take a look at solutions,do you know where the getUserIDs come from ?"
                    },
                    {
                        "username": "user6797aV",
                        "content": "THIS IS NOT CLEAR AS HELL"
                    }
                ]
            },
            {
                "id": 1758178,
                "content": [
                    {
                        "username": "SandeepSubbiah",
                        "content": "CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT\\nBEGIN\\n  RETURN (\\n      # Write your MySQL query statement below.\\n      select count(user_id) from Purchases where time_stamp >= startDate and time_stamp <= endDate and amount >= minAmount\\n  );\\nEND"
                    },
                    {
                        "username": "obsidianla",
                        "content": "why the function name have to be as \"getUserIDs\"? how do we know that? "
                    },
                    {
                        "username": "endccp",
                        "content": "Great question to practice creating function but not very clear. Don\\'t even know the function name as \"getUserIDs\" until I ran the case and got an error message."
                    },
                    {
                        "username": "Shanebabe",
                        "content": "this is not easy one.take a look at solutions,do you know where the getUserIDs come from ?"
                    },
                    {
                        "username": "user6797aV",
                        "content": "THIS IS NOT CLEAR AS HELL"
                    }
                ]
            }
        ]
    }
]