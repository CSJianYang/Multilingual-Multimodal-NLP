[
    {
        "title": "Time to Cross a Bridge",
        "question_content": "There are k workers who want to move n boxes from an old warehouse to a new one. You are given the two integers n and k, and a 2D integer array time of size k x 4 where time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].\nThe warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all k workers are waiting on the left side of the bridge. To move the boxes, the ith worker (0-indexed) can :\n\n\tCross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in leftToRighti minutes.\n\tPick a box from the old warehouse and return to the bridge in pickOldi minutes. Different workers can pick up their boxes simultaneously.\n\tCross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in rightToLefti minutes.\n\tPut the box in the new warehouse and return to the bridge in putNewi minutes. Different workers can put their boxes simultaneously.\n\nA worker i is less efficient than a worker j if either condition is met:\n\n\tleftToRighti + rightToLefti > leftToRightj + rightToLeftj\n\tleftToRighti + rightToLefti == leftToRightj + rightToLeftj and i > j\n\nThe following rules regulate the movement of the workers through the bridge :\n\n\tIf a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge.\n\tIf the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\n\tIf the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\n\nReturn the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\n&nbsp;\nExample 1:\n\nInput: n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]\nOutput: 6\nExplanation: \nFrom 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.\nFrom 1 to 2: worker 2 picks up a box from the old warehouse.\nFrom 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.\nFrom 6 to 7: worker 2 puts a box at the new warehouse.\nThe whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\nExample 2:\n\nInput: n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]\nOutput: 50\nExplanation: \nFrom 0 &nbsp;to 10: worker 1 crosses the bridge from the left bank to the right bank.\nFrom 10 to 20: worker 1 picks up a box from the old warehouse.\nFrom 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 11 to 20: worker 0 picks up a box from the old warehouse.\nFrom 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.\nFrom 30 to 40: worker 1 puts a box at the new warehouse.\nFrom 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 31 to 39: worker 0 puts a box at the new warehouse.\nFrom 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 40 to 49: worker 0 picks up a box from the old warehouse.\nFrom 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 50 to 58: worker 0 puts a box at the new warehouse.\nThe whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\n&nbsp;\nConstraints:\n\n\t1 <= n, k <= 104\n\ttime.length == k\n\ttime[i].length == 4\n\t1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000",
        "solutions": [
            {
                "id": 3016767,
                "title": "queue-simulation",
                "content": "We use 2 priority queues (based on the efficiency) to simulate workers queuing on both sides of the bridge (`bq_l` and `bq_r`).\\n\\nWe also use two sorted sets (based on the time) to simulate workers in the warehouses (`wh_l` and `wh_r`).\\n\\nFinally, `bridge_t` defines the time of the last crossing.\\n\\n- We \"wait\" till the bridge is available.\\n\\t- We just fast forward to the `bridge_t` time.\\n\\t- If no workers are waiting by the bridge, we advance `bridge_t` to the earliest time when some worker finishes in the warehouse.\\n- We move workers who have finished with boxes from the warehouse to the bridge queue.\\n- We pick the next worker to cross the bridge from bridge queues:\\n\\t- We advance the time of the last crossing.\\n\\t- If the worker is moving right-to-left, we decrease the number of boxes needed.\\n\\t- We move the worker into the warehouse queue (with added time) on the opposite side. \\n\\n**C++**\\n```cpp\\nint findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n    priority_queue<pair<int, int>> bq_l, bq_r;\\n    set<pair<int, int>> wh_l, wh_r;\\n    int bridge_t = 0;\\n    for (int i = 0; i < k; ++i)\\n        bq_l.push({time[i][0] + time[i][2], i});\\n    while (n || bq_r.size() + wh_r.size()) {\\n      while (!wh_l.empty() && begin(wh_l)->first <= bridge_t) {\\n          int i = begin(wh_l)->second;\\n          bq_l.push({time[i][0] + time[i][2], i});\\n          wh_l.erase(begin(wh_l));\\n      }\\n      while (!wh_r.empty() && begin(wh_r)->first <= bridge_t) {\\n          int i = begin(wh_r)->second;\\n          bq_r.push({time[i][0] + time[i][2], i});\\n          wh_r.erase(begin(wh_r));\\n      }\\n      if (!bq_r.empty()) {\\n          int i = bq_r.top().second; bq_r.pop();\\n          bridge_t += time[i][2];\\n          wh_l.insert({bridge_t + time[i][3], i});\\n      }\\n      else if (!bq_l.empty() && n) {     \\n          int i = bq_l.top().second; bq_l.pop();\\n          --n;\\n          bridge_t += time[i][0];\\n          wh_r.insert({bridge_t + time[i][1], i});        \\n      }\\n      else\\n          bridge_t = min(!wh_l.empty() && n ? begin(wh_l)->first : INT_MAX,\\n                         !wh_r.empty() ? begin(wh_r)->first : INT_MAX);\\n    }\\n    return bridge_t;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n    priority_queue<pair<int, int>> bq_l, bq_r;\\n    set<pair<int, int>> wh_l, wh_r;\\n    int bridge_t = 0;\\n    for (int i = 0; i < k; ++i)\\n        bq_l.push({time[i][0] + time[i][2], i});\\n    while (n || bq_r.size() + wh_r.size()) {\\n      while (!wh_l.empty() && begin(wh_l)->first <= bridge_t) {\\n          int i = begin(wh_l)->second;\\n          bq_l.push({time[i][0] + time[i][2], i});\\n          wh_l.erase(begin(wh_l));\\n      }\\n      while (!wh_r.empty() && begin(wh_r)->first <= bridge_t) {\\n          int i = begin(wh_r)->second;\\n          bq_r.push({time[i][0] + time[i][2], i});\\n          wh_r.erase(begin(wh_r));\\n      }\\n      if (!bq_r.empty()) {\\n          int i = bq_r.top().second; bq_r.pop();\\n          bridge_t += time[i][2];\\n          wh_l.insert({bridge_t + time[i][3], i});\\n      }\\n      else if (!bq_l.empty() && n) {     \\n          int i = bq_l.top().second; bq_l.pop();\\n          --n;\\n          bridge_t += time[i][0];\\n          wh_r.insert({bridge_t + time[i][1], i});        \\n      }\\n      else\\n          bridge_t = min(!wh_l.empty() && n ? begin(wh_l)->first : INT_MAX,\\n                         !wh_r.empty() ? begin(wh_r)->first : INT_MAX);\\n    }\\n    return bridge_t;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016947,
                "title": "c-java-python3-simulation",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/cd738c7122f758231c4f575936d09271343de490) for solutions of weekly 327. \\n\\n**Intuition**\\nHere, we maintain 4 prioirty queues. \\n1) `l` ready to join the queue `ll` once the time allows\\n2) `ll` ready to cross the bridge from left to right \\n3) `r` ready to join the queue `rr` once the time allows \\n4) `rr` ready to cross the bridge from right to left \\n\\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int ans = 0, free = 0; \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> l, r; \\n        priority_queue<pair<int, int>> ll, rr; \\n        for (int i = 0; i < time.size(); ++i) \\n            ll.emplace(time[i][0]+time[i][2], i); \\n        while (n || r.size() || rr.size()) {\\n            if (rr.empty() && (r.empty() || r.top().first>free) && (!n || ll.empty() && (l.empty() || l.top().first>free))) {\\n                int cand = INT_MAX; \\n                if (n && l.size()) cand = min(cand, l.top().first); \\n                if (r.size()) cand = min(cand, r.top().first); \\n                free = cand; \\n            }\\n            while (l.size() && l.top().first <= free) {\\n                auto [_, i] = l.top(); l.pop(); \\n                ll.emplace(time[i][0]+time[i][2], i); \\n            }\\n            while (r.size() && r.top().first <= free) {\\n                auto [_, i] = r.top(); r.pop(); \\n                rr.emplace(time[i][0]+time[i][2], i); \\n            }\\n            if (rr.size()) {\\n                auto [_, i] = rr.top(); rr.pop(); \\n                free += time[i][2]; \\n                if (n) l.emplace(free+time[i][3], i); \\n                else ans = max(ans, free); \\n            } else {\\n                auto [_, i] = ll.top(); ll.pop();\\n                free += time[i][0]; \\n                r.emplace(free+time[i][1], i); \\n                --n; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        int ans = 0, free = 0; \\n        PriorityQueue<int[]> l = new PriorityQueue<>((a, b)->(a[0]-b[0])); \\n        PriorityQueue<int[]> r = new PriorityQueue<>((a, b)->(a[0]-b[0])); \\n        PriorityQueue<int[]> ll = new PriorityQueue<>((a, b)->(a[0] != b[0] ? b[0]-a[0] : b[1]-a[1]));\\n        PriorityQueue<int[]> rr = new PriorityQueue<>((a, b)->(a[0] != b[0] ? b[0]-a[0] : b[1]-a[1])); \\n        for (int i = 0; i < time.length; ++i) \\n            ll.add(new int[]{time[i][0]+time[i][2], i}); \\n        while (n > 0 || r.size() > 0 || rr.size() > 0) {\\n            if (rr.isEmpty() && (r.isEmpty() || r.peek()[0] > free) && (n == 0 || ll.isEmpty() && (l.isEmpty() || l.peek()[0] > free))) {\\n                int cand = Integer.MAX_VALUE; \\n                if (n > 0 && l.size() > 0) cand = Math.min(cand, l.peek()[0]); \\n                if (r.size() > 0) cand = Math.min(cand, r.peek()[0]); \\n                free = cand; \\n            }\\n            while (l.size() > 0 && l.peek()[0] <= free) {\\n                int i = l.poll()[1]; \\n                ll.add(new int[] {time[i][0] + time[i][2], i}); \\n            }\\n            while (r.size() > 0 && r.peek()[0] <= free) {\\n                int i = r.poll()[1]; \\n                rr.add(new int[] {time[i][0] + time[i][2], i}); \\n            }\\n            if (rr.size() > 0) {\\n                int i = rr.poll()[1]; \\n                free += time[i][2]; \\n                if (n > 0) l.add(new int[] {free+time[i][3], i}); \\n                else ans = Math.max(ans, free); \\n            } else {\\n                int i = ll.poll()[1]; \\n                free += time[i][0]; \\n                r.add(new int[] {free+time[i][1], i}); \\n                --n; \\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        ans = free = 0 \\n        l, ll = [], []\\n        r, rr = [], []\\n        for i, (x, _, y, _) in enumerate(time): heappush(ll, (-x-y, -i))\\n        while n or r or rr: \\n            if not rr and (not r or r[0][0] > free) and (not n or not ll and (not l or l[0][0] > free)): \\n                cand = inf \\n                if n and l: cand = min(cand, l[0][0])\\n                if r: cand = min(cand, r[0][0])\\n                free = cand\\n                \\n            while r and r[0][0] <= free: \\n                _, i = heappop(r)\\n                heappush(rr, (-time[i][0] - time[i][2], -i))\\n\\n            while l and l[0][0] <= free: \\n                _, i = heappop(l)\\n                heappush(ll, (-time[i][0] - time[i][2], -i))\\n                \\n            if rr: \\n                _, i = heappop(rr)\\n                free += time[-i][2]\\n                if n: heappush(l, (free + time[-i][3], -i))\\n                else: ans = max(ans, free)\\n            else: \\n                _, i = heappop(ll)\\n                free += time[-i][0]\\n                heappush(r, (free + time[-i][1], -i))\\n                n -= 1\\n        return ans \\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int ans = 0, free = 0; \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> l, r; \\n        priority_queue<pair<int, int>> ll, rr; \\n        for (int i = 0; i < time.size(); ++i) \\n            ll.emplace(time[i][0]+time[i][2], i); \\n        while (n || r.size() || rr.size()) {\\n            if (rr.empty() && (r.empty() || r.top().first>free) && (!n || ll.empty() && (l.empty() || l.top().first>free))) {\\n                int cand = INT_MAX; \\n                if (n && l.size()) cand = min(cand, l.top().first); \\n                if (r.size()) cand = min(cand, r.top().first); \\n                free = cand; \\n            }\\n            while (l.size() && l.top().first <= free) {\\n                auto [_, i] = l.top(); l.pop(); \\n                ll.emplace(time[i][0]+time[i][2], i); \\n            }\\n            while (r.size() && r.top().first <= free) {\\n                auto [_, i] = r.top(); r.pop(); \\n                rr.emplace(time[i][0]+time[i][2], i); \\n            }\\n            if (rr.size()) {\\n                auto [_, i] = rr.top(); rr.pop(); \\n                free += time[i][2]; \\n                if (n) l.emplace(free+time[i][3], i); \\n                else ans = max(ans, free); \\n            } else {\\n                auto [_, i] = ll.top(); ll.pop();\\n                free += time[i][0]; \\n                r.emplace(free+time[i][1], i); \\n                --n; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        int ans = 0, free = 0; \\n        PriorityQueue<int[]> l = new PriorityQueue<>((a, b)->(a[0]-b[0])); \\n        PriorityQueue<int[]> r = new PriorityQueue<>((a, b)->(a[0]-b[0])); \\n        PriorityQueue<int[]> ll = new PriorityQueue<>((a, b)->(a[0] != b[0] ? b[0]-a[0] : b[1]-a[1]));\\n        PriorityQueue<int[]> rr = new PriorityQueue<>((a, b)->(a[0] != b[0] ? b[0]-a[0] : b[1]-a[1])); \\n        for (int i = 0; i < time.length; ++i) \\n            ll.add(new int[]{time[i][0]+time[i][2], i}); \\n        while (n > 0 || r.size() > 0 || rr.size() > 0) {\\n            if (rr.isEmpty() && (r.isEmpty() || r.peek()[0] > free) && (n == 0 || ll.isEmpty() && (l.isEmpty() || l.peek()[0] > free))) {\\n                int cand = Integer.MAX_VALUE; \\n                if (n > 0 && l.size() > 0) cand = Math.min(cand, l.peek()[0]); \\n                if (r.size() > 0) cand = Math.min(cand, r.peek()[0]); \\n                free = cand; \\n            }\\n            while (l.size() > 0 && l.peek()[0] <= free) {\\n                int i = l.poll()[1]; \\n                ll.add(new int[] {time[i][0] + time[i][2], i}); \\n            }\\n            while (r.size() > 0 && r.peek()[0] <= free) {\\n                int i = r.poll()[1]; \\n                rr.add(new int[] {time[i][0] + time[i][2], i}); \\n            }\\n            if (rr.size() > 0) {\\n                int i = rr.poll()[1]; \\n                free += time[i][2]; \\n                if (n > 0) l.add(new int[] {free+time[i][3], i}); \\n                else ans = Math.max(ans, free); \\n            } else {\\n                int i = ll.poll()[1]; \\n                free += time[i][0]; \\n                r.add(new int[] {free+time[i][1], i}); \\n                --n; \\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        ans = free = 0 \\n        l, ll = [], []\\n        r, rr = [], []\\n        for i, (x, _, y, _) in enumerate(time): heappush(ll, (-x-y, -i))\\n        while n or r or rr: \\n            if not rr and (not r or r[0][0] > free) and (not n or not ll and (not l or l[0][0] > free)): \\n                cand = inf \\n                if n and l: cand = min(cand, l[0][0])\\n                if r: cand = min(cand, r[0][0])\\n                free = cand\\n                \\n            while r and r[0][0] <= free: \\n                _, i = heappop(r)\\n                heappush(rr, (-time[i][0] - time[i][2], -i))\\n\\n            while l and l[0][0] <= free: \\n                _, i = heappop(l)\\n                heappush(ll, (-time[i][0] - time[i][2], -i))\\n                \\n            if rr: \\n                _, i = heappop(rr)\\n                free += time[-i][2]\\n                if n: heappush(l, (free + time[-i][3], -i))\\n                else: ans = max(ans, free)\\n            else: \\n                _, i = heappop(ll)\\n                free += time[-i][0]\\n                heappush(r, (free + time[-i][1], -i))\\n                n -= 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016806,
                "title": "priority-queue-simulation-organized-easy-to-understand",
                "content": "\\n# Approach\\nMaintain 4 priority queues:\\nleft - min efficiency on left\\nright - min efficiency on right\\nup - workers picking up boxes on right sorted by increasing time of completion\\ndown - workers putting down boxes on left sorted by increasing time of completion\\n# Complexity\\n- Time complexity:\\n$$O(NlogN)$$ \\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<pair<int, int>> left, right;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> up, down;\\n        for(int i = 0; i <  time.size(); i++) left.push({time[i][0] + time[i][2], i});\\n        int t = 0;\\n        while(n > 0){\\n            if(!right.empty()){\\n                auto x = right.top();\\n                right.pop();\\n                t += time[x.second][2];\\n                down.push({t + time[x.second][3], x.second});\\n            }\\n            else if(!left.empty()){\\n                auto x = left.top();\\n                left.pop();\\n                t += time[x.second][0];\\n                n--;                \\n                up.push({t + time[x.second][1], x.second});\\n            } else { \\n                if(up.empty()){\\n                    t= down.top().first;\\n                }   \\n                else if(down.empty()){\\n                    t = up.top().first;\\n                }\\n                else{\\n                    auto x = up.top(), y = down.top();\\n                    t = min(x.first, y.first);\\n                }\\n            }\\n            while(!up.empty() && up.top().first <= t) {\\n                auto x = up.top();\\n                up.pop();\\n                int i = x.second;\\n                right.push({time[i][0] + time[i][2], i});\\n            }\\n            while(!down.empty() && down.top().first <= t) {\\n                auto x = down.top();\\n                down.pop();\\n                int i = x.second;\\n                left.push({time[i][0] + time[i][2], i});\\n            }\\n        }\\n        while(!right.empty()){\\n            auto x = right.top();\\n            right.pop();\\n            \\n            t += time[x.second][2];\\n            while(!up.empty() && up.top().first <= t) {\\n                auto x = up.top();\\n                up.pop();\\n                int i = x.second;\\n                right.push({time[i][0] + time[i][2], i});\\n            }\\n        }\\n        while(!up.empty()){\\n            auto x = up.top();\\n            up.pop();\\n            t = max(t, x.first);\\n            int u = x.second;\\n            t += time[u][2];\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<pair<int, int>> left, right;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> up, down;\\n        for(int i = 0; i <  time.size(); i++) left.push({time[i][0] + time[i][2], i});\\n        int t = 0;\\n        while(n > 0){\\n            if(!right.empty()){\\n                auto x = right.top();\\n                right.pop();\\n                t += time[x.second][2];\\n                down.push({t + time[x.second][3], x.second});\\n            }\\n            else if(!left.empty()){\\n                auto x = left.top();\\n                left.pop();\\n                t += time[x.second][0];\\n                n--;                \\n                up.push({t + time[x.second][1], x.second});\\n            } else { \\n                if(up.empty()){\\n                    t= down.top().first;\\n                }   \\n                else if(down.empty()){\\n                    t = up.top().first;\\n                }\\n                else{\\n                    auto x = up.top(), y = down.top();\\n                    t = min(x.first, y.first);\\n                }\\n            }\\n            while(!up.empty() && up.top().first <= t) {\\n                auto x = up.top();\\n                up.pop();\\n                int i = x.second;\\n                right.push({time[i][0] + time[i][2], i});\\n            }\\n            while(!down.empty() && down.top().first <= t) {\\n                auto x = down.top();\\n                down.pop();\\n                int i = x.second;\\n                left.push({time[i][0] + time[i][2], i});\\n            }\\n        }\\n        while(!right.empty()){\\n            auto x = right.top();\\n            right.pop();\\n            \\n            t += time[x.second][2];\\n            while(!up.empty() && up.top().first <= t) {\\n                auto x = up.top();\\n                up.pop();\\n                int i = x.second;\\n                right.push({time[i][0] + time[i][2], i});\\n            }\\n        }\\n        while(!up.empty()){\\n            auto x = up.top();\\n            up.pop();\\n            t = max(t, x.first);\\n            int u = x.second;\\n            t += time[u][2];\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017656,
                "title": "python-simulation",
                "content": "Use 2 priority queues (based on the efficiency) to simulate workers queuing on both sides of the bridge (l and r).\\n\\nUse 2 priority queues (based on the time) to simulate workers in the warehouses (ll and rr).\\n\\nFinally, t defines the time of the last crossing.\\n\\nWe \"wait\" till the bridge is available.\\n- We move workers to the bridge queue.\\n- We pick the next worker to cross the bridge from bridge queues:\\n- We advance the time of the last crossing.\\n- If the worker is moving right-to-left, we decrease the number of boxes needed.\\n- We move the worker into the warehouse queue (with added time) on the opposite side.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    # l: (-(leftToRight + rightToLeft), -i), waiting on the left side, sort by efficiency\\n    # r: (-(leftToRight + rightToLeft), -i), waiting on the right side, sort by efficiency\\n    # ll: (time, i), on what time can move to l from new warehouse\\n    # rr: (time, i), on what time can move to r from old warehouse\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        ll, l, r, rr = list(), list(), list(), list()\\n        for i, (a, _, c, _) in enumerate(time):\\n            heapq.heappush(l, (-a - c, -i))\\n\\n        t = 0\\n        while n:\\n            while ll and ll[0][0] <= t:\\n                _, i = heapq.heappop(ll)\\n                heapq.heappush(l, (-time[i][0] - time[i][2], -i))\\n            while rr and rr[0][0] <= t:\\n                _, i = heapq.heappop(rr)\\n                heapq.heappush(r, (-time[i][0] - time[i][2], -i))\\n\\n            if r:\\n                _, i = heapq.heappop(r)\\n                t += time[-i][2]\\n                heapq.heappush(ll, (t + time[-i][3], -i))\\n                n -= 1\\n            elif l and n > len(r) + len(rr):\\n                _, i = heapq.heappop(l)\\n                t += time[-i][0]\\n                heapq.heappush(rr, (t + time[-i][1], -i))\\n            else:\\n                x = ll[0][0] if ll and n > len(r) + len(rr) else float(\\'inf\\')\\n                y = rr[0][0] if rr else float(\\'inf\\')\\n                t = min(x, y)\\n        return t\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # l: (-(leftToRight + rightToLeft), -i), waiting on the left side, sort by efficiency\\n    # r: (-(leftToRight + rightToLeft), -i), waiting on the right side, sort by efficiency\\n    # ll: (time, i), on what time can move to l from new warehouse\\n    # rr: (time, i), on what time can move to r from old warehouse\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        ll, l, r, rr = list(), list(), list(), list()\\n        for i, (a, _, c, _) in enumerate(time):\\n            heapq.heappush(l, (-a - c, -i))\\n\\n        t = 0\\n        while n:\\n            while ll and ll[0][0] <= t:\\n                _, i = heapq.heappop(ll)\\n                heapq.heappush(l, (-time[i][0] - time[i][2], -i))\\n            while rr and rr[0][0] <= t:\\n                _, i = heapq.heappop(rr)\\n                heapq.heappush(r, (-time[i][0] - time[i][2], -i))\\n\\n            if r:\\n                _, i = heapq.heappop(r)\\n                t += time[-i][2]\\n                heapq.heappush(ll, (t + time[-i][3], -i))\\n                n -= 1\\n            elif l and n > len(r) + len(rr):\\n                _, i = heapq.heappop(l)\\n                t += time[-i][0]\\n                heapq.heappush(rr, (t + time[-i][1], -i))\\n            else:\\n                x = ll[0][0] if ll and n > len(r) + len(rr) else float(\\'inf\\')\\n                y = rr[0][0] if rr else float(\\'inf\\')\\n                t = min(x, y)\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017955,
                "title": "2-heaps-only-shorter-and-sweeter",
                "content": "**Idea:**\\nThe idea is to start thinking of each worker as a thread/process as in OS theory.\\n\\n**At any point in time, we need to answer two questions:**\\n1. Which workers are ready to cross the bridge (either left to right or right to left)?\\n2. Among the workers who are ready, which worker crosses first?\\n\\n**If are able to answer these 2 questions, we know which worker to move across the bridge at any given point**. We can increment the time by that duration, and ask the same 2 questions again. We can continue this process till all the boxes are moved to destination.\\n\\n**Approach**:\\n2nd question is easy to answer: **At a given point, if we know who all are ready. We can prioritize based on criterion mentioned in the problem statement.**\\n1. If there is any worker ready on right side, we choose. Only then, we choose left\\n2. Among workers on same side, choose the one with lowest efficiency.\\n\\nNow coming ot first question: **At a given point, if we know the time at which the worker would have finished picking/dumping the current box, and if this time is in past of the current time, they can now be moved to the ready workers queue**\\n \\n**Algo**:\\nMaintain 2 heaps for answering the 2 questions:\\n1. For question 1, maintain `blocked` heap. It stores all the workers and the time by which they will finish the picking/putting job and be ready to cross the bridge.\\n\\n2. For question 2, maintain `ready` heap. It stores all the workers who want to cross the bridge at given time.\\n\\n**Code:**\\n```\\n#define L   0\\n#define R   1\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& w) {\\n        /* workers still picking / putting boxes */\\n        /* highest priority worker is deciced by (in this order):\\n                1. lowest time they are ready to cross\\n        */\\n        priority_queue<vector<int>> blocked;\\n        \\n        /* workers ready to cross */\\n        /* highest priority worker is deciced by (in this order):\\n                1. right side, then left side\\n                2. lowest efficiency\\n                3. highest index\\n        */\\n        priority_queue<vector<int>> ready;\\n        \\n        /* add all workers as blocked */\\n        for (int i = 0; i < k; i++) {\\n            blocked.push({\\n                0,                 /* -(time to be ready) */\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* (keep this extra info handy in blocked heap for copying, \\n\\t\\t\\t\\t     not needed in this heap though) */\\n                L,                 /* side                  */ \\n                w[i][0] + w[i][2], /* efficiency inverse    */\\n                i                  /* worker index          */\\n            });\\n        }\\n        \\n        int t = 0;\\n        int np = n; /* number of boxes to be picked */\\n        \\n        /* in 1 loop iteration, cross only 1 worker */\\n        while (n) {\\n            \\n            /* By the time last worker crossed the bridge,\\n               no worker is ready to cross. We need to\\n               fast forward the time so that some worker is ready */\\n            if (ready.empty() && t < -blocked.top()[0]) {\\n                t = -blocked.top()[0];\\n            }\\n            \\n            /* move all the workers who are unblocked to ready queue */\\n            while (blocked.size() && t >= -blocked.top()[0]) {\\n                auto curblocked = blocked.top();\\n                int i = curblocked[3];\\n                blocked.pop();\\n                \\n                \\n                ready.push({\\n                    curblocked[1],  /* side                  */\\n                    curblocked[2],  /* efficiency inverse    */\\n                    i               /* worker index          */\\n                });\\n            }\\n            \\n            /* move 1 ready worker across bridge */\\n            auto curready = ready.top();\\n            int i = curready[2];\\n            int side = curready[0];\\n            ready.pop();\\n            \\n            /* increment time to the point they reach other side */\\n            if (side == R) { \\n                t += w[i][2];\\n                n--; /* 1 more box delivered */\\n            } else {\\n                /* if we have sent worker n times to pick up boxes, we need not send more */\\n                if (np == 0) continue;\\n                else np--;\\n                t += w[i][0];\\n            }\\n            \\n            blocked.push({\\n                (side == R) ? -(t + w[i][3]) : -(t + w[i][1]), /* -(time to become ready) */\\n                1 - side,       /* new side after crossing */\\n                curready[1],    /* efficiency inverse    */\\n                i               /* worker index          */\\n            });\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define L   0\\n#define R   1\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& w) {\\n        /* workers still picking / putting boxes */\\n        /* highest priority worker is deciced by (in this order):\\n                1. lowest time they are ready to cross\\n        */\\n        priority_queue<vector<int>> blocked;\\n        \\n        /* workers ready to cross */\\n        /* highest priority worker is deciced by (in this order):\\n                1. right side, then left side\\n                2. lowest efficiency\\n                3. highest index\\n        */\\n        priority_queue<vector<int>> ready;\\n        \\n        /* add all workers as blocked */\\n        for (int i = 0; i < k; i++) {\\n            blocked.push({\\n                0,                 /* -(time to be ready) */\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* (keep this extra info handy in blocked heap for copying, \\n\\t\\t\\t\\t     not needed in this heap though) */\\n                L,                 /* side                  */ \\n                w[i][0] + w[i][2], /* efficiency inverse    */\\n                i                  /* worker index          */\\n            });\\n        }\\n        \\n        int t = 0;\\n        int np = n; /* number of boxes to be picked */\\n        \\n        /* in 1 loop iteration, cross only 1 worker */\\n        while (n) {\\n            \\n            /* By the time last worker crossed the bridge,\\n               no worker is ready to cross. We need to\\n               fast forward the time so that some worker is ready */\\n            if (ready.empty() && t < -blocked.top()[0]) {\\n                t = -blocked.top()[0];\\n            }\\n            \\n            /* move all the workers who are unblocked to ready queue */\\n            while (blocked.size() && t >= -blocked.top()[0]) {\\n                auto curblocked = blocked.top();\\n                int i = curblocked[3];\\n                blocked.pop();\\n                \\n                \\n                ready.push({\\n                    curblocked[1],  /* side                  */\\n                    curblocked[2],  /* efficiency inverse    */\\n                    i               /* worker index          */\\n                });\\n            }\\n            \\n            /* move 1 ready worker across bridge */\\n            auto curready = ready.top();\\n            int i = curready[2];\\n            int side = curready[0];\\n            ready.pop();\\n            \\n            /* increment time to the point they reach other side */\\n            if (side == R) { \\n                t += w[i][2];\\n                n--; /* 1 more box delivered */\\n            } else {\\n                /* if we have sent worker n times to pick up boxes, we need not send more */\\n                if (np == 0) continue;\\n                else np--;\\n                t += w[i][0];\\n            }\\n            \\n            blocked.push({\\n                (side == R) ? -(t + w[i][3]) : -(t + w[i][1]), /* -(time to become ready) */\\n                1 - side,       /* new side after crossing */\\n                curready[1],    /* efficiency inverse    */\\n                i               /* worker index          */\\n            });\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016747,
                "title": "java-simulation-using-4-priorityqueues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimulate the process and keep updating the current time\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(k)) in the worst case\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k) for 4 priority queues\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        Worker[] worker = new Worker[k];\\n        for(int i=0;i<k;i++) {\\n            worker[i] = new Worker(i, time[i][0], time[i][1], time[i][2], time[i][3]);\\n        }\\n        //Four priority queues based on current position of the workers\\n        \\n        //Waiting at left side\\n        PriorityQueue<Worker> leftToRight = new PriorityQueue<Worker>(k);\\n        \\n        //Picking up old boxes\\n        PriorityQueue<Worker> pickOld = new PriorityQueue<Worker>(k, (a,b) -> a.time-b.time);\\n        \\n        //Waiting at Right Side\\n        PriorityQueue<Worker> rightToLeft = new PriorityQueue<Worker>(k);\\n        \\n        //Putting new boxes\\n        PriorityQueue<Worker> putNew = new PriorityQueue<Worker>(k, (a,b) -> a.time-b.time);\\n        \\n        //Initially all workers waiting at left\\n        for(int i=0;i<k;i++) {\\n            leftToRight.offer(worker[i]);\\n        }\\n        \\n        //Num boxes remaining\\n        int remaining = n;\\n        \\n        //Current time\\n        int currentTime = 0;\\n        \\n        \\n        while(remaining > 0) {\\n            //Move the workers from pickOld to rightToLeft or putNew to leftToRight if currentTime >= worker\\'s time to complete the task\\n            while(!pickOld.isEmpty() && pickOld.peek().time <= currentTime) {\\n                Worker w = pickOld.poll();\\n                rightToLeft.offer(w);\\n            }\\n            while(!putNew.isEmpty() && putNew.peek().time <= currentTime) {\\n                Worker w = putNew.poll();\\n                leftToRight.offer(w);\\n            }\\n            \\n            //Move worker on the bridge and update the worker\\'s time to complete the task\\n            if(!rightToLeft.isEmpty()) {\\n                Worker w = rightToLeft.poll();\\n                w.time = currentTime + w.RL + w.PN;\\n                putNew.offer(w);\\n                currentTime = currentTime + w.RL;\\n            } else if(!leftToRight.isEmpty()) {\\n                Worker w = leftToRight.poll();\\n                w.time = currentTime + w.LR + w.PO;\\n                pickOld.offer(w);\\n                remaining--;\\n                currentTime = currentTime + w.LR;\\n            } else {\\n                //Bridge is empty and no worker waiting, move currenttime to first person finishing the task\\n                currentTime = Integer.MAX_VALUE;\\n                if(!pickOld.isEmpty()) {\\n                    currentTime = Math.min(currentTime, pickOld.peek().time);\\n                }\\n                if(!putNew.isEmpty()) {\\n                    currentTime = Math.min(currentTime, putNew.peek().time);\\n                }\\n            }\\n        }\\n        //Now empty the right warehouse and keep workers moving\\n        while(!rightToLeft.isEmpty() || !pickOld.isEmpty()) {\\n            while(!pickOld.isEmpty() && pickOld.peek().time <= currentTime) {\\n                Worker w = pickOld.poll();\\n                rightToLeft.offer(w);\\n            }\\n            if(!rightToLeft.isEmpty()) {\\n                Worker w = rightToLeft.poll();\\n                w.time = currentTime + w.RL + w.PN;\\n                currentTime = currentTime + w.RL;\\n            } else {\\n                currentTime = pickOld.peek().time;\\n            }\\n        }\\n        return currentTime;\\n    }\\n    \\n    class Worker implements Comparable<Worker> {\\n        int index;\\n        int LR;\\n        int PO;\\n        int RL;\\n        int PN;\\n        int time;\\n        \\n        Worker(int i, int LR, int PO, int RL, int PN) {\\n            this.index = i;\\n            this.LR = LR;\\n            this.PO = PO;\\n            this.RL = RL;\\n            this.PN = PN;\\n            this.time = 0;\\n        }\\n        \\n        @Override\\n        public int compareTo(Worker w) {\\n            if(this.LR+this.RL!=w.LR+w.RL) {\\n                return w.LR+w.RL-this.LR-this.RL;\\n            }\\n            return w.index-this.index;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return index+\":\"+time+\":[\"+LR+\" \"+PO+\" \"+RL+\" \"+PN+\"]\";\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        Worker[] worker = new Worker[k];\\n        for(int i=0;i<k;i++) {\\n            worker[i] = new Worker(i, time[i][0], time[i][1], time[i][2], time[i][3]);\\n        }\\n        //Four priority queues based on current position of the workers\\n        \\n        //Waiting at left side\\n        PriorityQueue<Worker> leftToRight = new PriorityQueue<Worker>(k);\\n        \\n        //Picking up old boxes\\n        PriorityQueue<Worker> pickOld = new PriorityQueue<Worker>(k, (a,b) -> a.time-b.time);\\n        \\n        //Waiting at Right Side\\n        PriorityQueue<Worker> rightToLeft = new PriorityQueue<Worker>(k);\\n        \\n        //Putting new boxes\\n        PriorityQueue<Worker> putNew = new PriorityQueue<Worker>(k, (a,b) -> a.time-b.time);\\n        \\n        //Initially all workers waiting at left\\n        for(int i=0;i<k;i++) {\\n            leftToRight.offer(worker[i]);\\n        }\\n        \\n        //Num boxes remaining\\n        int remaining = n;\\n        \\n        //Current time\\n        int currentTime = 0;\\n        \\n        \\n        while(remaining > 0) {\\n            //Move the workers from pickOld to rightToLeft or putNew to leftToRight if currentTime >= worker\\'s time to complete the task\\n            while(!pickOld.isEmpty() && pickOld.peek().time <= currentTime) {\\n                Worker w = pickOld.poll();\\n                rightToLeft.offer(w);\\n            }\\n            while(!putNew.isEmpty() && putNew.peek().time <= currentTime) {\\n                Worker w = putNew.poll();\\n                leftToRight.offer(w);\\n            }\\n            \\n            //Move worker on the bridge and update the worker\\'s time to complete the task\\n            if(!rightToLeft.isEmpty()) {\\n                Worker w = rightToLeft.poll();\\n                w.time = currentTime + w.RL + w.PN;\\n                putNew.offer(w);\\n                currentTime = currentTime + w.RL;\\n            } else if(!leftToRight.isEmpty()) {\\n                Worker w = leftToRight.poll();\\n                w.time = currentTime + w.LR + w.PO;\\n                pickOld.offer(w);\\n                remaining--;\\n                currentTime = currentTime + w.LR;\\n            } else {\\n                //Bridge is empty and no worker waiting, move currenttime to first person finishing the task\\n                currentTime = Integer.MAX_VALUE;\\n                if(!pickOld.isEmpty()) {\\n                    currentTime = Math.min(currentTime, pickOld.peek().time);\\n                }\\n                if(!putNew.isEmpty()) {\\n                    currentTime = Math.min(currentTime, putNew.peek().time);\\n                }\\n            }\\n        }\\n        //Now empty the right warehouse and keep workers moving\\n        while(!rightToLeft.isEmpty() || !pickOld.isEmpty()) {\\n            while(!pickOld.isEmpty() && pickOld.peek().time <= currentTime) {\\n                Worker w = pickOld.poll();\\n                rightToLeft.offer(w);\\n            }\\n            if(!rightToLeft.isEmpty()) {\\n                Worker w = rightToLeft.poll();\\n                w.time = currentTime + w.RL + w.PN;\\n                currentTime = currentTime + w.RL;\\n            } else {\\n                currentTime = pickOld.peek().time;\\n            }\\n        }\\n        return currentTime;\\n    }\\n    \\n    class Worker implements Comparable<Worker> {\\n        int index;\\n        int LR;\\n        int PO;\\n        int RL;\\n        int PN;\\n        int time;\\n        \\n        Worker(int i, int LR, int PO, int RL, int PN) {\\n            this.index = i;\\n            this.LR = LR;\\n            this.PO = PO;\\n            this.RL = RL;\\n            this.PN = PN;\\n            this.time = 0;\\n        }\\n        \\n        @Override\\n        public int compareTo(Worker w) {\\n            if(this.LR+this.RL!=w.LR+w.RL) {\\n                return w.LR+w.RL-this.LR-this.RL;\\n            }\\n            return w.index-this.index;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return index+\":\"+time+\":[\"+LR+\" \"+PO+\" \"+RL+\" \"+PN+\"]\";\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016733,
                "title": "java-4-heaps-explained",
                "content": "The idea behind this solution is straight forward: `Simulate the process and see how long it would take`.\\n- Use the heap to maintain the waiting list of bridge. \\n- Use another heap to maintian the list of workers that will enter the wailing list\\n\\nThe core logic of the code is the for-loop. The for loop does following things:\\n* Update the bright waiting list.\\n* Pick a worker to pass the bridge.\\n* Advance time.\\n* Update the count of boxes needed to be moved.\\n\\t* I choose to update the count of boxes when a worker returned to left river bank because it will be easier to compute the time we want.\\n\\nThere are some corner cases worth noticing:\\n* When there are enough workers on the right bank, workers on left side **should not** pass the bridhgt.\\n* When there are no workers waiting to cross the bridge on both side, we should move the time to the next moment that there could be a worker waiting to cross the bridge.\\n\\nOverflow check:\\n* The time cos to move a box is at most 4 * 1000 (4 steps to move the box, each takes 1000 time).\\n* There are at most 1e4 boxes. So the total time is at most 4e7. \\n* So we are safe to store the total time.\\n\\n```java\\nclass Solution {\\n  // worker at rightside always moves first\\n  // two heap to maintain the waiting list on river bank\\n  // two heap to maintain the worker list that is puting boxes.\\n  \\n  // total time max: 4e3*e4 = 4e7\\n  private static final boolean debug = false;\\n  \\n  public int findCrossingTime(int n, int k, int[][] time) {\\n    PriorityQueue<Integer> lBank = new PriorityQueue<>((a, b) -> {\\n      int[] ta = time[a], tb = time[b];\\n      int ca = ta[0] + ta[2], cb = tb[0] + tb[2];\\n      if (ca == cb) return b - a; // larger index cross first\\n      return cb - ca; // larger cross time cross first.\\n    });\\n    PriorityQueue<Integer> rBank = new PriorityQueue<>((a, b) -> {\\n      int[] ta = time[a], tb = time[b];\\n      int ca = ta[0] + ta[2], cb = tb[0] + tb[2];\\n      if (ca == cb) return b - a; // larger index cross first\\n      return cb - ca; // larger cross time cross first.\\n    });\\n    \\n    \\n    // 0 -> time of the worker will be waiting to cross the bridge, 1 ->idx\\n    PriorityQueue<int[]> lWorker = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    PriorityQueue<int[]> rWorker = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    \\n    // initally, all at left bank\\n    for (int i = 0; i < k; i++) lBank.add(i);\\n    \\n    int curTime = 0;\\n    while (n > 0) {\\n      // process worker.\\n      while (!lWorker.isEmpty() && lWorker.peek()[0] <= curTime) lBank.add(lWorker.poll()[1]);\\n      while (!rWorker.isEmpty() && rWorker.peek()[0] <= curTime) rBank.add(rWorker.poll()[1]);\\n      \\n      int worker = -1;\\n      if (debug) System.out.println(curTime + \" \" + lBank);\\n      if (debug) System.out.println(curTime + \" \" + rBank);\\n      if (!rBank.isEmpty()) {\\n        // right side can pass. A box will be put.\\n        worker = rBank.poll();\\n        int t[] = time[worker];\\n        lWorker.add(new int[]{curTime + t[2] + t[3], worker});\\n        curTime += t[2]; // right to left.\\n        \\n        n--;\\n      } else if (!lBank.isEmpty() && (n > rBank.size() + rWorker.size())) {\\n        // left side can pass.\\n        // left side only pass when there are more boxes.\\n        worker = lBank.poll();\\n        int t[] = time[worker];\\n        rWorker.add(new int[]{curTime + t[0] + t[1], worker});\\n        curTime += t[0]; // left to right.\\n      } else if (n == rBank.size() + rWorker.size()) {\\n        curTime = rWorker.peek()[0];\\n      } else {\\n        // if still empty, advance time.\\n        int nxt;\\n        if (rWorker.isEmpty()) nxt = lWorker.peek()[0];\\n        else if (lWorker.isEmpty()) nxt = rWorker.peek()[0];\\n        else nxt = Math.min(lWorker.peek()[0], rWorker.peek()[0]);\\n        \\n        curTime = nxt;\\n      }\\n      \\n      if (debug) System.out.println(curTime + \", \" + worker + \" n: \" + n);\\n    }\\n    \\n    return curTime;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n  // worker at rightside always moves first\\n  // two heap to maintain the waiting list on river bank\\n  // two heap to maintain the worker list that is puting boxes.\\n  \\n  // total time max: 4e3*e4 = 4e7\\n  private static final boolean debug = false;\\n  \\n  public int findCrossingTime(int n, int k, int[][] time) {\\n    PriorityQueue<Integer> lBank = new PriorityQueue<>((a, b) -> {\\n      int[] ta = time[a], tb = time[b];\\n      int ca = ta[0] + ta[2], cb = tb[0] + tb[2];\\n      if (ca == cb) return b - a; // larger index cross first\\n      return cb - ca; // larger cross time cross first.\\n    });\\n    PriorityQueue<Integer> rBank = new PriorityQueue<>((a, b) -> {\\n      int[] ta = time[a], tb = time[b];\\n      int ca = ta[0] + ta[2], cb = tb[0] + tb[2];\\n      if (ca == cb) return b - a; // larger index cross first\\n      return cb - ca; // larger cross time cross first.\\n    });\\n    \\n    \\n    // 0 -> time of the worker will be waiting to cross the bridge, 1 ->idx\\n    PriorityQueue<int[]> lWorker = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    PriorityQueue<int[]> rWorker = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    \\n    // initally, all at left bank\\n    for (int i = 0; i < k; i++) lBank.add(i);\\n    \\n    int curTime = 0;\\n    while (n > 0) {\\n      // process worker.\\n      while (!lWorker.isEmpty() && lWorker.peek()[0] <= curTime) lBank.add(lWorker.poll()[1]);\\n      while (!rWorker.isEmpty() && rWorker.peek()[0] <= curTime) rBank.add(rWorker.poll()[1]);\\n      \\n      int worker = -1;\\n      if (debug) System.out.println(curTime + \" \" + lBank);\\n      if (debug) System.out.println(curTime + \" \" + rBank);\\n      if (!rBank.isEmpty()) {\\n        // right side can pass. A box will be put.\\n        worker = rBank.poll();\\n        int t[] = time[worker];\\n        lWorker.add(new int[]{curTime + t[2] + t[3], worker});\\n        curTime += t[2]; // right to left.\\n        \\n        n--;\\n      } else if (!lBank.isEmpty() && (n > rBank.size() + rWorker.size())) {\\n        // left side can pass.\\n        // left side only pass when there are more boxes.\\n        worker = lBank.poll();\\n        int t[] = time[worker];\\n        rWorker.add(new int[]{curTime + t[0] + t[1], worker});\\n        curTime += t[0]; // left to right.\\n      } else if (n == rBank.size() + rWorker.size()) {\\n        curTime = rWorker.peek()[0];\\n      } else {\\n        // if still empty, advance time.\\n        int nxt;\\n        if (rWorker.isEmpty()) nxt = lWorker.peek()[0];\\n        else if (lWorker.isEmpty()) nxt = rWorker.peek()[0];\\n        else nxt = Math.min(lWorker.peek()[0], rWorker.peek()[0]);\\n        \\n        curTime = nxt;\\n      }\\n      \\n      if (debug) System.out.println(curTime + \", \" + worker + \" n: \" + n);\\n    }\\n    \\n    return curTime;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016800,
                "title": "simulation-with-3-queues-bridge-left-right-side-and-events-queue",
                "content": "# Intuition/Ideas\\nSimulate with 3 queues:\\n- Time-series queue (based on timestamp)\\n- Bridge left and right side waiting queue (based on their efficiency)\\n\\nDefine 4 events\\n- waitL: complete putNew and join bridge left side queue\\n- waitR: complete pickOld and join bridge right side queue\\n- reachL: complete rightToLeft and start putNew\\n- reachR: complete leftToRight and start pick old\\n\\nProcess each event accordingly, needs to be careful that when processing the time series, we need to process all the events happened at the same timestamp at once.\\n\\n#### Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        priority = [(time[i][0] + time[i][2], i) for i in range(k)]\\n        priority.sort()\\n        efficiency = [0] * k\\n        for i in range(k):\\n            efficiency[priority[i][1]] = -i\\n        \\n        left_queue, right_queue = [], []\\n        for i in range(k):\\n            heappush(left_queue, (efficiency[i], i))\\n        \\n        # Events: \"waitL, waitR, reachL, reachR\"\\n        time_series = []\\n        collected_box = [0, 0] # pending_box, total_box counts\\n        occupied = False\\n        timing = 0\\n                \\n        def process_bridge(timing):\\n            occupied = True\\n            if right_queue:\\n                _, worker = heappop(right_queue)\\n                heappush(time_series, (timing + time[worker][2], 2, worker))\\n            elif left_queue and collected_box[0] < n:\\n                collected_box[0] += 1\\n                _, worker = heappop(left_queue)\\n                heappush(time_series, (timing + time[worker][0], 3, worker))\\n            else:\\n                occupied = False\\n            return occupied\\n                \\n        def process_time_series(timing, events, worker, occupied):\\n            # print(timing, \"waitL, waitR, reachL, reachR\".split(\\', \\')[events], worker)\\n            if events == 0:\\n                heappush(left_queue, (efficiency[worker], worker))\\n            elif events == 1:\\n                heappush(right_queue, (efficiency[worker], worker))\\n            elif events == 2:\\n                collected_box[1] += 1\\n                if collected_box[1] == n:\\n                    return True, occupied\\n                heappush(time_series, (timing + time[worker][3], 0, worker))\\n            else:\\n                heappush(time_series, (timing + time[worker][1], 1, worker))\\n            if events >= 2:\\n                occupied = process_bridge(timing)\\n            return False, occupied\\n        \\n        while True:\\n            if not occupied:\\n                occupied = process_bridge(timing)\\n\\n            if time_series:\\n                timing, events, worker = heappop(time_series)\\n                complete, occupied = process_time_series(timing, events, worker, occupied)\\n                if complete:\\n                    return timing\\n                while time_series:\\n                    ctiming, events, worker = heappop(time_series)\\n                    if ctiming == timing:\\n                        complete, occupied = process_time_series(timing, events, worker, occupied)\\n                        if complete:\\n                            return timing\\n                    else:\\n                        heappush(time_series, (ctiming, events, worker))\\n                        break\\n            \\n        return -1\\n                    \\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        priority = [(time[i][0] + time[i][2], i) for i in range(k)]\\n        priority.sort()\\n        efficiency = [0] * k\\n        for i in range(k):\\n            efficiency[priority[i][1]] = -i\\n        \\n        left_queue, right_queue = [], []\\n        for i in range(k):\\n            heappush(left_queue, (efficiency[i], i))\\n        \\n        # Events: \"waitL, waitR, reachL, reachR\"\\n        time_series = []\\n        collected_box = [0, 0] # pending_box, total_box counts\\n        occupied = False\\n        timing = 0\\n                \\n        def process_bridge(timing):\\n            occupied = True\\n            if right_queue:\\n                _, worker = heappop(right_queue)\\n                heappush(time_series, (timing + time[worker][2], 2, worker))\\n            elif left_queue and collected_box[0] < n:\\n                collected_box[0] += 1\\n                _, worker = heappop(left_queue)\\n                heappush(time_series, (timing + time[worker][0], 3, worker))\\n            else:\\n                occupied = False\\n            return occupied\\n                \\n        def process_time_series(timing, events, worker, occupied):\\n            # print(timing, \"waitL, waitR, reachL, reachR\".split(\\', \\')[events], worker)\\n            if events == 0:\\n                heappush(left_queue, (efficiency[worker], worker))\\n            elif events == 1:\\n                heappush(right_queue, (efficiency[worker], worker))\\n            elif events == 2:\\n                collected_box[1] += 1\\n                if collected_box[1] == n:\\n                    return True, occupied\\n                heappush(time_series, (timing + time[worker][3], 0, worker))\\n            else:\\n                heappush(time_series, (timing + time[worker][1], 1, worker))\\n            if events >= 2:\\n                occupied = process_bridge(timing)\\n            return False, occupied\\n        \\n        while True:\\n            if not occupied:\\n                occupied = process_bridge(timing)\\n\\n            if time_series:\\n                timing, events, worker = heappop(time_series)\\n                complete, occupied = process_time_series(timing, events, worker, occupied)\\n                if complete:\\n                    return timing\\n                while time_series:\\n                    ctiming, events, worker = heappop(time_series)\\n                    if ctiming == timing:\\n                        complete, occupied = process_time_series(timing, events, worker, occupied)\\n                        if complete:\\n                            return timing\\n                    else:\\n                        heappush(time_series, (ctiming, events, worker))\\n                        break\\n            \\n        return -1\\n                    \\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017291,
                "title": "4-priority-queues-simulation-easy-explaination",
                "content": "\\n# Intuition\\nwe can maintain 4 queues at both end for the selection of less efficienct worker\\n1. leftpq contains workers waiting at left end\\n2. right pq contains workers waiting at right end, \\n3. leftslave contains workers who  are currently putting boxes and we can free them as soon as there putting time finishes\\n4. right slave contains workers who currently picking boxes and we will free them as soon as time passes\\n\\n# Approach\\n1. At each time instance we free the workers who have completed loading or unloading\\n2. Then at right end we check if some worker is currently free or not \\n3. If there is no worker on left we check if a worker on left is free or not\\n4. If no worker is free on either end means our current time didn\\'t change therefore we will just change our current time to \\n\\n\\ncould not submit it during the contest as i missed the line that we need to remove the unloading time of the last worker and kept debugging\\n\\n# Code\\n```\\nclass Compare{\\n    public:\\n     bool operator()(vector<int> &a , vector<int> &b){\\n        if(a[0]+a[2] !=b[0]+b[2]) return a[0]+a[2] < b[0]+b[2];\\n        return a[4] < b[4];\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int index=0;\\n        priority_queue<vector<int> , vector<vector<int> > , Compare > leftpq , rightpq;\\n        for(int i=0;i<time.size();i++){\\n            vector<int>t = time[i];\\n            t.push_back(i);//index will help us in  left and right slave priority queue as we can then just store the release time and the index in those queues\\n            leftpq.push(t);\\n        }\\n        \\n        int currtime=0,last=0;\\n        priority_queue<pair<int,int> , vector<pair<int,int> > , greater<pair<int,int> > >leftslave , rightslave; \\n        \\n        while(leftpq.size() or leftslave.size() or rightpq.size() or rightslave.size()){\\n            int prevtime = currtime;\\n            while(rightslave.size() and rightslave.top().first<=currtime){\\n                //release the workers who have finished loading \\n                auto e = rightslave.top();rightslave.pop();\\n                vector<int> v = time[e.second];\\n                v.push_back(e.second);\\n                rightpq.push(v);\\n            }\\n            while(leftslave.size() and leftslave.top().first <= currtime){\\n                //remove the workers who finished unloading\\n                    auto e = leftslave.top();leftslave.pop();\\n                    vector<int> v = time[e.second];\\n                    v.push_back(e.second);\\n                    leftpq.push(v);\\n                    last = e.first;\\n                    index=e.second;\\n            }\\n\\n            if(rightpq.size()){\\n                //check if a worker is waiting at right side of bridge\\n                auto e = rightpq.top();rightpq.pop();\\n                currtime += e[2];\\n                leftslave.push({currtime+e[3],e[4]});\\n            }else{\\n                //else check if a box is present and a worker is present on the left side\\n                if(n>0 and leftpq.size()){\\n                n--;\\n                auto e= leftpq.top();leftpq.pop();\\n                currtime += e[0];\\n                rightslave.push({currtime+e[1],e[4]});\\n                }\\n            }\\n            //if no worker made a move fastforward the time to the instance when some worker gets free from loading or unloading\\n            if(currtime==prevtime){\\n              if(!leftslave.size() and !rightslave.size()) break;\\n              if(leftslave.size() and rightslave.size()) currtime = min(leftslave.top().first,rightslave.top().first);\\n              else if (leftslave.size() and !rightslave.size()) currtime = leftslave.top().first;\\n              else if (rightslave.size() and !leftslave.size()) currtime = rightslave.top().first; \\n            }\\n        }\\n    \\n        return last-time[index][3];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Compare{\\n    public:\\n     bool operator()(vector<int> &a , vector<int> &b){\\n        if(a[0]+a[2] !=b[0]+b[2]) return a[0]+a[2] < b[0]+b[2];\\n        return a[4] < b[4];\\n    }\\n};\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int index=0;\\n        priority_queue<vector<int> , vector<vector<int> > , Compare > leftpq , rightpq;\\n        for(int i=0;i<time.size();i++){\\n            vector<int>t = time[i];\\n            t.push_back(i);//index will help us in  left and right slave priority queue as we can then just store the release time and the index in those queues\\n            leftpq.push(t);\\n        }\\n        \\n        int currtime=0,last=0;\\n        priority_queue<pair<int,int> , vector<pair<int,int> > , greater<pair<int,int> > >leftslave , rightslave; \\n        \\n        while(leftpq.size() or leftslave.size() or rightpq.size() or rightslave.size()){\\n            int prevtime = currtime;\\n            while(rightslave.size() and rightslave.top().first<=currtime){\\n                //release the workers who have finished loading \\n                auto e = rightslave.top();rightslave.pop();\\n                vector<int> v = time[e.second];\\n                v.push_back(e.second);\\n                rightpq.push(v);\\n            }\\n            while(leftslave.size() and leftslave.top().first <= currtime){\\n                //remove the workers who finished unloading\\n                    auto e = leftslave.top();leftslave.pop();\\n                    vector<int> v = time[e.second];\\n                    v.push_back(e.second);\\n                    leftpq.push(v);\\n                    last = e.first;\\n                    index=e.second;\\n            }\\n\\n            if(rightpq.size()){\\n                //check if a worker is waiting at right side of bridge\\n                auto e = rightpq.top();rightpq.pop();\\n                currtime += e[2];\\n                leftslave.push({currtime+e[3],e[4]});\\n            }else{\\n                //else check if a box is present and a worker is present on the left side\\n                if(n>0 and leftpq.size()){\\n                n--;\\n                auto e= leftpq.top();leftpq.pop();\\n                currtime += e[0];\\n                rightslave.push({currtime+e[1],e[4]});\\n                }\\n            }\\n            //if no worker made a move fastforward the time to the instance when some worker gets free from loading or unloading\\n            if(currtime==prevtime){\\n              if(!leftslave.size() and !rightslave.size()) break;\\n              if(leftslave.size() and rightslave.size()) currtime = min(leftslave.top().first,rightslave.top().first);\\n              else if (leftslave.size() and !rightslave.size()) currtime = leftslave.top().first;\\n              else if (rightslave.size() and !leftslave.size()) currtime = rightslave.top().first; \\n            }\\n        }\\n    \\n        return last-time[index][3];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105756,
                "title": "python-3-priority-queue-heap-with-thought-process-and-full-explanation",
                "content": "This is a really hard and interesting problem, which took me many hours to solve. I could only get the final code (with all the conditions) after multiple attemps. The hardest part is to get all the right conditions (other posted solutions do not seem to give explanations for their conditions).\\n\\nMy first solution is easier to come up with and has less conditions, but it gives TLE. I will present it first, then my final accepted solution.\\n\\n# TLE Solution\\n\\n**Variables:**\\n+ *timing*: keep track of the progress.\\n+ *left*: heap to store info of workers on the left of the bridge\\n+ *right*: heap to store info of workers on the right of the bridge\\n\\nInfo of each worker in *left* and *right* is the tuple (availableTime,-efficiency,-index), where *availableTime* is the time instance when the workers are ready to cross the bridge. *availableTime* is placed first so that heap will choose workers by the time workers are ready to cross the bridge before considering their efficiency and indices. For example, when the current time instance *timing* = 5, there are 2 workers on the right of the bridge: worker 0 is ready to cross at time instance 6 and worker 1 is ready at 5, then worker 1 will be chosen to cross the bridge, i.e. *availableTime* should be considered before efficiency and indices.\\n\\nThe variables are initialized as follows (which is straightforward):\\n```\\nleft,right = [],[] # (availableTime,-efficiency,-index)\\nfor i in range(k):\\n    heapq.heappush(left,(0,-time[i][0]-time[i][2],-i))\\ntiming = 0\\n```\\n**Approach**\\nObviously, we need a variable (*timing*) to keep track of time progress.\\nThere are 2 main processes for the workers (which should occur in the order listed below): \\n+ crossing the bridge from left to right (when there are workers on the left, i.e. *left* is not null; and there are boxes in the old warehouse, i.e. *n>0*; and there is no woker waiting on the right, i.e. there is no worker on the right (*right* is null) or the time instance the workers on the right ready to cross the bridge is greater than the current time instance (*timing<right[0][0])*), with the secondary process of picking up boxes from the old warehouse. This process is reflected by the code below:\\n```\\nwhile left and n>0 and (not right or timing<right[0][0]):\\n# all the workers with availableTime<=timing are ready to cross  \\n# the bridge and should be chosen by their efficiency, thus \\n# we need to update their availableTime to the current time \\n# instance (timing) so that the heap will work correctly \\n# by the next while loop.\\n    while left and left[0][0]<timing:\\n        _,effi,i = heapq.heappop(left)\\n        heapq.heappush(left,(timing,effi,i))\\n    avail,effi,i = heapq.heappop(left)\\n# we will need max(avail,timing) to update timing because, \\n# for example, the current time instance timing = 10 (note that, \\n# timing will only record the time instances workers finishing \\n# crossing bridge) and there is only one worker 0 but worker 0 \\n# is ready to cross the bridge from left to right at 11. \\n# timing will be updated to the time instance workers finish \\n# crossing bridge from left to right\\n    timing = max(avail,timing)+time[-i][0]\\n# push the workers to right with availableTime to cross bridge \\n# from right to left after picking up boxes\\n    heapq.heappush(right,(timing+time[-i][1],effi,i))\\n    n -= 1\\n```\\n+ crossing the bridge from right to left (when there are workers on the right, i.e. *right* is not null; and the workers on the right are waiting (*timing>=right[0][0]*) or there is no box left in the old warehouse (*n==0*) or there is no worker on the left (*left* is null)), with the secondary process of putting boxes in the new warehouse. This process is reflected by the code below:\\n```\\nwhile right and (timing>=right[0][0] or n==0 or not left):\\n# similar to the previous process, we need to \\n# update their availableTime.\\n    while right and right[0][0]<timing:\\n        _,effi,i = heapq.heappop(right)\\n        heapq.heappush(right,(timing,effi,i))\\n    avail,effi,i = heapq.heappop(right)\\n# timing will be updated to the time instance workers finish \\n# crossing bridge from right to left, using max(avail,timing)\\n#  similar to the previous process\\n    timing = max(avail,timing)+time[-i][2]\\n# push the workers to left with availableTime to cross bridge \\n# from left after putting boxes\\n    heapq.heappush(left,(timing+time[-i][3],effi,i))\\n```\\n*timing* will record the time instances workers finishing crossing bridge (left to right as well as right to left). It would record the instance of time at which the last worker reaches the left bank of the river after all n boxes have been taken from the old warehouse, thus we return *timing*.\\n\\n# TLE Python 3 Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n, k, time):\\n        left,right = [],[] # (availableTime,-efficiency,-index)\\n        for i in range(k):\\n            heapq.heappush(left,(0,-time[i][0]-time[i][2],-i))\\n        timing = 0\\n        while n>0:\\n            while left and n>0 and (not right or timing<right[0][0]):\\n                while left and left[0][0]<timing:\\n                    _,effi,i = heapq.heappop(left)\\n                    heapq.heappush(left,(timing,effi,i))\\n                avail,effi,i = heapq.heappop(left)\\n                timing = max(avail,timing)+time[-i][0]\\n                heapq.heappush(right,(timing+time[-i][1],effi,i))\\n                n -= 1\\n            while right and (timing>=right[0][0] or n==0 or not left):\\n                while right and right[0][0]<timing:\\n                    _,effi,i = heapq.heappop(right)\\n                    heapq.heappush(right,(timing,effi,i))\\n                avail,effi,i = heapq.heappop(right)\\n                timing = max(avail,timing)+time[-i][2]\\n                heapq.heappush(left,(timing+time[-i][3],effi,i))\\n        return timing\\n```\\n\\nThe previous code gives TLE because of the third nested while loops (inside the main while loop). To improve time complexity and avoid TLE, we need to get rid of the third while loop.\\n\\n# Accepted Solution\\n**Variables:**\\n+ *timing*: keep track of the progress.\\n+ *left*: heap to store info of workers on the left of bridge ready to cross the bridge\\n+ *right*: heap to store info of workers on the right of bridge ready to cross the bridge\\n\\nDifferent from the TLE code, *left* and *right* only contain workers who are ready and waiting to cross the bridge, i.e. *availableTime<=Timing* (in the previous code, *left* and *right* contain all the workers). Info of each worker in *left* and *right* is the tuple (-efficiency,-index,availableTime), where *availableTime* is now placed last. Since the workers in *left* and *right* are all ready to cross the bridge, they will be chosen by their efficiency then indices.\\n\\n+ *left0*: heap to reserve info of workers on the left of bridge after they put boxes in the new warehouse. When they are ready to cross the bridge, i.e. *availableTime<=timing*, they will be pushed to *left* and wait to cross the bridge.\\n+ *right0*: heap to reserve info of workers on the right of bridge after they pick up boxes from the old warehouse. When they are ready to cross the bridge, i.e. *availableTime<=timing*, they will be pushed to *right* and wait to cross the bridge.\\n\\nInfo of each worker in *left0* and *right0* is the tuple (availableTime,-index).\\n\\nThe variables are initialized as follows:\\n```\\nleft,right = [],[] # (-efficiency,-index,availableTime)\\nfor i in range(k):\\n    heapq.heappush(left,(-time[i][0]-time[i][2],-i,0))\\nleft0,right0 = [],[] # (availableTime,-index)\\ntiming = 0\\n```\\n**Approach**\\nThe 2 main processes are implemented by the codes as follows:\\n+ crossing the bridge from left to right: conditions of the first process is similar to the TLE code. Note that, here, right is always null due to the condition of the (while right:) loop in the next process.\\n```\\nwhile left and n>0 and (not right0 or timing<right0[0][0]):\\n    _,i,avail = heapq.heappop(left)\\n    timing = max(avail,timing)+time[-i][0]\\n    heapq.heappush(right0,(timing+time[-i][1],i))\\n    n -= 1\\n# we need to update left for each new time instance timing, \\n# i.e. move the workers who are ready from left0 to left. \\n# Function updateLeft will be explained later. \\n    self.updateLeft(timing,left,right,left0,right0,time,n)\\n```\\n+ crossing the bridge from right to left: \\n```\\n# we update right for the new time instance, i.e. \\n# move workers who are ready from right0 to right. \\n# Function updateRight will be explained later. \\nself.updateRight(timing,left,right,left0,right0,time,n)\\n# compare to the TLE code, condition (timing>=right[0][0] or n==0 or not left) \\n# is not used in the (while right:) loop because it is used in \\n# function updateRight. Note that, because of condition (while right:), \\n# right will always be null at start of each main loop (while n>0:).\\nwhile right:\\n    _,i,avail = heapq.heappop(right)\\n    timing = max(avail,timing)+time[-i][2]\\n    heapq.heappush(left0,(timing+time[-i][3],i))\\n# we need to update right for each new time instance. Note that, \\n# we need to update left before updating right.\\n    self.updateLeft(timing,left,right,left0,right0,time,n)\\n    self.updateRight(timing,left,right,left0,right0,time,n)\\n```\\n+ *updateLeft*: this function pushes workers from *left0* to *left* if they are ready to cross the bridge from the left of the bridge, i.e. *left0[0][0]<=timing*, in addition to the case when *left0[0][0]>timing* but *left* and *right* are null while: *right0* is null (there is no worker other than workers reserved in *left0*), or *right0* is not null and *left0[0][0]<right0[0][0]* (there are only workers reserved in *left0* and *right0*, and workers in *left0* are ready to cross the bridge earlier than workers in *right0*).\\n```\\ndef updateLeft(self,timing,left,right,left0,right0,time,n):\\n    while left0 and (left0[0][0]<=timing or (not left and not right and not right0) or (not left and not right and right0 and left0[0][0]<right0[0][0])):\\n        avail,i = heapq.heappop(left0)\\n        heapq.heappush(left,(-time[-i][0]-time[-i][2],i,max(avail,timing)))\\n```\\n+ *updateRight*: this function pushes workers from *right0* to *right* if they are ready to cross the bridge from the right of the bridge, i.e. *right0[0][0]<=timing*, in addition to the case when *right0[0][0]>timing* but *right* is null while: *n==0* (there is no box at the old warehouse and no worker is required to cross the bridge from left side), or *left* is null (there is no worker waiting to cross the bridge from left side at the current time instance).\\n```\\ndef updateRight(self,timing,left,right,left0,right0,time,n):\\n    while right0 and (right0[0][0]<=timing or (not right and (n==0 or not left))):\\n        avail,i = heapq.heappop(right0)\\n        heapq.heappush(right,(-time[-i][0]-time[-i][2],i,max(avail,timing)))\\n```\\n# Accepted Python 3 Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n, k, time):\\n        left,right = [],[] # (-efficiency,-index,availableTime)\\n        for i in range(k):\\n            heapq.heappush(left,(-time[i][0]-time[i][2],-i,0))\\n        left0,right0 = [],[] # (availableTime,-index)\\n        timing = 0\\n        while n>0:\\n            while left and n>0 and (not right0 or timing<right0[0][0]):\\n                _,i,avail = heapq.heappop(left)\\n                timing = max(avail,timing)+time[-i][0]\\n                heapq.heappush(right0,(timing+time[-i][1],i))\\n                n -= 1\\n                self.updateLeft(timing,left,right,left0,right0,time,n)\\n            self.updateRight(timing,left,right,left0,right0,time,n)\\n            while right:\\n                _,i,avail = heapq.heappop(right)\\n                timing = max(avail,timing)+time[-i][2]\\n                heapq.heappush(left0,(timing+time[-i][3],i))\\n                self.updateLeft(timing,left,right,left0,right0,time,n)\\n                self.updateRight(timing,left,right,left0,right0,time,n)\\n        return timing\\n\\n    def updateLeft(self,timing,left,right,left0,right0,time,n):\\n        while left0 and (left0[0][0]<=timing or (not left and not right and right0 and left0[0][0]<right0[0][0]) or (not left and not right and not right0)):\\n            avail,i = heapq.heappop(left0)\\n            heapq.heappush(left,(-time[-i][0]-time[-i][2],i,max(avail,timing)))\\n\\n    def updateRight(self,timing,left,right,left0,right0,time,n):\\n        while right0 and (right0[0][0]<=timing or (not right and (n==0 or not left))):\\n            avail,i = heapq.heappop(right0)\\n            heapq.heappush(right,(-time[-i][0]-time[-i][2],i,max(avail,timing)))\\n```\\n\\n**Notes:**\\nPlease note that the problem description is somewhat misleading. It states that: \"... after all n boxes have been put in the new warehouse\", but it actually should be (as shown by the examples): \"... after all n boxes have been taken from the old warehouse\".",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nleft,right = [],[] # (availableTime,-efficiency,-index)\\nfor i in range(k):\\n    heapq.heappush(left,(0,-time[i][0]-time[i][2],-i))\\ntiming = 0\\n```\n```\\nwhile left and n>0 and (not right or timing<right[0][0]):\\n# all the workers with availableTime<=timing are ready to cross  \\n# the bridge and should be chosen by their efficiency, thus \\n# we need to update their availableTime to the current time \\n# instance (timing) so that the heap will work correctly \\n# by the next while loop.\\n    while left and left[0][0]<timing:\\n        _,effi,i = heapq.heappop(left)\\n        heapq.heappush(left,(timing,effi,i))\\n    avail,effi,i = heapq.heappop(left)\\n# we will need max(avail,timing) to update timing because, \\n# for example, the current time instance timing = 10 (note that, \\n# timing will only record the time instances workers finishing \\n# crossing bridge) and there is only one worker 0 but worker 0 \\n# is ready to cross the bridge from left to right at 11. \\n# timing will be updated to the time instance workers finish \\n# crossing bridge from left to right\\n    timing = max(avail,timing)+time[-i][0]\\n# push the workers to right with availableTime to cross bridge \\n# from right to left after picking up boxes\\n    heapq.heappush(right,(timing+time[-i][1],effi,i))\\n    n -= 1\\n```\n```\\nwhile right and (timing>=right[0][0] or n==0 or not left):\\n# similar to the previous process, we need to \\n# update their availableTime.\\n    while right and right[0][0]<timing:\\n        _,effi,i = heapq.heappop(right)\\n        heapq.heappush(right,(timing,effi,i))\\n    avail,effi,i = heapq.heappop(right)\\n# timing will be updated to the time instance workers finish \\n# crossing bridge from right to left, using max(avail,timing)\\n#  similar to the previous process\\n    timing = max(avail,timing)+time[-i][2]\\n# push the workers to left with availableTime to cross bridge \\n# from left after putting boxes\\n    heapq.heappush(left,(timing+time[-i][3],effi,i))\\n```\n```\\nclass Solution:\\n    def findCrossingTime(self, n, k, time):\\n        left,right = [],[] # (availableTime,-efficiency,-index)\\n        for i in range(k):\\n            heapq.heappush(left,(0,-time[i][0]-time[i][2],-i))\\n        timing = 0\\n        while n>0:\\n            while left and n>0 and (not right or timing<right[0][0]):\\n                while left and left[0][0]<timing:\\n                    _,effi,i = heapq.heappop(left)\\n                    heapq.heappush(left,(timing,effi,i))\\n                avail,effi,i = heapq.heappop(left)\\n                timing = max(avail,timing)+time[-i][0]\\n                heapq.heappush(right,(timing+time[-i][1],effi,i))\\n                n -= 1\\n            while right and (timing>=right[0][0] or n==0 or not left):\\n                while right and right[0][0]<timing:\\n                    _,effi,i = heapq.heappop(right)\\n                    heapq.heappush(right,(timing,effi,i))\\n                avail,effi,i = heapq.heappop(right)\\n                timing = max(avail,timing)+time[-i][2]\\n                heapq.heappush(left,(timing+time[-i][3],effi,i))\\n        return timing\\n```\n```\\nleft,right = [],[] # (-efficiency,-index,availableTime)\\nfor i in range(k):\\n    heapq.heappush(left,(-time[i][0]-time[i][2],-i,0))\\nleft0,right0 = [],[] # (availableTime,-index)\\ntiming = 0\\n```\n```\\nwhile left and n>0 and (not right0 or timing<right0[0][0]):\\n    _,i,avail = heapq.heappop(left)\\n    timing = max(avail,timing)+time[-i][0]\\n    heapq.heappush(right0,(timing+time[-i][1],i))\\n    n -= 1\\n# we need to update left for each new time instance timing, \\n# i.e. move the workers who are ready from left0 to left. \\n# Function updateLeft will be explained later. \\n    self.updateLeft(timing,left,right,left0,right0,time,n)\\n```\n```\\n# we update right for the new time instance, i.e. \\n# move workers who are ready from right0 to right. \\n# Function updateRight will be explained later. \\nself.updateRight(timing,left,right,left0,right0,time,n)\\n# compare to the TLE code, condition (timing>=right[0][0] or n==0 or not left) \\n# is not used in the (while right:) loop because it is used in \\n# function updateRight. Note that, because of condition (while right:), \\n# right will always be null at start of each main loop (while n>0:).\\nwhile right:\\n    _,i,avail = heapq.heappop(right)\\n    timing = max(avail,timing)+time[-i][2]\\n    heapq.heappush(left0,(timing+time[-i][3],i))\\n# we need to update right for each new time instance. Note that, \\n# we need to update left before updating right.\\n    self.updateLeft(timing,left,right,left0,right0,time,n)\\n    self.updateRight(timing,left,right,left0,right0,time,n)\\n```\n```\\ndef updateLeft(self,timing,left,right,left0,right0,time,n):\\n    while left0 and (left0[0][0]<=timing or (not left and not right and not right0) or (not left and not right and right0 and left0[0][0]<right0[0][0])):\\n        avail,i = heapq.heappop(left0)\\n        heapq.heappush(left,(-time[-i][0]-time[-i][2],i,max(avail,timing)))\\n```\n```\\ndef updateRight(self,timing,left,right,left0,right0,time,n):\\n    while right0 and (right0[0][0]<=timing or (not right and (n==0 or not left))):\\n        avail,i = heapq.heappop(right0)\\n        heapq.heappush(right,(-time[-i][0]-time[-i][2],i,max(avail,timing)))\\n```\n```\\nclass Solution:\\n    def findCrossingTime(self, n, k, time):\\n        left,right = [],[] # (-efficiency,-index,availableTime)\\n        for i in range(k):\\n            heapq.heappush(left,(-time[i][0]-time[i][2],-i,0))\\n        left0,right0 = [],[] # (availableTime,-index)\\n        timing = 0\\n        while n>0:\\n            while left and n>0 and (not right0 or timing<right0[0][0]):\\n                _,i,avail = heapq.heappop(left)\\n                timing = max(avail,timing)+time[-i][0]\\n                heapq.heappush(right0,(timing+time[-i][1],i))\\n                n -= 1\\n                self.updateLeft(timing,left,right,left0,right0,time,n)\\n            self.updateRight(timing,left,right,left0,right0,time,n)\\n            while right:\\n                _,i,avail = heapq.heappop(right)\\n                timing = max(avail,timing)+time[-i][2]\\n                heapq.heappush(left0,(timing+time[-i][3],i))\\n                self.updateLeft(timing,left,right,left0,right0,time,n)\\n                self.updateRight(timing,left,right,left0,right0,time,n)\\n        return timing\\n\\n    def updateLeft(self,timing,left,right,left0,right0,time,n):\\n        while left0 and (left0[0][0]<=timing or (not left and not right and right0 and left0[0][0]<right0[0][0]) or (not left and not right and not right0)):\\n            avail,i = heapq.heappop(left0)\\n            heapq.heappush(left,(-time[-i][0]-time[-i][2],i,max(avail,timing)))\\n\\n    def updateRight(self,timing,left,right,left0,right0,time,n):\\n        while right0 and (right0[0][0]<=timing or (not right and (n==0 or not left))):\\n            avail,i = heapq.heappop(right0)\\n            heapq.heappush(right,(-time[-i][0]-time[-i][2],i,max(avail,timing)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027635,
                "title": "c-python-big-simulation",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n\\n> **Vote welcome if this solution helped.**\\n---\\n\\n# Intuition\\n1. Notice that either answer or main logic are about the bridge, so we should mainly track the \"events\" of getting on and off the bridge.\\n2. Usually, one worker should get on the bridge as soon as another worker gets off. Of course, there are special circumstances where everyone is working and the bridge is idle.\\n3. Tracking time of \"events\". Now we must choose a data structure to **quickly \"select a highest priority\" and \"remove it\"**. That is heap.\\n\\n# Approach\\n1. Notice we only care about the \"events\", which is the instants of up bridge and down bridge. As a result, **in these instances we can guarantee that nobody is on the bridge**.\\n2. So the workers have only four states: waiting in leftside, working in leftside, waiting in rightside and working in rightside.\\n3. Use four heaps to maintain them, then simulate.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log k)$\\n- Space complexity: $O(k)$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pii;\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        // After sorting, the order of the indexes is the order of selection\\n        stable_sort(time.begin(), time.end(), [](auto& x, auto& y) -> bool {\\n            return x[0] + x[2] < y[0] + y[2];\\n        });\\n        priority_queue<int> lwait, rwait;\\n        for (int i = 0; i < k; ++i) lwait.push(i);\\n        // Maintain the finish time and index\\n        priority_queue<pii, vector<pii>, greater<pii>> lwork, rwork;\\n        int t = 0;\\n        while (n || rwait.size() || rwork.size()) {\\n            // Before t, these workers have finished their work\\n            // Collect them and insert into waitlist\\n            while (lwork.size() && lwork.top().first <= t) {\\n                lwait.push(lwork.top().second);\\n                lwork.pop();\\n            }\\n            while (rwork.size() && rwork.top().first <= t) {\\n                rwait.push(rwork.top().second);\\n                rwork.pop();\\n            }\\n\\n            if (rwait.size() > 0) {\\n                // Choose the rightside workers at first\\n                int c = rwait.top();\\n                rwait.pop();\\n                // Restart to wait after cross and work\\n                lwork.push(pii(t + time[c][2] + time[c][3], c));\\n                // Bridge return to idle after worker crossed\\n                t += time[c][2];\\n            }\\n            else {\\n                // Nobody waiting in rightside, choose leftside workers\\n                if (n == 0) {\\n                    // No need to schedule leftside worker\\n                    // Advance directly to the next worker to complete\\n                    t = rwork.top().first; \\n                }\\n                else {\\n                    if (lwait.size() > 0) {\\n                        // There are workers waiting in leftside \\n                        int c = lwait.top();\\n                        lwait.pop();\\n                        // Restart to wait after cross and work\\n                        rwork.push(pii(t + time[c][0] + time[c][1], c));\\n                        // Bridge return to idle after worker crossed\\n                        t += time[c][0];\\n                        n--;\\n                    }\\n                    else {\\n                        // Choose the earlier complete time\\n                        int u = lwork.size() ? lwork.top().first : INT_MAX;\\n                        int v = rwork.size() ? rwork.top().first : INT_MAX;\\n                        t = min(u, v);\\n                    }\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```\\n``` Python3 []\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        # After sorting, the order of the indexes is the order of selection\\n        time = sorted(time[::-1], key=lambda x: -x[0]-x[2])\\n        lwait, rwait, lwork, rwork = [i for i in range(k)], [], [], []\\n        heapify(lwait)\\n        t = 0\\n        while n or len(rwait) or len(rwork):\\n            # Before t, these workers have finished their work\\n            # Collect them and insert into waitlist\\n            while len(lwork) and lwork[0][0] <= t:\\n                heappush(lwait, heappop(lwork)[1])\\n            while len(rwork) and rwork[0][0] <= t:\\n                heappush(rwait, heappop(rwork)[1])\\n            if len(rwait):\\n                # Choose the rightside workers at first\\n                c = heappop(rwait)\\n                # Restart to wait after cross and work\\n                heappush(lwork, (t + time[c][2] + time[c][3], c))\\n                # Bridge return to idle after worker crossed\\n                t += time[c][2]\\n            else:\\n                # Nobody waiting in rightside, choose leftside workers\\n                if n == 0: \\n                    # No need to schedule leftside worker\\n                    # Advance directly to the next worker to complete\\n                    t = rwork[0][0]\\n                else:\\n                    if len(lwait):\\n                        # There are workers waiting in leftside \\n                        c = heappop(lwait)\\n                        # Restart to wait after cross and work\\n                        heappush(rwork, (t + time[c][0] + time[c][1], c))\\n                        # Bridge return to idle after worker crossed\\n                        t += time[c][0]\\n                        n -= 1\\n                    else:\\n                        # Choose the earlier complete time\\n                        u = lwork[0][0] if len(lwork) else 1e9\\n                        v = rwork[0][0] if len(rwork) else 1e9\\n                        t = min(u, v)\\n        return t\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Simulation"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pii;\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        // After sorting, the order of the indexes is the order of selection\\n        stable_sort(time.begin(), time.end(), [](auto& x, auto& y) -> bool {\\n            return x[0] + x[2] < y[0] + y[2];\\n        });\\n        priority_queue<int> lwait, rwait;\\n        for (int i = 0; i < k; ++i) lwait.push(i);\\n        // Maintain the finish time and index\\n        priority_queue<pii, vector<pii>, greater<pii>> lwork, rwork;\\n        int t = 0;\\n        while (n || rwait.size() || rwork.size()) {\\n            // Before t, these workers have finished their work\\n            // Collect them and insert into waitlist\\n            while (lwork.size() && lwork.top().first <= t) {\\n                lwait.push(lwork.top().second);\\n                lwork.pop();\\n            }\\n            while (rwork.size() && rwork.top().first <= t) {\\n                rwait.push(rwork.top().second);\\n                rwork.pop();\\n            }\\n\\n            if (rwait.size() > 0) {\\n                // Choose the rightside workers at first\\n                int c = rwait.top();\\n                rwait.pop();\\n                // Restart to wait after cross and work\\n                lwork.push(pii(t + time[c][2] + time[c][3], c));\\n                // Bridge return to idle after worker crossed\\n                t += time[c][2];\\n            }\\n            else {\\n                // Nobody waiting in rightside, choose leftside workers\\n                if (n == 0) {\\n                    // No need to schedule leftside worker\\n                    // Advance directly to the next worker to complete\\n                    t = rwork.top().first; \\n                }\\n                else {\\n                    if (lwait.size() > 0) {\\n                        // There are workers waiting in leftside \\n                        int c = lwait.top();\\n                        lwait.pop();\\n                        // Restart to wait after cross and work\\n                        rwork.push(pii(t + time[c][0] + time[c][1], c));\\n                        // Bridge return to idle after worker crossed\\n                        t += time[c][0];\\n                        n--;\\n                    }\\n                    else {\\n                        // Choose the earlier complete time\\n                        int u = lwork.size() ? lwork.top().first : INT_MAX;\\n                        int v = rwork.size() ? rwork.top().first : INT_MAX;\\n                        t = min(u, v);\\n                    }\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```\n``` Python3 []\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        # After sorting, the order of the indexes is the order of selection\\n        time = sorted(time[::-1], key=lambda x: -x[0]-x[2])\\n        lwait, rwait, lwork, rwork = [i for i in range(k)], [], [], []\\n        heapify(lwait)\\n        t = 0\\n        while n or len(rwait) or len(rwork):\\n            # Before t, these workers have finished their work\\n            # Collect them and insert into waitlist\\n            while len(lwork) and lwork[0][0] <= t:\\n                heappush(lwait, heappop(lwork)[1])\\n            while len(rwork) and rwork[0][0] <= t:\\n                heappush(rwait, heappop(rwork)[1])\\n            if len(rwait):\\n                # Choose the rightside workers at first\\n                c = heappop(rwait)\\n                # Restart to wait after cross and work\\n                heappush(lwork, (t + time[c][2] + time[c][3], c))\\n                # Bridge return to idle after worker crossed\\n                t += time[c][2]\\n            else:\\n                # Nobody waiting in rightside, choose leftside workers\\n                if n == 0: \\n                    # No need to schedule leftside worker\\n                    # Advance directly to the next worker to complete\\n                    t = rwork[0][0]\\n                else:\\n                    if len(lwait):\\n                        # There are workers waiting in leftside \\n                        c = heappop(lwait)\\n                        # Restart to wait after cross and work\\n                        heappush(rwork, (t + time[c][0] + time[c][1], c))\\n                        # Bridge return to idle after worker crossed\\n                        t += time[c][0]\\n                        n -= 1\\n                    else:\\n                        # Choose the earlier complete time\\n                        u = lwork[0][0] if len(lwork) else 1e9\\n                        v = rwork[0][0] if len(rwork) else 1e9\\n                        t = min(u, v)\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021322,
                "title": "priority-queue-solution-easy-to-understand-with-no-major-tricks-c",
                "content": "I am using four priority queues, two are max heap and two are min heap.\\n\\t1) max heaps for LeftToRight (l2r) and RightToLeft (r2l) movements. They are prioritized based on less efficient workers\\n\\t2) min heaps are used for queuing workers at both the warehouses. They are prioritized based on time taken to pick up/put down a box\\n\\nInitialize the left bank queue (l2r) by putting all workers as per their less efficientness condition.\\n\\nThe following steps are required untill all boxes are delivered:\\n1) Check and move workers if available in the old warehouse queue (oldWH) to right bank queue (r2l)\\n2) Check and move workers if available in the new warehouse queue (newWH) to left bank queue (l2r)\\n3) Follow one of the following step:\\n\\ti) Check if workers are available in the right bank queue (r2l), cross and lineup them in new warehouse queue (newWH)\\n\\tii) Check if workers are available in the left bank queue (l2r), cross and lineup them in old warehouse queue (oldWH)\\n\\tiii) If the current time is not updated maybe due to no movements of workers on the bridge, then increment it by one unit to give a fair chance and release workers who are either stuck in the warehouse queues.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> newWH, oldWH; \\n        priority_queue<pair<int, int>> l2r, r2l;\\n        \\n        for (int i = 0; i < time.size(); ++i) l2r.push({time[i][0]+time[i][2], i}); \\n        \\n        int curr_time = 0;\\n        while (n > 0 || !oldWH.empty() || !r2l.empty()) \\n        {\\n            // move workers from old warehouse to right bank queue\\n            while (!oldWH.empty() && oldWH.top().first <= curr_time) \\n            {\\n                int i = oldWH.top().second; oldWH.pop(); \\n                r2l.push({time[i][0] + time[i][2], i}); \\n            }\\n            \\n            // move workers from new warehouse to left bank queue\\n            while (!newWH.empty() && newWH.top().first <= curr_time) \\n            {\\n                int i = newWH.top().second; newWH.pop(); \\n                l2r.push({time[i][0] + time[i][2], i}); \\n            }\\n            \\n            if (!r2l.empty()) \\n            {// cross right to left bridge and lineup in new warehouse queue\\n                int i = r2l.top().second; r2l.pop(); \\n                curr_time += time[i][2];\\n                if (n > 0) newWH.push({curr_time + time[i][3], i}); \\n            } \\n            else if (!l2r.empty() && n > 0)\\n            {// cross left to right bridge and lineup in old warehouse queue\\n                int i = l2r.top().second; l2r.pop();\\n                curr_time += time[i][0];\\n                oldWH.push({curr_time + time[i][1], i}); \\n                --n; \\n            }\\n            // if you are unable to increment the current time \\n            // and you are still here, it means there are some workers\\n            // stuck up in the new/old warehouse, hence increment \\n            // time by one minute \\n            else curr_time += 1;\\n        }\\n        \\n        return curr_time; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> newWH, oldWH; \\n        priority_queue<pair<int, int>> l2r, r2l;\\n        \\n        for (int i = 0; i < time.size(); ++i) l2r.push({time[i][0]+time[i][2], i}); \\n        \\n        int curr_time = 0;\\n        while (n > 0 || !oldWH.empty() || !r2l.empty()) \\n        {\\n            // move workers from old warehouse to right bank queue\\n            while (!oldWH.empty() && oldWH.top().first <= curr_time) \\n            {\\n                int i = oldWH.top().second; oldWH.pop(); \\n                r2l.push({time[i][0] + time[i][2], i}); \\n            }\\n            \\n            // move workers from new warehouse to left bank queue\\n            while (!newWH.empty() && newWH.top().first <= curr_time) \\n            {\\n                int i = newWH.top().second; newWH.pop(); \\n                l2r.push({time[i][0] + time[i][2], i}); \\n            }\\n            \\n            if (!r2l.empty()) \\n            {// cross right to left bridge and lineup in new warehouse queue\\n                int i = r2l.top().second; r2l.pop(); \\n                curr_time += time[i][2];\\n                if (n > 0) newWH.push({curr_time + time[i][3], i}); \\n            } \\n            else if (!l2r.empty() && n > 0)\\n            {// cross left to right bridge and lineup in old warehouse queue\\n                int i = l2r.top().second; l2r.pop();\\n                curr_time += time[i][0];\\n                oldWH.push({curr_time + time[i][1], i}); \\n                --n; \\n            }\\n            // if you are unable to increment the current time \\n            // and you are still here, it means there are some workers\\n            // stuck up in the new/old warehouse, hence increment \\n            // time by one minute \\n            else curr_time += 1;\\n        }\\n        \\n        return curr_time; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020473,
                "title": "c-beats-100-commented-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        \\n        // Optimal Data structure to store the least efficient workers ready to cross the bridge at both sides.\\n        priority_queue<pair<int,int>>left_bank;   // efficiency , index\\n        priority_queue<pair<int,int>>right_bank; // efficiency , index\\n        \\n        // Optimal Data structure to store the workers waiting for the bridge after picking and putting operations.\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>left_wait;  // time , index\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>right_wait; // time , index\\n        \\n        // Insert all the workers (acc to their efficiency) ready to cross the bridge on the left bank.\\n        for(int i=0;i<k;i++){\\n            left_bank.push({time[i][0]+time[i][2],i});\\n        }\\n        \\n        // What are the conditions when we need to stop the process. Let\\'s have a look quickly :\\n        \\n        // condition 1. When some workers are on the right bank , either ready to cross the bridge , or picking the old warehouse boxes from there.\\n        \\n        // condition 2. When all the old boxes are not placed at the new warehouses.\\n        \\n        int timer = 0;\\n        \\n        // Exit Condition\\n        while((right_bank.size()+right_wait.size()) || (n>0)){\\n            \\n            // Check all the workers who are done with putting the boxes at the new warehouse and become ready to cross the bridge again from left to right.\\n            \\n            while(left_wait.size() && left_wait.top().first <= timer){\\n                int i = left_wait.top().second;\\n                left_wait.pop();\\n                left_bank.push({time[i][0]+time[i][2],i});\\n            }\\n            \\n            // Check all the workers who are done with picking up the boxes from the old warehouse and bexome ready to cross the bridge again from right to left.\\n            \\n            while(right_wait.size() && right_wait.top().first <= timer){\\n                int i = right_wait.top().second;\\n                right_wait.pop();\\n                right_bank.push({time[i][0]+time[i][2],i});\\n            }\\n            \\n            // First priority is to check if there are ready to move workers on the right bank.\\n            if(right_bank.size()){\\n                \\n                int i = right_bank.top().second;\\n                right_bank.pop();\\n                timer += time[i][2];\\n                left_wait.push({timer+time[i][3],i});\\n                \\n            }\\n            \\n            // Second priority is to check if there are ready to move workers on the left bank.\\n            else{\\n                \\n                // This is the most crucial corner case \\n                // If there are some workers ready to move from left to right and we are done with exchanging all the boxes , should we allow them to use the bridge ??? No.\\n                if(left_bank.size() && n){\\n                    \\n                    int i = left_bank.top().second;\\n                    left_bank.pop();\\n                    timer += time[i][0];\\n                    right_wait.push({timer+time[i][1],i});\\n                    n--;\\n                    \\n                }\\n                else{\\n                    \\n                    timer = INT_MAX;\\n                    if(left_wait.size() && n){\\n                        timer = min(timer,left_wait.top().first);\\n                    }\\n                    if(right_wait.size()){\\n                        timer = min(timer,right_wait.top().first);\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return timer;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        \\n        // Optimal Data structure to store the least efficient workers ready to cross the bridge at both sides.\\n        priority_queue<pair<int,int>>left_bank;   // efficiency , index\\n        priority_queue<pair<int,int>>right_bank; // efficiency , index\\n        \\n        // Optimal Data structure to store the workers waiting for the bridge after picking and putting operations.\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>left_wait;  // time , index\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>right_wait; // time , index\\n        \\n        // Insert all the workers (acc to their efficiency) ready to cross the bridge on the left bank.\\n        for(int i=0;i<k;i++){\\n            left_bank.push({time[i][0]+time[i][2],i});\\n        }\\n        \\n        // What are the conditions when we need to stop the process. Let\\'s have a look quickly :\\n        \\n        // condition 1. When some workers are on the right bank , either ready to cross the bridge , or picking the old warehouse boxes from there.\\n        \\n        // condition 2. When all the old boxes are not placed at the new warehouses.\\n        \\n        int timer = 0;\\n        \\n        // Exit Condition\\n        while((right_bank.size()+right_wait.size()) || (n>0)){\\n            \\n            // Check all the workers who are done with putting the boxes at the new warehouse and become ready to cross the bridge again from left to right.\\n            \\n            while(left_wait.size() && left_wait.top().first <= timer){\\n                int i = left_wait.top().second;\\n                left_wait.pop();\\n                left_bank.push({time[i][0]+time[i][2],i});\\n            }\\n            \\n            // Check all the workers who are done with picking up the boxes from the old warehouse and bexome ready to cross the bridge again from right to left.\\n            \\n            while(right_wait.size() && right_wait.top().first <= timer){\\n                int i = right_wait.top().second;\\n                right_wait.pop();\\n                right_bank.push({time[i][0]+time[i][2],i});\\n            }\\n            \\n            // First priority is to check if there are ready to move workers on the right bank.\\n            if(right_bank.size()){\\n                \\n                int i = right_bank.top().second;\\n                right_bank.pop();\\n                timer += time[i][2];\\n                left_wait.push({timer+time[i][3],i});\\n                \\n            }\\n            \\n            // Second priority is to check if there are ready to move workers on the left bank.\\n            else{\\n                \\n                // This is the most crucial corner case \\n                // If there are some workers ready to move from left to right and we are done with exchanging all the boxes , should we allow them to use the bridge ??? No.\\n                if(left_bank.size() && n){\\n                    \\n                    int i = left_bank.top().second;\\n                    left_bank.pop();\\n                    timer += time[i][0];\\n                    right_wait.push({timer+time[i][1],i});\\n                    n--;\\n                    \\n                }\\n                else{\\n                    \\n                    timer = INT_MAX;\\n                    if(left_wait.size() && n){\\n                        timer = min(timer,left_wait.top().first);\\n                    }\\n                    if(right_wait.size()){\\n                        timer = min(timer,right_wait.top().first);\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return timer;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684494,
                "title": "2532-time-to-cross-a-bridge-c-priority-queue-explained-heap-easy-to-understand",
                "content": "# 2532. Time to Cross a Bridge | C++ | Priority Queue | Explained | Heap | Easy to Understand\\n```\\nclass Solution {\\npublic:\\n    struct compareEfficiency {\\n    public:\\n        bool operator()(vector<int>& a, vector<int>& b) \\n        {\\n            if (a[0] + a[2] > b[0] + b[2])\\n                return false;\\n            if (a[0] + a[2] < b[0] + b[2])\\n                return true;\\n            if (a[4] > b[4])\\n                return false;\\n            return true;\\n        }\\n    };\\n    \\n    struct compareTime {\\n    public:\\n        bool operator()(vector<int>& a, vector<int>& b) \\n        {\\n            if (a[5] > b[5])\\n                return true;\\n            return false;\\n        }\\n    };\\n    \\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<vector<int>, vector<vector<int>>, compareEfficiency> pq1; // queue at left bridge\\n        priority_queue<vector<int>, vector<vector<int>>, compareEfficiency> pq2; // queue at right bridge\\n        priority_queue<vector<int>, vector<vector<int>>, compareTime> pq3; // queue at left warehouse\\n        priority_queue<vector<int>, vector<vector<int>>, compareTime> pq4; // queue at right warehouse\\n        vector<int> onBridge;\\n        int count = 0;\\n        int currentTime = 0;\\n        for (int i = 0; i < k; i++)\\n        {\\n            time[i].push_back(i);\\n            time[i].push_back(0);\\n            pq1.push(time[i]);\\n        }\\n        while (count < n)\\n        {\\n            // update queues\\n            while (!pq3.empty() && pq3.top()[5] <= currentTime)\\n            {\\n                vector<int> temp = pq3.top();\\n                pq3.pop();\\n                pq1.push(temp);\\n            }\\n            while (!pq4.empty() && pq4.top()[5] <= currentTime)\\n            {\\n                vector<int> temp = pq4.top();\\n                pq4.pop();\\n                pq2.push(temp);\\n            }\\n            \\n            // worker crosses the bridge left to right\\n            if (pq2.empty() && !pq1.empty())\\n            {\\n                // enough workers at right side of the bridge to move the last few boxes\\n                if (count + pq2.size() + pq4.size() >= n)\\n                {\\n                    currentTime++;\\n                    continue;\\n                }\\n                onBridge = pq1.top();\\n                pq1.pop();\\n                currentTime += onBridge[0];\\n                onBridge[5] = currentTime + onBridge[1];\\n                pq4.push(onBridge);\\n            }\\n            // worker crosses the bridge right to left\\n            else if (!pq2.empty())\\n            {\\n                onBridge = pq2.top();\\n                pq2.pop();\\n                currentTime += onBridge[2];\\n                onBridge[5] = currentTime + onBridge[3];\\n                pq3.push(onBridge);\\n                count++;\\n            }\\n            // no worker waiting at the bridge\\n            else\\n            {\\n                if (pq3.empty())\\n                {\\n                    vector<int> temp = pq4.top();\\n                    currentTime = temp[5];\\n                }\\n                else if (pq4.empty())\\n                {\\n                    vector<int> temp = pq3.top();\\n                    currentTime = temp[5];\\n                }\\n                else\\n                {\\n                    if (pq3.top()[5] < pq4.top()[5])\\n                    {\\n                        vector<int> temp = pq3.top();\\n                        currentTime = temp[5];\\n                    }\\n                    else\\n                    {\\n                        vector<int> temp = pq4.top();\\n                        currentTime = temp[5];\\n                    }\\n                }\\n            }\\n            //cout << currentTime << endl;\\n        }\\n        \\n        return currentTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct compareEfficiency {\\n    public:\\n        bool operator()(vector<int>& a, vector<int>& b) \\n        {\\n            if (a[0] + a[2] > b[0] + b[2])\\n                return false;\\n            if (a[0] + a[2] < b[0] + b[2])\\n                return true;\\n            if (a[4] > b[4])\\n                return false;\\n            return true;\\n        }\\n    };\\n    \\n    struct compareTime {\\n    public:\\n        bool operator()(vector<int>& a, vector<int>& b) \\n        {\\n            if (a[5] > b[5])\\n                return true;\\n            return false;\\n        }\\n    };\\n    \\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<vector<int>, vector<vector<int>>, compareEfficiency> pq1; // queue at left bridge\\n        priority_queue<vector<int>, vector<vector<int>>, compareEfficiency> pq2; // queue at right bridge\\n        priority_queue<vector<int>, vector<vector<int>>, compareTime> pq3; // queue at left warehouse\\n        priority_queue<vector<int>, vector<vector<int>>, compareTime> pq4; // queue at right warehouse\\n        vector<int> onBridge;\\n        int count = 0;\\n        int currentTime = 0;\\n        for (int i = 0; i < k; i++)\\n        {\\n            time[i].push_back(i);\\n            time[i].push_back(0);\\n            pq1.push(time[i]);\\n        }\\n        while (count < n)\\n        {\\n            // update queues\\n            while (!pq3.empty() && pq3.top()[5] <= currentTime)\\n            {\\n                vector<int> temp = pq3.top();\\n                pq3.pop();\\n                pq1.push(temp);\\n            }\\n            while (!pq4.empty() && pq4.top()[5] <= currentTime)\\n            {\\n                vector<int> temp = pq4.top();\\n                pq4.pop();\\n                pq2.push(temp);\\n            }\\n            \\n            // worker crosses the bridge left to right\\n            if (pq2.empty() && !pq1.empty())\\n            {\\n                // enough workers at right side of the bridge to move the last few boxes\\n                if (count + pq2.size() + pq4.size() >= n)\\n                {\\n                    currentTime++;\\n                    continue;\\n                }\\n                onBridge = pq1.top();\\n                pq1.pop();\\n                currentTime += onBridge[0];\\n                onBridge[5] = currentTime + onBridge[1];\\n                pq4.push(onBridge);\\n            }\\n            // worker crosses the bridge right to left\\n            else if (!pq2.empty())\\n            {\\n                onBridge = pq2.top();\\n                pq2.pop();\\n                currentTime += onBridge[2];\\n                onBridge[5] = currentTime + onBridge[3];\\n                pq3.push(onBridge);\\n                count++;\\n            }\\n            // no worker waiting at the bridge\\n            else\\n            {\\n                if (pq3.empty())\\n                {\\n                    vector<int> temp = pq4.top();\\n                    currentTime = temp[5];\\n                }\\n                else if (pq4.empty())\\n                {\\n                    vector<int> temp = pq3.top();\\n                    currentTime = temp[5];\\n                }\\n                else\\n                {\\n                    if (pq3.top()[5] < pq4.top()[5])\\n                    {\\n                        vector<int> temp = pq3.top();\\n                        currentTime = temp[5];\\n                    }\\n                    else\\n                    {\\n                        vector<int> temp = pq4.top();\\n                        currentTime = temp[5];\\n                    }\\n                }\\n            }\\n            //cout << currentTime << endl;\\n        }\\n        \\n        return currentTime;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3595535,
                "title": "kotlin-4-heaps",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun findCrossingTime(n: Int, k: Int, time: Array<IntArray>): Int {\\n        val comp = compareByDescending { it: IntArray -> it[0] }.thenByDescending { it: IntArray -> it[1] }\\n        val comp2 = compareBy { it: IntArray -> it[0] }.thenByDescending { it: IntArray -> it[1] }\\n        val lw = PriorityQueue<IntArray>(comp) // waiting queue: effectiveness + worker index\\n        val rw = PriorityQueue<IntArray>(comp)\\n        val lp = PriorityQueue<IntArray>(comp2) // processing queue: time when ready + worker index\\n        val rp = PriorityQueue<IntArray>(comp2)\\n        var res = 0\\n\\n        // place all workers on the left side\\n        for (i in 0..time.size - 1) {\\n            val t = time[i]\\n            val a = IntArray(2, { 0 })\\n            a[0] = t[0] + t[2]\\n            a[1] = i\\n            lw.add(a)\\n        }\\n\\n        var b = n // boxes left\\n        var t = 0 // current time\\n        while (true) {\\n            if (b == 0 && rw.size == 0 && rp.size == 0) break\\n            if ((lw.size > 0 && b > 0) || rw.size > 0) {\\n                if (rw.size > 0) {\\n                    // send a worker back to left side\\n                    val w = rw.poll() // worker\\n                    t += time[w[1]][2]\\n                    \\n                    w[0] = t + time[w[1]][3] // will be ready again at this time\\n                    lp.add(w)\\n                } else {\\n                    // send a new one from the left if needed\\n                    if (b > 0 && lw.size > 0) {\\n                        val w = lw.poll()\\n                        t += time[w[1]][0]\\n\\n                        w[0] = t + time[w[1]][1] // will be ready to get back at this time\\n                        rp.add(w)\\n                        b--\\n                    }\\n                }\\n                checkIfReady(lw, rw, lp, rp, t, time)\\n\\n                continue\\n            }\\n\\n            // if all workers are busy wait until processed\\n            val t1 = if (lp.size > 0) lp.peek()[0] else Int.MAX_VALUE\\n            val t2 = if (rp.size > 0) rp.peek()[0] else Int.MAX_VALUE\\n            t = Math.min(t1, t2)\\n\\n            checkIfReady(lw, rw, lp, rp, t, time)\\n        }\\n\\n        return t\\n    }\\n\\n    fun checkIfReady(lw: PriorityQueue<IntArray>,\\n            rw: PriorityQueue<IntArray>,\\n            lp: PriorityQueue<IntArray>,\\n            rp: PriorityQueue<IntArray>,\\n            t: Int,\\n            time: Array<IntArray>) {\\n        while (true) {\\n            if (lp.size == 0) break\\n            if (lp.peek()[0] > t) break\\n            val w = lp.poll()\\n            val i = w[1] // index\\n            w[0] = time[i][0] + time[i][2]\\n            lw.add(w)\\n        }\\n\\n        while (true) {\\n            if (rp.size == 0) break\\n            if (rp.peek()[0] > t) break\\n            val w = rp.poll()\\n            val i = w[1] // index\\n            w[0] = time[i][0] + time[i][2]\\n            rw.add(w)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    fun findCrossingTime(n: Int, k: Int, time: Array<IntArray>): Int {\\n        val comp = compareByDescending { it: IntArray -> it[0] }.thenByDescending { it: IntArray -> it[1] }\\n        val comp2 = compareBy { it: IntArray -> it[0] }.thenByDescending { it: IntArray -> it[1] }\\n        val lw = PriorityQueue<IntArray>(comp) // waiting queue: effectiveness + worker index\\n        val rw = PriorityQueue<IntArray>(comp)\\n        val lp = PriorityQueue<IntArray>(comp2) // processing queue: time when ready + worker index\\n        val rp = PriorityQueue<IntArray>(comp2)\\n        var res = 0\\n\\n        // place all workers on the left side\\n        for (i in 0..time.size - 1) {\\n            val t = time[i]\\n            val a = IntArray(2, { 0 })\\n            a[0] = t[0] + t[2]\\n            a[1] = i\\n            lw.add(a)\\n        }\\n\\n        var b = n // boxes left\\n        var t = 0 // current time\\n        while (true) {\\n            if (b == 0 && rw.size == 0 && rp.size == 0) break\\n            if ((lw.size > 0 && b > 0) || rw.size > 0) {\\n                if (rw.size > 0) {\\n                    // send a worker back to left side\\n                    val w = rw.poll() // worker\\n                    t += time[w[1]][2]\\n                    \\n                    w[0] = t + time[w[1]][3] // will be ready again at this time\\n                    lp.add(w)\\n                } else {\\n                    // send a new one from the left if needed\\n                    if (b > 0 && lw.size > 0) {\\n                        val w = lw.poll()\\n                        t += time[w[1]][0]\\n\\n                        w[0] = t + time[w[1]][1] // will be ready to get back at this time\\n                        rp.add(w)\\n                        b--\\n                    }\\n                }\\n                checkIfReady(lw, rw, lp, rp, t, time)\\n\\n                continue\\n            }\\n\\n            // if all workers are busy wait until processed\\n            val t1 = if (lp.size > 0) lp.peek()[0] else Int.MAX_VALUE\\n            val t2 = if (rp.size > 0) rp.peek()[0] else Int.MAX_VALUE\\n            t = Math.min(t1, t2)\\n\\n            checkIfReady(lw, rw, lp, rp, t, time)\\n        }\\n\\n        return t\\n    }\\n\\n    fun checkIfReady(lw: PriorityQueue<IntArray>,\\n            rw: PriorityQueue<IntArray>,\\n            lp: PriorityQueue<IntArray>,\\n            rp: PriorityQueue<IntArray>,\\n            t: Int,\\n            time: Array<IntArray>) {\\n        while (true) {\\n            if (lp.size == 0) break\\n            if (lp.peek()[0] > t) break\\n            val w = lp.poll()\\n            val i = w[1] // index\\n            w[0] = time[i][0] + time[i][2]\\n            lw.add(w)\\n        }\\n\\n        while (true) {\\n            if (rp.size == 0) break\\n            if (rp.peek()[0] > t) break\\n            val w = rp.poll()\\n            val i = w[1] // index\\n            w[0] = time[i][0] + time[i][2]\\n            rw.add(w)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159246,
                "title": "python3-simulate-cpu-scheduler-with-four-priority-queues",
                "content": "```python\\nclass Solution:\\n    def cross(self, wait, cpu, time, tick, is_left_to_right) -> int:\\n        cur = heapq.heappop(wait)\\n        i = 0 if is_left_to_right else 2\\n        tick += time[-cur[2]][i]\\n        cur[0] = tick + time[-cur[2]][i + 1]\\n        heapq.heappush(cpu, cur)\\n        return tick\\n\\n    def check_cpu(self, cpu, wait, tick) -> None:\\n        while cpu and cpu[0][0] <= tick:\\n            cur = heapq.heappop(cpu)\\n            cur[0] = 0\\n            heapq.heappush(wait, cur)\\n\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        \"\"\"This is basically a CPU scheduler. We have two tasks, one on the left\\n        and the other on the right. When a task is done, the worker needs to\\n        wait for his turn to cross the bridge. Thus, we create four heaps.\\n\\n        l_wait: left wait queue. Workers here have completed their tasks and\\n        wait for cross.\\n        l_cpu: left CPU queue. Workers here are actively doing the task\\n        r_wait: same as l_wait, but for the workers waiting on the right\\n        r_cpu: same as l_cpu, but for the workers doing the task on the right\\n\\n        A worker is represented by an array\\n\\n        [available_time_tick, efficiency, idx]\\n\\n        available_time_tick is the time tick at which the worker finishes the\\n        task and is able to join l_wait or r_wait. Note that all the workers in\\n        the wait queue have available_time_tick equal to 0\\n\\n        efficiency is the sum of left to right time and right to left time. In\\n        the implementation, efficiency must be the negative of the sum.\\n\\n        idx is the index of the worker. In the implementation, idx must be\\n        negative as well.\\n\\n        Thus, in the heap, the worker with the smallest available_time_tick,\\n        i.e., the worker who will finish the earlieset gets to the top. If the\\n        available_time_tick are the same (e.g. in the wait queue), the worker\\n        with the larger negative efficiency, i.e., lower efficiency, gets to\\n        the top. If the efficiency are the same, the worker with the larger\\n        negative index, gets to the top.\\n\\n        We also use a variable tick to keep track of the current time.\\n\\n        The work flow goes like this. First, we need to check if anyone on the\\n        CPU queue has completed their tasks. The check is to compare the current\\n        tick with available_time_tick on each worker. If the tick is larger\\n        than available_time_tick, the worker has completed the task and shall\\n        join the wait queue. We do this for both l_cpu and r_cpu\\n\\n        Then, we grab workers from the wait queue. If only l_wait is available,\\n        as in the case at the beginning, we pop the worker from there and have\\n        him cross the bridge. The time spent crossing the bridge is the time\\n        everyone has to wait. We update tick for that. Once the worker is on the\\n        right side, we compute its available_time_tick as current tick plus the\\n        time needed for him to complete the task on the right. Then we put him\\n        in r_cpu.\\n\\n        If r_wait is available, then regardless of whether l_wait is available,\\n        we always pop workers from r_wait, and have him cross the bridge from\\n        right to left. We update tick for the current time, and compute the\\n        available_time_tick for the worker working on the task on the left. Then\\n        we put him in l_cpu.\\n\\n        Last case, if neither l_wait nor r_wait is available, that means the\\n        current tick is smaller than available_time_tick from the top worker on\\n        both l_cpu and r_cpu. Then we need to fast forward tick to the smaller\\n        of the two and then repeat the process.\\n\\n        One complication is that once all jobs have been picked up, we need to\\n        terminate the process above. At this point, there are still workers on\\n        r_cpu, but we don\\'t care about l_cpu or l_wait anymore. We just want to\\n        get workers from r_cpu to r_wait to crossing the bridge.\\n\\n        O(NlogK), 731 ms, faster than 35.31%\\n        \"\"\"\\n        l_wait, l_cpu, r_wait, r_cpu = [], [], [], []\\n        # All workers on l_wait at the beginning\\n        for i in range(k):\\n            heapq.heappush(l_wait, [0, -time[i][0] - time[i][2], -i])\\n        tick = 0\\n        while n:\\n            self.check_cpu(l_cpu, l_wait, tick)\\n            self.check_cpu(r_cpu, r_wait, tick)\\n            if l_wait and not r_wait:\\n                tick = self.cross(l_wait, r_cpu, time, tick, True)\\n                n -= 1\\n            elif r_wait:\\n                tick = self.cross(r_wait, l_cpu, time, tick, False)\\n            else:  # l_wait and r_wait both empty\\n                tick = min(l_cpu[0][0] if l_cpu else math.inf, r_cpu[0][0] if r_cpu else math.inf)\\n\\n        # Move all remaining workers from right to left\\n        while r_cpu or r_wait:\\n            self.check_cpu(r_cpu, r_wait, tick)\\n            tick = self.cross(r_wait, l_cpu, time, tick, False) if r_wait else r_cpu[0][0]\\n        return tick\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def cross(self, wait, cpu, time, tick, is_left_to_right) -> int:\\n        cur = heapq.heappop(wait)\\n        i = 0 if is_left_to_right else 2\\n        tick += time[-cur[2]][i]\\n        cur[0] = tick + time[-cur[2]][i + 1]\\n        heapq.heappush(cpu, cur)\\n        return tick\\n\\n    def check_cpu(self, cpu, wait, tick) -> None:\\n        while cpu and cpu[0][0] <= tick:\\n            cur = heapq.heappop(cpu)\\n            cur[0] = 0\\n            heapq.heappush(wait, cur)\\n\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        \"\"\"This is basically a CPU scheduler. We have two tasks, one on the left\\n        and the other on the right. When a task is done, the worker needs to\\n        wait for his turn to cross the bridge. Thus, we create four heaps.\\n\\n        l_wait: left wait queue. Workers here have completed their tasks and\\n        wait for cross.\\n        l_cpu: left CPU queue. Workers here are actively doing the task\\n        r_wait: same as l_wait, but for the workers waiting on the right\\n        r_cpu: same as l_cpu, but for the workers doing the task on the right\\n\\n        A worker is represented by an array\\n\\n        [available_time_tick, efficiency, idx]\\n\\n        available_time_tick is the time tick at which the worker finishes the\\n        task and is able to join l_wait or r_wait. Note that all the workers in\\n        the wait queue have available_time_tick equal to 0\\n\\n        efficiency is the sum of left to right time and right to left time. In\\n        the implementation, efficiency must be the negative of the sum.\\n\\n        idx is the index of the worker. In the implementation, idx must be\\n        negative as well.\\n\\n        Thus, in the heap, the worker with the smallest available_time_tick,\\n        i.e., the worker who will finish the earlieset gets to the top. If the\\n        available_time_tick are the same (e.g. in the wait queue), the worker\\n        with the larger negative efficiency, i.e., lower efficiency, gets to\\n        the top. If the efficiency are the same, the worker with the larger\\n        negative index, gets to the top.\\n\\n        We also use a variable tick to keep track of the current time.\\n\\n        The work flow goes like this. First, we need to check if anyone on the\\n        CPU queue has completed their tasks. The check is to compare the current\\n        tick with available_time_tick on each worker. If the tick is larger\\n        than available_time_tick, the worker has completed the task and shall\\n        join the wait queue. We do this for both l_cpu and r_cpu\\n\\n        Then, we grab workers from the wait queue. If only l_wait is available,\\n        as in the case at the beginning, we pop the worker from there and have\\n        him cross the bridge. The time spent crossing the bridge is the time\\n        everyone has to wait. We update tick for that. Once the worker is on the\\n        right side, we compute its available_time_tick as current tick plus the\\n        time needed for him to complete the task on the right. Then we put him\\n        in r_cpu.\\n\\n        If r_wait is available, then regardless of whether l_wait is available,\\n        we always pop workers from r_wait, and have him cross the bridge from\\n        right to left. We update tick for the current time, and compute the\\n        available_time_tick for the worker working on the task on the left. Then\\n        we put him in l_cpu.\\n\\n        Last case, if neither l_wait nor r_wait is available, that means the\\n        current tick is smaller than available_time_tick from the top worker on\\n        both l_cpu and r_cpu. Then we need to fast forward tick to the smaller\\n        of the two and then repeat the process.\\n\\n        One complication is that once all jobs have been picked up, we need to\\n        terminate the process above. At this point, there are still workers on\\n        r_cpu, but we don\\'t care about l_cpu or l_wait anymore. We just want to\\n        get workers from r_cpu to r_wait to crossing the bridge.\\n\\n        O(NlogK), 731 ms, faster than 35.31%\\n        \"\"\"\\n        l_wait, l_cpu, r_wait, r_cpu = [], [], [], []\\n        # All workers on l_wait at the beginning\\n        for i in range(k):\\n            heapq.heappush(l_wait, [0, -time[i][0] - time[i][2], -i])\\n        tick = 0\\n        while n:\\n            self.check_cpu(l_cpu, l_wait, tick)\\n            self.check_cpu(r_cpu, r_wait, tick)\\n            if l_wait and not r_wait:\\n                tick = self.cross(l_wait, r_cpu, time, tick, True)\\n                n -= 1\\n            elif r_wait:\\n                tick = self.cross(r_wait, l_cpu, time, tick, False)\\n            else:  # l_wait and r_wait both empty\\n                tick = min(l_cpu[0][0] if l_cpu else math.inf, r_cpu[0][0] if r_cpu else math.inf)\\n\\n        # Move all remaining workers from right to left\\n        while r_cpu or r_wait:\\n            self.check_cpu(r_cpu, r_wait, tick)\\n            tick = self.cross(r_wait, l_cpu, time, tick, False) if r_wait else r_cpu[0][0]\\n        return tick\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042477,
                "title": "python-simple-organized-heap-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nMaintain 4 minimum Heap queue to record workers at different situation:\\n* Waiting at **left side** of bridge\\n* Waiting at **right side** of bridge\\n* **Picking** box\\n* **Putting** box\\n\\nWorker jump amount these 4 queue as time pass.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThere is a priority amount the 4 queues.\\n1. Based on question, `rightSide` has the highest priority.\\n2. If no person are waiting on `rightSide` and other work are busy, the `leftSide` can pass.\\n3. If no one use bridge, we shall just move forward the time with the worker who finish `putting` or `picking` next.\\n\\nTo summarize, the priority amount the 4 queues is `rightSide -> leftSide -> Picking -> putting`.\\n\\n# Complexity\\n- Time complexity: $$O(k + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        leftSide = []\\n        rightSide = []\\n        picking = []\\n        putting = []\\n        for i, worker in enumerate(time):\\n            heapq.heappush(leftSide, [-(worker[0] + worker[2]), -i])\\n        t = 0\\n        while n or rightSide or picking or putting:\\n            if rightSide: # right to left passing\\n                worker = heapq.heappop(rightSide)\\n                t += time[-worker[1]][2]\\n                heapq.heappush(putting, [t + time[-worker[1]][3], worker])\\n            elif n and leftSide: # left to right passing\\n                worker = heapq.heappop(leftSide)\\n                t += time[-worker[1]][0]\\n                n -= 1\\n                heapq.heappush(picking, [t + time[-worker[1]][1], worker])\\n            # No one uses bridge, so move forward with the next worker who either picking or putting\\n            else:\\n                if not n and not picking:\\n                    # Ending Case\\n                    return t\\n                nextTime = []\\n                if picking:\\n                    nextTime.append(picking[0][0])\\n                if putting:\\n                    nextTime.append(putting[0][0])\\n                t = min(nextTime)\\n\\n            # Put all worker back to bridge queue if they finish at current time\\n            while putting and putting[0][0] <= t:\\n                _, worker = heapq.heappop(putting)\\n                heapq.heappush(leftSide, worker)\\n            while picking and picking[0][0] <= t:\\n                _, worker = heapq.heappop(picking)\\n                heapq.heappush(rightSide, worker)\\n        return t\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        leftSide = []\\n        rightSide = []\\n        picking = []\\n        putting = []\\n        for i, worker in enumerate(time):\\n            heapq.heappush(leftSide, [-(worker[0] + worker[2]), -i])\\n        t = 0\\n        while n or rightSide or picking or putting:\\n            if rightSide: # right to left passing\\n                worker = heapq.heappop(rightSide)\\n                t += time[-worker[1]][2]\\n                heapq.heappush(putting, [t + time[-worker[1]][3], worker])\\n            elif n and leftSide: # left to right passing\\n                worker = heapq.heappop(leftSide)\\n                t += time[-worker[1]][0]\\n                n -= 1\\n                heapq.heappush(picking, [t + time[-worker[1]][1], worker])\\n            # No one uses bridge, so move forward with the next worker who either picking or putting\\n            else:\\n                if not n and not picking:\\n                    # Ending Case\\n                    return t\\n                nextTime = []\\n                if picking:\\n                    nextTime.append(picking[0][0])\\n                if putting:\\n                    nextTime.append(putting[0][0])\\n                t = min(nextTime)\\n\\n            # Put all worker back to bridge queue if they finish at current time\\n            while putting and putting[0][0] <= t:\\n                _, worker = heapq.heappop(putting)\\n                heapq.heappush(leftSide, worker)\\n            while picking and picking[0][0] <= t:\\n                _, worker = heapq.heappop(picking)\\n                heapq.heappush(rightSide, worker)\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027604,
                "title": "golang-four-queues-85-ms-7-5-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n*logk)$$\\n- Space complexity: $$O(k)$$\\n# Code\\n```\\ntype Worker struct {\\n\\tefficiency  int32\\n\\tleftToRight int16\\n\\trightToLeft int16\\n\\tpickOld     int16\\n\\tputNew      int16\\n}\\n\\ntype BankQueue []Worker\\n\\nfunc (q BankQueue) Len() int            { return len(q) }\\nfunc (q BankQueue) Less(i, j int) bool  { return q[i].efficiency > q[j].efficiency }\\nfunc (q BankQueue) Swap(i, j int)       { q[i], q[j] = q[j], q[i] }\\nfunc (q *BankQueue) Push(x interface{}) { *q = append(*q, x.(Worker)) }\\nfunc (q *BankQueue) Pop() interface{} {\\n\\told := *q\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*q = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype Event struct {\\n\\ttime   int32\\n\\tworker Worker\\n}\\n\\ntype EventQueue []Event\\n\\nfunc (q EventQueue) Len() int            { return len(q) }\\nfunc (q EventQueue) Less(i, j int) bool  { return q[i].time < q[j].time }\\nfunc (q EventQueue) Swap(i, j int)       { q[i], q[j] = q[j], q[i] }\\nfunc (q *EventQueue) Push(x interface{}) { *q = append(*q, x.(Event)) }\\nfunc (q *EventQueue) Pop() interface{} {\\n\\told := *q\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*q = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc findCrossingTime(n int, k int, time [][]int) int {\\n\\tleftWarehouse := make(EventQueue, 0, k)\\n\\tleftBank := make(BankQueue, k)\\n\\tfor i, workerTime := range time {\\n\\t\\tleftBank[i] = Worker{\\n\\t\\t\\tefficiency:  int32(((workerTime[0] + workerTime[2]) << 16) | i),\\n\\t\\t\\tleftToRight: int16(workerTime[0]),\\n\\t\\t\\trightToLeft: int16(workerTime[2]),\\n\\t\\t\\tpickOld:     int16(workerTime[1]),\\n\\t\\t\\tputNew:      int16(workerTime[3]),\\n\\t\\t}\\n\\t}\\n\\theap.Init(&leftBank)\\n\\trightBank := make(BankQueue, 0, k)\\n\\trightWarehouse := make(EventQueue, 0, k)\\n\\tvar result int32\\n\\tfor n != 0 {\\n\\t\\tfor len(rightWarehouse) != 0 && rightWarehouse[0].time <= result {\\n\\t\\t\\theap.Push(&rightBank, rightWarehouse[0].worker)\\n\\t\\t\\theap.Pop(&rightWarehouse)\\n\\t\\t}\\n\\t\\tfor len(leftWarehouse) != 0 && leftWarehouse[0].time <= result {\\n\\t\\t\\theap.Push(&leftBank, leftWarehouse[0].worker)\\n\\t\\t\\theap.Pop(&leftWarehouse)\\n\\t\\t}\\n\\t\\tif len(rightBank) != 0 {\\n\\t\\t\\tresult += int32(rightBank[0].rightToLeft)\\n\\t\\t\\theap.Push(&leftWarehouse, Event{\\n\\t\\t\\t\\ttime:   result + int32(rightBank[0].putNew),\\n\\t\\t\\t\\tworker: rightBank[0],\\n\\t\\t\\t})\\n\\t\\t\\theap.Pop(&rightBank)\\n\\t\\t} else if len(leftBank) != 0 {\\n\\t\\t\\tresult += int32(leftBank[0].leftToRight)\\n\\t\\t\\theap.Push(&rightWarehouse, Event{\\n\\t\\t\\t\\ttime:   result + int32(leftBank[0].pickOld),\\n\\t\\t\\t\\tworker: leftBank[0],\\n\\t\\t\\t})\\n\\t\\t\\theap.Pop(&leftBank)\\n\\t\\t\\tn--\\n\\t\\t} else if len(leftWarehouse) != 0 && len(rightWarehouse) != 0 {\\n\\t\\t\\tif leftWarehouse[0].time <= rightWarehouse[0].time {\\n\\t\\t\\t\\tresult = leftWarehouse[0].time\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult = rightWarehouse[0].time\\n\\t\\t\\t}\\n\\t\\t} else if len(leftWarehouse) != 0 {\\n\\t\\t\\tresult = leftWarehouse[0].time\\n\\t\\t} else {\\n\\t\\t\\tresult = rightWarehouse[0].time\\n\\t\\t}\\n\\t}\\n\\tfor len(rightWarehouse) != 0 {\\n\\t\\tif rightWarehouse[0].time <= result {\\n\\t\\t\\tresult += int32(rightWarehouse[0].worker.rightToLeft)\\n\\t\\t} else {\\n\\t\\t\\tresult = rightWarehouse[0].time + int32(rightWarehouse[0].worker.rightToLeft)\\n\\t\\t}\\n\\t\\theap.Pop(&rightWarehouse)\\n\\t}\\n\\treturn int(result)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Worker struct {\\n\\tefficiency  int32\\n\\tleftToRight int16\\n\\trightToLeft int16\\n\\tpickOld     int16\\n\\tputNew      int16\\n}\\n\\ntype BankQueue []Worker\\n\\nfunc (q BankQueue) Len() int            { return len(q) }\\nfunc (q BankQueue) Less(i, j int) bool  { return q[i].efficiency > q[j].efficiency }\\nfunc (q BankQueue) Swap(i, j int)       { q[i], q[j] = q[j], q[i] }\\nfunc (q *BankQueue) Push(x interface{}) { *q = append(*q, x.(Worker)) }\\nfunc (q *BankQueue) Pop() interface{} {\\n\\told := *q\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*q = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype Event struct {\\n\\ttime   int32\\n\\tworker Worker\\n}\\n\\ntype EventQueue []Event\\n\\nfunc (q EventQueue) Len() int            { return len(q) }\\nfunc (q EventQueue) Less(i, j int) bool  { return q[i].time < q[j].time }\\nfunc (q EventQueue) Swap(i, j int)       { q[i], q[j] = q[j], q[i] }\\nfunc (q *EventQueue) Push(x interface{}) { *q = append(*q, x.(Event)) }\\nfunc (q *EventQueue) Pop() interface{} {\\n\\told := *q\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*q = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc findCrossingTime(n int, k int, time [][]int) int {\\n\\tleftWarehouse := make(EventQueue, 0, k)\\n\\tleftBank := make(BankQueue, k)\\n\\tfor i, workerTime := range time {\\n\\t\\tleftBank[i] = Worker{\\n\\t\\t\\tefficiency:  int32(((workerTime[0] + workerTime[2]) << 16) | i),\\n\\t\\t\\tleftToRight: int16(workerTime[0]),\\n\\t\\t\\trightToLeft: int16(workerTime[2]),\\n\\t\\t\\tpickOld:     int16(workerTime[1]),\\n\\t\\t\\tputNew:      int16(workerTime[3]),\\n\\t\\t}\\n\\t}\\n\\theap.Init(&leftBank)\\n\\trightBank := make(BankQueue, 0, k)\\n\\trightWarehouse := make(EventQueue, 0, k)\\n\\tvar result int32\\n\\tfor n != 0 {\\n\\t\\tfor len(rightWarehouse) != 0 && rightWarehouse[0].time <= result {\\n\\t\\t\\theap.Push(&rightBank, rightWarehouse[0].worker)\\n\\t\\t\\theap.Pop(&rightWarehouse)\\n\\t\\t}\\n\\t\\tfor len(leftWarehouse) != 0 && leftWarehouse[0].time <= result {\\n\\t\\t\\theap.Push(&leftBank, leftWarehouse[0].worker)\\n\\t\\t\\theap.Pop(&leftWarehouse)\\n\\t\\t}\\n\\t\\tif len(rightBank) != 0 {\\n\\t\\t\\tresult += int32(rightBank[0].rightToLeft)\\n\\t\\t\\theap.Push(&leftWarehouse, Event{\\n\\t\\t\\t\\ttime:   result + int32(rightBank[0].putNew),\\n\\t\\t\\t\\tworker: rightBank[0],\\n\\t\\t\\t})\\n\\t\\t\\theap.Pop(&rightBank)\\n\\t\\t} else if len(leftBank) != 0 {\\n\\t\\t\\tresult += int32(leftBank[0].leftToRight)\\n\\t\\t\\theap.Push(&rightWarehouse, Event{\\n\\t\\t\\t\\ttime:   result + int32(leftBank[0].pickOld),\\n\\t\\t\\t\\tworker: leftBank[0],\\n\\t\\t\\t})\\n\\t\\t\\theap.Pop(&leftBank)\\n\\t\\t\\tn--\\n\\t\\t} else if len(leftWarehouse) != 0 && len(rightWarehouse) != 0 {\\n\\t\\t\\tif leftWarehouse[0].time <= rightWarehouse[0].time {\\n\\t\\t\\t\\tresult = leftWarehouse[0].time\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult = rightWarehouse[0].time\\n\\t\\t\\t}\\n\\t\\t} else if len(leftWarehouse) != 0 {\\n\\t\\t\\tresult = leftWarehouse[0].time\\n\\t\\t} else {\\n\\t\\t\\tresult = rightWarehouse[0].time\\n\\t\\t}\\n\\t}\\n\\tfor len(rightWarehouse) != 0 {\\n\\t\\tif rightWarehouse[0].time <= result {\\n\\t\\t\\tresult += int32(rightWarehouse[0].worker.rightToLeft)\\n\\t\\t} else {\\n\\t\\t\\tresult = rightWarehouse[0].time + int32(rightWarehouse[0].worker.rightToLeft)\\n\\t\\t}\\n\\t\\theap.Pop(&rightWarehouse)\\n\\t}\\n\\treturn int(result)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3026554,
                "title": "easy-solution-with-intution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis was a kind of implementation problem where we can use priority queue to get which worker will cross bridge next and which workers had done their task of putting or picking boxes.\\n\\nFeel free to comment below in case you find any thing difficult to understand :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int currTime = 0, idx, t, boxLeftToPick = n, boxLeftToPut = n;\\n        priority_queue<pair<int, int>, vector<pii>, greater<pii>> leftHouse, rightHouse;\\n        priority_queue<pair<int, int>> leftBank, rightBank;\\n        // leftHouse, rightHouse -> <time of completion of storing/picking, index>\\n        // leftBank, rightBank -> <efficiency, index> \\n        pii worker;\\n\\n        for(int i = 0; i < k; i++)\\n        {\\n            worker.first = time[i][0] + time[i][2];\\n            worker.second = i;\\n            leftBank.push(worker);\\n        }\\n\\n        while(boxLeftToPut)\\n        {\\n            if(rightHouse.size())\\n            {\\n                worker = rightHouse.top();\\n                t = worker.first;\\n                idx = worker.second;\\n                if(t <= currTime)\\n                {\\n                    rightHouse.pop();\\n                    rightBank.push({time[idx][0] + time[idx][2], idx});\\n                    continue;\\n                }\\n            }\\n\\n            if(rightBank.size())\\n            {\\n                worker = rightBank.top();\\n                rightBank.pop();\\n                idx = worker.second;\\n                currTime += time[idx][2];\\n                t = currTime + time[idx][3];\\n                leftHouse.push({t , idx});\\n                boxLeftToPut--;\\n                if(boxLeftToPut == 0)\\n                return currTime;\\n                continue;\\n            }\\n\\n            if(leftHouse.size())\\n            {\\n                worker = leftHouse.top();\\n                t = worker.first;\\n                idx = worker.second;\\n                if(t <= currTime)\\n                {\\n                    leftHouse.pop();\\n                    leftBank.push({time[idx][0] + time[idx][2], idx});\\n                    continue;\\n                }\\n            }\\n\\n            if(leftBank.size())\\n            { \\n                worker = leftBank.top();\\n                leftBank.pop();\\n                idx = worker.second;\\n                currTime += time[idx][0];\\n                t = currTime + time[idx][1];\\n                if(boxLeftToPick != 0)\\n                { \\n                    rightHouse.push({t , idx});\\n                    boxLeftToPick--;\\n                    continue;\\n                }\\n            }\\n\\n            t = 1e9;\\n            if(leftHouse.size())\\n            t = leftHouse.top().first;\\n            if(rightHouse.size())\\n            t = min(t, rightHouse.top().first);\\n            currTime = t;  \\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int currTime = 0, idx, t, boxLeftToPick = n, boxLeftToPut = n;\\n        priority_queue<pair<int, int>, vector<pii>, greater<pii>> leftHouse, rightHouse;\\n        priority_queue<pair<int, int>> leftBank, rightBank;\\n        // leftHouse, rightHouse -> <time of completion of storing/picking, index>\\n        // leftBank, rightBank -> <efficiency, index> \\n        pii worker;\\n\\n        for(int i = 0; i < k; i++)\\n        {\\n            worker.first = time[i][0] + time[i][2];\\n            worker.second = i;\\n            leftBank.push(worker);\\n        }\\n\\n        while(boxLeftToPut)\\n        {\\n            if(rightHouse.size())\\n            {\\n                worker = rightHouse.top();\\n                t = worker.first;\\n                idx = worker.second;\\n                if(t <= currTime)\\n                {\\n                    rightHouse.pop();\\n                    rightBank.push({time[idx][0] + time[idx][2], idx});\\n                    continue;\\n                }\\n            }\\n\\n            if(rightBank.size())\\n            {\\n                worker = rightBank.top();\\n                rightBank.pop();\\n                idx = worker.second;\\n                currTime += time[idx][2];\\n                t = currTime + time[idx][3];\\n                leftHouse.push({t , idx});\\n                boxLeftToPut--;\\n                if(boxLeftToPut == 0)\\n                return currTime;\\n                continue;\\n            }\\n\\n            if(leftHouse.size())\\n            {\\n                worker = leftHouse.top();\\n                t = worker.first;\\n                idx = worker.second;\\n                if(t <= currTime)\\n                {\\n                    leftHouse.pop();\\n                    leftBank.push({time[idx][0] + time[idx][2], idx});\\n                    continue;\\n                }\\n            }\\n\\n            if(leftBank.size())\\n            { \\n                worker = leftBank.top();\\n                leftBank.pop();\\n                idx = worker.second;\\n                currTime += time[idx][0];\\n                t = currTime + time[idx][1];\\n                if(boxLeftToPick != 0)\\n                { \\n                    rightHouse.push({t , idx});\\n                    boxLeftToPick--;\\n                    continue;\\n                }\\n            }\\n\\n            t = 1e9;\\n            if(leftHouse.size())\\n            t = leftHouse.top().first;\\n            if(rightHouse.size())\\n            t = min(t, rightHouse.top().first);\\n            currTime = t;  \\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019596,
                "title": "c-detailed-explanation-clean-easy-2-heaps-and-1-set",
                "content": "Following observations can make the implementation much simpler:\\n\\n- Let\\'s just think about workers waiting on both the banks of the river. Ignore anyone who is picking or dropping the boxes.\\n  - To handle this all we need to do is to maintain min-heaps (based on efficiency) for each of the banks\\n  - Initially put all the workers in the heap for the left bank, since all of them are good to go.\\n  - We\\'ll keep a variable to track the current time, let\\'s call it `t`.\\n  - In each iteration, we first check the right bank. If a worker is available, let him cross over. If no worker is available on the right bank, and some box is left in the old warehouse, then let the top-most worker cross the bridge.\\n\\nNow, let\\'s put the workers picking or dropping boxes into the above solution. A worker reaches the bank, then he/she either picks (if on the right bank) or drops (if on the left bank). Given the current time `t`, we can figure out when the worker would be available to cross the bridge. That time would be some time greater than `t`  (i.e. in the future).\\nSo, all we need is a good mechanism to push notifications to my min-heaps that \"hey, I am good to go, please consider me too henceforth\". How to do this?\\n- Let\\'s maintain a `set`, call it `st`, whenever a worker lands on the bridge, he\\'ll push an event indicating the time when he\\'ll be free.\\n- In each iteration, we check our `st` for all the notifications which should have been pushed to respective min-heaps by now (i.e. by time `t`). That should be fairly easy to do, all we need is a list of all event where the time is lesser than `t`. Once we get these notifications, we process them, i.e. we push the available worker to the respective priority queue.\\n\\nNow, converge both the solutions above, and here\\'s what we have.\\n- Maintain 2 heaps, one for each bank\\n- Initially push all the workers to the min-heap for the left bank\\n- Start simulation with `t = 0`\\n- Maintain a flag to see if the process is `done = false`\\n- In each iteration (until `!done`)\\n  1) Check all the events in `st` which should have occurred by `t`. Process all of them.\\n  2) Check if min-heap for the right bank is empty, if not empty.\\n      - Pop the top worker from heap, and let him cross the bridge and reach the left bank. \\n      - Increase your `t` accordingly (don\\'t include the time to pick the box). `t` is supposed to track movement of workers across the bridge.\\n      - Insert the time he\\'ll be available next in `st`.\\n      - If he was the worker with the last box, mark `done = true` \\n  3) If the right bank heap in (2) was empty and you still got some boxes left in the old warehouse, check the left bank heap. If not empty,\\n      -  Pop the top worker from heap, and let him cross the bridge and reach the right bank.\\n      - Increase your `t` accordingly (don\\'t include the time to pick the box)\\n      - Insert the time he\\'ll be available next in `st`.\\n      - Reduce the number of boxes available in the old warehouse by 1. \\n  4) If both left & right bank heaps are empty [in (2) and (3)], this means no worker is available to cross the bridge right now. All of them are busy in picking or dropping the boxes. Now you need the time for the first worker to become available. That\\'s simple, it\\'s the earliest time of the event in our `st`. Simply update `t` to the earliest time in `st` and you\\'re good to move to the next iteration.\\n\\n`t` is your answer. Note that when we update `t`, we never include the time to pick/drop. That is handled separately by polling our `st`. So, at the end, `t` won\\'t include the time to drop the last box to the new warehouse.\\n\\nRefer to my submission (with comments) here : https://leetcode.com/submissions/detail/874047326/",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "Following observations can make the implementation much simpler:\\n\\n- Let\\'s just think about workers waiting on both the banks of the river. Ignore anyone who is picking or dropping the boxes.\\n  - To handle this all we need to do is to maintain min-heaps (based on efficiency) for each of the banks\\n  - Initially put all the workers in the heap for the left bank, since all of them are good to go.\\n  - We\\'ll keep a variable to track the current time, let\\'s call it `t`.\\n  - In each iteration, we first check the right bank. If a worker is available, let him cross over. If no worker is available on the right bank, and some box is left in the old warehouse, then let the top-most worker cross the bridge.\\n\\nNow, let\\'s put the workers picking or dropping boxes into the above solution. A worker reaches the bank, then he/she either picks (if on the right bank) or drops (if on the left bank). Given the current time `t`, we can figure out when the worker would be available to cross the bridge. That time would be some time greater than `t`  (i.e. in the future).\\nSo, all we need is a good mechanism to push notifications to my min-heaps that \"hey, I am good to go, please consider me too henceforth\". How to do this?\\n- Let\\'s maintain a `set`, call it `st`, whenever a worker lands on the bridge, he\\'ll push an event indicating the time when he\\'ll be free.\\n- In each iteration, we check our `st` for all the notifications which should have been pushed to respective min-heaps by now (i.e. by time `t`). That should be fairly easy to do, all we need is a list of all event where the time is lesser than `t`. Once we get these notifications, we process them, i.e. we push the available worker to the respective priority queue.\\n\\nNow, converge both the solutions above, and here\\'s what we have.\\n- Maintain 2 heaps, one for each bank\\n- Initially push all the workers to the min-heap for the left bank\\n- Start simulation with `t = 0`\\n- Maintain a flag to see if the process is `done = false`\\n- In each iteration (until `!done`)\\n  1) Check all the events in `st` which should have occurred by `t`. Process all of them.\\n  2) Check if min-heap for the right bank is empty, if not empty.\\n      - Pop the top worker from heap, and let him cross the bridge and reach the left bank. \\n      - Increase your `t` accordingly (don\\'t include the time to pick the box). `t` is supposed to track movement of workers across the bridge.\\n      - Insert the time he\\'ll be available next in `st`.\\n      - If he was the worker with the last box, mark `done = true` \\n  3) If the right bank heap in (2) was empty and you still got some boxes left in the old warehouse, check the left bank heap. If not empty,\\n      -  Pop the top worker from heap, and let him cross the bridge and reach the right bank.\\n      - Increase your `t` accordingly (don\\'t include the time to pick the box)\\n      - Insert the time he\\'ll be available next in `st`.\\n      - Reduce the number of boxes available in the old warehouse by 1. \\n  4) If both left & right bank heaps are empty [in (2) and (3)], this means no worker is available to cross the bridge right now. All of them are busy in picking or dropping the boxes. Now you need the time for the first worker to become available. That\\'s simple, it\\'s the earliest time of the event in our `st`. Simply update `t` to the earliest time in `st` and you\\'re good to move to the next iteration.\\n\\n`t` is your answer. Note that when we update `t`, we never include the time to pick/drop. That is handled separately by polling our `st`. So, at the end, `t` won\\'t include the time to drop the last box to the new warehouse.\\n\\nRefer to my submission (with comments) here : https://leetcode.com/submissions/detail/874047326/",
                "codeTag": "Unknown"
            },
            {
                "id": 3017163,
                "title": "java-straightforward-simulation-solution-with-comments",
                "content": "# Intuition\\nSimulate the process with priority queues. We need 4 of them, leftPending, rightPending, leftWIP, rightWIP. \\n\\nPending ones means the workers are ready to cross the bridge (without a box on left, or with a box on right). WIP ones means the workers are picking up boxes, or dropping them off.\\n\\nWe also need to maintain a varialble for bridge (specifically, when the bridge will be free), because at one time, there is only one worker allowed on the bridge.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        Queue<Integer> leftPending = new PriorityQueue<>((i, j) -> {\\n            if (time[i][0] + time[i][2] != time[j][0] + time[j][2]) {\\n                return Integer.compare(time[j][0] + time[j][2], time[i][0] + time[i][2]);\\n            } else {\\n                return Integer.compare(j, i);\\n            }\\n        });\\n\\n        Queue<Integer> rightPending = new PriorityQueue<>((i, j) -> {\\n            if (time[i][0] + time[i][2] != time[j][0] + time[j][2]) {\\n                return Integer.compare(time[j][0] + time[j][2], time[i][0] + time[i][2]);\\n            } else {\\n                return Integer.compare(j, i);\\n            }\\n        });\\n\\n        // In WIP queues, an item [x, y] means worker x will complete the job (pick up box or drop off box) on time y\\n        Queue<int[]> leftWIP = new PriorityQueue<>(Comparator.comparingInt(i -> i[1]));\\n        Queue<int[]> rightWIP = new PriorityQueue<>(Comparator.comparingInt(i -> i[1]));\\n\\n        // Initially, add all workers to leftPending\\n        for (int i = 0; i < k; i++) {\\n            leftPending.add(i);\\n        }\\n\\n        int bridge = 0;\\n        while (n > 0) {\\n            // Drain the WIP queues at time \"bridge\"\\n            drainWIP(leftWIP, leftPending, bridge);\\n            drainWIP(rightWIP, rightPending, bridge);\\n\\n            // If both leftPending and rightPending are empty, all workers are actively picking up / dropping off boxes\\n            // Get the next time\\n            if (leftPending.isEmpty() && rightPending.isEmpty()) {\\n                if (leftWIP.isEmpty()) {\\n                    bridge = rightWIP.peek()[1];\\n                } else if (rightWIP.isEmpty()) {\\n                    bridge = leftWIP.peek()[1];\\n                } else {\\n                    bridge = Math.min(leftWIP.peek()[1], rightWIP.peek()[1]);\\n                }\\n            } else if (!rightPending.isEmpty()) { // Move a worker to left if there are workers pending right\\n                int w = rightPending.poll();\\n                bridge += time[w][2];\\n\\n                leftWIP.add(new int[] {w, bridge + time[w][3]});\\n            } else { // Move a worker to right\\n                int w = leftPending.poll();\\n                bridge += time[w][0];\\n\\n                n--;\\n                rightWIP.add(new int[] {w, bridge + time[w][1]});\\n            }\\n        }\\n\\n        // Drain remaining rightWIP\\n        while (!rightWIP.isEmpty()) {\\n            int[] w = rightWIP.poll();\\n            if (w[1] > bridge) {\\n                bridge = w[1];\\n            }\\n\\n            bridge += time[w[0]][2];\\n        }\\n\\n        return bridge;\\n    }\\n\\n    private void drainWIP(Queue<int[]> wip, Queue<Integer> pending, int bridge) {\\n        while (!wip.isEmpty() && wip.peek()[1] <= bridge) {\\n            pending.add(wip.poll()[0]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        Queue<Integer> leftPending = new PriorityQueue<>((i, j) -> {\\n            if (time[i][0] + time[i][2] != time[j][0] + time[j][2]) {\\n                return Integer.compare(time[j][0] + time[j][2], time[i][0] + time[i][2]);\\n            } else {\\n                return Integer.compare(j, i);\\n            }\\n        });\\n\\n        Queue<Integer> rightPending = new PriorityQueue<>((i, j) -> {\\n            if (time[i][0] + time[i][2] != time[j][0] + time[j][2]) {\\n                return Integer.compare(time[j][0] + time[j][2], time[i][0] + time[i][2]);\\n            } else {\\n                return Integer.compare(j, i);\\n            }\\n        });\\n\\n        // In WIP queues, an item [x, y] means worker x will complete the job (pick up box or drop off box) on time y\\n        Queue<int[]> leftWIP = new PriorityQueue<>(Comparator.comparingInt(i -> i[1]));\\n        Queue<int[]> rightWIP = new PriorityQueue<>(Comparator.comparingInt(i -> i[1]));\\n\\n        // Initially, add all workers to leftPending\\n        for (int i = 0; i < k; i++) {\\n            leftPending.add(i);\\n        }\\n\\n        int bridge = 0;\\n        while (n > 0) {\\n            // Drain the WIP queues at time \"bridge\"\\n            drainWIP(leftWIP, leftPending, bridge);\\n            drainWIP(rightWIP, rightPending, bridge);\\n\\n            // If both leftPending and rightPending are empty, all workers are actively picking up / dropping off boxes\\n            // Get the next time\\n            if (leftPending.isEmpty() && rightPending.isEmpty()) {\\n                if (leftWIP.isEmpty()) {\\n                    bridge = rightWIP.peek()[1];\\n                } else if (rightWIP.isEmpty()) {\\n                    bridge = leftWIP.peek()[1];\\n                } else {\\n                    bridge = Math.min(leftWIP.peek()[1], rightWIP.peek()[1]);\\n                }\\n            } else if (!rightPending.isEmpty()) { // Move a worker to left if there are workers pending right\\n                int w = rightPending.poll();\\n                bridge += time[w][2];\\n\\n                leftWIP.add(new int[] {w, bridge + time[w][3]});\\n            } else { // Move a worker to right\\n                int w = leftPending.poll();\\n                bridge += time[w][0];\\n\\n                n--;\\n                rightWIP.add(new int[] {w, bridge + time[w][1]});\\n            }\\n        }\\n\\n        // Drain remaining rightWIP\\n        while (!rightWIP.isEmpty()) {\\n            int[] w = rightWIP.poll();\\n            if (w[1] > bridge) {\\n                bridge = w[1];\\n            }\\n\\n            bridge += time[w[0]][2];\\n        }\\n\\n        return bridge;\\n    }\\n\\n    private void drainWIP(Queue<int[]> wip, Queue<Integer> pending, int bridge) {\\n        while (!wip.isEmpty() && wip.peek()[1] <= bridge) {\\n            pending.add(wip.poll()[0]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017008,
                "title": "simulation-with-prioirty-queue-with-detailed-comments",
                "content": "Create 4 heaps to keep track of the following.\\n1. The workers waiting on the left bank. Heap - sorted by efficiency. Send the least efficient person first.\\n2. The workers that are in the process of putting new box in the left ware house. Heap - sorted by their completion time, when they would come back to left bank\\n3. The workers waiting on the right bank. Heap - sorted by efficiency. Send the least efficient person first.\\n4. The workers that are in the process of picking up boxes from the right (old) waerhouse. Heap - sorted by their completion time, when they would come back to right bank\\n\\nA corner case that I missed during case: Do not send more workers from left to right, if there aren\\'t enough boxes to pick on the right bank.\\n\\n```\\n#define PII pair<int,pair<int,pair<int,pair<int,int>>>>\\n\\nclass Compare {\\npublic:\\n    bool operator()(PII& p1, PII& p2)\\n    {\\n        //pair<leftToRight,pair<pickOld,pair<rightToLeft,pair<putNew,index>>>>\\n        int ltr1 = p1.first;\\n        int po1 = p1.second.first;\\n        int rtl1 = p1.second.second.first;\\n        int pn1 = p1.second.second.second.first;\\n        int idx1 = p1.second.second.second.second;\\n        \\n        \\n        int ltr2 = p2.first;\\n        int po2 = p2.second.first;\\n        int rtl2 = p2.second.second.first;\\n        int pn2 = p2.second.second.second.first;\\n        int idx2 = p2.second.second.second.second;        \\n        \\n        \\n        if(ltr1 + rtl1 < ltr2 + rtl2) {\\n            return true;\\n        } else if(ltr1 + rtl1 > ltr2 + rtl2) {\\n            return false;\\n        } else {\\n            // compare idx;\\n            if(idx1 < idx2) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<PII, vector<PII>, Compare> pql;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>>>leftWait;\\n        for(int i=0;i<time.size();i++) {\\n            pql.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});\\n        }\\n        priority_queue<PII, vector<PII>, Compare> pqr;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>>>rightWait;\\n        // now we have sorted the workers by efficiency; lets go box by box;\\n        int lastLeftTime = 0;\\n        int curTime = 0;\\n        while(n) {            \\n            // cout<<\"Now Time is \" <<curTime<<\"\\\\n\";\\n            // if nobody is on either side of the bridge; jump fwd in time;\\n            if(pql.size() == 0 && pqr.size() == 0) {\\n                // see who is the first on wait list;\\n                if(leftWait.size() == 0) {\\n                    curTime = rightWait.top().first;\\n                    pair<int,int> t = rightWait.top();                \\n                    rightWait.pop();\\n                    int i = t.second;\\n                    pqr.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});\\n                } else if(rightWait.size() == 0) {\\n                    curTime = leftWait.top().first;                    \\n                    pair<int,int> t = leftWait.top();                                    \\n                    leftWait.pop();\\n                    int i = t.second;\\n                    pql.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});                      \\n                }\\n                else if(leftWait.top().first < rightWait.top().first) {\\n                    curTime = leftWait.top().first;\\n                    pair<int,int> t = leftWait.top();                \\n                    if(t.first > curTime) {\\n                        break;\\n                    }\\n                    leftWait.pop();\\n                    int i = t.second;\\n                    pql.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});                      \\n                } else {\\n                    curTime = rightWait.top().first;\\n                    pair<int,int> t = rightWait.top();\\n                    rightWait.pop();\\n                    int i = t.second;\\n                    pqr.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});\\n                }\\n                \\n                continue;\\n            }\\n            \\n            // see who all has come back;\\n            while(leftWait.size()) {\\n                pair<int,int> t = leftWait.top();                \\n                if(t.first > curTime) {\\n                    break;\\n                }\\n                leftWait.pop();\\n                int i = t.second;\\n                pql.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});                            \\n            }\\n            \\n            while(rightWait.size()) {\\n                pair<int,int> t = rightWait.top();\\n                if(t.first > curTime) {\\n                    break;\\n                }\\n                rightWait.pop();\\n                int i = t.second;\\n                pqr.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});\\n            }\\n            \\n            // now let the guy on the right pass;\\n            if(pqr.size() > 0) {\\n                PII p = pqr.top();\\n                int timeToCross = p.second.second.first;                \\n                curTime += timeToCross;\\n                lastLeftTime = curTime;\\n                int idx = p.second.second.second.second;                 \\n                int pn = p.second.second.second.first; // put new in new wh\\n                n--;\\n                leftWait.push({pn+curTime,idx});\\n                pqr.pop();\\n            } else {\\n                // nobody on the right; let the guy on the left pass; pql must be > 0 size; gotta ensure this;\\n                // but should we ? if we don\\'t have stuff on the right and we keep sending more guys, then it might cause chaos;\\n                if(n == rightWait.size()) {\\n                    // staahhhp;\\n                    curTime = rightWait.top().first;\\n                    continue;\\n                }\\n                PII p = pql.top();\\n                int timeToCross = p.first;\\n                curTime += timeToCross;\\n                int idx = p.second.second.second.second;                   \\n                int po = p.second.first; // pick old from old wh\\n                rightWait.push({po+curTime,idx});\\n                pql.pop();\\n            }                        \\n            \\n            \\n        }\\n        \\n       \\n        \\n        return lastLeftTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\n#define PII pair<int,pair<int,pair<int,pair<int,int>>>>\\n\\nclass Compare {\\npublic:\\n    bool operator()(PII& p1, PII& p2)\\n    {\\n        //pair<leftToRight,pair<pickOld,pair<rightToLeft,pair<putNew,index>>>>\\n        int ltr1 = p1.first;\\n        int po1 = p1.second.first;\\n        int rtl1 = p1.second.second.first;\\n        int pn1 = p1.second.second.second.first;\\n        int idx1 = p1.second.second.second.second;\\n        \\n        \\n        int ltr2 = p2.first;\\n        int po2 = p2.second.first;\\n        int rtl2 = p2.second.second.first;\\n        int pn2 = p2.second.second.second.first;\\n        int idx2 = p2.second.second.second.second;        \\n        \\n        \\n        if(ltr1 + rtl1 < ltr2 + rtl2) {\\n            return true;\\n        } else if(ltr1 + rtl1 > ltr2 + rtl2) {\\n            return false;\\n        } else {\\n            // compare idx;\\n            if(idx1 < idx2) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<PII, vector<PII>, Compare> pql;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>>>leftWait;\\n        for(int i=0;i<time.size();i++) {\\n            pql.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});\\n        }\\n        priority_queue<PII, vector<PII>, Compare> pqr;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>>>rightWait;\\n        // now we have sorted the workers by efficiency; lets go box by box;\\n        int lastLeftTime = 0;\\n        int curTime = 0;\\n        while(n) {            \\n            // cout<<\"Now Time is \" <<curTime<<\"\\\\n\";\\n            // if nobody is on either side of the bridge; jump fwd in time;\\n            if(pql.size() == 0 && pqr.size() == 0) {\\n                // see who is the first on wait list;\\n                if(leftWait.size() == 0) {\\n                    curTime = rightWait.top().first;\\n                    pair<int,int> t = rightWait.top();                \\n                    rightWait.pop();\\n                    int i = t.second;\\n                    pqr.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});\\n                } else if(rightWait.size() == 0) {\\n                    curTime = leftWait.top().first;                    \\n                    pair<int,int> t = leftWait.top();                                    \\n                    leftWait.pop();\\n                    int i = t.second;\\n                    pql.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});                      \\n                }\\n                else if(leftWait.top().first < rightWait.top().first) {\\n                    curTime = leftWait.top().first;\\n                    pair<int,int> t = leftWait.top();                \\n                    if(t.first > curTime) {\\n                        break;\\n                    }\\n                    leftWait.pop();\\n                    int i = t.second;\\n                    pql.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});                      \\n                } else {\\n                    curTime = rightWait.top().first;\\n                    pair<int,int> t = rightWait.top();\\n                    rightWait.pop();\\n                    int i = t.second;\\n                    pqr.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});\\n                }\\n                \\n                continue;\\n            }\\n            \\n            // see who all has come back;\\n            while(leftWait.size()) {\\n                pair<int,int> t = leftWait.top();                \\n                if(t.first > curTime) {\\n                    break;\\n                }\\n                leftWait.pop();\\n                int i = t.second;\\n                pql.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});                            \\n            }\\n            \\n            while(rightWait.size()) {\\n                pair<int,int> t = rightWait.top();\\n                if(t.first > curTime) {\\n                    break;\\n                }\\n                rightWait.pop();\\n                int i = t.second;\\n                pqr.push({time[i][0],{time[i][1],{time[i][2],{time[i][3],i}}}});\\n            }\\n            \\n            // now let the guy on the right pass;\\n            if(pqr.size() > 0) {\\n                PII p = pqr.top();\\n                int timeToCross = p.second.second.first;                \\n                curTime += timeToCross;\\n                lastLeftTime = curTime;\\n                int idx = p.second.second.second.second;                 \\n                int pn = p.second.second.second.first; // put new in new wh\\n                n--;\\n                leftWait.push({pn+curTime,idx});\\n                pqr.pop();\\n            } else {\\n                // nobody on the right; let the guy on the left pass; pql must be > 0 size; gotta ensure this;\\n                // but should we ? if we don\\'t have stuff on the right and we keep sending more guys, then it might cause chaos;\\n                if(n == rightWait.size()) {\\n                    // staahhhp;\\n                    curTime = rightWait.top().first;\\n                    continue;\\n                }\\n                PII p = pql.top();\\n                int timeToCross = p.first;\\n                curTime += timeToCross;\\n                int idx = p.second.second.second.second;                   \\n                int po = p.second.first; // pick old from old wh\\n                rightWait.push({po+curTime,idx});\\n                pql.pop();\\n            }                        \\n            \\n            \\n        }\\n        \\n       \\n        \\n        return lastLeftTime;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3016895,
                "title": "python3-heap-based-simulation",
                "content": "Credit to @Yawn_Sean for this incredible solution (for self-learning purpose).\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        ans = 0\\n        left = [[-t[0]-t[2], -i] for i, t in enumerate(time)]\\n        right = []\\n        save = []\\n        heapify(left)\\n        cnt = note = tmstamp = 0\\n        while cnt < n:\\n            if len(left) == len(right) == 0 and save[0][0] > tmstamp:\\n                tmstamp = save[0][0]\\n            while save and save[0][0] <= tmstamp:\\n                t, eff, idx, direction = heappop(save)\\n                if direction == 1:\\n                    heappush(left, [eff, idx])\\n                else:\\n                    heappush(right, [eff, idx])\\n            flag = True\\n            if note == n:\\n                while len(right) == 0:\\n                    t, eff, idx, direction = heappop(save)\\n                    tmstamp = t\\n                    if direction == 0: heappush(right, [eff, idx])\\n            elif len(right) == 0: flag = False\\n            cnt += flag\\n            if flag:\\n                eff, idx = heappop(right)\\n                tmstamp += time[-idx][2]\\n                heappush(save, [tmstamp + time[-idx][3], eff, idx, 1])\\n            else:\\n                eff, idx = heappop(left)\\n                tmstamp += time[-idx][0]\\n                heappush(save, [tmstamp + time[-idx][1], eff, idx, 0])\\n                note += 1\\n        return tmstamp\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        ans = 0\\n        left = [[-t[0]-t[2], -i] for i, t in enumerate(time)]\\n        right = []\\n        save = []\\n        heapify(left)\\n        cnt = note = tmstamp = 0\\n        while cnt < n:\\n            if len(left) == len(right) == 0 and save[0][0] > tmstamp:\\n                tmstamp = save[0][0]\\n            while save and save[0][0] <= tmstamp:\\n                t, eff, idx, direction = heappop(save)\\n                if direction == 1:\\n                    heappush(left, [eff, idx])\\n                else:\\n                    heappush(right, [eff, idx])\\n            flag = True\\n            if note == n:\\n                while len(right) == 0:\\n                    t, eff, idx, direction = heappop(save)\\n                    tmstamp = t\\n                    if direction == 0: heappush(right, [eff, idx])\\n            elif len(right) == 0: flag = False\\n            cnt += flag\\n            if flag:\\n                eff, idx = heappop(right)\\n                tmstamp += time[-idx][2]\\n                heappush(save, [tmstamp + time[-idx][3], eff, idx, 1])\\n            else:\\n                eff, idx = heappop(left)\\n                tmstamp += time[-idx][0]\\n                heappush(save, [tmstamp + time[-idx][1], eff, idx, 0])\\n                note += 1\\n        return tmstamp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016854,
                "title": "c-decoupled-and-straightforward-logic-state-machine",
                "content": "We use priority queue to manage the sequence that each event is processed. At every timetamp, we process all the events happening at the same time. We know the task that is finished and the worker done that so we can put the worker into next state. Workers are getting modeled a state machine and states go in a loop. Each state will have corresponding processing.\\n\\nAfter done processing all the event, depending on the availbility of the bridge, some worker will start crossing the bridge; or nothing will happen.\\n\\n```\\nstruct State {\\n    int time;\\n    // -1: not specified\\n    // 0: left to right\\n    // 1: pickOld\\n    // 2: right to left\\n    // 3: put New\\n    int donetask;\\n    // -1: not specified\\n    int worker;\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        // k * 4\\n        // time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].\\n        \\n        // left queue and right queue\\n        priority_queue<vector<int>> lq, rq;\\n        \\n        // put all worker into lq\\n        for (int i = 0; i < k; ++i) {\\n            // bridge time, index\\n            lq.push(gets(i, time));\\n        }\\n        \\n        // State: [time, done task, worker]\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> tq;\\n        tq.push({0, -1, -1});\\n        \\n        // current time\\n        int t = 0;\\n        // last worker for get last putNew time\\n        int lw = -1;\\n        \\n        // whether bridge is in use\\n        bool bridge = false;\\n        \\n        int res = 0;\\n        while (tq.size()) {\\n            // cur time\\n            t = tq.top()[0];\\n            \\n            // process all same time\\n            while (tq.size() && tq.top()[0] == t) {\\n                auto ts = tq.top();\\n                int dt = ts[1]; // done task\\n                int worker = ts[2]; // worker index\\n                tq.pop();\\n                \\n                if (dt == 1) {\\n                    // done pick old, add to rq\\n                    rq.push(gets(worker, time));\\n                } else if (dt == 3) {\\n                    // done put new, add to lq\\n                    lq.push(gets(worker, time));\\n                } else if (dt == 0) {\\n                    // crossed bridge from left to right, next pick old\\n                    tq.push({t + time[worker][1], 1, worker});\\n                    n--;\\n                    bridge = false;\\n                } else if (dt == 2) {\\n                    // crossed bridge from right to left, next put new\\n                    tq.push({t + time[worker][3], 3, worker});\\n                    lw = worker;\\n                    bridge = false;\\n                    \\n                    // save the time last person get back to left\\n                    res = t;\\n                }    \\n            }\\n            \\n            // if bridge in use, nothing can do\\n            if (bridge) continue;\\n            \\n            // bridge should be false/free here\\n            if (!rq.empty()) {\\n                // if someone waiting on right\\n                \\n                // get worker\\n                auto v = rq.top();\\n                rq.pop();\\n                \\n                int cw = v[1];\\n                \\n                // this worker will cross from right to left\\n                tq.push({t + time[cw][2], 2, cw});\\n                \\n                // put bridge in use\\n                bridge = true;\\n            } else if (n && !lq.empty()) {\\n                // if there\\'s box on the right and no one waiting on the right\\n                \\n                // get worker\\n                auto v = lq.top();\\n                lq.pop();\\n                \\n                int cw = v[1];\\n                \\n                // this worker will cross left to right\\n                tq.push({t + time[cw][0], 0, cw});\\n                \\n                // put bridge in use\\n                bridge = true;\\n            } \\n        }\\n        \\n        return res;\\n    }\\n    \\n    vector<int> gets(int i, vector<vector<int>>& time) {\\n        vector<int> v = time[i];\\n        return {v[0] + v[2], i};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct State {\\n    int time;\\n    // -1: not specified\\n    // 0: left to right\\n    // 1: pickOld\\n    // 2: right to left\\n    // 3: put New\\n    int donetask;\\n    // -1: not specified\\n    int worker;\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        // k * 4\\n        // time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].\\n        \\n        // left queue and right queue\\n        priority_queue<vector<int>> lq, rq;\\n        \\n        // put all worker into lq\\n        for (int i = 0; i < k; ++i) {\\n            // bridge time, index\\n            lq.push(gets(i, time));\\n        }\\n        \\n        // State: [time, done task, worker]\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> tq;\\n        tq.push({0, -1, -1});\\n        \\n        // current time\\n        int t = 0;\\n        // last worker for get last putNew time\\n        int lw = -1;\\n        \\n        // whether bridge is in use\\n        bool bridge = false;\\n        \\n        int res = 0;\\n        while (tq.size()) {\\n            // cur time\\n            t = tq.top()[0];\\n            \\n            // process all same time\\n            while (tq.size() && tq.top()[0] == t) {\\n                auto ts = tq.top();\\n                int dt = ts[1]; // done task\\n                int worker = ts[2]; // worker index\\n                tq.pop();\\n                \\n                if (dt == 1) {\\n                    // done pick old, add to rq\\n                    rq.push(gets(worker, time));\\n                } else if (dt == 3) {\\n                    // done put new, add to lq\\n                    lq.push(gets(worker, time));\\n                } else if (dt == 0) {\\n                    // crossed bridge from left to right, next pick old\\n                    tq.push({t + time[worker][1], 1, worker});\\n                    n--;\\n                    bridge = false;\\n                } else if (dt == 2) {\\n                    // crossed bridge from right to left, next put new\\n                    tq.push({t + time[worker][3], 3, worker});\\n                    lw = worker;\\n                    bridge = false;\\n                    \\n                    // save the time last person get back to left\\n                    res = t;\\n                }    \\n            }\\n            \\n            // if bridge in use, nothing can do\\n            if (bridge) continue;\\n            \\n            // bridge should be false/free here\\n            if (!rq.empty()) {\\n                // if someone waiting on right\\n                \\n                // get worker\\n                auto v = rq.top();\\n                rq.pop();\\n                \\n                int cw = v[1];\\n                \\n                // this worker will cross from right to left\\n                tq.push({t + time[cw][2], 2, cw});\\n                \\n                // put bridge in use\\n                bridge = true;\\n            } else if (n && !lq.empty()) {\\n                // if there\\'s box on the right and no one waiting on the right\\n                \\n                // get worker\\n                auto v = lq.top();\\n                lq.pop();\\n                \\n                int cw = v[1];\\n                \\n                // this worker will cross left to right\\n                tq.push({t + time[cw][0], 0, cw});\\n                \\n                // put bridge in use\\n                bridge = true;\\n            } \\n        }\\n        \\n        return res;\\n    }\\n    \\n    vector<int> gets(int i, vector<vector<int>>& time) {\\n        vector<int> v = time[i];\\n        return {v[0] + v[2], i};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867842,
                "title": "solution-in-swift",
                "content": "# Approach\\nThe main for-loop in the code handles the following steps:\\n1. Update the waiting list on the bridge.\\n2. Pick a worker to pass the bridge based on the defined conditions.\\n3. Advance the time.\\n4. Update the count of remaining boxes that need to be moved.\\n\\n# Noteworthy points:\\n1. When there are enough workers on the right bank, workers on the left side should not pass the bridge.\\n2. When there are no workers waiting to cross the bridge on either side, the time is moved to the next moment when a worker could potentially be waiting to cross.\\n\\n# Complexity\\nOverflow checks have been taken into consideration. The maximum time to move a box is at most 4 * 1000 (four steps to move the box, each taking 1000 time). With at most 1e4 boxes, the total time is at most 4e7, ensuring the solution is safe.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    func findCrossingTime(_ n: Int, _ k: Int, _ time: [[Int]]) -> Int {\\n        var lBank = PriorityQueue<Int>(comparator: { (a, b) -> Bool in\\n            let ta = time[a]\\n            let tb = time[b]\\n            let ca = ta[0] + ta[2]\\n            let cb = tb[0] + tb[2]\\n            if ca == cb { return b < a }  // larger index cross first\\n            return cb < ca  // larger cross time cross first\\n        })\\n        var rBank = PriorityQueue<Int>(comparator: { (a, b) -> Bool in\\n            let ta = time[a]\\n            let tb = time[b]\\n            let ca = ta[0] + ta[2]\\n            let cb = tb[0] + tb[2]\\n            if ca == cb { return b < a }  // larger index cross first\\n            return cb < ca  // larger cross time cross first\\n        })\\n\\n        // 0 -> time of the worker will be waiting to cross the bridge, 1 ->idx\\n        var lWorker = PriorityQueue<(Int, Int)>(comparator: { (a, b) -> Bool in a.0 < b.0 })\\n        var rWorker = PriorityQueue<(Int, Int)>(comparator: { (a, b) -> Bool in a.0 < b.0 })\\n\\n        // initially, all at left bank\\n        for i in 0..<k {\\n            lBank.add(i)\\n        }\\n\\n        var curTime = 0\\n        var remainingBoxes = n\\n        while remainingBoxes > 0 {\\n            // process worker\\n            while !lWorker.isEmpty && lWorker.peek()!.0 <= curTime {\\n                lBank.add(lWorker.poll()!.1)\\n            }\\n            while !rWorker.isEmpty && rWorker.peek()!.0 <= curTime {\\n                rBank.add(rWorker.poll()!.1)\\n            }\\n\\n            var worker = -1\\n            if !rBank.isEmpty {\\n                // right side can pass, a box will be put\\n                worker = rBank.poll()!\\n                let t = time[worker]\\n                lWorker.add((curTime + t[2] + t[3], worker))\\n                curTime += t[2]  // right to left\\n\\n                remainingBoxes -= 1\\n            } else if !lBank.isEmpty && (remainingBoxes > rBank.size + rWorker.size) {\\n                // left side can pass\\n                // left side only pass when there are more boxes\\n                worker = lBank.poll()!\\n                let t = time[worker]\\n                rWorker.add((curTime + t[0] + t[1], worker))\\n                curTime += t[0]  // left to right\\n            } else if remainingBoxes == rBank.size + rWorker.size {\\n                curTime = rWorker.peek()!.0\\n            } else {\\n                // if still empty, advance time\\n                let nxt: Int\\n                if rWorker.isEmpty {\\n                    nxt = lWorker.peek()!.0\\n                } else if lWorker.isEmpty {\\n                    nxt = rWorker.peek()!.0\\n                } else {\\n                    nxt = min(lWorker.peek()!.0, rWorker.peek()!.0)\\n                }\\n\\n                curTime = nxt\\n            }\\n        }\\n\\n        return curTime\\n    }\\n}\\n\\n// Wrapper class for PriorityQueue\\nstruct PriorityQueue<Element> {\\n    private var heap: [Element]\\n    private let comparator: (Element, Element) -> Bool\\n\\n    init(comparator: @escaping (Element, Element) -> Bool) {\\n        self.heap = []\\n        self.comparator = comparator\\n    }\\n\\n    var isEmpty: Bool {\\n        return heap.isEmpty\\n    }\\n\\n    var size: Int {\\n        return heap.count\\n    }\\n\\n    func peek() -> Element? {\\n        return heap.first\\n    }\\n\\n    mutating func add(_ element: Element) {\\n        heap.append(element)\\n        swim(heap.count - 1)\\n    }\\n\\n    mutating func poll() -> Element? {\\n        if heap.isEmpty { return nil }\\n        if heap.count == 1 { return heap.removeFirst() }\\n\\n        heap.swapAt(0, heap.count - 1)\\n        let element = heap.removeLast()\\n        sink(0)\\n\\n        return element\\n    }\\n\\n    private mutating func swim(_ index: Int) {\\n        var childIndex = index\\n        var parentIndex = (childIndex - 1) / 2\\n\\n        while childIndex > 0 && comparator(heap[childIndex], heap[parentIndex]) {\\n            heap.swapAt(childIndex, parentIndex)\\n            childIndex = parentIndex\\n            parentIndex = (childIndex - 1) / 2\\n        }\\n    }\\n\\n    private mutating func sink(_ index: Int) {\\n        var parentIndex = index\\n\\n        while true {\\n            let leftChildIndex = 2 * parentIndex + 1\\n            let rightChildIndex = 2 * parentIndex + 2\\n            var candidateIndex = parentIndex\\n\\n            if leftChildIndex < heap.count && comparator(heap[leftChildIndex], heap[candidateIndex])\\n            {\\n                candidateIndex = leftChildIndex\\n            }\\n            if rightChildIndex < heap.count\\n                && comparator(heap[rightChildIndex], heap[candidateIndex])\\n            {\\n                candidateIndex = rightChildIndex\\n            }\\n\\n            if candidateIndex == parentIndex {\\n                return\\n            }\\n\\n            heap.swapAt(parentIndex, candidateIndex)\\n            parentIndex = candidateIndex\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    func findCrossingTime(_ n: Int, _ k: Int, _ time: [[Int]]) -> Int {\\n        var lBank = PriorityQueue<Int>(comparator: { (a, b) -> Bool in\\n            let ta = time[a]\\n            let tb = time[b]\\n            let ca = ta[0] + ta[2]\\n            let cb = tb[0] + tb[2]\\n            if ca == cb { return b < a }  // larger index cross first\\n            return cb < ca  // larger cross time cross first\\n        })\\n        var rBank = PriorityQueue<Int>(comparator: { (a, b) -> Bool in\\n            let ta = time[a]\\n            let tb = time[b]\\n            let ca = ta[0] + ta[2]\\n            let cb = tb[0] + tb[2]\\n            if ca == cb { return b < a }  // larger index cross first\\n            return cb < ca  // larger cross time cross first\\n        })\\n\\n        // 0 -> time of the worker will be waiting to cross the bridge, 1 ->idx\\n        var lWorker = PriorityQueue<(Int, Int)>(comparator: { (a, b) -> Bool in a.0 < b.0 })\\n        var rWorker = PriorityQueue<(Int, Int)>(comparator: { (a, b) -> Bool in a.0 < b.0 })\\n\\n        // initially, all at left bank\\n        for i in 0..<k {\\n            lBank.add(i)\\n        }\\n\\n        var curTime = 0\\n        var remainingBoxes = n\\n        while remainingBoxes > 0 {\\n            // process worker\\n            while !lWorker.isEmpty && lWorker.peek()!.0 <= curTime {\\n                lBank.add(lWorker.poll()!.1)\\n            }\\n            while !rWorker.isEmpty && rWorker.peek()!.0 <= curTime {\\n                rBank.add(rWorker.poll()!.1)\\n            }\\n\\n            var worker = -1\\n            if !rBank.isEmpty {\\n                // right side can pass, a box will be put\\n                worker = rBank.poll()!\\n                let t = time[worker]\\n                lWorker.add((curTime + t[2] + t[3], worker))\\n                curTime += t[2]  // right to left\\n\\n                remainingBoxes -= 1\\n            } else if !lBank.isEmpty && (remainingBoxes > rBank.size + rWorker.size) {\\n                // left side can pass\\n                // left side only pass when there are more boxes\\n                worker = lBank.poll()!\\n                let t = time[worker]\\n                rWorker.add((curTime + t[0] + t[1], worker))\\n                curTime += t[0]  // left to right\\n            } else if remainingBoxes == rBank.size + rWorker.size {\\n                curTime = rWorker.peek()!.0\\n            } else {\\n                // if still empty, advance time\\n                let nxt: Int\\n                if rWorker.isEmpty {\\n                    nxt = lWorker.peek()!.0\\n                } else if lWorker.isEmpty {\\n                    nxt = rWorker.peek()!.0\\n                } else {\\n                    nxt = min(lWorker.peek()!.0, rWorker.peek()!.0)\\n                }\\n\\n                curTime = nxt\\n            }\\n        }\\n\\n        return curTime\\n    }\\n}\\n\\n// Wrapper class for PriorityQueue\\nstruct PriorityQueue<Element> {\\n    private var heap: [Element]\\n    private let comparator: (Element, Element) -> Bool\\n\\n    init(comparator: @escaping (Element, Element) -> Bool) {\\n        self.heap = []\\n        self.comparator = comparator\\n    }\\n\\n    var isEmpty: Bool {\\n        return heap.isEmpty\\n    }\\n\\n    var size: Int {\\n        return heap.count\\n    }\\n\\n    func peek() -> Element? {\\n        return heap.first\\n    }\\n\\n    mutating func add(_ element: Element) {\\n        heap.append(element)\\n        swim(heap.count - 1)\\n    }\\n\\n    mutating func poll() -> Element? {\\n        if heap.isEmpty { return nil }\\n        if heap.count == 1 { return heap.removeFirst() }\\n\\n        heap.swapAt(0, heap.count - 1)\\n        let element = heap.removeLast()\\n        sink(0)\\n\\n        return element\\n    }\\n\\n    private mutating func swim(_ index: Int) {\\n        var childIndex = index\\n        var parentIndex = (childIndex - 1) / 2\\n\\n        while childIndex > 0 && comparator(heap[childIndex], heap[parentIndex]) {\\n            heap.swapAt(childIndex, parentIndex)\\n            childIndex = parentIndex\\n            parentIndex = (childIndex - 1) / 2\\n        }\\n    }\\n\\n    private mutating func sink(_ index: Int) {\\n        var parentIndex = index\\n\\n        while true {\\n            let leftChildIndex = 2 * parentIndex + 1\\n            let rightChildIndex = 2 * parentIndex + 2\\n            var candidateIndex = parentIndex\\n\\n            if leftChildIndex < heap.count && comparator(heap[leftChildIndex], heap[candidateIndex])\\n            {\\n                candidateIndex = leftChildIndex\\n            }\\n            if rightChildIndex < heap.count\\n                && comparator(heap[rightChildIndex], heap[candidateIndex])\\n            {\\n                candidateIndex = rightChildIndex\\n            }\\n\\n            if candidateIndex == parentIndex {\\n                return\\n            }\\n\\n            heap.swapAt(parentIndex, candidateIndex)\\n            parentIndex = candidateIndex\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684080,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        map<int,set<int,greater<int>>,greater<int>> L,R;\\n        map<int,vector<int>> l,r;\\n        int wait=0,ind;\\n        for(int i=0;i<time.size();i++)L[time[i][0]+time[i][2]].insert(i);\\n        while(1){\\n            if(L.size()==0 && R.size()==0){\\n                if(l.size()==0 && r.size()>0){\\n                    wait=r.begin()->first;for(int i=0;i<r.begin()->second.size();i++){\\n                    ind=r.begin()->second[i];\\n                    R[time[ind][0]+time[ind][2]].insert(ind);\\n                }\\n                    r.erase(r.begin());\\n                }\\n                else if(r.size()==0&&l.size()>0){\\n                  wait=l.begin()->first;for(int i=0;i<l.begin()->second.size();i++){\\n                    ind=l.begin()->second[i];\\n                    L[time[ind][0]+time[ind][2]].insert(ind);\\n                  }\\n                  l.erase(l.begin());\\n                }\\n                else if(l.begin()->first>r.begin()->first){\\n               wait=r.begin()->first;for(int i=0;i<r.begin()->second.size();i++){\\n                    ind=r.begin()->second[i];\\n                    R[time[ind][0]+time[ind][2]].insert(ind);\\n                     }\\n                     r.erase(r.begin());\\n                }\\n                else if(r.begin()->first>l.begin()->first){\\n                      wait=l.begin()->first;for(int i=0;i<l.begin()->second.size();i++){\\n                    ind=l.begin()->second[i];\\n                    L[time[ind][0]+time[ind][2]].insert(ind);\\n                      }\\n                      l.erase(l.begin());\\n                }\\n                else{\\n                      wait=l.begin()->first;for(int i=0;i<l.begin()->second.size();i++){\\n                    ind=l.begin()->second[i];\\n                    L[time[ind][0]+time[ind][2]].insert(ind);\\n                      }\\n                      l.erase(l.begin());\\n                      wait=r.begin()->first;for(int i=0;i<r.begin()->second.size();i++){\\n                    ind=r.begin()->second[i];\\n                    R[time[ind][0]+time[ind][2]].insert(ind);\\n                      }\\n                      r.erase(r.begin());\\n                }\\n                \\n            }\\n            if(R.size()>0){\\n                ind=*R.begin()->second.begin();\\n                wait+=time[ind][2];\\n                l[wait+time[ind][3]].push_back(ind);\\n                n--;\\n                if(R.begin()->second.size()==1)R.erase(R.begin());\\n                else\\n                R.begin()->second.erase(R.begin()->second.begin());\\n                if(n==0)break;\\n            }\\n            else if(n-r.size()>0){\\n                ind=*L.begin()->second.begin();\\n                wait+=time[ind][0];\\n                r[wait+time[ind][1]].push_back(ind);\\n            if(L.begin()->second.size()==1)L.erase(L.begin());\\n                else\\n                L.begin()->second.erase(L.begin()->second.begin());        \\n            }\\n            else if(n-r.size()==0){L.clear();l.clear();}\\n            while(l.size()>0 && l.begin()->first<=wait){\\n                for(int i=0;i<l.begin()->second.size();i++){\\n                    ind=l.begin()->second[i];\\n                    L[time[ind][0]+time[ind][2]].insert(ind);\\n                }\\n                l.erase(l.begin());\\n            }\\n            while(r.size()>0 && r.begin()->first<=wait){\\n                   for(int i=0;i<r.begin()->second.size();i++){\\n                    ind=r.begin()->second[i];\\n                    R[time[ind][0]+time[ind][2]].insert(ind);\\n                }\\n                r.erase(r.begin());\\n            }\\n            if(n==0)break;\\n        }\\n        return wait;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        map<int,set<int,greater<int>>,greater<int>> L,R;\\n        map<int,vector<int>> l,r;\\n        int wait=0,ind;\\n        for(int i=0;i<time.size();i++)L[time[i][0]+time[i][2]].insert(i);\\n        while(1){\\n            if(L.size()==0 && R.size()==0){\\n                if(l.size()==0 && r.size()>0){\\n                    wait=r.begin()->first;for(int i=0;i<r.begin()->second.size();i++){\\n                    ind=r.begin()->second[i];\\n                    R[time[ind][0]+time[ind][2]].insert(ind);\\n                }\\n                    r.erase(r.begin());\\n                }\\n                else if(r.size()==0&&l.size()>0){\\n                  wait=l.begin()->first;for(int i=0;i<l.begin()->second.size();i++){\\n                    ind=l.begin()->second[i];\\n                    L[time[ind][0]+time[ind][2]].insert(ind);\\n                  }\\n                  l.erase(l.begin());\\n                }\\n                else if(l.begin()->first>r.begin()->first){\\n               wait=r.begin()->first;for(int i=0;i<r.begin()->second.size();i++){\\n                    ind=r.begin()->second[i];\\n                    R[time[ind][0]+time[ind][2]].insert(ind);\\n                     }\\n                     r.erase(r.begin());\\n                }\\n                else if(r.begin()->first>l.begin()->first){\\n                      wait=l.begin()->first;for(int i=0;i<l.begin()->second.size();i++){\\n                    ind=l.begin()->second[i];\\n                    L[time[ind][0]+time[ind][2]].insert(ind);\\n                      }\\n                      l.erase(l.begin());\\n                }\\n                else{\\n                      wait=l.begin()->first;for(int i=0;i<l.begin()->second.size();i++){\\n                    ind=l.begin()->second[i];\\n                    L[time[ind][0]+time[ind][2]].insert(ind);\\n                      }\\n                      l.erase(l.begin());\\n                      wait=r.begin()->first;for(int i=0;i<r.begin()->second.size();i++){\\n                    ind=r.begin()->second[i];\\n                    R[time[ind][0]+time[ind][2]].insert(ind);\\n                      }\\n                      r.erase(r.begin());\\n                }\\n                \\n            }\\n            if(R.size()>0){\\n                ind=*R.begin()->second.begin();\\n                wait+=time[ind][2];\\n                l[wait+time[ind][3]].push_back(ind);\\n                n--;\\n                if(R.begin()->second.size()==1)R.erase(R.begin());\\n                else\\n                R.begin()->second.erase(R.begin()->second.begin());\\n                if(n==0)break;\\n            }\\n            else if(n-r.size()>0){\\n                ind=*L.begin()->second.begin();\\n                wait+=time[ind][0];\\n                r[wait+time[ind][1]].push_back(ind);\\n            if(L.begin()->second.size()==1)L.erase(L.begin());\\n                else\\n                L.begin()->second.erase(L.begin()->second.begin());        \\n            }\\n            else if(n-r.size()==0){L.clear();l.clear();}\\n            while(l.size()>0 && l.begin()->first<=wait){\\n                for(int i=0;i<l.begin()->second.size();i++){\\n                    ind=l.begin()->second[i];\\n                    L[time[ind][0]+time[ind][2]].insert(ind);\\n                }\\n                l.erase(l.begin());\\n            }\\n            while(r.size()>0 && r.begin()->first<=wait){\\n                   for(int i=0;i<r.begin()->second.size();i++){\\n                    ind=r.begin()->second[i];\\n                    R[time[ind][0]+time[ind][2]].insert(ind);\\n                }\\n                r.erase(r.begin());\\n            }\\n            if(n==0)break;\\n        }\\n        return wait;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683948,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\n#define pi pair<int, int>\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        stable_sort(time.begin(), time.end(), [&](auto &a, auto &b) {\\n            return a[0] + a[2] < b[0] + b[2]; // sorting according to bridge cover currTime;\\n        });\\n\\n        /* stable_sort() is used to sort the elements in the range [first, last) in ascending order. It is like       std::sort, but stable_sort() keeps the relative order of elements with equivalent values. It comes under the <algorithm> header file. */\\n\\n        priority_queue<int> lbank, rbank; // index least efficient\\n        for(int i = 0; i < k; i++)\\n            lbank.push(i);\\n\\n        priority_queue<pi, vector<pi>, greater<pi>> lwork, rwork; // time and index\\n        int currTime = 0;\\n\\n        while(n or !rbank.empty() or !rwork.empty()) {\\n            while(!rwork.empty() and rwork.top().first <= currTime) {\\n                rbank.push(rwork.top().second); // pick the box ? yes then wait on right bank\\n                rwork.pop();\\n            }\\n\\n            while(!lwork.empty() and lwork.top().first <= currTime) {\\n                lbank.push(lwork.top().second); // put the box ? yes then wait on left bank\\n                lwork.pop();\\n            }\\n\\n            if(!rbank.empty()) {\\n                int ind = rbank.top();\\n                rbank.pop();\\n\\n                lwork.push({currTime + time[ind][2] + time[ind][3], ind});\\n                currTime += time[ind][2];\\n            } \\n            \\n            else {\\n                if(n == 0)\\n                    currTime = rwork.top().first;\\n                else {\\n                    if(!lbank.empty()) {\\n                        int ind = lbank.top();\\n                        lbank.pop();\\n\\n                        rwork.push({currTime + time[ind][0] + time[ind][1], ind});\\n                        currTime += time[ind][0];\\n\\n                        n--; // picked up the box from old warehouse which is on right side\\n                    }\\n\\n                    else {\\n                        /* take the mini of workers time and spend the whole time */\\n                        int a = !lwork.empty() ? lwork.top().first : INT_MAX;\\n                        int b = !rwork.empty() ? rwork.top().first : INT_MAX;\\n                        currTime = min(a, b);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return currTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pi pair<int, int>\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        stable_sort(time.begin(), time.end(), [&](auto &a, auto &b) {\\n            return a[0] + a[2] < b[0] + b[2]; // sorting according to bridge cover currTime;\\n        });\\n\\n        /* stable_sort() is used to sort the elements in the range [first, last) in ascending order. It is like       std::sort, but stable_sort() keeps the relative order of elements with equivalent values. It comes under the <algorithm> header file. */\\n\\n        priority_queue<int> lbank, rbank; // index least efficient\\n        for(int i = 0; i < k; i++)\\n            lbank.push(i);\\n\\n        priority_queue<pi, vector<pi>, greater<pi>> lwork, rwork; // time and index\\n        int currTime = 0;\\n\\n        while(n or !rbank.empty() or !rwork.empty()) {\\n            while(!rwork.empty() and rwork.top().first <= currTime) {\\n                rbank.push(rwork.top().second); // pick the box ? yes then wait on right bank\\n                rwork.pop();\\n            }\\n\\n            while(!lwork.empty() and lwork.top().first <= currTime) {\\n                lbank.push(lwork.top().second); // put the box ? yes then wait on left bank\\n                lwork.pop();\\n            }\\n\\n            if(!rbank.empty()) {\\n                int ind = rbank.top();\\n                rbank.pop();\\n\\n                lwork.push({currTime + time[ind][2] + time[ind][3], ind});\\n                currTime += time[ind][2];\\n            } \\n            \\n            else {\\n                if(n == 0)\\n                    currTime = rwork.top().first;\\n                else {\\n                    if(!lbank.empty()) {\\n                        int ind = lbank.top();\\n                        lbank.pop();\\n\\n                        rwork.push({currTime + time[ind][0] + time[ind][1], ind});\\n                        currTime += time[ind][0];\\n\\n                        n--; // picked up the box from old warehouse which is on right side\\n                    }\\n\\n                    else {\\n                        /* take the mini of workers time and spend the whole time */\\n                        int a = !lwork.empty() ? lwork.top().first : INT_MAX;\\n                        int b = !rwork.empty() ? rwork.top().first : INT_MAX;\\n                        currTime = min(a, b);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return currTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592325,
                "title": "c-priority-queue-simulation-practice-self-explanatory-code",
                "content": "# Intuition\\nThe most difficult part of this problem is to understand the process and pick the right data structure to simulate it.\\n\\nFirst, we realize that we need two queues ```l```, ```r``` to represent the \"ready to enter bridge\" workers on the left and right end. Here, we can use naive queue if the rule is based on ready time; however, the rule is based on efficiency, which requires a custom compare function.\\n\\nNotice that a worker at either end cannot enter the queue until \"put\" or \"pick\" operation is done. Then, we need two other queues ```lq```, ```rq``` to simulate the process to enter ```l, r```. Priority queue is needed since the later arrived worker can do his/her operation faster having an earlier ready time.\\n\\n# Approach\\nAll pqs are implemented using the index of workers: ```l, r``` based on efficiency, ```lq, rq``` based on ready time ```avtime```. In each iteration, bridge time ```bt``` will be updated so we need to get the ready workers into the ```l, r``` queues at the beginning.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int bt = 0;\\n        vector<int> avtime(k);\\n        auto cmp = [&] (int a, int b) {\\n            if (time[a][0] + time[a][2] < time[b][0] + time[b][2]) return true;\\n            else if (time[a][0] + time[a][2] == time[b][0] + time[b][2] && a < b) return true;\\n            return false;\\n        };\\n        priority_queue<int, vector<int>, decltype(cmp)> l(cmp), r(cmp);\\n        for (int i = 0; i < k; i++) l.push(i);\\n        \\n        auto cmp1 = [&] (int a, int b) {\\n            return avtime[a] > avtime[b];\\n        };\\n        priority_queue<int, vector<int>, decltype(cmp1)> lq(cmp1), rq(cmp1);\\n        \\n        while (n) {\\n            while (!rq.empty() && avtime[rq.top()] <= bt) {\\n                r.push(rq.top()); rq.pop();\\n            }\\n            while (!lq.empty() && avtime[lq.top()] <= bt) {\\n                l.push(lq.top()); lq.pop();\\n            }\\n            \\n            if (!r.empty()) {\\n                n--;\\n                \\n                int x = r.top(); r.pop();\\n                bt += time[x][2];\\n                avtime[x] = bt + time[x][3];\\n                lq.push(x);\\n            }\\n            else if (!l.empty() && n > rq.size()) {\\n                int x = l.top(); l.pop();\\n                bt += time[x][0];\\n                avtime[x] = bt + time[x][1];\\n                rq.push(x);\\n            }\\n            else {\\n                int x = lq.empty() ? INT_MAX : avtime[lq.top()];\\n                int y = rq.empty() ? INT_MAX : avtime[rq.top()];\\n                bt = min(x, y);\\n            }\\n        }\\n        \\n        \\n        return bt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```l```\n```r```\n```lq```\n```rq```\n```l, r```\n```l, r```\n```lq, rq```\n```avtime```\n```bt```\n```l, r```\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int bt = 0;\\n        vector<int> avtime(k);\\n        auto cmp = [&] (int a, int b) {\\n            if (time[a][0] + time[a][2] < time[b][0] + time[b][2]) return true;\\n            else if (time[a][0] + time[a][2] == time[b][0] + time[b][2] && a < b) return true;\\n            return false;\\n        };\\n        priority_queue<int, vector<int>, decltype(cmp)> l(cmp), r(cmp);\\n        for (int i = 0; i < k; i++) l.push(i);\\n        \\n        auto cmp1 = [&] (int a, int b) {\\n            return avtime[a] > avtime[b];\\n        };\\n        priority_queue<int, vector<int>, decltype(cmp1)> lq(cmp1), rq(cmp1);\\n        \\n        while (n) {\\n            while (!rq.empty() && avtime[rq.top()] <= bt) {\\n                r.push(rq.top()); rq.pop();\\n            }\\n            while (!lq.empty() && avtime[lq.top()] <= bt) {\\n                l.push(lq.top()); lq.pop();\\n            }\\n            \\n            if (!r.empty()) {\\n                n--;\\n                \\n                int x = r.top(); r.pop();\\n                bt += time[x][2];\\n                avtime[x] = bt + time[x][3];\\n                lq.push(x);\\n            }\\n            else if (!l.empty() && n > rq.size()) {\\n                int x = l.top(); l.pop();\\n                bt += time[x][0];\\n                avtime[x] = bt + time[x][1];\\n                rq.push(x);\\n            }\\n            else {\\n                int x = lq.empty() ? INT_MAX : avtime[lq.top()];\\n                int y = rq.empty() ? INT_MAX : avtime[rq.top()];\\n                bt = min(x, y);\\n            }\\n        }\\n        \\n        \\n        return bt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453097,
                "title": "time-simulation",
                "content": "Note: if you can solve using state machine or simulation where time is also involved then priority queue helps passing time to next event point.\\nHere lp and rp are those priority queue(lp: leftPutWorker rp: rightPickWorker) for passing the wait time.\\nlr(leftToRightBridgeCrosser) and rl(rightToLeftBridgeCrosser) are only for less efficient worker for next bridge crossing(event point) and is not needed for the wait time. They only forward the event time.\\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int t = 0;\\n        priority_queue<pair<int, int> > lr;\\n        priority_queue<pair<int, int> > rl;\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > lp;\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > rp;\\n        for(int i = 0; i < k; i++){\\n            lr.push({time[i][0] + time[i][2], i});\\n        }\\n        int x, d;\\n        while(true){\\n            if(n == 0 && rl.empty() && rp.empty()) return t;\\n            if(rl.empty() && (n == 0 || lr.empty())){\\n                d = INT_MAX;\\n                if(!rp.empty()) d = rp.top().first;\\n                if(n != 0 && !lp.empty()) d = min(d, lp.top().first);\\n                t = max(t, d);\\n            }\\n            while(!rp.empty() && rp.top().first <= t){\\n                x = rp.top().second;\\n                rp.pop();\\n                rl.push({time[x][0] + time[x][2], x});\\n            }\\n            if(!rl.empty()){\\n                x = rl.top().second;\\n                rl.pop();\\n                t += time[x][2];\\n                lp.push({t + time[x][3], x});\\n            }\\n            else{\\n                while(!lp.empty() && lp.top().first <= t){\\n                    x = lp.top().second;\\n                    lp.pop();\\n                    lr.push({time[x][0] + time[x][2], x});\\n                }\\n                if(n > 0){\\n                    x = lr.top().second;\\n                    lr.pop();\\n                    t += time[x][0];\\n                    rp.push({t + time[x][1], x});\\n                    n--;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int t = 0;\\n        priority_queue<pair<int, int> > lr;\\n        priority_queue<pair<int, int> > rl;\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > lp;\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > rp;\\n        for(int i = 0; i < k; i++){\\n            lr.push({time[i][0] + time[i][2], i});\\n        }\\n        int x, d;\\n        while(true){\\n            if(n == 0 && rl.empty() && rp.empty()) return t;\\n            if(rl.empty() && (n == 0 || lr.empty())){\\n                d = INT_MAX;\\n                if(!rp.empty()) d = rp.top().first;\\n                if(n != 0 && !lp.empty()) d = min(d, lp.top().first);\\n                t = max(t, d);\\n            }\\n            while(!rp.empty() && rp.top().first <= t){\\n                x = rp.top().second;\\n                rp.pop();\\n                rl.push({time[x][0] + time[x][2], x});\\n            }\\n            if(!rl.empty()){\\n                x = rl.top().second;\\n                rl.pop();\\n                t += time[x][2];\\n                lp.push({t + time[x][3], x});\\n            }\\n            else{\\n                while(!lp.empty() && lp.top().first <= t){\\n                    x = lp.top().second;\\n                    lp.pop();\\n                    lr.push({time[x][0] + time[x][2], x});\\n                }\\n                if(n > 0){\\n                    x = lr.top().second;\\n                    lr.pop();\\n                    t += time[x][0];\\n                    rp.push({t + time[x][1], x});\\n                    n--;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253320,
                "title": "java-using-pqs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- k workers in a queue at most - insert will log K\\n- N boxes , each worker will move across 4 Queues.\\n- 1 box= 4 logk\\n- n boxes = 4N log K\\nO(n log k)\\n\\n- Space complexity:\\nO(K)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        //create 2 PQ\\n        PriorityQueue<int[]> leftBridgePQ = new PriorityQueue<> ((a,b) -> (a[1] == b[1] ? \\n                                                                          b[0] - a[0] : b[1] - a[1]));\\n\\n        PriorityQueue<int[]> rightBridgePQ = new PriorityQueue<> ((a,b) -> (a[1] == b[1] ? \\n                                                                          b[0] - a[0] : b[1] - a[1]));\\n\\n        PriorityQueue<int[]> leftWHPQ = new PriorityQueue<> ( (a,b) -> a[1] - b[1]);\\n        PriorityQueue<int[]> rightWHPQ = new PriorityQueue<> ((a,b) -> a[1] - b[1]);\\n\\n        for (int i = 0; i < k; i++){\\n            int effciency = time[i][0]+time[i][2];\\n            leftBridgePQ.offer(new int[]{i, effciency});\\n        }\\n\\n        int duration = 0;\\n        while(n > 0 || !rightBridgePQ.isEmpty()|| !rightWHPQ.isEmpty()){\\n            \\n            while(!leftWHPQ.isEmpty() && leftWHPQ.peek()[1] <= duration){\\n                int id = leftWHPQ.poll()[0];\\n                int e = time[id][0] + time[id][2];\\n                leftBridgePQ.offer(new int[]{id, e});\\n            }\\n\\n            while(!rightWHPQ.isEmpty() && rightWHPQ.peek()[1] <= duration){\\n                int id = rightWHPQ.poll()[0];\\n                int e = time[id][0] + time[id][2];\\n                rightBridgePQ.offer(new int[]{id, e});\\n            }\\n\\n            if (!rightBridgePQ.isEmpty()){\\n                int id = rightBridgePQ.poll()[0];\\n                duration += time[id][2];\\n                leftWHPQ.offer(new int[]{id, duration+time[id][3]});\\n            } else if (!leftBridgePQ.isEmpty() && n > 0){\\n                int id = leftBridgePQ.poll()[0];\\n                duration += time[id][0];\\n                rightWHPQ.offer(new int[]{id, duration + time[id][1]});\\n                --n;\\n            } else {\\n                // update duration \\n                int left = Integer.MAX_VALUE;\\n                if (!leftWHPQ.isEmpty() && n > 0)\\n                    left = leftWHPQ.peek()[1];\\n                int right = Integer.MAX_VALUE;\\n                if (!rightWHPQ.isEmpty())\\n                    right = rightWHPQ.peek()[1];\\n                \\n                duration = Math.min(left, right);\\n            }\\n\\n        }\\n        return duration;\\n    }\\n}\\n\\n/*\\n\\nn - num of boxes\\nk - workers\\n\\natleast 1 box no upper limit\\n\\ntime[i][0] -- L->R\\ntime[i][1] -- PICK\\ntime[i][2] -- R->L\\ntime[i][3] -- PUT\\n\\nefficiency, if === i > j\\n\\nmax heap for bridge heap (lowest effciency LTR+RTL, i > j)\\nmin heap for time \\n\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        //create 2 PQ\\n        PriorityQueue<int[]> leftBridgePQ = new PriorityQueue<> ((a,b) -> (a[1] == b[1] ? \\n                                                                          b[0] - a[0] : b[1] - a[1]));\\n\\n        PriorityQueue<int[]> rightBridgePQ = new PriorityQueue<> ((a,b) -> (a[1] == b[1] ? \\n                                                                          b[0] - a[0] : b[1] - a[1]));\\n\\n        PriorityQueue<int[]> leftWHPQ = new PriorityQueue<> ( (a,b) -> a[1] - b[1]);\\n        PriorityQueue<int[]> rightWHPQ = new PriorityQueue<> ((a,b) -> a[1] - b[1]);\\n\\n        for (int i = 0; i < k; i++){\\n            int effciency = time[i][0]+time[i][2];\\n            leftBridgePQ.offer(new int[]{i, effciency});\\n        }\\n\\n        int duration = 0;\\n        while(n > 0 || !rightBridgePQ.isEmpty()|| !rightWHPQ.isEmpty()){\\n            \\n            while(!leftWHPQ.isEmpty() && leftWHPQ.peek()[1] <= duration){\\n                int id = leftWHPQ.poll()[0];\\n                int e = time[id][0] + time[id][2];\\n                leftBridgePQ.offer(new int[]{id, e});\\n            }\\n\\n            while(!rightWHPQ.isEmpty() && rightWHPQ.peek()[1] <= duration){\\n                int id = rightWHPQ.poll()[0];\\n                int e = time[id][0] + time[id][2];\\n                rightBridgePQ.offer(new int[]{id, e});\\n            }\\n\\n            if (!rightBridgePQ.isEmpty()){\\n                int id = rightBridgePQ.poll()[0];\\n                duration += time[id][2];\\n                leftWHPQ.offer(new int[]{id, duration+time[id][3]});\\n            } else if (!leftBridgePQ.isEmpty() && n > 0){\\n                int id = leftBridgePQ.poll()[0];\\n                duration += time[id][0];\\n                rightWHPQ.offer(new int[]{id, duration + time[id][1]});\\n                --n;\\n            } else {\\n                // update duration \\n                int left = Integer.MAX_VALUE;\\n                if (!leftWHPQ.isEmpty() && n > 0)\\n                    left = leftWHPQ.peek()[1];\\n                int right = Integer.MAX_VALUE;\\n                if (!rightWHPQ.isEmpty())\\n                    right = rightWHPQ.peek()[1];\\n                \\n                duration = Math.min(left, right);\\n            }\\n\\n        }\\n        return duration;\\n    }\\n}\\n\\n/*\\n\\nn - num of boxes\\nk - workers\\n\\natleast 1 box no upper limit\\n\\ntime[i][0] -- L->R\\ntime[i][1] -- PICK\\ntime[i][2] -- R->L\\ntime[i][3] -- PUT\\n\\nefficiency, if === i > j\\n\\nmax heap for bridge heap (lowest effciency LTR+RTL, i > j)\\nmin heap for time \\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251118,
                "title": "golang-simulation-using-4-priority-queues",
                "content": "```go\\ntype Worker struct {\\n  leftToRight int\\n  pickOld int\\n  rightToLeft int\\n  putNew int\\n  index int\\n}\\n\\ntype PriorityQueue1 []*Worker\\n\\nfunc (pq PriorityQueue1) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue1) Less(i, j int) bool {\\n  if pq[i].leftToRight + pq[i].rightToLeft == pq[j].leftToRight + pq[j].rightToLeft {\\n    return pq[i].index > pq[j].index\\n  }\\n  return pq[i].leftToRight + pq[i].rightToLeft > pq[j].leftToRight + pq[j].rightToLeft\\n}\\nfunc (pq PriorityQueue1) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue1) Push(x interface{}) {\\n  *pq = append(*pq, x.(*Worker))\\n}\\n\\nfunc (pq *PriorityQueue1) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc (pq PriorityQueue1) Top() interface{} {\\n  return pq[0]\\n}\\n\\ntype Working struct {\\n  w *Worker\\n  doneAt int\\n}\\n\\ntype PriorityQueue2 []*Working\\n\\nfunc (pq PriorityQueue2) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue2) Less(i, j int) bool {\\n  return pq[i].doneAt < pq[j].doneAt\\n}\\nfunc (pq PriorityQueue2) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue2) Push(x interface{}) {\\n  *pq = append(*pq, x.(*Working))\\n}\\n\\nfunc (pq *PriorityQueue2) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc (pq PriorityQueue2) Top() interface{} {\\n  return pq[0]\\n}\\n\\nfunc findCrossingTime(n int, k int, time [][]int) int {\\n  var left, right PriorityQueue1\\n  var picking, putting PriorityQueue2\\n  // Initially everyone is at the left bridge\\n  for i := 0; i < len(time); i++ {\\n    heap.Push(&left, &Worker{time[i][0], time[i][1], time[i][2], time[i][3], i})\\n  }\\n  currTime := 0\\n  for n > 0 {\\n    // Let\\'s get people finished picking on the right to come back to the bridge\\n    // Also includes the ones that just finish picking\\n    for picking.Len() > 0 && picking.Top().(*Working).doneAt <= currTime {\\n      top := heap.Pop(&picking).(*Working)\\n      heap.Push(&right, top.w)\\n    }\\n    // Let\\'s try to get people from the right bridge to cross the left\\n    if right.Len() > 0 {\\n      top := heap.Pop(&right).(*Worker)\\n      currTime += top.rightToLeft\\n      heap.Push(&putting, &Working{w: top, doneAt: currTime + top.putNew})\\n    } else {\\n      // Get people putting boxes to the left of the bridge\\n      for putting.Len() > 0 && putting.Top().(*Working).doneAt <= currTime {\\n        top := heap.Pop(&putting).(*Working)\\n        heap.Push(&left, top.w)\\n      }\\n      // If we have anybody available on the left bank now, let\\'s get them to the right\\n      // to pick more boxes from the old warehouse.\\n      if left.Len() > 0 {\\n        top := heap.Pop(&left).(*Worker)\\n        currTime += top.leftToRight\\n        n--\\n        heap.Push(&picking, &Working{w: top, doneAt: currTime + top.pickOld})\\n      } else {\\n        // If we\\'ve reached this condition, it means everyone is either still putting boxes\\n        // or picking boxes. Let\\'s get the earliest of either of the PQ to finish their work\\n        pickingTop, puttingTop := math.MaxInt32, math.MaxInt32\\n        if picking.Len() > 0 {\\n          pickingTop = picking.Top().(*Working).doneAt\\n        }\\n        if putting.Len() > 0 {\\n          puttingTop = putting.Top().(*Working).doneAt\\n        }\\n        if pickingTop <= puttingTop { // the one picking has preference because they\\'re on the right bank\\n          top := heap.Pop(&picking).(*Working)\\n          currTime = top.doneAt\\n          heap.Push(&right, top.w)\\n        } else {\\n          top := heap.Pop(&putting).(*Working)\\n          currTime = top.doneAt\\n          heap.Push(&left, top.w)          \\n        }\\n      }\\n    }\\n  }\\n  for picking.Len() > 0 {\\n    top := heap.Pop(&picking).(*Working)\\n    currTime = max(currTime, top.doneAt) + top.w.rightToLeft\\n  }\\n  return currTime\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\ntype Worker struct {\\n  leftToRight int\\n  pickOld int\\n  rightToLeft int\\n  putNew int\\n  index int\\n}\\n\\ntype PriorityQueue1 []*Worker\\n\\nfunc (pq PriorityQueue1) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue1) Less(i, j int) bool {\\n  if pq[i].leftToRight + pq[i].rightToLeft == pq[j].leftToRight + pq[j].rightToLeft {\\n    return pq[i].index > pq[j].index\\n  }\\n  return pq[i].leftToRight + pq[i].rightToLeft > pq[j].leftToRight + pq[j].rightToLeft\\n}\\nfunc (pq PriorityQueue1) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue1) Push(x interface{}) {\\n  *pq = append(*pq, x.(*Worker))\\n}\\n\\nfunc (pq *PriorityQueue1) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc (pq PriorityQueue1) Top() interface{} {\\n  return pq[0]\\n}\\n\\ntype Working struct {\\n  w *Worker\\n  doneAt int\\n}\\n\\ntype PriorityQueue2 []*Working\\n\\nfunc (pq PriorityQueue2) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue2) Less(i, j int) bool {\\n  return pq[i].doneAt < pq[j].doneAt\\n}\\nfunc (pq PriorityQueue2) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue2) Push(x interface{}) {\\n  *pq = append(*pq, x.(*Working))\\n}\\n\\nfunc (pq *PriorityQueue2) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc (pq PriorityQueue2) Top() interface{} {\\n  return pq[0]\\n}\\n\\nfunc findCrossingTime(n int, k int, time [][]int) int {\\n  var left, right PriorityQueue1\\n  var picking, putting PriorityQueue2\\n  // Initially everyone is at the left bridge\\n  for i := 0; i < len(time); i++ {\\n    heap.Push(&left, &Worker{time[i][0], time[i][1], time[i][2], time[i][3], i})\\n  }\\n  currTime := 0\\n  for n > 0 {\\n    // Let\\'s get people finished picking on the right to come back to the bridge\\n    // Also includes the ones that just finish picking\\n    for picking.Len() > 0 && picking.Top().(*Working).doneAt <= currTime {\\n      top := heap.Pop(&picking).(*Working)\\n      heap.Push(&right, top.w)\\n    }\\n    // Let\\'s try to get people from the right bridge to cross the left\\n    if right.Len() > 0 {\\n      top := heap.Pop(&right).(*Worker)\\n      currTime += top.rightToLeft\\n      heap.Push(&putting, &Working{w: top, doneAt: currTime + top.putNew})\\n    } else {\\n      // Get people putting boxes to the left of the bridge\\n      for putting.Len() > 0 && putting.Top().(*Working).doneAt <= currTime {\\n        top := heap.Pop(&putting).(*Working)\\n        heap.Push(&left, top.w)\\n      }\\n      // If we have anybody available on the left bank now, let\\'s get them to the right\\n      // to pick more boxes from the old warehouse.\\n      if left.Len() > 0 {\\n        top := heap.Pop(&left).(*Worker)\\n        currTime += top.leftToRight\\n        n--\\n        heap.Push(&picking, &Working{w: top, doneAt: currTime + top.pickOld})\\n      } else {\\n        // If we\\'ve reached this condition, it means everyone is either still putting boxes\\n        // or picking boxes. Let\\'s get the earliest of either of the PQ to finish their work\\n        pickingTop, puttingTop := math.MaxInt32, math.MaxInt32\\n        if picking.Len() > 0 {\\n          pickingTop = picking.Top().(*Working).doneAt\\n        }\\n        if putting.Len() > 0 {\\n          puttingTop = putting.Top().(*Working).doneAt\\n        }\\n        if pickingTop <= puttingTop { // the one picking has preference because they\\'re on the right bank\\n          top := heap.Pop(&picking).(*Working)\\n          currTime = top.doneAt\\n          heap.Push(&right, top.w)\\n        } else {\\n          top := heap.Pop(&putting).(*Working)\\n          currTime = top.doneAt\\n          heap.Push(&left, top.w)          \\n        }\\n      }\\n    }\\n  }\\n  for picking.Len() > 0 {\\n    top := heap.Pop(&picking).(*Working)\\n    currTime = max(currTime, top.doneAt) + top.w.rightToLeft\\n  }\\n  return currTime\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3166109,
                "title": "python-solution-using-4-priority-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        # workers putting new boxes\\n        put_new = [(0, i) for i in range(k)] # [(available_at, i)] waiting to put new\\n        heapq.heapify(put_new)\\n        # workers waiting on left bank of bridge\\n        bridge_left = [] # [(eff, i)] ready to cross river left to right\\n        # workers picking old boxes\\n        pick_old = [] # [(available_at, i)] waiting to pick old\\n        # workers waiting on right bank of bridge\\n        bridge_right = [] # [(eff, i)] ready to cross river right to left\\n        box_left = 0\\n        box_right = n\\n        \\n        def eff(i):\\n            return (-time[i][0]-time[i][2], -i)\\n            \\n        t = 0    \\n        while box_left < n:\\n            while put_new and put_new[0][0] <= t:\\n                _, i = heapq.heappop(put_new)\\n                heapq.heappush(bridge_left, (eff(i), i))\\n            while pick_old and pick_old[0][0] <= t:\\n                _, i = heapq.heappop(pick_old)\\n                heapq.heappush(bridge_right, (eff(i), i))\\n            \\n            if bridge_right:\\n                _, i = heapq.heappop(bridge_right)\\n                t += time[i][2]\\n                box_left += 1\\n                heapq.heappush(put_new, (t+time[i][3], i))\\n            elif bridge_left and box_right > 0:\\n                _, i = heapq.heappop(bridge_left)\\n                t += time[i][0]\\n                box_right -= 1\\n                heapq.heappush(pick_old, (t+time[i][1], i))\\n            elif put_new or pick_old:\\n                t = 2**31\\n                if put_new:\\n                    t = min(t, put_new[0][0])\\n                if pick_old:\\n                    t = min(t, pick_old[0][0])    \\n        return t\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        # workers putting new boxes\\n        put_new = [(0, i) for i in range(k)] # [(available_at, i)] waiting to put new\\n        heapq.heapify(put_new)\\n        # workers waiting on left bank of bridge\\n        bridge_left = [] # [(eff, i)] ready to cross river left to right\\n        # workers picking old boxes\\n        pick_old = [] # [(available_at, i)] waiting to pick old\\n        # workers waiting on right bank of bridge\\n        bridge_right = [] # [(eff, i)] ready to cross river right to left\\n        box_left = 0\\n        box_right = n\\n        \\n        def eff(i):\\n            return (-time[i][0]-time[i][2], -i)\\n            \\n        t = 0    \\n        while box_left < n:\\n            while put_new and put_new[0][0] <= t:\\n                _, i = heapq.heappop(put_new)\\n                heapq.heappush(bridge_left, (eff(i), i))\\n            while pick_old and pick_old[0][0] <= t:\\n                _, i = heapq.heappop(pick_old)\\n                heapq.heappush(bridge_right, (eff(i), i))\\n            \\n            if bridge_right:\\n                _, i = heapq.heappop(bridge_right)\\n                t += time[i][2]\\n                box_left += 1\\n                heapq.heappush(put_new, (t+time[i][3], i))\\n            elif bridge_left and box_right > 0:\\n                _, i = heapq.heappop(bridge_left)\\n                t += time[i][0]\\n                box_right -= 1\\n                heapq.heappush(pick_old, (t+time[i][1], i))\\n            elif put_new or pick_old:\\n                t = 2**31\\n                if put_new:\\n                    t = min(t, put_new[0][0])\\n                if pick_old:\\n                    t = min(t, pick_old[0][0])    \\n        return t\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130781,
                "title": "detailed-explanation-c-heaps-simulation",
                "content": "# Overview\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe question looks overwhelming initially but it mainly boils down to simulating the crossings over a bridge at any given instant t.\\n\\nAt a time instant t:\\n1. If worker(s) is/are waiting on the right, one of them should cross the bridge first.\\n2. If no one is waiting on the right and workers(s) is/are waiting on the left, one of them should cross the bridge at that instant.\\n3. If no one is waiting and there are boxes left to be tranferred, we need to move to the next instant t\\' where there would be a worker ready to access the bridge.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nMainly one should decide the ordering in which access must be given to the workers in left and right. As that is dictated by the efficiency level, and at a certain time instant \\'t\\' we need to find the person with minimum efficiency on either side of the bridge to contest for the crossing, the **priority queues \\'bridgeRight\\' and \\'bridgeLeft\\' sorted by efficiency** in the code would have a group of workers who were ready to cross the bridge at a time t\\' < current time t and are waiting for their turn.\\n\\nNow how to find a group of workers who are ready on/before the time instant t. The answer is simple. Once a worker \\'i\\' has crossed the bridge, he would take time[i][1]/time[i][3] units of time (depending upon the side) to finish up his work and return back to the entry of bridge. We need to find all those workers who are able to reach back to the bridge on/before t, so the solution would be to maintain **priority queues \\'waitLeft\\' and \\'waitRight\\' sorted by ready time** and at an instant t, shift all those workers to the BridgeLeft/BridRight heaps whose ready time are less than/ equal to t.\\n\\nWhat if at an instant t no one crosses the bridge? Then the plan is to **simulate to the nearest time ahead t\\' where there is atleast one worker ready** to cross the bridge.\\n\\nAlso, the variable \\'n\\' in the code keeps a count of the workers who are assigned to transfer a box. In case n becomes 0, it means the number of workers present in the right side of the bridge are sufficient to bring back all the remaining boxes, and no more worker is required to be sent from the left side. The variable \\'m\\' in the code keeps a count of the number of boxes which have successfully crossed the bridge. \\'m\\' becoming 0 indicates that the last box has been brought to the left side of the bank and the bridge need not be used anymore. We can therefore return the time of that instant.\\n\\n# Code\\n```\\n#define pii pair<int,int>\\n#define ppi pair<pii,int>\\n#define rdy first.first\\n#define eff first.second\\n#define idx second\\n\\n/*\\n10\\n6\\n[[2,10,5,8],[3,5,2,2],[5,8,10,10],[7,8,8,5],[5,6,6,10],[6,10,6,2]]\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    struct cmp1 {\\n        bool operator() (ppi a, ppi b) {\\n            return a.eff<b.eff || (a.eff==b.eff && a.idx<b.idx);\\n        }\\n    };\\n\\n    struct cmp2 {\\n        bool operator() (ppi a, ppi b) {\\n            return a.rdy>b.rdy;\\n        }\\n    };\\n\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        \\n        int timer = 0, m=n;\\n        priority_queue<ppi, vector<ppi>, cmp1> bridgeLeft, bridgeRight;\\n        priority_queue<ppi, vector<ppi>, cmp2> waitLeft, waitRight;\\n        for (int i=0; i<k; i++) waitLeft.push({{0,time[i][0]+time[i][2]},i});\\n        \\n        while (m) {\\n            bool cross = false;\\n            while (waitRight.size()>0 && timer>=waitRight.top().rdy) {\\n                ppi shift = waitRight.top();\\n                waitRight.pop();\\n                bridgeRight.push(shift);\\n            }\\n            if (bridgeRight.size()>0) {\\n                //cout<<\"At right bank at \"<<timer<<endl;\\n                cross = true;\\n                ppi shift = bridgeRight.top();\\n                cout<<\"RL at \"<<timer<<\" to \"<<timer+time[shift.idx][2]<<\" by \"<<shift.idx<<endl;\\n                bridgeRight.pop();\\n                timer += time[shift.idx][2];\\n                waitLeft.push({{timer+time[shift.idx][3], shift.eff}, shift.idx});\\n                m--;\\n            }\\n            if (!cross && n>0) {\\n                //cout<<\"At left bank at \"<<timer<<endl;\\n                while (waitLeft.size()>0 && timer>=waitLeft.top().rdy) {\\n                    ppi shift = waitLeft.top();\\n                    waitLeft.pop();\\n                    bridgeLeft.push(shift);\\n                }\\n                if (bridgeLeft.size()>0) {\\n                    cross = true;\\n                    ppi shift = bridgeLeft.top();\\n                    cout<<\"LR from \"<<timer<<\" to \"<<timer+time[shift.idx][0]<<\" by \"<<shift.idx<<endl;\\n                    bridgeLeft.pop();\\n                    timer += time[shift.idx][0];\\n                    waitRight.push({{timer+time[shift.idx][1], shift.eff}, shift.idx});\\n                    n--;\\n                }    \\n            }\\n            if (!cross) {\\n                timer = (waitLeft.size()>0 && n>0) ? waitLeft.top().rdy:waitRight.top().rdy;\\n                if (waitRight.size()>0) timer = min(timer, waitRight.top().rdy);\\n            }\\n        }\\n\\n        return timer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\n#define pii pair<int,int>\\n#define ppi pair<pii,int>\\n#define rdy first.first\\n#define eff first.second\\n#define idx second\\n\\n/*\\n10\\n6\\n[[2,10,5,8],[3,5,2,2],[5,8,10,10],[7,8,8,5],[5,6,6,10],[6,10,6,2]]\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    struct cmp1 {\\n        bool operator() (ppi a, ppi b) {\\n            return a.eff<b.eff || (a.eff==b.eff && a.idx<b.idx);\\n        }\\n    };\\n\\n    struct cmp2 {\\n        bool operator() (ppi a, ppi b) {\\n            return a.rdy>b.rdy;\\n        }\\n    };\\n\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        \\n        int timer = 0, m=n;\\n        priority_queue<ppi, vector<ppi>, cmp1> bridgeLeft, bridgeRight;\\n        priority_queue<ppi, vector<ppi>, cmp2> waitLeft, waitRight;\\n        for (int i=0; i<k; i++) waitLeft.push({{0,time[i][0]+time[i][2]},i});\\n        \\n        while (m) {\\n            bool cross = false;\\n            while (waitRight.size()>0 && timer>=waitRight.top().rdy) {\\n                ppi shift = waitRight.top();\\n                waitRight.pop();\\n                bridgeRight.push(shift);\\n            }\\n            if (bridgeRight.size()>0) {\\n                //cout<<\"At right bank at \"<<timer<<endl;\\n                cross = true;\\n                ppi shift = bridgeRight.top();\\n                cout<<\"RL at \"<<timer<<\" to \"<<timer+time[shift.idx][2]<<\" by \"<<shift.idx<<endl;\\n                bridgeRight.pop();\\n                timer += time[shift.idx][2];\\n                waitLeft.push({{timer+time[shift.idx][3], shift.eff}, shift.idx});\\n                m--;\\n            }\\n            if (!cross && n>0) {\\n                //cout<<\"At left bank at \"<<timer<<endl;\\n                while (waitLeft.size()>0 && timer>=waitLeft.top().rdy) {\\n                    ppi shift = waitLeft.top();\\n                    waitLeft.pop();\\n                    bridgeLeft.push(shift);\\n                }\\n                if (bridgeLeft.size()>0) {\\n                    cross = true;\\n                    ppi shift = bridgeLeft.top();\\n                    cout<<\"LR from \"<<timer<<\" to \"<<timer+time[shift.idx][0]<<\" by \"<<shift.idx<<endl;\\n                    bridgeLeft.pop();\\n                    timer += time[shift.idx][0];\\n                    waitRight.push({{timer+time[shift.idx][1], shift.eff}, shift.idx});\\n                    n--;\\n                }    \\n            }\\n            if (!cross) {\\n                timer = (waitLeft.size()>0 && n>0) ? waitLeft.top().rdy:waitRight.top().rdy;\\n                if (waitRight.size()>0) timer = min(timer, waitRight.top().rdy);\\n            }\\n        }\\n\\n        return timer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3113117,
                "title": "simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n    priority_queue<pair<int, int>> bq_l, bq_r;\\n    set<pair<int, int>> wh_l, wh_r;\\n    int bridge_t = 0;\\n    for (int i = 0; i < k; ++i)\\n        bq_l.push({time[i][0] + time[i][2], i});\\n    while (n || bq_r.size() + wh_r.size()) {\\n      while (!wh_l.empty() && begin(wh_l)->first <= bridge_t) {\\n          int i = begin(wh_l)->second;\\n          bq_l.push({time[i][0] + time[i][2], i});\\n          wh_l.erase(begin(wh_l));\\n      }\\n      while (!wh_r.empty() && begin(wh_r)->first <= bridge_t) {\\n          int i = begin(wh_r)->second;\\n          bq_r.push({time[i][0] + time[i][2], i});\\n          wh_r.erase(begin(wh_r));\\n      }\\n      if (!bq_r.empty()) {\\n          int i = bq_r.top().second; bq_r.pop();\\n          bridge_t += time[i][2];\\n          wh_l.insert({bridge_t + time[i][3], i});\\n      }\\n      else if (!bq_l.empty() && n) {     \\n          int i = bq_l.top().second; bq_l.pop();\\n          --n;\\n          bridge_t += time[i][0];\\n          wh_r.insert({bridge_t + time[i][1], i});        \\n      }\\n      else\\n          bridge_t = min(!wh_l.empty() && n ? begin(wh_l)->first : INT_MAX,\\n                         !wh_r.empty() ? begin(wh_r)->first : INT_MAX);\\n    }\\n    return bridge_t;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n    priority_queue<pair<int, int>> bq_l, bq_r;\\n    set<pair<int, int>> wh_l, wh_r;\\n    int bridge_t = 0;\\n    for (int i = 0; i < k; ++i)\\n        bq_l.push({time[i][0] + time[i][2], i});\\n    while (n || bq_r.size() + wh_r.size()) {\\n      while (!wh_l.empty() && begin(wh_l)->first <= bridge_t) {\\n          int i = begin(wh_l)->second;\\n          bq_l.push({time[i][0] + time[i][2], i});\\n          wh_l.erase(begin(wh_l));\\n      }\\n      while (!wh_r.empty() && begin(wh_r)->first <= bridge_t) {\\n          int i = begin(wh_r)->second;\\n          bq_r.push({time[i][0] + time[i][2], i});\\n          wh_r.erase(begin(wh_r));\\n      }\\n      if (!bq_r.empty()) {\\n          int i = bq_r.top().second; bq_r.pop();\\n          bridge_t += time[i][2];\\n          wh_l.insert({bridge_t + time[i][3], i});\\n      }\\n      else if (!bq_l.empty() && n) {     \\n          int i = bq_l.top().second; bq_l.pop();\\n          --n;\\n          bridge_t += time[i][0];\\n          wh_r.insert({bridge_t + time[i][1], i});        \\n      }\\n      else\\n          bridge_t = min(!wh_l.empty() && n ? begin(wh_l)->first : INT_MAX,\\n                         !wh_r.empty() ? begin(wh_r)->first : INT_MAX);\\n    }\\n    return bridge_t;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081887,
                "title": "c-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) \\n    {\\n        priority_queue<pair<int,int>>left;\\n        priority_queue<pair<int,int>>right;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>waitLeft;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>waitRight;\\n        for(int i=0;i<time.size();i++)left.push({time[i][0]+time[i][2],i});\\n        int curTime=0;\\n        while(n>=0)\\n        {\\n            // cout << curTime << \" \" << n << endl;\\n            if(right.size()>0)\\n            {\\n                int rightIndex=right.top().second;\\n                // cout << \"right\" << \" \" << rightIndex << endl;\\n                right.pop();\\n                curTime=curTime+time[rightIndex][2];\\n                waitLeft.push({curTime+time[rightIndex][3],rightIndex});\\n            }else if(left.size()>0&&n>0)\\n            {\\n                int leftIndex=left.top().second;\\n                // cout << \"left \" << leftIndex << endl;\\n                left.pop();\\n                curTime=curTime+time[leftIndex][0];\\n                waitRight.push({curTime+time[leftIndex][1],leftIndex});\\n                n--;\\n            }else\\n            {\\n                // cout << \"None\" << endl;\\n                int leftTime=waitLeft.size() == 0 ? INT_MAX : waitLeft.top().first;\\n                int rightTime=waitRight.size() == 0 ? INT_MAX : waitRight.top().first;\\n                // cout << leftTime << \" \" << rightTime << endl;\\n                if(n>0)\\n                    curTime=min(leftTime,rightTime);\\n                else\\n                    curTime=rightTime;\\n            }\\n            while(waitLeft.size()&&waitLeft.top().first<=curTime)\\n            {\\n                int leftIndex=waitLeft.top().second;\\n                waitLeft.pop();\\n                left.push({time[leftIndex][0]+time[leftIndex][2],leftIndex});\\n            }\\n            while(waitRight.size()&&waitRight.top().first<=curTime)\\n            {\\n                int rightIndex=waitRight.top().second;\\n                waitRight.pop();\\n                right.push({time[rightIndex][0]+time[rightIndex][2],rightIndex});\\n            }\\n            if(n==0&&waitRight.size()==0&&right.size()==0)break;\\n        }\\n        return curTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) \\n    {\\n        priority_queue<pair<int,int>>left;\\n        priority_queue<pair<int,int>>right;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>waitLeft;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>waitRight;\\n        for(int i=0;i<time.size();i++)left.push({time[i][0]+time[i][2],i});\\n        int curTime=0;\\n        while(n>=0)\\n        {\\n            // cout << curTime << \" \" << n << endl;\\n            if(right.size()>0)\\n            {\\n                int rightIndex=right.top().second;\\n                // cout << \"right\" << \" \" << rightIndex << endl;\\n                right.pop();\\n                curTime=curTime+time[rightIndex][2];\\n                waitLeft.push({curTime+time[rightIndex][3],rightIndex});\\n            }else if(left.size()>0&&n>0)\\n            {\\n                int leftIndex=left.top().second;\\n                // cout << \"left \" << leftIndex << endl;\\n                left.pop();\\n                curTime=curTime+time[leftIndex][0];\\n                waitRight.push({curTime+time[leftIndex][1],leftIndex});\\n                n--;\\n            }else\\n            {\\n                // cout << \"None\" << endl;\\n                int leftTime=waitLeft.size() == 0 ? INT_MAX : waitLeft.top().first;\\n                int rightTime=waitRight.size() == 0 ? INT_MAX : waitRight.top().first;\\n                // cout << leftTime << \" \" << rightTime << endl;\\n                if(n>0)\\n                    curTime=min(leftTime,rightTime);\\n                else\\n                    curTime=rightTime;\\n            }\\n            while(waitLeft.size()&&waitLeft.top().first<=curTime)\\n            {\\n                int leftIndex=waitLeft.top().second;\\n                waitLeft.pop();\\n                left.push({time[leftIndex][0]+time[leftIndex][2],leftIndex});\\n            }\\n            while(waitRight.size()&&waitRight.top().first<=curTime)\\n            {\\n                int rightIndex=waitRight.top().second;\\n                waitRight.pop();\\n                right.push({time[rightIndex][0]+time[rightIndex][2],rightIndex});\\n            }\\n            if(n==0&&waitRight.size()==0&&right.size()==0)break;\\n        }\\n        return curTime;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3072284,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int ans = 0, free = 0; \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> l, r; \\n        priority_queue<pair<int, int>> ll, rr; \\n        for (int i = 0; i < time.size(); ++i) \\n            ll.emplace(time[i][0]+time[i][2], i); \\n        while (n || r.size() || rr.size()) {\\n            if (rr.empty() && (r.empty() || r.top().first>free) && (!n || ll.empty() && (l.empty() || l.top().first>free))) {\\n                int cand = INT_MAX; \\n                if (n && l.size()) cand = min(cand, l.top().first); \\n                if (r.size()) cand = min(cand, r.top().first); \\n                free = cand; \\n            }\\n            while (l.size() && l.top().first <= free) {\\n                auto [_, i] = l.top(); l.pop(); \\n                ll.emplace(time[i][0]+time[i][2], i); \\n            }\\n            while (r.size() && r.top().first <= free) {\\n                auto [_, i] = r.top(); r.pop(); \\n                rr.emplace(time[i][0]+time[i][2], i); \\n            }\\n            if (rr.size()) {\\n                auto [_, i] = rr.top(); rr.pop(); \\n                free += time[i][2]; \\n                if (n) l.emplace(free+time[i][3], i); \\n                else ans = max(ans, free); \\n            } else {\\n                auto [_, i] = ll.top(); ll.pop();\\n                free += time[i][0]; \\n                r.emplace(free+time[i][1], i); \\n                --n; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int ans = 0, free = 0; \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> l, r; \\n        priority_queue<pair<int, int>> ll, rr; \\n        for (int i = 0; i < time.size(); ++i) \\n            ll.emplace(time[i][0]+time[i][2], i); \\n        while (n || r.size() || rr.size()) {\\n            if (rr.empty() && (r.empty() || r.top().first>free) && (!n || ll.empty() && (l.empty() || l.top().first>free))) {\\n                int cand = INT_MAX; \\n                if (n && l.size()) cand = min(cand, l.top().first); \\n                if (r.size()) cand = min(cand, r.top().first); \\n                free = cand; \\n            }\\n            while (l.size() && l.top().first <= free) {\\n                auto [_, i] = l.top(); l.pop(); \\n                ll.emplace(time[i][0]+time[i][2], i); \\n            }\\n            while (r.size() && r.top().first <= free) {\\n                auto [_, i] = r.top(); r.pop(); \\n                rr.emplace(time[i][0]+time[i][2], i); \\n            }\\n            if (rr.size()) {\\n                auto [_, i] = rr.top(); rr.pop(); \\n                free += time[i][2]; \\n                if (n) l.emplace(free+time[i][3], i); \\n                else ans = max(ans, free); \\n            } else {\\n                auto [_, i] = ll.top(); ll.pop();\\n                free += time[i][0]; \\n                r.emplace(free+time[i][1], i); \\n                --n; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071564,
                "title": "easy-to-understand-java-priorityqueues-to-describe-and-solve",
                "content": "```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        if (k <= 0 || n <= 0 || time == null || time.length != k) {\\n            return 0;\\n        }\\n\\n        Queue<Worker> left = new PriorityQueue<Worker>((w1, w2) -> {\\n            int priority1 = time[w1.index][0] + time[w1.index][2], priority2 = time[w2.index][0] + time[w2.index][2];\\n            return (priority1 == priority2) ? (w2.index - w1.index) : (priority2 - priority1);\\n        });\\n        Queue<Worker> right = new PriorityQueue<Worker>((w1, w2) -> {\\n            int priority1 = time[w1.index][0] + time[w1.index][2], priority2 = time[w2.index][0] + time[w2.index][2];\\n            return (priority1 == priority2) ? (w2.index - w1.index) : (priority2 - priority1);\\n        });\\n        Queue<Worker> pick = new PriorityQueue<Worker>((w1, w2) -> w1.time - w2.time);\\n        Queue<Worker> put = new PriorityQueue<Worker>((w1, w2) -> w1.time - w2.time);\\n        for (int i = 0; i < k; i++) {\\n            left.offer(new Worker(i, 0));\\n        }\\n\\n        int current = 0;\\n        while (n > 0 || pick.size() + right.size() > 0) {\\n            while (!put.isEmpty() && put.peek().time <= current) {\\n                left.offer(put.poll());\\n            }\\n            while (!pick.isEmpty() && pick.peek().time <= current) {\\n                right.offer(pick.poll());\\n            }\\n\\n            if (!right.isEmpty()) {\\n                Worker head = right.poll();\\n                current += time[head.index][2];\\n                head.time = current + time[head.index][3];\\n                put.offer(head);\\n            } else if (!left.isEmpty() && n > 0) {\\n                Worker head = left.poll();\\n                current += time[head.index][0];\\n                head.time = current + time[head.index][1];\\n                pick.offer(head);\\n                n--;\\n            } else {\\n                current = Integer.MAX_VALUE;\\n                if (!pick.isEmpty()) {\\n                    current = Math.min(current, pick.peek().time);\\n                }\\n                if (!put.isEmpty() && n > 0) {\\n                    current = Math.min(current, put.peek().time);\\n                }\\n            }\\n        }\\n        return current;\\n    }\\n\\n    private class Worker {\\n        private int index;\\n        private int time;\\n\\n        private Worker(int index, int time) {\\n            this.index = index;\\n            this.time = time;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        if (k <= 0 || n <= 0 || time == null || time.length != k) {\\n            return 0;\\n        }\\n\\n        Queue<Worker> left = new PriorityQueue<Worker>((w1, w2) -> {\\n            int priority1 = time[w1.index][0] + time[w1.index][2], priority2 = time[w2.index][0] + time[w2.index][2];\\n            return (priority1 == priority2) ? (w2.index - w1.index) : (priority2 - priority1);\\n        });\\n        Queue<Worker> right = new PriorityQueue<Worker>((w1, w2) -> {\\n            int priority1 = time[w1.index][0] + time[w1.index][2], priority2 = time[w2.index][0] + time[w2.index][2];\\n            return (priority1 == priority2) ? (w2.index - w1.index) : (priority2 - priority1);\\n        });\\n        Queue<Worker> pick = new PriorityQueue<Worker>((w1, w2) -> w1.time - w2.time);\\n        Queue<Worker> put = new PriorityQueue<Worker>((w1, w2) -> w1.time - w2.time);\\n        for (int i = 0; i < k; i++) {\\n            left.offer(new Worker(i, 0));\\n        }\\n\\n        int current = 0;\\n        while (n > 0 || pick.size() + right.size() > 0) {\\n            while (!put.isEmpty() && put.peek().time <= current) {\\n                left.offer(put.poll());\\n            }\\n            while (!pick.isEmpty() && pick.peek().time <= current) {\\n                right.offer(pick.poll());\\n            }\\n\\n            if (!right.isEmpty()) {\\n                Worker head = right.poll();\\n                current += time[head.index][2];\\n                head.time = current + time[head.index][3];\\n                put.offer(head);\\n            } else if (!left.isEmpty() && n > 0) {\\n                Worker head = left.poll();\\n                current += time[head.index][0];\\n                head.time = current + time[head.index][1];\\n                pick.offer(head);\\n                n--;\\n            } else {\\n                current = Integer.MAX_VALUE;\\n                if (!pick.isEmpty()) {\\n                    current = Math.min(current, pick.peek().time);\\n                }\\n                if (!put.isEmpty() && n > 0) {\\n                    current = Math.min(current, put.peek().time);\\n                }\\n            }\\n        }\\n        return current;\\n    }\\n\\n    private class Worker {\\n        private int index;\\n        private int time;\\n\\n        private Worker(int index, int time) {\\n            this.index = index;\\n            this.time = time;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056963,
                "title": "java-solution-using-priorityqueues",
                "content": "```\\n// Bridge-Worker Class\\nclass Bridge implements Comparable<Bridge>{\\n    int idx, total, ltr, rtl, time;\\n    int pickOld, putNew;\\n    Bridge(int idx, int ltr, int rtl, int pickOld, int putNew){\\n        this.idx=idx;\\n        this.total=ltr+rtl;\\n        this.ltr=ltr; this.rtl=rtl;\\n        this.pickOld=pickOld;\\n        this.putNew=putNew;\\n    }  \\n    \\n    public int compareTo(Bridge a){\\n        if(this.total!=a.total) return a.total-this.total;\\n        return a.idx-this.idx;\\n    }\\n}\\n\\n\\n// Ware-House Worker Class\\nclass House implements Comparable<House>{\\n    int idx; int finish;\\n    House(int idx, int finish){\\n        this.idx=idx;\\n        this.finish=finish;\\n    }\\n    \\n    public int compareTo(House h){\\n        return this.finish-h.finish;\\n    }\\n}\\n\\n\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        PriorityQueue<Bridge> leftBridge = new PriorityQueue<>();\\n        PriorityQueue<Bridge> rightBridge = new PriorityQueue<>();\\n        \\n        PriorityQueue<House> leftHouse = new PriorityQueue<>();\\n        PriorityQueue<House> rightHouse = new PriorityQueue<>();\\n        \\n\\t\\t// Initiall all the workers are at left-bank\\n        for(int i=0; i<k; i++){\\n            leftBridge.add(new Bridge(i,time[i][0],time[i][2],time[i][1],time[i][3]));\\n        }\\n        \\n        ArrayList<Integer> ans = new ArrayList<Integer>();\\n                           \\n        int curTime = 0;\\n        while(n>0){\\n            \\n            // Left-Ware-House\\n            while(!leftHouse.isEmpty() && leftHouse.peek().finish<=curTime && n>(rightBridge.size()+rightHouse.size())){\\n                House h = leftHouse.poll();\\n                leftBridge.add(new Bridge(h.idx,time[h.idx][0],time[h.idx][2],time[h.idx][1],time[h.idx][3]));\\n            }\\n                \\n            // Right-WareHouse\\n            while(!rightHouse.isEmpty() && rightHouse.peek().finish<=curTime){\\n                House h = rightHouse.poll();\\n                rightBridge.add(new Bridge(h.idx,time[h.idx][0],time[h.idx][2],time[h.idx][1],time[h.idx][3]));\\n            }\\n                  \\n                  \\n            // Right-Bridge\\n            if(!rightBridge.isEmpty()){\\n                Bridge b = rightBridge.poll();\\n                curTime+=b.rtl;\\n                ans.add(curTime);\\n                leftHouse.add(new House(b.idx,curTime+b.putNew));\\n                n--;\\n                continue;\\n            }\\n            \\n            // Left-Bridge\\n            if(!leftBridge.isEmpty() && n>(rightBridge.size()+rightHouse.size())){\\n                Bridge b = leftBridge.poll();\\n                curTime+=b.ltr;\\n                rightHouse.add(new House(b.idx,curTime+b.pickOld));\\n                continue;\\n            }\\n             \\n\\t\\t\\t // if both the bridges are empty than we bring the worker to the bridge from either of the  house \\n            int leftTime =  (leftHouse.size()!=0 && n>(rightHouse.size()+rightBridge.size()))? leftHouse.peek().finish: Integer.MAX_VALUE;\\n            int rightTime = (rightHouse.size()!=0)? rightHouse.peek().finish:Integer.MAX_VALUE;\\n                       \\n            if(leftTime<rightTime){\\n                House h = leftHouse.poll();\\n                curTime=leftTime;\\n                leftBridge.add(new Bridge(h.idx,time[h.idx][0],time[h.idx][2],time[h.idx][1],time[h.idx][3]));\\n            }else{\\n                House h = rightHouse.poll();\\n                curTime=rightTime;\\n                rightBridge.add(new Bridge(h.idx,time[h.idx][0],time[h.idx][2],time[h.idx][1],time[h.idx][3]));                \\n            }\\n        }\\n                              \\n        return ans.get(ans.size()-1);             \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Bridge-Worker Class\\nclass Bridge implements Comparable<Bridge>{\\n    int idx, total, ltr, rtl, time;\\n    int pickOld, putNew;\\n    Bridge(int idx, int ltr, int rtl, int pickOld, int putNew){\\n        this.idx=idx;\\n        this.total=ltr+rtl;\\n        this.ltr=ltr; this.rtl=rtl;\\n        this.pickOld=pickOld;\\n        this.putNew=putNew;\\n    }  \\n    \\n    public int compareTo(Bridge a){\\n        if(this.total!=a.total) return a.total-this.total;\\n        return a.idx-this.idx;\\n    }\\n}\\n\\n\\n// Ware-House Worker Class\\nclass House implements Comparable<House>{\\n    int idx; int finish;\\n    House(int idx, int finish){\\n        this.idx=idx;\\n        this.finish=finish;\\n    }\\n    \\n    public int compareTo(House h){\\n        return this.finish-h.finish;\\n    }\\n}\\n\\n\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        PriorityQueue<Bridge> leftBridge = new PriorityQueue<>();\\n        PriorityQueue<Bridge> rightBridge = new PriorityQueue<>();\\n        \\n        PriorityQueue<House> leftHouse = new PriorityQueue<>();\\n        PriorityQueue<House> rightHouse = new PriorityQueue<>();\\n        \\n\\t\\t// Initiall all the workers are at left-bank\\n        for(int i=0; i<k; i++){\\n            leftBridge.add(new Bridge(i,time[i][0],time[i][2],time[i][1],time[i][3]));\\n        }\\n        \\n        ArrayList<Integer> ans = new ArrayList<Integer>();\\n                           \\n        int curTime = 0;\\n        while(n>0){\\n            \\n            // Left-Ware-House\\n            while(!leftHouse.isEmpty() && leftHouse.peek().finish<=curTime && n>(rightBridge.size()+rightHouse.size())){\\n                House h = leftHouse.poll();\\n                leftBridge.add(new Bridge(h.idx,time[h.idx][0],time[h.idx][2],time[h.idx][1],time[h.idx][3]));\\n            }\\n                \\n            // Right-WareHouse\\n            while(!rightHouse.isEmpty() && rightHouse.peek().finish<=curTime){\\n                House h = rightHouse.poll();\\n                rightBridge.add(new Bridge(h.idx,time[h.idx][0],time[h.idx][2],time[h.idx][1],time[h.idx][3]));\\n            }\\n                  \\n                  \\n            // Right-Bridge\\n            if(!rightBridge.isEmpty()){\\n                Bridge b = rightBridge.poll();\\n                curTime+=b.rtl;\\n                ans.add(curTime);\\n                leftHouse.add(new House(b.idx,curTime+b.putNew));\\n                n--;\\n                continue;\\n            }\\n            \\n            // Left-Bridge\\n            if(!leftBridge.isEmpty() && n>(rightBridge.size()+rightHouse.size())){\\n                Bridge b = leftBridge.poll();\\n                curTime+=b.ltr;\\n                rightHouse.add(new House(b.idx,curTime+b.pickOld));\\n                continue;\\n            }\\n             \\n\\t\\t\\t // if both the bridges are empty than we bring the worker to the bridge from either of the  house \\n            int leftTime =  (leftHouse.size()!=0 && n>(rightHouse.size()+rightBridge.size()))? leftHouse.peek().finish: Integer.MAX_VALUE;\\n            int rightTime = (rightHouse.size()!=0)? rightHouse.peek().finish:Integer.MAX_VALUE;\\n                       \\n            if(leftTime<rightTime){\\n                House h = leftHouse.poll();\\n                curTime=leftTime;\\n                leftBridge.add(new Bridge(h.idx,time[h.idx][0],time[h.idx][2],time[h.idx][1],time[h.idx][3]));\\n            }else{\\n                House h = rightHouse.poll();\\n                curTime=rightTime;\\n                rightBridge.add(new Bridge(h.idx,time[h.idx][0],time[h.idx][2],time[h.idx][1],time[h.idx][3]));                \\n            }\\n        }\\n                              \\n        return ans.get(ans.size()-1);             \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051098,
                "title": "c-4-priority-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& T) {\\n        priority_queue<pair<int, int>> wait_l, wait_r, pick, put;\\n        for(int i = 0; i < T.size(); i++) wait_l.push({T[i][0]+T[i][2], i});\\n        int t = 0;\\n        while(n > 0) {\\n            if(!wait_r.empty()) {\\n                auto p = wait_r.top(); wait_r.pop();\\n                int idx = p.second;\\n                t += T[idx][2];\\n                put.push({-(t + T[idx][3]), idx});\\n            } else if(!wait_l.empty()) {\\n                auto p = wait_l.top(); wait_l.pop();\\n                n--;\\n                int idx = p.second;\\n                t += T[idx][0];\\n                pick.push({-(t + T[idx][1]), idx});\\n            } else {\\n                if(pick.empty()) {\\n                    t = -put.top().first;\\n                } else if(put.empty()) {\\n                    t = -pick.top().first;\\n                } else {\\n                    t = min(-pick.top().first, -put.top().first);\\n                }\\n            }\\n\\n            //KEY: when time changes, we update the waiting queue\\n            while(!pick.empty() && -pick.top().first <= t) {\\n                auto p = pick.top(); pick.pop();\\n                int idx = p.second;\\n                wait_r.push({T[idx][0]+T[idx][2], idx});\\n            }\\n            while(!put.empty() && -put.top().first <= t) {\\n                auto p = put.top(); put.pop();\\n                int idx = p.second;\\n                wait_l.push({T[idx][0]+T[idx][2], idx});\\n            }\\n        }\\n\\n        while(!wait_r.empty()) {\\n            auto p = wait_r.top(); wait_r.pop();\\n            int idx = p.second;\\n            t += T[idx][2];\\n            //put.push({t + T[idx][3], idx});\\n            while(!pick.empty() && -pick.top().first <= t) {\\n                auto p = pick.top(); pick.pop();\\n                int idx = p.second;\\n                wait_r.push({T[idx][0]+T[idx][2], idx});\\n            }\\n        }\\n\\n        while(!pick.empty()) {\\n            auto p = pick.top(); pick.pop();\\n            int idx = p.second;\\n            t = max(t, -p.first);\\n            t += T[idx][2];\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& T) {\\n        priority_queue<pair<int, int>> wait_l, wait_r, pick, put;\\n        for(int i = 0; i < T.size(); i++) wait_l.push({T[i][0]+T[i][2], i});\\n        int t = 0;\\n        while(n > 0) {\\n            if(!wait_r.empty()) {\\n                auto p = wait_r.top(); wait_r.pop();\\n                int idx = p.second;\\n                t += T[idx][2];\\n                put.push({-(t + T[idx][3]), idx});\\n            } else if(!wait_l.empty()) {\\n                auto p = wait_l.top(); wait_l.pop();\\n                n--;\\n                int idx = p.second;\\n                t += T[idx][0];\\n                pick.push({-(t + T[idx][1]), idx});\\n            } else {\\n                if(pick.empty()) {\\n                    t = -put.top().first;\\n                } else if(put.empty()) {\\n                    t = -pick.top().first;\\n                } else {\\n                    t = min(-pick.top().first, -put.top().first);\\n                }\\n            }\\n\\n            //KEY: when time changes, we update the waiting queue\\n            while(!pick.empty() && -pick.top().first <= t) {\\n                auto p = pick.top(); pick.pop();\\n                int idx = p.second;\\n                wait_r.push({T[idx][0]+T[idx][2], idx});\\n            }\\n            while(!put.empty() && -put.top().first <= t) {\\n                auto p = put.top(); put.pop();\\n                int idx = p.second;\\n                wait_l.push({T[idx][0]+T[idx][2], idx});\\n            }\\n        }\\n\\n        while(!wait_r.empty()) {\\n            auto p = wait_r.top(); wait_r.pop();\\n            int idx = p.second;\\n            t += T[idx][2];\\n            //put.push({t + T[idx][3], idx});\\n            while(!pick.empty() && -pick.top().first <= t) {\\n                auto p = pick.top(); pick.pop();\\n                int idx = p.second;\\n                wait_r.push({T[idx][0]+T[idx][2], idx});\\n            }\\n        }\\n\\n        while(!pick.empty()) {\\n            auto p = pick.top(); pick.pop();\\n            int idx = p.second;\\n            t = max(t, -p.first);\\n            t += T[idx][2];\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049092,
                "title": "python-simulation-with-4-priority-queues-explained",
                "content": "We are using 4 priority queues to track the workers at four different points:\\n(1) the new site on left bank of river;\\n(2) the old site on right bank of river;\\n(3) the left end of bridge;\\n(4) the right end of bridge.\\n\\nqueue (1) and (2) are ordered based on the finishing time;\\nqueue (3) and (4) are ordered based on the efficiency defined in the problem\\n\\nSince only one worker is allowed crossing the bridage, and workers on the right bank should cross first. We can use the bridge crossing event as the time control event and advance the time.\\n\\nThere are a few cases we need to pay attention and advance time accordingly. Othervise, we may enter infinite loop:\\n1) both end of the bridge is empty --> no waiting workers: we need to advance time based on the first complete time in warehouse;\\n2) we have already sent enough workers to old warehouse, and no workers is waiting on the right end of the bridge: --> we just need to advance time based on the complete time in old warehouse.\\n\\n```\\nclass Solution:\\n    def findCrossingTime(self, n, k, time):\\n        self.time = time\\n        # one queue to track the workers putting down boxes at new site\\n        self.new_site_workers = []\\n        # one queue to track the workers picking up boxes at old site\\n        self.old_site_workers = []\\n        # two queues to track the workers waiting at two side of the bridge\\n        self.bridge_left_workers = []\\n        self.bridge_right_workers = []\\n\\n        # initailly all the workers are at left side of river\\n        for idx, worker_time in enumerate(time):\\n            heapq.heappush(self.bridge_left_workers, (-(worker_time[0] + worker_time[2]), -idx))\\n\\n        # start simulation\\n        moved_box = 0\\n        left_box = n\\n        t = 0\\n        while True:\\n            while self.bridge_right_workers:\\n                _, widx = heapq.heappop(self.bridge_right_workers)\\n                widx = -widx\\n                # advance time\\n                t += time[widx][2]\\n                # update status\\n                heapq.heappush(self.new_site_workers, (t + time[widx][3], widx))\\n                # one box is moved to new site\\n                moved_box += 1\\n                if moved_box == n:\\n                    return t\\n                self.status_update(t)\\n\\n            if not self.bridge_left_workers and not self.bridge_right_workers:\\n                # no workers are waiting at the bridge\\n                t_old, t_new = float(\\'inf\\'), float(\\'inf\\')\\n                if self.old_site_workers:\\n                    t_old = self.old_site_workers[0][0]\\n                if self.new_site_workers:\\n                    t_new = self.new_site_workers[0][0]\\n                t = min(t_old, t_new)\\n                self.status_update(t)\\n\\n            if left_box == 0 and not self.bridge_right_workers:\\n                t = self.old_site_workers[0][0]\\n                self.status_update(t)\\n\\n            # no more workers are waiting on the right side of the river\\n            if left_box and self.bridge_left_workers:\\n                _, widx = heapq.heappop(self.bridge_left_workers)\\n                widx = -widx\\n                # advance time\\n                t += time[widx][0]\\n                # update status\\n                heapq.heappush(self.old_site_workers, (t + time[widx][1], widx))\\n                self.status_update(t)\\n                left_box -= 1\\n\\n    def status_update(self, t):\\n        while self.new_site_workers and self.new_site_workers[0][0] <= t:\\n            _, widx = heapq.heappop(self.new_site_workers)\\n            # adding this worker to the waiting queue at left side of river\\n            wt = self.time[widx]\\n            heapq.heappush(self.bridge_left_workers, (-(wt[0] + wt[2]), -widx))\\n\\n        while self.old_site_workers and self.old_site_workers[0][0] <= t:\\n            _, widx = heapq.heappop(self.old_site_workers)\\n            # adding this worker to the waiting queue at right side of river\\n            wt = self.time[widx]\\n            heapq.heappush(self.bridge_right_workers, (-(wt[0] + wt[2]), -widx))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n, k, time):\\n        self.time = time\\n        # one queue to track the workers putting down boxes at new site\\n        self.new_site_workers = []\\n        # one queue to track the workers picking up boxes at old site\\n        self.old_site_workers = []\\n        # two queues to track the workers waiting at two side of the bridge\\n        self.bridge_left_workers = []\\n        self.bridge_right_workers = []\\n\\n        # initailly all the workers are at left side of river\\n        for idx, worker_time in enumerate(time):\\n            heapq.heappush(self.bridge_left_workers, (-(worker_time[0] + worker_time[2]), -idx))\\n\\n        # start simulation\\n        moved_box = 0\\n        left_box = n\\n        t = 0\\n        while True:\\n            while self.bridge_right_workers:\\n                _, widx = heapq.heappop(self.bridge_right_workers)\\n                widx = -widx\\n                # advance time\\n                t += time[widx][2]\\n                # update status\\n                heapq.heappush(self.new_site_workers, (t + time[widx][3], widx))\\n                # one box is moved to new site\\n                moved_box += 1\\n                if moved_box == n:\\n                    return t\\n                self.status_update(t)\\n\\n            if not self.bridge_left_workers and not self.bridge_right_workers:\\n                # no workers are waiting at the bridge\\n                t_old, t_new = float(\\'inf\\'), float(\\'inf\\')\\n                if self.old_site_workers:\\n                    t_old = self.old_site_workers[0][0]\\n                if self.new_site_workers:\\n                    t_new = self.new_site_workers[0][0]\\n                t = min(t_old, t_new)\\n                self.status_update(t)\\n\\n            if left_box == 0 and not self.bridge_right_workers:\\n                t = self.old_site_workers[0][0]\\n                self.status_update(t)\\n\\n            # no more workers are waiting on the right side of the river\\n            if left_box and self.bridge_left_workers:\\n                _, widx = heapq.heappop(self.bridge_left_workers)\\n                widx = -widx\\n                # advance time\\n                t += time[widx][0]\\n                # update status\\n                heapq.heappush(self.old_site_workers, (t + time[widx][1], widx))\\n                self.status_update(t)\\n                left_box -= 1\\n\\n    def status_update(self, t):\\n        while self.new_site_workers and self.new_site_workers[0][0] <= t:\\n            _, widx = heapq.heappop(self.new_site_workers)\\n            # adding this worker to the waiting queue at left side of river\\n            wt = self.time[widx]\\n            heapq.heappush(self.bridge_left_workers, (-(wt[0] + wt[2]), -widx))\\n\\n        while self.old_site_workers and self.old_site_workers[0][0] <= t:\\n            _, widx = heapq.heappop(self.old_site_workers)\\n            # adding this worker to the waiting queue at right side of river\\n            wt = self.time[widx]\\n            heapq.heappush(self.bridge_right_workers, (-(wt[0] + wt[2]), -widx))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048926,
                "title": "c-easy-to-understand-event-simulation-understandable-in-first-look",
                "content": "```\\n// Easy simulation just code the Finite state machine\\n// Enable the cout to see step by step simulation\\n\\nclass Solution {\\npublic:\\n    using pi = pair<int,int>;\\n    #define IDLE 0\\n    #define LeftFree 1\\n    #define Left2Right 2\\n    #define PickOld 3\\n    #define Right2Left 4\\n    #define RightFree 5\\n    #define PutNew 6\\n    \\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<pi> left;\\n        priority_queue<pi> right;\\n        priority_queue<pi,vector<pi>,greater<pi>> timeQ;\\n        \\n        // push all the workers in left priority queue\\n        for (int i = 0; i < k; i++) {\\n            int cost = time[i][0] + time[i][2];\\n            left.push({cost,i});\\n        }\\n        vector<int> status(k,IDLE);\\n        int result = 0;\\n        int t = 0;\\n        int task = 0;\\n        bool bridgeFree = true;\\n        do {\\n            // if timeQ is not empty process the current time events\\n            if (!timeQ.empty()) {\\n                auto [nxt,idx] = timeQ.top();\\n                t = nxt;\\n                while(!timeQ.empty()) {\\n                    auto [nxt,idx] = timeQ.top();\\n                    if (nxt != t) {\\n                        break;\\n                    }\\n                    timeQ.pop();\\n                    int s = status[idx];\\n                    int cost = 0;\\n                    switch(s) {\\n                        case LeftFree :  // if current event to cross from left to right generate the future event for timeQueue and block bridge\\n                            timeQ.push({t+time[idx][0],idx});\\n                            status[idx] = Left2Right;\\n                            task++;\\n                            //cout << t << \" to \" << t+time[idx][0] << \" \" << \"worker \" << idx ;\\n                            //cout << \" crosses the bridge from the left bank to the right bank.\" << endl;\\n                            bridgeFree = false;\\n                            break;\\n                        case Left2Right :  // if current event reached the right bank, free the bridge and schedule the pickup for future\\n                            timeQ.push({t+time[idx][1],idx});\\n                            status[idx] = PickOld;\\n                            //cout << t << \" to \" << t+time[idx][1] << \" \" << \"worker \" << idx ;\\n                            //cout << \" picks up a box from the old warehouse.\" << endl;\\n                            bridgeFree = true;\\n                            break;\\n                        case PickOld: // if current event pick up done, put the current worker in ready right bank worker list\\n                            cost = time[idx][0] + time[idx][2];\\n                            right.push({cost,idx});\\n                            status[idx] = IDLE;\\n                            break;\\n                        case Right2Left : //  if current event to cross from right to left generate the future event for timeQueue and block bridge\\n                            timeQ.push({t+time[idx][2],idx});\\n                            status[idx] = RightFree;\\n                            bridgeFree = false;\\n                            //cout << t << \" to \" << t+time[idx][2] << \" \" << \"worker \" << idx ;\\n                            //cout << \" crosses the bridge from the left bank to the right bank.\"<< endl;\\n                            break;\\n                        case RightFree : // if current event reached theleft bank, free the bridge and schedule the drop off for future\\n                            bridgeFree = true;\\n                            //cout << t << \" to \" << t+time[idx][3] << \" \" << \"worker \" << idx ;\\n                            //cout << \" puts a box at the new warehouse.\" << endl;\\n                            timeQ.push({t+time[idx][3],idx});\\n                            status[idx] = PutNew;\\n                            result = t;\\n                            break;    \\n                        case PutNew: // if current drop off is done, put the current worker in ready left bank worker list\\n                            //cout << \"Time \" << t << \" Job completed by worker : \" << idx << endl;\\n                            status[idx] = IDLE;\\n                            cost = time[idx][0] + time[idx][2];\\n                            left.push({cost,idx});\\n                            break;\\n                        default :;\\n                    }\\n                }\\n            }\\n            // if Bridge is free let first right waiting worker cross , if no right then \\n            // let less efficient left bank worker pass\\n            if (bridgeFree) {\\n                if (!right.empty()) {\\n                    auto [cost,idx] = right.top(); right.pop();\\n                    timeQ.push({t,idx});\\n                    status[idx] = Right2Left;\\n                } else if ((task < n) && !left.empty()) {\\n                    auto [cost,idx] = left.top(); left.pop();\\n                    timeQ.push({t,idx});\\n                    status[idx] = LeftFree;\\n                } \\n            }\\n        } while (!timeQ.empty());\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Easy simulation just code the Finite state machine\\n// Enable the cout to see step by step simulation\\n\\nclass Solution {\\npublic:\\n    using pi = pair<int,int>;\\n    #define IDLE 0\\n    #define LeftFree 1\\n    #define Left2Right 2\\n    #define PickOld 3\\n    #define Right2Left 4\\n    #define RightFree 5\\n    #define PutNew 6\\n    \\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<pi> left;\\n        priority_queue<pi> right;\\n        priority_queue<pi,vector<pi>,greater<pi>> timeQ;\\n        \\n        // push all the workers in left priority queue\\n        for (int i = 0; i < k; i++) {\\n            int cost = time[i][0] + time[i][2];\\n            left.push({cost,i});\\n        }\\n        vector<int> status(k,IDLE);\\n        int result = 0;\\n        int t = 0;\\n        int task = 0;\\n        bool bridgeFree = true;\\n        do {\\n            // if timeQ is not empty process the current time events\\n            if (!timeQ.empty()) {\\n                auto [nxt,idx] = timeQ.top();\\n                t = nxt;\\n                while(!timeQ.empty()) {\\n                    auto [nxt,idx] = timeQ.top();\\n                    if (nxt != t) {\\n                        break;\\n                    }\\n                    timeQ.pop();\\n                    int s = status[idx];\\n                    int cost = 0;\\n                    switch(s) {\\n                        case LeftFree :  // if current event to cross from left to right generate the future event for timeQueue and block bridge\\n                            timeQ.push({t+time[idx][0],idx});\\n                            status[idx] = Left2Right;\\n                            task++;\\n                            //cout << t << \" to \" << t+time[idx][0] << \" \" << \"worker \" << idx ;\\n                            //cout << \" crosses the bridge from the left bank to the right bank.\" << endl;\\n                            bridgeFree = false;\\n                            break;\\n                        case Left2Right :  // if current event reached the right bank, free the bridge and schedule the pickup for future\\n                            timeQ.push({t+time[idx][1],idx});\\n                            status[idx] = PickOld;\\n                            //cout << t << \" to \" << t+time[idx][1] << \" \" << \"worker \" << idx ;\\n                            //cout << \" picks up a box from the old warehouse.\" << endl;\\n                            bridgeFree = true;\\n                            break;\\n                        case PickOld: // if current event pick up done, put the current worker in ready right bank worker list\\n                            cost = time[idx][0] + time[idx][2];\\n                            right.push({cost,idx});\\n                            status[idx] = IDLE;\\n                            break;\\n                        case Right2Left : //  if current event to cross from right to left generate the future event for timeQueue and block bridge\\n                            timeQ.push({t+time[idx][2],idx});\\n                            status[idx] = RightFree;\\n                            bridgeFree = false;\\n                            //cout << t << \" to \" << t+time[idx][2] << \" \" << \"worker \" << idx ;\\n                            //cout << \" crosses the bridge from the left bank to the right bank.\"<< endl;\\n                            break;\\n                        case RightFree : // if current event reached theleft bank, free the bridge and schedule the drop off for future\\n                            bridgeFree = true;\\n                            //cout << t << \" to \" << t+time[idx][3] << \" \" << \"worker \" << idx ;\\n                            //cout << \" puts a box at the new warehouse.\" << endl;\\n                            timeQ.push({t+time[idx][3],idx});\\n                            status[idx] = PutNew;\\n                            result = t;\\n                            break;    \\n                        case PutNew: // if current drop off is done, put the current worker in ready left bank worker list\\n                            //cout << \"Time \" << t << \" Job completed by worker : \" << idx << endl;\\n                            status[idx] = IDLE;\\n                            cost = time[idx][0] + time[idx][2];\\n                            left.push({cost,idx});\\n                            break;\\n                        default :;\\n                    }\\n                }\\n            }\\n            // if Bridge is free let first right waiting worker cross , if no right then \\n            // let less efficient left bank worker pass\\n            if (bridgeFree) {\\n                if (!right.empty()) {\\n                    auto [cost,idx] = right.top(); right.pop();\\n                    timeQ.push({t,idx});\\n                    status[idx] = Right2Left;\\n                } else if ((task < n) && !left.empty()) {\\n                    auto [cost,idx] = left.top(); left.pop();\\n                    timeQ.push({t,idx});\\n                    status[idx] = LeftFree;\\n                } \\n            }\\n        } while (!timeQ.empty());\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3048598,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        ll, l, r, rr = list(), list(), list(), list()\\n        for i, (a, _, c, _) in enumerate(time):\\n            heapq.heappush(l, (-a - c, -i))\\n\\n        t = 0\\n        while n:\\n            while ll and ll[0][0] <= t:\\n                _, i = heapq.heappop(ll)\\n                heapq.heappush(l, (-time[i][0] - time[i][2], -i))\\n            while rr and rr[0][0] <= t:\\n                _, i = heapq.heappop(rr)\\n                heapq.heappush(r, (-time[i][0] - time[i][2], -i))\\n\\n            if r:\\n                _, i = heapq.heappop(r)\\n                t += time[-i][2]\\n                heapq.heappush(ll, (t + time[-i][3], -i))\\n                n -= 1\\n            elif l and n > len(r) + len(rr):\\n                _, i = heapq.heappop(l)\\n                t += time[-i][0]\\n                heapq.heappush(rr, (t + time[-i][1], -i))\\n            else:\\n                x = ll[0][0] if ll and n > len(r) + len(rr) else float(\\'inf\\')\\n                y = rr[0][0] if rr else float(\\'inf\\')\\n                t = min(x, y)\\n        return t\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        ll, l, r, rr = list(), list(), list(), list()\\n        for i, (a, _, c, _) in enumerate(time):\\n            heapq.heappush(l, (-a - c, -i))\\n\\n        t = 0\\n        while n:\\n            while ll and ll[0][0] <= t:\\n                _, i = heapq.heappop(ll)\\n                heapq.heappush(l, (-time[i][0] - time[i][2], -i))\\n            while rr and rr[0][0] <= t:\\n                _, i = heapq.heappop(rr)\\n                heapq.heappush(r, (-time[i][0] - time[i][2], -i))\\n\\n            if r:\\n                _, i = heapq.heappop(r)\\n                t += time[-i][2]\\n                heapq.heappush(ll, (t + time[-i][3], -i))\\n                n -= 1\\n            elif l and n > len(r) + len(rr):\\n                _, i = heapq.heappop(l)\\n                t += time[-i][0]\\n                heapq.heappush(rr, (t + time[-i][1], -i))\\n            else:\\n                x = ll[0][0] if ll and n > len(r) + len(rr) else float(\\'inf\\')\\n                y = rr[0][0] if rr else float(\\'inf\\')\\n                t = min(x, y)\\n        return t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046920,
                "title": "short-and-simple-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    class WorkerOnBank{\\n        int details[], id;\\n        WorkerOnBank(int details[], int id){\\n            this.details = details;\\n            this.id = id;\\n        }\\n    }\\n    class WorkerInWarehouse{\\n        int id, outTime;\\n        WorkerInWarehouse(int id, int outTime){\\n            this.id = id;\\n            this.outTime = outTime;\\n        }\\n    }\\n    class WorkerOnBankComparator implements Comparator<WorkerOnBank>{\\n        public int compare(WorkerOnBank a, WorkerOnBank b){\\n            if(a.details[0] + a.details[2] == b.details[0] + b.details[2])\\n                return b.id - a.id;\\n            return (b.details[0] + b.details[2]) - (a.details[0] + a.details[2]);\\n        }\\n    }\\n    class WorkerInWarehouseComparator implements Comparator<WorkerInWarehouse>{\\n        public int compare(WorkerInWarehouse a, WorkerInWarehouse b){\\n           return a.outTime - b.outTime;\\n        }\\n    }\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        int t = 0, i = 0, ans = 0;\\n\\n        PriorityQueue<WorkerOnBank> leftBank = new PriorityQueue<>(k, new WorkerOnBankComparator());\\n        PriorityQueue<WorkerOnBank> rightBank = new PriorityQueue<>(k, new WorkerOnBankComparator());\\n\\n        PriorityQueue<WorkerInWarehouse> oldWarehouse = new PriorityQueue<>(k, new WorkerInWarehouseComparator());\\n        PriorityQueue<WorkerInWarehouse> newWarehouse = new PriorityQueue<>(k, new WorkerInWarehouseComparator());\\n\\n        for(int tt[] : time) leftBank.add(new WorkerOnBank(tt,i++));\\n        \\n        while(n > 0 || rightBank.size() > 0 || oldWarehouse.size() > 0 || newWarehouse.size() > 0){\\n            if(rightBank.size() == 0){\\n                if(n > 0 && leftBank.size() > 0){\\n                    t += leftBank.peek().details[0];\\n                    oldWarehouse.add(new WorkerInWarehouse(leftBank.peek().id, t + leftBank.poll().details[1]));\\n                    n -= 1;\\n                } else {\\n                    int minTime = Integer.MAX_VALUE;\\n                    if(oldWarehouse.size() > 0) minTime = Math.min(minTime, oldWarehouse.peek().outTime);\\n                    if(newWarehouse.size() > 0) minTime = Math.min(minTime, newWarehouse.peek().outTime);\\n\\n                    t = minTime;\\n                }\\n            } else {\\n                t += rightBank.peek().details[2]; ans = t;\\n                newWarehouse.add(new WorkerInWarehouse(rightBank.peek().id, t + rightBank.poll().details[3]));\\n            }\\n\\n            while(oldWarehouse.size() > 0 && oldWarehouse.peek().outTime <= t)\\n                rightBank.add(new WorkerOnBank(time[oldWarehouse.peek().id], oldWarehouse.poll().id));\\n            \\n            while(newWarehouse.size() > 0 && newWarehouse.peek().outTime <= t)\\n                leftBank.add(new WorkerOnBank(time[newWarehouse.peek().id], newWarehouse.poll().id));\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class WorkerOnBank{\\n        int details[], id;\\n        WorkerOnBank(int details[], int id){\\n            this.details = details;\\n            this.id = id;\\n        }\\n    }\\n    class WorkerInWarehouse{\\n        int id, outTime;\\n        WorkerInWarehouse(int id, int outTime){\\n            this.id = id;\\n            this.outTime = outTime;\\n        }\\n    }\\n    class WorkerOnBankComparator implements Comparator<WorkerOnBank>{\\n        public int compare(WorkerOnBank a, WorkerOnBank b){\\n            if(a.details[0] + a.details[2] == b.details[0] + b.details[2])\\n                return b.id - a.id;\\n            return (b.details[0] + b.details[2]) - (a.details[0] + a.details[2]);\\n        }\\n    }\\n    class WorkerInWarehouseComparator implements Comparator<WorkerInWarehouse>{\\n        public int compare(WorkerInWarehouse a, WorkerInWarehouse b){\\n           return a.outTime - b.outTime;\\n        }\\n    }\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        int t = 0, i = 0, ans = 0;\\n\\n        PriorityQueue<WorkerOnBank> leftBank = new PriorityQueue<>(k, new WorkerOnBankComparator());\\n        PriorityQueue<WorkerOnBank> rightBank = new PriorityQueue<>(k, new WorkerOnBankComparator());\\n\\n        PriorityQueue<WorkerInWarehouse> oldWarehouse = new PriorityQueue<>(k, new WorkerInWarehouseComparator());\\n        PriorityQueue<WorkerInWarehouse> newWarehouse = new PriorityQueue<>(k, new WorkerInWarehouseComparator());\\n\\n        for(int tt[] : time) leftBank.add(new WorkerOnBank(tt,i++));\\n        \\n        while(n > 0 || rightBank.size() > 0 || oldWarehouse.size() > 0 || newWarehouse.size() > 0){\\n            if(rightBank.size() == 0){\\n                if(n > 0 && leftBank.size() > 0){\\n                    t += leftBank.peek().details[0];\\n                    oldWarehouse.add(new WorkerInWarehouse(leftBank.peek().id, t + leftBank.poll().details[1]));\\n                    n -= 1;\\n                } else {\\n                    int minTime = Integer.MAX_VALUE;\\n                    if(oldWarehouse.size() > 0) minTime = Math.min(minTime, oldWarehouse.peek().outTime);\\n                    if(newWarehouse.size() > 0) minTime = Math.min(minTime, newWarehouse.peek().outTime);\\n\\n                    t = minTime;\\n                }\\n            } else {\\n                t += rightBank.peek().details[2]; ans = t;\\n                newWarehouse.add(new WorkerInWarehouse(rightBank.peek().id, t + rightBank.poll().details[3]));\\n            }\\n\\n            while(oldWarehouse.size() > 0 && oldWarehouse.peek().outTime <= t)\\n                rightBank.add(new WorkerOnBank(time[oldWarehouse.peek().id], oldWarehouse.poll().id));\\n            \\n            while(newWarehouse.size() > 0 && newWarehouse.peek().outTime <= t)\\n                leftBank.add(new WorkerOnBank(time[newWarehouse.peek().id], newWarehouse.poll().id));\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040792,
                "title": "solution-with-action-summary-debug-to-play-with",
                "content": "It helped for me to output an action summary for every iteration of the simulation. Play around with the print statements if you want!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    typedef array<int, 2> ai;\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int timeline = 0; // time of arrival, ID\\n        set<ai> l_wh, r_wh;\\n        priority_queue<ai> l_bridge, r_bridge;\\n        for(int i = 0; i < time.size(); i++) l_bridge.push({(time[i][0]+time[i][2]), i}); // efficiency, ID\\n\\n        while(n || r_bridge.size()+r_wh.size()){\\n            cout << \"ACTION SUMMARY: \" << endl;\\n            bool ok = false;\\n            if(r_bridge.empty() && l_bridge.size() && n-r_wh.size() > 0){\\n                auto temp = l_bridge.top();\\n                l_bridge.pop();\\n                r_wh.insert({timeline+time[temp[1]][0]+time[temp[1]][1], temp[1]});\\n                timeline += time[temp[1]][0];\\n                ok = true;\\n                cout << \"Worker \" << temp[1] << \" going to \" << \"r_wh\" << \"(\" << timeline << \")\" << \"(\" << \" Arrives \" << timeline+time[temp[1]][1] << \")\" << endl;\\n                cout << timeline << \" \" << temp[1] << endl;\\n            }\\n            \\n            if(r_bridge.size()){\\n                auto temp = r_bridge.top();\\n                r_bridge.pop();\\n                l_wh.insert({timeline+time[temp[1]][2]+time[temp[1]][3], temp[1]});\\n                timeline += time[temp[1]][2];\\n                ok = true;\\n                n--;\\n            }\\n            while (r_wh.size() && (*r_wh.begin())[0] <= timeline){\\n                auto it = r_wh.begin();\\n                auto id = (*it)[1];\\n                r_bridge.push({time[id][0]+time[id][2], id});\\n                cout << \"Worker \" << id << \" returns to r_bridge \" << \"(\" << timeline << \")\" << endl;\\n                r_wh.erase(it);\\n                ok = true;\\n            }\\n            while(l_wh.size() && (*l_wh.begin())[0] <= timeline){\\n                auto it = l_wh.begin();\\n                auto id = (*l_wh.begin())[1];\\n                l_bridge.push({time[id][0]+time[id][2], id});\\n                l_wh.erase(it);\\n                ok = true;\\n            }\\n            if(!ok){\\n                int t1 = l_wh.size() ? (*l_wh.begin())[0] : INT_MAX;\\n                int t2 = r_wh.size() ? (*r_wh.begin())[0] : INT_MAX;\\n                if(t1 <= timeline || t2 <= timeline) break;\\n                auto og = timeline;\\n                if(t1 > timeline && t2 > timeline) timeline = min(t1, t2);\\n                cout << \"TIMELINE UPDATED TO \" << timeline << \" FROM \" << og << endl;\\n            }\\n            cout << \"TIME = \" << timeline << endl;\\n            cout << endl << endl;\\n        }\\n        return timeline;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    typedef array<int, 2> ai;\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int timeline = 0; // time of arrival, ID\\n        set<ai> l_wh, r_wh;\\n        priority_queue<ai> l_bridge, r_bridge;\\n        for(int i = 0; i < time.size(); i++) l_bridge.push({(time[i][0]+time[i][2]), i}",
                "codeTag": "Java"
            },
            {
                "id": 3040253,
                "title": "simulation-explanation",
                "content": "# Intuition\\n\\nThere are 4 queues:\\n1. Workers waiting on the left side `left_q`\\n2. Workers with box waiting on the right side `right_q`\\n3. Workers picking box `right_box_q`\\n4. Workers putting box `left_box_q`\\n\\n**Waiting queues** contain tubles `(x, y)` where `x` is a worker efficiency miltipled by `-1`. Doing that the biggest values becomes the smallest. And `y` is a worker index miltipled by `-1` for the same purpose: bigger index will be later in priopity queue. It helps meating regulation rule on the bridge.\\n\\n**Box queues** contain tubles `(x, y)` where `x` is a time when the worker `y` would pick/put a box (get ready to cross the bridge).\\n\\nI also count a number of workers left to send (initialy `n`) to avoid sending workers for nothing.\\n\\n# Approach\\n\\nReserve a number `current_time` to know where workers on a timeline.\\nDo while there are some boxes on the right side or any worker somewhere on the right side.\\n1. Check **box** queues if some worker is ready to go to **waiting** queue. Move them: `right_box_q` -> `right_q` or `left_box_q` -> `left_q`.\\n2. Workers on the right side go first. One worker from the right queue can cross the bridge. Pick the one with lowest efficiency and \"move\" him to the left side: increase `current_time` and put him to `left_box_q` (which means he will be putting box until `x` from tuple `(x, y)` in `left_box_q`).\\n3. If nobody waiting on the right side one worker from left queue can cross the bridge: increase `current_time` and move him from `left_q` to `right_box_q`. Decrease `workers_to_send` count.\\n4. If both **waiting** queues are empty and we still in loop that means all workers are picking/putting boxes. In that case move the `current_time` to the closes time when any of workers will be ready to cross the bridge.\\n\\n# Complexity\\n- Time complexity: $$O(n * k)$$ ?\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        ef = []\\n        left_q = [] # queue waiting on the left side\\n        for i in range(k):\\n            ef.append(-(time[i][0] + time[i][2]))\\n            heapq.heappush(left_q, (ef[i], -i))\\n        workers_to_send = n # boxes to care minus workers in progress\\n        current_time = 0\\n        right_q = [] # queue waiting on the right side\\n        left_box_q = [] # queue for taking boxes\\n        right_box_q = [] # queue for putting boxes\\n        # box queues are sorted by the time when worker will be ready with picking boxes\\n        # waiting queues are sorted by efficiency\\n        while len(right_q) > 0 or len(right_box_q) > 0 or workers_to_send > 0:\\n            while len(right_box_q) > 0 and right_box_q[0][0] <= current_time: # check if smbd\\'s picked a box\\n                _, with_box = heapq.heappop(right_box_q)\\n                # move him to the right queue\\n                heapq.heappush(right_q, (ef[with_box], -with_box))\\n            while len(left_box_q) and left_box_q[0][0] <= current_time: # check if smbd\\'s put a box\\n                _, without_box = heapq.heappop(left_box_q)\\n                # move him to the right queue\\n                heapq.heappush(left_q, (ef[without_box], -without_box))\\n            if len(right_q) > 0: # the 1st from right to left go first\\n                _, next_to_left = heapq.heappop(right_q) # get with the lowest efficient\\n                next_to_left = -next_to_left\\n                current_time += time[next_to_left][2] # he crosses the bridge and putting a box\\n                heapq.heappush(left_box_q, (current_time + time[next_to_left][3], next_to_left))\\n            # when right queue is empty 1 from left queue can cross if some boxes left\\n            elif len(left_q) > 0 and workers_to_send > 0:\\n                _, next_to_right = heapq.heappop(left_q) # get with the lowest efficient\\n                next_to_right = -next_to_right\\n                current_time += time[next_to_right][0] # he crosses the bridge and picking a box\\n                heapq.heappush(right_box_q, (current_time + time[next_to_right][1], next_to_right))\\n                workers_to_send -= 1 # decrease a count of workers to send\\n            else: # both queues are empty (left queue we consider as empty if we dont need more workers)\\n                if len(right_box_q) == 0 and workers_to_send == 0: # nobody in a new warehouse and nobody to send\\n                    return current_time # we\\'ve done\\n                # take the smallest value from left_box_q and right_box_q and shift time\\n                right_box_time = sys.maxsize if len(right_box_q) == 0 else right_box_q[0][0]\\n                left_box_time = sys.maxsize if len(left_box_q) == 0 else left_box_q[0][0]\\n                # worker will get to a queue on the next iteration\\n                current_time = min(right_box_time, left_box_time)\\n        return current_time\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        ef = []\\n        left_q = [] # queue waiting on the left side\\n        for i in range(k):\\n            ef.append(-(time[i][0] + time[i][2]))\\n            heapq.heappush(left_q, (ef[i], -i))\\n        workers_to_send = n # boxes to care minus workers in progress\\n        current_time = 0\\n        right_q = [] # queue waiting on the right side\\n        left_box_q = [] # queue for taking boxes\\n        right_box_q = [] # queue for putting boxes\\n        # box queues are sorted by the time when worker will be ready with picking boxes\\n        # waiting queues are sorted by efficiency\\n        while len(right_q) > 0 or len(right_box_q) > 0 or workers_to_send > 0:\\n            while len(right_box_q) > 0 and right_box_q[0][0] <= current_time: # check if smbd\\'s picked a box\\n                _, with_box = heapq.heappop(right_box_q)\\n                # move him to the right queue\\n                heapq.heappush(right_q, (ef[with_box], -with_box))\\n            while len(left_box_q) and left_box_q[0][0] <= current_time: # check if smbd\\'s put a box\\n                _, without_box = heapq.heappop(left_box_q)\\n                # move him to the right queue\\n                heapq.heappush(left_q, (ef[without_box], -without_box))\\n            if len(right_q) > 0: # the 1st from right to left go first\\n                _, next_to_left = heapq.heappop(right_q) # get with the lowest efficient\\n                next_to_left = -next_to_left\\n                current_time += time[next_to_left][2] # he crosses the bridge and putting a box\\n                heapq.heappush(left_box_q, (current_time + time[next_to_left][3], next_to_left))\\n            # when right queue is empty 1 from left queue can cross if some boxes left\\n            elif len(left_q) > 0 and workers_to_send > 0:\\n                _, next_to_right = heapq.heappop(left_q) # get with the lowest efficient\\n                next_to_right = -next_to_right\\n                current_time += time[next_to_right][0] # he crosses the bridge and picking a box\\n                heapq.heappush(right_box_q, (current_time + time[next_to_right][1], next_to_right))\\n                workers_to_send -= 1 # decrease a count of workers to send\\n            else: # both queues are empty (left queue we consider as empty if we dont need more workers)\\n                if len(right_box_q) == 0 and workers_to_send == 0: # nobody in a new warehouse and nobody to send\\n                    return current_time # we\\'ve done\\n                # take the smallest value from left_box_q and right_box_q and shift time\\n                right_box_time = sys.maxsize if len(right_box_q) == 0 else right_box_q[0][0]\\n                left_box_time = sys.maxsize if len(left_box_q) == 0 else left_box_q[0][0]\\n                # worker will get to a queue on the next iteration\\n                current_time = min(right_box_time, left_box_time)\\n        return current_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040002,
                "title": "rephrasing-the-problem-python-o-nlogk-with-descriptive-comments",
                "content": "# Rephrasing the Problem\\nThis problem is very verbose and has some flaws in the wording. I\\'ll re-explain it quickly, but I won\\'t be as technical.\\n\\nThere are $$k$$ workers at the new warehouse and $$n$$ boxes in the old warehouse. The workers need to cross a bridge to the old warehouse, pick up a box, cross the bridge back to the new warehouse and put the box down. Each of these actions takes a certain amount of time for each worker (the ```ith``` entry of ```time```).\\n\\nCrossing the bridge is a blocking operation. Only one person can be on the bridge at a time (I guess imagine an old rickety bridge that will collapse if two people are on it).\\n\\nHowever, picking up and putting down the boxes are non-blocking and can be done concurrently.\\n\\nTo choose who can cross the bridge we need to consider 2 cases:\\n1. Someone ready to bring a box to the new warehouse. I.e. they already finished picking up a box at the old warehouse.\\n\\nIn this case, we should send the slowest walker (highest total time to cross both directions (take higher index on tie)) who has a box.\\n\\n2. There are no box carriers ready to cross, but there is someone ready to cross from the new warehouse to the old warehouse and there is a box for them to pick up there.\\n\\nIn this case, we should send the slowest walker from the new warehouse.\\n\\nWe want to know the time at which the last box finishes crossing the bridge. (NOT when all boxes are have been put in the new warehouse)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Intuition\\nJust by looking at the examples you should be able to tell that there isn\\'t much you can do to reframe the problem into something simple. The state has many different possibilities and each next state heavily depends on the previous state. This indicates that we probably need to simulate it.\\n\\nWe first recognize that the bridge bottlenecks the process, and we don\\'t need to make any decisions about who should cross the bridge until the current worker finishes crossing the bridge. So we can skip the current time to when the worker we choose to cross finishes and then see which workers would be done picking up/putting down boxes so we can consider them next time we choose who should cross.\\n\\nIt\\'s also important to consider the case where no one is ready to cross. In this case, we should move time to when at least one person will be to cross.\\n\\nIt\\'s not unreasonable to consider trying to find a cycle, but it will take a considerable amount of time to hash the state each time. If $$n>>k$$ or the limits on each worker\\'s time cost were much closer to 1 (which would limit the number of concurrent workers picking up/putting down boxes and thus reduce the number of possible states), it would be a good idea to try to find a cycle. However, the constraints do not meet either of these requirements, so we will just simulate.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBefore solving this problem generally, we should consider the case where $$k==1$$. In this case, we don\\'t actually need to simulate since we don\\'t need to make any bridge crossing choices. The answer will simply be the time it takes for the worker to do all tasks multiplied by the number of boxes minus the time it takes to put down the last box (since that isn\\'t counted).\\n\\nTo solve this problem, we will maintain 4 heaps. It is probably a bit more concise to only use 2 heaps, but in my opinion 4 heaps is more readable. (This is also the solution I thought of before being influenced by other solutions)\\n\\nThe 4 heaps are as follows:\\n1. ```left```. This is a max heap for workers trying to cross from the new warehouse to the old warehouse. The items are a tuple of total crossing time and the index.\\n2. ```right```. This is a max heap for workers trying to cross from the old warehouse to the new warehouse. The items are the same as ```left```.\\n3. ```picking```. This is a min heap for workers picking up boxes in the old warehouse. The items are a tuple of time when finished picking up and the index.\\n4. ```putting```. This is a min heap for workers putting down boxes in the new warehouse. The items are a tuple of time when finished putting down and the index.\\n\\nThroughout the simulation, we will move the workers between the heaps. Each heap feeds into exactly one heap:\\n1. ```left``` feeds into ```picking```\\n2. ```picking``` feeds into ```right```\\n3. ```right``` feeds into ```putting```\\n4. ```putting``` feeds into ```left```\\n\\nWe begin the simulation with all workers in the ```left``` heap.\\n\\nWe then loop until we run out of boxes to pick up (```n```), all workers picking up boxes are done (```picking```), and all workers trying to cross from the right are done crossing (```right```).\\n\\nIn each loop iteration we will do the following:\\n1. If someone is ready to cross from the right:\\n    a. Get the slowest walker from ```right```.\\n    b. Add the time for them to cross to the total time.\\n    c. Push the worker onto ```putting```.\\n2. Else if someone is ready to cross on the left and there is a box for them to pick up:\\n    a. Get the slowest walker from ```left```.\\n    b. Add the time for them to cross to the total time.\\n    c. Push the worker onto ```picking```.\\n3. Else:\\n    a. Update the total time to when the next person is done picking up or putting down a box.\\n4. Add all people done putting boxes down to ```left```.\\n5. Add all people done picking boxes up to ```right```.\\n\\nAt the end of this loop, the total time will be the answer.\\n\\n# Complexity\\n- Time complexity: $$O(nlogk)$$\\nPushing/popping from heaps takes $$O(logk)$$ time where $$k$$ is the number of workers. A worker will enter and exit each of the 4 heaps once for each of the $$n$$ boxes. Therefore the total time complexity is $$O(nlogk)$$. Note that if $$k==1$$, we can determine the answer in $$O(1)$$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(k)$$\\nThe number of workers, $$k$$, never changes and each worker will be in exactly one heap at any given time. Therefore the total amount of space taken up by the heaps will be proportional to $$k$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        # left = new, right = old\\n        #            0            1        2            3\\n        # time[i] = [leftToRight, pickOld, rightToLeft, putNew]\\n\\n        # if only one worker answer can be found in constant time\\n        # (simulation would still work for k==1, this is just faster)\\n        if k==1:\\n            # Don\\'t count the last put by subtracting it\\n            return sum(time[0]) * n - time[0][3]\\n\\n        # start with everyone on left side of bridge, trying to cross to old factory\\n        # left and right are max heaps based on efficiency\\n        left = [(-(time[i][0] + time[i][2]), -i) for i in range(k)]\\n        heapify(left)\\n        right = []\\n        # picking and putting are min heaps based on the timestamp that the worker will finish picking up/putting down a box\\n        picking = []\\n        putting = []\\n\\n        total_time = 0\\n\\n        # Since we are not counting the time to put down the last box(es), don\\'t check if putting is non-empty\\n        # To adjust this so it counts the final put time, add \"or putting\" to while condition\\n        while n or right or picking:\\n            # try to have someone cross bridge, update total_time to the when they will finish crossing\\n            # add worker to corresponding picking/putting heap with the time they will be done at\\n            if right:\\n                efficiency, i = heappop(right)\\n                i *= -1\\n                total_time += time[i][2]\\n                heappush(putting, (total_time + time[i][3], i))\\n            elif left and n:\\n                efficiency, i = heappop(left)\\n                i *= -1\\n                total_time += time[i][0]\\n                heappush(picking, (total_time + time[i][1], i))\\n                n -= 1\\n            # If no one is trying to cross, update time to the first person to finish their current task\\n            else:\\n                total_time = min(putting[0][0] if putting else inf, picking[0][0] if picking else inf)\\n            # Now move anyone done picking or putting boxes back in corresponding heaps to cross the bridge\\n            while putting and putting[0][0] <= total_time:\\n                t, i = heappop(putting)\\n                heappush(left, (-(time[i][0] + time[i][2]), -i))\\n            while picking and picking[0][0] <= total_time:\\n                t, i = heappop(picking)\\n                heappush(right, (-(time[i][0] + time[i][2]), -i))\\n\\n        return total_time\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```ith```\n```time```\n```left```\n```right```\n```left```\n```picking```\n```putting```\n```left```\n```picking```\n```picking```\n```right```\n```right```\n```putting```\n```putting```\n```left```\n```left```\n```n```\n```picking```\n```right```\n```right```\n```putting```\n```left```\n```picking```\n```left```\n```right```\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        # left = new, right = old\\n        #            0            1        2            3\\n        # time[i] = [leftToRight, pickOld, rightToLeft, putNew]\\n\\n        # if only one worker answer can be found in constant time\\n        # (simulation would still work for k==1, this is just faster)\\n        if k==1:\\n            # Don\\'t count the last put by subtracting it\\n            return sum(time[0]) * n - time[0][3]\\n\\n        # start with everyone on left side of bridge, trying to cross to old factory\\n        # left and right are max heaps based on efficiency\\n        left = [(-(time[i][0] + time[i][2]), -i) for i in range(k)]\\n        heapify(left)\\n        right = []\\n        # picking and putting are min heaps based on the timestamp that the worker will finish picking up/putting down a box\\n        picking = []\\n        putting = []\\n\\n        total_time = 0\\n\\n        # Since we are not counting the time to put down the last box(es), don\\'t check if putting is non-empty\\n        # To adjust this so it counts the final put time, add \"or putting\" to while condition\\n        while n or right or picking:\\n            # try to have someone cross bridge, update total_time to the when they will finish crossing\\n            # add worker to corresponding picking/putting heap with the time they will be done at\\n            if right:\\n                efficiency, i = heappop(right)\\n                i *= -1\\n                total_time += time[i][2]\\n                heappush(putting, (total_time + time[i][3], i))\\n            elif left and n:\\n                efficiency, i = heappop(left)\\n                i *= -1\\n                total_time += time[i][0]\\n                heappush(picking, (total_time + time[i][1], i))\\n                n -= 1\\n            # If no one is trying to cross, update time to the first person to finish their current task\\n            else:\\n                total_time = min(putting[0][0] if putting else inf, picking[0][0] if picking else inf)\\n            # Now move anyone done picking or putting boxes back in corresponding heaps to cross the bridge\\n            while putting and putting[0][0] <= total_time:\\n                t, i = heappop(putting)\\n                heappush(left, (-(time[i][0] + time[i][2]), -i))\\n            while picking and picking[0][0] <= total_time:\\n                t, i = heappop(picking)\\n                heappush(right, (-(time[i][0] + time[i][2]), -i))\\n\\n        return total_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038837,
                "title": "java-solution-simulation-priorityqueue-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        // \\u6A21\\u62DF(+\\u65F6\\u95F4\\u8F74) + \\u4F18\\u5148\\u961F\\u5217 + \\u5BF9\\u8C61\\n        PriorityQueue<Worker> lNotReady = new PriorityQueue<>((a, b) -> a.readyTime == b.readyTime ? (a.efficiency == b.efficiency ? b.id - a.id : b.efficiency - a.efficiency) : a.readyTime - b.readyTime);\\n        PriorityQueue<Worker> rNotReady = new PriorityQueue<>((a, b) -> a.readyTime == b.readyTime ? (a.efficiency == b.efficiency ? b.id - a.id : b.efficiency - a.efficiency) : a.readyTime - b.readyTime);\\n        PriorityQueue<Worker> lWait = new PriorityQueue<>((a, b) -> a.efficiency == b.efficiency ? b.id - a.id : b.efficiency - a.efficiency);\\n        PriorityQueue<Worker> rWait = new PriorityQueue<>((a, b) -> a.efficiency == b.efficiency ? b.id - a.id : b.efficiency - a.efficiency);\\n        \\n        for (int i=0; i<k; i++) lWait.offer(new Worker(i, time[i][0] + time[i][2], 0)); // \\u4E00\\u5F00\\u59CB\\u90FD\\u5728\\u5DE6\\u5CB8\\n        \\n        int timestamp = 0;\\n        while (n > 0) {\\n            if (lWait.isEmpty() && rWait.isEmpty() && (lNotReady.isEmpty() || lNotReady.peek().readyTime > timestamp) && (rNotReady.isEmpty() || rNotReady.peek().readyTime > timestamp)) {\\n                timestamp = Math.min(lNotReady.isEmpty() ? Integer.MAX_VALUE : lNotReady.peek().readyTime, rNotReady.isEmpty() ? Integer.MAX_VALUE : rNotReady.peek().readyTime);\\n            }\\n            // \\u9700\\u8981\\u53E6\\u7528\\u4E00\\u4E2A\\u4F18\\u5148\\u961F\\u5217\\u627E\\u51FA\\u6240\\u6709 readyTime \\u5339\\u914D\\u7684\\uFF0C\\u7136\\u540E\\u53EA\\u53D6\\u6700\\u4F18\\u5148\\u7684\\u51FA\\u6765\\uFF08\\u6B64\\u65F6\\u4E0D\\u4E00\\u5B9A\\u662F readyTime \\u6700\\u9760\\u524D\\u7684\\uFF09\\n            while (!lNotReady.isEmpty() && lNotReady.peek().readyTime <= timestamp) lWait.offer(lNotReady.poll());\\n            Worker lNextWorker = lWait.poll();\\n            // \\u540C\\u4E0A\\uFF0C\\u53F3\\u5CB8\\n            while (!rNotReady.isEmpty() && rNotReady.peek().readyTime <= timestamp) rWait.offer(rNotReady.poll());\\n            Worker rNextWorker = rWait.poll();\\n\\n            if (rNextWorker == null) {\\n                timestamp += time[lNextWorker.id][0];\\n                rNotReady.offer(new Worker(lNextWorker.id, time[lNextWorker.id][0] + time[lNextWorker.id][2], timestamp + time[lNextWorker.id][1]));\\n                n--;\\n            } else {\\n                if (lNextWorker != null) lWait.offer(lNextWorker);\\n                timestamp += time[rNextWorker.id][2];\\n                lNotReady.offer(new Worker(rNextWorker.id, time[rNextWorker.id][0] + time[rNextWorker.id][2], timestamp + time[rNextWorker.id][3]));\\n            }\\n        }\\n\\n        while (!rNotReady.isEmpty() || !rWait.isEmpty()) { // \\u6700\\u540E\\u5269\\u7684\\u80AF\\u5B9A\\u662F\\u53F3\\u5CB8\\n            if (rWait.isEmpty() && rNotReady.peek().readyTime > timestamp) timestamp = rNotReady.peek().readyTime;\\n            // \\u9700\\u8981\\u53E6\\u7528\\u4E00\\u4E2A\\u4F18\\u5148\\u961F\\u5217\\u627E\\u51FA\\u6240\\u6709 readyTime \\u5339\\u914D\\u7684\\uFF0C\\u7136\\u540E\\u53EA\\u53D6\\u6700\\u4F18\\u5148\\u7684\\u51FA\\u6765\\n            while (!rNotReady.isEmpty() && rNotReady.peek().readyTime <= timestamp) rWait.offer(rNotReady.poll());\\n            Worker nextWorker = rWait.poll();\\n            timestamp += time[nextWorker.id][2];\\n        }\\n        \\n        return timestamp;\\n    }\\n    \\n    class Worker {\\n        int id;\\n        int efficiency;\\n        int readyTime;\\n        \\n        public Worker(int id, int efficiency, int readyTime) {\\n            this.id = id;\\n            this.efficiency = efficiency;\\n            this.readyTime = readyTime;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        // \\u6A21\\u62DF(+\\u65F6\\u95F4\\u8F74) + \\u4F18\\u5148\\u961F\\u5217 + \\u5BF9\\u8C61\\n        PriorityQueue<Worker> lNotReady = new PriorityQueue<>((a, b) -> a.readyTime == b.readyTime ? (a.efficiency == b.efficiency ? b.id - a.id : b.efficiency - a.efficiency) : a.readyTime - b.readyTime);\\n        PriorityQueue<Worker> rNotReady = new PriorityQueue<>((a, b) -> a.readyTime == b.readyTime ? (a.efficiency == b.efficiency ? b.id - a.id : b.efficiency - a.efficiency) : a.readyTime - b.readyTime);\\n        PriorityQueue<Worker> lWait = new PriorityQueue<>((a, b) -> a.efficiency == b.efficiency ? b.id - a.id : b.efficiency - a.efficiency);\\n        PriorityQueue<Worker> rWait = new PriorityQueue<>((a, b) -> a.efficiency == b.efficiency ? b.id - a.id : b.efficiency - a.efficiency);\\n        \\n        for (int i=0; i<k; i++) lWait.offer(new Worker(i, time[i][0] + time[i][2], 0)); // \\u4E00\\u5F00\\u59CB\\u90FD\\u5728\\u5DE6\\u5CB8\\n        \\n        int timestamp = 0;\\n        while (n > 0) {\\n            if (lWait.isEmpty() && rWait.isEmpty() && (lNotReady.isEmpty() || lNotReady.peek().readyTime > timestamp) && (rNotReady.isEmpty() || rNotReady.peek().readyTime > timestamp)) {\\n                timestamp = Math.min(lNotReady.isEmpty() ? Integer.MAX_VALUE : lNotReady.peek().readyTime, rNotReady.isEmpty() ? Integer.MAX_VALUE : rNotReady.peek().readyTime);\\n            }\\n            // \\u9700\\u8981\\u53E6\\u7528\\u4E00\\u4E2A\\u4F18\\u5148\\u961F\\u5217\\u627E\\u51FA\\u6240\\u6709 readyTime \\u5339\\u914D\\u7684\\uFF0C\\u7136\\u540E\\u53EA\\u53D6\\u6700\\u4F18\\u5148\\u7684\\u51FA\\u6765\\uFF08\\u6B64\\u65F6\\u4E0D\\u4E00\\u5B9A\\u662F readyTime \\u6700\\u9760\\u524D\\u7684\\uFF09\\n            while (!lNotReady.isEmpty() && lNotReady.peek().readyTime <= timestamp) lWait.offer(lNotReady.poll());\\n            Worker lNextWorker = lWait.poll();\\n            // \\u540C\\u4E0A\\uFF0C\\u53F3\\u5CB8\\n            while (!rNotReady.isEmpty() && rNotReady.peek().readyTime <= timestamp) rWait.offer(rNotReady.poll());\\n            Worker rNextWorker = rWait.poll();\\n\\n            if (rNextWorker == null) {\\n                timestamp += time[lNextWorker.id][0];\\n                rNotReady.offer(new Worker(lNextWorker.id, time[lNextWorker.id][0] + time[lNextWorker.id][2], timestamp + time[lNextWorker.id][1]));\\n                n--;\\n            } else {\\n                if (lNextWorker != null) lWait.offer(lNextWorker);\\n                timestamp += time[rNextWorker.id][2];\\n                lNotReady.offer(new Worker(rNextWorker.id, time[rNextWorker.id][0] + time[rNextWorker.id][2], timestamp + time[rNextWorker.id][3]));\\n            }\\n        }\\n\\n        while (!rNotReady.isEmpty() || !rWait.isEmpty()) { // \\u6700\\u540E\\u5269\\u7684\\u80AF\\u5B9A\\u662F\\u53F3\\u5CB8\\n            if (rWait.isEmpty() && rNotReady.peek().readyTime > timestamp) timestamp = rNotReady.peek().readyTime;\\n            // \\u9700\\u8981\\u53E6\\u7528\\u4E00\\u4E2A\\u4F18\\u5148\\u961F\\u5217\\u627E\\u51FA\\u6240\\u6709 readyTime \\u5339\\u914D\\u7684\\uFF0C\\u7136\\u540E\\u53EA\\u53D6\\u6700\\u4F18\\u5148\\u7684\\u51FA\\u6765\\n            while (!rNotReady.isEmpty() && rNotReady.peek().readyTime <= timestamp) rWait.offer(rNotReady.poll());\\n            Worker nextWorker = rWait.poll();\\n            timestamp += time[nextWorker.id][2];\\n        }\\n        \\n        return timestamp;\\n    }\\n    \\n    class Worker {\\n        int id;\\n        int efficiency;\\n        int readyTime;\\n        \\n        public Worker(int id, int efficiency, int readyTime) {\\n            this.id = id;\\n            this.efficiency = efficiency;\\n            this.readyTime = readyTime;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038816,
                "title": "php-two-heaps-763ms",
                "content": "```\\nclass Worker {\\n    public $startTime;\\n    public $endTime;\\n    public $idx;\\n    public $LR;\\n    public $pickOld;\\n    public $RL;\\n    public $putNew;\\n    function __construct($startTime, $endTime, $idx, $LR, $pickOld, $RL, $putNew) {\\n        $this->startTime = $startTime;\\n        $this->endTime = $endTime;\\n        $this->idx = $idx;\\n        $this->LR = $LR;\\n        $this->pickOld = $pickOld;\\n        $this->RL = $RL;\\n        $this->putNew = $putNew;\\n    }\\n    function show() {\\n        return $this->startTime.\" \".$this->endTime.\" \".$this->idx.\" \".$this->LR.\" \".$this->pickOld.\" \".$this->RL.\" \".$this->putNew;\\n    }\\n}\\n\\nclass MinHeap extends SplHeap {\\n    function compare($x, $y) {\\n        return $y->startTime - $x->startTime;\\n    }\\n}\\n\\nclass MaxHeap extends SplHeap { // PHP comparator is opposite to Java\\n    function compare($x, $y) {\\n        if ($x->endTime != $y->endTime) return $x->endTime - $y->endTime;\\n        if ($x->LR + $x->RL != $y->LR + $y->RL) return ($x->LR + $x->RL) - ($y->LR + $y->RL);\\n        if ($x->idx != $y->idx) return $x->idx - $y->idx;\\n    }\\n}\\n\\nclass Solution {\\n    function findCrossingTime($n, $k, $time) {\\n        $collect = new MinHeap(); // $collect = new SplMinHeap(); also works using built-in SplMinHeap\\n        $waiting = new MaxHeap();\\n        for ($i = 0; $i < sizeof($time); $i++) {\\n            $item = new Worker(0, 0, $i, $time[$i][0], $time[$i][1], $time[$i][2], $time[$i][3]);\\n            $collect->insert($item);\\n        }\\n        $clock = 0;\\n        $np = $n;\\n        while (1) {\\n           if ($waiting->count() == 0 && $collect->top()->startTime > $clock) $clock = $collect->top()->startTime;\\n           while ($collect->count() && $collect->top()->startTime <= $clock) $waiting->insert($collect->extract());\\n           $cur = $waiting->extract();\\n           if ($cur->endTime != 0 || $np != 0) {\\n             $nextClock = 0;\\n             if ($cur->endTime == 0) {\\n                $np--;\\n                $cur->endTime = 1;\\n                $nextClock = $clock + $cur->LR;\\n                $cur->startTime = $clock + $cur->LR + $cur->pickOld;\\n             } else {\\n                if (--$n == 0) return $clock + $cur->RL;\\n                $cur->endTime = 0;\\n                $nextClock = $clock + $cur->RL;\\n                $cur->startTime = $clock + $cur->RL + $cur->putNew;\\n             }\\n             $clock = $nextClock;\\n             $collect->insert($cur);\\n           }\\n        }\\n    }\\n}\\n```\\nJavascript version:\\nhttps://leetcode.com/problems/time-to-cross-a-bridge/solutions/3025339/javascript-two-heap-pq-357ms/",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Worker {\\n    public $startTime;\\n    public $endTime;\\n    public $idx;\\n    public $LR;\\n    public $pickOld;\\n    public $RL;\\n    public $putNew;\\n    function __construct($startTime, $endTime, $idx, $LR, $pickOld, $RL, $putNew) {\\n        $this->startTime = $startTime;\\n        $this->endTime = $endTime;\\n        $this->idx = $idx;\\n        $this->LR = $LR;\\n        $this->pickOld = $pickOld;\\n        $this->RL = $RL;\\n        $this->putNew = $putNew;\\n    }\\n    function show() {\\n        return $this->startTime.\" \".$this->endTime.\" \".$this->idx.\" \".$this->LR.\" \".$this->pickOld.\" \".$this->RL.\" \".$this->putNew;\\n    }\\n}\\n\\nclass MinHeap extends SplHeap {\\n    function compare($x, $y) {\\n        return $y->startTime - $x->startTime;\\n    }\\n}\\n\\nclass MaxHeap extends SplHeap { // PHP comparator is opposite to Java\\n    function compare($x, $y) {\\n        if ($x->endTime != $y->endTime) return $x->endTime - $y->endTime;\\n        if ($x->LR + $x->RL != $y->LR + $y->RL) return ($x->LR + $x->RL) - ($y->LR + $y->RL);\\n        if ($x->idx != $y->idx) return $x->idx - $y->idx;\\n    }\\n}\\n\\nclass Solution {\\n    function findCrossingTime($n, $k, $time) {\\n        $collect = new MinHeap(); // $collect = new SplMinHeap(); also works using built-in SplMinHeap\\n        $waiting = new MaxHeap();\\n        for ($i = 0; $i < sizeof($time); $i++) {\\n            $item = new Worker(0, 0, $i, $time[$i][0], $time[$i][1], $time[$i][2], $time[$i][3]);\\n            $collect->insert($item);\\n        }\\n        $clock = 0;\\n        $np = $n;\\n        while (1) {\\n           if ($waiting->count() == 0 && $collect->top()->startTime > $clock) $clock = $collect->top()->startTime;\\n           while ($collect->count() && $collect->top()->startTime <= $clock) $waiting->insert($collect->extract());\\n           $cur = $waiting->extract();\\n           if ($cur->endTime != 0 || $np != 0) {\\n             $nextClock = 0;\\n             if ($cur->endTime == 0) {\\n                $np--;\\n                $cur->endTime = 1;\\n                $nextClock = $clock + $cur->LR;\\n                $cur->startTime = $clock + $cur->LR + $cur->pickOld;\\n             } else {\\n                if (--$n == 0) return $clock + $cur->RL;\\n                $cur->endTime = 0;\\n                $nextClock = $clock + $cur->RL;\\n                $cur->startTime = $clock + $cur->RL + $cur->putNew;\\n             }\\n             $clock = $nextClock;\\n             $collect->insert($cur);\\n           }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035224,
                "title": "java-4-pq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int findCrossingTime(int n, int k, int[][] time) {\\n    int cur_time = 0, ans = 0;\\n    PriorityQueue<int[]> LR = new PriorityQueue<>(time.length, (int[] o1, int[] o2) -> o2[4] - o1[4] ); \\n    PriorityQueue<int[]> RL = new PriorityQueue<>(time.length, (int[] o1, int[] o2) -> o2[4] - o1[4] );   \\n    \\n    PriorityQueue<int[]> L = new PriorityQueue<>(time.length, (int[] o1, int[] o2) -> o1[5] - o2[5] ); \\n    PriorityQueue<int[]> R = new PriorityQueue<>(time.length, (int[] o1, int[] o2) -> o1[5] - o2[5] );   \\n\\n\\n    for(int i = 0; i != k; i++)\\n      LR.add( new int[]{\\n        time[i][0],\\n        time[i][1],\\n        time[i][2],\\n        time[i][3],\\n        ((time[i][0] + time[i][2])<<11) + i,\\n        0} );\\n   \\n    while(true){\\n      while(!L.isEmpty() && L.peek()[5] <= cur_time) LR.add(L.poll());\\n      while(!R.isEmpty() && R.peek()[5] <= cur_time) RL.add(R.poll());\\n\\n      if(!RL.isEmpty()){ \\n        int w[] = RL.poll();\\n        cur_time += w[2];\\n        w[5] = cur_time + w[3];\\n        L.add(w);\\n\\n        ans = cur_time;\\n      }else if(!LR.isEmpty() && n != 0){\\n        n--;\\n        int w[] = LR.poll(); \\n        cur_time += w[0];\\n        w[5] = cur_time + w[1];\\n        R.add(w);\\n      }else if(L.isEmpty()  && !R.isEmpty()){\\n          int w[] = R.poll(); \\n          cur_time = w[5];\\n          RL.add(w);\\n      }else if(R.isEmpty() && !L.isEmpty()){\\n          int w[] = L.poll();\\n          cur_time = w[5];\\n          LR.add(w);\\n      }else if(!R.isEmpty() && !L.isEmpty()) {\\n          cur_time = Math.min(L.peek()[5], R.peek()[5]);\\n      }else return ans; \\n    }  \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int findCrossingTime(int n, int k, int[][] time) {\\n    int cur_time = 0, ans = 0;\\n    PriorityQueue<int[]> LR = new PriorityQueue<>(time.length, (int[] o1, int[] o2) -> o2[4] - o1[4] ); \\n    PriorityQueue<int[]> RL = new PriorityQueue<>(time.length, (int[] o1, int[] o2) -> o2[4] - o1[4] );   \\n    \\n    PriorityQueue<int[]> L = new PriorityQueue<>(time.length, (int[] o1, int[] o2) -> o1[5] - o2[5] ); \\n    PriorityQueue<int[]> R = new PriorityQueue<>(time.length, (int[] o1, int[] o2) -> o1[5] - o2[5] );   \\n\\n\\n    for(int i = 0; i != k; i++)\\n      LR.add( new int[]{\\n        time[i][0],\\n        time[i][1],\\n        time[i][2],\\n        time[i][3],\\n        ((time[i][0] + time[i][2])<<11) + i,\\n        0} );\\n   \\n    while(true){\\n      while(!L.isEmpty() && L.peek()[5] <= cur_time) LR.add(L.poll());\\n      while(!R.isEmpty() && R.peek()[5] <= cur_time) RL.add(R.poll());\\n\\n      if(!RL.isEmpty()){ \\n        int w[] = RL.poll();\\n        cur_time += w[2];\\n        w[5] = cur_time + w[3];\\n        L.add(w);\\n\\n        ans = cur_time;\\n      }else if(!LR.isEmpty() && n != 0){\\n        n--;\\n        int w[] = LR.poll(); \\n        cur_time += w[0];\\n        w[5] = cur_time + w[1];\\n        R.add(w);\\n      }else if(L.isEmpty()  && !R.isEmpty()){\\n          int w[] = R.poll(); \\n          cur_time = w[5];\\n          RL.add(w);\\n      }else if(R.isEmpty() && !L.isEmpty()){\\n          int w[] = L.poll();\\n          cur_time = w[5];\\n          LR.add(w);\\n      }else if(!R.isEmpty() && !L.isEmpty()) {\\n          cur_time = Math.min(L.peek()[5], R.peek()[5]);\\n      }else return ans; \\n    }  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033207,
                "title": "python-priority-queue-simulation",
                "content": "# Intuition\\nThe only waiting in this problem happens where workers on the left/right side of the bridge. We can use priority queue to determine who should pass the bridge first by setting the key as (-leftToRight_i - rightToLeft_i, -idx_i) for each individual. That is, the worker with the highest leftToRight_i + rightToLeft go pass the bridge first and the tie-breaker is their idx number. \\n\\n# Approach\\nWe set up 4 priority queue, left, right, left_wait, right_wait.\\n\\nleft: all workers waiting on the left side of the bridge\\nright: all workers waiting on the right side of the bridge\\nleft_wait: all workers putting new item into the left bank and haven\\'t return to the left side of the bridge yet\\nright_wait: all workers picking old item from the right bank and haven\\'t return to the right side of the bridge yet\\n\\nthe way we represent workers in these 4 pq:\\nlet \\nrank1 = -leftToRight_i - rightToLeft_i\\nrank2 = -idx_i\\ntime_left = time when worker finish putting new item into the left bank and return to the left side of the bridge\\ntime time when worker finish picking old item from the right bank and return to the right side of the bridge\\n\\nleft: [rank1, rank2]\\nright\\uFF1A[rank1, rank2]\\nleft_wait: [time_left, rank1, rank2]\\nright_wait: [time_right, rank1, rank2]\\n\\nThen we can keep track of the current time and pop worker out of the left_wait, right_wait to left and right if they finish putting/picking item to/from the bank and return to the side of the bridge.\\n\\nMeanwhile, we follow the rule specified in this problem: right queue has higher priority than the left.\\n\\n# Complexity\\n- Time complexity:\\nWe have at most n items, so we will pop/push at most n times to each queue. The size of each queue will not exceed k at any time since k is the total number of workers we have. \\nO(nlogk)\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, times: List[List[int]]) -> int:\\n        left = [[-(leftToRight + rightToLeft), -idx]\\n                for idx, (leftToRight, _, rightToLeft, _) in enumerate(times)]\\n        heapq.heapify(left)\\n        right = []\\n\\n        num_moved = 0\\n        cur_time = 0\\n\\n        left_wait, right_wait = [], []\\n\\n        def update():\\n            while right_wait and cur_time >= right_wait[0][0]:\\n                heapq.heappush(right, heapq.heappop(right_wait)[1:])\\n            while left_wait and cur_time >= left_wait[0][0]:\\n                heapq.heappush(left, heapq.heappop(left_wait)[1:])\\n\\n        while right or right_wait or num_moved < n:\\n\\n            if num_moved == n:\\n                left, left_wait = [], []\\n\\n            if not left and not right:\\n                if not right_wait or (left_wait and left_wait[0][0] < right_wait[0][0]):\\n                    time, rank1, rank2 = heapq.heappop(left_wait)\\n                    heapq.heappush(left, [rank1, rank2])\\n                else:\\n                    time, rank1, rank2 = heapq.heappop(right_wait)\\n                    heapq.heappush(right, [rank1, rank2])\\n                cur_time = time\\n\\n            while right:\\n                rank1, rank2 = heapq.heappop(right)\\n                leftToRight, pickOld, rightToLeft, putNew = times[-rank2]\\n                if num_moved < n:\\n                    heapq.heappush(left_wait, [cur_time + rightToLeft + putNew, rank1, rank2])\\n                cur_time += rightToLeft\\n                update()\\n\\n            if not left:\\n                continue\\n            rank1, rank2 = heapq.heappop(left)\\n            leftToRight, pickOld, rightToLeft, putNew = times[-rank2]\\n            heapq.heappush(right_wait, [cur_time + leftToRight + pickOld, rank1, rank2])\\n            cur_time += leftToRight\\n            update()\\n            num_moved += 1\\n\\n        return cur_time\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, times: List[List[int]]) -> int:\\n        left = [[-(leftToRight + rightToLeft), -idx]\\n                for idx, (leftToRight, _, rightToLeft, _) in enumerate(times)]\\n        heapq.heapify(left)\\n        right = []\\n\\n        num_moved = 0\\n        cur_time = 0\\n\\n        left_wait, right_wait = [], []\\n\\n        def update():\\n            while right_wait and cur_time >= right_wait[0][0]:\\n                heapq.heappush(right, heapq.heappop(right_wait)[1:])\\n            while left_wait and cur_time >= left_wait[0][0]:\\n                heapq.heappush(left, heapq.heappop(left_wait)[1:])\\n\\n        while right or right_wait or num_moved < n:\\n\\n            if num_moved == n:\\n                left, left_wait = [], []\\n\\n            if not left and not right:\\n                if not right_wait or (left_wait and left_wait[0][0] < right_wait[0][0]):\\n                    time, rank1, rank2 = heapq.heappop(left_wait)\\n                    heapq.heappush(left, [rank1, rank2])\\n                else:\\n                    time, rank1, rank2 = heapq.heappop(right_wait)\\n                    heapq.heappush(right, [rank1, rank2])\\n                cur_time = time\\n\\n            while right:\\n                rank1, rank2 = heapq.heappop(right)\\n                leftToRight, pickOld, rightToLeft, putNew = times[-rank2]\\n                if num_moved < n:\\n                    heapq.heappush(left_wait, [cur_time + rightToLeft + putNew, rank1, rank2])\\n                cur_time += rightToLeft\\n                update()\\n\\n            if not left:\\n                continue\\n            rank1, rank2 = heapq.heappop(left)\\n            leftToRight, pickOld, rightToLeft, putNew = times[-rank2]\\n            heapq.heappush(right_wait, [cur_time + leftToRight + pickOld, rank1, rank2])\\n            cur_time += leftToRight\\n            update()\\n            num_moved += 1\\n\\n        return cur_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032478,
                "title": "comparator-macros-binary-heaps-recursive-let-simulation",
                "content": "# Approach\\nWe\\'ll just simulate the rules with help of `data/heap` mutable data structure.\\nThe most challenging step here is definition of suitable `<=` implementation for the heaps.\\nWe define a macro-helper for that\\n`compare-on` is macro that should be called in form \\n```\\n(compare-on (f1 lt1 eq1) (f2 lt2 eq2) ... final)\\n```\\nIt constructs a binary lambda function for comparing two values according to some chain of measures and corresponding comparison operations. For each triple `(fi lti eqi)` it gets results of `fi` from both arguments, compare them using `lti` and if comparison is unsuccesfull, trying to check for equivalence using `eqi` and delegating to the next triple in the chain.\\nWhen all the functions are exausted, it means that two arguments are equivalent according to all the provided measures, the `final` value is returned.\\n\\nThe rest is impemented pretty straightforward, we keep track of boxes at the `old`  and `new` area as well as current `time`. We have three heaps: `left`, `right` for each of the river sides and `tasks` to account workers during they picking or putting phase. \\nWhenever a worker crosses the bridge we put him at the `tasks` que. Whenever some task is over, we put the worker in the corresponding river-side queue.\\n`unroll` procedure finishes tooks all items from the `tasks` that should be finished to the current time\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n\\\\cdot log(n))$$\\n- Space complexity:\\n$$O(n\\\\cdot log(n))$$\\n\\n# Code\\n```\\n(require data/heap)\\n\\n(define-syntax compare-on-body \\n    (syntax-rules ()\\n        [(compare-on-body _ _ res) res]\\n        [(compare-on-body x y (f lt eq) fs ...) \\n            (let ((fx (f x)) (fy (f y))) \\n                (or (lt fx fy) (and (eq fx fy) (compare-on-body x y fs ...))))]\\n    ))\\n\\n(define-syntax compare-on \\n    (syntax-rules () \\n        ((compare-on fs ...) (lambda (x y) (compare-on-body x y fs ...)))))\\n\\n(struct worker (idx l2r pick-old r2l put-new) #:transparent)\\n(struct task (time side worker) #:transparent)\\n\\n(define (worker-delay worker) (+ (worker-l2r worker) (worker-r2l worker)))\\n \\n(define worker-eff>=? (compare-on (worker-delay > =) (worker-idx > =) true))\\n(define task-time<=? (compare-on (task-time < =) true))\\n\\n(define (heap-nonempty? h) (< 0 (heap-count h)))\\n(define (heap-take-min! h) (let ((x (heap-min h))) (heap-remove-min! h) x))\\n\\n(define (find-crossing-time n _ time)\\n    (define workers (for/vector ((i (in-naturals)) (t time)) (apply worker (cons i t))))\\n    (define left (vector->heap worker-eff>=? workers))\\n    (define right (make-heap worker-eff>=?))\\n    (define tasks (make-heap task-time<=?))\\n    (define (unroll t) \\n        (when (and (heap-nonempty? tasks) (>= t (task-time (heap-min tasks))))\\n            (match (heap-take-min! tasks)\\n                ((task _ \\'left w) (heap-add! left w))\\n                ((task _ \\'right w) (heap-add! right w)))\\n            (unroll t)\\n        )) \\n    (let go ((new 0) (old n) (time 0) )\\n        (unroll time)\\n        (cond \\n            ((heap-nonempty? right) \\n                (define w (heap-take-min! right))\\n                (define t (+ time (worker-r2l w)))\\n                (heap-add! tasks (task (+ t (worker-put-new w)) \\'left w))\\n                (go (add1 new) old t))\\n            ((and (> old 0) (heap-nonempty? left) )\\n                (define w (heap-take-min! left))\\n                (define t (+ time (worker-l2r w)))\\n                (heap-add! tasks (task (+ t (worker-pick-old w)) \\'right w))\\n                (go new (sub1 old) t))\\n            ((= new n) time)\\n            (else (go new old (task-time (heap-min tasks)))))))\\n\\n```",
                "solutionTags": [
                    "Racket",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\n(compare-on (f1 lt1 eq1) (f2 lt2 eq2) ... final)\\n```\n```\\n(require data/heap)\\n\\n(define-syntax compare-on-body \\n    (syntax-rules ()\\n        [(compare-on-body _ _ res) res]\\n        [(compare-on-body x y (f lt eq) fs ...) \\n            (let ((fx (f x)) (fy (f y))) \\n                (or (lt fx fy) (and (eq fx fy) (compare-on-body x y fs ...))))]\\n    ))\\n\\n(define-syntax compare-on \\n    (syntax-rules () \\n        ((compare-on fs ...) (lambda (x y) (compare-on-body x y fs ...)))))\\n\\n(struct worker (idx l2r pick-old r2l put-new) #:transparent)\\n(struct task (time side worker) #:transparent)\\n\\n(define (worker-delay worker) (+ (worker-l2r worker) (worker-r2l worker)))\\n \\n(define worker-eff>=? (compare-on (worker-delay > =) (worker-idx > =) true))\\n(define task-time<=? (compare-on (task-time < =) true))\\n\\n(define (heap-nonempty? h) (< 0 (heap-count h)))\\n(define (heap-take-min! h) (let ((x (heap-min h))) (heap-remove-min! h) x))\\n\\n(define (find-crossing-time n _ time)\\n    (define workers (for/vector ((i (in-naturals)) (t time)) (apply worker (cons i t))))\\n    (define left (vector->heap worker-eff>=? workers))\\n    (define right (make-heap worker-eff>=?))\\n    (define tasks (make-heap task-time<=?))\\n    (define (unroll t) \\n        (when (and (heap-nonempty? tasks) (>= t (task-time (heap-min tasks))))\\n            (match (heap-take-min! tasks)\\n                ((task _ \\'left w) (heap-add! left w))\\n                ((task _ \\'right w) (heap-add! right w)))\\n            (unroll t)\\n        )) \\n    (let go ((new 0) (old n) (time 0) )\\n        (unroll time)\\n        (cond \\n            ((heap-nonempty? right) \\n                (define w (heap-take-min! right))\\n                (define t (+ time (worker-r2l w)))\\n                (heap-add! tasks (task (+ t (worker-put-new w)) \\'left w))\\n                (go (add1 new) old t))\\n            ((and (> old 0) (heap-nonempty? left) )\\n                (define w (heap-take-min! left))\\n                (define t (+ time (worker-l2r w)))\\n                (heap-add! tasks (task (+ t (worker-pick-old w)) \\'right w))\\n                (go new (sub1 old) t))\\n            ((= new n) time)\\n            (else (go new old (task-time (heap-min tasks)))))))\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3032036,
                "title": "object-oriented-c-simulation",
                "content": "# Approach\\nI found it helpful to explicitly model workers by defining a `Worker` class to encapsulate their state. `Worker` objects only have one method to mutate state: `SetTask()`. `SetTask` handles calculating the completion time of the new task, so we don\\'t constantly need to be looking up completion times by task and worker ID.\\n\\nBecause the workers are ~32 bytes each, I didn\\'t want to copy them each time I removed or added them to a `std::priority_queue`. I originally tried to use `std::priority_queue<std::unique_ptr<Worker>>` to solve this, but C++ doesn\\'t give you a way to extract a `std::unique_ptr` from a collection - you need to make a copy into a new object. So instead I created a `std::vector` to store the worker objects, and made the priority queue objects store non-owning pointers.\\n\\nThe comparators were also a bit tricky, because they need to be written in the reverse of the problem description. A `std::priority_queue` will always return the *max value* based on the comparator ordering, but in both queues here we want the min.\\n\\n# Code\\n```c++\\nenum class Task {\\n  kLeftToRight,\\n  kPickOld,\\n  kRightToLeft,\\n  kPutNew,\\n  kWaitLeftToRight,\\n  kWaitRightToLeft\\n};\\n\\nclass Worker {\\npublic:\\n  Worker(int id, std::vector<int>& task_times) : \\n    id_(id), \\n    task_(Task::kWaitLeftToRight), \\n    task_completion_time_(0) {\\n    for (int i = 0; i < 4; i++) {\\n      task_times_[i] = task_times[i];\\n    }\\n    total_bridge_crossing_cost_ = task_times_[static_cast<int>(Task::kLeftToRight)] \\n      + task_times_[static_cast<int>(Task::kRightToLeft)];\\n  }\\n\\n  void SetTask(Task t, int current_time) {\\n    task_ = t;\\n    if (t == Task::kWaitLeftToRight || t== Task::kWaitRightToLeft) {\\n      task_completion_time_ = 0;\\n    } else {\\n      task_completion_time_ = current_time + task_times_[static_cast<int>(t)];\\n    }\\n  }\\n\\n  int id() {\\n    return id_;\\n  }\\n\\n  Task task() {\\n    return task_;\\n  }\\n\\n  int task_completion_time() {\\n    return task_completion_time_;\\n  }\\n\\n  int total_bridge_crossing_cost() {\\n    return total_bridge_crossing_cost_;\\n  }\\n\\nprivate:\\n  int id_;\\n  Task task_;\\n  int task_completion_time_;\\n  int task_times_[4];\\n  int total_bridge_crossing_cost_;\\n};\\n\\nstruct BridgeQueueComparator {\\n  // Returns true iff lhs worker has lower priority on the bridge than rhs.\\n  bool operator()(Worker* lhs, Worker* rhs) {\\n    if (lhs->task() == Task::kWaitLeftToRight && rhs->task() != Task::kWaitLeftToRight) {\\n      return true;\\n    }\\n    if (rhs->task() == Task::kWaitLeftToRight && lhs->task() != Task::kWaitLeftToRight) {\\n      return false;\\n    }\\n    if (lhs->total_bridge_crossing_cost() < rhs->total_bridge_crossing_cost()) {\\n      return true;\\n    }\\n    if (rhs->total_bridge_crossing_cost() < lhs->total_bridge_crossing_cost()) {\\n      return false;\\n    }\\n    return lhs->id() < rhs->id();\\n  }\\n};\\n\\nstruct TaskCompletionTimeComparator {\\n  // Returns true iff lhs worker will complete their current task after rhs worker.\\n  bool operator()(Worker* lhs, Worker* rhs) {\\n    return lhs->task_completion_time() > rhs->task_completion_time();\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n      std::vector<Worker> workers;\\n      workers.reserve(time.size());\\n      for (int i = 0; i < time.size(); i++) {\\n        workers.push_back(Worker(i, time[i]));\\n      }\\n\\n      // priority_queues hold non-owning pointers to Worker objects.\\n      std::priority_queue<Worker*, std::vector<Worker*>, BridgeQueueComparator> bridge_queue;\\n      std::priority_queue<Worker*, std::vector<Worker*>, TaskCompletionTimeComparator> busy_workers;\\n      // It would be slightly better to initialize the heap in a constructor (O(n)), \\n      // rather than repeated calls to push() (O(nlogn)), but it\\'s complicated to do \\n      // so without creating a copy.\\n      for (int i = 0; i < time.size(); i++) {\\n        bridge_queue.push(&workers[i]);\\n      }\\n\\n      int t = 0;\\n      int unclaimed_boxes = n;\\n      int boxes_on_left = 0;\\n      bool bridge_busy = false;\\n      while (true) {\\n        // Advance all workers that are done with their current task.\\n        while (!busy_workers.empty() && busy_workers.top()->task_completion_time() == t) {\\n          Worker* w = busy_workers.top();\\n          busy_workers.pop();\\n          switch (w->task()) {\\n            case Task::kLeftToRight:\\n              bridge_busy = false;\\n              w->SetTask(Task::kPickOld, t);\\n              busy_workers.push(w);\\n              break;\\n            case Task::kPickOld:\\n              w->SetTask(Task::kWaitRightToLeft, t);\\n              bridge_queue.push(w);\\n              break;\\n            case Task::kRightToLeft:\\n              bridge_busy = false;\\n              boxes_on_left++;\\n              // Exit early when the last box makes it to the left bank.\\n              if (boxes_on_left == n) {\\n                goto worker_loop_end;\\n              }\\n              w->SetTask(Task::kPutNew, t);\\n              busy_workers.push(w);\\n              break;\\n            case Task::kPutNew:\\n              w->SetTask(Task::kWaitLeftToRight, t);\\n              bridge_queue.push(w);\\n            default:\\n              // Should never happen.\\n              break;\\n          }\\n        }\\n        // Let the next worker onto the bridge.\\n        if (!bridge_busy && !bridge_queue.empty()) {\\n          Worker* w = bridge_queue.top();\\n          if (w->task() == Task::kWaitRightToLeft) {\\n            w->SetTask(Task::kRightToLeft, t);\\n            bridge_busy = true;\\n            bridge_queue.pop();\\n            busy_workers.push(w);\\n          } else if (unclaimed_boxes > 0 && w->task() == Task::kWaitLeftToRight) {\\n            w->SetTask(Task::kLeftToRight, t);\\n            unclaimed_boxes--;\\n            bridge_busy = true;\\n            bridge_queue.pop();\\n            busy_workers.push(w);\\n          }\\n        }\\n        t = busy_workers.top()->task_completion_time();\\n      }\\n    worker_loop_end:\\n      return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nenum class Task {\\n  kLeftToRight,\\n  kPickOld,\\n  kRightToLeft,\\n  kPutNew,\\n  kWaitLeftToRight,\\n  kWaitRightToLeft\\n};\\n\\nclass Worker {\\npublic:\\n  Worker(int id, std::vector<int>& task_times) : \\n    id_(id), \\n    task_(Task::kWaitLeftToRight), \\n    task_completion_time_(0) {\\n    for (int i = 0; i < 4; i++) {\\n      task_times_[i] = task_times[i];\\n    }\\n    total_bridge_crossing_cost_ = task_times_[static_cast<int>(Task::kLeftToRight)] \\n      + task_times_[static_cast<int>(Task::kRightToLeft)];\\n  }\\n\\n  void SetTask(Task t, int current_time) {\\n    task_ = t;\\n    if (t == Task::kWaitLeftToRight || t== Task::kWaitRightToLeft) {\\n      task_completion_time_ = 0;\\n    } else {\\n      task_completion_time_ = current_time + task_times_[static_cast<int>(t)];\\n    }\\n  }\\n\\n  int id() {\\n    return id_;\\n  }\\n\\n  Task task() {\\n    return task_;\\n  }\\n\\n  int task_completion_time() {\\n    return task_completion_time_;\\n  }\\n\\n  int total_bridge_crossing_cost() {\\n    return total_bridge_crossing_cost_;\\n  }\\n\\nprivate:\\n  int id_;\\n  Task task_;\\n  int task_completion_time_;\\n  int task_times_[4];\\n  int total_bridge_crossing_cost_;\\n};\\n\\nstruct BridgeQueueComparator {\\n  // Returns true iff lhs worker has lower priority on the bridge than rhs.\\n  bool operator()(Worker* lhs, Worker* rhs) {\\n    if (lhs->task() == Task::kWaitLeftToRight && rhs->task() != Task::kWaitLeftToRight) {\\n      return true;\\n    }\\n    if (rhs->task() == Task::kWaitLeftToRight && lhs->task() != Task::kWaitLeftToRight) {\\n      return false;\\n    }\\n    if (lhs->total_bridge_crossing_cost() < rhs->total_bridge_crossing_cost()) {\\n      return true;\\n    }\\n    if (rhs->total_bridge_crossing_cost() < lhs->total_bridge_crossing_cost()) {\\n      return false;\\n    }\\n    return lhs->id() < rhs->id();\\n  }\\n};\\n\\nstruct TaskCompletionTimeComparator {\\n  // Returns true iff lhs worker will complete their current task after rhs worker.\\n  bool operator()(Worker* lhs, Worker* rhs) {\\n    return lhs->task_completion_time() > rhs->task_completion_time();\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n      std::vector<Worker> workers;\\n      workers.reserve(time.size());\\n      for (int i = 0; i < time.size(); i++) {\\n        workers.push_back(Worker(i, time[i]));\\n      }\\n\\n      // priority_queues hold non-owning pointers to Worker objects.\\n      std::priority_queue<Worker*, std::vector<Worker*>, BridgeQueueComparator> bridge_queue;\\n      std::priority_queue<Worker*, std::vector<Worker*>, TaskCompletionTimeComparator> busy_workers;\\n      // It would be slightly better to initialize the heap in a constructor (O(n)), \\n      // rather than repeated calls to push() (O(nlogn)), but it\\'s complicated to do \\n      // so without creating a copy.\\n      for (int i = 0; i < time.size(); i++) {\\n        bridge_queue.push(&workers[i]);\\n      }\\n\\n      int t = 0;\\n      int unclaimed_boxes = n;\\n      int boxes_on_left = 0;\\n      bool bridge_busy = false;\\n      while (true) {\\n        // Advance all workers that are done with their current task.\\n        while (!busy_workers.empty() && busy_workers.top()->task_completion_time() == t) {\\n          Worker* w = busy_workers.top();\\n          busy_workers.pop();\\n          switch (w->task()) {\\n            case Task::kLeftToRight:\\n              bridge_busy = false;\\n              w->SetTask(Task::kPickOld, t);\\n              busy_workers.push(w);\\n              break;\\n            case Task::kPickOld:\\n              w->SetTask(Task::kWaitRightToLeft, t);\\n              bridge_queue.push(w);\\n              break;\\n            case Task::kRightToLeft:\\n              bridge_busy = false;\\n              boxes_on_left++;\\n              // Exit early when the last box makes it to the left bank.\\n              if (boxes_on_left == n) {\\n                goto worker_loop_end;\\n              }\\n              w->SetTask(Task::kPutNew, t);\\n              busy_workers.push(w);\\n              break;\\n            case Task::kPutNew:\\n              w->SetTask(Task::kWaitLeftToRight, t);\\n              bridge_queue.push(w);\\n            default:\\n              // Should never happen.\\n              break;\\n          }\\n        }\\n        // Let the next worker onto the bridge.\\n        if (!bridge_busy && !bridge_queue.empty()) {\\n          Worker* w = bridge_queue.top();\\n          if (w->task() == Task::kWaitRightToLeft) {\\n            w->SetTask(Task::kRightToLeft, t);\\n            bridge_busy = true;\\n            bridge_queue.pop();\\n            busy_workers.push(w);\\n          } else if (unclaimed_boxes > 0 && w->task() == Task::kWaitLeftToRight) {\\n            w->SetTask(Task::kLeftToRight, t);\\n            unclaimed_boxes--;\\n            bridge_busy = true;\\n            bridge_queue.pop();\\n            busy_workers.push(w);\\n          }\\n        }\\n        t = busy_workers.top()->task_completion_time();\\n      }\\n    worker_loop_end:\\n      return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029423,
                "title": "accepted-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int get(int index, vector<vector<int>>& time) {\\n        return (time[index][0] + time[index][2]) * 100000 + index;\\n    }\\n    int ret(int val) {\\n        return val%100000;\\n    }\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<int>leftwait, rightwait;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        map<int,vector<pair<int,int>>>m;\\n        for(int i = 0; i < k; i++) {\\n            leftwait.push(get(i, time));\\n        }\\n        pq.push(0);\\n        bool sac = true;\\n        set<int>s;\\n        int ans = 0;\\n        int avail = n;\\n        while(!pq.empty() ) {\\n            int curr = pq.top();\\n            pq.pop();\\n            if(s.count(curr)) continue;\\n            s.insert(curr);\\n            // cout << curr<<endl;\\n            for(auto it:m[curr]) {\\n                if(it.first == 0) {\\n                    // cout << \"reached right side\" <<\" \" << it.second<<endl;\\n                    sac = true;\\n                    int op = 2;\\n                    \\n                    int t = curr + time[it.second][1];\\n                    m[t].push_back({op,it.second});\\n                    pq.push(t);\\n                }\\n                if(it.first == 1) {\\n                    sac = true;\\n                    // cout << \"reached left side\" <<\" \" << it.second<<endl;\\n                    int op = 3;\\n                    int t = curr + time[it.second][3];\\n                    m[t].push_back({op,it.second});\\n                    pq.push(t);\\n                    ans = max(ans, curr);\\n                }\\n                if(it.first == 2) {\\n                    \\n                    // cout << \"picked up the block from right\" <<\" \" << it.second<<endl;\\n                    rightwait.push(get(it.second,time));\\n                }\\n                if(it.first == 3) {\\n                    n--;\\n                    // cout << \"dropped the box\" <<\" \"<< it.second<<endl;\\n                    if(n == 0) {\\n                        return ans;\\n                    }\\n                    leftwait.push(get(it.second,time));\\n                }\\n                \\n            }\\n            if(sac) {\\n                    if(rightwait.size() > 0) {\\n                        int index = ret(rightwait.top());\\n                        rightwait.pop();\\n                       // cout << \"going right to left\" << index << endl;\\n                        int op = 1;\\n                        \\n                        sac = false; \\n                        int t = curr + time[index][2];\\n                        m[t].push_back({op,index});\\n                        pq.push(t);\\n                        \\n                        \\n                    }\\n                    else if(leftwait.size() > 0) {\\n                        \\n                        int index = ret(leftwait.top());\\n                       // cout << \"going left to right\" << index << endl;\\n                        leftwait.pop();\\n                        if(avail) {\\n                            avail--;\\n                            sac = false;\\n                            int op = 0;\\n\\n                            int t = curr + time[index][0];\\n                            m[t].push_back({op,index});\\n                            pq.push(t);\\n                        }\\n                    }\\n                }\\n                \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int get(int index, vector<vector<int>>& time) {\\n        return (time[index][0] + time[index][2]) * 100000 + index;\\n    }\\n    int ret(int val) {\\n        return val%100000;\\n    }\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<int>leftwait, rightwait;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        map<int,vector<pair<int,int>>>m;\\n        for(int i = 0; i < k; i++) {\\n            leftwait.push(get(i, time));\\n        }\\n        pq.push(0);\\n        bool sac = true;\\n        set<int>s;\\n        int ans = 0;\\n        int avail = n;\\n        while(!pq.empty() ) {\\n            int curr = pq.top();\\n            pq.pop();\\n            if(s.count(curr)) continue;\\n            s.insert(curr);\\n            // cout << curr<<endl;\\n            for(auto it:m[curr]) {\\n                if(it.first == 0) {\\n                    // cout << \"reached right side\" <<\" \" << it.second<<endl;\\n                    sac = true;\\n                    int op = 2;\\n                    \\n                    int t = curr + time[it.second][1];\\n                    m[t].push_back({op,it.second});\\n                    pq.push(t);\\n                }\\n                if(it.first == 1) {\\n                    sac = true;\\n                    // cout << \"reached left side\" <<\" \" << it.second<<endl;\\n                    int op = 3;\\n                    int t = curr + time[it.second][3];\\n                    m[t].push_back({op,it.second});\\n                    pq.push(t);\\n                    ans = max(ans, curr);\\n                }\\n                if(it.first == 2) {\\n                    \\n                    // cout << \"picked up the block from right\" <<\" \" << it.second<<endl;\\n                    rightwait.push(get(it.second,time));\\n                }\\n                if(it.first == 3) {\\n                    n--;\\n                    // cout << \"dropped the box\" <<\" \"<< it.second<<endl;\\n                    if(n == 0) {\\n                        return ans;\\n                    }\\n                    leftwait.push(get(it.second,time));\\n                }\\n                \\n            }\\n            if(sac) {\\n                    if(rightwait.size() > 0) {\\n                        int index = ret(rightwait.top());\\n                        rightwait.pop();\\n                       // cout << \"going right to left\" << index << endl;\\n                        int op = 1;\\n                        \\n                        sac = false; \\n                        int t = curr + time[index][2];\\n                        m[t].push_back({op,index});\\n                        pq.push(t);\\n                        \\n                        \\n                    }\\n                    else if(leftwait.size() > 0) {\\n                        \\n                        int index = ret(leftwait.top());\\n                       // cout << \"going left to right\" << index << endl;\\n                        leftwait.pop();\\n                        if(avail) {\\n                            avail--;\\n                            sac = false;\\n                            int op = 0;\\n\\n                            int t = curr + time[index][0];\\n                            m[t].push_back({op,index});\\n                            pq.push(t);\\n                        }\\n                    }\\n                }\\n                \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3028963,
                "title": "using-priorityqueue-in-java",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPriorityQueue in java\\n\\n\\n# Code\\n```\\nclass Solution {\\n  // worker at rightside always moves first\\n  // two heap to maintain the waiting list on river bank\\n  // two heap to maintain the worker list that is puting boxes.\\n  \\n  // total time max: 4e3*e4 = 4e7\\n  private static final boolean debug = false;\\n  \\n  public int findCrossingTime(int n, int k, int[][] time) {\\n    PriorityQueue<Integer> lBank = new PriorityQueue<>((a, b) -> {\\n      int[] ta = time[a], tb = time[b];\\n      int ca = ta[0] + ta[2], cb = tb[0] + tb[2];\\n      if (ca == cb) return b - a; // larger index cross first\\n      return cb - ca; // larger cross time cross first.\\n    });\\n    PriorityQueue<Integer> rBank = new PriorityQueue<>((a, b) -> {\\n      int[] ta = time[a], tb = time[b];\\n      int ca = ta[0] + ta[2], cb = tb[0] + tb[2];\\n      if (ca == cb) return b - a; // larger index cross first\\n      return cb - ca; // larger cross time cross first.\\n    });\\n    \\n    \\n    // 0 -> time of the worker will be waiting to cross the bridge, 1 ->idx\\n    PriorityQueue<int[]> lWorker = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    PriorityQueue<int[]> rWorker = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    \\n    // initally, all at left bank\\n    for (int i = 0; i < k; i++) lBank.add(i);\\n    \\n    int curTime = 0;\\n    while (n > 0) {\\n      // process worker.\\n      while (!lWorker.isEmpty() && lWorker.peek()[0] <= curTime) lBank.add(lWorker.poll()[1]);\\n      while (!rWorker.isEmpty() && rWorker.peek()[0] <= curTime) rBank.add(rWorker.poll()[1]);\\n      \\n      int worker = -1;\\n      if (debug) System.out.println(curTime + \" \" + lBank);\\n      if (debug) System.out.println(curTime + \" \" + rBank);\\n      if (!rBank.isEmpty()) {\\n        // right side can pass. A box will be put.\\n        worker = rBank.poll();\\n        int t[] = time[worker];\\n        lWorker.add(new int[]{curTime + t[2] + t[3], worker});\\n        curTime += t[2]; // right to left.\\n        \\n        n--;\\n      } else if (!lBank.isEmpty() && (n > rBank.size() + rWorker.size())) {\\n        // left side can pass.\\n        // left side only pass when there are more boxes.\\n        worker = lBank.poll();\\n        int t[] = time[worker];\\n        rWorker.add(new int[]{curTime + t[0] + t[1], worker});\\n        curTime += t[0]; // left to right.\\n      } else if (n == rBank.size() + rWorker.size()) {\\n        curTime = rWorker.peek()[0];\\n      } else {\\n        // if still empty, advance time.\\n        int nxt;\\n        if (rWorker.isEmpty()) nxt = lWorker.peek()[0];\\n        else if (lWorker.isEmpty()) nxt = rWorker.peek()[0];\\n        else nxt = Math.min(lWorker.peek()[0], rWorker.peek()[0]);\\n        \\n        curTime = nxt;\\n      }\\n      \\n      if (debug) System.out.println(curTime + \", \" + worker + \" n: \" + n);\\n    }\\n    \\n    return curTime;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  // worker at rightside always moves first\\n  // two heap to maintain the waiting list on river bank\\n  // two heap to maintain the worker list that is puting boxes.\\n  \\n  // total time max: 4e3*e4 = 4e7\\n  private static final boolean debug = false;\\n  \\n  public int findCrossingTime(int n, int k, int[][] time) {\\n    PriorityQueue<Integer> lBank = new PriorityQueue<>((a, b) -> {\\n      int[] ta = time[a], tb = time[b];\\n      int ca = ta[0] + ta[2], cb = tb[0] + tb[2];\\n      if (ca == cb) return b - a; // larger index cross first\\n      return cb - ca; // larger cross time cross first.\\n    });\\n    PriorityQueue<Integer> rBank = new PriorityQueue<>((a, b) -> {\\n      int[] ta = time[a], tb = time[b];\\n      int ca = ta[0] + ta[2], cb = tb[0] + tb[2];\\n      if (ca == cb) return b - a; // larger index cross first\\n      return cb - ca; // larger cross time cross first.\\n    });\\n    \\n    \\n    // 0 -> time of the worker will be waiting to cross the bridge, 1 ->idx\\n    PriorityQueue<int[]> lWorker = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    PriorityQueue<int[]> rWorker = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    \\n    // initally, all at left bank\\n    for (int i = 0; i < k; i++) lBank.add(i);\\n    \\n    int curTime = 0;\\n    while (n > 0) {\\n      // process worker.\\n      while (!lWorker.isEmpty() && lWorker.peek()[0] <= curTime) lBank.add(lWorker.poll()[1]);\\n      while (!rWorker.isEmpty() && rWorker.peek()[0] <= curTime) rBank.add(rWorker.poll()[1]);\\n      \\n      int worker = -1;\\n      if (debug) System.out.println(curTime + \" \" + lBank);\\n      if (debug) System.out.println(curTime + \" \" + rBank);\\n      if (!rBank.isEmpty()) {\\n        // right side can pass. A box will be put.\\n        worker = rBank.poll();\\n        int t[] = time[worker];\\n        lWorker.add(new int[]{curTime + t[2] + t[3], worker});\\n        curTime += t[2]; // right to left.\\n        \\n        n--;\\n      } else if (!lBank.isEmpty() && (n > rBank.size() + rWorker.size())) {\\n        // left side can pass.\\n        // left side only pass when there are more boxes.\\n        worker = lBank.poll();\\n        int t[] = time[worker];\\n        rWorker.add(new int[]{curTime + t[0] + t[1], worker});\\n        curTime += t[0]; // left to right.\\n      } else if (n == rBank.size() + rWorker.size()) {\\n        curTime = rWorker.peek()[0];\\n      } else {\\n        // if still empty, advance time.\\n        int nxt;\\n        if (rWorker.isEmpty()) nxt = lWorker.peek()[0];\\n        else if (lWorker.isEmpty()) nxt = rWorker.peek()[0];\\n        else nxt = Math.min(lWorker.peek()[0], rWorker.peek()[0]);\\n        \\n        curTime = nxt;\\n      }\\n      \\n      if (debug) System.out.println(curTime + \", \" + worker + \" n: \" + n);\\n    }\\n    \\n    return curTime;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026128,
                "title": "python-four-pqs-simple-code",
                "content": "We maintain global (current) time. Using four PQs, we process proper events.\\n# Code\\n```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        leftbank = [(-(lr+rl), -i) for i, (lr, po, rl, pn) in enumerate(time)]\\n        heapify(leftbank)\\n        rightbank, lefthouse, righthouse = [], [], []\\n        target, curtime, cnt = n, 0, 0\\n        while cnt < target:\\n            while lefthouse and lefthouse[0][0] <= curtime:\\n                t, i = heappop(lefthouse)\\n                lr, _, rl, pn = time[i]\\n                heappush(leftbank, (-(lr+rl), -i))\\n            while righthouse and righthouse[0][0] <= curtime:\\n                _, i = heappop(righthouse)\\n                lr, _, rl, _ = time[i]\\n                heappush(rightbank, (-(lr+rl), -i))\\n            if rightbank:\\n                _, i = heappop(rightbank)\\n                i = -i\\n                curtime += time[i][2] \\n                heappush(lefthouse, (curtime+time[i][3], i))\\n                cnt += 1\\n            else:\\n                if not leftbank or not n:\\n                    curtime = min(lefthouse[0][0] if lefthouse else float(\\'inf\\'), righthouse[0][0] if righthouse else float(\\'inf\\'))\\n                    continue\\n                if n:\\n                    _, i = heappop(leftbank)\\n                    i = -i\\n                    curtime += time[i][0]\\n                    n -= 1\\n                    heappush(righthouse, (curtime + time[i][1], i))\\n        return curtime\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        leftbank = [(-(lr+rl), -i) for i, (lr, po, rl, pn) in enumerate(time)]\\n        heapify(leftbank)\\n        rightbank, lefthouse, righthouse = [], [], []\\n        target, curtime, cnt = n, 0, 0\\n        while cnt < target:\\n            while lefthouse and lefthouse[0][0] <= curtime:\\n                t, i = heappop(lefthouse)\\n                lr, _, rl, pn = time[i]\\n                heappush(leftbank, (-(lr+rl), -i))\\n            while righthouse and righthouse[0][0] <= curtime:\\n                _, i = heappop(righthouse)\\n                lr, _, rl, _ = time[i]\\n                heappush(rightbank, (-(lr+rl), -i))\\n            if rightbank:\\n                _, i = heappop(rightbank)\\n                i = -i\\n                curtime += time[i][2] \\n                heappush(lefthouse, (curtime+time[i][3], i))\\n                cnt += 1\\n            else:\\n                if not leftbank or not n:\\n                    curtime = min(lefthouse[0][0] if lefthouse else float(\\'inf\\'), righthouse[0][0] if righthouse else float(\\'inf\\'))\\n                    continue\\n                if n:\\n                    _, i = heappop(leftbank)\\n                    i = -i\\n                    curtime += time[i][0]\\n                    n -= 1\\n                    heappush(righthouse, (curtime + time[i][1], i))\\n        return curtime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025339,
                "title": "javascript-two-heap-pq-357ms",
                "content": "```\\nconst findCrossingTime = (n, k, time) => {\\n    let collect = new MinPriorityQueue({ compare: (x, y) => x.startTime - y.startTime });\\n    let waiting = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x.endTime != y.endTime) return y.endTime - x.endTime;\\n            if (x.LR + x.RL != y.LR + y.RL) return (y.LR + y.RL) - (x.LR + x.RL);\\n            if (x.idx != y.idx) return y.idx - x.idx;\\n        }\\n    });\\n    for (let i = 0; i < time.length; i++) {\\n        let item = { startTime: 0, endTime: 0, idx: i, LR: time[i][0], pickOld: time[i][1], RL: time[i][2], putNew: time[i][3] };\\n        collect.enqueue(item)\\n    }\\n    let clock = 0, np = n;\\n    while (1) {\\n        if (waiting.size() == 0 && collect.front().startTime > clock) clock = collect.front().startTime;\\n        while (collect.size() && collect.front().startTime <= clock) waiting.enqueue(collect.dequeue());\\n        let cur = waiting.dequeue();\\n        if (cur.endTime != 0 || np != 0) {\\n            let nextClock = 0;\\n            if (cur.endTime == 0) {\\n                np--;\\n                cur.endTime = 1;\\n                nextClock = clock + cur.LR;\\n                cur.startTime = clock + cur.LR + cur.pickOld;\\n            } else {\\n                if (--n == 0) return clock + cur.RL;\\n                cur.endTime = 0;\\n                nextClock = clock + cur.RL;\\n                cur.startTime = clock + cur.RL + cur.putNew;\\n            }\\n            clock = nextClock;\\n            collect.enqueue(cur);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst findCrossingTime = (n, k, time) => {\\n    let collect = new MinPriorityQueue({ compare: (x, y) => x.startTime - y.startTime });\\n    let waiting = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x.endTime != y.endTime) return y.endTime - x.endTime;\\n            if (x.LR + x.RL != y.LR + y.RL) return (y.LR + y.RL) - (x.LR + x.RL);\\n            if (x.idx != y.idx) return y.idx - x.idx;\\n        }\\n    });\\n    for (let i = 0; i < time.length; i++) {\\n        let item = { startTime: 0, endTime: 0, idx: i, LR: time[i][0], pickOld: time[i][1], RL: time[i][2], putNew: time[i][3] };\\n        collect.enqueue(item)\\n    }\\n    let clock = 0, np = n;\\n    while (1) {\\n        if (waiting.size() == 0 && collect.front().startTime > clock) clock = collect.front().startTime;\\n        while (collect.size() && collect.front().startTime <= clock) waiting.enqueue(collect.dequeue());\\n        let cur = waiting.dequeue();\\n        if (cur.endTime != 0 || np != 0) {\\n            let nextClock = 0;\\n            if (cur.endTime == 0) {\\n                np--;\\n                cur.endTime = 1;\\n                nextClock = clock + cur.LR;\\n                cur.startTime = clock + cur.LR + cur.pickOld;\\n            } else {\\n                if (--n == 0) return clock + cur.RL;\\n                cur.endTime = 0;\\n                nextClock = clock + cur.RL;\\n                cur.startTime = clock + cur.RL + cur.putNew;\\n            }\\n            clock = nextClock;\\n            collect.enqueue(cur);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3023466,
                "title": "java-4-priorityqueues-solution-with-explanation",
                "content": "# Code\\n```\\nclass Solution{\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        // Create 4 priorityqueues\\n        PriorityQueue<Worker> leftShore = new PriorityQueue<>();\\n        PriorityQueue<Worker> rightShore = new PriorityQueue<>();\\n        PriorityQueue<Event> newWarehouse = new PriorityQueue<>();\\n        PriorityQueue<Event> oldWarehouse = new PriorityQueue<>();\\n\\n        // Create Worker object for each worker\\n        Worker[] workers = new Worker[k];\\n        for (int i = 0; i < k; ++i) {\\n            workers[i] = new Worker(i, time[i][0], time[i][2], time[i][1], time[i][3]);\\n        }\\n        // put all workers into the left shore waiting area\\n        for (Worker worker : workers) {\\n            leftShore.offer(worker);\\n        }\\n        // initialize the current time\\n        // initialize remaining items at old and new ware hourses\\n        int currTime = 0, oldRemain = n, newExist = 0;\\n\\n        while (newExist < n) {\\n            \\n            // Put all workers who already finished their work into the waiting area on their own side\\n            while (!oldWarehouse.isEmpty() && oldWarehouse.peek().time <= currTime) {\\n                rightShore.offer(oldWarehouse.poll().worker);\\n            }\\n            while (!newWarehouse.isEmpty() && newWarehouse.peek().time <= currTime) {\\n                leftShore.offer(newWarehouse.poll().worker);\\n            }\\n\\n            // Let the least efficient worker cross the bridge if there is at least one worker waiting at the two shores\\n            // (Note that, we need to consider right shore first based on the problem\\'s description, then left shore)\\n            // Otherwise, advancing the currTime to be the time of the workers with the smallest finish time at two warehouses\\n            if (!rightShore.isEmpty()) {\\n                Worker currWorker = rightShore.poll();\\n                currTime += currWorker.rightToLeft;\\n                newExist += 1;\\n                newWarehouse.offer(new Event(currTime + currWorker.putNew, currWorker));\\n            } else if (!leftShore.isEmpty() && oldRemain > 0) {\\n                Worker currWorker = leftShore.poll();\\n                currTime += currWorker.leftToRight;\\n                oldRemain -= 1;\\n                oldWarehouse.offer(new Event(currTime + currWorker.pickOld, currWorker));\\n            } else {\\n                int rightLatest = oldWarehouse.isEmpty() ? Integer.MAX_VALUE : oldWarehouse.peek().time;\\n                int leftLatest = newWarehouse.isEmpty() ? Integer.MAX_VALUE : newWarehouse.peek().time;\\n                currTime = Math.min(leftLatest, rightLatest);\\n            }\\n        }\\n        return currTime;\\n    }\\n\\n    class Worker implements Comparable<Worker> {\\n        int index;\\n        int leftToRight, rightToLeft, pickOld, putNew;\\n        Worker(int i, int ltr, int rtl, int po, int pn) {\\n            index = i;\\n            leftToRight = ltr;\\n            rightToLeft = rtl;\\n            pickOld = po;\\n            putNew = pn;\\n        }\\n        @Override\\n        public int compareTo(Worker another) {\\n            int total = this.leftToRight + this.rightToLeft;\\n            int anotherTotal = another.leftToRight + another.rightToLeft;\\n            if (total == anotherTotal) {\\n                return another.index - this.index;\\n            } else {\\n                return anotherTotal - total;\\n            }\\n        }\\n    }\\n    \\n    class Event implements Comparable<Event> {\\n        int time;\\n        Worker worker;\\n        Event(int time, Worker worker) {\\n            this.time = time;\\n            this.worker = worker;\\n        }\\n        @Override\\n        public int compareTo(Event another) {\\n            return this.time - another.time;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution{\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        // Create 4 priorityqueues\\n        PriorityQueue<Worker> leftShore = new PriorityQueue<>();\\n        PriorityQueue<Worker> rightShore = new PriorityQueue<>();\\n        PriorityQueue<Event> newWarehouse = new PriorityQueue<>();\\n        PriorityQueue<Event> oldWarehouse = new PriorityQueue<>();\\n\\n        // Create Worker object for each worker\\n        Worker[] workers = new Worker[k];\\n        for (int i = 0; i < k; ++i) {\\n            workers[i] = new Worker(i, time[i][0], time[i][2], time[i][1], time[i][3]);\\n        }\\n        // put all workers into the left shore waiting area\\n        for (Worker worker : workers) {\\n            leftShore.offer(worker);\\n        }\\n        // initialize the current time\\n        // initialize remaining items at old and new ware hourses\\n        int currTime = 0, oldRemain = n, newExist = 0;\\n\\n        while (newExist < n) {\\n            \\n            // Put all workers who already finished their work into the waiting area on their own side\\n            while (!oldWarehouse.isEmpty() && oldWarehouse.peek().time <= currTime) {\\n                rightShore.offer(oldWarehouse.poll().worker);\\n            }\\n            while (!newWarehouse.isEmpty() && newWarehouse.peek().time <= currTime) {\\n                leftShore.offer(newWarehouse.poll().worker);\\n            }\\n\\n            // Let the least efficient worker cross the bridge if there is at least one worker waiting at the two shores\\n            // (Note that, we need to consider right shore first based on the problem\\'s description, then left shore)\\n            // Otherwise, advancing the currTime to be the time of the workers with the smallest finish time at two warehouses\\n            if (!rightShore.isEmpty()) {\\n                Worker currWorker = rightShore.poll();\\n                currTime += currWorker.rightToLeft;\\n                newExist += 1;\\n                newWarehouse.offer(new Event(currTime + currWorker.putNew, currWorker));\\n            } else if (!leftShore.isEmpty() && oldRemain > 0) {\\n                Worker currWorker = leftShore.poll();\\n                currTime += currWorker.leftToRight;\\n                oldRemain -= 1;\\n                oldWarehouse.offer(new Event(currTime + currWorker.pickOld, currWorker));\\n            } else {\\n                int rightLatest = oldWarehouse.isEmpty() ? Integer.MAX_VALUE : oldWarehouse.peek().time;\\n                int leftLatest = newWarehouse.isEmpty() ? Integer.MAX_VALUE : newWarehouse.peek().time;\\n                currTime = Math.min(leftLatest, rightLatest);\\n            }\\n        }\\n        return currTime;\\n    }\\n\\n    class Worker implements Comparable<Worker> {\\n        int index;\\n        int leftToRight, rightToLeft, pickOld, putNew;\\n        Worker(int i, int ltr, int rtl, int po, int pn) {\\n            index = i;\\n            leftToRight = ltr;\\n            rightToLeft = rtl;\\n            pickOld = po;\\n            putNew = pn;\\n        }\\n        @Override\\n        public int compareTo(Worker another) {\\n            int total = this.leftToRight + this.rightToLeft;\\n            int anotherTotal = another.leftToRight + another.rightToLeft;\\n            if (total == anotherTotal) {\\n                return another.index - this.index;\\n            } else {\\n                return anotherTotal - total;\\n            }\\n        }\\n    }\\n    \\n    class Event implements Comparable<Event> {\\n        int time;\\n        Worker worker;\\n        Event(int time, Worker worker) {\\n            this.time = time;\\n            this.worker = worker;\\n        }\\n        @Override\\n        public int compareTo(Event another) {\\n            return this.time - another.time;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022057,
                "title": "java-easy-to-understand-oop",
                "content": "# Approach\\nWe use 3 `PriorityQueues` (heaps) to simulate the process. The most important of them is the time queue. Two others just manage crossing the bridge. In theory, it is possible to combine them into a single one, but that will be less efficient.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * \\\\log k + k)$$\\n\\n- Space complexity:\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\tprivate class Worker {\\n\\t\\tfinal int index;\\n\\t\\tfinal int[] workTime; // { leftToRight, pickOld, rightToLeft, putNew }\\n\\t\\tfinal int bridgeCrossTime; // leftToRight + rightToLeft\\n\\t\\tint position; // 0 - 3, see the switch on w.arrive() below for the meaning of values\\n\\t\\tint arriveTime;\\n\\n\\t\\tWorker(int index, int[] workTime) {\\n\\t\\t\\tthis.index = index;\\n\\t\\t\\tthis.workTime = workTime;\\n\\t\\t\\tbridgeCrossTime = workTime[0] + workTime[2];\\n\\t\\t}\\n\\n\\t\\tvoid move() {\\n\\t\\t\\tarriveTime = currentTime + workTime[position];\\n\\t\\t\\ttimeQueue.add(this);\\n\\t\\t}\\n\\n\\t\\tint arrive() { // returns the position where the worker has just arrived\\n\\t\\t\\treturn position = (position + 1) % 4; // the movement is circular\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static final Comparator<Worker> BY_ARRIVE_TIME = (w1, w2) ->\\n\\t\\tw1.arriveTime - w2.arriveTime;\\n\\tprivate static final Comparator<Worker> LESS_EFFICIENT_FIRST = (w1, w2) -> {\\n\\t\\tint d = w2.bridgeCrossTime - w1.bridgeCrossTime;\\n\\t\\treturn d != 0 ? d : w2.index - w1.index;\\n\\t};\\n\\n\\tprivate final Queue<Worker> timeQueue = new PriorityQueue<>(BY_ARRIVE_TIME);\\n\\tprivate Queue<Worker> leftBankQueue;\\n\\tprivate final Queue<Worker> rightBankQueue = new PriorityQueue<>(LESS_EFFICIENT_FIRST);\\n\\tprivate int currentTime;\\n\\tprivate int bridgeFreeTime;\\n\\tprivate boolean boxesRemaining; // true if at least one box remains at the old warehouse\\n\\n\\tprivate void manageBridgeCrossing() {\\n\\t\\tif (bridgeFreeTime <= currentTime) { // the bridge is free\\n\\t\\t\\tWorker w = rightBankQueue.poll();\\n\\t\\t\\tif (w == null && boxesRemaining)\\n\\t\\t\\t\\tw = leftBankQueue.poll();\\n\\t\\t\\tif (w != null) {\\n\\t\\t\\t\\tw.move();\\n\\t\\t\\t\\tbridgeFreeTime = w.arriveTime;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int findCrossingTime(int n, int k, int[][] time) {\\n\\t\\tleftBankQueue = new PriorityQueue<>(k, LESS_EFFICIENT_FIRST);\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tleftBankQueue.add(new Worker(i, time[i]));\\n\\t\\tcurrentTime = 0;\\n\\t\\tbridgeFreeTime = 0;\\n\\t\\tboxesRemaining = true;\\n\\t\\tmanageBridgeCrossing(); // move the first worker across the bridge to start the process\\n\\t\\tdo {\\n\\t\\t\\tWorker w = timeQueue.peek();\\n\\t\\t\\tcurrentTime = w.arriveTime;\\n\\t\\t\\t// handle all events occurring at currentTime\\n\\t\\t\\tdo {\\n\\t\\t\\t\\ttimeQueue.poll(); // remove w from queue\\n\\t\\t\\t\\tswitch (w.arrive()) { // on new w.position\\n\\t\\t\\t\\t\\tcase 0: // left bank\\n\\t\\t\\t\\t\\t\\tleftBankQueue.add(w); // wait to cross the bridge\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 1: // old warehouse\\n\\t\\t\\t\\t\\t\\tboxesRemaining = --n > 0; // pick a box\\n\\t\\t\\t\\t\\t\\tw.move(); // move immediately\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 2: // right bank\\n\\t\\t\\t\\t\\t\\trightBankQueue.add(w); // wait to cross the bridge\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 3: // new warehouse\\n\\t\\t\\t\\t\\t\\tif (boxesRemaining)\\n\\t\\t\\t\\t\\t\\t\\tw.move(); // move immediately\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tw = timeQueue.peek();\\n\\t\\t\\t} while (w != null && w.arriveTime == currentTime);\\n\\t\\t\\tmanageBridgeCrossing();\\n\\t\\t} while (!timeQueue.isEmpty()); // until the process stops\\n\\t\\treturn currentTime;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n\\tprivate class Worker {\\n\\t\\tfinal int index;\\n\\t\\tfinal int[] workTime; // { leftToRight, pickOld, rightToLeft, putNew }\\n\\t\\tfinal int bridgeCrossTime; // leftToRight + rightToLeft\\n\\t\\tint position; // 0 - 3, see the switch on w.arrive() below for the meaning of values\\n\\t\\tint arriveTime;\\n\\n\\t\\tWorker(int index, int[] workTime) {\\n\\t\\t\\tthis.index = index;\\n\\t\\t\\tthis.workTime = workTime;\\n\\t\\t\\tbridgeCrossTime = workTime[0] + workTime[2];\\n\\t\\t}\\n\\n\\t\\tvoid move() {\\n\\t\\t\\tarriveTime = currentTime + workTime[position];\\n\\t\\t\\ttimeQueue.add(this);\\n\\t\\t}\\n\\n\\t\\tint arrive() { // returns the position where the worker has just arrived\\n\\t\\t\\treturn position = (position + 1) % 4; // the movement is circular\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static final Comparator<Worker> BY_ARRIVE_TIME = (w1, w2) ->\\n\\t\\tw1.arriveTime - w2.arriveTime;\\n\\tprivate static final Comparator<Worker> LESS_EFFICIENT_FIRST = (w1, w2) -> {\\n\\t\\tint d = w2.bridgeCrossTime - w1.bridgeCrossTime;\\n\\t\\treturn d != 0 ? d : w2.index - w1.index;\\n\\t};\\n\\n\\tprivate final Queue<Worker> timeQueue = new PriorityQueue<>(BY_ARRIVE_TIME);\\n\\tprivate Queue<Worker> leftBankQueue;\\n\\tprivate final Queue<Worker> rightBankQueue = new PriorityQueue<>(LESS_EFFICIENT_FIRST);\\n\\tprivate int currentTime;\\n\\tprivate int bridgeFreeTime;\\n\\tprivate boolean boxesRemaining; // true if at least one box remains at the old warehouse\\n\\n\\tprivate void manageBridgeCrossing() {\\n\\t\\tif (bridgeFreeTime <= currentTime) { // the bridge is free\\n\\t\\t\\tWorker w = rightBankQueue.poll();\\n\\t\\t\\tif (w == null && boxesRemaining)\\n\\t\\t\\t\\tw = leftBankQueue.poll();\\n\\t\\t\\tif (w != null) {\\n\\t\\t\\t\\tw.move();\\n\\t\\t\\t\\tbridgeFreeTime = w.arriveTime;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int findCrossingTime(int n, int k, int[][] time) {\\n\\t\\tleftBankQueue = new PriorityQueue<>(k, LESS_EFFICIENT_FIRST);\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tleftBankQueue.add(new Worker(i, time[i]));\\n\\t\\tcurrentTime = 0;\\n\\t\\tbridgeFreeTime = 0;\\n\\t\\tboxesRemaining = true;\\n\\t\\tmanageBridgeCrossing(); // move the first worker across the bridge to start the process\\n\\t\\tdo {\\n\\t\\t\\tWorker w = timeQueue.peek();\\n\\t\\t\\tcurrentTime = w.arriveTime;\\n\\t\\t\\t// handle all events occurring at currentTime\\n\\t\\t\\tdo {\\n\\t\\t\\t\\ttimeQueue.poll(); // remove w from queue\\n\\t\\t\\t\\tswitch (w.arrive()) { // on new w.position\\n\\t\\t\\t\\t\\tcase 0: // left bank\\n\\t\\t\\t\\t\\t\\tleftBankQueue.add(w); // wait to cross the bridge\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 1: // old warehouse\\n\\t\\t\\t\\t\\t\\tboxesRemaining = --n > 0; // pick a box\\n\\t\\t\\t\\t\\t\\tw.move(); // move immediately\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 2: // right bank\\n\\t\\t\\t\\t\\t\\trightBankQueue.add(w); // wait to cross the bridge\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase 3: // new warehouse\\n\\t\\t\\t\\t\\t\\tif (boxesRemaining)\\n\\t\\t\\t\\t\\t\\t\\tw.move(); // move immediately\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tw = timeQueue.peek();\\n\\t\\t\\t} while (w != null && w.arriveTime == currentTime);\\n\\t\\t\\tmanageBridgeCrossing();\\n\\t\\t} while (!timeQueue.isEmpty()); // until the process stops\\n\\t\\treturn currentTime;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021792,
                "title": "c-simulation-with-heap",
                "content": "# Code\\n```\\nclass Solution {\\n    struct Worker{\\n        Worker(int i, int t) : id(i), time(t) {}\\n        int id, time;\\n    };\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        auto cmp_priority = [&](const Worker& w1, const Worker& w2){\\n            const int p1 = time[w1.id][0] + time[w1.id][2],\\n                      p2 = time[w2.id][0] + time[w2.id][2];\\n            return p1 < p2 || (p1 == p2 && w1.id < w2.id);\\n        };\\n        // right/left bridge waiting queue\\n        priority_queue<Worker, vector<Worker>, decltype(cmp_priority)> lb_pq(cmp_priority);\\n        priority_queue<Worker, vector<Worker>, decltype(cmp_priority)> rb_pq(cmp_priority);\\n        for(int i = 0; i < k; ++i) lb_pq.push(Worker(i, 0));\\n        // right/left warehouse wokers.\\n        auto cmp_time = [&](const Worker& w1, const Worker& w2){ return w1.time > w2.time;};     \\n        priority_queue<Worker, vector<Worker>, decltype(cmp_time)> lw_pq(cmp_time);\\n        priority_queue<Worker, vector<Worker>, decltype(cmp_time)> rw_pq(cmp_time);\\n    \\n        int cur_time = 0, num_picked = 0, num_sent = 0;\\n        while(num_picked < n){\\n            // Add worker that has finished picking/putting to bridge queues.\\n            while(!rw_pq.empty() && rw_pq.top().time <= cur_time){\\n                auto w = rw_pq.top();\\n                rw_pq.pop();\\n                rb_pq.push(w);\\n            }\\n            while(!lw_pq.empty() && lw_pq.top().time <= cur_time){\\n                auto w = lw_pq.top();\\n                lw_pq.pop();\\n                lb_pq.push(w);\\n            }\\n            \\n            if(!rb_pq.empty()){\\n                // Right to left.\\n                auto w = rb_pq.top();\\n                rb_pq.pop();\\n                num_picked++;\\n                cur_time += time[w.id][2];\\n                w.time = cur_time + time[w.id][3];\\n                lw_pq.push(w);\\n            }else if(!lb_pq.empty() && num_sent < n){\\n                // Left to right.\\n                auto w = lb_pq.top();\\n                lb_pq.pop();\\n                ++num_sent;\\n                cur_time += time[w.id][0];\\n                w.time = cur_time + time[w.id][1];\\n                rw_pq.push(w);\\n            }else{\\n                // Advance time.\\n                const int lt = num_sent == n || lw_pq.empty() ? numeric_limits<int>::max() : lw_pq.top().time;\\n                const int rt = rw_pq.empty() ? numeric_limits<int>::max() : rw_pq.top().time;\\n                cur_time = min(lt, rt);\\n            }\\n        }\\n\\n        return cur_time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    struct Worker{\\n        Worker(int i, int t) : id(i), time(t) {}\\n        int id, time;\\n    };\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        auto cmp_priority = [&](const Worker& w1, const Worker& w2){\\n            const int p1 = time[w1.id][0] + time[w1.id][2],\\n                      p2 = time[w2.id][0] + time[w2.id][2];\\n            return p1 < p2 || (p1 == p2 && w1.id < w2.id);\\n        };\\n        // right/left bridge waiting queue\\n        priority_queue<Worker, vector<Worker>, decltype(cmp_priority)> lb_pq(cmp_priority);\\n        priority_queue<Worker, vector<Worker>, decltype(cmp_priority)> rb_pq(cmp_priority);\\n        for(int i = 0; i < k; ++i) lb_pq.push(Worker(i, 0));\\n        // right/left warehouse wokers.\\n        auto cmp_time = [&](const Worker& w1, const Worker& w2){ return w1.time > w2.time;};     \\n        priority_queue<Worker, vector<Worker>, decltype(cmp_time)> lw_pq(cmp_time);\\n        priority_queue<Worker, vector<Worker>, decltype(cmp_time)> rw_pq(cmp_time);\\n    \\n        int cur_time = 0, num_picked = 0, num_sent = 0;\\n        while(num_picked < n){\\n            // Add worker that has finished picking/putting to bridge queues.\\n            while(!rw_pq.empty() && rw_pq.top().time <= cur_time){\\n                auto w = rw_pq.top();\\n                rw_pq.pop();\\n                rb_pq.push(w);\\n            }\\n            while(!lw_pq.empty() && lw_pq.top().time <= cur_time){\\n                auto w = lw_pq.top();\\n                lw_pq.pop();\\n                lb_pq.push(w);\\n            }\\n            \\n            if(!rb_pq.empty()){\\n                // Right to left.\\n                auto w = rb_pq.top();\\n                rb_pq.pop();\\n                num_picked++;\\n                cur_time += time[w.id][2];\\n                w.time = cur_time + time[w.id][3];\\n                lw_pq.push(w);\\n            }else if(!lb_pq.empty() && num_sent < n){\\n                // Left to right.\\n                auto w = lb_pq.top();\\n                lb_pq.pop();\\n                ++num_sent;\\n                cur_time += time[w.id][0];\\n                w.time = cur_time + time[w.id][1];\\n                rw_pq.push(w);\\n            }else{\\n                // Advance time.\\n                const int lt = num_sent == n || lw_pq.empty() ? numeric_limits<int>::max() : lw_pq.top().time;\\n                const int rt = rw_pq.empty() ? numeric_limits<int>::max() : rw_pq.top().time;\\n                cur_time = min(lt, rt);\\n            }\\n        }\\n\\n        return cur_time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021739,
                "title": "faster-than-90-less-memory-than-81",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a complicated simulation problem. One has no choice but to do the simulation in minute detail.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe main thing is using heaps (or ordered lists) for keeping track of river crossings.\\nIn fact, one absolutely needs two heaps:\\n* one to keep track of who is busy and who is free to attempt a river crossing\\n* another to keep track of the river crossing priority.\\n\\nThe two heaps use different sorting criteria.\\n\\nThere are many minute details regarding timekeeping or, for example, when the last box was picked up in the old warehouse, so that workers on the left bank should attempt no more crossings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        tmp=list(enumerate(time))\\n        tmp.sort(key=lambda it:(it[1][0]+it[1][2], it[0]))\\n        dct={it[0]:i for i, it in enumerate(tmp)}\\n        \\n        busy=[[0, dct[i], time[i][0], time[i][1], time[i][2], time[i][3], 0] for i in range(k)]\\n        heapq.heapify(busy) # key=lambda x:x[0] represents the time when this worker will be free to attempt to cross the river again\\n        waiting=[] # key=lambda x:(-x[6], -x[1])), where x[6] represents the river side, left or right, and x[1] is the crossing priority\\n\\n        t=0\\n        left=n\\n\\n        while n:\\n            if not waiting and t<busy[0][0]:\\n                t=busy[0][0]\\n            while busy and t>=busy[0][0]:\\n                tmp=heapq.heappop(busy)\\n                heapq.heappush(waiting, (-tmp[6], -tmp[1], tmp))\\n            _, _, w1=heapq.heappop(waiting)\\n            if w1[6]:\\n                t+=w1[4]\\n                w1[0]=t+w1[5]\\n                w1[6]^=1\\n                n-=1\\n                heapq.heappush(busy, w1)\\n            elif left:\\n                    t+=+w1[2]\\n                    w1[0]=t+w1[3]\\n                    w1[6]^=1\\n                    left-=1\\n                    heapq.heappush(busy, w1)\\n\\n        return t\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        tmp=list(enumerate(time))\\n        tmp.sort(key=lambda it:(it[1][0]+it[1][2], it[0]))\\n        dct={it[0]:i for i, it in enumerate(tmp)}\\n        \\n        busy=[[0, dct[i], time[i][0], time[i][1], time[i][2], time[i][3], 0] for i in range(k)]\\n        heapq.heapify(busy) # key=lambda x:x[0] represents the time when this worker will be free to attempt to cross the river again\\n        waiting=[] # key=lambda x:(-x[6], -x[1])), where x[6] represents the river side, left or right, and x[1] is the crossing priority\\n\\n        t=0\\n        left=n\\n\\n        while n:\\n            if not waiting and t<busy[0][0]:\\n                t=busy[0][0]\\n            while busy and t>=busy[0][0]:\\n                tmp=heapq.heappop(busy)\\n                heapq.heappush(waiting, (-tmp[6], -tmp[1], tmp))\\n            _, _, w1=heapq.heappop(waiting)\\n            if w1[6]:\\n                t+=w1[4]\\n                w1[0]=t+w1[5]\\n                w1[6]^=1\\n                n-=1\\n                heapq.heappush(busy, w1)\\n            elif left:\\n                    t+=+w1[2]\\n                    w1[0]=t+w1[3]\\n                    w1[6]^=1\\n                    left-=1\\n                    heapq.heappush(busy, w1)\\n\\n        return t\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021599,
                "title": "c-simulate-time-event-using-customized-priority-queue",
                "content": "# Intuition\\nsimulate using 5 priority queue\\n\\n# Approach\\n1. use 1 priority queue to save all interesting time spot\\n2. use 1 priority queue to save all workers picking up on right side\\n3. use 1 priority queue to save all workers ready in pick up and wait to cross the bridge (from right to left)\\n4. use 1 priority queue to save all workers putting down on left side\\n5. use 1 priority queue to save all workers ready to cross the bridge (from left to right)\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN) from PQ\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct compare // find lowest efficient worker\\n    {\\n        bool operator()(const vector<int> & a, const vector<int> & b)\\n        {\\n            return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n        }\\n    };\\n    \\n    struct compare2 // time ascend\\n    {\\n        bool operator()(const vector<int> & a, const vector<int> & b)\\n        {\\n            return a[0] > b[0];\\n        }\\n    };\\n    \\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int bridging = INT_MIN; // current worker id who is in bridge, postive id if they move from left to right, negative value if they move from right to left, as 0 has no positive or negative indicator, so we start worker id from 1;\\n        int bridgeClearTime = -1; // the nearest time for bridge to be free, need to check who will be the next to cross bridge\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq; // right side wait queue, to cross bridge\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq2; // left side wait queue, to cross bridge\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, compare2> pq3; // right side wait queue, to finish pick up old\\n        priority_queue<vector<int>, vector<vector<int>>, compare2> pq4; // left side wait queue, to finish put new \\n        \\n        \\n        std::priority_queue<int, std::vector<int>, std::greater<int>> timeQ; // global queue for interesting time check point, sort in time asend, multiple for the same time could exist\\n        \\n        // initial the pq2 at time 0, all workers are ready to send to right side to pick up box\\n        for(int i = 0; i < k; ++i) {\\n            pq2.push({time[i][0] + time[i][2], i, 0});\\n        }        \\n        timeQ.push(0);\\n        \\n        // iterate the time simulator in asend order until end\\n        while(!timeQ.empty()) {\\n            \\n            int current = timeQ.top();\\n            timeQ.pop();\\n            \\n            // if bridge is not free\\n            if (bridging != INT_MIN) {\\n                if (bridgeClearTime == current) {\\n                    if (bridging > 0) {\\n                        // worker cross to right\\n                        int workid = bridging - 1;\\n                        pq3.push({current + time[workid][1], workid});\\n                        timeQ.push(current + time[workid][1]);\\n                    } else {                        \\n                        // worker cross to left\\n                        if (pq.empty() && pq3.empty() && n == 0) {\\n                            return current;\\n                        }\\n                        \\n                        int workid = -1 - bridging;\\n                        pq4.push({current + time[workid][3], workid});\\n                        timeQ.push(current + time[workid][3]);\\n                    }\\n                    \\n                    bridging = INT_MIN;\\n                    bridgeClearTime = -1;\\n                }\\n            }\\n            \\n            // if bridge is free           \\n            if (bridging == INT_MIN) {\\n                // whether workers wait on right, find pq element from pq3\\n                while(!pq3.empty()) {\\n                    auto x = pq3.top();\\n                    \\n                    if (x[0] <= current) {\\n                        int wid = x[1];\\n                        pq.push({time[wid][0] + time[wid][2], wid, x[0]});\\n                        pq3.pop();\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                \\n                if (!pq.empty()) {\\n                    auto next = pq.top();                    \\n                    pq.pop();\\n                    bridging = 0 - next[1] - 1; // right to left, using -workerID\\n\\n                    timeQ.push(current + time[next[1]][2]);\\n                    bridgeClearTime = current + time[next[1]][2];\\n                    continue;                    \\n                }\\n                \\n                // no one on the right side, check remaining n\\n                if (n > 0) {\\n                    while(!pq4.empty()) {\\n                        auto x = pq4.top();\\n\\n                        if (x[0] <= current) {\\n                            int wid = x[1];\\n                            pq2.push({time[wid][0] + time[wid][2], wid, x[0]});\\n                            pq4.pop();\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if (!pq2.empty()) {\\n                        auto next = pq2.top();\\n                        pq2.pop();\\n                        bridging = next[1] + 1; // right to left, using +workerID\\n\\n                        timeQ.push(current + time[next[1]][0]);\\n                        bridgeClearTime = current + time[next[1]][0];\\n                        --n; // one less box need move\\n                        continue;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct compare // find lowest efficient worker\\n    {\\n        bool operator()(const vector<int> & a, const vector<int> & b)\\n        {\\n            return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\\n        }\\n    };\\n    \\n    struct compare2 // time ascend\\n    {\\n        bool operator()(const vector<int> & a, const vector<int> & b)\\n        {\\n            return a[0] > b[0];\\n        }\\n    };\\n    \\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        int bridging = INT_MIN; // current worker id who is in bridge, postive id if they move from left to right, negative value if they move from right to left, as 0 has no positive or negative indicator, so we start worker id from 1;\\n        int bridgeClearTime = -1; // the nearest time for bridge to be free, need to check who will be the next to cross bridge\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq; // right side wait queue, to cross bridge\\n        priority_queue<vector<int>, vector<vector<int>>, compare> pq2; // left side wait queue, to cross bridge\\n        \\n        priority_queue<vector<int>, vector<vector<int>>, compare2> pq3; // right side wait queue, to finish pick up old\\n        priority_queue<vector<int>, vector<vector<int>>, compare2> pq4; // left side wait queue, to finish put new \\n        \\n        \\n        std::priority_queue<int, std::vector<int>, std::greater<int>> timeQ; // global queue for interesting time check point, sort in time asend, multiple for the same time could exist\\n        \\n        // initial the pq2 at time 0, all workers are ready to send to right side to pick up box\\n        for(int i = 0; i < k; ++i) {\\n            pq2.push({time[i][0] + time[i][2], i, 0});\\n        }        \\n        timeQ.push(0);\\n        \\n        // iterate the time simulator in asend order until end\\n        while(!timeQ.empty()) {\\n            \\n            int current = timeQ.top();\\n            timeQ.pop();\\n            \\n            // if bridge is not free\\n            if (bridging != INT_MIN) {\\n                if (bridgeClearTime == current) {\\n                    if (bridging > 0) {\\n                        // worker cross to right\\n                        int workid = bridging - 1;\\n                        pq3.push({current + time[workid][1], workid});\\n                        timeQ.push(current + time[workid][1]);\\n                    } else {                        \\n                        // worker cross to left\\n                        if (pq.empty() && pq3.empty() && n == 0) {\\n                            return current;\\n                        }\\n                        \\n                        int workid = -1 - bridging;\\n                        pq4.push({current + time[workid][3], workid});\\n                        timeQ.push(current + time[workid][3]);\\n                    }\\n                    \\n                    bridging = INT_MIN;\\n                    bridgeClearTime = -1;\\n                }\\n            }\\n            \\n            // if bridge is free           \\n            if (bridging == INT_MIN) {\\n                // whether workers wait on right, find pq element from pq3\\n                while(!pq3.empty()) {\\n                    auto x = pq3.top();\\n                    \\n                    if (x[0] <= current) {\\n                        int wid = x[1];\\n                        pq.push({time[wid][0] + time[wid][2], wid, x[0]});\\n                        pq3.pop();\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                \\n                if (!pq.empty()) {\\n                    auto next = pq.top();                    \\n                    pq.pop();\\n                    bridging = 0 - next[1] - 1; // right to left, using -workerID\\n\\n                    timeQ.push(current + time[next[1]][2]);\\n                    bridgeClearTime = current + time[next[1]][2];\\n                    continue;                    \\n                }\\n                \\n                // no one on the right side, check remaining n\\n                if (n > 0) {\\n                    while(!pq4.empty()) {\\n                        auto x = pq4.top();\\n\\n                        if (x[0] <= current) {\\n                            int wid = x[1];\\n                            pq2.push({time[wid][0] + time[wid][2], wid, x[0]});\\n                            pq4.pop();\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if (!pq2.empty()) {\\n                        auto next = pq2.top();\\n                        pq2.pop();\\n                        bridging = next[1] + 1; // right to left, using +workerID\\n\\n                        timeQ.push(current + time[next[1]][0]);\\n                        bridgeClearTime = current + time[next[1]][0];\\n                        --n; // one less box need move\\n                        continue;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021340,
                "title": "wrong-problem-statement-simulation-w-heaps",
                "content": "Patently wrong problem statement. Especially this line *\"Return the instance of time at which the last worker reaches the left bank of the river **after all n boxes** have been put in the new warehouse.\"*\\n\\nNo wonder so many downvotes!\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvent based simulation for the problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHave a priority queue(heap) to accomplish efficiency pick.\\nHave a priority queue(heap) for event queue\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n, k, ti):\\n        L2R,R2L,PUN,PIO=1,2,3,4\\n        ct, eq, busy, lbq, rbq = 0, [(0,0,-1)], 0, [(-v[0]-v[2], -i)for i,v in enumerate(ti)], []\\n        heapify(lbq)\\n        def sched_bridge():\\n            nonlocal busy, n\\n            if busy==1: return\\n            if rbq: \\n                _, w = heappop(rbq)\\n                w, busy = -w, 1\\n                heappush(eq, (ct+ti[w][2], R2L, w))\\n            elif lbq and n > 0:\\n                _, w = heappop(lbq)\\n                w, busy, n = -w, 1, n-1\\n                heappush(eq, (ct+ti[w][0], L2R, w))\\n        while eq:\\n            ct, et, w = heappop(eq)\\n            if et in (L2R, R2L): busy=0\\n            if et == L2R: heappush(eq, (ct+ti[w][1], PIO, w))\\n            elif et == R2L: heappush(eq, (ct+ti[w][3], PUN, w))\\n            elif et == PUN: heappush(lbq, (-ti[w][0]-ti[w][2], -w))\\n            elif et == PIO: heappush(rbq, (-ti[w][0]-ti[w][2], -w))\\n            if eq and eq[0][0] == ct: continue\\n            sched_bridge()\\n        return ct-ti[w][3]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n, k, ti):\\n        L2R,R2L,PUN,PIO=1,2,3,4\\n        ct, eq, busy, lbq, rbq = 0, [(0,0,-1)], 0, [(-v[0]-v[2], -i)for i,v in enumerate(ti)], []\\n        heapify(lbq)\\n        def sched_bridge():\\n            nonlocal busy, n\\n            if busy==1: return\\n            if rbq: \\n                _, w = heappop(rbq)\\n                w, busy = -w, 1\\n                heappush(eq, (ct+ti[w][2], R2L, w))\\n            elif lbq and n > 0:\\n                _, w = heappop(lbq)\\n                w, busy, n = -w, 1, n-1\\n                heappush(eq, (ct+ti[w][0], L2R, w))\\n        while eq:\\n            ct, et, w = heappop(eq)\\n            if et in (L2R, R2L): busy=0\\n            if et == L2R: heappush(eq, (ct+ti[w][1], PIO, w))\\n            elif et == R2L: heappush(eq, (ct+ti[w][3], PUN, w))\\n            elif et == PUN: heappush(lbq, (-ti[w][0]-ti[w][2], -w))\\n            elif et == PIO: heappush(rbq, (-ti[w][0]-ti[w][2], -w))\\n            if eq and eq[0][0] == ct: continue\\n            sched_bridge()\\n        return ct-ti[w][3]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021238,
                "title": "4-heap-simulation-commented",
                "content": "# Intuition\\nInitially the problem looks very scary but its just a simulation problem where all the constraints and instructions are laid out for us. \\n\\nKeep track of the current time, only incrememting when either a worker is crossing a bridge, or there are no available workers.\\n\\nA worker can either be idle at leftBank or rightBank or they can be packing/unpacking. If they are packing or unpacking they have a set time when they will finish.\\n\\nAlso note the answer is not when all packages are done being unpacked just when the last worker reaches the leftBank\\n\\nWorker path is leftBank => pack => rightBank => unpack\\n\\n# Approach\\nAll workers start on leftBank\\n\\n1. Move any workers who are done packing/unpacking from their heaps and move them into the respective heaps. (packing => rightBank, unpacking => leftBank) We do this with respect to the current time.\\n2. Check if any workers are idling at the rightBank, the least efficient goes, increment the time by how long it takes them to cross. Move this worker to pack heap \\n3. If no workers are idling at the rightBank, check if any workers are idling at the leftBank, the least efficient goes, increment the time by how long it takes them to cross, and decrement the number of packages. Move this worker to unpack heap \\n4. If no workers are idling at the left or right bank, all available workers are packing/unpacking so we move the time until a worker is avaiable\\n5. Go back to step 1 until all packages are claimed\\n6. Once all packages are claimed repeat steps 1 and 2 until all workers are moved off the rightBank.\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        leftBank, rightBank, pack, unpack = [], [], [], []\\n        a = 0\\n        t = 0\\n        for i in range(len(time)):\\n            eff = time[i][0] + time[i][2]\\n            heappush(leftBank, (-eff, -i))\\n            \\n        while n > 0:\\n            # moving workers who are done packing to idle\\n            while pack and t >= pack[0][0]:\\n                worker = heappop(pack)\\n                heappush(rightBank, (worker[1], worker[2]))\\n            # moving workers who are done unpacking to idle\\n            while unpack and t >= unpack[0][0]:\\n                worker = heappop(unpack)\\n                heappush(leftBank, (worker[1], worker[2]))\\n            # checking for idle worker\\n            if rightBank:\\n                worker = heappop(rightBank)\\n                ind = -1*worker[1]\\n                t += time[ind][2]\\n                a = t\\n                heappush(unpack, (t+time[ind][3], worker[0], worker[1]))\\n            elif leftBank:\\n                worker = heappop(leftBank)\\n                ind = -1* worker[1]\\n                t += time[ind][0]\\n                heappush(pack, (t+time[ind][1], worker[0], worker[1]))\\n                n -= 1\\n            else:\\n                if pack and unpack:\\n                    t = min(pack[0][0], unpack[0][0])\\n                elif pack:\\n                    t = pack[0][0]\\n                else:\\n                    t = unpack[0][0]\\n        while pack or rightBank:\\n            # moving workers who are done packing to idle\\n            while pack and t >= pack[0][0]:\\n                worker = heappop(pack)\\n                heappush(rightBank, (worker[1], worker[2]))\\n            # no idle worker\\n            if not rightBank:\\n                t = pack[0][0]\\n            # idle worker crosses rightBank\\n            else:\\n                worker = heappop(rightBank)\\n                ind = -1*worker[1]\\n                t += time[ind][2]\\n                a = t\\n                \\n        return a \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        leftBank, rightBank, pack, unpack = [], [], [], []\\n        a = 0\\n        t = 0\\n        for i in range(len(time)):\\n            eff = time[i][0] + time[i][2]\\n            heappush(leftBank, (-eff, -i))\\n            \\n        while n > 0:\\n            # moving workers who are done packing to idle\\n            while pack and t >= pack[0][0]:\\n                worker = heappop(pack)\\n                heappush(rightBank, (worker[1], worker[2]))\\n            # moving workers who are done unpacking to idle\\n            while unpack and t >= unpack[0][0]:\\n                worker = heappop(unpack)\\n                heappush(leftBank, (worker[1], worker[2]))\\n            # checking for idle worker\\n            if rightBank:\\n                worker = heappop(rightBank)\\n                ind = -1*worker[1]\\n                t += time[ind][2]\\n                a = t\\n                heappush(unpack, (t+time[ind][3], worker[0], worker[1]))\\n            elif leftBank:\\n                worker = heappop(leftBank)\\n                ind = -1* worker[1]\\n                t += time[ind][0]\\n                heappush(pack, (t+time[ind][1], worker[0], worker[1]))\\n                n -= 1\\n            else:\\n                if pack and unpack:\\n                    t = min(pack[0][0], unpack[0][0])\\n                elif pack:\\n                    t = pack[0][0]\\n                else:\\n                    t = unpack[0][0]\\n        while pack or rightBank:\\n            # moving workers who are done packing to idle\\n            while pack and t >= pack[0][0]:\\n                worker = heappop(pack)\\n                heappush(rightBank, (worker[1], worker[2]))\\n            # no idle worker\\n            if not rightBank:\\n                t = pack[0][0]\\n            # idle worker crosses rightBank\\n            else:\\n                worker = heappop(rightBank)\\n                ind = -1*worker[1]\\n                t += time[ind][2]\\n                a = t\\n                \\n        return a \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020848,
                "title": "rust-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use four priority queues to simulate the movments\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe main idea is to keep two priority queeues: left, right up to the latest time.\\n\\nThere are three places that time (tm) could be advanced:\\n1) across bridge left -> right;\\n2) across bridge right -> left;\\n3) when no one is waiting to across the bridge, in this case, we need to advance the the earliest time in the cooling down queues: left_wait(only if more across the bridge from left => right is needed), right_wait;\\n\\nAfter each these time updates, we move immediately to processing (including retrieving all available entries to populate them) two queues: left, right. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn find_crossing_time(n: i32, k: i32, time: Vec<Vec<i32>>) -> i32 {\\n        let mut left = BinaryHeap::<(i32, usize)>::new();\\n        let mut right = BinaryHeap::<(i32, usize)>::new();\\n        let mut left_wait = BinaryHeap::<Reverse<(i32, usize)>>::new();\\n        let mut right_wait = BinaryHeap::<Reverse<(i32, usize)>>::new();\\n\\n        for i in 0 .. k as usize { left.push((time[i][0] + time[i][2], i)); }\\n        let (mut tm, mut n) = (0, n); \\n        loop {\\n            while let Some(Reverse((t, i))) = left_wait.peek() {\\n                if *t > tm { break }\\n                left.push((time[*i][0] + time[*i][2], *i));\\n                left_wait.pop();\\n            }\\n\\n            while let Some(Reverse((t, i))) = right_wait.peek() {\\n                if *t > tm { break }\\n                right.push((time[*i][0] + time[*i][2], *i));\\n                right_wait.pop();\\n            }\\n\\n            if let Some((_, i)) = right.pop() {\\n                tm += time[i][2];    \\n                left_wait.push(Reverse((tm + time[i][3], i)));\\n                continue\\n            }\\n            if n == 0 && right.is_empty() && right_wait.is_empty() { break }\\n\\n            if let Some((_, i)) = left.pop() {\\n                if n > 0 { \\n                    n -= 1;\\n                    tm += time[i][0];\\n                    right_wait.push(Reverse((tm + time[i][1], i)));\\n                    continue\\n                }\\n            }\\n \\n            let mut new_time = i32::MAX;\\n            if let Some(Reverse((t, _))) = left_wait.peek() {\\n                if n > 0 { new_time = new_time.min(*t); }\\n            }\\n            if let Some(Reverse((t, _))) = right_wait.peek() { new_time = new_time.min(*t); }\\n            tm = tm.max(new_time);\\n        }\\n        tm\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn find_crossing_time(n: i32, k: i32, time: Vec<Vec<i32>>) -> i32 {\\n        let mut left = BinaryHeap::<(i32, usize)>::new();\\n        let mut right = BinaryHeap::<(i32, usize)>::new();\\n        let mut left_wait = BinaryHeap::<Reverse<(i32, usize)>>::new();\\n        let mut right_wait = BinaryHeap::<Reverse<(i32, usize)>>::new();\\n\\n        for i in 0 .. k as usize { left.push((time[i][0] + time[i][2], i)); }\\n        let (mut tm, mut n) = (0, n); \\n        loop {\\n            while let Some(Reverse((t, i))) = left_wait.peek() {\\n                if *t > tm { break }\\n                left.push((time[*i][0] + time[*i][2], *i));\\n                left_wait.pop();\\n            }\\n\\n            while let Some(Reverse((t, i))) = right_wait.peek() {\\n                if *t > tm { break }\\n                right.push((time[*i][0] + time[*i][2], *i));\\n                right_wait.pop();\\n            }\\n\\n            if let Some((_, i)) = right.pop() {\\n                tm += time[i][2];    \\n                left_wait.push(Reverse((tm + time[i][3], i)));\\n                continue\\n            }\\n            if n == 0 && right.is_empty() && right_wait.is_empty() { break }\\n\\n            if let Some((_, i)) = left.pop() {\\n                if n > 0 { \\n                    n -= 1;\\n                    tm += time[i][0];\\n                    right_wait.push(Reverse((tm + time[i][1], i)));\\n                    continue\\n                }\\n            }\\n \\n            let mut new_time = i32::MAX;\\n            if let Some(Reverse((t, _))) = left_wait.peek() {\\n                if n > 0 { new_time = new_time.min(*t); }\\n            }\\n            if let Some(Reverse((t, _))) = right_wait.peek() { new_time = new_time.min(*t); }\\n            tm = tm.max(new_time);\\n        }\\n        tm\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3019640,
                "title": "java-priorityqueue-easy-to-understand",
                "content": "```\\n    //1. PriorityQueue\\n    //Runtime: 80ms 33%; Memory: 48.7MB 91%\\n    //time: O(K + N * logK); Space: O(N)\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        int[] worker = new int[k];\\n        //waiting for bridge (base on efficiency)\\n        PriorityQueue<Integer> workL = new PriorityQueue<>((a, b) -> (time[b][0] + time[b][2] == time[a][0] + time[a][2]) ? b - a : time[b][0] + time[b][2] - (time[a][0] + time[a][2]));\\n        PriorityQueue<Integer> workR = new PriorityQueue<>((a, b) -> (time[b][0] + time[b][2] == time[a][0] + time[a][2]) ? b - a : time[b][0] + time[b][2] - (time[a][0] + time[a][2]));\\n        //working in warehouse (base on time)\\n        PriorityQueue<Integer> heapL = new PriorityQueue<>(Comparator.comparingInt(a -> worker[a]));\\n        PriorityQueue<Integer> heapR = new PriorityQueue<>(Comparator.comparingInt(a -> worker[a]));\\n\\n        //all waiting on the left side\\n        for (int i = 0; i < k; i++) workL.add(i);\\n\\n        int assign = 0, unmoved = n, currTime = 0;\\n        while (unmoved > 0) {\\n\\n            //move to bridge queue\\n            while (!heapL.isEmpty() && worker[heapL.peek()] <= currTime)\\n                workL.add(heapL.poll());\\n\\n            while (!heapR.isEmpty() && worker[heapR.peek()] <= currTime)\\n                workR.add(heapR.poll());\\n\\n            //cross bridge\\n            if (!workR.isEmpty()) {\\n                int idx = workR.poll();\\n                currTime = Math.max(worker[idx], currTime) + time[idx][2];\\n                worker[idx] = currTime + time[idx][3];\\n                heapL.add(idx);\\n                unmoved--;\\n\\n            } else if (!workL.isEmpty()){\\n                int idx = workL.poll();\\n                if (assign == n) continue;\\n                currTime = Math.max(worker[idx], currTime) + time[idx][0];\\n                worker[idx] = currTime + time[idx][1];\\n                heapR.add(idx);\\n                assign++;\\n\\n            } else {\\n                //time fly...\\n                if (!heapR.isEmpty() && !heapL.isEmpty())\\n                    currTime = Math.min(worker[heapL.peek()], worker[heapR.peek()]);\\n                else if (!heapR.isEmpty())\\n                    currTime = worker[heapR.peek()];\\n                else\\n                    currTime = worker[heapL.peek()];\\n            }\\n        }\\n        return currTime;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    //1. PriorityQueue\\n    //Runtime: 80ms 33%; Memory: 48.7MB 91%\\n    //time: O(K + N * logK); Space: O(N)\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        int[] worker = new int[k];\\n        //waiting for bridge (base on efficiency)\\n        PriorityQueue<Integer> workL = new PriorityQueue<>((a, b) -> (time[b][0] + time[b][2] == time[a][0] + time[a][2]) ? b - a : time[b][0] + time[b][2] - (time[a][0] + time[a][2]));\\n        PriorityQueue<Integer> workR = new PriorityQueue<>((a, b) -> (time[b][0] + time[b][2] == time[a][0] + time[a][2]) ? b - a : time[b][0] + time[b][2] - (time[a][0] + time[a][2]));\\n        //working in warehouse (base on time)\\n        PriorityQueue<Integer> heapL = new PriorityQueue<>(Comparator.comparingInt(a -> worker[a]));\\n        PriorityQueue<Integer> heapR = new PriorityQueue<>(Comparator.comparingInt(a -> worker[a]));\\n\\n        //all waiting on the left side\\n        for (int i = 0; i < k; i++) workL.add(i);\\n\\n        int assign = 0, unmoved = n, currTime = 0;\\n        while (unmoved > 0) {\\n\\n            //move to bridge queue\\n            while (!heapL.isEmpty() && worker[heapL.peek()] <= currTime)\\n                workL.add(heapL.poll());\\n\\n            while (!heapR.isEmpty() && worker[heapR.peek()] <= currTime)\\n                workR.add(heapR.poll());\\n\\n            //cross bridge\\n            if (!workR.isEmpty()) {\\n                int idx = workR.poll();\\n                currTime = Math.max(worker[idx], currTime) + time[idx][2];\\n                worker[idx] = currTime + time[idx][3];\\n                heapL.add(idx);\\n                unmoved--;\\n\\n            } else if (!workL.isEmpty()){\\n                int idx = workL.poll();\\n                if (assign == n) continue;\\n                currTime = Math.max(worker[idx], currTime) + time[idx][0];\\n                worker[idx] = currTime + time[idx][1];\\n                heapR.add(idx);\\n                assign++;\\n\\n            } else {\\n                //time fly...\\n                if (!heapR.isEmpty() && !heapL.isEmpty())\\n                    currTime = Math.min(worker[heapL.peek()], worker[heapR.peek()]);\\n                else if (!heapR.isEmpty())\\n                    currTime = worker[heapR.peek()];\\n                else\\n                    currTime = worker[heapL.peek()];\\n            }\\n        }\\n        return currTime;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3019227,
                "title": "python-4-events-4-priority-queue-with-explanation",
                "content": "# Intuition\\n\\n**Definition**\\n`left`\\n- ready to cross the bridge to pick up the box.\\n- prioritize with lowest efficiency\\n\\n`right`\\n- ready to cross the bridge to put down the box.\\n- prioritize with lowest efficiency\\n\\n`picking`\\n- busy in picking up box.\\n- prioritize with the process time. choose the most recent one to finish picking up\\n\\n`putting`\\n- busy in putting down box.\\n- prioritize with the process time. choose the most recent one to finish putting down\\n\\nthen, keep sending worker to work until `n` is 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### Preprocess\\n- let\\'s process workers their effeciency and put in max heap `left`\\n- use currTime to know the timeline\\n\\n### Simulation\\n\\n- if someone in the `right` ready to cross the bridge, send them to put down the box\\n    - increment time with `rightToLeft` time\\n\\n    ```\\n    currTime += time[-i][2]\\n    heapq.heappush(putting, [currTime+time[-i][3], eff, i])\\n    ```\\n\\n- if someone in the `left` ready to cross the bridge, send them to pick up the box\\n    - increment time with `leftToRight` time\\n    - decrement `n`\\n    ```\\n    currTime += time[-i][0]\\n    n -= 1\\n    heapq.heappush(picking, [currTime+time[-i][1], eff, i])\\n    ```\\n- if no one is waiting for crossing the bridge, find one who is about to finish his work.\\n    - choose from `picking` and `putting`\\n\\nAfter `n` becomes 0, there must exist:\\n- someone waiting to cross the bridge from `right` to `left`\\n- someone busy in picking up\\n\\n1. send those who is ready to cross the bridge from `right` to `left` first\\n    - increment current time by `rightToLeft` time\\n    - while they are crossing the bridge, those finish picking go to `right`\\n\\n2. send last few workers who are still picking up boxes back\\n    - update currentTime to last one\\'s finish time and increment by `rightToLeft` time\\n\\nNow, every workers are back to left finally...\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        left, right = [], []\\n        for i in range(k):\\n            l2r, pick, r2l, put = time[i]\\n            effeciency = l2r+r2l\\n            heapq.heappush(left, [-effeciency, -i])\\n        \\n        currTime = 0\\n        picking = []\\n        putting = []\\n        while n:\\n            if right:\\n                # corss bridge: R -> L Putting\\n                eff, i = heapq.heappop(right)\\n                currTime += time[-i][2]\\n\\n                heapq.heappush(putting, [currTime+time[-i][3], eff, i])\\n            elif left:\\n                # corss bridge: L -> R Picking\\n                eff, i = heapq.heappop(left)\\n                currTime += time[-i][0]\\n                n -= 1\\n\\n                heapq.heappush(picking, [currTime+time[-i][1], eff, i])\\n            else:\\n                # find one who\\'s ready to cross the bridge\\n                if not putting:\\n                    currTime = picking[0][0]\\n                elif not picking:\\n                    currTime = putting[0][0]\\n                else:\\n                    currTime = min(picking[0][0], putting[0][0])\\n\\n            # now, current time is the most recent work to finish\\n            # these are ready to cross the bridge in left or right\\n            while picking and picking[0][0] <= currTime:\\n                _, eff, i = heapq.heappop(picking)\\n                heapq.heappush(right, [eff, i])\\n            while putting and putting[0][0] <= currTime:\\n                _, eff, i = heapq.heappop(putting)\\n                heapq.heappush(left, [eff, i])\\n        \\n        # some in right and some in picking\\n        # we need to send them back\\n\\n        # right cross first\\n        while right:\\n            eff, i = heapq.heappop(right)\\n            currTime += time[-i][2]\\n            while picking and picking[0][0] <= currTime:\\n                _, eff, i = heapq.heappop(picking)\\n                heapq.heappush(right, [eff, i])\\n\\n        # last few workers\\n        while picking:\\n            endTime, eff, i = heapq.heappop(picking)\\n            currTime = max(currTime, endTime)\\n\\n            # to right then to left\\n            # _, eff, i = heapq.heappop(picking)\\n            # heapq.heappush(right, [eff, i])\\n            # while right:\\n            #     eff, i = heapq.heappop(right)\\n            #     currTime += time[-i][2]\\n            currTime += time[-i][2]\\n            # we don\\'t need to increment putNew time at final round\\n\\n        return currTime\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    currTime += time[-i][2]\\n    heapq.heappush(putting, [currTime+time[-i][3], eff, i])\\n    ```\n```\\n    currTime += time[-i][0]\\n    n -= 1\\n    heapq.heappush(picking, [currTime+time[-i][1], eff, i])\\n    ```\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        left, right = [], []\\n        for i in range(k):\\n            l2r, pick, r2l, put = time[i]\\n            effeciency = l2r+r2l\\n            heapq.heappush(left, [-effeciency, -i])\\n        \\n        currTime = 0\\n        picking = []\\n        putting = []\\n        while n:\\n            if right:\\n                # corss bridge: R -> L Putting\\n                eff, i = heapq.heappop(right)\\n                currTime += time[-i][2]\\n\\n                heapq.heappush(putting, [currTime+time[-i][3], eff, i])\\n            elif left:\\n                # corss bridge: L -> R Picking\\n                eff, i = heapq.heappop(left)\\n                currTime += time[-i][0]\\n                n -= 1\\n\\n                heapq.heappush(picking, [currTime+time[-i][1], eff, i])\\n            else:\\n                # find one who\\'s ready to cross the bridge\\n                if not putting:\\n                    currTime = picking[0][0]\\n                elif not picking:\\n                    currTime = putting[0][0]\\n                else:\\n                    currTime = min(picking[0][0], putting[0][0])\\n\\n            # now, current time is the most recent work to finish\\n            # these are ready to cross the bridge in left or right\\n            while picking and picking[0][0] <= currTime:\\n                _, eff, i = heapq.heappop(picking)\\n                heapq.heappush(right, [eff, i])\\n            while putting and putting[0][0] <= currTime:\\n                _, eff, i = heapq.heappop(putting)\\n                heapq.heappush(left, [eff, i])\\n        \\n        # some in right and some in picking\\n        # we need to send them back\\n\\n        # right cross first\\n        while right:\\n            eff, i = heapq.heappop(right)\\n            currTime += time[-i][2]\\n            while picking and picking[0][0] <= currTime:\\n                _, eff, i = heapq.heappop(picking)\\n                heapq.heappush(right, [eff, i])\\n\\n        # last few workers\\n        while picking:\\n            endTime, eff, i = heapq.heappop(picking)\\n            currTime = max(currTime, endTime)\\n\\n            # to right then to left\\n            # _, eff, i = heapq.heappop(picking)\\n            # heapq.heappush(right, [eff, i])\\n            # while right:\\n            #     eff, i = heapq.heappop(right)\\n            #     currTime += time[-i][2]\\n            currTime += time[-i][2]\\n            # we don\\'t need to increment putNew time at final round\\n\\n        return currTime\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019095,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n public:\\n  int findCrossingTime(const int n, const int k, const vector<vector<int>> &time) {\\n    /**\\n     * `first`, the working index\\n     * `second`, the time\\n     */\\n    using worker_info = pair<int, int>;\\n    constexpr int i_left_to_right = 0;\\n    constexpr int i_pick_old = 1;\\n    constexpr int i_right_to_left = 2;\\n    constexpr int i_put_new = 3;\\n    auto compare_waiting = [&time](const worker_info &lhs, const worker_info &rhs) -> bool {\\n      const int time_l = time[lhs.first][i_left_to_right] + time[lhs.first][i_right_to_left];\\n      const int time_r = time[rhs.first][i_left_to_right] + time[rhs.first][i_right_to_left];\\n      return !(time_l > time_r || (time_l == time_r && lhs > rhs));\\n    };\\n    priority_queue<worker_info, vector<worker_info>, decltype(compare_waiting)> pq_left_waiting(compare_waiting);\\n    priority_queue<worker_info, vector<worker_info>, decltype(compare_waiting)> pq_right_waiting(compare_waiting);\\n    \\n    auto compare_working = [](const worker_info &lhs, const worker_info &rhs) -> bool {\\n      return !(lhs.second < rhs.second);\\n    };\\n    priority_queue<worker_info, vector<worker_info>, decltype(compare_working)> pq_left_working(compare_working);\\n    priority_queue<worker_info, vector<worker_info>, decltype(compare_working)> pq_right_working(compare_working);\\n    \\n    for (int i = 0; i < k; ++i) {\\n      pq_left_waiting.emplace(i, 0);\\n    }\\n    int current_time = 0;\\n    int remained_box = n;\\n    while (true) {\\n      while (!pq_left_working.empty() && pq_left_working.top().second <= current_time) {\\n        worker_info worker = pq_left_working.top();\\n        pq_left_working.pop();\\n        if (remained_box > 0) {\\n          pq_left_waiting.emplace(move(worker));\\n        }\\n      }\\n      while (!pq_right_working.empty() && pq_right_working.top().second <= current_time) {\\n        worker_info worker = pq_right_working.top();\\n        pq_right_working.pop();\\n        pq_right_waiting.emplace(move(worker));\\n      }\\n      if (pq_left_waiting.empty() && pq_right_waiting.empty()) {\\n        int next_current_time = numeric_limits<int>::max();\\n        if (!pq_left_working.empty()) {\\n          next_current_time = min(next_current_time, pq_left_working.top().second);\\n        }\\n        if (!pq_right_working.empty()) {\\n          next_current_time = min(next_current_time, pq_right_working.top().second);\\n        }\\n        if (next_current_time != numeric_limits<int>::max()) {\\n          current_time = next_current_time;\\n        }\\n        continue;\\n      }\\n      if (!pq_right_waiting.empty()) {\\n        worker_info worker = pq_right_waiting.top();\\n        pq_right_waiting.pop();\\n        current_time += time[worker.first][i_right_to_left];\\n        worker.second = current_time + time[worker.first][i_put_new];\\n        pq_left_working.emplace(worker);\\n        if (remained_box == 0 && pq_right_waiting.empty() && pq_right_working.empty()) {\\n          break;\\n        }\\n        continue;\\n      }\\n      \\n      // !pq_left_waiting.empty()\\n      if (remained_box == 0) {\\n        while (!pq_left_waiting.empty()) {\\n          pq_left_waiting.pop();\\n        }\\n        continue;\\n      }\\n      --remained_box;\\n      worker_info worker = pq_left_waiting.top();\\n      pq_left_waiting.pop();\\n      current_time += time[worker.first][i_left_to_right];\\n      worker.second = current_time + time[worker.first][i_pick_old];\\n      pq_right_working.emplace(worker);\\n    }\\n    return current_time;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int findCrossingTime(const int n, const int k, const vector<vector<int>> &time) {\\n    /**\\n     * `first`, the working index\\n     * `second`, the time\\n     */\\n    using worker_info = pair<int, int>;\\n    constexpr int i_left_to_right = 0;\\n    constexpr int i_pick_old = 1;\\n    constexpr int i_right_to_left = 2;\\n    constexpr int i_put_new = 3;\\n    auto compare_waiting = [&time](const worker_info &lhs, const worker_info &rhs) -> bool {\\n      const int time_l = time[lhs.first][i_left_to_right] + time[lhs.first][i_right_to_left];\\n      const int time_r = time[rhs.first][i_left_to_right] + time[rhs.first][i_right_to_left];\\n      return !(time_l > time_r || (time_l == time_r && lhs > rhs));\\n    };\\n    priority_queue<worker_info, vector<worker_info>, decltype(compare_waiting)> pq_left_waiting(compare_waiting);\\n    priority_queue<worker_info, vector<worker_info>, decltype(compare_waiting)> pq_right_waiting(compare_waiting);\\n    \\n    auto compare_working = [](const worker_info &lhs, const worker_info &rhs) -> bool {\\n      return !(lhs.second < rhs.second);\\n    };\\n    priority_queue<worker_info, vector<worker_info>, decltype(compare_working)> pq_left_working(compare_working);\\n    priority_queue<worker_info, vector<worker_info>, decltype(compare_working)> pq_right_working(compare_working);\\n    \\n    for (int i = 0; i < k; ++i) {\\n      pq_left_waiting.emplace(i, 0);\\n    }\\n    int current_time = 0;\\n    int remained_box = n;\\n    while (true) {\\n      while (!pq_left_working.empty() && pq_left_working.top().second <= current_time) {\\n        worker_info worker = pq_left_working.top();\\n        pq_left_working.pop();\\n        if (remained_box > 0) {\\n          pq_left_waiting.emplace(move(worker));\\n        }\\n      }\\n      while (!pq_right_working.empty() && pq_right_working.top().second <= current_time) {\\n        worker_info worker = pq_right_working.top();\\n        pq_right_working.pop();\\n        pq_right_waiting.emplace(move(worker));\\n      }\\n      if (pq_left_waiting.empty() && pq_right_waiting.empty()) {\\n        int next_current_time = numeric_limits<int>::max();\\n        if (!pq_left_working.empty()) {\\n          next_current_time = min(next_current_time, pq_left_working.top().second);\\n        }\\n        if (!pq_right_working.empty()) {\\n          next_current_time = min(next_current_time, pq_right_working.top().second);\\n        }\\n        if (next_current_time != numeric_limits<int>::max()) {\\n          current_time = next_current_time;\\n        }\\n        continue;\\n      }\\n      if (!pq_right_waiting.empty()) {\\n        worker_info worker = pq_right_waiting.top();\\n        pq_right_waiting.pop();\\n        current_time += time[worker.first][i_right_to_left];\\n        worker.second = current_time + time[worker.first][i_put_new];\\n        pq_left_working.emplace(worker);\\n        if (remained_box == 0 && pq_right_waiting.empty() && pq_right_working.empty()) {\\n          break;\\n        }\\n        continue;\\n      }\\n      \\n      // !pq_left_waiting.empty()\\n      if (remained_box == 0) {\\n        while (!pq_left_waiting.empty()) {\\n          pq_left_waiting.pop();\\n        }\\n        continue;\\n      }\\n      --remained_box;\\n      worker_info worker = pq_left_waiting.top();\\n      pq_left_waiting.pop();\\n      current_time += time[worker.first][i_left_to_right];\\n      worker.second = current_time + time[worker.first][i_pick_old];\\n      pq_right_working.emplace(worker);\\n    }\\n    return current_time;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018740,
                "title": "readable-java-using-1-event-queue-and-2-wait-queues-in-o-n-log-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- unsing 3 priority queues\\n    - 2 wait queue for each side sorted by worker properties only\\n    - 1 event qeue for future arrivals sorted by time\\n    - workers are moved between these queues\\n- tracks time when bridge will be available next\\n    - if noone is waiting for bridge, advances nextBridgeFreeTime to next arrival\\n\\n# Complexity\\n- Time complexity:\\nO(n * lof(k))\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        // events in future\\n        PriorityQueue<WorkerAction> timeQueue = new PriorityQueue<>(WorkerAction.TimeOrder);\\n        // waiting on left bank\\n        PriorityQueue<WorkerAction> leftReady = new PriorityQueue<>(WorkerAction.EfficiencyOrder); \\n        // waiting on right bank\\n        PriorityQueue<WorkerAction> rightReady = new PriorityQueue<>(WorkerAction.EfficiencyOrder);\\n        Set<WorkerAction> onRight = new HashSet<>();\\n        int id = 0;\\n        for (int[] worker : time) {\\n            timeQueue.add(new WorkerAction(id++, worker[0], worker[1], worker[2], worker[3]));\\n        }\\n        int packagesInNew = 0, packagesInOld = n;\\n        int nextBridgeFreeTime = 0;\\n\\n        while (packagesInNew < n) {\\n            // distribute arrived workers to ready queues\\n            while (!timeQueue.isEmpty() && timeQueue.peek().time <= nextBridgeFreeTime) {\\n                WorkerAction wa = timeQueue.remove();\\n                if (onRight.contains(wa)) {\\n                    rightReady.offer(wa);\\n                } else {\\n                    leftReady.offer(wa);\\n                }\\n                onRight.remove(wa);\\n            }\\n\\n            // process wrorkers movement according to rules in descripiton\\n            if (!rightReady.isEmpty()) {\\n                WorkerAction wa = rightReady.remove();\\n                wa.time = nextBridgeFreeTime + wa.rightToLeft + wa.putNew;\\n                nextBridgeFreeTime = nextBridgeFreeTime + wa.rightToLeft;\\n                timeQueue.offer(wa);\\n                ++packagesInNew;\\n            } else if (!leftReady.isEmpty() && packagesInOld > 0) {\\n                WorkerAction wa = leftReady.remove();\\n                wa.time = nextBridgeFreeTime + wa.leftToRight + wa.pickOld;\\n                nextBridgeFreeTime = nextBridgeFreeTime + wa.leftToRight;\\n                timeQueue.offer(wa);\\n                onRight.add(wa);\\n                --packagesInOld;\\n            } else {\\n                // brige is unused, advance to next event\\n                nextBridgeFreeTime = timeQueue.peek().time;\\n            }\\n        }\\n        return nextBridgeFreeTime;\\n    }\\n\\n    private static class WorkerAction {\\n        int id, leftToRight, pickOld, rightToLeft, putNew;\\n        int time = 0;\\n        WorkerAction(int id, int leftToRight, int pickOld, int rightToLeft, int putNew) {\\n            this.id = id;\\n            this.leftToRight = leftToRight;\\n            this.pickOld = pickOld;\\n            this.rightToLeft = rightToLeft;\\n            this.putNew = putNew;\\n        }\\n\\n        static final Comparator<WorkerAction> TimeOrder = (a,b) -> Integer.compare(a.time, b.time);\\n        static final Comparator<WorkerAction> EfficiencyOrder = (a,b) -> { \\n            int efficiencyComparison = -Integer.compare(a.leftToRight + a.rightToLeft, b.leftToRight + b.rightToLeft);\\n            if (efficiencyComparison != 0) {\\n                return efficiencyComparison;\\n            }\\n            return -Integer.compare(a.id, b.id);\\n        };\\n\\n        @Override\\n        public String toString() {\\n            return \"{<\" + time +\",\"+ + id +\">[\" + leftToRight +\",\"+ pickOld +\",\"+  rightToLeft +\",\"+  putNew + \"]}\";\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        // events in future\\n        PriorityQueue<WorkerAction> timeQueue = new PriorityQueue<>(WorkerAction.TimeOrder);\\n        // waiting on left bank\\n        PriorityQueue<WorkerAction> leftReady = new PriorityQueue<>(WorkerAction.EfficiencyOrder); \\n        // waiting on right bank\\n        PriorityQueue<WorkerAction> rightReady = new PriorityQueue<>(WorkerAction.EfficiencyOrder);\\n        Set<WorkerAction> onRight = new HashSet<>();\\n        int id = 0;\\n        for (int[] worker : time) {\\n            timeQueue.add(new WorkerAction(id++, worker[0], worker[1], worker[2], worker[3]));\\n        }\\n        int packagesInNew = 0, packagesInOld = n;\\n        int nextBridgeFreeTime = 0;\\n\\n        while (packagesInNew < n) {\\n            // distribute arrived workers to ready queues\\n            while (!timeQueue.isEmpty() && timeQueue.peek().time <= nextBridgeFreeTime) {\\n                WorkerAction wa = timeQueue.remove();\\n                if (onRight.contains(wa)) {\\n                    rightReady.offer(wa);\\n                } else {\\n                    leftReady.offer(wa);\\n                }\\n                onRight.remove(wa);\\n            }\\n\\n            // process wrorkers movement according to rules in descripiton\\n            if (!rightReady.isEmpty()) {\\n                WorkerAction wa = rightReady.remove();\\n                wa.time = nextBridgeFreeTime + wa.rightToLeft + wa.putNew;\\n                nextBridgeFreeTime = nextBridgeFreeTime + wa.rightToLeft;\\n                timeQueue.offer(wa);\\n                ++packagesInNew;\\n            } else if (!leftReady.isEmpty() && packagesInOld > 0) {\\n                WorkerAction wa = leftReady.remove();\\n                wa.time = nextBridgeFreeTime + wa.leftToRight + wa.pickOld;\\n                nextBridgeFreeTime = nextBridgeFreeTime + wa.leftToRight;\\n                timeQueue.offer(wa);\\n                onRight.add(wa);\\n                --packagesInOld;\\n            } else {\\n                // brige is unused, advance to next event\\n                nextBridgeFreeTime = timeQueue.peek().time;\\n            }\\n        }\\n        return nextBridgeFreeTime;\\n    }\\n\\n    private static class WorkerAction {\\n        int id, leftToRight, pickOld, rightToLeft, putNew;\\n        int time = 0;\\n        WorkerAction(int id, int leftToRight, int pickOld, int rightToLeft, int putNew) {\\n            this.id = id;\\n            this.leftToRight = leftToRight;\\n            this.pickOld = pickOld;\\n            this.rightToLeft = rightToLeft;\\n            this.putNew = putNew;\\n        }\\n\\n        static final Comparator<WorkerAction> TimeOrder = (a,b) -> Integer.compare(a.time, b.time);\\n        static final Comparator<WorkerAction> EfficiencyOrder = (a,b) -> { \\n            int efficiencyComparison = -Integer.compare(a.leftToRight + a.rightToLeft, b.leftToRight + b.rightToLeft);\\n            if (efficiencyComparison != 0) {\\n                return efficiencyComparison;\\n            }\\n            return -Integer.compare(a.id, b.id);\\n        };\\n\\n        @Override\\n        public String toString() {\\n            return \"{<\" + time +\",\"+ + id +\">[\" + leftToRight +\",\"+ pickOld +\",\"+  rightToLeft +\",\"+  putNew + \"]}\";\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018686,
                "title": "every-scenario-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe process can be simulated as the constraints are not big.\\n***store finish time and index along with workers***\\ntime[] = {ltr , pick , rtl , put , finish , index};\\n\\nwe can have 4 priorityQueues for for states:- \\n1. **put**  :- workers putting the box in new warehouse (min Priority on basis of finish time of the state)\\n2. **ltr** :- workers waiting to cross the bridge ---> way (max PQ)\\n3. **rtl** :- workers waiting to cross the bridge <--- way (max PQ)\\n4. **pick** :- workers picking the box in old warehouse (min PQ as put).\\n\\nmaintain a variable **time**.\\nworkers on the **rtl** have the most priority so first process **rtl** and add them in the **put** and increase **time** by crossing time of each worker in the **rtl** and update their finish time by current time+their putting time.\\nwhile doing check if workers finished their picking in **pick** and add them if done.\\nprocess the **ltr** the same way and check at every move wether the move is correct or not\\nat end of the box if we substract putting time from  finish time we get answe\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(10*nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        for(int i = 0; i < k ; i++){\\n            time[i] = new int[]{time[i][0] , time[i][1] , time[i][2] , time[i][3] , 0 , i};\\n        }\\n        PriorityQueue<int[]> ltr = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a , int[] b){\\n                int d = (b[0]+b[2])-(a[0]+a[2]);\\n                if(d == 0)return b[5]-a[5];\\n                return d;\\n            }\\n        });\\n        PriorityQueue<int[]> rtl = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a , int[] b){\\n                int d = (b[0]+b[2])-(a[0]+a[2]);\\n                if(d == 0)return b[5]-a[5];\\n                return d;\\n            }\\n        });\\n        PriorityQueue<int[]> pick = new PriorityQueue<>((a,b)-> a[4] - b[4]);\\n        PriorityQueue<int[]> put = new PriorityQueue<>((a,b)-> a[4] - b[4]);\\n\\n        int t = 0;int max=  0;\\n        for(int[] tt : time)ltr.add(tt);\\n        // System.out.println(Arrays.toString(ltr.peek()));\\n        int boxes = 0;\\n        while(boxes < n){\\n            while(rtl.size() >= 0){//process rightside\\n                while(pick.size() > 0 && pick.peek()[4] <= t){//add workers who picked their boxes.\\n                    rtl.add(pick.remove());\\n                }\\n                if(rtl.size() > 0){//cross the workers bridge & update their finishing time(putting).\\n                    int[] le = rtl.remove();\\n                    t += le[2];\\n                    le[4] = t+le[3];//finish time=t+put time\\n                    put.add(le);\\n                }\\n                else{//if rtl empty at some time check who will be available first. to process\\n                    if(pick.size() == 0)break;\\n                    if(ltr.size() > 0 && (n-boxes > put.size()+pick.size()+rtl.size()))break;\\n                    if(put.size() != 0 && put.peek()[4] < pick.peek()[4]){\\n                        t = put.peek()[4];\\n                        break;\\n                    }\\n                    t = pick.peek()[4];\\n                }\\n            }\\n            while(ltr.size() >= 0 && (pick.size() == 0 || pick.peek()[4] > t)){//process if no one is waiting on right side\\n                while(put.size() > 0 && put.peek()[4] <= t){//add workers who put their box\\n                    max = Math.max(max, put.peek()[4]-put.peek()[3]);\\n                    // System.out.println(Arrays.toString(put.peek()));\\n                    ltr.add(put.remove());\\n                    boxes++;\\n                }\\n                if(ltr.size() > 0 && (n-boxes > put.size()+pick.size()+rtl.size())){//send workers only if boxes are left\\n                    int[] le = ltr.remove();\\n                    t += le[0];\\n                    le[4] = t+le[1];\\n                    pick.add(le);\\n                }else{//if ltr empty at some time check who will be available first\\n                    if(put.size() == 0)break;\\n                    if(rtl.size() != 0)break;\\n                    if(pick.size() != 0 && put.peek()[4] >= pick.peek()[4]){\\n                        t = pick.peek()[4];\\n                        break;\\n                    }\\n                    t = put.peek()[4];\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        for(int i = 0; i < k ; i++){\\n            time[i] = new int[]{time[i][0] , time[i][1] , time[i][2] , time[i][3] , 0 , i};\\n        }\\n        PriorityQueue<int[]> ltr = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a , int[] b){\\n                int d = (b[0]+b[2])-(a[0]+a[2]);\\n                if(d == 0)return b[5]-a[5];\\n                return d;\\n            }\\n        });\\n        PriorityQueue<int[]> rtl = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a , int[] b){\\n                int d = (b[0]+b[2])-(a[0]+a[2]);\\n                if(d == 0)return b[5]-a[5];\\n                return d;\\n            }\\n        });\\n        PriorityQueue<int[]> pick = new PriorityQueue<>((a,b)-> a[4] - b[4]);\\n        PriorityQueue<int[]> put = new PriorityQueue<>((a,b)-> a[4] - b[4]);\\n\\n        int t = 0;int max=  0;\\n        for(int[] tt : time)ltr.add(tt);\\n        // System.out.println(Arrays.toString(ltr.peek()));\\n        int boxes = 0;\\n        while(boxes < n){\\n            while(rtl.size() >= 0){//process rightside\\n                while(pick.size() > 0 && pick.peek()[4] <= t){//add workers who picked their boxes.\\n                    rtl.add(pick.remove());\\n                }\\n                if(rtl.size() > 0){//cross the workers bridge & update their finishing time(putting).\\n                    int[] le = rtl.remove();\\n                    t += le[2];\\n                    le[4] = t+le[3];//finish time=t+put time\\n                    put.add(le);\\n                }\\n                else{//if rtl empty at some time check who will be available first. to process\\n                    if(pick.size() == 0)break;\\n                    if(ltr.size() > 0 && (n-boxes > put.size()+pick.size()+rtl.size()))break;\\n                    if(put.size() != 0 && put.peek()[4] < pick.peek()[4]){\\n                        t = put.peek()[4];\\n                        break;\\n                    }\\n                    t = pick.peek()[4];\\n                }\\n            }\\n            while(ltr.size() >= 0 && (pick.size() == 0 || pick.peek()[4] > t)){//process if no one is waiting on right side\\n                while(put.size() > 0 && put.peek()[4] <= t){//add workers who put their box\\n                    max = Math.max(max, put.peek()[4]-put.peek()[3]);\\n                    // System.out.println(Arrays.toString(put.peek()));\\n                    ltr.add(put.remove());\\n                    boxes++;\\n                }\\n                if(ltr.size() > 0 && (n-boxes > put.size()+pick.size()+rtl.size())){//send workers only if boxes are left\\n                    int[] le = ltr.remove();\\n                    t += le[0];\\n                    le[4] = t+le[1];\\n                    pick.add(le);\\n                }else{//if ltr empty at some time check who will be available first\\n                    if(put.size() == 0)break;\\n                    if(rtl.size() != 0)break;\\n                    if(pick.size() != 0 && put.peek()[4] >= pick.peek()[4]){\\n                        t = pick.peek()[4];\\n                        break;\\n                    }\\n                    t = put.peek()[4];\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018641,
                "title": "c-simulation-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n  int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n    // Worker is a struct used to represent the workers.\\n    vector<Worker> workers;\\n    \\n    // leftPq: for workers waiting on the left bank.\\n    // rightPq: for workers waiting on the right bank.\\n    priority_queue<Worker> leftPq, rightPq;\\n    \\n    for (int i = 0; i < k; ++i) {\\n      workers.push_back(Worker(i, time[i][0], time[i][1], time[i][2], time[i][3]));\\n      leftPq.push(*(--workers.end()));\\n    }\\n    \\n    // A timeline of {wTime, wIdx, action}\\n    // action: {0: put down, 1: bridge crossed L->R, 2: picked up, 3: bridge crossed R->L}\\n    priority_queue<tuple<int, int, int>> timePq;\\n    bool bridgeInUse = false;\\n    int maxT = 0;\\n    \\n    int moved = 0, picked = 0;\\n    while (moved < n) {\\n      // The current time in the simulation.\\n      int curT = 0;\\n      \\n      while (!timePq.empty()) {\\n        auto [wTime, wIdx, action] = timePq.top();\\n        auto w = workers[wIdx];\\n        wTime *= -1;\\n        if (curT == 0) {\\n          curT = wTime;\\n        } else if (wTime > curT) {\\n          break;\\n        }\\n        \\n        timePq.pop();\\n        if (action == 0) {\\n          // One block has been successfully moved.\\n          moved++;\\n          // Enqueue on left side of the bridge.\\n          leftPq.push(workers[wIdx]);\\n        } else if (action == 1) {\\n          // Bridge freed up.\\n          bridgeInUse = false;\\n          // Enqueue for picking up\\n          timePq.push({-(curT + w.pO), wIdx, 2});\\n          // Although, it hasn\\'t been picked yet but tests don\\'t pass otherwise :(\\n          picked++;\\n        } else if (action == 2) {\\n          // Enqueue on right side of the bridge.\\n          rightPq.push(workers[wIdx]);\\n        } else if (action == 3) {\\n          // Lazy way to record the last time a worker reaches the left bank.\\n          maxT = max(maxT, curT);\\n          // Bridge freed up.\\n          bridgeInUse = false;\\n          // Enqueue for putting down in the new warehouse.\\n          timePq.push({-(curT + w.pN), wIdx, 0});\\n        }\\n      }\\n      \\n      // Use the bridge only if it is free.\\n      if (!bridgeInUse) {\\n        if (!rightPq.empty()) {\\n          auto w = rightPq.top(); rightPq.pop();\\n          timePq.push({-(curT + w.r2L), w.idx, 3});\\n          bridgeInUse = true;\\n        } else if (!leftPq.empty() && (picked < n)) {\\n          auto w = leftPq.top(); leftPq.pop();\\n          timePq.push({-(curT + w.l2R), w.idx, 1});\\n          bridgeInUse = true;\\n        }\\n      }\\n    }\\n    \\n    return maxT;\\n  }\\n  \\n  struct Worker {\\n    // idx: Index in the array.\\n    // l2R: Time to go from left -> right.\\n    // pO: Time to pick up from old warehous.\\n    // r2L: Time to go from right -> left.\\n    // pN: Time to put down in new warehouse.\\n    int idx, l2R, pO, r2L, pN;\\n    Worker(int idx, int l2R, int pO, int r2L, int pN) :\\n    idx(idx), l2R(l2R), pO(pO), r2L(r2L), pN(pN) {}\\n    \\n    // Comparator for comparing efficiency in the max-heap PQ.\\n    bool operator<(const Worker& other) const {\\n      if (this == &other) return false;\\n      if ((l2R + r2L) == (other.l2R + other.r2L)) return idx < other.idx;\\n      return  (l2R + r2L) < (other.l2R + other.r2L);\\n    }\\n  };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n    // Worker is a struct used to represent the workers.\\n    vector<Worker> workers;\\n    \\n    // leftPq: for workers waiting on the left bank.\\n    // rightPq: for workers waiting on the right bank.\\n    priority_queue<Worker> leftPq, rightPq;\\n    \\n    for (int i = 0; i < k; ++i) {\\n      workers.push_back(Worker(i, time[i][0], time[i][1], time[i][2], time[i][3]));\\n      leftPq.push(*(--workers.end()));\\n    }\\n    \\n    // A timeline of {wTime, wIdx, action}\\n    // action: {0: put down, 1: bridge crossed L->R, 2: picked up, 3: bridge crossed R->L}\\n    priority_queue<tuple<int, int, int>> timePq;\\n    bool bridgeInUse = false;\\n    int maxT = 0;\\n    \\n    int moved = 0, picked = 0;\\n    while (moved < n) {\\n      // The current time in the simulation.\\n      int curT = 0;\\n      \\n      while (!timePq.empty()) {\\n        auto [wTime, wIdx, action] = timePq.top();\\n        auto w = workers[wIdx];\\n        wTime *= -1;\\n        if (curT == 0) {\\n          curT = wTime;\\n        } else if (wTime > curT) {\\n          break;\\n        }\\n        \\n        timePq.pop();\\n        if (action == 0) {\\n          // One block has been successfully moved.\\n          moved++;\\n          // Enqueue on left side of the bridge.\\n          leftPq.push(workers[wIdx]);\\n        } else if (action == 1) {\\n          // Bridge freed up.\\n          bridgeInUse = false;\\n          // Enqueue for picking up\\n          timePq.push({-(curT + w.pO), wIdx, 2});\\n          // Although, it hasn\\'t been picked yet but tests don\\'t pass otherwise :(\\n          picked++;\\n        } else if (action == 2) {\\n          // Enqueue on right side of the bridge.\\n          rightPq.push(workers[wIdx]);\\n        } else if (action == 3) {\\n          // Lazy way to record the last time a worker reaches the left bank.\\n          maxT = max(maxT, curT);\\n          // Bridge freed up.\\n          bridgeInUse = false;\\n          // Enqueue for putting down in the new warehouse.\\n          timePq.push({-(curT + w.pN), wIdx, 0});\\n        }\\n      }\\n      \\n      // Use the bridge only if it is free.\\n      if (!bridgeInUse) {\\n        if (!rightPq.empty()) {\\n          auto w = rightPq.top(); rightPq.pop();\\n          timePq.push({-(curT + w.r2L), w.idx, 3});\\n          bridgeInUse = true;\\n        } else if (!leftPq.empty() && (picked < n)) {\\n          auto w = leftPq.top(); leftPq.pop();\\n          timePq.push({-(curT + w.l2R), w.idx, 1});\\n          bridgeInUse = true;\\n        }\\n      }\\n    }\\n    \\n    return maxT;\\n  }\\n  \\n  struct Worker {\\n    // idx: Index in the array.\\n    // l2R: Time to go from left -> right.\\n    // pO: Time to pick up from old warehous.\\n    // r2L: Time to go from right -> left.\\n    // pN: Time to put down in new warehouse.\\n    int idx, l2R, pO, r2L, pN;\\n    Worker(int idx, int l2R, int pO, int r2L, int pN) :\\n    idx(idx), l2R(l2R), pO(pO), r2L(r2L), pN(pN) {}\\n    \\n    // Comparator for comparing efficiency in the max-heap PQ.\\n    bool operator<(const Worker& other) const {\\n      if (this == &other) return false;\\n      if ((l2R + r2L) == (other.l2R + other.r2L)) return idx < other.idx;\\n      return  (l2R + r2L) < (other.l2R + other.r2L);\\n    }\\n  };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018620,
                "title": "python-java-step-by-step-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- have four priority queues to represent each stage\\n- we go from leftBank -> rightWarehouse -> rightBank -> leftWarehouse -> leftBank\\n- prioritise workers ready at rightBank over those ready at leftBank\\n- if we have already sent a total of n workers, we should stop sending workers\\n- stopping (return) condition: when n == 0, empty rightBank and empty rightWarehouse\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- bank priority queues are compared by efficiency (non increasing order), then index (decreasing order)\\n- warehouse priority queues are compared by completion time (increasing order)\\n- for my algorithm, i tried to write it in such a way that whenever we start the while block, the bridge is definitely open for someone to cross\\n- as we send workers\\n    * check if there is anyone on the rightBank (since we prioritise the rightBank)\\n        * we send the next worker over the bridge\\n        * update our current time\\n        * check if return condition is met\\n        * update worker completion time\\n        * rightBank -> leftWarehouse\\n    * if we want to send more workers (n > 0) and there are workers ready at leftBank\\n        * send the next worker over the bridge\\n        * decrement the number of workers to send\\n        * update current time\\n        * update worker completion time\\n        * leftBank -> rightWarehouse\\n    * if both conditions fail (either rightBank empty, n == 0 or leftBank empty)\\n        * since we prioritise workers coming from rightBank, if the rightWarehouse is not empty, we take the next worker who finishes at the rightWarehouse\\n        * if the rightWarehouse is empty, then we take the next worker who finishes at the leftWarehouse\\n        * update the current time to this next worker\\'s completion time\\n    * before we make the next worker cross the bridge, check if worker\\'s have finished their task at the warehouses considering the current time\\n        * leftWarehouse -> leftBank\\n        * rightWarehouse -> rightBank\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        PriorityQueue<int[]> leftBank = new PriorityQueue<>((a, b) -> (a[4] == b[4]) ? b[5] - a[5] : b[4] - a[4]);\\n        PriorityQueue<int[]> rightBank = new PriorityQueue<>((a, b) -> (a[4] == b[4]) ? b[5] - a[5] : b[4] - a[4]);\\n        PriorityQueue<int[]> leftWarehouse = new PriorityQueue<>((a, b) -> a[6] - b[6]);\\n        PriorityQueue<int[]> rightWarehouse = new PriorityQueue<>((a, b) -> a[6] - b[6]);\\n        for (int i = 0; i < k; i++) {\\n            leftBank.offer(new int[] { time[i][0], time[i][1], time[i][2], time[i][3], time[i][0] + time[i][2], i, 0 });\\n        }\\n        int currTime = 0;\\n        while (n > 0 || !rightBank.isEmpty() || !rightWarehouse.isEmpty()) {\\n            if (!rightBank.isEmpty()) {\\n                int[] fromRightBank = rightBank.poll();\\n                currTime += fromRightBank[2];\\n                if (n == 0 && rightBank.isEmpty() && rightWarehouse.isEmpty()) return currTime;\\n                fromRightBank[6] = currTime + fromRightBank[3];\\n                leftWarehouse.offer(fromRightBank);\\n            } else if (n > 0 && !leftBank.isEmpty()) {\\n                int[] fromLeftBank = leftBank.poll();\\n                n--;\\n                currTime += fromLeftBank[0];\\n                fromLeftBank[6] = currTime + fromLeftBank[1];\\n                rightWarehouse.offer(fromLeftBank);\\n            } else {\\n                int[] fromWarehouse;\\n                if (!rightWarehouse.isEmpty()) {\\n                    fromWarehouse = rightWarehouse.poll();\\n                    rightBank.offer(fromWarehouse);\\n                } else {\\n                    fromWarehouse = leftWarehouse.poll();\\n                    leftBank.offer(fromWarehouse);\\n                }\\n                currTime = fromWarehouse[6];\\n            }\\n            while (!leftWarehouse.isEmpty() && leftWarehouse.peek()[6] <= currTime) {\\n                leftBank.offer(leftWarehouse.poll());\\n            }\\n            while (!rightWarehouse.isEmpty() && rightWarehouse.peek()[6] <= currTime) {\\n                rightBank.offer(rightWarehouse.poll());\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# Python Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        leftBank, rightBank, leftWarehouse, rightWarehouse = [], [], [], []\\n        for i in range(len(time)):\\n            heapq.heappush(leftBank, [-(time[i][0] + time[i][2]), -i, 0, time[i]])\\n        currTime = 0\\n        while n > 0 or rightBank or rightWarehouse:\\n            if rightBank:\\n                fromRightBank = heapq.heappop(rightBank)\\n                currTime += fromRightBank[3][2]\\n                if n == 0 and not rightBank and not rightWarehouse: return currTime\\n                fromRightBank[2] = currTime + fromRightBank[3][3]\\n                heapq.heappush(leftWarehouse, [fromRightBank[2], fromRightBank[0], fromRightBank[1], fromRightBank[3]])\\n            elif n > 0 and leftBank:\\n                fromLeftBank = heapq.heappop(leftBank)\\n                n -= 1\\n                currTime += fromLeftBank[3][0]\\n                fromLeftBank[2] = currTime + fromLeftBank[3][1]\\n                heapq.heappush(rightWarehouse, [fromLeftBank[2], fromLeftBank[0], fromLeftBank[1], fromLeftBank[3]])\\n            else:\\n                if rightWarehouse:\\n                    fromWarehouse = heapq.heappop(rightWarehouse)\\n                    heapq.heappush(rightBank, [fromWarehouse[1], fromWarehouse[2], fromWarehouse[0], fromWarehouse[3]])\\n                else:\\n                    fromWarehouse = heapq.heappop(leftWarehouse)\\n                    heapq.heappush(leftBank, [fromWarehouse[1], fromWarehouse[2], fromWarehouse[0], fromWarehouse[3]])\\n                currTime = fromWarehouse[0]\\n            while leftWarehouse:\\n                fromLeftWarehouse = heapq.heappop(leftWarehouse)\\n                if fromLeftWarehouse[0] <= currTime:\\n                    heapq.heappush(leftBank, [fromLeftWarehouse[1], fromLeftWarehouse[2], fromLeftWarehouse[0], fromLeftWarehouse[3]])\\n                else:\\n                    heapq.heappush(leftWarehouse, fromLeftWarehouse)\\n                    break\\n            while rightWarehouse:\\n                fromRightWarehouse = heapq.heappop(rightWarehouse)\\n                if fromRightWarehouse[0] <= currTime:\\n                    heapq.heappush(rightBank, [fromRightWarehouse[1], fromRightWarehouse[2], fromRightWarehouse[0], fromRightWarehouse[3]])\\n                else:\\n                    heapq.heappush(rightWarehouse, fromRightWarehouse)\\n                    break\\n        return -1\\n            \\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        PriorityQueue<int[]> leftBank = new PriorityQueue<>((a, b) -> (a[4] == b[4]) ? b[5] - a[5] : b[4] - a[4]);\\n        PriorityQueue<int[]> rightBank = new PriorityQueue<>((a, b) -> (a[4] == b[4]) ? b[5] - a[5] : b[4] - a[4]);\\n        PriorityQueue<int[]> leftWarehouse = new PriorityQueue<>((a, b) -> a[6] - b[6]);\\n        PriorityQueue<int[]> rightWarehouse = new PriorityQueue<>((a, b) -> a[6] - b[6]);\\n        for (int i = 0; i < k; i++) {\\n            leftBank.offer(new int[] { time[i][0], time[i][1], time[i][2], time[i][3], time[i][0] + time[i][2], i, 0 });\\n        }\\n        int currTime = 0;\\n        while (n > 0 || !rightBank.isEmpty() || !rightWarehouse.isEmpty()) {\\n            if (!rightBank.isEmpty()) {\\n                int[] fromRightBank = rightBank.poll();\\n                currTime += fromRightBank[2];\\n                if (n == 0 && rightBank.isEmpty() && rightWarehouse.isEmpty()) return currTime;\\n                fromRightBank[6] = currTime + fromRightBank[3];\\n                leftWarehouse.offer(fromRightBank);\\n            } else if (n > 0 && !leftBank.isEmpty()) {\\n                int[] fromLeftBank = leftBank.poll();\\n                n--;\\n                currTime += fromLeftBank[0];\\n                fromLeftBank[6] = currTime + fromLeftBank[1];\\n                rightWarehouse.offer(fromLeftBank);\\n            } else {\\n                int[] fromWarehouse;\\n                if (!rightWarehouse.isEmpty()) {\\n                    fromWarehouse = rightWarehouse.poll();\\n                    rightBank.offer(fromWarehouse);\\n                } else {\\n                    fromWarehouse = leftWarehouse.poll();\\n                    leftBank.offer(fromWarehouse);\\n                }\\n                currTime = fromWarehouse[6];\\n            }\\n            while (!leftWarehouse.isEmpty() && leftWarehouse.peek()[6] <= currTime) {\\n                leftBank.offer(leftWarehouse.poll());\\n            }\\n            while (!rightWarehouse.isEmpty() && rightWarehouse.peek()[6] <= currTime) {\\n                rightBank.offer(rightWarehouse.poll());\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nimport heapq\\n\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        leftBank, rightBank, leftWarehouse, rightWarehouse = [], [], [], []\\n        for i in range(len(time)):\\n            heapq.heappush(leftBank, [-(time[i][0] + time[i][2]), -i, 0, time[i]])\\n        currTime = 0\\n        while n > 0 or rightBank or rightWarehouse:\\n            if rightBank:\\n                fromRightBank = heapq.heappop(rightBank)\\n                currTime += fromRightBank[3][2]\\n                if n == 0 and not rightBank and not rightWarehouse: return currTime\\n                fromRightBank[2] = currTime + fromRightBank[3][3]\\n                heapq.heappush(leftWarehouse, [fromRightBank[2], fromRightBank[0], fromRightBank[1], fromRightBank[3]])\\n            elif n > 0 and leftBank:\\n                fromLeftBank = heapq.heappop(leftBank)\\n                n -= 1\\n                currTime += fromLeftBank[3][0]\\n                fromLeftBank[2] = currTime + fromLeftBank[3][1]\\n                heapq.heappush(rightWarehouse, [fromLeftBank[2], fromLeftBank[0], fromLeftBank[1], fromLeftBank[3]])\\n            else:\\n                if rightWarehouse:\\n                    fromWarehouse = heapq.heappop(rightWarehouse)\\n                    heapq.heappush(rightBank, [fromWarehouse[1], fromWarehouse[2], fromWarehouse[0], fromWarehouse[3]])\\n                else:\\n                    fromWarehouse = heapq.heappop(leftWarehouse)\\n                    heapq.heappush(leftBank, [fromWarehouse[1], fromWarehouse[2], fromWarehouse[0], fromWarehouse[3]])\\n                currTime = fromWarehouse[0]\\n            while leftWarehouse:\\n                fromLeftWarehouse = heapq.heappop(leftWarehouse)\\n                if fromLeftWarehouse[0] <= currTime:\\n                    heapq.heappush(leftBank, [fromLeftWarehouse[1], fromLeftWarehouse[2], fromLeftWarehouse[0], fromLeftWarehouse[3]])\\n                else:\\n                    heapq.heappush(leftWarehouse, fromLeftWarehouse)\\n                    break\\n            while rightWarehouse:\\n                fromRightWarehouse = heapq.heappop(rightWarehouse)\\n                if fromRightWarehouse[0] <= currTime:\\n                    heapq.heappush(rightBank, [fromRightWarehouse[1], fromRightWarehouse[2], fromRightWarehouse[0], fromRightWarehouse[3]])\\n                else:\\n                    heapq.heappush(rightWarehouse, fromRightWarehouse)\\n                    break\\n        return -1\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018506,
                "title": "simulation-using-4-prorityqueue-s-java-nlog-k-self-explainatory-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimulating the process is the way to sove the problem by tracking the time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMost of the explanation is in the code, 4 queues for right&left banks and right&left land for picking and putting boxes.\\n\\n# Complexity\\n- Time complexity:  O(nlogk) k is size of pq, n is boxes.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(4*k)~O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n\\n        //Consider the workers present on left bank, add their index and sort them.\\n        PriorityQueue<Integer> lBank = new PriorityQueue<>((a,b)->{\\n            int[] atime = time[a], btime = time[b];\\n            if(atime[0]+atime[2]==btime[0]+btime[2]) {\\n                return b-a;             //If same efficiency, sort on index\\n            }\\n            else {\\n                return btime[0]+btime[2]-atime[0]-atime[2];\\n            }\\n        });\\n\\n        //Consider the workers present on right bank, add their index and sort them.\\n        PriorityQueue<Integer> rBank = new PriorityQueue<>((a,b)->{\\n            int[] atime = time[a], btime = time[b];\\n            if(atime[0]+atime[2]==btime[0]+btime[2]) {\\n                return b-a;\\n            }\\n            else {\\n                return btime[0]+btime[2]-atime[0]-atime[2];\\n            }\\n        });\\n\\n        //Consider the workers on both lands ans sort them based on time taken by them to \\n        //pick  or put the box.\\n        //This pq will take array of size 2, 2nd element is index, \\n        //1st is currTime after adding the time to complete the task on that bank.\\n        PriorityQueue<int[]> lLand = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        PriorityQueue<int[]> rLand = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        \\n        //Add all of the workers as all are present on left bank.\\n        for(int i=0; i<k; i++) {\\n            lBank.add(i);\\n        }\\n\\n        //Run the loop until all the boxes are shifted.\\n        int currTime = 0;\\n        while(n>0) {\\n\\n            //Check for co-activity, complete the work of all workers on the land, \\n            //which can be done before the currTime and make them ready for the bridge crossing.\\n            while(!lLand.isEmpty()&&lLand.peek()[0]<=currTime) {\\n                lBank.add(lLand.poll()[1]);\\n            }\\n            while(!rLand.isEmpty()&&rLand.peek()[0]<=currTime) {\\n                rBank.add(rLand.poll()[1]);\\n            }\\n            \\n            //Check for workers on right bank, they get the first priority.\\n            //Here we will also shift 1 box, so decrease count.\\n            if(!rBank.isEmpty()) {\\n                int worker = rBank.poll();\\n                currTime += time[worker][2];\\n                lLand.add(new int[]{currTime+time[worker][3],worker});\\n                n--;\\n            }\\n\\n            //If rBank is empty, check for left Bank.\\n            //Also check whether the boxes are left to be shifted.\\n            else if(!lBank.isEmpty()&&n>rBank.size()+rLand.size()) {\\n                int worker = lBank.poll();\\n                currTime += time[worker][0];\\n                rLand.add(new int[]{currTime+time[worker][1],worker});\\n            }\\n\\n            //If no boxes left, make the quickest rLand worker ready to cross bridge.\\n            else if(n==rBank.size()+rLand.size()) {\\n                currTime = rLand.peek()[0];\\n            }\\n\\n            //If Banks are empty and boxes are left, we have to free the workers.\\n            else {\\n                //If right land has no workers, we go for left land and vice-versa.\\n                if(rLand.isEmpty()) {\\n                    currTime = lLand.peek()[0];\\n                }\\n                else if(lLand.isEmpty()) {\\n                    currTime = rLand.peek()[0];\\n                }\\n                //If both are not empty, we take the minTime among to reach the bridge.\\n                else {\\n                    currTime = Math.min(lLand.peek()[0],rLand.peek()[0]);\\n                }\\n            }\\n        }\\n        return currTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n\\n        //Consider the workers present on left bank, add their index and sort them.\\n        PriorityQueue<Integer> lBank = new PriorityQueue<>((a,b)->{\\n            int[] atime = time[a], btime = time[b];\\n            if(atime[0]+atime[2]==btime[0]+btime[2]) {\\n                return b-a;             //If same efficiency, sort on index\\n            }\\n            else {\\n                return btime[0]+btime[2]-atime[0]-atime[2];\\n            }\\n        });\\n\\n        //Consider the workers present on right bank, add their index and sort them.\\n        PriorityQueue<Integer> rBank = new PriorityQueue<>((a,b)->{\\n            int[] atime = time[a], btime = time[b];\\n            if(atime[0]+atime[2]==btime[0]+btime[2]) {\\n                return b-a;\\n            }\\n            else {\\n                return btime[0]+btime[2]-atime[0]-atime[2];\\n            }\\n        });\\n\\n        //Consider the workers on both lands ans sort them based on time taken by them to \\n        //pick  or put the box.\\n        //This pq will take array of size 2, 2nd element is index, \\n        //1st is currTime after adding the time to complete the task on that bank.\\n        PriorityQueue<int[]> lLand = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        PriorityQueue<int[]> rLand = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        \\n        //Add all of the workers as all are present on left bank.\\n        for(int i=0; i<k; i++) {\\n            lBank.add(i);\\n        }\\n\\n        //Run the loop until all the boxes are shifted.\\n        int currTime = 0;\\n        while(n>0) {\\n\\n            //Check for co-activity, complete the work of all workers on the land, \\n            //which can be done before the currTime and make them ready for the bridge crossing.\\n            while(!lLand.isEmpty()&&lLand.peek()[0]<=currTime) {\\n                lBank.add(lLand.poll()[1]);\\n            }\\n            while(!rLand.isEmpty()&&rLand.peek()[0]<=currTime) {\\n                rBank.add(rLand.poll()[1]);\\n            }\\n            \\n            //Check for workers on right bank, they get the first priority.\\n            //Here we will also shift 1 box, so decrease count.\\n            if(!rBank.isEmpty()) {\\n                int worker = rBank.poll();\\n                currTime += time[worker][2];\\n                lLand.add(new int[]{currTime+time[worker][3],worker});\\n                n--;\\n            }\\n\\n            //If rBank is empty, check for left Bank.\\n            //Also check whether the boxes are left to be shifted.\\n            else if(!lBank.isEmpty()&&n>rBank.size()+rLand.size()) {\\n                int worker = lBank.poll();\\n                currTime += time[worker][0];\\n                rLand.add(new int[]{currTime+time[worker][1],worker});\\n            }\\n\\n            //If no boxes left, make the quickest rLand worker ready to cross bridge.\\n            else if(n==rBank.size()+rLand.size()) {\\n                currTime = rLand.peek()[0];\\n            }\\n\\n            //If Banks are empty and boxes are left, we have to free the workers.\\n            else {\\n                //If right land has no workers, we go for left land and vice-versa.\\n                if(rLand.isEmpty()) {\\n                    currTime = lLand.peek()[0];\\n                }\\n                else if(lLand.isEmpty()) {\\n                    currTime = rLand.peek()[0];\\n                }\\n                //If both are not empty, we take the minTime among to reach the bridge.\\n                else {\\n                    currTime = Math.min(lLand.peek()[0],rLand.peek()[0]);\\n                }\\n            }\\n        }\\n        return currTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018504,
                "title": "python-minheap-2-maxheaps-simulation-o-nlogn-klogk",
                "content": "# Intuition\\nWant to process events at earlier time first, so would need a minheap and would want to process workers at the left or right bank with worse efficiency first so would need a maxheap for those. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nminheap stores events with are timestamped events that are at either the locations (bridge, old warehouse, new warehouse).\\nWhenever at a bridge event, check if there is a queue of workers at the right bank first and than the left bank only if their remain boxes at the left bank.  The queue for the banks uses a max heap to get the workers with least efficiency first which means maximum time to cross bridges. \\nNot fully describe method, reading the code should explain other details. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn + klogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n + k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Event:\\n    def __init__(self, timestamp: int, location: str, worker_index: int = None):\\n        self.timestamp = timestamp\\n        self.location = location\\n        self.worker_index = worker_index\\n        self.location_priority = [\\'old_warehouse\\', \\'new_warehouse\\', \\'bridge\\']\\n\\n    def __repr__(self) -> str:\\n        return f\\'timestamp: {self.timestamp}, location: {self.location}\\'\\n\\n    def __lt__(self, other) -> bool:\\n        if self.timestamp != other.timestamp: return self.timestamp < other.timestamp\\n        return self.location_priority.index(self.location) < other.location_priority.index(other.location)\\n\\nclass WorkerEfficiency:\\n    def __init__(self, efficiency: int, worker_index: int):\\n        self.efficiency = efficiency\\n        self.worker_index = worker_index\\n\\n    def __lt__(self, other) -> bool:\\n        return self.efficiency > other.efficiency if self.efficiency != other.efficiency else self.worker_index > other.worker_index\\n\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        # LOCATION VARIABLES\\n        old_warehouse, new_warehouse, bridge = (\\'old_warehouse\\', \\'new_warehouse\\', \\'bridge\\')\\n        # EFFICIENCY FUNCTION\\n        efficiency = lambda index: time[index][0] + time[index][2]\\n        # 3 HEAPS\\n        heapify(minheap := [Event(0, bridge)])\\n        heapify(left_bank_queue := [WorkerEfficiency(efficiency(i), i) for i in range(k)])\\n        right_bank_queue = []\\n        # TRACKING VARIABLES\\n        last_worker_reach_left_bank = 0\\n        bridge_next_available = 0\\n        remaining_old = n\\n        # SIMULATION TILL NO MORE EVENTS\\n        while minheap:\\n            event = heappop(minheap)\\n            if event.location == bridge:\\n                if event.timestamp < bridge_next_available: # bridge in use\\n                    pass\\n                elif right_bank_queue:\\n                    worker_eff = heappop(right_bank_queue)\\n                    i = worker_eff.worker_index\\n                    left_to_right, pick_old, right_to_left, put_new = time[i]\\n                    bridge_next_available = max(bridge_next_available, event.timestamp + right_to_left)\\n                    last_worker_reach_left_bank = max(last_worker_reach_left_bank, event.timestamp + right_to_left)\\n                    heappush(minheap, Event(event.timestamp + right_to_left, bridge))\\n                    heappush(minheap, Event(event.timestamp + right_to_left + put_new, new_warehouse, i))\\n                    heappush(minheap, Event(event.timestamp + right_to_left + put_new, bridge))\\n                elif remaining_old > 0 and left_bank_queue:\\n                    worker_eff = heappop(left_bank_queue)\\n                    i = worker_eff.worker_index\\n                    left_to_right, pick_old, right_to_left, put_new = time[i]\\n                    bridge_next_available = max(bridge_next_available, event.timestamp + left_to_right)\\n                    heappush(minheap, Event(event.timestamp + left_to_right, bridge))\\n                    heappush(minheap, Event(event.timestamp + left_to_right + pick_old, old_warehouse, i))\\n                    heappush(minheap, Event(event.timestamp + left_to_right + pick_old, bridge))\\n                    remaining_old -= 1\\n            elif event.location == old_warehouse:\\n                heappush(right_bank_queue, WorkerEfficiency(efficiency(event.worker_index), event.worker_index))\\n            elif event.location == new_warehouse:\\n                heappush(left_bank_queue, WorkerEfficiency(efficiency(event.worker_index), event.worker_index))\\n        return last_worker_reach_left_bank\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Event:\\n    def __init__(self, timestamp: int, location: str, worker_index: int = None):\\n        self.timestamp = timestamp\\n        self.location = location\\n        self.worker_index = worker_index\\n        self.location_priority = [\\'old_warehouse\\', \\'new_warehouse\\', \\'bridge\\']\\n\\n    def __repr__(self) -> str:\\n        return f\\'timestamp: {self.timestamp}, location: {self.location}\\'\\n\\n    def __lt__(self, other) -> bool:\\n        if self.timestamp != other.timestamp: return self.timestamp < other.timestamp\\n        return self.location_priority.index(self.location) < other.location_priority.index(other.location)\\n\\nclass WorkerEfficiency:\\n    def __init__(self, efficiency: int, worker_index: int):\\n        self.efficiency = efficiency\\n        self.worker_index = worker_index\\n\\n    def __lt__(self, other) -> bool:\\n        return self.efficiency > other.efficiency if self.efficiency != other.efficiency else self.worker_index > other.worker_index\\n\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        # LOCATION VARIABLES\\n        old_warehouse, new_warehouse, bridge = (\\'old_warehouse\\', \\'new_warehouse\\', \\'bridge\\')\\n        # EFFICIENCY FUNCTION\\n        efficiency = lambda index: time[index][0] + time[index][2]\\n        # 3 HEAPS\\n        heapify(minheap := [Event(0, bridge)])\\n        heapify(left_bank_queue := [WorkerEfficiency(efficiency(i), i) for i in range(k)])\\n        right_bank_queue = []\\n        # TRACKING VARIABLES\\n        last_worker_reach_left_bank = 0\\n        bridge_next_available = 0\\n        remaining_old = n\\n        # SIMULATION TILL NO MORE EVENTS\\n        while minheap:\\n            event = heappop(minheap)\\n            if event.location == bridge:\\n                if event.timestamp < bridge_next_available: # bridge in use\\n                    pass\\n                elif right_bank_queue:\\n                    worker_eff = heappop(right_bank_queue)\\n                    i = worker_eff.worker_index\\n                    left_to_right, pick_old, right_to_left, put_new = time[i]\\n                    bridge_next_available = max(bridge_next_available, event.timestamp + right_to_left)\\n                    last_worker_reach_left_bank = max(last_worker_reach_left_bank, event.timestamp + right_to_left)\\n                    heappush(minheap, Event(event.timestamp + right_to_left, bridge))\\n                    heappush(minheap, Event(event.timestamp + right_to_left + put_new, new_warehouse, i))\\n                    heappush(minheap, Event(event.timestamp + right_to_left + put_new, bridge))\\n                elif remaining_old > 0 and left_bank_queue:\\n                    worker_eff = heappop(left_bank_queue)\\n                    i = worker_eff.worker_index\\n                    left_to_right, pick_old, right_to_left, put_new = time[i]\\n                    bridge_next_available = max(bridge_next_available, event.timestamp + left_to_right)\\n                    heappush(minheap, Event(event.timestamp + left_to_right, bridge))\\n                    heappush(minheap, Event(event.timestamp + left_to_right + pick_old, old_warehouse, i))\\n                    heappush(minheap, Event(event.timestamp + left_to_right + pick_old, bridge))\\n                    remaining_old -= 1\\n            elif event.location == old_warehouse:\\n                heappush(right_bank_queue, WorkerEfficiency(efficiency(event.worker_index), event.worker_index))\\n            elif event.location == new_warehouse:\\n                heappush(left_bank_queue, WorkerEfficiency(efficiency(event.worker_index), event.worker_index))\\n        return last_worker_reach_left_bank\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018329,
                "title": "python-solution-using-queues",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimulate the problem by question statement, when the bridge is free, right can go first, if no one on the right then left go\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse 4 priority queues, ready queues are used for decide who goes:\\n- left ready\\n- right ready\\n- left waiting (at the current time, the person has not yet to reach the bridge)\\n- right waiting\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as n boxes are to be picked up\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k) as there are k worker who can be in one of the queues\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        cur = 0 # current time \\n        # lowest eff go first => heap\\n        left_ready = [] # by efficiency, queue to go\\n        left_waiting = [(0, i) for i in range(k)] # by time reaching the bank\\n        right_ready = []\\n        right_waiting = []\\n        done = 0\\n        rem = n\\n        \\n        while True:\\n            # pull all the people to the pq\\n            while left_waiting and left_waiting[0][0] <= cur:\\n                _, idx = heappop(left_waiting)\\n                eff = (-time[idx][0] - time[idx][2], -idx)\\n                heappush(left_ready, (eff, idx))\\n                \\n            while right_waiting and right_waiting[0][0] <= cur:\\n                _, idx = heappop(right_waiting)\\n                eff = (-time[idx][0] - time[idx][2], -idx)\\n                heappush(right_ready, (eff, idx))\\n            \\n            # choose a person to go from the right first\\n            if right_ready:\\n                # this person goes\\n                _, idx = heappop(right_ready)\\n                l_r, pick, r_l, put = time[idx]\\n                cur += r_l # reach the bank\\n                # he will put the box and reach back at\\n                done += 1\\n                if done == n:\\n                    return cur\\n                heappush(left_waiting, (cur + put, idx))\\n            elif left_ready and rem > 0:\\n                # will cross from the left if there\\'re still boxes on the right\\n                rem -= 1\\n                _, idx = heappop(left_ready)\\n                l_r, pick, r_l, put = time[idx]\\n                cur += l_r\\n                heappush(right_waiting, (cur + pick, idx))\\n            else:\\n                # increase the cur by minimum of either left or right bank\\n                if left_waiting and right_waiting:\\n                    cur = min(left_waiting[0][0], right_waiting[0][0])\\n                elif left_waiting:\\n                    cur = left_waiting[0][0]\\n                elif right_waiting:\\n                    cur = right_waiting[0][0]\\n        \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        cur = 0 # current time \\n        # lowest eff go first => heap\\n        left_ready = [] # by efficiency, queue to go\\n        left_waiting = [(0, i) for i in range(k)] # by time reaching the bank\\n        right_ready = []\\n        right_waiting = []\\n        done = 0\\n        rem = n\\n        \\n        while True:\\n            # pull all the people to the pq\\n            while left_waiting and left_waiting[0][0] <= cur:\\n                _, idx = heappop(left_waiting)\\n                eff = (-time[idx][0] - time[idx][2], -idx)\\n                heappush(left_ready, (eff, idx))\\n                \\n            while right_waiting and right_waiting[0][0] <= cur:\\n                _, idx = heappop(right_waiting)\\n                eff = (-time[idx][0] - time[idx][2], -idx)\\n                heappush(right_ready, (eff, idx))\\n            \\n            # choose a person to go from the right first\\n            if right_ready:\\n                # this person goes\\n                _, idx = heappop(right_ready)\\n                l_r, pick, r_l, put = time[idx]\\n                cur += r_l # reach the bank\\n                # he will put the box and reach back at\\n                done += 1\\n                if done == n:\\n                    return cur\\n                heappush(left_waiting, (cur + put, idx))\\n            elif left_ready and rem > 0:\\n                # will cross from the left if there\\'re still boxes on the right\\n                rem -= 1\\n                _, idx = heappop(left_ready)\\n                l_r, pick, r_l, put = time[idx]\\n                cur += l_r\\n                heappush(right_waiting, (cur + pick, idx))\\n            else:\\n                # increase the cur by minimum of either left or right bank\\n                if left_waiting and right_waiting:\\n                    cur = min(left_waiting[0][0], right_waiting[0][0])\\n                elif left_waiting:\\n                    cur = left_waiting[0][0]\\n                elif right_waiting:\\n                    cur = right_waiting[0][0]\\n        \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018181,
                "title": "python-heaps-solution-check-the-logic-and-set-up-the-system",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI knew heaps are needed to solve the problem, but it was tricky to set up the system. This is among the few problems on Leetcode towards object-oriented design rather than algorithms\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used BridgeTime as the global time. It works most of the time, except there could be deadlocks when the workers are still in the old warehouse and the right queue is empty; or workers are still in the new warehouse and there are still boxes that need to be picked up.\\n\\nAlso, every time you update BridgeTime, you need to call fillQueues to update the queues.\\n\\nIt\\'s important to figure out the logic for the while logic to avoid getting into TLE\\n\\n# Code\\n```\\nclass Solution:\\n    # We need 4 heaps to simulate the process, named accordingly\\n    # And we use bridgeTime as the global clock\\n    # We move workers when \\n    # 1. n > 0\\n    # 2. there are queues lining up on the right bank\\n    # 3. there are workers in the old Warehouse\\n    # There could be deadlock at any n because the global time might fall behind the final worker in the old warehouse. Update the global time to avoid the situation\\n    # Whenever we update BridgeTime, we always perform fillQueues\\n    # We follow the rule: only release workers from the warehouses when the global time has passed the time they pick up /  put down the box\\n    # And we process all the rightQ workers before handling the leftQ\\n    # Record the moment which each worker coming out of rightQueue plus the passthrough time\\n    # When we want to pop from the left queue, always check for the right queue is empty.\\n\\n    def fillQueues(self):\\n        while self.oldWarehouse and self.oldWarehouse[0][0] <= self.BridgeTime:\\n            t, ind = heapq.heappop(self.oldWarehouse)\\n            heapq.heappush(self.rightQ, [-self.workers[ind][\"LR\"] - self.workers[ind][\"RL\"], -ind])\\n        while self.newWarehouse and self.newWarehouse[0][0] <= self.BridgeTime:\\n            t, ind = heapq.heappop(self.newWarehouse)\\n            heapq.heappush(self.leftQ, [-self.workers[ind][\"LR\"] - self.workers[ind][\"RL\"], -ind])\\n\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        self.workers = [{} for i in range(k)]\\n        self.leftQ, self.rightQ, self.newWarehouse, self.oldWarehouse = [], [], [], []\\n        for i, worker in enumerate(time):\\n            lr, po, rl, pn = worker\\n            self.workers[i][\"LR\"] = lr\\n            self.workers[i][\"PO\"] = po\\n            self.workers[i][\"RL\"] = rl\\n            self.workers[i][\"PN\"] = pn\\n            heapq.heappush(self.newWarehouse, [0, i])\\n        self.BridgeTime, result = 0, 0\\n        while n > 0 or self.rightQ or self.oldWarehouse: \\n            if not self.rightQ and self.oldWarehouse:\\n                self.BridgeTime = self.oldWarehouse[0][0]\\n                self.fillQueues()\\n            elif not self.leftQ and n > 0 and self.newWarehouse:\\n                self.BridgeTime = self.newWarehouse[0][0]\\n                self.fillQueues()\\n            while self.rightQ:\\n                eff, ind = heapq.heappop(self.rightQ)\\n                self.BridgeTime += self.workers[-ind][\"RL\"]\\n                result = self.BridgeTime\\n                heapq.heappush(self.newWarehouse, [self.BridgeTime + self.workers[-ind][\"PN\"], -ind])\\n                self.fillQueues()\\n            while n > 0 and self.leftQ and not self.rightQ:\\n                eff, ind = heapq.heappop(self.leftQ)\\n                self.BridgeTime += self.workers[-ind][\"LR\"]\\n                heapq.heappush(self.oldWarehouse, [self.BridgeTime + self.workers[-ind][\"PO\"], -ind])\\n                n -= 1\\n                self.fillQueues()\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # We need 4 heaps to simulate the process, named accordingly\\n    # And we use bridgeTime as the global clock\\n    # We move workers when \\n    # 1. n > 0\\n    # 2. there are queues lining up on the right bank\\n    # 3. there are workers in the old Warehouse\\n    # There could be deadlock at any n because the global time might fall behind the final worker in the old warehouse. Update the global time to avoid the situation\\n    # Whenever we update BridgeTime, we always perform fillQueues\\n    # We follow the rule: only release workers from the warehouses when the global time has passed the time they pick up /  put down the box\\n    # And we process all the rightQ workers before handling the leftQ\\n    # Record the moment which each worker coming out of rightQueue plus the passthrough time\\n    # When we want to pop from the left queue, always check for the right queue is empty.\\n\\n    def fillQueues(self):\\n        while self.oldWarehouse and self.oldWarehouse[0][0] <= self.BridgeTime:\\n            t, ind = heapq.heappop(self.oldWarehouse)\\n            heapq.heappush(self.rightQ, [-self.workers[ind][\"LR\"] - self.workers[ind][\"RL\"], -ind])\\n        while self.newWarehouse and self.newWarehouse[0][0] <= self.BridgeTime:\\n            t, ind = heapq.heappop(self.newWarehouse)\\n            heapq.heappush(self.leftQ, [-self.workers[ind][\"LR\"] - self.workers[ind][\"RL\"], -ind])\\n\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        self.workers = [{} for i in range(k)]\\n        self.leftQ, self.rightQ, self.newWarehouse, self.oldWarehouse = [], [], [], []\\n        for i, worker in enumerate(time):\\n            lr, po, rl, pn = worker\\n            self.workers[i][\"LR\"] = lr\\n            self.workers[i][\"PO\"] = po\\n            self.workers[i][\"RL\"] = rl\\n            self.workers[i][\"PN\"] = pn\\n            heapq.heappush(self.newWarehouse, [0, i])\\n        self.BridgeTime, result = 0, 0\\n        while n > 0 or self.rightQ or self.oldWarehouse: \\n            if not self.rightQ and self.oldWarehouse:\\n                self.BridgeTime = self.oldWarehouse[0][0]\\n                self.fillQueues()\\n            elif not self.leftQ and n > 0 and self.newWarehouse:\\n                self.BridgeTime = self.newWarehouse[0][0]\\n                self.fillQueues()\\n            while self.rightQ:\\n                eff, ind = heapq.heappop(self.rightQ)\\n                self.BridgeTime += self.workers[-ind][\"RL\"]\\n                result = self.BridgeTime\\n                heapq.heappush(self.newWarehouse, [self.BridgeTime + self.workers[-ind][\"PN\"], -ind])\\n                self.fillQueues()\\n            while n > 0 and self.leftQ and not self.rightQ:\\n                eff, ind = heapq.heappop(self.leftQ)\\n                self.BridgeTime += self.workers[-ind][\"LR\"]\\n                heapq.heappush(self.oldWarehouse, [self.BridgeTime + self.workers[-ind][\"PO\"], -ind])\\n                n -= 1\\n                self.fillQueues()\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017869,
                "title": "python3-object-oriented-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe simulate the important events for this problem and at each step advance the time unit until the next important event.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe consider 4 heaps: free left workers, free right workers, unloading workers, and loading workers. At any time, each worker is at one of these heaps, except potentially one worker that may be on the bridge. Based on this fact, at each time step, we find the worker that is to finish the task at hand and add them to the next heap they should go to. \\n\\nHeaps are used to get the next worker (having the minimum time left) for each group of tasks.\\n\\n\\n# Complexity\\n- Time complexity: $O(n + k \\\\log k)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(k)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        for i in range(len(time)):\\n            time[i].append(i)\\n        new_time = sorted(time, key=lambda x: (x[0]+x[2], x[4]), reverse=True)\\n        sim = Simulation(n)\\n        \\n        for i, x in enumerate(new_time):\\n            worker = Worker(x[0], x[1], x[2], x[3], i)\\n            sim.add_left_worker(worker)\\n        \\n        return sim.run()\\n            \\n            \\n        \\nclass Worker:\\n    def __init__(self, leftToRight, pickOld, rightToLeft, putNew, priority):\\n        self.leftToRight = leftToRight\\n        self.pickOld = pickOld\\n        self.rightToLeft = rightToLeft\\n        self.putNew = putNew\\n        self.priority = priority\\n        \\n        \\nclass Simulation:\\n    def __init__(self, n):\\n        self.left_workers = []\\n        self.right_workers = []\\n        self.unload_queue = []\\n        self.load_queue = []\\n        self.on_bridge = None\\n        self.sim_TU = 0\\n        self.INF = float(\"inf\")\\n        self.n = n\\n        \\n        \\n    def add_left_worker(self, worker):\\n        heapq.heappush(self.left_workers, (worker.priority, worker))\\n        \\n    def add_right_worker(self, worker):\\n        heapq.heappush(self.right_workers, (worker.priority, worker))\\n        \\n    def add_unload(self, worker, TU):\\n        heapq.heappush(self.unload_queue, (TU, worker.priority, worker))\\n    \\n    def add_load(self, worker, TU):\\n        heapq.heappush(self.load_queue, (TU, worker.priority, worker))\\n        \\n    def add_on_bridge(self, worker, TU, direction):\\n        self.on_bridge = (TU, direction, worker)\\n        \\n    def remove_left_worker(self):\\n        return heapq.heappop(self.left_workers)[-1]\\n    \\n    def remove_right_worker(self):\\n        return heapq.heappop(self.right_workers)[-1]\\n        \\n    def remove_unload_queue(self):\\n        return heapq.heappop(self.unload_queue)[-1]\\n    \\n    def remove_load_queue(self):\\n        return heapq.heappop(self.load_queue)[-1]\\n    \\n        \\n    def run(self):\\n        while(self.n or self.on_bridge or self.right_workers or self.load_queue):\\n            self.advance_TU()\\n        return self.sim_TU\\n        \\n    \\n    def advance_TU(self):\\n        a1 = self.on_bridge[0] if self.on_bridge else self.INF\\n        a2 = self.unload_queue[0][0] if self.unload_queue else self.INF\\n        a3 = self.load_queue[0][0] if self.load_queue else self.INF\\n        \\n        if a1 != self.sim_TU and a2 != self.sim_TU and a3 != self.sim_TU and (not self.on_bridge):\\n            if self.right_workers:\\n                worker = self.remove_right_worker()\\n                self.add_on_bridge(worker, self.sim_TU + worker.rightToLeft, \\'ToLeft\\')\\n            elif self.left_workers and self.n:\\n                worker = self.remove_left_worker()\\n                self.add_on_bridge(worker, self.sim_TU + worker.leftToRight, \\'ToRight\\')\\n                self.n -= 1\\n            a1 = self.on_bridge[0] if self.on_bridge else self.INF\\n        \\n        \\n        if a1 <= a2 and a1 <= a3:\\n            self.sim_TU = a1\\n            worker = self.on_bridge[-1]\\n            if self.on_bridge[1] == \\'ToLeft\\':\\n                self.add_unload(worker, self.sim_TU + worker.putNew)\\n            elif self.on_bridge[1] == \\'ToRight\\':\\n                self.add_load(worker, self.sim_TU + worker.pickOld)\\n            self.on_bridge = None\\n            return\\n        elif a2 <= a1 and a2 <= a3:\\n            self.sim_TU = a2\\n            worker = self.remove_unload_queue()\\n            self.add_left_worker(worker)\\n        elif a3 <= a1 and a3 <= a2:\\n            self.sim_TU = a3\\n            worker = self.remove_load_queue()\\n            self.add_right_worker(worker)\\n            \\n            \\n            \\n    \\n    \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        for i in range(len(time)):\\n            time[i].append(i)\\n        new_time = sorted(time, key=lambda x: (x[0]+x[2], x[4]), reverse=True)\\n        sim = Simulation(n)\\n        \\n        for i, x in enumerate(new_time):\\n            worker = Worker(x[0], x[1], x[2], x[3], i)\\n            sim.add_left_worker(worker)\\n        \\n        return sim.run()\\n            \\n            \\n        \\nclass Worker:\\n    def __init__(self, leftToRight, pickOld, rightToLeft, putNew, priority):\\n        self.leftToRight = leftToRight\\n        self.pickOld = pickOld\\n        self.rightToLeft = rightToLeft\\n        self.putNew = putNew\\n        self.priority = priority\\n        \\n        \\nclass Simulation:\\n    def __init__(self, n):\\n        self.left_workers = []\\n        self.right_workers = []\\n        self.unload_queue = []\\n        self.load_queue = []\\n        self.on_bridge = None\\n        self.sim_TU = 0\\n        self.INF = float(\"inf\")\\n        self.n = n\\n        \\n        \\n    def add_left_worker(self, worker):\\n        heapq.heappush(self.left_workers, (worker.priority, worker))\\n        \\n    def add_right_worker(self, worker):\\n        heapq.heappush(self.right_workers, (worker.priority, worker))\\n        \\n    def add_unload(self, worker, TU):\\n        heapq.heappush(self.unload_queue, (TU, worker.priority, worker))\\n    \\n    def add_load(self, worker, TU):\\n        heapq.heappush(self.load_queue, (TU, worker.priority, worker))\\n        \\n    def add_on_bridge(self, worker, TU, direction):\\n        self.on_bridge = (TU, direction, worker)\\n        \\n    def remove_left_worker(self):\\n        return heapq.heappop(self.left_workers)[-1]\\n    \\n    def remove_right_worker(self):\\n        return heapq.heappop(self.right_workers)[-1]\\n        \\n    def remove_unload_queue(self):\\n        return heapq.heappop(self.unload_queue)[-1]\\n    \\n    def remove_load_queue(self):\\n        return heapq.heappop(self.load_queue)[-1]\\n    \\n        \\n    def run(self):\\n        while(self.n or self.on_bridge or self.right_workers or self.load_queue):\\n            self.advance_TU()\\n        return self.sim_TU\\n        \\n    \\n    def advance_TU(self):\\n        a1 = self.on_bridge[0] if self.on_bridge else self.INF\\n        a2 = self.unload_queue[0][0] if self.unload_queue else self.INF\\n        a3 = self.load_queue[0][0] if self.load_queue else self.INF\\n        \\n        if a1 != self.sim_TU and a2 != self.sim_TU and a3 != self.sim_TU and (not self.on_bridge):\\n            if self.right_workers:\\n                worker = self.remove_right_worker()\\n                self.add_on_bridge(worker, self.sim_TU + worker.rightToLeft, \\'ToLeft\\')\\n            elif self.left_workers and self.n:\\n                worker = self.remove_left_worker()\\n                self.add_on_bridge(worker, self.sim_TU + worker.leftToRight, \\'ToRight\\')\\n                self.n -= 1\\n            a1 = self.on_bridge[0] if self.on_bridge else self.INF\\n        \\n        \\n        if a1 <= a2 and a1 <= a3:\\n            self.sim_TU = a1\\n            worker = self.on_bridge[-1]\\n            if self.on_bridge[1] == \\'ToLeft\\':\\n                self.add_unload(worker, self.sim_TU + worker.putNew)\\n            elif self.on_bridge[1] == \\'ToRight\\':\\n                self.add_load(worker, self.sim_TU + worker.pickOld)\\n            self.on_bridge = None\\n            return\\n        elif a2 <= a1 and a2 <= a3:\\n            self.sim_TU = a2\\n            worker = self.remove_unload_queue()\\n            self.add_left_worker(worker)\\n        elif a3 <= a1 and a3 <= a2:\\n            self.sim_TU = a3\\n            worker = self.remove_load_queue()\\n            self.add_right_worker(worker)\\n            \\n            \\n            \\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017679,
                "title": "c-literal-simulation-no-clever-tricks",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    enum class State\\n    {\\n        WaitingLeft,\\n        CrossingLeftToRight,\\n        Picking,\\n        WaitingRight,\\n        CrossingRightToLeft,\\n        Putting\\n    };\\n    \\n    struct Worker\\n    {\\n        bool operator<(Worker const& other) const \\n        {\\n            if(m_efficiency != other.m_efficiency)\\n                return m_efficiency < other.m_efficiency; \\n            return m_idx < other.m_idx;\\n        }\\n        \\n        uint16_t m_leftToRight;\\n        uint16_t m_pick;\\n        uint16_t m_rightToLeft;\\n        uint16_t m_put;\\n        uint16_t m_efficiency = 0;\\n        uint16_t m_idx = 0;\\n        State m_state = State::WaitingLeft;\\n        int m_currStateTimeRemaining = 0;\\n    };\\n    \\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        \\n        vector<Worker> workers(k);\\n        \\n        // Init worker objects\\n        for(int workerIdx = 0; workerIdx<k; ++workerIdx)\\n        {\\n            auto const& t = time[workerIdx];\\n         \\n            Worker& w = workers[workerIdx];\\n            w.m_leftToRight = t[0];\\n            w.m_pick = t[1];\\n            w.m_rightToLeft = t[2];\\n            w.m_put = t[3];\\n            w.m_efficiency = w.m_leftToRight + w.m_rightToLeft;\\n            w.m_idx = workerIdx;\\n        }\\n        \\n        auto cmpEff = [](Worker* w1, Worker* w2) {return *w1 < *w2;};\\n        auto isDone = [](Worker* w) { return w->m_currStateTimeRemaining==0; };\\n     \\n        // Priority queues for workers waiting to use the bridge\\n        priority_queue<Worker*, vector<Worker*>, decltype(cmpEff)> leftQ(cmpEff), rightQ(cmpEff);\\n\\n        // Warehouses where workers are either picking or putting boxes\\n        vector<Worker*> leftWH, rightWH;\\n\\n        // Bridge\\n        Worker* bridge = nullptr;\\n \\n        // Init all workers waiting on the left shore\\n        for(Worker& w : workers)\\n            leftQ.push(&w);\\n        \\n        int t = 0;\\n        int remainingBoxesToPick = n;\\n        int nbrBoxesOnLeftShore = 0;\\n        while(nbrBoxesOnLeftShore != n) // Once all boxes are back to left shore, sim ends\\n        {\\n            // Populate bridge with less efficient worker if we have some in waiting\\n            if(bridge == nullptr)\\n            {\\n                // If worker is waiting on the right, it has priority\\n                if(!rightQ.empty())\\n                {\\n                    bridge = rightQ.top();\\n                    rightQ.pop();\\n                    bridge->m_state = State::CrossingRightToLeft;\\n                    bridge->m_currStateTimeRemaining = bridge->m_rightToLeft;\\n                }\\n                else if(!leftQ.empty() && (remainingBoxesToPick > 0)) // Only assign a worker if there will be a box to pick\\n                {\\n                    bridge = leftQ.top();\\n                    leftQ.pop();\\n                    bridge->m_state = State::CrossingLeftToRight;\\n                    bridge->m_currStateTimeRemaining = bridge->m_leftToRight;\\n                    --remainingBoxesToPick;\\n                }\\n            }\\n            \\n            // Compute time slice we can safely advance without going negative \\n            // for any active worker time remaining for current state\\n            int minT = INT_MAX;\\n            for(auto w : leftWH)\\n                minT = min(minT, w->m_currStateTimeRemaining);\\n            \\n            for(auto w : rightWH)\\n                minT = min(minT, w->m_currStateTimeRemaining);\\n            \\n            if(bridge != nullptr)\\n                minT = min(minT, bridge->m_currStateTimeRemaining);\\n            \\n            // Add to total time\\n            t += minT;\\n            \\n            // Simulate\\n            for(auto w : leftWH)\\n            {\\n                w->m_currStateTimeRemaining -= minT;\\n                if(w->m_currStateTimeRemaining == 0)\\n                {\\n                    w->m_state = State::WaitingLeft;\\n                    leftQ.push(w); \\n                }\\n            }\\n            leftWH.erase(remove_if(leftWH.begin(), leftWH.end(), isDone), leftWH.end()); \\n            \\n            for(auto w : rightWH)\\n            {\\n                w->m_currStateTimeRemaining -= minT;\\n                if(w->m_currStateTimeRemaining == 0)\\n                {\\n                    w->m_state = State::WaitingRight;\\n                    rightQ.push(w); \\n                }\\n            }\\n            rightWH.erase(remove_if(rightWH.begin(), rightWH.end(), isDone), rightWH.end());\\n                     \\n            if(bridge != nullptr)\\n            {\\n                bridge->m_currStateTimeRemaining -= minT;\\n                if(bridge->m_currStateTimeRemaining==0)\\n                {\\n                    if(bridge->m_state == State::CrossingRightToLeft)\\n                    {\\n                        bridge->m_state = State::Putting;\\n                        bridge->m_currStateTimeRemaining = bridge->m_put;\\n                        leftWH.push_back(bridge);\\n                        nbrBoxesOnLeftShore++;\\n                    }\\n                    else\\n                    {\\n                        bridge->m_state = State::Picking;\\n                        bridge->m_currStateTimeRemaining = bridge->m_pick;\\n                        rightWH.push_back(bridge);\\n                    }\\n                    \\n                    // Bridge is now available\\n                    bridge = nullptr;\\n                }\\n            }\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    enum class State\\n    {\\n        WaitingLeft,\\n        CrossingLeftToRight,\\n        Picking,\\n        WaitingRight,\\n        CrossingRightToLeft,\\n        Putting\\n    };\\n    \\n    struct Worker\\n    {\\n        bool operator<(Worker const& other) const \\n        {\\n            if(m_efficiency != other.m_efficiency)\\n                return m_efficiency < other.m_efficiency; \\n            return m_idx < other.m_idx;\\n        }\\n        \\n        uint16_t m_leftToRight;\\n        uint16_t m_pick;\\n        uint16_t m_rightToLeft;\\n        uint16_t m_put;\\n        uint16_t m_efficiency = 0;\\n        uint16_t m_idx = 0;\\n        State m_state = State::WaitingLeft;\\n        int m_currStateTimeRemaining = 0;\\n    };\\n    \\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        \\n        vector<Worker> workers(k);\\n        \\n        // Init worker objects\\n        for(int workerIdx = 0; workerIdx<k; ++workerIdx)\\n        {\\n            auto const& t = time[workerIdx];\\n         \\n            Worker& w = workers[workerIdx];\\n            w.m_leftToRight = t[0];\\n            w.m_pick = t[1];\\n            w.m_rightToLeft = t[2];\\n            w.m_put = t[3];\\n            w.m_efficiency = w.m_leftToRight + w.m_rightToLeft;\\n            w.m_idx = workerIdx;\\n        }\\n        \\n        auto cmpEff = [](Worker* w1, Worker* w2) {return *w1 < *w2;};\\n        auto isDone = [](Worker* w) { return w->m_currStateTimeRemaining==0; };\\n     \\n        // Priority queues for workers waiting to use the bridge\\n        priority_queue<Worker*, vector<Worker*>, decltype(cmpEff)> leftQ(cmpEff), rightQ(cmpEff);\\n\\n        // Warehouses where workers are either picking or putting boxes\\n        vector<Worker*> leftWH, rightWH;\\n\\n        // Bridge\\n        Worker* bridge = nullptr;\\n \\n        // Init all workers waiting on the left shore\\n        for(Worker& w : workers)\\n            leftQ.push(&w);\\n        \\n        int t = 0;\\n        int remainingBoxesToPick = n;\\n        int nbrBoxesOnLeftShore = 0;\\n        while(nbrBoxesOnLeftShore != n) // Once all boxes are back to left shore, sim ends\\n        {\\n            // Populate bridge with less efficient worker if we have some in waiting\\n            if(bridge == nullptr)\\n            {\\n                // If worker is waiting on the right, it has priority\\n                if(!rightQ.empty())\\n                {\\n                    bridge = rightQ.top();\\n                    rightQ.pop();\\n                    bridge->m_state = State::CrossingRightToLeft;\\n                    bridge->m_currStateTimeRemaining = bridge->m_rightToLeft;\\n                }\\n                else if(!leftQ.empty() && (remainingBoxesToPick > 0)) // Only assign a worker if there will be a box to pick\\n                {\\n                    bridge = leftQ.top();\\n                    leftQ.pop();\\n                    bridge->m_state = State::CrossingLeftToRight;\\n                    bridge->m_currStateTimeRemaining = bridge->m_leftToRight;\\n                    --remainingBoxesToPick;\\n                }\\n            }\\n            \\n            // Compute time slice we can safely advance without going negative \\n            // for any active worker time remaining for current state\\n            int minT = INT_MAX;\\n            for(auto w : leftWH)\\n                minT = min(minT, w->m_currStateTimeRemaining);\\n            \\n            for(auto w : rightWH)\\n                minT = min(minT, w->m_currStateTimeRemaining);\\n            \\n            if(bridge != nullptr)\\n                minT = min(minT, bridge->m_currStateTimeRemaining);\\n            \\n            // Add to total time\\n            t += minT;\\n            \\n            // Simulate\\n            for(auto w : leftWH)\\n            {\\n                w->m_currStateTimeRemaining -= minT;\\n                if(w->m_currStateTimeRemaining == 0)\\n                {\\n                    w->m_state = State::WaitingLeft;\\n                    leftQ.push(w); \\n                }\\n            }\\n            leftWH.erase(remove_if(leftWH.begin(), leftWH.end(), isDone), leftWH.end()); \\n            \\n            for(auto w : rightWH)\\n            {\\n                w->m_currStateTimeRemaining -= minT;\\n                if(w->m_currStateTimeRemaining == 0)\\n                {\\n                    w->m_state = State::WaitingRight;\\n                    rightQ.push(w); \\n                }\\n            }\\n            rightWH.erase(remove_if(rightWH.begin(), rightWH.end(), isDone), rightWH.end());\\n                     \\n            if(bridge != nullptr)\\n            {\\n                bridge->m_currStateTimeRemaining -= minT;\\n                if(bridge->m_currStateTimeRemaining==0)\\n                {\\n                    if(bridge->m_state == State::CrossingRightToLeft)\\n                    {\\n                        bridge->m_state = State::Putting;\\n                        bridge->m_currStateTimeRemaining = bridge->m_put;\\n                        leftWH.push_back(bridge);\\n                        nbrBoxesOnLeftShore++;\\n                    }\\n                    else\\n                    {\\n                        bridge->m_state = State::Picking;\\n                        bridge->m_currStateTimeRemaining = bridge->m_pick;\\n                        rightWH.push_back(bridge);\\n                    }\\n                    \\n                    // Bridge is now available\\n                    bridge = nullptr;\\n                }\\n            }\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017622,
                "title": "python-solution",
                "content": "# Intuition\\nSome intuition from Advent of Code simulation type question. \\n\\n# Approach\\nKeeps two priority queue. The first priority queue, left_minute/right_minute, serves to document the workers whose time are past the current time (who may just finished performing the putting or picking tasks). We pop these workers to the second priority queue, left_heap/right_heap, to check for which worker should move across the bridge. \\n\\nThanks for reading. This is my first time posting a solution.\\n\\n\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        left_heap = []\\n        right_heap = []\\n        left_minute = []\\n        right_minute = []\\n        heapq.heapify(left_heap)\\n        heapq.heapify(right_heap)\\n        heapq.heapify(left_minute)\\n        heapq.heapify(right_minute)\\n        current_time = 0\\n        bridge = None # optional ((idx, time, right to left True, left to right False), None)\\n        \\n        # push to the left_heap with (-(left_to_right + right_to_left), idx)\\n        for idx, (left_to_right, _, right_to_left, _) in enumerate(time):\\n            heapq.heappush(left_heap, (-(left_to_right+right_to_left), -idx))\\n\\n        boxes = 0\\n        sent = 0\\n        cnt = 0\\n        while boxes < n:\\n            # simulate the entire worker base\\n            # If a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge.\\n            \\n\\n            if bridge:\\n                string = \"to the left\" if bridge[2] else \"to the right\"\\n\\n            \\n            if bridge:\\n                idx, finish_time, left_or_right = bridge\\n                string = \"to the left\" if left_or_right else \"to the right\"\\n                current_time = finish_time\\n                left_to_right, pick_old, right_to_left, put_new = time[idx]\\n                if left_or_right: # case of from right to left\\n                    heapq.heappush(left_minute, (current_time + put_new, -left_to_right - right_to_left, -idx))\\n                else: # case of from left to right\\n                    heapq.heappush(right_minute, (current_time + pick_old, -left_to_right - right_to_left, -idx))\\n                bridge = None    \\n            # pop from right_minutes      \\n            while right_minute and right_minute[0][0] <= current_time:\\n                temp_time, _, idx = heapq.heappop(right_minute)\\n                idx = -idx\\n                left_to_right, _,  right_to_left, _ = time[idx]\\n                heapq.heappush(right_heap, (-(left_to_right + right_to_left), -idx))\\n            \\n            ret_var = False\\n            # pop from left_minutes\\n            while left_minute and left_minute[0][0] <= current_time:\\n                temp_time, _, idx = heapq.heappop(left_minute)\\n                idx = -idx\\n                left_to_right, _, right_to_left, _ = time[idx]\\n                heapq.heappush(left_heap, (-(left_to_right + right_to_left), -idx))   \\n                boxes += 1\\n                \\n                if boxes >= n:\\n                    ret_var = True\\n                    current_time = temp_time - time[idx][3]\\n                    break\\n            if ret_var:\\n                break\\n                \\n                \\n            # If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\\n            if right_heap:\\n                # print(\"right heap is now:\", right_heap)\\n                _, idx = heapq.heappop(right_heap)\\n                idx = -idx\\n                # occupy the bridge, add time to the bridge\\n                if bridge:\\n                    raise Exception(\"incorrect bridge setting\")\\n                _, _, right_to_left, _ = time[idx]\\n                bridge = (idx, current_time + right_to_left, True)\\n                \\n                \\n            # If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\\n            elif left_heap:\\n                # print(\"left heap is now:\", left_heap)\\n                _, idx = heapq.heappop(left_heap)\\n                idx = -idx\\n                if bridge:\\n                    raise Exception(\"incorrect bridge setting\")\\n                left_to_right, _, _, _ = time[idx]\\n                if n - sent > 0:\\n                    bridge = (idx, current_time + left_to_right, False)\\n                    sent += 1\\n            \\n            # if not left heap and not right heap, update the time to the smallest between left time and right time\\n            else:\\n                left = float(\\'inf\\') if not left_minute else left_minute[0][0]\\n                right = float(\\'inf\\') if not right_minute else right_minute[0][0]\\n                if left_minute or right_minute:\\n                    current_time = min(left, right)\\n                # print(current_time)\\n            \\n            # print(\"finished -- current boxes on the left hand is:\", boxes, \"\\\\n\")\\n\\n            \\n\\n        return current_time\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        left_heap = []\\n        right_heap = []\\n        left_minute = []\\n        right_minute = []\\n        heapq.heapify(left_heap)\\n        heapq.heapify(right_heap)\\n        heapq.heapify(left_minute)\\n        heapq.heapify(right_minute)\\n        current_time = 0\\n        bridge = None # optional ((idx, time, right to left True, left to right False), None)\\n        \\n        # push to the left_heap with (-(left_to_right + right_to_left), idx)\\n        for idx, (left_to_right, _, right_to_left, _) in enumerate(time):\\n            heapq.heappush(left_heap, (-(left_to_right+right_to_left), -idx))\\n\\n        boxes = 0\\n        sent = 0\\n        cnt = 0\\n        while boxes < n:\\n            # simulate the entire worker base\\n            # If a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge.\\n            \\n\\n            if bridge:\\n                string = \"to the left\" if bridge[2] else \"to the right\"\\n\\n            \\n            if bridge:\\n                idx, finish_time, left_or_right = bridge\\n                string = \"to the left\" if left_or_right else \"to the right\"\\n                current_time = finish_time\\n                left_to_right, pick_old, right_to_left, put_new = time[idx]\\n                if left_or_right: # case of from right to left\\n                    heapq.heappush(left_minute, (current_time + put_new, -left_to_right - right_to_left, -idx))\\n                else: # case of from left to right\\n                    heapq.heappush(right_minute, (current_time + pick_old, -left_to_right - right_to_left, -idx))\\n                bridge = None    \\n            # pop from right_minutes      \\n            while right_minute and right_minute[0][0] <= current_time:\\n                temp_time, _, idx = heapq.heappop(right_minute)\\n                idx = -idx\\n                left_to_right, _,  right_to_left, _ = time[idx]\\n                heapq.heappush(right_heap, (-(left_to_right + right_to_left), -idx))\\n            \\n            ret_var = False\\n            # pop from left_minutes\\n            while left_minute and left_minute[0][0] <= current_time:\\n                temp_time, _, idx = heapq.heappop(left_minute)\\n                idx = -idx\\n                left_to_right, _, right_to_left, _ = time[idx]\\n                heapq.heappush(left_heap, (-(left_to_right + right_to_left), -idx))   \\n                boxes += 1\\n                \\n                if boxes >= n:\\n                    ret_var = True\\n                    current_time = temp_time - time[idx][3]\\n                    break\\n            if ret_var:\\n                break\\n                \\n                \\n            # If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\\n            if right_heap:\\n                # print(\"right heap is now:\", right_heap)\\n                _, idx = heapq.heappop(right_heap)\\n                idx = -idx\\n                # occupy the bridge, add time to the bridge\\n                if bridge:\\n                    raise Exception(\"incorrect bridge setting\")\\n                _, _, right_to_left, _ = time[idx]\\n                bridge = (idx, current_time + right_to_left, True)\\n                \\n                \\n            # If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\\n            elif left_heap:\\n                # print(\"left heap is now:\", left_heap)\\n                _, idx = heapq.heappop(left_heap)\\n                idx = -idx\\n                if bridge:\\n                    raise Exception(\"incorrect bridge setting\")\\n                left_to_right, _, _, _ = time[idx]\\n                if n - sent > 0:\\n                    bridge = (idx, current_time + left_to_right, False)\\n                    sent += 1\\n            \\n            # if not left heap and not right heap, update the time to the smallest between left time and right time\\n            else:\\n                left = float(\\'inf\\') if not left_minute else left_minute[0][0]\\n                right = float(\\'inf\\') if not right_minute else right_minute[0][0]\\n                if left_minute or right_minute:\\n                    current_time = min(left, right)\\n                # print(current_time)\\n            \\n            # print(\"finished -- current boxes on the left hand is:\", boxes, \"\\\\n\")\\n\\n            \\n\\n        return current_time\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017620,
                "title": "python-solution",
                "content": "# Intuition\\nSome intuition from Advent of Code simulation type question. \\n\\n# Approach\\nKeeps two priority queue. The first priority queue, left_minute/right_minute, serves to document the workers whose time are past the current time (who may just finished performing the putting or picking tasks). We pop these workers to the second priority queue, left_heap/right_heap, to check for which worker should move across the bridge. \\n\\nThanks for reading. This is my first time posting a solution.\\n\\n\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        left_heap = []\\n        right_heap = []\\n        left_minute = []\\n        right_minute = []\\n        heapq.heapify(left_heap)\\n        heapq.heapify(right_heap)\\n        heapq.heapify(left_minute)\\n        heapq.heapify(right_minute)\\n        current_time = 0\\n        bridge = None # optional ((idx, time, right to left True, left to right False), None)\\n        \\n        # push to the left_heap with (-(left_to_right + right_to_left), idx)\\n        for idx, (left_to_right, _, right_to_left, _) in enumerate(time):\\n            heapq.heappush(left_heap, (-(left_to_right+right_to_left), -idx))\\n\\n        boxes = 0\\n        sent = 0\\n        cnt = 0\\n        while boxes < n:\\n            # simulate the entire worker base\\n            # If a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge.\\n            \\n\\n            if bridge:\\n                string = \"to the left\" if bridge[2] else \"to the right\"\\n\\n            \\n            if bridge:\\n                idx, finish_time, left_or_right = bridge\\n                string = \"to the left\" if left_or_right else \"to the right\"\\n                current_time = finish_time\\n                left_to_right, pick_old, right_to_left, put_new = time[idx]\\n                if left_or_right: # case of from right to left\\n                    heapq.heappush(left_minute, (current_time + put_new, -left_to_right - right_to_left, -idx))\\n                else: # case of from left to right\\n                    heapq.heappush(right_minute, (current_time + pick_old, -left_to_right - right_to_left, -idx))\\n                bridge = None    \\n            # pop from right_minutes      \\n            while right_minute and right_minute[0][0] <= current_time:\\n                temp_time, _, idx = heapq.heappop(right_minute)\\n                idx = -idx\\n                left_to_right, _,  right_to_left, _ = time[idx]\\n                heapq.heappush(right_heap, (-(left_to_right + right_to_left), -idx))\\n            \\n            ret_var = False\\n            # pop from left_minutes\\n            while left_minute and left_minute[0][0] <= current_time:\\n                temp_time, _, idx = heapq.heappop(left_minute)\\n                idx = -idx\\n                left_to_right, _, right_to_left, _ = time[idx]\\n                heapq.heappush(left_heap, (-(left_to_right + right_to_left), -idx))   \\n                boxes += 1\\n                \\n                if boxes >= n:\\n                    ret_var = True\\n                    current_time = temp_time - time[idx][3]\\n                    break\\n            if ret_var:\\n                break\\n                \\n                \\n            # If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\\n            if right_heap:\\n                # print(\"right heap is now:\", right_heap)\\n                _, idx = heapq.heappop(right_heap)\\n                idx = -idx\\n                # occupy the bridge, add time to the bridge\\n                if bridge:\\n                    raise Exception(\"incorrect bridge setting\")\\n                _, _, right_to_left, _ = time[idx]\\n                bridge = (idx, current_time + right_to_left, True)\\n                \\n                \\n            # If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\\n            elif left_heap:\\n                # print(\"left heap is now:\", left_heap)\\n                _, idx = heapq.heappop(left_heap)\\n                idx = -idx\\n                if bridge:\\n                    raise Exception(\"incorrect bridge setting\")\\n                left_to_right, _, _, _ = time[idx]\\n                if n - sent > 0:\\n                    bridge = (idx, current_time + left_to_right, False)\\n                    sent += 1\\n            \\n            # if not left heap and not right heap, update the time to the smallest between left time and right time\\n            else:\\n                left = float(\\'inf\\') if not left_minute else left_minute[0][0]\\n                right = float(\\'inf\\') if not right_minute else right_minute[0][0]\\n                if left_minute or right_minute:\\n                    current_time = min(left, right)\\n                # print(current_time)\\n            \\n            # print(\"finished -- current boxes on the left hand is:\", boxes, \"\\\\n\")\\n\\n            \\n\\n        return current_time\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        left_heap = []\\n        right_heap = []\\n        left_minute = []\\n        right_minute = []\\n        heapq.heapify(left_heap)\\n        heapq.heapify(right_heap)\\n        heapq.heapify(left_minute)\\n        heapq.heapify(right_minute)\\n        current_time = 0\\n        bridge = None # optional ((idx, time, right to left True, left to right False), None)\\n        \\n        # push to the left_heap with (-(left_to_right + right_to_left), idx)\\n        for idx, (left_to_right, _, right_to_left, _) in enumerate(time):\\n            heapq.heappush(left_heap, (-(left_to_right+right_to_left), -idx))\\n\\n        boxes = 0\\n        sent = 0\\n        cnt = 0\\n        while boxes < n:\\n            # simulate the entire worker base\\n            # If a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge.\\n            \\n\\n            if bridge:\\n                string = \"to the left\" if bridge[2] else \"to the right\"\\n\\n            \\n            if bridge:\\n                idx, finish_time, left_or_right = bridge\\n                string = \"to the left\" if left_or_right else \"to the right\"\\n                current_time = finish_time\\n                left_to_right, pick_old, right_to_left, put_new = time[idx]\\n                if left_or_right: # case of from right to left\\n                    heapq.heappush(left_minute, (current_time + put_new, -left_to_right - right_to_left, -idx))\\n                else: # case of from left to right\\n                    heapq.heappush(right_minute, (current_time + pick_old, -left_to_right - right_to_left, -idx))\\n                bridge = None    \\n            # pop from right_minutes      \\n            while right_minute and right_minute[0][0] <= current_time:\\n                temp_time, _, idx = heapq.heappop(right_minute)\\n                idx = -idx\\n                left_to_right, _,  right_to_left, _ = time[idx]\\n                heapq.heappush(right_heap, (-(left_to_right + right_to_left), -idx))\\n            \\n            ret_var = False\\n            # pop from left_minutes\\n            while left_minute and left_minute[0][0] <= current_time:\\n                temp_time, _, idx = heapq.heappop(left_minute)\\n                idx = -idx\\n                left_to_right, _, right_to_left, _ = time[idx]\\n                heapq.heappush(left_heap, (-(left_to_right + right_to_left), -idx))   \\n                boxes += 1\\n                \\n                if boxes >= n:\\n                    ret_var = True\\n                    current_time = temp_time - time[idx][3]\\n                    break\\n            if ret_var:\\n                break\\n                \\n                \\n            # If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\\n            if right_heap:\\n                # print(\"right heap is now:\", right_heap)\\n                _, idx = heapq.heappop(right_heap)\\n                idx = -idx\\n                # occupy the bridge, add time to the bridge\\n                if bridge:\\n                    raise Exception(\"incorrect bridge setting\")\\n                _, _, right_to_left, _ = time[idx]\\n                bridge = (idx, current_time + right_to_left, True)\\n                \\n                \\n            # If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\\n            elif left_heap:\\n                # print(\"left heap is now:\", left_heap)\\n                _, idx = heapq.heappop(left_heap)\\n                idx = -idx\\n                if bridge:\\n                    raise Exception(\"incorrect bridge setting\")\\n                left_to_right, _, _, _ = time[idx]\\n                if n - sent > 0:\\n                    bridge = (idx, current_time + left_to_right, False)\\n                    sent += 1\\n            \\n            # if not left heap and not right heap, update the time to the smallest between left time and right time\\n            else:\\n                left = float(\\'inf\\') if not left_minute else left_minute[0][0]\\n                right = float(\\'inf\\') if not right_minute else right_minute[0][0]\\n                if left_minute or right_minute:\\n                    current_time = min(left, right)\\n                # print(current_time)\\n            \\n            # print(\"finished -- current boxes on the left hand is:\", boxes, \"\\\\n\")\\n\\n            \\n\\n        return current_time\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017602,
                "title": "python-priority-queue-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem requires careful design and understanding how to break quite long description into simple pieces.\\nThe idea behind solution is to simulate all operations performed by workers. To effiently select the least efficient worker we will use a heap (priority queue). For ordering all events happening during the simulation, we will use another heap. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo keep track of events in simulation, we can use a heap where every element is an instance of `Event` class. There are five different event types:\\n1. Event when a worker completes crossing a bridge from left to right - `L2RFINISH`\\n2. Event when a worker finishes picking up a box from an old warehouse - `PICKED`\\n3. Event when a worker completes crossing from right to left - `R2LFINISH`\\n4. Event when a worker completes putting a box in a new warehous - `PUT`\\n5. A dummy event to initialize simulation - `DUMMY`\\n\\nAll events are ordered by the time when they happen. A heap allows to choose the earliest available event with `O(log(k))` complexity.\\nAfter every `R2LFINISH` event we increment the number of boxes reached the left side by one and finish the simulation when that number equals to the number of boxes - `n` (as asked in the problem statement).\\n\\nBased on the rules described in the problem, we should pick the least effecient worker when decising who is crossing the bridge if it is not currently being crossed by other worker. We select the least efficient worker when choosing who will be crossing from left to right and from right to left independently. Therefore, it is convenient to create `Worker` class and define comparison between its instances based on the efficiency rule.\\nAt the beginning of the simulation all workers are on the left side, so we have a heap with all worker in the direction from left to right, and an empty heap with workers ready to cross from right to left.\\n\\n# Complexity\\n- Time complexity:\\nEvent heap can have at most 4*k events (because every worker can be working on only one thing at a time). Two heaps with worker can be as large as k also (we have at most k workers ready to cross the bridge in either direction).\\nTherefore the overall complexity is `O(n*log(k))`.\\n\\n- Space complexity:\\n`O(k)` for three heaps\\n\\n# Code\\n```\\nclass Worker:\\n    def __init__(self, i, params):\\n        l2r, pick, r2l, put = params\\n        self.i = i\\n        self.l2r = l2r\\n        self.pick = pick\\n        self.r2l = r2l\\n        self.put = put\\n        \\n    def __lt__(self, other):\\n        thisTime = self.l2r + self.r2l\\n        otherTime = other.l2r + other.r2l\\n        return thisTime > otherTime or (thisTime == otherTime and self.i > other.i)\\n\\n\\nL2RFINISH = 0\\nPICKED = 1\\nR2LFINISH = 2\\nPUT = 3\\nDUMMY = 4\\n\\nclass Event:\\n    def __init__(self, eType, time, worker):\\n        self.type = eType\\n        self.time = time\\n        self.worker = worker\\n        \\n    def __lt__(self, other):\\n        return self.time < other.time\\n\\n\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        l2rWorkers = [Worker(i, time[i]) for i in range(len(time))]\\n        heapq.heapify(l2rWorkers)\\n        r2lWorkers = []\\n        events = [Event(DUMMY, 0, None)]\\n        crossing = False\\n        leftToPick = n\\n        reachedLeft = 0\\n        while True:\\n            currTime = events[0].time\\n            while events and events[0].time == currTime:\\n                currEvent = heapq.heappop(events)\\n                if currEvent.type == L2RFINISH:\\n                    crossing = False\\n                    newEvent = Event(PICKED, currTime + currEvent.worker.pick, worker)\\n                    heapq.heappush(events, newEvent)\\n                elif currEvent.type == PICKED:\\n                    heapq.heappush(r2lWorkers, currEvent.worker)\\n                elif currEvent.type == R2LFINISH:\\n                    crossing = False\\n                    newEvent = Event(PUT, currTime + currEvent.worker.put, worker)\\n                    heapq.heappush(events, newEvent)\\n                    reachedLeft += 1\\n                    if reachedLeft == n:\\n                        return currTime\\n                elif currEvent.type == PUT:\\n                    heapq.heappush(l2rWorkers, currEvent.worker)\\n                \\n            if not crossing:\\n                if r2lWorkers:\\n                    crossing = True\\n                    worker = heapq.heappop(r2lWorkers)\\n                    newEvent = Event(R2LFINISH, currTime + worker.r2l, worker)\\n                    heapq.heappush(events, newEvent)\\n                elif leftToPick and l2rWorkers:\\n                    crossing = True\\n                    leftToPick -= 1\\n                    worker = heapq.heappop(l2rWorkers)\\n                    newEvent = Event(L2RFINISH, currTime + worker.l2r, worker)\\n                    heapq.heappush(events, newEvent)\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Worker:\\n    def __init__(self, i, params):\\n        l2r, pick, r2l, put = params\\n        self.i = i\\n        self.l2r = l2r\\n        self.pick = pick\\n        self.r2l = r2l\\n        self.put = put\\n        \\n    def __lt__(self, other):\\n        thisTime = self.l2r + self.r2l\\n        otherTime = other.l2r + other.r2l\\n        return thisTime > otherTime or (thisTime == otherTime and self.i > other.i)\\n\\n\\nL2RFINISH = 0\\nPICKED = 1\\nR2LFINISH = 2\\nPUT = 3\\nDUMMY = 4\\n\\nclass Event:\\n    def __init__(self, eType, time, worker):\\n        self.type = eType\\n        self.time = time\\n        self.worker = worker\\n        \\n    def __lt__(self, other):\\n        return self.time < other.time\\n\\n\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        l2rWorkers = [Worker(i, time[i]) for i in range(len(time))]\\n        heapq.heapify(l2rWorkers)\\n        r2lWorkers = []\\n        events = [Event(DUMMY, 0, None)]\\n        crossing = False\\n        leftToPick = n\\n        reachedLeft = 0\\n        while True:\\n            currTime = events[0].time\\n            while events and events[0].time == currTime:\\n                currEvent = heapq.heappop(events)\\n                if currEvent.type == L2RFINISH:\\n                    crossing = False\\n                    newEvent = Event(PICKED, currTime + currEvent.worker.pick, worker)\\n                    heapq.heappush(events, newEvent)\\n                elif currEvent.type == PICKED:\\n                    heapq.heappush(r2lWorkers, currEvent.worker)\\n                elif currEvent.type == R2LFINISH:\\n                    crossing = False\\n                    newEvent = Event(PUT, currTime + currEvent.worker.put, worker)\\n                    heapq.heappush(events, newEvent)\\n                    reachedLeft += 1\\n                    if reachedLeft == n:\\n                        return currTime\\n                elif currEvent.type == PUT:\\n                    heapq.heappush(l2rWorkers, currEvent.worker)\\n                \\n            if not crossing:\\n                if r2lWorkers:\\n                    crossing = True\\n                    worker = heapq.heappop(r2lWorkers)\\n                    newEvent = Event(R2LFINISH, currTime + worker.r2l, worker)\\n                    heapq.heappush(events, newEvent)\\n                elif leftToPick and l2rWorkers:\\n                    crossing = True\\n                    leftToPick -= 1\\n                    worker = heapq.heappop(l2rWorkers)\\n                    newEvent = Event(L2RFINISH, currTime + worker.l2r, worker)\\n                    heapq.heappush(events, newEvent)\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017572,
                "title": "simple-python-solution-with-min-heaps",
                "content": "We have 4 min heaps, left/right keep track of workers waiting on left and right side.\\nup/down keep track of works picking up boxes on right or putting down on left\\n\\nWhenever we increment time, we see that we can always increment to after the next bridge action is done since the bridge can only be used by one person and isn\\'t affected by picking up/putting down boxes.\\n\\nWe keep track of 2 additional variables: needdone is how many more crossing to the left we need to be finished\\nneedpicked is how many more crossing to the right we need to stop sending more workers to the right\\n```py\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n\\t\\t# add -(lr + rl), -i to start of tuple to make least efficient workers show up first\\n        efftimes = [(-(lr + rl), -i, lr, po, rl, pn)\\n                    for i, (lr, po, rl, pn) in enumerate(time)]  \\n        heapq.heapify(efftimes)\\n        needdone = n  # decreases when we cross left (can return at 0)\\n        needpicked = n  # decreases when we cross right (can stop crossing at 0)\\n        left = efftimes\\n        up, right, down = [], [], []\\n        time = 0\\n        # 0: eff, 1: idx, 2: lr, 3: up, 4: rl, 5: down    indices for each worker (assuming no prefixed times)\\n        while needdone:\\n            # 3 if statements to see minimal time for next significant action (which is bridge crossing if it exists, if not, picking/putting)\\n            if right:\\n                worker = heapq.heappop(right)\\n                time += worker[4]\\n                needdone -= 1\\n                if needdone == 0:\\n                    return time\\n                heapq.heappush(down, (time + worker[5],) + worker)\\n            elif left and needpicked > 0:\\n                worker = heapq.heappop(left)\\n                time += worker[2]\\n                heapq.heappush(up, (time + worker[3],) + worker)\\n                needpicked -= 1\\n            else:\\n                # find min time out of up/down\\n                time = float(\\'inf\\')\\n                if up:\\n                    time = up[0][0]\\n                if down:\\n                    time = min(time, down[0][0])\\n\\n            # while we can put down more boxes\\n            while down and down[0][0] <= time:\\n                worker = heapq.heappop(down)\\n                heapq.heappush(left, worker[1:])\\n\\n            # while we can pick up more boxes\\n            while up and up[0][0] <= time:\\n                worker = heapq.heappop(up)\\n                heapq.heappush(right, (worker[1:]))\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n\\t\\t# add -(lr + rl), -i to start of tuple to make least efficient workers show up first\\n        efftimes = [(-(lr + rl), -i, lr, po, rl, pn)\\n                    for i, (lr, po, rl, pn) in enumerate(time)]  \\n        heapq.heapify(efftimes)\\n        needdone = n  # decreases when we cross left (can return at 0)\\n        needpicked = n  # decreases when we cross right (can stop crossing at 0)\\n        left = efftimes\\n        up, right, down = [], [], []\\n        time = 0\\n        # 0: eff, 1: idx, 2: lr, 3: up, 4: rl, 5: down    indices for each worker (assuming no prefixed times)\\n        while needdone:\\n            # 3 if statements to see minimal time for next significant action (which is bridge crossing if it exists, if not, picking/putting)\\n            if right:\\n                worker = heapq.heappop(right)\\n                time += worker[4]\\n                needdone -= 1\\n                if needdone == 0:\\n                    return time\\n                heapq.heappush(down, (time + worker[5],) + worker)\\n            elif left and needpicked > 0:\\n                worker = heapq.heappop(left)\\n                time += worker[2]\\n                heapq.heappush(up, (time + worker[3],) + worker)\\n                needpicked -= 1\\n            else:\\n                # find min time out of up/down\\n                time = float(\\'inf\\')\\n                if up:\\n                    time = up[0][0]\\n                if down:\\n                    time = min(time, down[0][0])\\n\\n            # while we can put down more boxes\\n            while down and down[0][0] <= time:\\n                worker = heapq.heappop(down)\\n                heapq.heappush(left, worker[1:])\\n\\n            # while we can pick up more boxes\\n            while up and up[0][0] <= time:\\n                worker = heapq.heappop(up)\\n                heapq.heappush(right, (worker[1:]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017444,
                "title": "simulation-with-priority-queues",
                "content": "# Intuition\\nSimulate the process based on the problem description.\\nBridge crossing is a blocking event. We advance a clock largely based on that.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static constexpr bool kDebug = false;\\n    \\n    enum Side {\\n        SOURCE = 0, TARGET\\n    };        \\n    \\n    struct Worker {\\n        int index;\\n        int time_delta_source;\\n        int time_delta_target;\\n        int time_delta_forward;\\n        int time_delta_reverse;            \\n        \\n        inline int transport_time() const {\\n            return time_delta_forward + time_delta_reverse;\\n        }\\n\\n        bool operator<(const Worker &rhs) const {\\n            const auto td_lhs = transport_time();\\n            const auto td_rhs = rhs.transport_time();\\n            if (td_lhs != td_rhs) {\\n                return td_lhs < td_rhs;\\n            }\\n            return index < rhs.index;\\n        }\\n    };\\n    \\n    struct Event {\\n        int time;\\n        Side side;\\n        Worker worker;\\n        \\n        bool operator>(const Event &rhs) const {\\n            return time > rhs.time;\\n        }\\n    };\\n    \\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& entries) {\\n        if constexpr (kDebug) {\\n            std::cout << \"#### items = \" << n << \" & workers = \" << k << std::endl;\\n        }\\n        \\n        std::priority_queue<Worker> workers_ord_source, workers_ord_target;\\n        int index = 0;\\n        for (auto &&entry : entries) {\\n            workers_ord_source.push(Worker{\\n                .index = index++,\\n                .time_delta_source = entry[3],\\n                .time_delta_target = entry[1],\\n                .time_delta_forward = entry[0],\\n                .time_delta_reverse = entry[2]\\n            });\\n        }\\n        \\n        std::priority_queue<Event, std::vector<Event>, std::greater<Event>> events_ord;\\n        int global_time = 0;\\n        int finalized_boxes = 0;\\n        int untouched_boxes = n;\\n        int last_arrival_time = -1;\\n        while (finalized_boxes < n) {\\n            // If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. \\n            // If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\\n            if (!workers_ord_target.empty()) {\\n                auto worker = workers_ord_target.top();\\n                workers_ord_target.pop();\\n                global_time += worker.time_delta_reverse;\\n                last_arrival_time = global_time;                \\n                if constexpr (kDebug) {\\n                    std::cout << \" | worker \" << worker.index << \" crossed[<<] @ \" << global_time << std::endl;\\n                }                \\n                \\n                events_ord.push(Event{\\n                    .time = global_time + worker.time_delta_source,\\n                    .side = Side::SOURCE,\\n                    .worker = std::move(worker)\\n                });                                \\n            } else if (!workers_ord_source.empty() && (untouched_boxes > 0)) {\\n                auto worker = workers_ord_source.top();\\n                workers_ord_source.pop();\\n                global_time += worker.time_delta_forward;\\n                --untouched_boxes;\\n\\n                if constexpr (kDebug) {\\n                    std::cout << \" | worker \" << worker.index << \" crossed[>>] @ \" << global_time << std::endl;\\n                }                                \\n                \\n                events_ord.push(Event{\\n                    .time = global_time + worker.time_delta_target,\\n                    .side = Side::TARGET,\\n                    .worker = std::move(worker)\\n                });\\n            } else if (!events_ord.empty()) {\\n                global_time = events_ord.top().time;\\n            } else {\\n                // panic\\n                assert(false);\\n            }\\n            \\n            for (; !events_ord.empty(); events_ord.pop()) {\\n                const auto &curr = events_ord.top();\\n                if (curr.time > global_time) {\\n                    break;\\n                }\\n                if (curr.side == Side::SOURCE) {                                        \\n                    ++finalized_boxes;\\n                    if constexpr (kDebug) {\\n                        std::cout << \" | worker \" << curr.worker.index << \" put box @ \" << curr.time << std::endl;\\n                    }                \\n                    \\n                    workers_ord_source.push(std::move(curr.worker));\\n                } else {                    \\n                    if constexpr (kDebug) {\\n                        std::cout << \" | worker \" << curr.worker.index << \" get box @ \" << curr.time << std::endl;\\n                    }                \\n                    \\n                    workers_ord_target.push(std::move(curr.worker));\\n                }\\n            }\\n        }\\n        assert(workers_ord_target.empty());\\n        \\n        return last_arrival_time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    static constexpr bool kDebug = false;\\n    \\n    enum Side {\\n        SOURCE = 0, TARGET\\n    };        \\n    \\n    struct Worker {\\n        int index;\\n        int time_delta_source;\\n        int time_delta_target;\\n        int time_delta_forward;\\n        int time_delta_reverse;            \\n        \\n        inline int transport_time() const {\\n            return time_delta_forward + time_delta_reverse;\\n        }\\n\\n        bool operator<(const Worker &rhs) const {\\n            const auto td_lhs = transport_time();\\n            const auto td_rhs = rhs.transport_time();\\n            if (td_lhs != td_rhs) {\\n                return td_lhs < td_rhs;\\n            }\\n            return index < rhs.index;\\n        }\\n    };\\n    \\n    struct Event {\\n        int time;\\n        Side side;\\n        Worker worker;\\n        \\n        bool operator>(const Event &rhs) const {\\n            return time > rhs.time;\\n        }\\n    };\\n    \\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& entries) {\\n        if constexpr (kDebug) {\\n            std::cout << \"#### items = \" << n << \" & workers = \" << k << std::endl;\\n        }\\n        \\n        std::priority_queue<Worker> workers_ord_source, workers_ord_target;\\n        int index = 0;\\n        for (auto &&entry : entries) {\\n            workers_ord_source.push(Worker{\\n                .index = index++,\\n                .time_delta_source = entry[3],\\n                .time_delta_target = entry[1],\\n                .time_delta_forward = entry[0],\\n                .time_delta_reverse = entry[2]\\n            });\\n        }\\n        \\n        std::priority_queue<Event, std::vector<Event>, std::greater<Event>> events_ord;\\n        int global_time = 0;\\n        int finalized_boxes = 0;\\n        int untouched_boxes = n;\\n        int last_arrival_time = -1;\\n        while (finalized_boxes < n) {\\n            // If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. \\n            // If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\\n            if (!workers_ord_target.empty()) {\\n                auto worker = workers_ord_target.top();\\n                workers_ord_target.pop();\\n                global_time += worker.time_delta_reverse;\\n                last_arrival_time = global_time;                \\n                if constexpr (kDebug) {\\n                    std::cout << \" | worker \" << worker.index << \" crossed[<<] @ \" << global_time << std::endl;\\n                }                \\n                \\n                events_ord.push(Event{\\n                    .time = global_time + worker.time_delta_source,\\n                    .side = Side::SOURCE,\\n                    .worker = std::move(worker)\\n                });                                \\n            } else if (!workers_ord_source.empty() && (untouched_boxes > 0)) {\\n                auto worker = workers_ord_source.top();\\n                workers_ord_source.pop();\\n                global_time += worker.time_delta_forward;\\n                --untouched_boxes;\\n\\n                if constexpr (kDebug) {\\n                    std::cout << \" | worker \" << worker.index << \" crossed[>>] @ \" << global_time << std::endl;\\n                }                                \\n                \\n                events_ord.push(Event{\\n                    .time = global_time + worker.time_delta_target,\\n                    .side = Side::TARGET,\\n                    .worker = std::move(worker)\\n                });\\n            } else if (!events_ord.empty()) {\\n                global_time = events_ord.top().time;\\n            } else {\\n                // panic\\n                assert(false);\\n            }\\n            \\n            for (; !events_ord.empty(); events_ord.pop()) {\\n                const auto &curr = events_ord.top();\\n                if (curr.time > global_time) {\\n                    break;\\n                }\\n                if (curr.side == Side::SOURCE) {                                        \\n                    ++finalized_boxes;\\n                    if constexpr (kDebug) {\\n                        std::cout << \" | worker \" << curr.worker.index << \" put box @ \" << curr.time << std::endl;\\n                    }                \\n                    \\n                    workers_ord_source.push(std::move(curr.worker));\\n                } else {                    \\n                    if constexpr (kDebug) {\\n                        std::cout << \" | worker \" << curr.worker.index << \" get box @ \" << curr.time << std::endl;\\n                    }                \\n                    \\n                    workers_ord_target.push(std::move(curr.worker));\\n                }\\n            }\\n        }\\n        assert(workers_ord_target.empty());\\n        \\n        return last_arrival_time;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3017355,
                "title": "priority-queue-simulation-c",
                "content": "# Approach\\n\\nWe can group the workers into 5 groups depending on what the are doing-\\n1) LeftWait - Waiting on the left side of the bridge, to get on the bridge\\n2) LeftWork - Working on the left side of the bridge (putting parcel in warehouse)\\n3) RightWait - Same as left wait but on right side of the bridge\\n4) RightWork - Same as LeftWork but on right side\\n5) bridgeUser - Worker on the bridge right now\\n\\nNow we can look at each time a worker leaves one group and enters another group, lets call this an event.\\n\\nNow we must go through all the events and move workers from one group to another. \\n\\nWe have reached our answer when-\\n1) All boxes have been picked up from the right side\\n2) No worker is waiting or working on the right side of the bridge\\n3) No worker is on the bridge\\n\\n\\n\\n# Code\\n```\\n\\nclass CompareWait {\\n   public:\\n    bool operator()(array<int, 5> &a, array<int, 5> &b) {\\n        if (a[0] + a[2] != b[0] + b[2]) return a[0] + a[2] < b[0] + b[2];\\n        return a[4] < b[4];\\n    }\\n};\\n\\nclass CompareWork {\\n   public:\\n    bool operator()(array<int, 6> &a, array<int, 6> &b) { return a[5] > b[5]; }\\n};\\n\\ninline array<int, 5> conv5(array<int, 6> a) {\\n    return {a[0], a[1], a[2], a[3], a[4]};\\n}\\n\\ninline array<int, 6> conv6(array<int, 5> a) {\\n    return {a[0], a[1], a[2], a[3], a[4], 0};\\n}\\n\\nclass Solution {\\n   public:\\n    int findCrossingTime(int n, int k, vector<vector<int>> &time) {\\n        vector<array<int, 5>> t(k);\\n        priority_queue<array<int, 5>, vector<array<int, 5>>, CompareWait>\\n            leftWait, rightWait;\\n        for (int x = 0; x < k; x++) {\\n            t[x][0] = time[x][0];\\n            t[x][1] = time[x][1];\\n            t[x][2] = time[x][2];\\n            t[x][3] = time[x][3];\\n            t[x][4] = x;\\n            leftWait.push(t[x]);\\n        }\\n        int objectsLeft = n;\\n        priority_queue<array<int, 6>, vector<array<int, 6>>, CompareWork>\\n            leftWork, rightWork;\\n        priority_queue<int, vector<int>, greater<int>> events;\\n        events.push(0);\\n        array<int, 6> bridgeUser;\\n        bridgeUser[0] = -1;\\n        while (events.size()) {\\n            int event = events.top();\\n            events.pop();\\n            if (events.size() && events.top() == event) continue;\\n\\n            if (bridgeUser[0] != -1 && bridgeUser[5] == event) {  // bridge\\n                auto newRightWork = bridgeUser;\\n                newRightWork[5] = newRightWork[1] + event;\\n                events.push(newRightWork[5]);\\n                rightWork.push(newRightWork);\\n                bridgeUser[0] = -1;\\n                objectsLeft--;\\n            }\\n\\n            if (bridgeUser[0] != -1 && -bridgeUser[5] == event) {  // bridge\\n                auto newLeftWork = bridgeUser;\\n                newLeftWork[5] = newLeftWork[3] + event;\\n                events.push(newLeftWork[5]);\\n                leftWork.push(newLeftWork);\\n                bridgeUser[0] = -1;\\n            }\\n\\n            while(!leftWork.empty() && leftWork.top()[5] == event) {\\n                leftWait.push(conv5(leftWork.top()));\\n                leftWork.pop();\\n            }\\n\\n            while(!rightWork.empty() && rightWork.top()[5] == event) {\\n                rightWait.push(conv5(rightWork.top()));\\n                rightWork.pop();\\n            }\\n\\n            if (bridgeUser[0] != -1) continue;\\n\\n            if (objectsLeft <= 0 && rightWork.empty() && rightWait.empty() &&\\n                bridgeUser[0] == -1)\\n                return event;\\n\\n            if (!rightWait.empty()) {\\n                bridgeUser = conv6(rightWait.top());\\n                bridgeUser[5] = event + bridgeUser[2];\\n                events.push(bridgeUser[5]);\\n                bridgeUser[5] *= -1;\\n                rightWait.pop();\\n            } else if (!leftWait.empty() && objectsLeft>0) {\\n                bridgeUser = conv6(leftWait.top());\\n                bridgeUser[5] = event + bridgeUser[0];\\n                events.push(bridgeUser[5]);\\n                leftWait.pop();\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass CompareWait {\\n   public:\\n    bool operator()(array<int, 5> &a, array<int, 5> &b) {\\n        if (a[0] + a[2] != b[0] + b[2]) return a[0] + a[2] < b[0] + b[2];\\n        return a[4] < b[4];\\n    }\\n};\\n\\nclass CompareWork {\\n   public:\\n    bool operator()(array<int, 6> &a, array<int, 6> &b) { return a[5] > b[5]; }\\n};\\n\\ninline array<int, 5> conv5(array<int, 6> a) {\\n    return {a[0], a[1], a[2], a[3], a[4]};\\n}\\n\\ninline array<int, 6> conv6(array<int, 5> a) {\\n    return {a[0], a[1], a[2], a[3], a[4], 0};\\n}\\n\\nclass Solution {\\n   public:\\n    int findCrossingTime(int n, int k, vector<vector<int>> &time) {\\n        vector<array<int, 5>> t(k);\\n        priority_queue<array<int, 5>, vector<array<int, 5>>, CompareWait>\\n            leftWait, rightWait;\\n        for (int x = 0; x < k; x++) {\\n            t[x][0] = time[x][0];\\n            t[x][1] = time[x][1];\\n            t[x][2] = time[x][2];\\n            t[x][3] = time[x][3];\\n            t[x][4] = x;\\n            leftWait.push(t[x]);\\n        }\\n        int objectsLeft = n;\\n        priority_queue<array<int, 6>, vector<array<int, 6>>, CompareWork>\\n            leftWork, rightWork;\\n        priority_queue<int, vector<int>, greater<int>> events;\\n        events.push(0);\\n        array<int, 6> bridgeUser;\\n        bridgeUser[0] = -1;\\n        while (events.size()) {\\n            int event = events.top();\\n            events.pop();\\n            if (events.size() && events.top() == event) continue;\\n\\n            if (bridgeUser[0] != -1 && bridgeUser[5] == event) {  // bridge\\n                auto newRightWork = bridgeUser;\\n                newRightWork[5] = newRightWork[1] + event;\\n                events.push(newRightWork[5]);\\n                rightWork.push(newRightWork);\\n                bridgeUser[0] = -1;\\n                objectsLeft--;\\n            }\\n\\n            if (bridgeUser[0] != -1 && -bridgeUser[5] == event) {  // bridge\\n                auto newLeftWork = bridgeUser;\\n                newLeftWork[5] = newLeftWork[3] + event;\\n                events.push(newLeftWork[5]);\\n                leftWork.push(newLeftWork);\\n                bridgeUser[0] = -1;\\n            }\\n\\n            while(!leftWork.empty() && leftWork.top()[5] == event) {\\n                leftWait.push(conv5(leftWork.top()));\\n                leftWork.pop();\\n            }\\n\\n            while(!rightWork.empty() && rightWork.top()[5] == event) {\\n                rightWait.push(conv5(rightWork.top()));\\n                rightWork.pop();\\n            }\\n\\n            if (bridgeUser[0] != -1) continue;\\n\\n            if (objectsLeft <= 0 && rightWork.empty() && rightWait.empty() &&\\n                bridgeUser[0] == -1)\\n                return event;\\n\\n            if (!rightWait.empty()) {\\n                bridgeUser = conv6(rightWait.top());\\n                bridgeUser[5] = event + bridgeUser[2];\\n                events.push(bridgeUser[5]);\\n                bridgeUser[5] *= -1;\\n                rightWait.pop();\\n            } else if (!leftWait.empty() && objectsLeft>0) {\\n                bridgeUser = conv6(leftWait.top());\\n                bridgeUser[5] = event + bridgeUser[0];\\n                events.push(bridgeUser[5]);\\n                leftWait.pop();\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017310,
                "title": "c-two-priority-queue-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing two priority queues to simulate the procedure. No need to distinguish the two sides bridge waiting list and working list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEvery time one worker gains access of the bridge (pop from the waiting priority queue), immediately push its finish time of working (pick or put) to the working list priority queue, and update the timestamp with the time of crossing bridge.\\n\\nWaiting list priority queue is used for generating the correct order based on the rules. Therefore, every \"past\" events should be pushed into this priority queue and reset the first timestamp field.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        using ai = array<int, 4>;\\n        priority_queue<ai, vector<ai>, greater<>> pq;   // time, type, l+r, index\\n        priority_queue<ai, vector<ai>, greater<>> waiting;\\n        // type: r2l:0, l2r:1\\n        for (int i = 0; i < k; i++) {\\n            pq.push({0, 1, -time[i][0] - time[i][2], -i});\\n        }\\n        \\n        int ans = 0;\\n        int ts = 0;\\n        while (!pq.empty()) {\\n            while (waiting.empty() || (!pq.empty() && ts >= pq.top()[0])) {\\n                auto p = pq.top();\\n                pq.pop();\\n\\n                if (waiting.empty()) ts = max(ts, p[0]);\\n\\n                p[0] = 0;   // reset timestamp for waiting pq\\n                waiting.push(p);\\n            }\\n\\n            auto p = waiting.top();\\n            waiting.pop();\\n\\n            int type = p[1];\\n            int idx = -p[3];\\n            \\n            if (type == 0) {    // r to l\\n                ts += time[idx][2];\\n                ans = ts;\\n                pq.push({ts + time[idx][3], 1, -time[idx][0] - time[idx][2], -idx});\\n            } else {            // l to r\\n                if (n <= 0) continue;\\n                ts += time[idx][0];\\n                pq.push({ts + time[idx][1], 0, -time[idx][0] - time[idx][2], -idx});\\n\\n                n--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        using ai = array<int, 4>;\\n        priority_queue<ai, vector<ai>, greater<>> pq;   // time, type, l+r, index\\n        priority_queue<ai, vector<ai>, greater<>> waiting;\\n        // type: r2l:0, l2r:1\\n        for (int i = 0; i < k; i++) {\\n            pq.push({0, 1, -time[i][0] - time[i][2], -i});\\n        }\\n        \\n        int ans = 0;\\n        int ts = 0;\\n        while (!pq.empty()) {\\n            while (waiting.empty() || (!pq.empty() && ts >= pq.top()[0])) {\\n                auto p = pq.top();\\n                pq.pop();\\n\\n                if (waiting.empty()) ts = max(ts, p[0]);\\n\\n                p[0] = 0;   // reset timestamp for waiting pq\\n                waiting.push(p);\\n            }\\n\\n            auto p = waiting.top();\\n            waiting.pop();\\n\\n            int type = p[1];\\n            int idx = -p[3];\\n            \\n            if (type == 0) {    // r to l\\n                ts += time[idx][2];\\n                ans = ts;\\n                pq.push({ts + time[idx][3], 1, -time[idx][0] - time[idx][2], -idx});\\n            } else {            // l to r\\n                if (n <= 0) continue;\\n                ts += time[idx][0];\\n                pq.push({ts + time[idx][1], 0, -time[idx][0] - time[idx][2], -idx});\\n\\n                n--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017301,
                "title": "python3-4-heaps-solution",
                "content": "# Note\\nSolved it after contest so it\\'s a bit painful :)\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConstraint is good enough for simulation (based on lengthy description)\\n- Two heaps come to my mind first. But the fact that only 1 person can cross at a time and there seems to be a need to keep track of workers who are picking/putting so 4 heaps may be needed.\\n- Tips: I\\'d like to think of heap as an extra dimension for sorting sometimes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        #leftRight, pickOld, rightLeft, putNew\\n        #Only 1 person crossing at a time\\n        heapLeft = [] #leftRight + rightLeft, i\\n        \\n        heapRight = []\\n        pickLeft, pickRight = [[0, i] for i in range(k)], []\\n        t = 0\\n        nLeft = n\\n        nxtAvail = 0 \\n        \\n        while n:\\n\\n            while pickRight and pickRight[0][0] <= t:\\n                tmpTime, i = heapq.heappop(pickRight)\\n                heapq.heappush(heapRight, [-time[i][0] - time[i][2], -i, tmpTime])\\n            \\n            while pickLeft and pickLeft[0][0] <= t:\\n                tmpTime, i = heapq.heappop(pickLeft)\\n                heapq.heappush(heapLeft, [-time[i][0] - time[i][2], -i, tmpTime])\\n                \\n            \\n            if heapRight:\\n                totalTime, i, _ = heapq.heappop(heapRight)\\n                totalTime, i = -totalTime, -i\\n                \\n                nxtAvail = time[i][2] + t\\n                heapq.heappush(pickLeft, [nxtAvail + time[i][3], i])\\n                n -= 1\\n                if n == 0:\\n                    return nxtAvail\\n                \\n                t = nxtAvail\\n                \\n            elif heapLeft and nLeft:\\n                totalTime, i, _ = heapq.heappop(heapLeft)\\n                totalTime, i = -totalTime, -i\\n                \\n                nxtAvail = time[i][0] + t\\n                heapq.heappush(pickRight, [nxtAvail + time[i][1], i])\\n                nLeft -= 1\\n                t = nxtAvail\\n\\n            #Could be optimized by choosing next time from pickLeft/pickRight\\n            else: #Nothing to process so increase time\\n                t += 1\\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        #leftRight, pickOld, rightLeft, putNew\\n        #Only 1 person crossing at a time\\n        heapLeft = [] #leftRight + rightLeft, i\\n        \\n        heapRight = []\\n        pickLeft, pickRight = [[0, i] for i in range(k)], []\\n        t = 0\\n        nLeft = n\\n        nxtAvail = 0 \\n        \\n        while n:\\n\\n            while pickRight and pickRight[0][0] <= t:\\n                tmpTime, i = heapq.heappop(pickRight)\\n                heapq.heappush(heapRight, [-time[i][0] - time[i][2], -i, tmpTime])\\n            \\n            while pickLeft and pickLeft[0][0] <= t:\\n                tmpTime, i = heapq.heappop(pickLeft)\\n                heapq.heappush(heapLeft, [-time[i][0] - time[i][2], -i, tmpTime])\\n                \\n            \\n            if heapRight:\\n                totalTime, i, _ = heapq.heappop(heapRight)\\n                totalTime, i = -totalTime, -i\\n                \\n                nxtAvail = time[i][2] + t\\n                heapq.heappush(pickLeft, [nxtAvail + time[i][3], i])\\n                n -= 1\\n                if n == 0:\\n                    return nxtAvail\\n                \\n                t = nxtAvail\\n                \\n            elif heapLeft and nLeft:\\n                totalTime, i, _ = heapq.heappop(heapLeft)\\n                totalTime, i = -totalTime, -i\\n                \\n                nxtAvail = time[i][0] + t\\n                heapq.heappush(pickRight, [nxtAvail + time[i][1], i])\\n                nLeft -= 1\\n                t = nxtAvail\\n\\n            #Could be optimized by choosing next time from pickLeft/pickRight\\n            else: #Nothing to process so increase time\\n                t += 1\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017252,
                "title": "python-heap-solution-beat-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn general we can categorize this as a priority queue problem, since it is all about choosing the right worker based on priority value. Therefore heap is the right solution for it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to maintain 4 heaps, left (worker who\\'s waiting on left side to cross the bridge), right (worker who\\'s waiting on right side to cross the bridge), leftShip (worker who\\'s currently putting stuff on new warehouse), rightShip (worker who\\'s currently picking stuff up on old warehouse). We need to keep track of the timestamp in order to pop the item from heap appropriately.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nk \\\\log(k) )$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        efficiency = [x[0] + x[2] for x in time]\\n        counter = 0\\n        left = [(-efficiency[i], -i) for i in range(k)]\\n        right = []\\n        shipLeft = []\\n        shipRight = []\\n        heapq.heapify(left)\\n        heapq.heapify(right)\\n        heapq.heapify(shipLeft)\\n        heapq.heapify(shipRight)\\n        currTime = 0\\n        pending = 0\\n        while counter < n:\\n            while len(shipLeft):\\n                (val, idx) = heapq.heappop(shipLeft)\\n                if val <= currTime:\\n                    heapq.heappush(left, (-efficiency[idx], -idx))\\n                    counter += 1\\n                else:\\n                    heapq.heappush(shipLeft, (val, idx))\\n                    break\\n            while len(shipRight):\\n                (val, idx) = heapq.heappop(shipRight)\\n                if val <= currTime:\\n                    heapq.heappush(right, (-efficiency[idx], -idx))\\n                else:\\n                    heapq.heappush(shipRight, (val, idx))\\n                    break\\n            \\n            if len(right):\\n                (val, idx) = heapq.heappop(right)\\n                idx = -idx\\n                currTime += time[idx][2]\\n                heapq.heappush(shipLeft, (currTime+time[idx][3], idx))\\n                if len(right) == 0 and len(shipRight) == 0 and pending == n:\\n                    return currTime\\n            elif len(left):\\n                if pending < n:\\n                    (val, idx) = heapq.heappop(left)\\n                    idx = -idx\\n                    pending += 1\\n                    currTime += time[idx][0]\\n                    heapq.heappush(shipRight, (currTime+time[idx][1], idx))\\n                else:\\n                    while len(left):\\n                        heapq.heappop(left)\\n            else:\\n                l = (sys.maxsize, None)\\n                r = (sys.maxsize, None)\\n                if len(shipRight):\\n                    r = heapq.heappop(shipRight)\\n                    heapq.heappush(shipRight, r)\\n                if len(shipLeft):\\n                    l = heapq.heappop(shipLeft)\\n                    heapq.heappush(shipLeft, l)\\n                currTime = min(l[0], r[0])\\n                \\n        return currTime\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        efficiency = [x[0] + x[2] for x in time]\\n        counter = 0\\n        left = [(-efficiency[i], -i) for i in range(k)]\\n        right = []\\n        shipLeft = []\\n        shipRight = []\\n        heapq.heapify(left)\\n        heapq.heapify(right)\\n        heapq.heapify(shipLeft)\\n        heapq.heapify(shipRight)\\n        currTime = 0\\n        pending = 0\\n        while counter < n:\\n            while len(shipLeft):\\n                (val, idx) = heapq.heappop(shipLeft)\\n                if val <= currTime:\\n                    heapq.heappush(left, (-efficiency[idx], -idx))\\n                    counter += 1\\n                else:\\n                    heapq.heappush(shipLeft, (val, idx))\\n                    break\\n            while len(shipRight):\\n                (val, idx) = heapq.heappop(shipRight)\\n                if val <= currTime:\\n                    heapq.heappush(right, (-efficiency[idx], -idx))\\n                else:\\n                    heapq.heappush(shipRight, (val, idx))\\n                    break\\n            \\n            if len(right):\\n                (val, idx) = heapq.heappop(right)\\n                idx = -idx\\n                currTime += time[idx][2]\\n                heapq.heappush(shipLeft, (currTime+time[idx][3], idx))\\n                if len(right) == 0 and len(shipRight) == 0 and pending == n:\\n                    return currTime\\n            elif len(left):\\n                if pending < n:\\n                    (val, idx) = heapq.heappop(left)\\n                    idx = -idx\\n                    pending += 1\\n                    currTime += time[idx][0]\\n                    heapq.heappush(shipRight, (currTime+time[idx][1], idx))\\n                else:\\n                    while len(left):\\n                        heapq.heappop(left)\\n            else:\\n                l = (sys.maxsize, None)\\n                r = (sys.maxsize, None)\\n                if len(shipRight):\\n                    r = heapq.heappop(shipRight)\\n                    heapq.heappush(shipRight, r)\\n                if len(shipLeft):\\n                    l = heapq.heappop(shipLeft)\\n                    heapq.heappush(shipLeft, l)\\n                currTime = min(l[0], r[0])\\n                \\n        return currTime\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017119,
                "title": "three-priorityqueue-left-right-events-java-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHold two priority queues on the left and right side\\nHold another priority queue for the events to simulate the process\\n\\n# Complexity\\n- Time complexity:\\n$$O(nklog(k))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n$$O(k+n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\n\\n\\nclass Solution {\\n    // create a new comparator to find the less efficient worker \\n    class EffiComparator implements Comparator<Integer>{\\n        int[][] time;\\n        public EffiComparator(int[][] time){\\n            this.time = time;\\n        }\\n        public int compare(Integer a, Integer b){\\n            if (time[a][0]+time[a][2]==time[b][0]+time[b][2]){\\n                return b-a;\\n            }\\n            else {\\n                return time[b][0]+time[b][2] - (time[a][0]+time[a][2]); \\n            }\\n        }\\n    }\\n\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        // hold two priority queues on the left and right side\\n        // we can do nothing when some one is on the bridge\\n        // when that one has crossed the bridge, we need to set the worker to pick things and detect whether the workers has picked up things and go back\\n        PriorityQueue<Integer> left = new PriorityQueue<>(new EffiComparator(time)); \\n        for(int i=0;i<k;i++){\\n            left.add(i);\\n        }\\n        PriorityQueue<Integer> right = new PriorityQueue<>(new EffiComparator(time)); \\n        int cumtime = 0;\\n        int cnt = 0;\\n        int cntWorker = 0; // worker on the way\\n        // event, 0 finish time, 1 type, 2 worker index\\n        // event queue, type meaning: 0, cross the bridge from left to right, 1 pick old stuff finish, 2 cross the bridge from right to left, 3 return stuff finish\\n        PriorityQueue<int[]> events = new PriorityQueue<>(\\n            (n1,n2)->n1[0]-n2[0]);\\n        int curr = left.poll();\\n        events.add(new int[]{cumtime+time[curr][0],0,curr});\\n        cntWorker++;\\n        boolean bridgeInUse = true;\\n        while(cnt < n){\\n            int[] event = events.poll();\\n            cumtime = event[0];\\n            int type = event[1];\\n            curr = event[2]; \\n            //System.out.println(cumtime+\" \"+type+\" \"+curr);\\n            if (type==0){\\n                // let the worker to get box\\n                events.add(new int[]{cumtime+time[curr][1],1,curr});\\n                // release the bridge\\n                bridgeInUse = false;\\n            }\\n            else if (type==1){\\n                // add worker on the right side\\n                right.add(curr);\\n            }\\n            else if (type==2){\\n                // let the worker to return the box\\n                events.add(new int[]{cumtime+time[curr][3],3,curr});\\n                // release the bridge\\n                bridgeInUse = false;\\n            }\\n            else if (type==3){\\n                cnt++;\\n                // add worker on the left side\\n                left.add(curr);\\n            }\\n            // if there are events on the queue and the event has the same time as current time, wait until next event\\n            if (!events.isEmpty()&&events.peek()[0]==cumtime) continue; \\n            // after every event, we need to update the bridge\\n            // check whether the bridge is in use \\n            if (!bridgeInUse){\\n                // send worker\\n                if (!right.isEmpty()){\\n                    int worker = right.poll();\\n                    events.add(new int[]{cumtime+time[worker][2],2,worker});\\n                    bridgeInUse = true;\\n                }\\n                else {\\n                    // send new worker\\n                    if (cntWorker<n&&!left.isEmpty()){\\n                        int worker = left.poll();\\n                        events.add(new int[]{cumtime+time[worker][0],0,worker});\\n                        cntWorker++;\\n                        bridgeInUse = true;\\n                    }\\n                }\\n            }\\n        }\\n        return cumtime-time[curr][3];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    // create a new comparator to find the less efficient worker \\n    class EffiComparator implements Comparator<Integer>{\\n        int[][] time;\\n        public EffiComparator(int[][] time){\\n            this.time = time;\\n        }\\n        public int compare(Integer a, Integer b){\\n            if (time[a][0]+time[a][2]==time[b][0]+time[b][2]){\\n                return b-a;\\n            }\\n            else {\\n                return time[b][0]+time[b][2] - (time[a][0]+time[a][2]); \\n            }\\n        }\\n    }\\n\\n    public int findCrossingTime(int n, int k, int[][] time) {\\n        // hold two priority queues on the left and right side\\n        // we can do nothing when some one is on the bridge\\n        // when that one has crossed the bridge, we need to set the worker to pick things and detect whether the workers has picked up things and go back\\n        PriorityQueue<Integer> left = new PriorityQueue<>(new EffiComparator(time)); \\n        for(int i=0;i<k;i++){\\n            left.add(i);\\n        }\\n        PriorityQueue<Integer> right = new PriorityQueue<>(new EffiComparator(time)); \\n        int cumtime = 0;\\n        int cnt = 0;\\n        int cntWorker = 0; // worker on the way\\n        // event, 0 finish time, 1 type, 2 worker index\\n        // event queue, type meaning: 0, cross the bridge from left to right, 1 pick old stuff finish, 2 cross the bridge from right to left, 3 return stuff finish\\n        PriorityQueue<int[]> events = new PriorityQueue<>(\\n            (n1,n2)->n1[0]-n2[0]);\\n        int curr = left.poll();\\n        events.add(new int[]{cumtime+time[curr][0],0,curr});\\n        cntWorker++;\\n        boolean bridgeInUse = true;\\n        while(cnt < n){\\n            int[] event = events.poll();\\n            cumtime = event[0];\\n            int type = event[1];\\n            curr = event[2]; \\n            //System.out.println(cumtime+\" \"+type+\" \"+curr);\\n            if (type==0){\\n                // let the worker to get box\\n                events.add(new int[]{cumtime+time[curr][1],1,curr});\\n                // release the bridge\\n                bridgeInUse = false;\\n            }\\n            else if (type==1){\\n                // add worker on the right side\\n                right.add(curr);\\n            }\\n            else if (type==2){\\n                // let the worker to return the box\\n                events.add(new int[]{cumtime+time[curr][3],3,curr});\\n                // release the bridge\\n                bridgeInUse = false;\\n            }\\n            else if (type==3){\\n                cnt++;\\n                // add worker on the left side\\n                left.add(curr);\\n            }\\n            // if there are events on the queue and the event has the same time as current time, wait until next event\\n            if (!events.isEmpty()&&events.peek()[0]==cumtime) continue; \\n            // after every event, we need to update the bridge\\n            // check whether the bridge is in use \\n            if (!bridgeInUse){\\n                // send worker\\n                if (!right.isEmpty()){\\n                    int worker = right.poll();\\n                    events.add(new int[]{cumtime+time[worker][2],2,worker});\\n                    bridgeInUse = true;\\n                }\\n                else {\\n                    // send new worker\\n                    if (cntWorker<n&&!left.isEmpty()){\\n                        int worker = left.poll();\\n                        events.add(new int[]{cumtime+time[worker][0],0,worker});\\n                        cntWorker++;\\n                        bridgeInUse = true;\\n                    }\\n                }\\n            }\\n        }\\n        return cumtime-time[curr][3];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017091,
                "title": "4-queue-solution-time-queue-efficiency-queue-on-each-side",
                "content": "# Intuition\\n4-queue solution: time-queue & efficiency-queue on each size\\n\\n# Approach\\nThe time-queue keeps track of which worker starts waiting after picking / putting, while the efficiency-queue selects the right worker to start crossing the bridge.\\n\\nOne subtle point is that the `todo` counter has to be gating the left efficiency-queue (called `l_heap` here) instead of the time-queue, otherwise the algorithm may select the wrong worker with higher efficiency while one with lower efficiency just finished putting a box.\\n\\n# Complexity\\n- Time complexity:\\n$$O((n + k) \\\\log k)$$\\n\\n\\n- Space complexity:\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        l_queue = [(0, -lr-rl, -i) for i, (lr, pick, rl, put) in enumerate(time)]\\n        heapq.heapify(l_queue)\\n        l_heap = []\\n        r_queue = []\\n        r_heap = []\\n        t = 0\\n        todo = n\\n        done = 0\\n        while done < n:\\n            while l_queue and l_queue[0][0] <= t:\\n                _, lrrl, i = heapq.heappop(l_queue)\\n                heapq.heappush(l_heap, (lrrl, i))\\n            while r_queue and r_queue[0][0] <= t:\\n                _, lrrl, i = heapq.heappop(r_queue)\\n                heapq.heappush(r_heap, (lrrl, i))\\n            if r_heap:\\n                lrrl, i = heapq.heappop(r_heap)\\n                lr, pick, rl, put = time[-i]\\n                t += rl\\n                heapq.heappush(l_queue, (t + put, lrrl, i))\\n                done += 1\\n            elif l_heap and todo:\\n                lrrl, i = heapq.heappop(l_heap)\\n                lr, pick, rl, put = time[-i]\\n                t += lr\\n                heapq.heappush(r_queue, (t + pick, lrrl, i))\\n                todo -= 1\\n            else:\\n                t = min(l_queue[0][0] if l_queue and todo else math.inf, r_queue[0][0] if r_queue else math.inf)\\n        return t\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        l_queue = [(0, -lr-rl, -i) for i, (lr, pick, rl, put) in enumerate(time)]\\n        heapq.heapify(l_queue)\\n        l_heap = []\\n        r_queue = []\\n        r_heap = []\\n        t = 0\\n        todo = n\\n        done = 0\\n        while done < n:\\n            while l_queue and l_queue[0][0] <= t:\\n                _, lrrl, i = heapq.heappop(l_queue)\\n                heapq.heappush(l_heap, (lrrl, i))\\n            while r_queue and r_queue[0][0] <= t:\\n                _, lrrl, i = heapq.heappop(r_queue)\\n                heapq.heappush(r_heap, (lrrl, i))\\n            if r_heap:\\n                lrrl, i = heapq.heappop(r_heap)\\n                lr, pick, rl, put = time[-i]\\n                t += rl\\n                heapq.heappush(l_queue, (t + put, lrrl, i))\\n                done += 1\\n            elif l_heap and todo:\\n                lrrl, i = heapq.heappop(l_heap)\\n                lr, pick, rl, put = time[-i]\\n                t += lr\\n                heapq.heappush(r_queue, (t + pick, lrrl, i))\\n                todo -= 1\\n            else:\\n                t = min(l_queue[0][0] if l_queue and todo else math.inf, r_queue[0][0] if r_queue else math.inf)\\n        return t\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017083,
                "title": "c-solution-by-managing-actions-in-time-order",
                "content": "# Intuition\\nEvery action is managed by priority_queue (`tq`) in time ascending order. In addition, workers waiting on each bridge are manged by priority_queue (`bwql` and `bwqr`). And every time an action occurred, next action is issued and one worker is allowed to cross the bridge if the bridge is free.\\n\\n# Code\\n```\\nusing State = array<int, 3>; \\n// first element is finish time of action.\\n// second one is worker index.\\n// third one is action indicator, where \\n// \\'r\\' is putting box and gettign ready to cross bridge on right side, \\n// \\'l\\' is picking up box and getting ready to cross bridge on left side,\\n// \\'m\\' is crossing the bridge from left side to right side, \\n// \\'s\\' is crossing the bridge from right side to left side.\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<array<int, 2>> bwql, bwqr; // bwql stands for bridge_waiting_queue_on_leftside    \\n        priority_queue<State, vector<State>, greater<State>> tq;\\n        int tm = 0;\\n        for(int i = 0; i < k; i++) {\\n            bwql.push({time[i][0] + time[i][2], i});       \\n        } \\n        int n_arrival_left = n;\\n        int ans = 0;\\n        int b_locked = 0; // bridge is blocked or not\\n        for(; n > 0;) {\\n            if (tq.size() > 0) {\\n                tm = tq.top()[0];\\n                for(; tq.size() > 0 and tq.top()[0] <= tm;) {\\n                    State s = tq.top(); tq.pop();\\n                    if (s[2] == (int) \\'l\\') {\\n                        bwql.push({time[s[1]][0] + time[s[1]][2], s[1]});\\n                    } else if (s[2] == (int) \\'r\\') {\\n                        bwqr.push({time[s[1]][0] + time[s[1]][2], s[1]});\\n                    } else if (s[2] == (int) \\'m\\') {\\n                        b_locked = 0;\\n                        tq.push({s[0] + time[s[1]][1], s[1], \\'r\\'}); \\n                    } else if (s[2] == (int) \\'s\\') {\\n                        b_locked = 0;\\n                        tq.push({s[0] + time[s[1]][3], s[1], \\'l\\'});\\n                        if (n > 0) ans = s[0];\\n                        n -= 1;\\n                    }\\n                }\\n            }\\n            \\n            if (!b_locked) { // if bridge is not used\\n                if (bwqr.size() > 0) {\\n                    auto c = bwqr.top(); bwqr.pop();\\n                    tq.push({tm + time[c[1]][2], c[1], \\'s\\'});\\n                    b_locked = 1;\\n                } else {\\n                    if (bwql.size() > 0 and n_arrival_left > 0) {\\n                        n_arrival_left -= 1;\\n                        auto c = bwql.top(); bwql.pop();\\n                        tq.push({tm + time[c[1]][0], c[1], \\'m\\'});\\n                        b_locked = 1;\\n                    } \\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing State = array<int, 3>; \\n// first element is finish time of action.\\n// second one is worker index.\\n// third one is action indicator, where \\n// \\'r\\' is putting box and gettign ready to cross bridge on right side, \\n// \\'l\\' is picking up box and getting ready to cross bridge on left side,\\n// \\'m\\' is crossing the bridge from left side to right side, \\n// \\'s\\' is crossing the bridge from right side to left side.\\n\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\\n        priority_queue<array<int, 2>> bwql, bwqr; // bwql stands for bridge_waiting_queue_on_leftside    \\n        priority_queue<State, vector<State>, greater<State>> tq;\\n        int tm = 0;\\n        for(int i = 0; i < k; i++) {\\n            bwql.push({time[i][0] + time[i][2], i});       \\n        } \\n        int n_arrival_left = n;\\n        int ans = 0;\\n        int b_locked = 0; // bridge is blocked or not\\n        for(; n > 0;) {\\n            if (tq.size() > 0) {\\n                tm = tq.top()[0];\\n                for(; tq.size() > 0 and tq.top()[0] <= tm;) {\\n                    State s = tq.top(); tq.pop();\\n                    if (s[2] == (int) \\'l\\') {\\n                        bwql.push({time[s[1]][0] + time[s[1]][2], s[1]});\\n                    } else if (s[2] == (int) \\'r\\') {\\n                        bwqr.push({time[s[1]][0] + time[s[1]][2], s[1]});\\n                    } else if (s[2] == (int) \\'m\\') {\\n                        b_locked = 0;\\n                        tq.push({s[0] + time[s[1]][1], s[1], \\'r\\'}); \\n                    } else if (s[2] == (int) \\'s\\') {\\n                        b_locked = 0;\\n                        tq.push({s[0] + time[s[1]][3], s[1], \\'l\\'});\\n                        if (n > 0) ans = s[0];\\n                        n -= 1;\\n                    }\\n                }\\n            }\\n            \\n            if (!b_locked) { // if bridge is not used\\n                if (bwqr.size() > 0) {\\n                    auto c = bwqr.top(); bwqr.pop();\\n                    tq.push({tm + time[c[1]][2], c[1], \\'s\\'});\\n                    b_locked = 1;\\n                } else {\\n                    if (bwql.size() > 0 and n_arrival_left > 0) {\\n                        n_arrival_left -= 1;\\n                        auto c = bwql.top(); bwql.pop();\\n                        tq.push({tm + time[c[1]][0], c[1], \\'m\\'});\\n                        b_locked = 1;\\n                    } \\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017066,
                "title": "sort-workers-first-then-simulate-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsort the efficiency and make timelines with crossing flag and worker who standing at left and right bridge\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& t) {\\n        for(int i=0; i< k; i++){\\n            t[i].push_back(i);\\n        }\\n        sort(t.begin(),t.end(), [](auto &t1, auto &t2){\\n            int time1 = t1[0] + t1[2];\\n            int time2 = t2[0] + t2[2];\\n            if(time1 == time2) return t1[4] > t2[4];\\n            else return time1 > time2;\\n        });\\n        priority_queue<int, vector<int>, greater<int>> l,r,timeline;\\n        for(int i=0;i<k;i++) l.push(i);\\n        bool crossing = false;\\n        // key = time, val = who\\n        map<int,vector<int>> pick,put;\\n        map<int,int> toL,toR;\\n        map<int,int> usedTime;\\n        timeline.push(0);\\n        int ans = 0;\\n        int picking = 0;\\n        int initialn = n;\\n        while(n > 0 && !timeline.empty()){\\n            int time = timeline.top();\\n            timeline.pop();\\n            if(usedTime.find(time) != usedTime.end()) continue;\\n            usedTime[time] ++;\\n            // cout << time << endl;\\n            if(pick.find(time) != pick.end()){\\n                // pick ended\\n                for(auto &w:pick[time]){\\n                    r.push(w);\\n                }\\n            }\\n            if(put.find(time) != put.end()){\\n                // put ended\\n                for(auto &w:put[time]){\\n                    l.push(w);\\n                }\\n            }\\n            if(toL.find(time) != toL.end()){\\n                // toL ended\\n                int w = toL[time];\\n                crossing = false;\\n                put[time + t[w][3]].push_back(w);\\n                // cout <<\\u3000\"put\"<< time + t[w][3] << endl;\\n                timeline.push(time + t[w][3]);\\n                n--;\\n                ans = time;\\n            }\\n            if(toR.find(time) != toR.end()){\\n                int w = toR[time];\\n                crossing = false;\\n                pick[time + t[w][1]].push_back(w);\\n                // cout <<\\u3000\"pick\" << time + t[w][1] << endl;\\n                timeline.push(time + t[w][1]);\\n            }\\n            if(!crossing){\\n                // toL\\n                if(!r.empty()){\\n                    int w = r.top();\\n                    r.pop();\\n                    crossing = true;\\n                    toL[time + t[w][2]] = w;\\n                    timeline.push(time + t[w][2]);\\n                    // cout <<\\u3000\"toL\" << w  << \\' \\' << time + t[w][2] << endl;\\n                }\\n                // toR\\n                else if(initialn > picking && !l.empty()){\\n                    int w = l.top();\\n                    l.pop();\\n                    crossing = true;\\n                    toR[time + t[w][0]] = w;\\n                    timeline.push(time + t[w][0]);\\n                    // cout <<\\u3000\"toR\" << w << \\' \\'<< time + t[w][0] << endl;\\n                    picking++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCrossingTime(int n, int k, vector<vector<int>>& t) {\\n        for(int i=0; i< k; i++){\\n            t[i].push_back(i);\\n        }\\n        sort(t.begin(),t.end(), [](auto &t1, auto &t2){\\n            int time1 = t1[0] + t1[2];\\n            int time2 = t2[0] + t2[2];\\n            if(time1 == time2) return t1[4] > t2[4];\\n            else return time1 > time2;\\n        });\\n        priority_queue<int, vector<int>, greater<int>> l,r,timeline;\\n        for(int i=0;i<k;i++) l.push(i);\\n        bool crossing = false;\\n        // key = time, val = who\\n        map<int,vector<int>> pick,put;\\n        map<int,int> toL,toR;\\n        map<int,int> usedTime;\\n        timeline.push(0);\\n        int ans = 0;\\n        int picking = 0;\\n        int initialn = n;\\n        while(n > 0 && !timeline.empty()){\\n            int time = timeline.top();\\n            timeline.pop();\\n            if(usedTime.find(time) != usedTime.end()) continue;\\n            usedTime[time] ++;\\n            // cout << time << endl;\\n            if(pick.find(time) != pick.end()){\\n                // pick ended\\n                for(auto &w:pick[time]){\\n                    r.push(w);\\n                }\\n            }\\n            if(put.find(time) != put.end()){\\n                // put ended\\n                for(auto &w:put[time]){\\n                    l.push(w);\\n                }\\n            }\\n            if(toL.find(time) != toL.end()){\\n                // toL ended\\n                int w = toL[time];\\n                crossing = false;\\n                put[time + t[w][3]].push_back(w);\\n                // cout <<\\u3000\"put\"<< time + t[w][3] << endl;\\n                timeline.push(time + t[w][3]);\\n                n--;\\n                ans = time;\\n            }\\n            if(toR.find(time) != toR.end()){\\n                int w = toR[time];\\n                crossing = false;\\n                pick[time + t[w][1]].push_back(w);\\n                // cout <<\\u3000\"pick\" << time + t[w][1] << endl;\\n                timeline.push(time + t[w][1]);\\n            }\\n            if(!crossing){\\n                // toL\\n                if(!r.empty()){\\n                    int w = r.top();\\n                    r.pop();\\n                    crossing = true;\\n                    toL[time + t[w][2]] = w;\\n                    timeline.push(time + t[w][2]);\\n                    // cout <<\\u3000\"toL\" << w  << \\' \\' << time + t[w][2] << endl;\\n                }\\n                // toR\\n                else if(initialn > picking && !l.empty()){\\n                    int w = l.top();\\n                    l.pop();\\n                    crossing = true;\\n                    toR[time + t[w][0]] = w;\\n                    timeline.push(time + t[w][0]);\\n                    // cout <<\\u3000\"toR\" << w << \\' \\'<< time + t[w][0] << endl;\\n                    picking++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1747221,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1747414,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1747352,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1747410,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1748181,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1747448,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1916240,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1755462,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1751332,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1751330,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1747221,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1747414,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1747352,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1747410,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1748181,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1747448,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1916240,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1755462,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1751332,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            },
            {
                "id": 1751330,
                "content": [
                    {
                        "username": "NeerajSati",
                        "content": "Edit: This is not a problem statement but a serious thesis written down by some superior intellectual"
                    },
                    {
                        "username": "qing306038",
                        "content": "lol"
                    },
                    {
                        "username": "brinuke",
                        "content": "The problem statement is not only verbose, but also self-contradicting and misleading. It says that `putNew` includes the time when the worker puts the box in the new warehouse and we need to return the instance of time **after** all `n` boxes have been put in the new warehouse, but both examples explicitly exclude this time from the answer."
                    },
                    {
                        "username": "shodan11",
                        "content": "Seems like the question comes from the  amazon delivery guy"
                    },
                    {
                        "username": "Umair9912",
                        "content": "There should be a project section for such problems.\\n"
                    },
                    {
                        "username": "ZhaoDanDaniel",
                        "content": "interesting problem and it worth everyone to have a try"
                    },
                    {
                        "username": "tr1ten",
                        "content": "Need extra category - Hard++"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Why? You just need to code a simulation"
                    },
                    {
                        "username": "c4tdog",
                        "content": "beautiful simulation! why so many dislikes?"
                    },
                    {
                        "username": "mihiragrawal022",
                        "content": "The statement could be more clearer and solution implementation is lengthy but still it is worth to give this problem a shot."
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "> Return the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\\n\\nThis adds needless complexity to the problem vs. just asking when the last box is placed in the new warehouse."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Not really, depends on your solution. I reserved a current time variable and increase it only when smdb crosses the bridge. Easy to return it"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "The problem description says: \\n\\n> If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.\\n\\nBut the examples seem to indicate that the condition is actually \"if the bridge is free and no worker is waiting on the right side, and the number of boxes at the old warehouse is greater than the number of workers who have already crossed or started to cross*\". If you follow the wording exactly then multiple workers will cross while waiting for a worker to pick up the box at the old warehouse, then come back empty-handed."
                    }
                ]
            }
        ]
    }
]