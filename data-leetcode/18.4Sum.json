[
    {
        "title": "4Sum",
        "question_content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n\t0 <= a, b, c, d&nbsp;< n\n\ta, b, c, and d are distinct.\n\tnums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\nExample 2:\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 200\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109",
        "solutions": [
            {
                "id": 8545,
                "title": "python-140ms-beats-100-and-works-for-n-sum-n-2",
                "content": "The core is to implement a fast 2-pointer to solve 2-sum, and recursion to reduce the N-sum to 2-sum. Some optimization was be made knowing the list is sorted.\\n\\n    def fourSum(self, nums, target):\\n        nums.sort()\\n        results = []\\n        self.findNsum(nums, target, 4, [], results)\\n        return results\\n    \\n    def findNsum(self, nums, target, N, result, results):\\n        if len(nums) < N or N < 2: return\\n    \\n        # solve 2-sum\\n        if N == 2:\\n            l,r = 0,len(nums)-1\\n            while l < r:\\n                if nums[l] + nums[r] == target:\\n                    results.append(result + [nums[l], nums[r]])\\n                    l += 1\\n                    r -= 1\\n                    while l < r and nums[l] == nums[l - 1]:\\n                        l += 1\\n                    while r > l and nums[r] == nums[r + 1]:\\n                        r -= 1\\n                elif nums[l] + nums[r] < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        else:\\n            for i in range(0, len(nums)-N+1):   # careful about range\\n                if target < nums[i]*N or target > nums[-1]*N:  # take advantages of sorted list\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]:  # recursively reduce N\\n                    self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\\n        return\\n\\n\\nJust revisited and clean the code\\n\\n\\n    def fourSum(self, nums, target):\\n        def findNsum(nums, target, N, result, results):\\n            if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination\\n                return\\n            if N == 2: # two pointers solve sorted 2-sum problem\\n                l,r = 0,len(nums)-1\\n                while l < r:\\n                    s = nums[l] + nums[r]\\n                    if s == target:\\n                        results.append(result + [nums[l], nums[r]])\\n                        l += 1\\n                        while l < r and nums[l] == nums[l-1]:\\n                            l += 1\\n                    elif s < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n            else: # recursively reduce N\\n                for i in range(len(nums)-N+1):\\n                    if i == 0 or (i > 0 and nums[i-1] != nums[i]):\\n                        findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\\n\\n        results = []\\n        findNsum(sorted(nums), target, 4, [], results)\\n        return results\\n\\t\\t\\t\\t\\npassing pointers, not sliced list\\n\\n    def fourSum(self, nums, target):\\n        def findNsum(l, r, target, N, result, results):\\n            if r-l+1 < N or N < 2 or target < nums[l]*N or target > nums[r]*N:  # early termination\\n                return\\n            if N == 2: # two pointers solve sorted 2-sum problem\\n                while l < r:\\n                    s = nums[l] + nums[r]\\n                    if s == target:\\n                        results.append(result + [nums[l], nums[r]])\\n                        l += 1\\n                        while l < r and nums[l] == nums[l-1]:\\n                            l += 1\\n                    elif s < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n            else: # recursively reduce N\\n                for i in range(l, r+1):\\n                    if i == l or (i > l and nums[i-1] != nums[i]):\\n                        findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)\\n\\n        nums.sort()\\n        results = []\\n        findNsum(0, len(nums)-1, target, 4, [], results)\\n        return results",
                "solutionTags": [
                    "Python"
                ],
                "code": "The core is to implement a fast 2-pointer to solve 2-sum, and recursion to reduce the N-sum to 2-sum. Some optimization was be made knowing the list is sorted.\\n\\n    def fourSum(self, nums, target):\\n        nums.sort()\\n        results = []\\n        self.findNsum(nums, target, 4, [], results)\\n        return results\\n    \\n    def findNsum(self, nums, target, N, result, results):\\n        if len(nums) < N or N < 2: return\\n    \\n        # solve 2-sum\\n        if N == 2:\\n            l,r = 0,len(nums)-1\\n            while l < r:\\n                if nums[l] + nums[r] == target:\\n                    results.append(result + [nums[l], nums[r]])\\n                    l += 1\\n                    r -= 1\\n                    while l < r and nums[l] == nums[l - 1]:\\n                        l += 1\\n                    while r > l and nums[r] == nums[r + 1]:\\n                        r -= 1\\n                elif nums[l] + nums[r] < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        else:\\n            for i in range(0, len(nums)-N+1):   # careful about range\\n                if target < nums[i]*N or target > nums[-1]*N:  # take advantages of sorted list\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]:  # recursively reduce N\\n                    self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\\n        return\\n\\n\\nJust revisited and clean the code\\n\\n\\n    def fourSum(self, nums, target):\\n        def findNsum(nums, target, N, result, results):\\n            if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination\\n                return\\n            if N == 2: # two pointers solve sorted 2-sum problem\\n                l,r = 0,len(nums)-1\\n                while l < r:\\n                    s = nums[l] + nums[r]\\n                    if s == target:\\n                        results.append(result + [nums[l], nums[r]])\\n                        l += 1\\n                        while l < r and nums[l] == nums[l-1]:\\n                            l += 1\\n                    elif s < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n            else: # recursively reduce N\\n                for i in range(len(nums)-N+1):\\n                    if i == 0 or (i > 0 and nums[i-1] != nums[i]):\\n                        findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\\n\\n        results = []\\n        findNsum(sorted(nums), target, 4, [], results)\\n        return results\\n\\t\\t\\t\\t\\npassing pointers, not sliced list\\n\\n    def fourSum(self, nums, target):\\n        def findNsum(l, r, target, N, result, results):\\n            if r-l+1 < N or N < 2 or target < nums[l]*N or target > nums[r]*N:  # early termination\\n                return\\n            if N == 2: # two pointers solve sorted 2-sum problem\\n                while l < r:\\n                    s = nums[l] + nums[r]\\n                    if s == target:\\n                        results.append(result + [nums[l], nums[r]])\\n                        l += 1\\n                        while l < r and nums[l] == nums[l-1]:\\n                            l += 1\\n                    elif s < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n            else: # recursively reduce N\\n                for i in range(l, r+1):\\n                    if i == l or (i > l and nums[i-1] != nums[i]):\\n                        findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)\\n\\n        nums.sort()\\n        results = []\\n        findNsum(0, len(nums)-1, target, 4, [], results)\\n        return results",
                "codeTag": "Python3"
            },
            {
                "id": 8609,
                "title": "my-solution-generalized-for-ksums-in-java",
                "content": "#### General Idea\\nIf you have already read and implement the 3sum and 4sum by using the sorting approach: reduce them into 2sum at the end, you might already got the feeling that, all ksum problem can be divided into two problems: \\n1. 2sum Problem\\n2. Reduce K sum problem to K \\u2013 1 sum Problem\\n\\nTherefore, the ideas is simple and straightforward. We could use recursive to solve this problem. Time complexity is O(N^(K-1)).\\n\\n```JAVA\\n    public class Solution {\\n        int len = 0;\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            len = nums.length;\\n            Arrays.sort(nums);\\n            return kSum(nums, target, 4, 0);\\n        }\\n       private ArrayList<List<Integer>> kSum(int[] nums, int target, int k, int index) {\\n            ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n            if(index >= len) {\\n                return res;\\n            }\\n            if(k == 2) {\\n            \\tint i = index, j = len - 1;\\n            \\twhile(i < j) {\\n                    //find a pair\\n            \\t    if(target - nums[i] == nums[j]) {\\n            \\t    \\tList<Integer> temp = new ArrayList<>();\\n                    \\ttemp.add(nums[i]);\\n                    \\ttemp.add(target-nums[i]);\\n                        res.add(temp);\\n                        //skip duplication\\n                        while(i<j && nums[i]==nums[i+1]) i++;\\n                        while(i<j && nums[j-1]==nums[j]) j--;\\n                        i++;\\n                        j--;\\n                    //move left bound\\n            \\t    } else if (target - nums[i] > nums[j]) {\\n            \\t        i++;\\n                    //move right bound\\n            \\t    } else {\\n            \\t        j--;\\n            \\t    }\\n            \\t}\\n            } else{\\n                for (int i = index; i < len - k + 1; i++) {\\n                    //use current number to reduce ksum into k-1sum\\n                    ArrayList<List<Integer>> temp = kSum(nums, target - nums[i], k-1, i+1);\\n                    if(temp != null){\\n                        //add previous results\\n                        for (List<Integer> t : temp) {\\n                            t.add(0, nums[i]);\\n                        }\\n                        res.addAll(temp);\\n                    }\\n                    while (i < len-1 && nums[i] == nums[i+1]) {\\n                        //skip duplicated numbers\\n                        i++;\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```JAVA\\n    public class Solution {\\n        int len = 0;\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            len = nums.length;\\n            Arrays.sort(nums);\\n            return kSum(nums, target, 4, 0);\\n        }\\n       private ArrayList<List<Integer>> kSum(int[] nums, int target, int k, int index) {\\n            ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n            if(index >= len) {\\n                return res;\\n            }\\n            if(k == 2) {\\n            \\tint i = index, j = len - 1;\\n            \\twhile(i < j) {\\n                    //find a pair\\n            \\t    if(target - nums[i] == nums[j]) {\\n            \\t    \\tList<Integer> temp = new ArrayList<>();\\n                    \\ttemp.add(nums[i]);\\n                    \\ttemp.add(target-nums[i]);\\n                        res.add(temp);\\n                        //skip duplication\\n                        while(i<j && nums[i]==nums[i+1]) i++;\\n                        while(i<j && nums[j-1]==nums[j]) j--;\\n                        i++;\\n                        j--;\\n                    //move left bound\\n            \\t    } else if (target - nums[i] > nums[j]) {\\n            \\t        i++;\\n                    //move right bound\\n            \\t    } else {\\n            \\t        j--;\\n            \\t    }\\n            \\t}\\n            } else{\\n                for (int i = index; i < len - k + 1; i++) {\\n                    //use current number to reduce ksum into k-1sum\\n                    ArrayList<List<Integer>> temp = kSum(nums, target - nums[i], k-1, i+1);\\n                    if(temp != null){\\n                        //add previous results\\n                        for (List<Integer> t : temp) {\\n                            t.add(0, nums[i]);\\n                        }\\n                        res.addAll(temp);\\n                    }\\n                    while (i < len-1 && nums[i] == nums[i+1]) {\\n                        //skip duplicated numbers\\n                        i++;\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8549,
                "title": "my-16ms-c-code",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>> total;\\n            int n = nums.size();\\n            if(n<4)  return total;\\n            sort(nums.begin(),nums.end());\\n            for(int i=0;i<n-3;i++)\\n            {\\n                if(i>0&&nums[i]==nums[i-1]) continue;\\n                if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\\n                if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\\n                for(int j=i+1;j<n-2;j++)\\n                {\\n                    if(j>i+1&&nums[j]==nums[j-1]) continue;\\n                    if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\\n                    if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\\n                    int left=j+1,right=n-1;\\n                    while(left<right){\\n                        int sum=nums[left]+nums[right]+nums[i]+nums[j];\\n                        if(sum<target) left++;\\n                        else if(sum>target) right--;\\n                        else{\\n                            total.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});\\n                            do{left++;}while(nums[left]==nums[left-1]&&left<right);\\n                            do{right--;}while(nums[right]==nums[right+1]&&left<right);\\n                        }\\n                    }\\n                }\\n            }\\n            return total;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>> total;\\n            int n = nums.size();\\n            if(n<4)  return total;\\n            sort(nums.begin(),nums.end());\\n            for(int i=0;i<n-3;i++)\\n            {\\n                if(i>0&&nums[i]==nums[i-1]) continue;\\n                if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\\n                if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\\n                for(int j=i+1;j<n-2;j++)\\n                {\\n                    if(j>i+1&&nums[j]==nums[j-1]) continue;\\n                    if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\\n                    if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\\n                    int left=j+1,right=n-1;\\n                    while(left<right){\\n                        int sum=nums[left]+nums[right]+nums[i]+nums[j];\\n                        if(sum<target) left++;\\n                        else if(sum>target) right--;\\n                        else{\\n                            total.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]}",
                "codeTag": "Java"
            },
            {
                "id": 1341213,
                "title": "c-python-2-solutions-clean-concise-follow-up-k-sum",
                "content": "**\\u2714\\uFE0F Solution 1: HashSet**\\n- The idea is to use `HashSet` to track past elements.\\n- We iterate the combinations of `nums[i]`, `nums[j]`, `nums[k]`, and calculate the last number by `lastNumber = target - nums[i] - nums[j] - nums[k]`. \\n- We check if `lastNumber` is existed the past by checking in the HashSet, if existed, then it form a `quadruplets` then add it to the answer.\\n\\nCredit @archit91 for providing C++ version.\\n<iframe src=\"https://leetcode.com/playground/BsiPbnLs/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\nComplexity:\\n- Time: `O(N^3)`\\n- Extra Space (Without count output as space): `O(N)`\\n---\\n**\\u2714\\uFE0F Solution 2: Sort then Two Pointers**\\n- Sort `nums` in increasing order.\\n- We fix `nums[i], nums[j]` by iterating the combination of `nums[i], nums[j]`, then the problem now become to very classic problem **[1. Two Sum](https://leetcode.com/problems/two-sum/)**.\\n- By using two pointers, one points to `left`, the other points to `right`, `remain = target - nums[i] - nums[j]`.\\n\\t- If `nums[left] + nums[right] == remain`\\n\\t\\t- Found a valid quadruplets\\n\\t- Else if `nums[left] + nums[right] > remain`\\n\\t\\t- Sum is bigger than remain, need to decrease sum by `right -= 1`\\n\\t- Else:\\n\\t\\t- Increasing sum by `left += 1`.\\n\\n<iframe src=\"https://leetcode.com/playground/Dz7F3Sqw/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\nComplexity:\\n- Time: `O(N^3)`\\n- Extra Space (Without count output as space): `O(sorting)`\\n\\n---\\n**\\u2714\\uFE0F Follow-up question: Calculate K-Sum?**\\n\\n<iframe src=\"https://leetcode.com/playground/KUgSSN93/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\nComplexity:\\n- Time: `O(NlogN + N^(k-1))`, where `k >= 2`, `N` is number of elements in the array `nums`.\\n- Extra space (Without count output as space): `O(N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: HashSet**\\n- The idea is to use `HashSet` to track past elements.\\n- We iterate the combinations of `nums[i]`, `nums[j]`, `nums[k]`, and calculate the last number by `lastNumber = target - nums[i] - nums[j] - nums[k]`. \\n- We check if `lastNumber` is existed the past by checking in the HashSet, if existed, then it form a `quadruplets` then add it to the answer.\\n\\nCredit @archit91 for providing C++ version.\\n<iframe src=\"https://leetcode.com/playground/BsiPbnLs/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\nComplexity:\\n- Time: `O(N^3)`\\n- Extra Space (Without count output as space): `O(N)`\\n---\\n**\\u2714\\uFE0F Solution 2: Sort then Two Pointers**\\n- Sort `nums` in increasing order.\\n- We fix `nums[i], nums[j]` by iterating the combination of `nums[i], nums[j]`, then the problem now become to very classic problem **[1. Two Sum](https://leetcode.com/problems/two-sum/)**.\\n- By using two pointers, one points to `left`, the other points to `right`, `remain = target - nums[i] - nums[j]`.\\n\\t- If `nums[left] + nums[right] == remain`\\n\\t\\t- Found a valid quadruplets\\n\\t- Else if `nums[left] + nums[right] > remain`\\n\\t\\t- Sum is bigger than remain, need to decrease sum by `right -= 1`\\n\\t- Else:\\n\\t\\t- Increasing sum by `left += 1`.\\n\\n<iframe src=\"https://leetcode.com/playground/Dz7F3Sqw/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\nComplexity:\\n- Time: `O(N^3)`\\n- Extra Space (Without count output as space): `O(sorting)`\\n\\n---\\n**\\u2714\\uFE0F Follow-up question: Calculate K-Sum?**\\n\\n<iframe src=\"https://leetcode.com/playground/KUgSSN93/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\nComplexity:\\n- Time: `O(NlogN + N^(k-1))`, where `k >= 2`, `N` is number of elements in the array `nums`.\\n- Extra space (Without count output as space): `O(N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Java"
            },
            {
                "id": 3186501,
                "title": "best-c-3-solution-two-pointers-sorting-hash-table-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array(Four Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\\n2. Solved using Array(Three Nested Loop) + Sorting + Hash Table(set).\\n3. Solved using Array(Three Nested Loop) + Sorting. Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^4), Here Four nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Four Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                for(int k=j+1; k<n-1; k++){\\n                    for(int l=k+1; l<n; l++){\\n                        if((long long)nums[i] + (long long)nums[j] + (long long)nums[k] + \\n                        (long long)nums[l] == target){\\n                            set.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Three Nested Loop) + Sorting + Hash Table(set).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        set.insert({nums[i], nums[j], nums[low], nums[high]});\\n                        low++; high--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Vector(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Array(Three Nested Loop) + Sorting. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        output.push_back({nums[i], nums[j], nums[low], nums[high]});\\n                        int tempIndex1 = low, tempIndex2 = high;\\n                        while(low < high && nums[low] == nums[tempIndex1]) low++;\\n                        while(low < high && nums[high] == nums[tempIndex2]) high--;\\n                    }\\n                }\\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\\n            }\\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^4), Here Four nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Four Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                for(int k=j+1; k<n-1; k++){\\n                    for(int l=k+1; l<n; l++){\\n                        if((long long)nums[i] + (long long)nums[j] + (long long)nums[k] + \\n                        (long long)nums[l] == target){\\n                            set.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Three Nested Loop) + Sorting + Hash Table(set).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        set.insert({nums[i], nums[j], nums[low], nums[high]});\\n                        low++; high--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Vector(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Array(Three Nested Loop) + Sorting. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        output.push_back({nums[i], nums[j], nums[low], nums[high]});\\n                        int tempIndex1 = low, tempIndex2 = high;\\n                        while(low < high && nums[low] == nums[tempIndex1]) low++;\\n                        while(low < high && nums[high] == nums[tempIndex2]) high--;\\n                    }\\n                }\\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\\n            }\\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8547,
                "title": "7ms-java-code-win-over-100",
                "content": "The first time win over 100%. Basic idea is using subfunctions for 3sum and 2sum, and keeping throwing all impossible cases. O(n^3) time complexity, O(1) extra space complexity.\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\t\\t\\tArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tif (nums == null || len < 4)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\tint max = nums[len - 1];\\n\\t\\t\\tif (4 * nums[0] > target || 4 * max < target)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tint i, z;\\n\\t\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\t\\tz = nums[i];\\n\\t\\t\\t\\tif (i > 0 && z == nums[i - 1])// avoid duplicate\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (z + 3 * max < target) // z is too small\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (4 * z > target) // z is too large\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (4 * z == target) { // z is the boundary\\n\\t\\t\\t\\t\\tif (i + 3 < len && nums[i + 3] == z)\\n\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(z, z, z, z));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthreeSumForFourSum(nums, target - z, i + 1, len - 1, res, z);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Find all possible distinguished three numbers adding up to the target\\n\\t\\t * in sorted array nums[] between indices low and high. If there are,\\n\\t\\t * add all of them into the ArrayList fourSumList, using\\n\\t\\t * fourSumList.add(Arrays.asList(z1, the three numbers))\\n\\t\\t */\\n\\t\\tpublic void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,\\n\\t\\t\\t\\tint z1) {\\n\\t\\t\\tif (low + 1 >= high)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint max = nums[high];\\n\\t\\t\\tif (3 * nums[low] > target || 3 * max < target)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint i, z;\\n\\t\\t\\tfor (i = low; i < high - 1; i++) {\\n\\t\\t\\t\\tz = nums[i];\\n\\t\\t\\t\\tif (i > low && z == nums[i - 1]) // avoid duplicate\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (z + 2 * max < target) // z is too small\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (3 * z > target) // z is too large\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tif (3 * z == target) { // z is the boundary\\n\\t\\t\\t\\t\\tif (i + 1 < high && nums[i + 2] == z)\\n\\t\\t\\t\\t\\t\\tfourSumList.add(Arrays.asList(z1, z, z, z));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttwoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Find all possible distinguished two numbers adding up to the target\\n\\t\\t * in sorted array nums[] between indices low and high. If there are,\\n\\t\\t * add all of them into the ArrayList fourSumList, using\\n\\t\\t * fourSumList.add(Arrays.asList(z1, z2, the two numbers))\\n\\t\\t */\\n\\t\\tpublic void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,\\n\\t\\t\\t\\tint z1, int z2) {\\n\\n\\t\\t\\tif (low >= high)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif (2 * nums[low] > target || 2 * nums[high] < target)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint i = low, j = high, sum, x;\\n\\t\\t\\twhile (i < j) {\\n\\t\\t\\t\\tsum = nums[i] + nums[j];\\n\\t\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\t\\tfourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j]));\\n\\n\\t\\t\\t\\t\\tx = nums[i];\\n\\t\\t\\t\\t\\twhile (++i < j && x == nums[i]) // avoid duplicate\\n\\t\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\t\\tx = nums[j];\\n\\t\\t\\t\\t\\twhile (i < --j && x == nums[j]) // avoid duplicate\\n\\t\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (sum > target)\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "The first time win over 100%. Basic idea is using subfunctions for 3sum and 2sum, and keeping throwing all impossible cases. O(n^3) time complexity, O(1) extra space complexity.\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\t\\t\\tArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tif (nums == null || len < 4)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\tint max = nums[len - 1];\\n\\t\\t\\tif (4 * nums[0] > target || 4 * max < target)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tint i, z;\\n\\t\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\t\\tz = nums[i];\\n\\t\\t\\t\\tif (i > 0 && z == nums[i - 1])// avoid duplicate\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (z + 3 * max < target) // z is too small\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (4 * z > target) // z is too large\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (4 * z == target) { // z is the boundary\\n\\t\\t\\t\\t\\tif (i + 3 < len && nums[i + 3] == z)\\n\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(z, z, z, z));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthreeSumForFourSum(nums, target - z, i + 1, len - 1, res, z);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Find all possible distinguished three numbers adding up to the target\\n\\t\\t * in sorted array nums[] between indices low and high. If there are,\\n\\t\\t * add all of them into the ArrayList fourSumList, using\\n\\t\\t * fourSumList.add(Arrays.asList(z1, the three numbers))\\n\\t\\t */\\n\\t\\tpublic void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,\\n\\t\\t\\t\\tint z1) {\\n\\t\\t\\tif (low + 1 >= high)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint max = nums[high];\\n\\t\\t\\tif (3 * nums[low] > target || 3 * max < target)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint i, z;\\n\\t\\t\\tfor (i = low; i < high - 1; i++) {\\n\\t\\t\\t\\tz = nums[i];\\n\\t\\t\\t\\tif (i > low && z == nums[i - 1]) // avoid duplicate\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (z + 2 * max < target) // z is too small\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (3 * z > target) // z is too large\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tif (3 * z == target) { // z is the boundary\\n\\t\\t\\t\\t\\tif (i + 1 < high && nums[i + 2] == z)\\n\\t\\t\\t\\t\\t\\tfourSumList.add(Arrays.asList(z1, z, z, z));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttwoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Find all possible distinguished two numbers adding up to the target\\n\\t\\t * in sorted array nums[] between indices low and high. If there are,\\n\\t\\t * add all of them into the ArrayList fourSumList, using\\n\\t\\t * fourSumList.add(Arrays.asList(z1, z2, the two numbers))\\n\\t\\t */\\n\\t\\tpublic void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,\\n\\t\\t\\t\\tint z1, int z2) {\\n\\n\\t\\t\\tif (low >= high)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif (2 * nums[low] > target || 2 * nums[high] < target)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint i = low, j = high, sum, x;\\n\\t\\t\\twhile (i < j) {\\n\\t\\t\\t\\tsum = nums[i] + nums[j];\\n\\t\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\t\\tfourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j]));\\n\\n\\t\\t\\t\\t\\tx = nums[i];\\n\\t\\t\\t\\t\\twhile (++i < j && x == nums[i]) // avoid duplicate\\n\\t\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\t\\tx = nums[j];\\n\\t\\t\\t\\t\\twhile (i < --j && x == nums[j]) // avoid duplicate\\n\\t\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (sum > target)\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 8714,
                "title": "4sum-c-solution-with-explanation-and-comparison-with-3sum-problem-easy-to-understand",
                "content": "For the reference, please have a look at my explanation of `3Sum` problem because the algorithm are exactly the same. The link is as blow.\\n\\n[My 3Sum problem answer][1]\\n\\nThe key idea is to downgrade the problem to a `2Sum` problem eventually. And the same algorithm can be expand to `NSum` problem.\\n\\nAfter you had a look at my explanation of `3Sum`, the code below will be extremely easy to understand.\\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > fourSum(vector<int> &num, int target) {\\n        \\n            vector<vector<int> > res;\\n        \\n            if (num.empty())\\n                return res;\\n        \\n            std::sort(num.begin(),num.end());\\n        \\n            for (int i = 0; i < num.size(); i++) {\\n            \\n                int target_3 = target - num[i];\\n            \\n                for (int j = i + 1; j < num.size(); j++) {\\n                \\n                    int target_2 = target_3 - num[j];\\n                \\n                    int front = j + 1;\\n                    int back = num.size() - 1;\\n                \\n                    while(front < back) {\\n                    \\n                        int two_sum = num[front] + num[back];\\n                    \\n                        if (two_sum < target_2) front++;\\n                    \\n                        else if (two_sum > target_2) back--;\\n                    \\n                        else {\\n                        \\n                            vector<int> quadruplet(4, 0);\\n                            quadruplet[0] = num[i];\\n                            quadruplet[1] = num[j];\\n                            quadruplet[2] = num[front];\\n                            quadruplet[3] = num[back];\\n                            res.push_back(quadruplet);\\n                        \\n                            // Processing the duplicates of number 3\\n                            while (front < back && num[front] == quadruplet[2]) ++front;\\n                        \\n                            // Processing the duplicates of number 4\\n                            while (front < back && num[back] == quadruplet[3]) --back;\\n                    \\n                        }\\n                    }\\n                    \\n                    // Processing the duplicates of number 2\\n                    while(j + 1 < num.size() && num[j + 1] == num[j]) ++j;\\n                }\\n            \\n                // Processing the duplicates of number 1\\n                while (i + 1 < num.size() && num[i + 1] == num[i]) ++i;\\n            \\n            }\\n        \\n            return res;\\n        \\n        }\\n    };\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/23595/share-my-solution-around-50ms-with-explanation-and-comments",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > fourSum(vector<int> &num, int target) {\\n        \\n            vector<vector<int> > res;\\n        \\n            if (num.empty())\\n                return res;\\n        \\n            std::sort(num.begin(),num.end());\\n        \\n            for (int i = 0; i < num.size(); i++) {\\n            \\n                int target_3 = target - num[i];\\n            \\n                for (int j = i + 1; j < num.size(); j++) {\\n                \\n                    int target_2 = target_3 - num[j];\\n                \\n                    int front = j + 1;\\n                    int back = num.size() - 1;\\n                \\n                    while(front < back) {\\n                    \\n                        int two_sum = num[front] + num[back];\\n                    \\n                        if (two_sum < target_2) front++;\\n                    \\n                        else if (two_sum > target_2) back--;\\n                    \\n                        else {\\n                        \\n                            vector<int> quadruplet(4, 0);\\n                            quadruplet[0] = num[i];\\n                            quadruplet[1] = num[j];\\n                            quadruplet[2] = num[front];\\n                            quadruplet[3] = num[back];\\n                            res.push_back(quadruplet);\\n                        \\n                            // Processing the duplicates of number 3\\n                            while (front < back && num[front] == quadruplet[2]) ++front;\\n                        \\n                            // Processing the duplicates of number 4\\n                            while (front < back && num[back] == quadruplet[3]) --back;\\n                    \\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 8575,
                "title": "clean-accepted-java-o-n-3-solution-based-on-3sum",
                "content": "    public class Solution {\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n        ArrayList<List<Integer>> ans = new ArrayList<>();\\n        if(num.length<4)return ans;\\n        Arrays.sort(num);\\n        for(int i=0; i<num.length-3; i++){\\n            if(num[i]+num[i+1]+num[i+2]+num[i+3]>target)break; //first candidate too large, search finished\\n            if(num[i]+num[num.length-1]+num[num.length-2]+num[num.length-3]<target)continue; //first candidate too small\\n            if(i>0&&num[i]==num[i-1])continue; //prevents duplicate result in ans list\\n            for(int j=i+1; j<num.length-2; j++){\\n                if(num[i]+num[j]+num[j+1]+num[j+2]>target)break; //second candidate too large\\n                if(num[i]+num[j]+num[num.length-1]+num[num.length-2]<target)continue; //second candidate too small\\n                if(j>i+1&&num[j]==num[j-1])continue; //prevents duplicate results in ans list\\n                int low=j+1, high=num.length-1;\\n                while(low<high){\\n                    int sum=num[i]+num[j]+num[low]+num[high];\\n                    if(sum==target){\\n                        ans.add(Arrays.asList(num[i], num[j], num[low], num[high]));\\n                        while(low<high&&num[low]==num[low+1])low++; //skipping over duplicate on low\\n                        while(low<high&&num[high]==num[high-1])high--; //skipping over duplicate on high\\n                        low++; \\n                        high--;\\n                    }\\n                    //move window\\n                    else if(sum<target)low++; \\n                    else high--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\nupdated with optimizations and comments",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n        ArrayList<List<Integer>> ans = new ArrayList<>();\\n        if(num.length<4)return ans;\\n        Arrays.sort(num);\\n        for(int i=0; i<num.length-3; i++){\\n            if(num[i]+num[i+1]+num[i+2]+num[i+3]>target)break; //first candidate too large, search finished\\n            if(num[i]+num[num.length-1]+num[num.length-2]+num[num.length-3]<target)continue; //first candidate too small\\n            if(i>0&&num[i]==num[i-1])continue; //prevents duplicate result in ans list\\n            for(int j=i+1; j<num.length-2; j++){\\n                if(num[i]+num[j]+num[j+1]+num[j+2]>target)break; //second candidate too large\\n                if(num[i]+num[j]+num[num.length-1]+num[num.length-2]<target)continue; //second candidate too small\\n                if(j>i+1&&num[j]==num[j-1])continue; //prevents duplicate results in ans list\\n                int low=j+1, high=num.length-1;\\n                while(low<high){\\n                    int sum=num[i]+num[j]+num[low]+num[high];\\n                    if(sum==target){\\n                        ans.add(Arrays.asList(num[i], num[j], num[low], num[high]));\\n                        while(low<high&&num[low]==num[low+1])low++; //skipping over duplicate on low\\n                        while(low<high&&num[high]==num[high-1])high--; //skipping over duplicate on high\\n                        low++; \\n                        high--;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 737096,
                "title": "sum-megapost-python3-solution-with-a-detailed-explanation",
                "content": "If you\\'re a newbie and sometimes have a hard time understanding the logic. Don\\'t worry, you\\'ll catch up after a month of doing Leetcode on a daily basis. Try to do it, even one example per day. It\\'d help. I\\'ve compiled a bunch on `sum` problems here, go ahead and check it out. Also, I think focusing on a subject and do 3-4 problems would help to get the idea behind solution since they mostly follow the same logic. Of course there are other ways to solve each problems but I try to be as uniform as possible. Good luck. \\n\\nIn general, `sum` problems can be categorized into two categories: 1) there is any array and you add some numbers to get to (or close to) a `target`, or 2) you need to return indices of numbers that sum up to a (or close to) a `target` value.  Note that when the problem is looking for a indices, `sort`ing the array is probably NOT a good idea. \\n\\n\\n **[Two Sum:](https://leetcode.com/problems/two-sum/)**  \\n \\n This is the second type of the problems where we\\'re looking for indices, so sorting is not necessary. What you\\'d want to do is to go over the array, and try to find two integers that sum up to  a `target` value. Most of the times, in such a problem, using dictionary (hastable) helps. You try to keep track of you\\'ve observations in a dictionary and use it once you get to the results. \\n\\nNote: try to be comfortable to use `enumerate` as it\\'s sometime out of comfort zone for newbies. `enumerate` comes handy in a lot of problems (I mean if you want to have a cleaner code of course). If I had to choose three built in functions/methods that I wasn\\'t comfortable with at the start and have found them super helpful, I\\'d probably say `enumerate`, `zip` and `set`. \\n \\nSolution: In this problem, you initialize a dictionary (`seen`). This dictionary will keep track of numbers (as `key`) and indices (as `value`). So, you go over your array (line `#1`) using `enumerate` that gives you both index and value of elements in array. As an example, let\\'s do `nums = [2,3,1]` and `target = 3`. Let\\'s say you\\'re at index `i = 0` and `value = 2`, ok? you need to find `value = 1` to finish the problem, meaning, `target - 2 = 1`. 1 here is the `remaining`. Since `remaining + value = target`, you\\'re done once you found it, right? So when going through the array, you calculate the `remaining` and check to see whether `remaining` is in the `seen` dictionary (line `#3`). If it is, you\\'re done! you\\'re current number and the remaining from `seen` would give you the output (line `#4`). Otherwise, you add your current number to the dictionary (line `#5`) since it\\'s going to be a `remaining` for (probably) a number you\\'ll see in the future assuming that there is at least one instance of answer.  \\n \\n \\n ```\\n class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n            \\n            if remaining in seen: #3\\n                return [i, seen[remaining]]  #4\\n            else:\\n                seen[value] = i  #5\\n```\\n \\n \\n\\n **[Two Sum II:](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)**  \\n\\nFor this, you can do exactly as the previous. The only change I made below was to change the order of line `#4`. In the previous example, the order didn\\'t matter. But, here the problem asks for asending order and since the values/indicess in `seen` has always lower indices than your current number, it should come first.  Also, note that the problem says it\\'s not zero based, meaning that indices don\\'t start from zero, that\\'s why I added 1 to both of them. \\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        seen = {}\\n        for i, value in enumerate(numbers): \\n            remaining = target - numbers[i] \\n           \\n            if remaining in seen: \\n                return [seen[remaining]+1, i+1]  #4\\n            else:\\n                seen[value] = i  \\n```\\n\\nAnother approach to solve this problem (probably what Leetcode is looking for) is to treat it as first category of problems. Since the array is already sorted, this works. You see the following approach in a lot of problems. What you want to do is to have two pointer (if it was 3sum, you\\'d need three pointers as you\\'ll see in the future examples). One pointer move from `left` and one from `right`. Let\\'s say you `numbers = [1,3,6,9]` and your `target = 10`. Now, `left` points to 1 at first, and  `right` points to 9. There are three possibilities. If you sum numbers that `left` and `right` are pointing at, you get `temp_sum` (line `#1`). If `temp_sum` is your target, you\\'r done! You\\'re return it (line `#9`). If it\\'s more than your `target`, it means that `right` is poiting to a very large value (line `#5`) and you need to bring it a little bit to the left to a smaller (r maybe equal) value (line `#6`)  by adding one to the index . If the `temp_sum` is less than `target` (line `#7`), then you need to move your `left` to a little bit larger value by adding one to the index (line `#9`). This way, you try to narrow down the range in which you\\'re looking at and will eventually find a couple of number that sum to `target`, then, you\\'ll return this in line `#9`. In this problem, since it says there is only one solution, nothing extra is necessary. However, when a problem asks to return all combinations that sum to `target`, you can\\'t simply return the first instace and you need to collect all the possibilities and return the list altogether (you\\'ll see something like this in the next example). \\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        for left in range(len(numbers) -1): #1\\n            right = len(numbers) - 1 #2\\n            while left < right: #3\\n                temp_sum = numbers[left] + numbers[right] #4\\n                if temp_sum > target:  #5\\n                    right -= 1 #6\\n                elif temp_sum < target: #7\\n                    left +=1 #8\\n                else:\\n                    return [left+1, right+1] #9\\n```\\n\\n\\n\\n\\n[**3Sum**](https://leetcode.com/problems/3sum/)\\n\\nThis is similar to the previous example except that it\\'s looking for three numbers. There are some minor differences in the problem statement. It\\'s looking for all combinations (not just one) of solutions returned as a list. And second, it\\'s looking for unique combination, repeatation is not allowed. \\n\\nHere, instead of looping (line `#1`) to `len(nums) -1`, we loop to `len(nums) -2` since we\\'re looking for three numbers. Since we\\'re returning values, `sort` would be a good idea. Otherwise, if the `nums` is not sorted, you cannot reducing `right` pointer or increasing `left` pointer easily, makes sense? \\n\\nSo, first you `sort` the array and define `res = []` to collect your outputs. In line `#2`, we check wether two consecutive elements are equal or not because if they are, we don\\'t want them (solutions need to be unique) and will skip to the next set of numbers. Also, there is an additional constrain in this line that `i > 0`. This is added to take care of cases like `nums = [1,1,1]` and `target = 3`. If we didn\\'t have `i > 0`, then we\\'d skip the only correct solution and would return `[]` as our answer which is wrong (correct answer is `[[1,1,1]]`.  \\n\\nWe define two additional pointers this time, `left = i + 1` and `right = len(nums) - 1`. For example, if `nums = [-2,-1,0,1,2]`, all the points in the case of `i=1` are looking at: `i` at `-1`, `left` at `0` and `right` at `2`. We then check `temp` variable similar to the previous example. There is only one change with respect to the previous example here between lines `#5` and `#10`.  If we have the `temp = target`, we obviously add this set to the `res` in line `#5`, right? However, we\\'re not done yet. For a fixed `i`, we still need to check and see whether there are other combinations by just changing `left` and `right` pointers. That\\'s what we are doing in lines `#6, 7, 8`. If we still have the condition of `left < right` and `nums[left]` and the number to the right of it are not the same, we move `left` one index to right (line `#6`). Similarly, if `nums[right]` and the value to left of it is not the same, we move `right` one index to left. This way for a fixed `i`, we get rid of repeative cases. For example, if `nums = [-3, 1,1, 3,5]` and `target = 3`, one we get the first `[-3,1,5]`, `left = 1`, but, `nums[2]` is also 1 which we don\\'t want the `left` variable to look at it simply because it\\'d again return `[-3,1,5]`, right? So, we move `left` one index. Finally, if the repeating elements don\\'t exists, lines `#6` to `#8` won\\'t get activated. In this case we still need to move forward by adding 1 to `left` and extracting 1 from `right` (lines `#9, 10`). \\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        res = []\\n\\n        for i in range(len(nums) -2): #1\\n            if i > 0 and nums[i] == nums[i-1]: #2\\n                continue\\n            left = i + 1 #3\\n            right = len(nums) - 1 #4\\n            \\n            while left < right:  \\n                temp = nums[i] + nums[left] + nums[right]\\n                                    \\n                if temp > 0:\\n                    right -= 1\\n                    \\n                elif temp < 0:\\n                    left += 1\\n                \\n                else:\\n                    res.append([nums[i], nums[left], nums[right]]) #5\\n                    while left < right and nums[left] == nums[left + 1]: #6\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:#7\\n                        right -= 1    #8\\n                \\n                    right -= 1 #9 \\n                    left += 1 #10\\n                       \\n```\\n\\nAnother way to solve this problem is to change it into a two sum problem. Instead of finding `a+b+c = 0`, you can find `a+b = -c` where we want to find two numbers `a` and `b` that are equal to `-c`, right? This is similar to the first problem. Remember if you wanted to use the exact same as the first code, it\\'d return indices and not numbers. Also, we need to re-arrage this problem in a way that we have `nums` and `target`. This code is not a good code and can be optimipized but you got the idea. For a better version of this, check [this](https://leetcode.com/problems/3sum/discuss/7384/My-Python-solution-based-on-2-sum-200-ms-beat-93.37). \\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            output_2sum = self.twoSum(nums[i+1:], -nums[i])\\n            if output_2sum ==[]:\\n                continue\\n            else:\\n                for idx in output_2sum:\\n                    instance = idx+[nums[i]]\\n                    res.append(instance)\\n        \\n        output = []\\n        for idx in res:\\n            if idx not in output:\\n                output.append(idx)\\n                \\n        \\n        return output\\n    \\n    \\n    def twoSum(self, nums, target):\\n        seen = {}\\n        res = []\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n           \\n            if remaining in seen: #3\\n                res.append([value, remaining])  #4\\n            else:\\n                seen[value] = i  #5\\n            \\n        return res\\n```\\n\\n[**4Sum**](https://leetcode.com/problems/4sum/)\\n\\nYou should have gotten the idea, and what you\\'ve seen so far can be generalized to `nSum`. Here, I write the generic code using the same ideas as before. What I\\'ll do is to break down each case to a `2Sum II` problem, and solve them recursively using the approach in `2Sum II` example above. \\n\\nFirst sort `nums`, then I\\'m using two extra functions, `helper` and `twoSum`. The `twoSum` is similar to the `2sum II` example with some modifications. It doesn\\'t return the first instance of results, it check every possible combinations and return all of them now. Basically, now it\\'s more similar to the `3Sum` solution. Understanding this function shouldn\\'t be difficult as it\\'s very similar to `3Sum`. As for `helper` function, it first tries to check for cases that don\\'t work (line `#1`). And later, if the `N` we need to sum to get to a `target` is 2 (line `#2`), then runs the `twoSum` function. For the more than two numbers, it recursively breaks them down to two sum (line `#3`). There are some cases like line `#4` that we don\\'t need to proceed with the algorithm anymore and we can `break`. These cases include if multiplying the lowest number in the list by `N` is more than `target`. Since its sorted array, if this happens, we can\\'t find any result. Also, if the largest array (`nums[-1]`) multiplied by `N` would be less than `target`, we can\\'t find any solution. So, `break`. \\n\\n\\nFor other cases, we run the `helper` function again with new inputs, and we keep doing it until we get to `N=2` in which we use `twoSum` function, and add the results to get the final output. \\n\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        results = []\\n        self.helper(nums, target, 4, [], results)\\n        return results\\n    \\n    def helper(self, nums, target, N, res, results):\\n        \\n        if len(nums) < N or N < 2: #1\\n            return\\n        if N == 2: #2\\n            output_2sum = self.twoSum(nums, target)\\n            if output_2sum != []:\\n                for idx in output_2sum:\\n                    results.append(res + idx)\\n        \\n        else: \\n            for i in range(len(nums) -N +1): #3\\n                if nums[i]*N > target or nums[-1]*N < target: #4\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]: #5\\n                    self.helper(nums[i+1:], target-nums[i], N-1, res + [nums[i]], results)\\n    \\n    \\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        left = 0\\n        right = len(nums) - 1 \\n        while left < right: \\n            temp_sum = nums[left] + nums[right] \\n\\n            if temp_sum == target:\\n                res.append([nums[left], nums[right]])\\n                right -= 1\\n                left += 1\\n                while left < right and nums[left] == nums[left - 1]:\\n                    left += 1\\n                while right > left and nums[right] == nums[right + 1]:\\n                    right -= 1\\n                                \\n            elif temp_sum < target: \\n                left +=1 \\n            else: \\n                right -= 1\\n                                        \\n        return res\\n```\\n\\n[**Combination Sum II**](https://leetcode.com/problems/combination-sum-ii/)\\nI don\\'t post combination sum here since it\\'s basically this problem a little bit easier. \\nCombination questions can be solved with `dfs` most of the time. if you want to fully understand this concept and [backtracking](https://www.***.org/backtracking-introduction/), try to finish [this](https://leetcode.com/problems/combination-sum/discuss/429538/General-Backtracking-questions-solutions-in-Python-for-reference-%3A) post and do all the examples. \\n\\nRead my older post first [here](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation). This should give you a better idea of what\\'s going on. The solution here also follow the exact same format except for some minor changes. I first made a minor change in the `dfs` function where it doesn\\'t need the `index` parameter anymore. This is taken care of by `candidates[i+1:]` in line `#3`. Note that we had `candidates` here in the previous post. \\n\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n            return res\\n        \\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]: #1\\n                continue #2\\n            self.dfs(candidates[i+1:], target - candidates[i], path+[candidates[i]], res) #3\\n```\\n\\n\\nThe only differences are lines `#1, 2, 3`. The difference in problem statement in this one and `combinations` problem of my previous post is >>>candidates must be used once<<< and lines `#1` and `2` are here to take care of this.  Line `#1` has two components where first `i > 0` and second `candidates[i] == candidates[i-1]`. The second component `candidates[i] == candidates[i-1]` is to take care of duplicates in the `candidates` variable as was instructed in the problem statement. Basically, if the next number in `candidates` is the same as the previous one, it means that it has already been taken care of, so `continue`. The first component takes care of cases like an input  `candidates = [1]` with `target = 1` (try to remove this component and submit your solution. You\\'ll see what I mean). The rest is similar to the previous [post](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation)\\n\\n\\n\\n================================================================\\nFinal note: Please let me know if you found any typo/error/ect. I\\'ll try to fix them.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n            \\n            if remaining in seen: #3\\n                return [i, seen[remaining]]  #4\\n            else:\\n                seen[value] = i  #5\\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        seen = {}\\n        for i, value in enumerate(numbers): \\n            remaining = target - numbers[i] \\n           \\n            if remaining in seen: \\n                return [seen[remaining]+1, i+1]  #4\\n            else:\\n                seen[value] = i  \\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        for left in range(len(numbers) -1): #1\\n            right = len(numbers) - 1 #2\\n            while left < right: #3\\n                temp_sum = numbers[left] + numbers[right] #4\\n                if temp_sum > target:  #5\\n                    right -= 1 #6\\n                elif temp_sum < target: #7\\n                    left +=1 #8\\n                else:\\n                    return [left+1, right+1] #9\\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        res = []\\n\\n        for i in range(len(nums) -2): #1\\n            if i > 0 and nums[i] == nums[i-1]: #2\\n                continue\\n            left = i + 1 #3\\n            right = len(nums) - 1 #4\\n            \\n            while left < right:  \\n                temp = nums[i] + nums[left] + nums[right]\\n                                    \\n                if temp > 0:\\n                    right -= 1\\n                    \\n                elif temp < 0:\\n                    left += 1\\n                \\n                else:\\n                    res.append([nums[i], nums[left], nums[right]]) #5\\n                    while left < right and nums[left] == nums[left + 1]: #6\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:#7\\n                        right -= 1    #8\\n                \\n                    right -= 1 #9 \\n                    left += 1 #10\\n                       \\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            output_2sum = self.twoSum(nums[i+1:], -nums[i])\\n            if output_2sum ==[]:\\n                continue\\n            else:\\n                for idx in output_2sum:\\n                    instance = idx+[nums[i]]\\n                    res.append(instance)\\n        \\n        output = []\\n        for idx in res:\\n            if idx not in output:\\n                output.append(idx)\\n                \\n        \\n        return output\\n    \\n    \\n    def twoSum(self, nums, target):\\n        seen = {}\\n        res = []\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n           \\n            if remaining in seen: #3\\n                res.append([value, remaining])  #4\\n            else:\\n                seen[value] = i  #5\\n            \\n        return res\\n```\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        results = []\\n        self.helper(nums, target, 4, [], results)\\n        return results\\n    \\n    def helper(self, nums, target, N, res, results):\\n        \\n        if len(nums) < N or N < 2: #1\\n            return\\n        if N == 2: #2\\n            output_2sum = self.twoSum(nums, target)\\n            if output_2sum != []:\\n                for idx in output_2sum:\\n                    results.append(res + idx)\\n        \\n        else: \\n            for i in range(len(nums) -N +1): #3\\n                if nums[i]*N > target or nums[-1]*N < target: #4\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]: #5\\n                    self.helper(nums[i+1:], target-nums[i], N-1, res + [nums[i]], results)\\n    \\n    \\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        left = 0\\n        right = len(nums) - 1 \\n        while left < right: \\n            temp_sum = nums[left] + nums[right] \\n\\n            if temp_sum == target:\\n                res.append([nums[left], nums[right]])\\n                right -= 1\\n                left += 1\\n                while left < right and nums[left] == nums[left - 1]:\\n                    left += 1\\n                while right > left and nums[right] == nums[right + 1]:\\n                    right -= 1\\n                                \\n            elif temp_sum < target: \\n                left +=1 \\n            else: \\n                right -= 1\\n                                        \\n        return res\\n```\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n            return res\\n        \\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]: #1\\n                continue #2\\n            self.dfs(candidates[i+1:], target - candidates[i], path+[candidates[i]], res) #3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8653,
                "title": "on-average-o-n-2-and-worst-case-o-n-3-java-solution-by-reducing-4sum-to-2sum",
                "content": "Basic idea is to reduce the 4Sum problem to 2Sum one. In order to achieve that, we can use an array (size of n^2) to store the pair sums and this array will act as the array in 2Sum case (Here n is the size of the original 1D array and it turned out that we do not even need to explicitly use the n^2 sized array ). We also use a hashmap to mark if a pair sum has been visited or not (the same as in the 2Sum case). The tricky part here is that we may have multiple pairs that result in the same pair sum. So we will use a list to group these pairs together. For every pair with a particular sum, check if the pair sum that is needed to get the target has been visited. If so, further check if there is overlapping between these two pairs. If not, record the result.\\n\\nTime complexity to get all the pairs is O(n^2). For each pair, if the pair sum needed to get the target has been visited, the time complexity will be O(k), where k is the maximum size of the lists holding pairs with visited pair sum. Therefore the total time complexity will be O(k*n^2). Now we need to determine the range of k. Basically the more distinct pair sums we get, the smaller k will be. If all the pair sums are different from each other, k will just be 1. However, if we have many repeated elements in the original 1D array, or in some extreme cases such as the elements form an arithmetic progression, k can be of the order of n (strictly speaking, for the repeated elements case, k can go as high as n^2, but we can get rid of many of them). On average k will be some constant between 1 and n for normal elements distribution in the original 1D array. So on average our algorithm will go in O(n^2) but with worst case of O(n^3).  Here is the complete code in java:\\n\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n        Arrays.sort(num);\\n        \\n        Map<Integer, List<int[]>> twoSumMap = new HashMap<>(); // for holding visited pair sums. All pairs with the same pair sum are grouped together\\n        Set<List<Integer>> res = new HashSet<>();  // for holding the results\\n        \\n        for (int i = 0; i < num.length; i++) {\\n        \\t// get rid of repeated pair sums\\n            if (i > 1 && num[i] == num[i - 2]) continue;\\n        \\t\\n            for (int j = i + 1; j < num.length; j++) {\\n                // get rid of repeated pair sums\\n                if (j > i + 2 && num[j] == num[j - 2]) continue;\\n\\n                // for each pair sum, check if the pair sum that is needed to get the target has been visited.            \\t\\n                if (twoSumMap.containsKey(target - (num[i] + num[j]))) {   \\n                    // if so, get all the pairs that contribute to this visited pair sum.\\n            \\tList<int[]> ls = twoSumMap.get(target - (num[i] + num[j]));\\n            \\t\\t\\n            \\tfor (int[] pair : ls) {\\n            \\t    // we have two pairs: one is indicated as (pair[0], pair[1]), the other is (i, j).\\n            \\t    // we first need to check if they are overlapping with each other.\\n            \\t    int m1 = Math.min(pair[0], i);  // m1 will always be the smallest index\\n                        int m2 = Math.min(pair[1], j);  // m2 will be one of the middle two indices\\n                        int m3 = Math.max(pair[0], i);  // m3 will be one of the middle two indices\\n                        int m4 = Math.max(pair[1], j);  // m4 will always be the largest index\\n                        \\n                        if (m1 == m3 || m1 == m4 || m2 == m3 || m2 == m4) continue;  // two pairs are overlapping, so just ignore this case\\n     \\t\\t    \\n     \\t\\t    res.add(Arrays.asList(num[m1], num[Math.min(m2, m3)], num[Math.max(m2, m3)], num[m4]));  // else record the result\\n            \\t}\\n                }\\n                \\n                // mark that we have visited current pair and add it to the corrsponding pair sum group.\\n                // here we've encoded the pair indices i and j into an integer array of length 2.\\n                twoSumMap.computeIfAbsent(num[i] + num[j], key -> new ArrayList<>()).add(new int[] {i, j});\\n            }\\n        }\\n        \\n        return new ArrayList<List<Integer>>(res);\\n    }",
                "solutionTags": [],
                "code": "Basic idea is to reduce the 4Sum problem to 2Sum one. In order to achieve that, we can use an array (size of n^2) to store the pair sums and this array will act as the array in 2Sum case (Here n is the size of the original 1D array and it turned out that we do not even need to explicitly use the n^2 sized array ). We also use a hashmap to mark if a pair sum has been visited or not (the same as in the 2Sum case). The tricky part here is that we may have multiple pairs that result in the same pair sum. So we will use a list to group these pairs together. For every pair with a particular sum, check if the pair sum that is needed to get the target has been visited. If so, further check if there is overlapping between these two pairs. If not, record the result.\\n\\nTime complexity to get all the pairs is O(n^2). For each pair, if the pair sum needed to get the target has been visited, the time complexity will be O(k), where k is the maximum size of the lists holding pairs with visited pair sum. Therefore the total time complexity will be O(k*n^2). Now we need to determine the range of k. Basically the more distinct pair sums we get, the smaller k will be. If all the pair sums are different from each other, k will just be 1. However, if we have many repeated elements in the original 1D array, or in some extreme cases such as the elements form an arithmetic progression, k can be of the order of n (strictly speaking, for the repeated elements case, k can go as high as n^2, but we can get rid of many of them). On average k will be some constant between 1 and n for normal elements distribution in the original 1D array. So on average our algorithm will go in O(n^2) but with worst case of O(n^3).  Here is the complete code in java:\\n\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n        Arrays.sort(num);\\n        \\n        Map<Integer, List<int[]>> twoSumMap = new HashMap<>(); // for holding visited pair sums. All pairs with the same pair sum are grouped together\\n        Set<List<Integer>> res = new HashSet<>();  // for holding the results\\n        \\n        for (int i = 0; i < num.length; i++) {\\n        \\t// get rid of repeated pair sums\\n            if (i > 1 && num[i] == num[i - 2]) continue;\\n        \\t\\n            for (int j = i + 1; j < num.length; j++) {\\n                // get rid of repeated pair sums\\n                if (j > i + 2 && num[j] == num[j - 2]) continue;\\n\\n                // for each pair sum, check if the pair sum that is needed to get the target has been visited.            \\t\\n                if (twoSumMap.containsKey(target - (num[i] + num[j]))) {   \\n                    // if so, get all the pairs that contribute to this visited pair sum.\\n            \\tList<int[]> ls = twoSumMap.get(target - (num[i] + num[j]));\\n            \\t\\t\\n            \\tfor (int[] pair : ls) {\\n            \\t    // we have two pairs: one is indicated as (pair[0], pair[1]), the other is (i, j).\\n            \\t    // we first need to check if they are overlapping with each other.\\n            \\t    int m1 = Math.min(pair[0], i);  // m1 will always be the smallest index\\n                        int m2 = Math.min(pair[1], j);  // m2 will be one of the middle two indices\\n                        int m3 = Math.max(pair[0], i);  // m3 will be one of the middle two indices\\n                        int m4 = Math.max(pair[1], j);  // m4 will always be the largest index\\n                        \\n                        if (m1 == m3 || m1 == m4 || m2 == m3 || m2 == m4) continue;  // two pairs are overlapping, so just ignore this case\\n     \\t\\t    \\n     \\t\\t    res.add(Arrays.asList(num[m1], num[Math.min(m2, m3)], num[Math.max(m2, m3)], num[m4]));  // else record the result\\n            \\t}\\n                }\\n                \\n                // mark that we have visited current pair and add it to the corrsponding pair sum group.\\n                // here we've encoded the pair indices i and j into an integer array of length 2.\\n                twoSumMap.computeIfAbsent(num[i] + num[j], key -> new ArrayList<>()).add(new int[] {i, j});\\n            }\\n        }\\n        \\n        return new ArrayList<List<Integer>>(res);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3110025,
                "title": "c-easiest-beginner-friendly-sol-set-two-pointer-approach-o-n-3-time-and-o-n-space",
                "content": "# Intuition of this Problem:\\nSet is used to prevent duplicate quadruplets and parallely we will use two pointer approach to maintain k and l.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Sort the input array of integers nums.\\n2. Initialize an empty set s, and an empty 2D vector output.\\n3. Use nested loops to iterate through all possible combinations of quadruplets in nums.\\n4. For each combination, use two pointers (k and l) to traverse the sub-array between the second and second-to-last elements of the combination.\\n5. At each iteration of the innermost while loop, calculate the sum of the current quadruplet and check if it is equal to the target.\\n6. If the sum is equal to the target, insert the quadruplet into the set s and increment both pointers (k and l).\\n7. If the sum is less than the target, increment the pointer k.\\n8. If the sum is greater than the target, decrement the pointer l.\\n9. After all quadruplets have been checked, iterate through the set s and add each quadruplet to the output vector.\\n10. Return the output vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n//Optimized Approach using two pointer - O(n^3) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                int k = j + 1;\\n                int l = nums.size() - 1;\\n                while (k < l) {\\n                    //by writing below 4 statement this way it will not give runtime error\\n                    long long int sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\\n```C++ []\\n//Brute force Approach - O(n^4) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                for(int k = j+1; k < nums.size(); k++){\\n                    for(int l = k+1; l < nums.size(); l++){\\n                        vector<int> temp;\\n                        if(nums[i] + nums[j] + nums[k] + nums[l] == target){\\n                            temp.push_back(nums[i]);\\n                            temp.push_back(nums[j]);\\n                            temp.push_back(nums[k]);\\n                            temp.push_back(nums[l]);\\n                            s.insert(temp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\\n```C++ []\\n// this peice of code will give runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' for below test case\\nnums = [1000000000,1000000000,1000000000,1000000000]\\ntarget = 0\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                int k = j + 1;\\n                int l = nums.size() - 1;\\n                while (k < l) {\\n                    //for below statement it will give runtime error\\n                    long long int sum = nums[i] + nums[j] + nums[k] + nums[l];\\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> s = new HashSet<>();\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                while (k < l) {\\n                    long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        s.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        output.addAll(s);\\n        return output;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                k = j + 1\\n                l = len(nums) - 1\\n                while k < l:\\n                    sum = nums[i] + nums[j] + nums[k] + nums[l]\\n                    if sum == target:\\n                        s.add((nums[i], nums[j], nums[k], nums[l]))\\n                        k += 1\\n                        l -= 1\\n                    elif sum < target:\\n                        k += 1\\n                    else:\\n                        l -= 1\\n        output = list(s)\\n        return output\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n^3)** // where n is the size of array\\n\\nThe outer two loops have a time complexity of O(n^2) and the inner while loop has a time complexity of O(n). The total time complexity is therefore O(n^2) * O(n) = O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n\\nThe set s stores all unique quadruplets, which in the worst case scenario is O(n).\\nThe output vector stores the final output, which is also O(n).\\nThe total space complexity is therefore O(n) + O(n) = O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers"
                ],
                "code": "```C++ []\\n//Optimized Approach using two pointer - O(n^3) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                int k = j + 1;\\n                int l = nums.size() - 1;\\n                while (k < l) {\\n                    //by writing below 4 statement this way it will not give runtime error\\n                    long long int sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\n```C++ []\\n//Brute force Approach - O(n^4) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                for(int k = j+1; k < nums.size(); k++){\\n                    for(int l = k+1; l < nums.size(); l++){\\n                        vector<int> temp;\\n                        if(nums[i] + nums[j] + nums[k] + nums[l] == target){\\n                            temp.push_back(nums[i]);\\n                            temp.push_back(nums[j]);\\n                            temp.push_back(nums[k]);\\n                            temp.push_back(nums[l]);\\n                            s.insert(temp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\n```C++ []\\n// this peice of code will give runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' for below test case\\nnums = [1000000000,1000000000,1000000000,1000000000]\\ntarget = 0\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                int k = j + 1;\\n                int l = nums.size() - 1;\\n                while (k < l) {\\n                    //for below statement it will give runtime error\\n                    long long int sum = nums[i] + nums[j] + nums[k] + nums[l];\\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> s = new HashSet<>();\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                while (k < l) {\\n                    long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        s.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        output.addAll(s);\\n        return output;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                k = j + 1\\n                l = len(nums) - 1\\n                while k < l:\\n                    sum = nums[i] + nums[j] + nums[k] + nums[l]\\n                    if sum == target:\\n                        s.add((nums[i], nums[j], nums[k], nums[l]))\\n                        k += 1\\n                        l -= 1\\n                    elif sum < target:\\n                        k += 1\\n                    else:\\n                        l -= 1\\n        output = list(s)\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341243,
                "title": "python-o-n-3-and-why-we-can-not-do-better-explained",
                "content": "In this problem we are asked to find not one 4-sum with sum equal to `target`, but all of them. If we were asked to find only one sum, there is `O(n^2)` solution: create array of pairs and then try to find the new pair is equal to `target` minus sums of two numbers. However we need to return all sums and imagine the case `nums = [1, 2, 3, ..., n]`. Then there will be `C_n^4 = O(n^4)` different ways to choose `4` number out of `n` and all sums are in range `[4, 4n]`. It means, that by pingenhole principle there will be some sum which we meet `Omega(n^3)` times, that is `>= alpha*n^3` for some constant alpha.\\n\\nSo, in general case we can have only `O(n^3)` solution (though with small constant, like 1/6) which allows us to pass problem constraints. The idea is exaclty the same as in other **2Sum** problems: sort numbers, choose `i` and `j` and then use two pointers approach to get solutions.\\n\\n#### Complexity\\nWe need to choose `i` and `j` with complexity `O(n^2)` and then for each choosen pair use two-pointers approach so we have `O(n^3)` total complexity. Space complexity is `O(n)` to keep sorted data.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def fourSum(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), []\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                goal = target - nums[i] - nums[j]\\n                beg, end = j + 1, n - 1\\n\\n                while beg < end:\\n                    if nums[beg] + nums[end] < goal:\\n                        beg += 1\\n                    elif nums[beg] + nums[end] > goal:\\n                        end -= 1\\n                    else:\\n                        ans.append((nums[i], nums[j], nums[beg], nums[end]))\\n                        beg += 1\\n                        end -= 1\\n\\n        return set(ans)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fourSum(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), []\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                goal = target - nums[i] - nums[j]\\n                beg, end = j + 1, n - 1\\n\\n                while beg < end:\\n                    if nums[beg] + nums[end] < goal:\\n                        beg += 1\\n                    elif nums[beg] + nums[end] > goal:\\n                        end -= 1\\n                    else:\\n                        ans.append((nums[i], nums[j], nums[beg], nums[end]))\\n                        beg += 1\\n                        end -= 1\\n\\n        return set(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128591,
                "title": "easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        d = dict()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                sum2 = nums[i]+nums[j]\\n                if sum2 in d:\\n                    d[sum2].append((i,j))\\n                else:\\n                    d[sum2] = [(i,j)]\\n        \\n        result = set()\\n        for key in d:\\n            value = target - key\\n            if value in d:\\n                list1 = d[key]\\n                list2 = d[value]\\n                for (i,j) in list1:\\n                    for (k,l) in list2:\\n                        if i!=k and i!=l and j!=k and j!=l:\\n                            flist = [nums[i],nums[j],nums[k],nums[l]]\\n                            flist.sort()\\n                            result.add(tuple(flist))\\n        return list(result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        d = dict()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                sum2 = nums[i]+nums[j]\\n                if sum2 in d:\\n                    d[sum2].append((i,j))\\n                else:\\n                    d[sum2] = [(i,j)]\\n        \\n        result = set()\\n        for key in d:\\n            value = target - key\\n            if value in d:\\n                list1 = d[key]\\n                list2 = d[value]\\n                for (i,j) in list1:\\n                    for (k,l) in list2:\\n                        if i!=k and i!=l and j!=k and j!=l:\\n                            flist = [nums[i],nums[j],nums[k],nums[l]]\\n                            flist.sort()\\n                            result.add(tuple(flist))\\n        return list(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363031,
                "title": "c-short-easy-two-pointers-solution",
                "content": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();  \\n        sort(nums.begin() , nums.end());  // sort the array to use the two pointers method\\n        vector<vector<int>> ans;  \\n        set<vector<int>> store;   // to store and remove the duplicate answers\\n\\t\\t\\n        for(int i = 0 ; i < n; i++){\\n\\t\\t\\n            for(int j = i + 1; j < n ; j++){\\n\\t\\t\\t\\n                int new_target  =  target - nums[i] - nums[j];\\n                \\n                int x = j+1 , y = n-1;\\n                \\n                while(x < y){\\n\\t\\t\\t\\t\\n                    int sum = nums[x] + nums[y];\\n                    \\n                    if(sum > new_target) y--;\\n                    else if(sum < new_target ) x++;\\n                    else  {\\n                        store.insert({nums[i] , nums[j] , nums[x] , nums[y]});\\n                        x++;\\n                        y--;\\n                    };\\n                }\\n            }\\n        }\\n\\t\\t\\n        for(auto i : store){\\n            ans.push_back(i);  // store the answers in an array(ans)\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();  \\n        sort(nums.begin() , nums.end());  // sort the array to use the two pointers method\\n        vector<vector<int>> ans;  \\n        set<vector<int>> store;   // to store and remove the duplicate answers\\n\\t\\t\\n        for(int i = 0 ; i < n; i++){\\n\\t\\t\\n            for(int j = i + 1; j < n ; j++){\\n\\t\\t\\t\\n                int new_target  =  target - nums[i] - nums[j];\\n                \\n                int x = j+1 , y = n-1;\\n                \\n                while(x < y){\\n\\t\\t\\t\\t\\n                    int sum = nums[x] + nums[y];\\n                    \\n                    if(sum > new_target) y--;\\n                    else if(sum < new_target ) x++;\\n                    else  {\\n                        store.insert({nums[i] , nums[j] , nums[x] , nums[y]});\\n                        x++;\\n                        y--;\\n                    };\\n                }\\n            }\\n        }\\n\\t\\t\\n        for(auto i : store){\\n            ans.push_back(i);  // store the answers in an array(ans)\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8628,
                "title": "my-c-solution-using-hashtable",
                "content": "My idea is to sort num first, then build a hashtable with the key as the sum of the pair and the value as a  vector storing all pairs of index of num that having the same sum. In this way, all elements stored in hashtable has a order that duplicate pairs are neighbors. Therefore scanning the vector in the hashtable we only put non duplicate elements into the final answer vvi.\\n\\nIs this method O(n^2) ? or Does anyone can improve it to O(n^2);\\n\\n\\n\\n        class Solution{ //using hashtable, avg O(n^2)\\n    \\n    public:\\n    \\n        vector<vector<int> > fourSum(vector<int> &num, int target){\\n            vector<vector<int> > vvi;\\n            int n = num.size();\\n            if(n < 4) return  vvi;\\n            \\n            sort(num.begin(), num.end());        \\n            unordered_map<int, vector<pair<int, int>> > mp;\\n            for(int i = 0; i < n; i++){\\n                for(int j = i + 1; j < n; j++){\\n                    mp[num[i]+num[j]].push_back(make_pair(i,j));\\n                }\\n            }\\n            \\n            for(int i = 0; i < n; i++){\\n                if(i>0 && num[i] == num[i-1]) continue;\\n                for(int j = i + 1; j < n; j++){\\n                    if(j > i + 1 && num[j] == num[j-1]) continue;\\n                    int res = target - num[i] - num[j];\\n                    if(mp.count(res)){\\n                        for(auto it = mp[res].begin(); it != mp[res].end(); it++){\\n                            int k = (*it).first, l = (*it).second;\\n                            if(k > j){ // k>j make sure that the second pair has bigger values than the first pair.\\n                                if(!vvi.empty() && num[i]==vvi.back()[0] && num[j]==vvi.back()[1]\\n                                && num[k]==vvi.back()[2] && num[l] == vvi.back()[3]){\\n                                    continue; //if the obtained 4 elements are the same as previous one continue to next\\n                                }\\n                                vector<int> vi={num[i], num[j], num[k], num[l]};\\n                                vvi.push_back(vi);\\n                            } // if k>j\\n                            \\n                        }//for it\\n                    }//if\\n                }// forj\\n            }//for i\\n            return vvi;\\n        }\\n      };",
                "solutionTags": [],
                "code": "class Solution{ //using hashtable, avg O(n^2)\\n    \\n    public:\\n    \\n        vector<vector<int> > fourSum(vector<int> &num, int target){\\n            vector<vector<int> > vvi;\\n            int n = num.size();\\n            if(n < 4) return  vvi;\\n            \\n            sort(num.begin(), num.end());        \\n            unordered_map<int, vector<pair<int, int>> > mp;\\n            for(int i = 0; i < n; i++){\\n                for(int j = i + 1; j < n; j++){\\n                    mp[num[i]+num[j]].push_back(make_pair(i,j));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1328067,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\\n        let len = nums.count\\n        guard len >= 4 else { return [] }\\n        \\n        var result = [[Int]]()\\n        let sort = nums.sorted()\\n        \\n        for a in 0..<(len - 1) where a == 0 || sort[a] != sort[a-1] {\\n            for b in (a + 1)..<len where b == a + 1 || sort[b] != sort[b-1] {\\n                var c = b + 1, d = len - 1\\n                while c < d {\\n                    let val = (a: sort[a], b: sort[b], c: sort[c], d: sort[d])\\n                    let sum = (val.a + val.b + val.c + val.d)\\n                    if sum == target { result.append([val.a,val.b,val.c,val.d]) }\\n                    if sum < target {\\n                        while sort[c] == val.c, c < d { c += 1 }\\n                    } else {\\n                        while sort[d] == val.d, d > b { d -= 1 }\\n                    }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.fourSum([1,0,-1,0,-2,2], 0)\\n        XCTAssertEqual(value, [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]])\\n    }\\n    func test1() {\\n        let value = solution.fourSum([2,2,2,2,2], 8)\\n        XCTAssertEqual(value, [[2,2,2,2]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\\n        let len = nums.count\\n        guard len >= 4 else { return [] }\\n        \\n        var result = [[Int]]()\\n        let sort = nums.sorted()\\n        \\n        for a in 0..<(len - 1) where a == 0 || sort[a] != sort[a-1] {\\n            for b in (a + 1)..<len where b == a + 1 || sort[b] != sort[b-1] {\\n                var c = b + 1, d = len - 1\\n                while c < d {\\n                    let val = (a: sort[a], b: sort[b], c: sort[c], d: sort[d])\\n                    let sum = (val.a + val.b + val.c + val.d)\\n                    if sum == target { result.append([val.a,val.b,val.c,val.d]) }\\n                    if sum < target {\\n                        while sort[c] == val.c, c < d { c += 1 }\\n                    } else {\\n                        while sort[d] == val.d, d > b { d -= 1 }\\n                    }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.fourSum([1,0,-1,0,-2,2], 0)\\n        XCTAssertEqual(value, [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]])\\n    }\\n    func test1() {\\n        let value = solution.fourSum([2,2,2,2,2], 8)\\n        XCTAssertEqual(value, [[2,2,2,2]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290604,
                "title": "c-beats-96-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition:** We will fix two-pointers and then find the remaining two elements using two pointer technique as the array will be sorted at first.\\n\\n**Approach:**\\n* Sort the array, and then fix two pointers, so the remaining sum will be (target \\u2013 (nums[i] + nums[j])). \\n* Now we can fix two-pointers, one front, and another back, and easily use a two-pointer to find the remaining two numbers of the quad. \\n* In order to avoid duplications, we jump the duplicates, because taking duplicates will result in repeating quads. \\n* We can easily jump duplicates, by skipping the same elements by running a loop.\\n\\n```\\n// Input => arr[] = [4,3,3,4,4,2,1,2,1,1], target = 9\\n// Output => [[1,1,3,4],[1,2,2,4],[1,2,3,3]]\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> res;\\n        \\n        if(nums.empty())\\n            return res;\\n        \\n        int n = nums.size();\\n        \\n        // Approach requires sorting and 2-pointer approach\\n        \\n        // Step1 -> sorting\\n        sort(nums.begin(),nums.end());\\n        \\n        \\n        // Step2 -> 2-pointer \\n        for(int i=0; i<n; i++)\\n        {\\n            long long int target3 = target - nums[i];\\n            \\n            for(int j=i+1; j<n; j++)\\n            {\\n                long long int target2 = target3 - nums[j];\\n                \\n                int front = j+1;\\n                int back = n-1;\\n                \\n                while(front<back)\\n                {\\n                    // remaining elements to be found for quad sum\\n                    int two_sum = nums[front] + nums[back];\\n                    \\n                    if(two_sum < target2)\\n                        front++;\\n                    else if(two_sum > target2)\\n                        back--;\\n                    \\n                    else\\n                    {\\n                        // if two_sum == target2\\n                        vector<int> quad(4,0);\\n                        // quad.push_back(nums[i]);\\n                        // quad.push_back(nums[j]);\\n                        // quad.push_back(nums[front]);\\n                        // quad.push_back(nums[back]);\\n                        quad[0] = nums[i];\\n                        quad[1] = nums[j];\\n                        quad[2] = nums[front];\\n                        quad[3] = nums[back];\\n                        \\n                        \\n                        res.push_back(quad);\\n                        \\n                        // Processing the duplicates of number 3\\n                        while(front < back && nums[front] == quad[2]) \\n                            front++;\\n                        \\n                        // Processing the duplicates of number 4\\n                        while(front < back && nums[back] == quad[3]) \\n                            back--;\\n                    }\\n                    \\n                }\\n                // Processing the duplicates of number 2\\n                    while(j + 1 < n && nums[j + 1] == nums[j]) \\n                        j++;\\n            }\\n            // Processing the duplicates of number 2\\n                    while(i + 1 < n && nums[i + 1] == nums[i]) \\n                        i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Input => arr[] = [4,3,3,4,4,2,1,2,1,1], target = 9\\n// Output => [[1,1,3,4],[1,2,2,4],[1,2,3,3]]\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> res;\\n        \\n        if(nums.empty())\\n            return res;\\n        \\n        int n = nums.size();\\n        \\n        // Approach requires sorting and 2-pointer approach\\n        \\n        // Step1 -> sorting\\n        sort(nums.begin(),nums.end());\\n        \\n        \\n        // Step2 -> 2-pointer \\n        for(int i=0; i<n; i++)\\n        {\\n            long long int target3 = target - nums[i];\\n            \\n            for(int j=i+1; j<n; j++)\\n            {\\n                long long int target2 = target3 - nums[j];\\n                \\n                int front = j+1;\\n                int back = n-1;\\n                \\n                while(front<back)\\n                {\\n                    // remaining elements to be found for quad sum\\n                    int two_sum = nums[front] + nums[back];\\n                    \\n                    if(two_sum < target2)\\n                        front++;\\n                    else if(two_sum > target2)\\n                        back--;\\n                    \\n                    else\\n                    {\\n                        // if two_sum == target2\\n                        vector<int> quad(4,0);\\n                        // quad.push_back(nums[i]);\\n                        // quad.push_back(nums[j]);\\n                        // quad.push_back(nums[front]);\\n                        // quad.push_back(nums[back]);\\n                        quad[0] = nums[i];\\n                        quad[1] = nums[j];\\n                        quad[2] = nums[front];\\n                        quad[3] = nums[back];\\n                        \\n                        \\n                        res.push_back(quad);\\n                        \\n                        // Processing the duplicates of number 3\\n                        while(front < back && nums[front] == quad[2]) \\n                            front++;\\n                        \\n                        // Processing the duplicates of number 4\\n                        while(front < back && nums[back] == quad[3]) \\n                            back--;\\n                    }\\n                    \\n                }\\n                // Processing the duplicates of number 2\\n                    while(j + 1 < n && nums[j + 1] == nums[j]) \\n                        j++;\\n            }\\n            // Processing the duplicates of number 2\\n                    while(i + 1 < n && nums[i + 1] == nums[i]) \\n                        i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8555,
                "title": "20-line-elegant-accepted-java-solution-using-backtracking",
                "content": "The key idea is using backtracking. But before each step, I checked the eligibility of i-th element in the array before adding it to the subset list. Basically a lower and an upper boundaries were added to each backtracking step.\\n```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        if(nums == null || nums.length == 0) return ans;\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        getSum(nums, 0, target, ans, list, 0);\\n        return ans;\\n    }\\n    private void getSum(int[] nums, int sum, int target, List<List<Integer>> ans, List<Integer> list, int pos){\\n        if(list.size() == 4 && sum == target && !ans.contains(list)){\\n            ans.add(new ArrayList<>(list)); return;\\n        }else if(list.size() == 4) return;\\n        for(int i = pos; i < nums.length; i++){\\n            if(nums[i] +  nums[nums.length - 1] * (3 - list.size()) + sum < target) continue;\\n            if(nums[i] * (4 - list.size()) + sum > target) return;\\n            list.add(nums[i]);\\n            getSum(nums, sum + nums[i], target, ans, list, i + 1);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        if(nums == null || nums.length == 0) return ans;\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        getSum(nums, 0, target, ans, list, 0);\\n        return ans;\\n    }\\n    private void getSum(int[] nums, int sum, int target, List<List<Integer>> ans, List<Integer> list, int pos){\\n        if(list.size() == 4 && sum == target && !ans.contains(list)){\\n            ans.add(new ArrayList<>(list)); return;\\n        }else if(list.size() == 4) return;\\n        for(int i = pos; i < nums.length; i++){\\n            if(nums[i] +  nums[nums.length - 1] * (3 - list.size()) + sum < target) continue;\\n            if(nums[i] * (4 - list.size()) + sum > target) return;\\n            list.add(nums[i]);\\n            getSum(nums, sum + nums[i], target, ans, list, i + 1);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8688,
                "title": "java-a-little-bit-faster-than-other-common-methods-9ms-beats-95",
                "content": "To avoid duplicate list items, I skip unnecessary indices at two locations:\\n\\n - one at the end of the outer loop (`i-loop`)\\n - the other at the end of the inner loop (`j-loop`). \\n\\n\\nTo avoid useless computations, the following is kind of critical:\\n\\n - the function `return` immediately when `nums[i]*4 > target`\\n - the inner loop `break` immediately when `nums[j]*4 < target`. \\n\\nThese two lines save quite some time due to the set up of the test cases in OJ.\\n\\n    public class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n            int second = 0, third = 0, nexti = 0, nextj = 0;\\n            for(int i=0, L=nums.length; i<L-3; i++) {\\n                if(nums[i]<<2 > target) return list; // return immediately\\n                for(int j=L-1; j>i+2; j--) {\\n                    if(nums[j]<<2 < target) break; // break immediately\\n                    int rem = target-nums[i]-nums[j];\\n                    int lo = i+1, hi=j-1;\\n                    while(lo<hi) {\\n                        int sum = nums[lo] + nums[hi];\\n                        if(sum>rem) --hi;\\n                        else if(sum<rem) ++lo;\\n                        else {\\n                            list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j]));\\n                            while(++lo<=hi && nums[lo-1]==nums[lo]) continue; // avoid duplicate results\\n                            while(--hi>=lo && nums[hi]==nums[hi+1]) continue; // avoid duplicate results\\n                        }\\n                    }\\n                    while(j>=1 && nums[j]==nums[j-1]) --j; // skip inner loop\\n                }\\n                while(i<L-1 && nums[i]==nums[i+1]) ++i; // skip outer loop\\n            }\\n            return list;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n            int second = 0, third = 0, nexti = 0, nextj = 0;\\n            for(int i=0, L=nums.length; i<L-3; i++) {\\n                if(nums[i]<<2 > target) return list; // return immediately\\n                for(int j=L-1; j>i+2; j--) {\\n                    if(nums[j]<<2 < target) break; // break immediately\\n                    int rem = target-nums[i]-nums[j];\\n                    int lo = i+1, hi=j-1;\\n                    while(lo<hi) {\\n                        int sum = nums[lo] + nums[hi];\\n                        if(sum>rem) --hi;\\n                        else if(sum<rem) ++lo;\\n                        else {\\n                            list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j]));\\n                            while(++lo<=hi && nums[lo-1]==nums[lo]) continue; // avoid duplicate results\\n                            while(--hi>=lo && nums[hi]==nums[hi+1]) continue; // avoid duplicate results\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 8583,
                "title": "twosum-twosum-foursum-a-simple-python-solution",
                "content": "    class Solution:\\n    # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n    def fourSum(self, num, target):\\n        two_sum = collections.defaultdict(list)\\n        res = set()\\n        for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2):\\n            two_sum[i1+i2].append({n1, n2})\\n        for t in list(two_sum.keys()):\\n            if not two_sum[target-t]:\\n                continue\\n            for pair1 in two_sum[t]:\\n                for pair2 in two_sum[target-t]:\\n                    if pair1.isdisjoint(pair2):\\n                        res.add(tuple(sorted(num[i] for i in pair1 | pair2)))\\n            del two_sum[t]\\n        return [list(r) for r in res]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n    def fourSum(self, num, target):\\n        two_sum = collections.defaultdict(list)\\n        res = set()\\n        for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2):\\n            two_sum[i1+i2].append({n1, n2}",
                "codeTag": "Java"
            },
            {
                "id": 581600,
                "title": "javascript-using-4-pointers-beats-96",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    const result = []\\n    \\n    for(let i = 0; i < nums.length - 3; i++) {\\n        for(let j = i + 1; j < nums.length - 2; j++) {\\n            let low = j + 1;\\n            let high = nums.length - 1\\n\\n            while(low < high) {\\n                const sum = nums[i] + nums[j] + nums[low] + nums[high];\\n                if(sum === target) {\\n                    result.push([nums[i], nums[j], nums[low], nums[high]])\\n                    while(nums[low] === nums[low + 1]) low++;\\n                    while(nums[high] === nums[high - 1]) high--;\\n                    low++;\\n                    high--;\\n                } else if(sum < target) {\\n                    low++\\n                } else {\\n                    high--\\n                }\\n            }   \\n            while(nums[j] === nums[j + 1]) j++;\\n        }   \\n        while(nums[i] === nums[i + 1]) i++;\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    const result = []\\n    \\n    for(let i = 0; i < nums.length - 3; i++) {\\n        for(let j = i + 1; j < nums.length - 2; j++) {\\n            let low = j + 1;\\n            let high = nums.length - 1\\n\\n            while(low < high) {\\n                const sum = nums[i] + nums[j] + nums[low] + nums[high];\\n                if(sum === target) {\\n                    result.push([nums[i], nums[j], nums[low], nums[high]])\\n                    while(nums[low] === nums[low + 1]) low++;\\n                    while(nums[high] === nums[high - 1]) high--;\\n                    low++;\\n                    high--;\\n                } else if(sum < target) {\\n                    low++\\n                } else {\\n                    high--\\n                }\\n            }   \\n            while(nums[j] === nums[j + 1]) j++;\\n        }   \\n        while(nums[i] === nums[i + 1]) i++;\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341532,
                "title": "c-simple-and-clean-o-n-2-solution-including-detailed-explanation",
                "content": "**Steps:**\\n1. First we store in a map `twoSums` all the pairs of numbers, while the key is their sum and the value is a pair of indices.\\n2. For each twoSum, we check if we have its complementary to target in the map too.\\n3. If so, we take the lists of indices of the key and the target-key, and pass them to the function `makePairs`.\\n4. In `makePairs` we loop through the pairs of indices of both lists and check if the indices are not the same. That\\'s because we don\\'t want to use the same index twice.\\n5. We sort the four results to avoid duplicate fourSums in different orders.\\n6. Insert into a set to avoid duplicate fourSums.\\n7. Last step is to convert the set into a vector and here we got our result :)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        nums1 = nums;\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i+1; j < nums.size(); j++) {\\n                twoSums[nums[i] + nums[j]].push_back({i, j});\\n            }\\n        }\\n        \\n        for (auto [key, value] : twoSums) {\\n            int tmp = target - key;\\n            if (twoSums.find(tmp) != twoSums.end()) makePairs(twoSums[key], twoSums[tmp]);\\n        }\\n        \\n        vector<vector<int>> res(fourSums.begin(), fourSums.end()); \\n        return res;\\n    }\\n    \\n    void makePairs(vector<pair<int, int>> arr1, vector<pair<int, int>> arr2) {\\n        for (auto [a, b] : arr1) {\\n            for (auto [c, d] : arr2) {\\n                if (a != c && b != c && a != d && b != d) {\\n                    vector<int> tmp = {nums1[a], nums1[b], nums1[c], nums1[d]};\\n                    sort(tmp.begin(), tmp.end());\\n                    fourSums.insert(tmp);\\n                } \\n            }\\n        }\\n    }\\n\\nprivate:\\n    set<vector<int>> fourSums;\\n    unordered_map<int, vector<pair<int, int>>> twoSums;\\n    vector<int> nums1;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        nums1 = nums;\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i+1; j < nums.size(); j++) {\\n                twoSums[nums[i] + nums[j]].push_back({i, j});\\n            }\\n        }\\n        \\n        for (auto [key, value] : twoSums) {\\n            int tmp = target - key;\\n            if (twoSums.find(tmp) != twoSums.end()) makePairs(twoSums[key], twoSums[tmp]);\\n        }\\n        \\n        vector<vector<int>> res(fourSums.begin(), fourSums.end()); \\n        return res;\\n    }\\n    \\n    void makePairs(vector<pair<int, int>> arr1, vector<pair<int, int>> arr2) {\\n        for (auto [a, b] : arr1) {\\n            for (auto [c, d] : arr2) {\\n                if (a != c && b != c && a != d && b != d) {\\n                    vector<int> tmp = {nums1[a], nums1[b], nums1[c], nums1[d]};\\n                    sort(tmp.begin(), tmp.end());\\n                    fourSums.insert(tmp);\\n                } \\n            }\\n        }\\n    }\\n\\nprivate:\\n    set<vector<int>> fourSums;\\n    unordered_map<int, vector<pair<int, int>>> twoSums;\\n    vector<int> nums1;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369782,
                "title": "optimized-c-solution-beats-99-8",
                "content": "```cpp\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n\\tstd::vector<std::vector<int>> result;\\n\\tstd::size_t n = nums.size();\\n\\tif (n < 4) {\\n\\t\\treturn result;\\n\\t}\\n\\n\\tstd::sort(nums.begin(), nums.end());\\n\\tfor (int i = 0; i < n-3; ++i) {\\n\\t\\t/* Conditions for pruning */\\n\\t\\t// target too small, no point in continuing\\n\\t\\tif (target <= 0 and nums[i] > 0) break;\\n\\t\\t// nums[i] has become too large, no point in continuing\\n\\t\\tif (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;\\n\\t\\t// nums[i] is so small, even the largest elements cannot help reach the sum\\n\\t\\tif (nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t // skip duplicates\\n\\t\\tif (i > 0 and nums[i] == nums[i-1]) continue;\\n\\n\\t\\t/* Now explore further */\\n\\t\\tfor (int j = i+1; j < n - 2; ++j) {\\n\\t\\t\\t/* Some more pruning */\\n\\t\\t\\t// nums[j] has become too large, no point in continuing\\n\\t\\t\\tif (nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) break;\\n\\t\\t\\t// nums[j] is so small, even the largest elements cannot help reach the sum\\n\\t\\t\\tif (nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t\\tif (j > i+1 and nums[j] == nums[j-1]) continue; // skip duplicates\\n\\n\\t\\t\\t/* Explore the solution space */\\n\\t\\t\\tint left = j+1, right = n-1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\t\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\t\\tresult.push_back({nums[i], nums[j], nums[left], nums[right]});\\n\\t\\t\\t\\t\\tint last_left = nums[left], last_right = nums[right];\\n\\t\\t\\t\\t\\twhile (left < right and nums[left] == last_left) ++left;\\n\\t\\t\\t\\t\\twhile (left < right and nums[right] == last_right) --right;\\n\\t\\t\\t\\t} else if (sum < target) {\\n\\t\\t\\t\\t\\t++left;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t--right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```cpp\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n\\tstd::vector<std::vector<int>> result;\\n\\tstd::size_t n = nums.size();\\n\\tif (n < 4) {\\n\\t\\treturn result;\\n\\t}\\n\\n\\tstd::sort(nums.begin(), nums.end());\\n\\tfor (int i = 0; i < n-3; ++i) {\\n\\t\\t/* Conditions for pruning */\\n\\t\\t// target too small, no point in continuing\\n\\t\\tif (target <= 0 and nums[i] > 0) break;\\n\\t\\t// nums[i] has become too large, no point in continuing\\n\\t\\tif (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;\\n\\t\\t// nums[i] is so small, even the largest elements cannot help reach the sum\\n\\t\\tif (nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t // skip duplicates\\n\\t\\tif (i > 0 and nums[i] == nums[i-1]) continue;\\n\\n\\t\\t/* Now explore further */\\n\\t\\tfor (int j = i+1; j < n - 2; ++j) {\\n\\t\\t\\t/* Some more pruning */\\n\\t\\t\\t// nums[j] has become too large, no point in continuing\\n\\t\\t\\tif (nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) break;\\n\\t\\t\\t// nums[j] is so small, even the largest elements cannot help reach the sum\\n\\t\\t\\tif (nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t\\tif (j > i+1 and nums[j] == nums[j-1]) continue; // skip duplicates\\n\\n\\t\\t\\t/* Explore the solution space */\\n\\t\\t\\tint left = j+1, right = n-1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\t\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\t\\tresult.push_back({nums[i], nums[j], nums[left], nums[right]});\\n\\t\\t\\t\\t\\tint last_left = nums[left], last_right = nums[right];\\n\\t\\t\\t\\t\\twhile (left < right and nums[left] == last_left) ++left;\\n\\t\\t\\t\\t\\twhile (left < right and nums[right] == last_right) --right;\\n\\t\\t\\t\\t} else if (sum < target) {\\n\\t\\t\\t\\t\\t++left;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t--right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8563,
                "title": "clean-c-19ms-backtracking-81-90",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>res;\\n        vector<int>path;\\n        DFS(res, nums, 0, target, 0, 0, path);\\n        return res;\\n    }\\n    \\n    void DFS(vector<vector<int>>& res, vector<int>& nums, int pos, int target, int count, int sum, vector<int>& path){\\n        if(count == 4){\\n            if(sum == target) res.push_back(path);\\n            return;\\n        }\\n        for(int i = pos; i < nums.size(); i++){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            if(sum + nums[i] + (3 - count) * nums[nums.size() - 1] < target) continue;\\n            if(sum + (4 - count)* nums[i] > target) break;\\n            path.push_back(nums[i]);\\n            DFS(res, nums, i + 1, target, count + 1, sum + nums[i], path);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>res;\\n        vector<int>path;\\n        DFS(res, nums, 0, target, 0, 0, path);\\n        return res;\\n    }\\n    \\n    void DFS(vector<vector<int>>& res, vector<int>& nums, int pos, int target, int count, int sum, vector<int>& path){\\n        if(count == 4){\\n            if(sum == target) res.push_back(path);\\n            return;\\n        }\\n        for(int i = pos; i < nums.size(); i++){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            if(sum + nums[i] + (3 - count) * nums[nums.size() - 1] < target) continue;\\n            if(sum + (4 - count)* nums[i] > target) break;\\n            path.push_back(nums[i]);\\n            DFS(res, nums, i + 1, target, count + 1, sum + nums[i], path);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8759,
                "title": "a-conise-python-solution-based-on-ksum",
                "content": "    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            num.sort()\\n            def ksum(num, k, target):\\n                i = 0\\n                result = set()\\n                if k == 2:\\n                    j = len(num) - 1\\n                    while i < j:\\n                        if num[i] + num[j] == target:\\n                            result.add((num[i], num[j]))\\n                            i += 1\\n                        elif num[i] + num[j] > target:\\n                            j -= 1\\n                        else:\\n                            i += 1\\n                else:\\n                    while i < len(num) - k + 1:\\n                        newtarget = target - num[i]\\n                        subresult = ksum(num[i+1:], k - 1, newtarget)\\n                        if subresult:\\n                            result = result | set( (num[i],) + nr for nr in subresult)\\n                        i += 1\\n                    \\n                return result\\n            \\n            return [list(t) for t in ksum(num, 4, target)]",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            num.sort()\\n            def ksum(num, k, target):\\n                i = 0\\n                result = set()\\n                if k == 2:\\n                    j = len(num) - 1\\n                    while i < j:\\n                        if num[i] + num[j] == target:\\n                            result.add((num[i], num[j]))\\n                            i += 1\\n                        elif num[i] + num[j] > target:\\n                            j -= 1\\n                        else:\\n                            i += 1\\n                else:\\n                    while i < len(num) - k + 1:\\n                        newtarget = target - num[i]\\n                        subresult = ksum(num[i+1:], k - 1, newtarget)\\n                        if subresult:\\n                            result = result | set( (num[i],) + nr for nr in subresult)\\n                        i += 1\\n                    \\n                return result\\n            \\n            return [list(t) for t in ksum(num, 4, target)]",
                "codeTag": "Java"
            },
            {
                "id": 3441034,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        output.push_back({nums[i], nums[j], nums[low], nums[high]});\\n                        int tempIndex1 = low, tempIndex2 = high;\\n                        while(low < high && nums[low] == nums[tempIndex1]) low++;\\n                        while(low < high && nums[high] == nums[tempIndex2]) high--;\\n                    }\\n                }\\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\\n            }\\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        output.push_back({nums[i], nums[j], nums[low], nums[high]});\\n                        int tempIndex1 = low, tempIndex2 = high;\\n                        while(low < high && nums[low] == nums[tempIndex1]) low++;\\n                        while(low < high && nums[high] == nums[tempIndex2]) high--;\\n                    }\\n                }\\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\\n            }\\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545624,
                "title": "easy-c-solution-with-explanation-using-4-pointers",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- First, we\\u2019ll sort the array.\\n- Take 4 pointers: ***i, j, left, right.***\\n- Outer 2 loops for ***i & j.*** We store the remaining value to find in sum variable.\\n- Then we try to calculate the ***left+right*** values & if they are equal then push all 4 values to the set.\\n- If the value is less than sum then we\\u2019ll increase left because array is in sorted order, else we\\u2019ll decrease right.\\n- **Time complexity:** O(n^3 logn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>>ans;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j=0, l, r;\\n        while(i<n){\\n            j=i+1;\\n            while(j<n){\\n                int sum=target-nums[i]-nums[j];\\n                l=j+1; r=n-1;\\n                while(l<r){\\n                    int x = nums[l]+nums[r];\\n                    int y = nums[l], z= nums[r] ;\\n                    if(x>sum)\\n                        r--;\\n                    else if(x<sum)\\n                        l++;\\n                    else{\\n                        ans.insert({nums[i],nums[j],nums[l],nums[r]});\\n                        while(l<r && nums[r]==z)r--;\\n                        while(l<r && nums[l]==y)l++;\\n                    }\\n                }j++;\\n               \\n            }i++;\\n        }\\n        vector<vector<int>>res(ans.begin(),ans.end());\\n        return res;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>>ans;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j=0, l, r;\\n        while(i<n){\\n            j=i+1;\\n            while(j<n){\\n                int sum=target-nums[i]-nums[j];\\n                l=j+1; r=n-1;\\n                while(l<r){\\n                    int x = nums[l]+nums[r];\\n                    int y = nums[l], z= nums[r] ;\\n                    if(x>sum)\\n                        r--;\\n                    else if(x<sum)\\n                        l++;\\n                    else{\\n                        ans.insert({nums[i],nums[j],nums[l],nums[r]});\\n                        while(l<r && nums[r]==z)r--;\\n                        while(l<r && nums[l]==y)l++;\\n                    }\\n                }j++;\\n               \\n            }i++;\\n        }\\n        vector<vector<int>>res(ans.begin(),ans.end());\\n        return res;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672948,
                "title": "universal-solution-to-solve-any-n-sum-problem-using-recursion",
                "content": "```javascript\\nvar fourSum = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    const result = [];\\n    \\n    // k represents N-sum, \\n    // if k = 3 : 3Sum, if k = 4 : 4Sum, if k = 5, 5Sum; \\n    function recurse(arr, tar, res, k) {\\n        if(k === 2) {\\n            twoSum(arr, tar, res);\\n            return;\\n        }\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            while(arr[i] === arr[i-1]) i++;\\n            recurse(arr.slice(i+1), tar - arr[i], [...res, arr[i]], k-1);\\n        }\\n    }\\n    \\n    function twoSum(arr, tar, res) {\\n        let low = 0, high = arr.length-1;\\n        \\n        while(low < high) {\\n            const sum = arr[low] + arr[high];\\n            if(sum === tar)  {\\n                result.push([...res, arr[low], arr[high]]);\\n                while(arr[low] === arr[low+1]) low++;\\n                while(arr[high] === arr[high-1]) high--;\\n                low++;\\n                high--;\\n            } else if(sum < tar) low++;\\n            else high--;\\n        }\\n    }\\n    \\n    recurse(nums, target, [], 4)\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar fourSum = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    const result = [];\\n    \\n    // k represents N-sum, \\n    // if k = 3 : 3Sum, if k = 4 : 4Sum, if k = 5, 5Sum; \\n    function recurse(arr, tar, res, k) {\\n        if(k === 2) {\\n            twoSum(arr, tar, res);\\n            return;\\n        }\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            while(arr[i] === arr[i-1]) i++;\\n            recurse(arr.slice(i+1), tar - arr[i], [...res, arr[i]], k-1);\\n        }\\n    }\\n    \\n    function twoSum(arr, tar, res) {\\n        let low = 0, high = arr.length-1;\\n        \\n        while(low < high) {\\n            const sum = arr[low] + arr[high];\\n            if(sum === tar)  {\\n                result.push([...res, arr[low], arr[high]]);\\n                while(arr[low] === arr[low+1]) low++;\\n                while(arr[high] === arr[high-1]) high--;\\n                low++;\\n                high--;\\n            } else if(sum < tar) low++;\\n            else high--;\\n        }\\n    }\\n    \\n    recurse(nums, target, [], 4)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450396,
                "title": "python-76-ms-beats-97-09-explain-why-it-is-fast",
                "content": "# Problem:\\n\\n> Given an array `nums` of *n* integers and an integer `target`, are there elements *a*, *b*, *c*, and *d* in `nums` such that *a* + *b* + *c* + *d* = `target`? Find all unique quadruplets in the array which gives the sum of `target`. The solution set must not contain duplicate quadruplets.\\n\\nExample :\\n\\n\\n```\\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\\n\\nA solution set is:\\n[\\n  [-1,  0, 0, 1],\\n  [-2, -1, 1, 2],\\n  [-2,  0, 0, 2]\\n]\\n```\\n\\n## Solution 1\\n\\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        i = 0\\n        L = len(nums)\\n        res = []\\n        while i < L-3:\\n            j = i+1\\n            while j < L-2:\\n                left = j+1\\n                right = L-1\\n                new_target = target-nums[i]-nums[j]\\n                while left<right:\\n                    if nums[left]+nums[right] > new_target:\\n                        right-=1\\n                    elif nums[left]+nums[right] < new_target:\\n                        left+=1\\n                    else:\\n                        res.append([nums[i],nums[j],nums[left],nums[right]])\\n                        temp_left = nums[left]\\n                        temp_right = nums[right]\\n                        while(left<right and nums[left]==temp_left):\\n                            left+=1\\n                        while(left<right and nums[right]==temp_right):\\n                            right-=1\\n                while j < L-3 and nums[j] == nums[j+1]:\\n                    j+=1\\n                j+=1\\n            while i < L-4 and nums[i] == nums[i+1]:\\n                i+=1\\n            i+=1\\n        return res\\n```\\n> Runtime: 880 ms; Memory Usage: 12.8 MB\\n\\n## Solution 2\\n\\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        res = []\\n        self.findNSum(nums, target, 4, [], res)\\n        return res\\n\\n    def findNSum(self, nums, target, N, prefix, result):\\n        L = len(nums)\\n        if N == 2:\\n            l, r = 0, L-1\\n            while l < r:\\n                add = nums[l] + nums[r]\\n                if add == target:\\n                    result.append(prefix + [nums[l], nums[r]])\\n                    l += 1\\n                    r -= 1\\n                    while l<r and nums[l-1] == nums[l]:\\n                        l += 1\\n                    while l<r and nums[r+1] == nums[r]:\\n                        r -= 1\\n                elif add > target:\\n                    r -= 1\\n                else:\\n                    l += 1\\n        else:\\n            for i in range(L-N+1):\\n                if target < N*nums[i] or target > N*nums[-1]: # key judgement\\n                    break\\n                if i == 0 or (i>0 and nums[i] != nums[i-1]):\\n                    self.findNSum(nums[i+1:], target-nums[i], N-1, prefix+[nums[i]], result)\\n        return\\n```\\n> Runtime: 84 ms; Memory Usage: 12.8 MB\\n\\n## Solution 3\\n\\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        i = 0\\n        L = len(nums)\\n        res = []\\n        while i < L-3:\\n            if target-nums[i] < 3*nums[i+1] or target-nums[i] > 3*nums[-1]:\\n                    while i < L-4 and nums[i] == nums[i+1]:\\n                        i+=1\\n                    i+=1\\n                    continue\\n            j = i+1\\n            while j < L-2:\\n                if target-nums[i]-nums[j] < 2*nums[j+1] or target-nums[i]-nums[j] > 2*nums[-1]:\\n                    while j < L-3 and nums[j] == nums[j+1]:\\n                        j+=1\\n                    j+=1\\n                    continue\\n                left = j+1\\n                right = L-1\\n                new_target = target-nums[i]-nums[j]\\n                while left<right:\\n                    if nums[left]+nums[right] > new_target:\\n                        right-=1\\n                    elif nums[left]+nums[right] < new_target:\\n                        left+=1\\n                    else:\\n                        res.append([nums[i],nums[j],nums[left],nums[right]])\\n                        temp_left = nums[left]\\n                        temp_right = nums[right]\\n                        while(left<right and nums[left]==temp_left):\\n                            left+=1\\n                        while(left<right and nums[right]==temp_right):\\n                            right-=1\\n                while j < L-3 and nums[j] == nums[j+1]:\\n                    j+=1\\n                j+=1\\n            while i < L-4 and nums[i] == nums[i+1]:\\n                i+=1\\n            i+=1\\n        return res\\n```\\n> Runtime: 76 ms; Memory Usage: 12.8 MB\\n\\n## Note:\\n\\n- \\u5728\\u7B2C\\u4E8C\\u79CD\\u7B97\\u6CD5\\u662F\\u9012\\u5F52\\u7B97\\u6CD5\\u3002\\n- \\u7B2C\\u4E8C\\u79CD\\u7B97\\u6CD5\\u6BD4\\u7B2C\\u4E00\\u79CD\\u7B97\\u6CD5\\u5FEB\\u5728`line 28`\\uFF0C\\u5373\\u5173\\u952E\\u5224\\u65AD\\u3002\\n- \\u7B2C\\u4E09\\u79CD\\u7B97\\u6CD5\\u662F\\u5728\\u7B2C\\u4E00\\u79CD\\u7B97\\u6CD5\\u7684\\u57FA\\u7840\\u4E0A\\u589E\\u52A0\\u4E86\\u5173\\u952E\\u5224\\u65AD\\uFF0C\\u901F\\u5EA6\\u5F97\\u5230\\u5927\\u5E45\\u63D0\\u5347\\u3002\\u5E76\\u4E14\\u6BD4\\u9012\\u5F52\\u7B97\\u6CD5\\u66F4\\u5FEB\\u3002\\n- Solution 2 is recursive algorithm.\\n- Solution 2 is faster than solution 1 because of `line 28`, which is the key judgement.\\n- Adding the key judgement to solution1 makes solution 3, which is even faster than recursive algorithm solution 2.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\\n\\nA solution set is:\\n[\\n  [-1,  0, 0, 1],\\n  [-2, -1, 1, 2],\\n  [-2,  0, 0, 2]\\n]\\n```\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        i = 0\\n        L = len(nums)\\n        res = []\\n        while i < L-3:\\n            j = i+1\\n            while j < L-2:\\n                left = j+1\\n                right = L-1\\n                new_target = target-nums[i]-nums[j]\\n                while left<right:\\n                    if nums[left]+nums[right] > new_target:\\n                        right-=1\\n                    elif nums[left]+nums[right] < new_target:\\n                        left+=1\\n                    else:\\n                        res.append([nums[i],nums[j],nums[left],nums[right]])\\n                        temp_left = nums[left]\\n                        temp_right = nums[right]\\n                        while(left<right and nums[left]==temp_left):\\n                            left+=1\\n                        while(left<right and nums[right]==temp_right):\\n                            right-=1\\n                while j < L-3 and nums[j] == nums[j+1]:\\n                    j+=1\\n                j+=1\\n            while i < L-4 and nums[i] == nums[i+1]:\\n                i+=1\\n            i+=1\\n        return res\\n```\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        res = []\\n        self.findNSum(nums, target, 4, [], res)\\n        return res\\n\\n    def findNSum(self, nums, target, N, prefix, result):\\n        L = len(nums)\\n        if N == 2:\\n            l, r = 0, L-1\\n            while l < r:\\n                add = nums[l] + nums[r]\\n                if add == target:\\n                    result.append(prefix + [nums[l], nums[r]])\\n                    l += 1\\n                    r -= 1\\n                    while l<r and nums[l-1] == nums[l]:\\n                        l += 1\\n                    while l<r and nums[r+1] == nums[r]:\\n                        r -= 1\\n                elif add > target:\\n                    r -= 1\\n                else:\\n                    l += 1\\n        else:\\n            for i in range(L-N+1):\\n                if target < N*nums[i] or target > N*nums[-1]: # key judgement\\n                    break\\n                if i == 0 or (i>0 and nums[i] != nums[i-1]):\\n                    self.findNSum(nums[i+1:], target-nums[i], N-1, prefix+[nums[i]], result)\\n        return\\n```\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        i = 0\\n        L = len(nums)\\n        res = []\\n        while i < L-3:\\n            if target-nums[i] < 3*nums[i+1] or target-nums[i] > 3*nums[-1]:\\n                    while i < L-4 and nums[i] == nums[i+1]:\\n                        i+=1\\n                    i+=1\\n                    continue\\n            j = i+1\\n            while j < L-2:\\n                if target-nums[i]-nums[j] < 2*nums[j+1] or target-nums[i]-nums[j] > 2*nums[-1]:\\n                    while j < L-3 and nums[j] == nums[j+1]:\\n                        j+=1\\n                    j+=1\\n                    continue\\n                left = j+1\\n                right = L-1\\n                new_target = target-nums[i]-nums[j]\\n                while left<right:\\n                    if nums[left]+nums[right] > new_target:\\n                        right-=1\\n                    elif nums[left]+nums[right] < new_target:\\n                        left+=1\\n                    else:\\n                        res.append([nums[i],nums[j],nums[left],nums[right]])\\n                        temp_left = nums[left]\\n                        temp_right = nums[right]\\n                        while(left<right and nums[left]==temp_left):\\n                            left+=1\\n                        while(left<right and nums[right]==temp_right):\\n                            right-=1\\n                while j < L-3 and nums[j] == nums[j+1]:\\n                    j+=1\\n                j+=1\\n            while i < L-4 and nums[i] == nums[i+1]:\\n                i+=1\\n            i+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8664,
                "title": "share-my-python-code-run-time-200-20ms",
                "content": "    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            num.sort()\\n            result = []\\n            for i in xrange(len(num)-3):\\n                if num[i] > target/4.0:\\n                    break\\n                if i > 0 and num[i] == num[i-1]:\\n                    continue\\n                target2 = target - num[i]\\n                for j in xrange(i+1, len(num)-2):\\n                    if num[j] > target2/3.0:\\n                        break\\n                    if j > i+1 and num[j] == num[j-1]:\\n                        continue\\n                    k = j + 1\\n                    l = len(num) - 1\\n                    target3 = target2 - num[j]\\n                    # we should use continue not break\\n                    # because target3 changes as j changes\\n                    if num[k] > target3/2.0:\\n                        continue\\n                    if num[l] < target3/2.0:\\n                        continue\\n                    while k < l:\\n                        sum_value = num[k] + num[l]\\n                        if sum_value == target3:\\n                            result.append([num[i], num[j], num[k], num[l]])\\n                            kk = num[k]\\n                            k += 1\\n                            while k<l and num[k] == kk:\\n                                k += 1\\n                            \\n                            ll = num[l]\\n                            l -= 1\\n                            while k<l and num[l] == ll:\\n                                l -= 1\\n                        elif sum_value < target3:\\n                            k += 1\\n                        else:\\n                            l -= 1\\n            return result\\n\\nWe can reduce run time by adding some restrictions.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            num.sort()\\n            result = []\\n            for i in xrange(len(num)-3):\\n                if num[i] > target/4.0:\\n                    break\\n                if i > 0 and num[i] == num[i-1]:\\n                    continue\\n                target2 = target - num[i]\\n                for j in xrange(i+1, len(num)-2):\\n                    if num[j] > target2/3.0:\\n                        break\\n                    if j > i+1 and num[j] == num[j-1]:\\n                        continue\\n                    k = j + 1\\n                    l = len(num) - 1\\n                    target3 = target2 - num[j]\\n                    # we should use continue not break\\n                    # because target3 changes as j changes\\n                    if num[k] > target3/2.0:\\n                        continue\\n                    if num[l] < target3/2.0:\\n                        continue\\n                    while k < l:\\n                        sum_value = num[k] + num[l]\\n                        if sum_value == target3:\\n                            result.append([num[i], num[j], num[k], num[l]])\\n                            kk = num[k]\\n                            k += 1\\n                            while k<l and num[k] == kk:\\n                                k += 1\\n                            \\n                            ll = num[l]\\n                            l -= 1\\n                            while k<l and num[l] == ll:\\n                                l -= 1\\n                        elif sum_value < target3:\\n                            k += 1\\n                        else:\\n                            l -= 1\\n            return result\\n\\nWe can reduce run time by adding some restrictions.",
                "codeTag": "Java"
            },
            {
                "id": 1533287,
                "title": "short-simple-solution-in-python",
                "content": "\\n\\tdef fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans = set()\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                left = j + 1\\n                right = n - 1\\n\\n                while left < right:\\n                    total = nums[i] + nums[left] + nums[right]+nums[j]\\n                    if total > target:\\n                        right -= 1\\n                    elif total < target:\\n                        left += 1\\n                    else:\\n                        ans.add(tuple(sorted((nums[i], nums[left], nums[right],nums[j]))))\\n                    \\n                        left += 1\\n                        right -= 1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "\\n\\tdef fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans = set()\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                left = j + 1\\n                right = n - 1\\n\\n                while left < right:\\n                    total = nums[i] + nums[left] + nums[right]+nums[j]\\n                    if total > target:\\n                        right -= 1\\n                    elif total < target:\\n                        left += 1\\n                    else:\\n                        ans.add(tuple(sorted((nums[i], nums[left], nums[right],nums[j]))))\\n                    \\n                        left += 1\\n                        right -= 1\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 260087,
                "title": "clear-and-simple-python3-solution-with-comment-o-n-3",
                "content": "```python\\nclass Solution:\\n    def fourSum(self, nums, target: int):\\n        res = []\\n        nums.sort()\\n\\n        # loop for first num, n times\\n        for i in range(len(nums) - 3):\\n            \\n            # skip duplication\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # skip uneccesary case\\n            if nums[i] * 4 > target:\\n                break\\n\\n            # loop for second number, n times\\n            for j in range(i + 1, len(nums) - 2):\\n                \\n                # skip duplication\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n\\n                # skip uneccesary case\\n                if nums[j] * 3 > target - nums[i]:\\n                    break\\n\\n                # search for last 2 nums, same as 2Sum/3Sum problem\\n                l, r = j + 1, len(nums) - 1\\n\\n                while l < r:\\n                    \\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\\n                    if s > target:\\n                        r = r - 1\\n                    elif s < target:\\n                        l = l + 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        while l < r and nums[l] == nums[l + 1]:\\n                            l = l + 1\\n                        while l < r and nums[r] == nums[r - 1]:\\n                            r = r - 1\\n                        l, r = l + 1, r - 1\\n            \\n        return res\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def fourSum(self, nums, target: int):\\n        res = []\\n        nums.sort()\\n\\n        # loop for first num, n times\\n        for i in range(len(nums) - 3):\\n            \\n            # skip duplication\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # skip uneccesary case\\n            if nums[i] * 4 > target:\\n                break\\n\\n            # loop for second number, n times\\n            for j in range(i + 1, len(nums) - 2):\\n                \\n                # skip duplication\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n\\n                # skip uneccesary case\\n                if nums[j] * 3 > target - nums[i]:\\n                    break\\n\\n                # search for last 2 nums, same as 2Sum/3Sum problem\\n                l, r = j + 1, len(nums) - 1\\n\\n                while l < r:\\n                    \\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\\n                    if s > target:\\n                        r = r - 1\\n                    elif s < target:\\n                        l = l + 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        while l < r and nums[l] == nums[l + 1]:\\n                            l = l + 1\\n                        while l < r and nums[r] == nums[r - 1]:\\n                            r = r - 1\\n                        l, r = l + 1, r - 1\\n            \\n        return res\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 8608,
                "title": "java-backtracking-solution-for-k-sum-beat-94",
                "content": "Some tips:\\n1) avoid sum cases by viewing nums[start]*k and nums[end]*k \\n2) when backtracking, first add nums[i] to current list, after that then remove\\n\\nOne C++ Reference: http://bangbingsyb.blogspot.hk/2014/11/leetcode-4sum.html \\n\\n    public class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n            kSum(result, new ArrayList<Integer>(), nums, target, 4, 0, nums.length-1);\\n            return result;\\n        }\\n    \\n        private void kSum(List<List<Integer>> result,List<Integer> cur,int[] nums, int target,int k,int start, int end){\\n            if(k == 0 || nums.length==0 || start>end) return;\\n            if(k == 1){\\n                for (int i = start; i <= end ; i++) {\\n                    if(nums[i] == target){\\n                        cur.add(nums[i]);\\n                        result.add(new ArrayList<Integer>(cur));\\n                        cur.remove(cur.size()-1);\\n                    }\\n                }\\n                return;\\n            }\\n    \\n            if(k == 2){ // 2 sum\\n                int sum;\\n                while (start < end){\\n                    sum = nums[start]+nums[end];\\n    \\n                    if(sum == target){\\n                        cur.add(nums[start]);\\n                        cur.add(nums[end]);\\n                        result.add(new ArrayList<Integer>(cur));\\n                        cur.remove(cur.size()-1);\\n                        cur.remove(cur.size()-1);\\n    \\n                        //avoid duplicate\\n                        while(start < end && nums[start] == nums[start+1]) ++start;\\n                        ++start;\\n                        while(start < end && nums[end] == nums[end-1]) --end;\\n                        --end;\\n                    }else if(sum < target){\\n                        //avoid duplicate\\n                        while(start < end && nums[start] == nums[start+1]) ++start;\\n                        ++start;\\n                    }else{\\n                        while(start < end && nums[end] == nums[end-1]) --end;\\n                        --end;\\n                    }\\n                }\\n                return;\\n            }\\n    \\n            //\\u907f\\u514d\\u4e00\\u4e9b\\u4e0d\\u5fc5\\u8981case\\n            if(k*nums[start] > target || k*nums[end]<target) return;\\n    \\n            // k > 2 : choose nums[i] and do k-1 sum on the rest at right\\n            for (int i = start; i <= (end-k+1) ; i++) {\\n                // avoid duplicate\\n                if(i>start && nums[i]==nums[i-1]) continue;\\n                // \\u91cd\\u70b9\\n                if(k*nums[i] <= target) { //\\u907f\\u514d\\u6389\\u4e00\\u4e9b\\u4e0d\\u5fc5\\u8981case\\n                    cur.add(nums[i]);\\n                    kSum(result, cur, nums, target - nums[i], k - 1, i + 1, end);\\n                    cur.remove(cur.size() - 1);\\n                }\\n            }\\n    \\n        }\\n    }",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n            kSum(result, new ArrayList<Integer>(), nums, target, 4, 0, nums.length-1);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2057363,
                "title": "0ms-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Kotlin ***\\n\\n```\\n\\nclass Solution {\\n    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {\\n\\tval arrayList = ArrayList<List<Int>>()\\n\\tnums.sort() // sort necessary to filter out duplicates\\n\\n\\tfor (i in 0 until nums.size) {\\n\\t\\tif (i > 0 && nums[i] == nums[i - 1]) {\\n\\t\\t\\tcontinue //since sorted, it is ok to skip and remove duplicates.\\n\\t\\t}\\n\\n\\t\\tfor (j in i + 1 until nums.size) {\\n\\t\\t\\tif (j > i + 1 && nums[j] == nums[j - 1]) {\\n\\t\\t\\t\\tcontinue //since sorted, it is ok to skip and remove duplicates.\\n\\t\\t\\t}\\n\\n\\t\\t\\tval friend = target - nums[i] - nums[j]\\n\\t\\t\\tvar left = j + 1\\n\\t\\t\\tvar right = nums.size - 1\\n\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tval sumIJ = nums[left] + nums[right]\\n\\t\\t\\t\\twhen {\\n\\t\\t\\t\\t\\tsumIJ < friend -> left++\\n\\t\\t\\t\\t\\tsumIJ > friend -> right--\\n\\t\\t\\t\\t\\tsumIJ == friend -> {\\n\\t\\t\\t\\t\\t\\t//detect duplicates, since they are in order, duplicates will be adjacent.\\n\\t\\t\\t\\t\\t\\t//so it is sufficient to compare to previous value\\n\\t\\t\\t\\t\\t\\tif (left > j + 1 && right < nums.size - 1) {\\n\\t\\t\\t\\t\\t\\t\\tif (nums[left] != nums[left - 1] || nums[right] != nums[right + 1]) {\\n\\t\\t\\t\\t\\t\\t\\t\\tarrayList.add(listOf(nums[i], nums[j], nums[left], nums[right]))\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tarrayList.add(listOf(nums[i], nums[j], nums[left], nums[right]))\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn arrayList\\n}\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n***\"We are Anonymous. We are legion. We do not forgive. We do not forget. Expect us. Open your eyes..\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {\\n\\tval arrayList = ArrayList<List<Int>>()\\n\\tnums.sort() // sort necessary to filter out duplicates\\n\\n\\tfor (i in 0 until nums.size) {\\n\\t\\tif (i > 0 && nums[i] == nums[i - 1]) {\\n\\t\\t\\tcontinue //since sorted, it is ok to skip and remove duplicates.\\n\\t\\t}\\n\\n\\t\\tfor (j in i + 1 until nums.size) {\\n\\t\\t\\tif (j > i + 1 && nums[j] == nums[j - 1]) {\\n\\t\\t\\t\\tcontinue //since sorted, it is ok to skip and remove duplicates.\\n\\t\\t\\t}\\n\\n\\t\\t\\tval friend = target - nums[i] - nums[j]\\n\\t\\t\\tvar left = j + 1\\n\\t\\t\\tvar right = nums.size - 1\\n\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tval sumIJ = nums[left] + nums[right]\\n\\t\\t\\t\\twhen {\\n\\t\\t\\t\\t\\tsumIJ < friend -> left++\\n\\t\\t\\t\\t\\tsumIJ > friend -> right--\\n\\t\\t\\t\\t\\tsumIJ == friend -> {\\n\\t\\t\\t\\t\\t\\t//detect duplicates, since they are in order, duplicates will be adjacent.\\n\\t\\t\\t\\t\\t\\t//so it is sufficient to compare to previous value\\n\\t\\t\\t\\t\\t\\tif (left > j + 1 && right < nums.size - 1) {\\n\\t\\t\\t\\t\\t\\t\\tif (nums[left] != nums[left - 1] || nums[right] != nums[right + 1]) {\\n\\t\\t\\t\\t\\t\\t\\t\\tarrayList.add(listOf(nums[i], nums[j], nums[left], nums[right]))\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tarrayList.add(listOf(nums[i], nums[j], nums[left], nums[right]))\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn arrayList\\n}\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491146,
                "title": "two-pointers-solution-java-o-n-3-time",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length-3; i++) {\\n            if(i==0 || i>0 && nums[i]!=nums[i-1]) {\\n                for(int j=i+1; j<nums.length-2; j++) {\\n                    if(j==i+1 || (j>i+1 && nums[j]!=nums[j-1])) {\\n                        int low = j+1;\\n                        int high = nums.length-1;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t//to prevent integer overflow\\n                        long sum = nums[i]+nums[j];\\n                        long val = ((long)target - sum);\\n\\t\\t\\t\\t\\t\\t\\n                        while(low < high) {\\n                            if(nums[low]+nums[high] < val)\\n                                low++;\\n                            else if(nums[low]+nums[high] > val)\\n                                high--;\\n                            else {\\n                                ans.add(Arrays.asList(nums[i], nums[j], nums[low], nums[high]));\\n                                while(low<high && nums[low]==nums[low+1])\\n                                    low++;\\n                                while(low<high && nums[high]==nums[high-1])\\n                                    high--;\\n                                low++;\\n                                high--;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length-3; i++) {\\n            if(i==0 || i>0 && nums[i]!=nums[i-1]) {\\n                for(int j=i+1; j<nums.length-2; j++) {\\n                    if(j==i+1 || (j>i+1 && nums[j]!=nums[j-1])) {\\n                        int low = j+1;\\n                        int high = nums.length-1;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t//to prevent integer overflow\\n                        long sum = nums[i]+nums[j];\\n                        long val = ((long)target - sum);\\n\\t\\t\\t\\t\\t\\t\\n                        while(low < high) {\\n                            if(nums[low]+nums[high] < val)\\n                                low++;\\n                            else if(nums[low]+nums[high] > val)\\n                                high--;\\n                            else {\\n                                ans.add(Arrays.asList(nums[i], nums[j], nums[low], nums[high]));\\n                                while(low<high && nums[low]==nums[low+1])\\n                                    low++;\\n                                while(low<high && nums[high]==nums[high-1])\\n                                    high--;\\n                                low++;\\n                                high--;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359731,
                "title": "generic-k-sum-easy-to-understand",
                "content": "```\\n\\ninterface IKSum {\\n\\n    List<List<Integer>> kSum(int nums[], int k, int target);\\n}\\n\\n/**\\n * We\\'ll use the problem of k sum and reduce it to two sum and attache the result back\\n */\\nclass KSumSorting implements IKSum {\\n\\n    @Override\\n    public List<List<Integer>> kSum(int[] nums, int k, int target) {\\n        if (nums == null || nums.length == 0 || nums.length < k)\\n            return Collections.EMPTY_LIST;\\n\\n        Arrays.sort(nums);\\n\\n        return kSum(nums, k, 0, target);\\n\\n    }\\n\\n    private List<List<Integer>> kSum(int[] nums, int k, int start, int target) {\\n        int len = nums.length;\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (len < k)\\n            return Collections.EMPTY_LIST;\\n\\n        if (k == 2) {\\n            return twoSum(nums, start, len - 1, target);\\n        } else {\\n\\n            /**\\n             * Take each element, and exclude it from target to reduce the problem to smaller k-1 sum problem\\n             */\\n            for (int i = start; i < len - (k - 1); i++) {\\n                /**\\n                 * Avoid duplicates\\n                 */\\n                if (i > start && nums[i] == nums[i - 1])\\n                    continue;\\n\\n                int ele = nums[i];\\n\\n                int rem = target - nums[i];\\n                List<List<Integer>> smallerSumResult = kSum(nums, k - 1, i + 1, rem);\\n\\n                /**\\n                 * Append the current element to make it k sum from k-1 sum\\n                 */\\n                for (List<Integer> list : smallerSumResult)\\n                    list.add(0, ele);\\n\\n                /**\\n                 * Append to our result\\n                 */\\n                result.addAll(smallerSumResult);\\n\\n\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private List<List<Integer>> twoSum(int nums[], int low, int high, int target) {\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        while (low < high) {\\n\\n            int sum = nums[low] + nums[high];\\n\\n            if (sum == target) {\\n                List<Integer> twoSum = new ArrayList<>();\\n                twoSum.add(nums[low]);\\n                twoSum.add(nums[high]);\\n\\n                result.add(twoSum);\\n\\n                /**\\n                 * Avoid duplicates\\n                 */\\n\\n                while (low < high && nums[low] == nums[++low]) ;\\n                while (high > low && nums[high] == nums[--high]) ;\\n\\n            } else if (sum < target)\\n                low++;\\n            else\\n                high--;\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\\n\\nDriver code\\n\\n```\\n\\npublic class KSum {\\n    public static void main(String[] args) {\\n        test(new int[]{1, 0, -1, 0, -2},  4, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 4, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 4, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 4, 0);\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  5, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 5, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 5, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 5, 0);\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  3, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 3, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 3, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 3, 0);\\n\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  2, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 2, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 2, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 2, 0);\\n\\n    }\\n\\n    private static void test(int[] nums, int k, int target) {\\n        IKSum kSum = new KSumSorting();\\n\\n        System.out.println(\"\\\\nInput : \" + Printer.toString(nums) + \" K :\" + k + \" Target: \" + target);\\n        System.out.println(\"Sorting: \" + kSum.kSum(nums, k, target));\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\ninterface IKSum {\\n\\n    List<List<Integer>> kSum(int nums[], int k, int target);\\n}\\n\\n/**\\n * We\\'ll use the problem of k sum and reduce it to two sum and attache the result back\\n */\\nclass KSumSorting implements IKSum {\\n\\n    @Override\\n    public List<List<Integer>> kSum(int[] nums, int k, int target) {\\n        if (nums == null || nums.length == 0 || nums.length < k)\\n            return Collections.EMPTY_LIST;\\n\\n        Arrays.sort(nums);\\n\\n        return kSum(nums, k, 0, target);\\n\\n    }\\n\\n    private List<List<Integer>> kSum(int[] nums, int k, int start, int target) {\\n        int len = nums.length;\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (len < k)\\n            return Collections.EMPTY_LIST;\\n\\n        if (k == 2) {\\n            return twoSum(nums, start, len - 1, target);\\n        } else {\\n\\n            /**\\n             * Take each element, and exclude it from target to reduce the problem to smaller k-1 sum problem\\n             */\\n            for (int i = start; i < len - (k - 1); i++) {\\n                /**\\n                 * Avoid duplicates\\n                 */\\n                if (i > start && nums[i] == nums[i - 1])\\n                    continue;\\n\\n                int ele = nums[i];\\n\\n                int rem = target - nums[i];\\n                List<List<Integer>> smallerSumResult = kSum(nums, k - 1, i + 1, rem);\\n\\n                /**\\n                 * Append the current element to make it k sum from k-1 sum\\n                 */\\n                for (List<Integer> list : smallerSumResult)\\n                    list.add(0, ele);\\n\\n                /**\\n                 * Append to our result\\n                 */\\n                result.addAll(smallerSumResult);\\n\\n\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private List<List<Integer>> twoSum(int nums[], int low, int high, int target) {\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        while (low < high) {\\n\\n            int sum = nums[low] + nums[high];\\n\\n            if (sum == target) {\\n                List<Integer> twoSum = new ArrayList<>();\\n                twoSum.add(nums[low]);\\n                twoSum.add(nums[high]);\\n\\n                result.add(twoSum);\\n\\n                /**\\n                 * Avoid duplicates\\n                 */\\n\\n                while (low < high && nums[low] == nums[++low]) ;\\n                while (high > low && nums[high] == nums[--high]) ;\\n\\n            } else if (sum < target)\\n                low++;\\n            else\\n                high--;\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\n```\\n\\npublic class KSum {\\n    public static void main(String[] args) {\\n        test(new int[]{1, 0, -1, 0, -2},  4, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 4, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 4, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 4, 0);\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  5, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 5, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 5, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 5, 0);\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  3, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 3, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 3, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 3, 0);\\n\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  2, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 2, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 2, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 2, 0);\\n\\n    }\\n\\n    private static void test(int[] nums, int k, int target) {\\n        IKSum kSum = new KSumSorting();\\n\\n        System.out.println(\"\\\\nInput : \" + Printer.toString(nums) + \" K :\" + k + \" Target: \" + target);\\n        System.out.println(\"Sorting: \" + kSum.kSum(nums, k, target));\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512671,
                "title": "c-java-python-javascript-two-pointer-array",
                "content": "# Intuition:\\nThe problem asks to find all unique quadruplets in the given array whose sum equals the target value. We can use a similar approach as we do for the 3Sum problem. We can sort the array and then use two pointers approach to find the quadruplets whose sum equals the target value.\\n\\n# Approach:\\n\\n1. Sort the input array in non-decreasing order.\\n2. Traverse the array from 0 to n-3 and use a variable i to keep track of the first element in the quadruplet.\\n3. If the current element is the same as the previous element, skip it to avoid duplicates.\\n4. Traverse the array from i+1 to n-2 and use a variable j to keep track of the second element in the quadruplet.\\n5. If the current element is the same as the previous element, skip it to avoid duplicates.\\n6. Use two pointers, left = j+1 and right = n-1, to find the other two elements in the quadruplet whose sum equals the target value.\\n7. If the sum of the four elements is less than the target value, increment left pointer.\\n8. If the sum of the four elements is greater than the target value, decrement right pointer.\\n9. If the sum of the four elements is equal to the target value, add the quadruplet to the result and increment left and decrement right pointers.\\n10. Skip duplicate values of left and right pointers to avoid duplicate quadruplets.\\n11. Return the result.\\n\\n# Complexity\\n- Time Complexity: O(n^3) where n is the length of the input array. The two outer loops run in O(n^2) time and the inner two-pointer loop runs in O(n) time.\\n\\n- Space Complexity: O(1) because we are not using any extra space apart from the output array.\\n- \\n# Similar Question: [https://leetcode.com/problems/3sum/solutions/3416585/c-java-python-javascript-fully-explained-two-pointer-array/?orderBy=most_votes]()\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> quadruplets;\\n        int n = nums.size();\\n        // Sorting the array\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i - 1]){\\n                continue;\\n            }\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicates\\n                if (j > i + 1 && nums[j] == nums[j - 1]){\\n                    continue;\\n                }\\n                int left = j + 1;\\n                int right = n - 1;\\n                while (left < right) {\\n                    long long sum = static_cast<long long>(nums[i]) + nums[j] + nums[left] + nums[right];\\n                    if (sum < target) {\\n                        left++;\\n                    } else if (sum > target) {\\n                        right--;\\n                    } else {\\n                        quadruplets.push_back({nums[i], nums[j], nums[left], nums[right]});\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left + 1]){\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]){\\n                            right--;\\n                        }\\n                        left++;\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return quadruplets;\\n    }\\n};\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        quadruplets = []\\n        n = len(nums)\\n        # Sorting the array\\n        nums.sort()\\n        for i in range(n - 3):\\n            # Skip duplicates\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            for j in range(i + 1, n - 2):\\n                # Skip duplicates\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n                left = j + 1\\n                right = n - 1\\n                while left < right:\\n                    sum = nums[i] + nums[j] + nums[left] + nums[right]\\n                    if sum < target:\\n                        left += 1\\n                    elif sum > target:\\n                        right -= 1\\n                    else:\\n                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])\\n                        # Skip duplicates\\n                        while left < right and nums[left] == nums[left + 1]:\\n                            left += 1\\n                        while left < right and nums[right] == nums[right - 1]:\\n                            right -= 1\\n                        left += 1\\n                        right -= 1\\n        return quadruplets\\n\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> quadruplets = new ArrayList<>();\\n        int n = nums.length;\\n        // Sorting the array\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicates\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n                int left = j + 1;\\n                int right = n - 1;\\n                while (left < right) {\\n                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum < target) {\\n                        left++;\\n                    } else if (sum > target) {\\n                        right--;\\n                    } else {\\n                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n                        left++;\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return quadruplets;\\n    }\\n}\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar fourSum = function(nums, target) {\\n  nums.sort((a, b) => a - b);\\n  const quadruplets = [];\\n  const n = nums.length;\\n  for (let i = 0; i < n - 3; i++) {\\n    if (i > 0 && nums[i] === nums[i - 1]) {\\n      continue;\\n    }\\n    for (let j = i + 1; j < n - 2; j++) {\\n      if (j > i + 1 && nums[j] === nums[j - 1]) {\\n        continue;\\n      }\\n      let left = j + 1;\\n      let right = n - 1;\\n      while (left < right) {\\n        const sum = BigInt(nums[i]) + BigInt(nums[j]) + BigInt(nums[left]) + BigInt(nums[right]);\\n        if (sum < target) {\\n          left++;\\n        } else if (sum > target) {\\n          right--;\\n        } else {\\n          quadruplets.push([nums[i], nums[j], nums[left], nums[right]]);\\n          while (left < right && nums[left] === nums[left + 1]) {\\n            left++;\\n          }\\n          while (left < right && nums[right] === nums[right - 1]) {\\n            right--;\\n          }\\n          left++;\\n          right--;\\n        }\\n      }\\n    }\\n  }\\n  return quadruplets;\\n};\\n```\\n\\n---\\n\\n# Similar Question: [https://leetcode.com/problems/3sum/solutions/3416585/c-java-python-javascript-fully-explained-two-pointer-array/?orderBy=most_votes]()",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> quadruplets;\\n        int n = nums.size();\\n        // Sorting the array\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i - 1]){\\n                continue;\\n            }\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicates\\n                if (j > i + 1 && nums[j] == nums[j - 1]){\\n                    continue;\\n                }\\n                int left = j + 1;\\n                int right = n - 1;\\n                while (left < right) {\\n                    long long sum = static_cast<long long>(nums[i]) + nums[j] + nums[left] + nums[right];\\n                    if (sum < target) {\\n                        left++;\\n                    } else if (sum > target) {\\n                        right--;\\n                    } else {\\n                        quadruplets.push_back({nums[i], nums[j], nums[left], nums[right]});\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left + 1]){\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]){\\n                            right--;\\n                        }\\n                        left++;\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return quadruplets;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        quadruplets = []\\n        n = len(nums)\\n        # Sorting the array\\n        nums.sort()\\n        for i in range(n - 3):\\n            # Skip duplicates\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            for j in range(i + 1, n - 2):\\n                # Skip duplicates\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n                left = j + 1\\n                right = n - 1\\n                while left < right:\\n                    sum = nums[i] + nums[j] + nums[left] + nums[right]\\n                    if sum < target:\\n                        left += 1\\n                    elif sum > target:\\n                        right -= 1\\n                    else:\\n                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])\\n                        # Skip duplicates\\n                        while left < right and nums[left] == nums[left + 1]:\\n                            left += 1\\n                        while left < right and nums[right] == nums[right - 1]:\\n                            right -= 1\\n                        left += 1\\n                        right -= 1\\n        return quadruplets\\n\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> quadruplets = new ArrayList<>();\\n        int n = nums.length;\\n        // Sorting the array\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicates\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n                int left = j + 1;\\n                int right = n - 1;\\n                while (left < right) {\\n                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum < target) {\\n                        left++;\\n                    } else if (sum > target) {\\n                        right--;\\n                    } else {\\n                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n                        left++;\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return quadruplets;\\n    }\\n}\\n\\n```\n```\\nvar fourSum = function(nums, target) {\\n  nums.sort((a, b) => a - b);\\n  const quadruplets = [];\\n  const n = nums.length;\\n  for (let i = 0; i < n - 3; i++) {\\n    if (i > 0 && nums[i] === nums[i - 1]) {\\n      continue;\\n    }\\n    for (let j = i + 1; j < n - 2; j++) {\\n      if (j > i + 1 && nums[j] === nums[j - 1]) {\\n        continue;\\n      }\\n      let left = j + 1;\\n      let right = n - 1;\\n      while (left < right) {\\n        const sum = BigInt(nums[i]) + BigInt(nums[j]) + BigInt(nums[left]) + BigInt(nums[right]);\\n        if (sum < target) {\\n          left++;\\n        } else if (sum > target) {\\n          right--;\\n        } else {\\n          quadruplets.push([nums[i], nums[j], nums[left], nums[right]]);\\n          while (left < right && nums[left] === nums[left + 1]) {\\n            left++;\\n          }\\n          while (left < right && nums[right] === nums[right - 1]) {\\n            right--;\\n          }\\n          left++;\\n          right--;\\n        }\\n      }\\n    }\\n  }\\n  return quadruplets;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048440,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, long target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        if(nums.size()<4)\\n            return ans;\\n        int n=nums.size();\\n        for(int i=0;i<n-3;i++)\\n        {\\n            for(int j=i+1; j<n-2;j++)\\n            {\\n                long sum=target-nums[i]-nums[j];\\n                int l=j+1, r=n-1;\\n                vector<int> v(4);\\n                while(l<r)\\n                {\\n                    if(nums[l]+nums[r]==sum)\\n                    {\\n                        v[0]=nums[i];\\n                        v[1]=nums[j];\\n                        v[2]=nums[l];\\n                        v[3]=nums[r];\\n                        ans.push_back(v);\\n                        while(l<r && v[2]==nums[l])\\n                            l++;\\n                        while(l<r && v[3]==nums[r])\\n                            r--;\\n                    }\\n                    else if(nums[l]+nums[r]<sum)\\n                        l++;\\n                    else\\n                        r--;\\n                }\\n                while(j<n-2 && nums[j]==nums[j+1])\\n                    j++;\\n            }\\n            while(i<n-3 && nums[i]==nums[i+1])\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, long target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        if(nums.size()<4)\\n            return ans;\\n        int n=nums.size();\\n        for(int i=0;i<n-3;i++)\\n        {\\n            for(int j=i+1; j<n-2;j++)\\n            {\\n                long sum=target-nums[i]-nums[j];\\n                int l=j+1, r=n-1;\\n                vector<int> v(4);\\n                while(l<r)\\n                {\\n                    if(nums[l]+nums[r]==sum)\\n                    {\\n                        v[0]=nums[i];\\n                        v[1]=nums[j];\\n                        v[2]=nums[l];\\n                        v[3]=nums[r];\\n                        ans.push_back(v);\\n                        while(l<r && v[2]==nums[l])\\n                            l++;\\n                        while(l<r && v[3]==nums[r])\\n                            r--;\\n                    }\\n                    else if(nums[l]+nums[r]<sum)\\n                        l++;\\n                    else\\n                        r--;\\n                }\\n                while(j<n-2 && nums[j]==nums[j+1])\\n                    j++;\\n            }\\n            while(i<n-3 && nums[i]==nums[i+1])\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342347,
                "title": "c-recursion-4ms-99-81-faster-code-explained-clearly",
                "content": "Here I used a very clever technique of reducing any n sum problem to a two sum by using recursing and simplification. The most time saving techniques was the skipping of duplicates and unnecessry cases by using if cases. Read the code carefully and please do **upvote** if you like the approach.\\n```\\n/*\\n  READ THE CODE USING MY MARKERS OF 1 to 10. START WITH THE foursum method AND\\n  THEN READ nSum method AND FINALLY TO twoSum.\\n*/\\nclass Solution {\\npublic:\\n  vector<vector<int>> twoSum(vector<int> &nums, int target, int start) {\\n    vector<vector<int>> result;\\n    // 7. Now we iterate through the array taking the two pointer approach and\\n    // try to find two values in the array to add to the result.\\n    int left = start, right = nums.size() - 1;\\n    while (left < right) {\\n      int curSum = nums[left] + nums[right];\\n      // 8. Now we need to move left pointer forward when sum is less than\\n      // target and also to avoid duplicates we do not consider the case when\\n      // nums[left] == nums[left - 1]. Here we write left > start to not check\\n      // nums[left] == nums[left - 1] when left == start.\\n      if (curSum < target || (left > start && nums[left] == nums[left - 1])) {\\n        left++;\\n      } else if (curSum > target || (right < nums.size() - 1 && nums[right] == nums[right + 1])) {\\n        // 9. Now we bring right pointer backwards when we have overshot the\\n        // target or when duplicates are recorded(nums[right] == nums[right + 1]\\n        // is to check for duplicates).\\n        right--;\\n      } else {\\n        // 10. This is executed when curSum == target.\\n        result.push_back({nums[left++], nums[right--]});\\n      }\\n    }\\n    return result;\\n  }\\n\\n  vector<vector<int>> nSum(vector<int> &nums, int target, int start, int n) {\\n    vector<vector<int>> result;\\n    // 2. If the current start value has reached end or start element times n is\\n    // greater than target or target is smaller than last element times n. We\\n    // cannot get any solution.\\n    if (start == nums.size() || nums[start] * n > target ||\\n        target > nums.back() * n) {\\n      return result;\\n    }\\n\\n    if (n == 2) {\\n      // 3. We simply calculate twoSum when we need to.\\n      return twoSum(nums, target, start);\\n    }\\n\\n    // 4. When n > 2, we need to reduce the problem into a twosum problem. This\\n    // is done by taking a sub problem. Here we consider the ith element and\\n    // call the function itself to calculate sum for (n - 1)th sum with a new\\n    // target of (target - nums[i]). Also we should start the call for search\\n    // with a start index if i + 1 so as to avoid duplicates. We also consider\\n    // skipping nums[i] when nums[i - 1] == nums[i] because the array is sorted\\n    // and we will avoid duplicates to be detected.\\n    for (int i = start; i < nums.size(); i++) {\\n      if (i == start || nums[i - 1] != nums[i]) {\\n        for (auto &j : nSum(nums, target - nums[i], i + 1, n - 1)) {\\n          // 5. Now the j variable is an iterator to the vectors where a target\\n          // of (target - nums[i]) has been achieved and we use this iterator to\\n          // add to the vector inside the result where nums[i] is present.\\n          result.push_back({nums[i]});\\n          // 6. Here, since we just added nums[i] to result, we now insert\\n          // inside the vector of {nums[i]} the values which came from the n-1\\n          // sum call. These results are concatenated to the nums[i].\\n          result.back().insert(end(result.back()), begin(j), end(j));\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n  vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n    // 1. We need a sorted array\\n    sort(begin(nums), end(nums));\\n    return nSum(nums, target, 0, 4);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*\\n  READ THE CODE USING MY MARKERS OF 1 to 10. START WITH THE foursum method AND\\n  THEN READ nSum method AND FINALLY TO twoSum.\\n*/\\nclass Solution {\\npublic:\\n  vector<vector<int>> twoSum(vector<int> &nums, int target, int start) {\\n    vector<vector<int>> result;\\n    // 7. Now we iterate through the array taking the two pointer approach and\\n    // try to find two values in the array to add to the result.\\n    int left = start, right = nums.size() - 1;\\n    while (left < right) {\\n      int curSum = nums[left] + nums[right];\\n      // 8. Now we need to move left pointer forward when sum is less than\\n      // target and also to avoid duplicates we do not consider the case when\\n      // nums[left] == nums[left - 1]. Here we write left > start to not check\\n      // nums[left] == nums[left - 1] when left == start.\\n      if (curSum < target || (left > start && nums[left] == nums[left - 1])) {\\n        left++;\\n      } else if (curSum > target || (right < nums.size() - 1 && nums[right] == nums[right + 1])) {\\n        // 9. Now we bring right pointer backwards when we have overshot the\\n        // target or when duplicates are recorded(nums[right] == nums[right + 1]\\n        // is to check for duplicates).\\n        right--;\\n      } else {\\n        // 10. This is executed when curSum == target.\\n        result.push_back({nums[left++], nums[right--]});\\n      }\\n    }\\n    return result;\\n  }\\n\\n  vector<vector<int>> nSum(vector<int> &nums, int target, int start, int n) {\\n    vector<vector<int>> result;\\n    // 2. If the current start value has reached end or start element times n is\\n    // greater than target or target is smaller than last element times n. We\\n    // cannot get any solution.\\n    if (start == nums.size() || nums[start] * n > target ||\\n        target > nums.back() * n) {\\n      return result;\\n    }\\n\\n    if (n == 2) {\\n      // 3. We simply calculate twoSum when we need to.\\n      return twoSum(nums, target, start);\\n    }\\n\\n    // 4. When n > 2, we need to reduce the problem into a twosum problem. This\\n    // is done by taking a sub problem. Here we consider the ith element and\\n    // call the function itself to calculate sum for (n - 1)th sum with a new\\n    // target of (target - nums[i]). Also we should start the call for search\\n    // with a start index if i + 1 so as to avoid duplicates. We also consider\\n    // skipping nums[i] when nums[i - 1] == nums[i] because the array is sorted\\n    // and we will avoid duplicates to be detected.\\n    for (int i = start; i < nums.size(); i++) {\\n      if (i == start || nums[i - 1] != nums[i]) {\\n        for (auto &j : nSum(nums, target - nums[i], i + 1, n - 1)) {\\n          // 5. Now the j variable is an iterator to the vectors where a target\\n          // of (target - nums[i]) has been achieved and we use this iterator to\\n          // add to the vector inside the result where nums[i] is present.\\n          result.push_back({nums[i]});\\n          // 6. Here, since we just added nums[i] to result, we now insert\\n          // inside the vector of {nums[i]} the values which came from the n-1\\n          // sum call. These results are concatenated to the nums[i].\\n          result.back().insert(end(result.back()), begin(j), end(j));\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n  vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n    // 1. We need a sorted array\\n    sort(begin(nums), end(nums));\\n    return nSum(nums, target, 0, 4);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272749,
                "title": "java-25-lines-of-code-easy-to-understand-answer-that-is-o-n-2-based-on-two-sum-solution",
                "content": "```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        //because res can be duplicated, we use set to deal with that\\n        //Set of a list compare all the elements in the list defaultly, you don\\'t need to override compare and hash function\\n        Set<List<Integer>> res = new HashSet<List<Integer>>();\\n        if(nums == null || nums.length < 4) {\\n            return new ArrayList<>(res);\\n        }\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        //key represents sum of first two nums, value is the list of indexes of those two nums\\n        //We dont need to worry about duplicate here, we deal with that in res set\\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                int sum = nums[i] + nums[j];\\n                //check if current nums[i] and nums[j] can combine with previous first two nums to get a target value; \\n\\t\\t\\t\\tif(map.containsKey(target - sum)) {\\n                    List<int[]> indexes = map.get(target - sum);\\n\\t\\t\\t\\t\\tfor(int[] index : indexes) {\\n                        // Here we already know that we can get 4 nums to get the target value, but we need those four nums comes in order\\n\\t\\t\\t\\t\\t\\t//assume we have first two nums nums[k], nums[l], and current nums are nums[i], nums[j], by definition, k < l and i < j are certain. So we only need to make sure that  l < i, then we can get k < l < i < j, and add it to result set \\n\\t\\t\\t\\t\\t\\tif(index[1] < i) {\\n                            //make a result\\n                            List<Integer> candidate = Arrays.asList(nums[index[0]], nums[index[1]], nums[i], nums[j]);\\n                            res.add(candidate);\\n                        }\\n                    }\\n                }\\n                List<int[]> temp = map.getOrDefault(sum, new ArrayList<>());\\n                temp.add(new int[]{i, j});\\n                map.put(sum, temp);\\n            }\\n        }\\n        //convert from Set<List> to List<List>\\n        return new ArrayList<>(res);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        //because res can be duplicated, we use set to deal with that\\n        //Set of a list compare all the elements in the list defaultly, you don\\'t need to override compare and hash function\\n        Set<List<Integer>> res = new HashSet<List<Integer>>();\\n        if(nums == null || nums.length < 4) {\\n            return new ArrayList<>(res);\\n        }\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        //key represents sum of first two nums, value is the list of indexes of those two nums\\n        //We dont need to worry about duplicate here, we deal with that in res set\\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                int sum = nums[i] + nums[j];\\n                //check if current nums[i] and nums[j] can combine with previous first two nums to get a target value; \\n\\t\\t\\t\\tif(map.containsKey(target - sum)) {\\n                    List<int[]> indexes = map.get(target - sum);\\n\\t\\t\\t\\t\\tfor(int[] index : indexes) {\\n                        // Here we already know that we can get 4 nums to get the target value, but we need those four nums comes in order\\n\\t\\t\\t\\t\\t\\t//assume we have first two nums nums[k], nums[l], and current nums are nums[i], nums[j], by definition, k < l and i < j are certain. So we only need to make sure that  l < i, then we can get k < l < i < j, and add it to result set \\n\\t\\t\\t\\t\\t\\tif(index[1] < i) {\\n                            //make a result\\n                            List<Integer> candidate = Arrays.asList(nums[index[0]], nums[index[1]], nums[i], nums[j]);\\n                            res.add(candidate);\\n                        }\\n                    }\\n                }\\n                List<int[]> temp = map.getOrDefault(sum, new ArrayList<>());\\n                temp.add(new int[]{i, j});\\n                map.put(sum, temp);\\n            }\\n        }\\n        //convert from Set<List> to List<List>\\n        return new ArrayList<>(res);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2115636,
                "title": "c-without-using-set-100-fast",
                "content": "# INSTEAD OF USING SET FOR REMOVING DUPLICATES WE ARE USING SOME WHILE LOOPS AND IF CONDITIONS:\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(ll i=0;i<nums.size();i++){\\n            if(i>0 && nums[i]==nums[i-1])continue;       //REMOVES DUPLICATE IN 1ST INDEX\\n            ll t=target-nums[i];\\n            for(ll j=i+1;j<nums.size();j++){\\n                if(j>i+1 && nums[j]==nums[j-1])continue;     //REMOVE DUPLICATE IN 2ND INDEX\\n                ll s=t-nums[j];\\n                ll left=j+1,right=nums.size()-1;\\n                while(left<right){\\n                    ll sum=nums[left] + nums[right];\\n                    if(sum==s){\\n                        ans.push_back({nums[i],nums[j],nums[left],nums[right]});\\n                        while(left<nums.size()-1 && nums[left]==nums[left+1])left++;     //REMOVE DUPLICATE IN 3RD INDEX\\n                        while(right>0 && nums[right]==nums[right-1])right--;       //REMOVE DUPLICATE IN 4TH INDEX\\n                        left++;\\n                        right--;\\n                    }\\n                    else if(sum<s)left++;\\n                    else right--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/10a8794f-c64c-4561-b4d9-2b7a2524753d_1654456657.7689903.png)\\n\\n\\n\\uD83D\\uDE4C\\uD83D\\uDE4C HAPPY CODING !!",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(ll i=0;i<nums.size();i++){\\n            if(i>0 && nums[i]==nums[i-1])continue;       //REMOVES DUPLICATE IN 1ST INDEX\\n            ll t=target-nums[i];\\n            for(ll j=i+1;j<nums.size();j++){\\n                if(j>i+1 && nums[j]==nums[j-1])continue;     //REMOVE DUPLICATE IN 2ND INDEX\\n                ll s=t-nums[j];\\n                ll left=j+1,right=nums.size()-1;\\n                while(left<right){\\n                    ll sum=nums[left] + nums[right];\\n                    if(sum==s){\\n                        ans.push_back({nums[i],nums[j],nums[left],nums[right]});\\n                        while(left<nums.size()-1 && nums[left]==nums[left+1])left++;     //REMOVE DUPLICATE IN 3RD INDEX\\n                        while(right>0 && nums[right]==nums[right-1])right--;       //REMOVE DUPLICATE IN 4TH INDEX\\n                        left++;\\n                        right--;\\n                    }\\n                    else if(sum<s)left++;\\n                    else right--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780266,
                "title": "simple-java-solution-18ms-o-n-3-hashset-100-beat",
                "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        \\n       Set<List<Integer> > set = new HashSet<>();\\n        Arrays.sort(arr);\\n        \\n        for(int i=0; i<arr.length-3; i++){\\n            for(int j=i+1; j<arr.length-2; j++){\\n                int left = j+1;\\n                int right = arr.length-1;\\n                \\n                while(left<right){\\n                    int sum = arr[i]+arr[j]+arr[left]+arr[right];\\n                    \\n                    if(sum==target) {\\n                        set.add(Arrays.asList(arr[i],arr[j],arr[left],arr[right]));\\n                        left++;\\n                        right--;\\n                    }\\n                    \\n                    else if(sum<target) left++;\\n                    \\n                    else if(sum>target) right--;\\n                    \\n                }    \\n                    \\n            }\\n                               \\n            }\\n        \\n        return new ArrayList<>(set);\\n        }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        \\n       Set<List<Integer> > set = new HashSet<>();\\n        Arrays.sort(arr);\\n        \\n        for(int i=0; i<arr.length-3; i++){\\n            for(int j=i+1; j<arr.length-2; j++){\\n                int left = j+1;\\n                int right = arr.length-1;\\n                \\n                while(left<right){\\n                    int sum = arr[i]+arr[j]+arr[left]+arr[right];\\n                    \\n                    if(sum==target) {\\n                        set.add(Arrays.asList(arr[i],arr[j],arr[left],arr[right]));\\n                        left++;\\n                        right--;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 8750,
                "title": "o-n-3-solution-is-trivial-is-there-any-o-n-2logn-algorithm",
                "content": "Any Better algorithm than O(n^3) time complexity.\\n\\n    public class Solution {\\n            public List<List<Integer>> fourSum(int[] num, int target) {\\n                List<List<Integer>> results = new LinkedList<List<Integer>>();\\n                if (num == null || num.length < 4)\\n                    return results;\\n                Arrays.sort(num);\\n        \\n                for (int s = 0; s < num.length - 3; s++) {\\n                    if (s > 0 && num[s] == num[s - 1])  continue;\\n        \\n        \\n                    for (int e = num.length - 1; e >= s + 3; e--) {\\n                        if (e < num.length - 1 && num[e] == num[e + 1]) continue;\\n        \\n                        int local = target - num[s] - num[e];\\n                        int j = s + 1;\\n                        int k = e - 1;\\n                        while (j < k) {\\n        \\n                            if (j > s + 1 && num[j] == num[j - 1]) {\\n                                j++;\\n                                continue;\\n                            }\\n                            if (k < e - 1 && num[k] == num[k + 1]) {\\n                                k--;\\n                                continue;\\n                            }\\n        \\n                            if ((num[j] + num[k]) > local)\\n                                k--;\\n                            else if ((num[j] + num[k]) < local)\\n                                j++;\\n                            else\\n                                results.add(new ArrayList<Integer>(Arrays.asList(\\n                                        num[s], num[j++], num[k--], num[e])));\\n                        }\\n                    }\\n                }\\n                return results;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public List<List<Integer>> fourSum(int[] num, int target) {\\n                List<List<Integer>> results = new LinkedList<List<Integer>>();\\n                if (num == null || num.length < 4)\\n                    return results;\\n                Arrays.sort(num);\\n        \\n                for (int s = 0; s < num.length - 3; s++) {\\n                    if (s > 0 && num[s] == num[s - 1])  continue;\\n        \\n        \\n                    for (int e = num.length - 1; e >= s + 3; e--) {\\n                        if (e < num.length - 1 && num[e] == num[e + 1]) continue;\\n        \\n                        int local = target - num[s] - num[e];\\n                        int j = s + 1;\\n                        int k = e - 1;\\n                        while (j < k) {\\n        \\n                            if (j > s + 1 && num[j] == num[j - 1]) {\\n                                j++;\\n                                continue;\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 420337,
                "title": "similar-to-3sum-use-two-pointers-java-easy-understand",
                "content": "## Problem\\n\\n> Given an array nums of `n` integers and an integer `target`, are there elements `a`, `b`, `c`, and `d` in `nums` such that `a + b + c + d = target`? Find all unique quadruplets in the array which gives the sum of `target`.\\n\\n**Note:** The solution set must not contain duplicate quadruplets.\\n\\n**Example:** \\n\\n```java\\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\\n\\nA solution set is:\\n[\\n  [-1,  0, 0, 1],\\n  [-2, -1, 1, 2],\\n  [-2,  0, 0, 2]\\n]\\n\\nInput: [0, 0, 0, 0], and target = 0.\\nOutput: [[0, 0, 0, 0]]\\n```\\n\\n\\n## Analysis\\n\\n### 3Sum + 4Sum\\n\\nUse two pointers in 3Sum.\\n\\n```java\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n  int n = nums.length;\\n  // sorting\\n  Arrays.sort(nums);\\n  // fourSum\\n  List<List<Integer>> result = new ArrayList<>();\\n  for (int i = 0; i < n; ++i) {\\n    if (i > 0 && nums[i - 1] == nums[i]) continue;\\n    threeSum(nums, i + 1, n - 1, target - nums[i], result);\\n  }\\n  return result;\\n}\\n  \\nprivate void threeSum(int[] nums, int lo, int hi, int target, List<List<Integer>> result) {\\n  int n = nums.length;\\n  int subLen = hi - lo + 1;\\n  for (int i = lo; i <= hi; ++i) {\\n    if (i > lo && nums[i] == nums[i - 1]) continue;  // skip same result\\n    // two pointers\\n    int j = i + 1, k = hi;\\n    int t = target - nums[i];\\n    while (j < k) { // each element is only used once\\n      if (nums[j] + nums[k] < t) {\\n        ++j;\\n      } else if (nums[j] + nums[k] > t) {\\n        --k;\\n      } else { // equal\\n        result.add(Arrays.asList(nums[lo - 1], nums[i], nums[j], nums[k]));\\n        ++j;\\n        --k;\\n        while (j < k && nums[j] == nums[j - 1]) j++;  // skip same result\\n        while (j < k && nums[k] == nums[k + 1]) k--;  // skip same result\\n      }\\n    }\\n  }\\n}\\n```\\n\\n**Time:** `O(N^3)`\\n**Space:** `O(1)`\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\\n\\nA solution set is:\\n[\\n  [-1,  0, 0, 1],\\n  [-2, -1, 1, 2],\\n  [-2,  0, 0, 2]\\n]\\n\\nInput: [0, 0, 0, 0], and target = 0.\\nOutput: [[0, 0, 0, 0]]\\n```\n```java\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n  int n = nums.length;\\n  // sorting\\n  Arrays.sort(nums);\\n  // fourSum\\n  List<List<Integer>> result = new ArrayList<>();\\n  for (int i = 0; i < n; ++i) {\\n    if (i > 0 && nums[i - 1] == nums[i]) continue;\\n    threeSum(nums, i + 1, n - 1, target - nums[i], result);\\n  }\\n  return result;\\n}\\n  \\nprivate void threeSum(int[] nums, int lo, int hi, int target, List<List<Integer>> result) {\\n  int n = nums.length;\\n  int subLen = hi - lo + 1;\\n  for (int i = lo; i <= hi; ++i) {\\n    if (i > lo && nums[i] == nums[i - 1]) continue;  // skip same result\\n    // two pointers\\n    int j = i + 1, k = hi;\\n    int t = target - nums[i];\\n    while (j < k) { // each element is only used once\\n      if (nums[j] + nums[k] < t) {\\n        ++j;\\n      } else if (nums[j] + nums[k] > t) {\\n        --k;\\n      } else { // equal\\n        result.add(Arrays.asList(nums[lo - 1], nums[i], nums[j], nums[k]));\\n        ++j;\\n        --k;\\n        while (j < k && nums[j] == nums[j - 1]) j++;  // skip same result\\n        while (j < k && nums[k] == nums[k + 1]) k--;  // skip same result\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371629,
                "title": "solution-in-python-3-beats-100-00-48-ms-o-n-asymptotic-analysis",
                "content": "_Asymptotic Worst Case Analysis:_\\nFor ease of analysis, we will assume that the input list is sorted since sorting only takes O(n log n) time. The worst case occurs if the target is equal to the sum of the four greatest elements in the list. This is because the search would have to continue until the very end to find the desired quadruplet _(a,b,c,d)_. For example, a list of the form _N_ = [1,2,3,4,5,6,7,8,9,10] with _target_ = 34 would require a complete run through all iterations of the three nested for loops. Note that the reason that there are only three nested for loops even though we are looking for a quadruplet is because finding the triplet _(a,b,c)_ determines a unique value of _d_ which will lead to a sum of _target_. Thus, we only need to search for triplets _(a,b,c)_ such that _target - (a+b+c)_ is in the original list.\\n\\nObserve that in the worst case, there is only one valid solution and that is found by adding the last four (i.e. the largest four) elements of the input list. Specifically, the desired quadruplet will be _( N[n-4], N[n-3], N[n-2], N[n-1] )_, where _N_ is the sorted input list and _n_ is its length. The outer for loop will have to iterate from _i_ = 1 to _i_ = _n-5_ with a guarantee of failure in finding the desired quadruplet since the lowest element in the desired quadrauplet occurs at index _n-4_. For each iteration of the outer for loop, the remaining two nested inner for loops iterate through the remaining elements to the right of index _i_, looking at all possible ordered pairs _(b,c)_ such that _target - (a+b+c)_ is in the original list. This is an O(n\\xB2) search that occurs _within_ each iteration of the outer for loop. It is guaranteed to fail in the worst case for outer loop indices from _i_ = 1 to _i_ = _n-5_. Thus in the worst case this algorithm is O(n\\xB3).\\n```\\nclass Solution:\\n    def fourSum(self, n: List[int], t: int) -> List[List[int]]:\\n    \\tif not n: return []\\n    \\tn.sort()\\n    \\tL, N, S, M = len(n), {j:i for i,j in enumerate(n)}, set(), n[-1]\\n    \\tfor i in range(L-3):\\n    \\t\\ta = n[i]\\n    \\t\\tif a + 3*M < t: continue\\n    \\t\\tif 4*a > t: break\\n    \\t\\tfor j in range(i+1,L-2):\\n    \\t\\t\\tb = n[j]\\n    \\t\\t\\tif a + b + 2*M < t: continue\\n    \\t\\t\\tif a + 3*b > t: break\\n    \\t\\t\\tfor k in range(j+1,L-1):\\n    \\t\\t\\t\\tc = n[k]\\n    \\t\\t\\t\\td = t-(a+b+c)\\n    \\t\\t\\t\\tif d > M: continue\\n    \\t\\t\\t\\tif d < c: break\\n    \\t\\t\\t\\tif d in N and N[d] > k: S.add((a,b,c,d))\\n    \\treturn S\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def fourSum(self, n: List[int], t: int) -> List[List[int]]:\\n    \\tif not n: return []\\n    \\tn.sort()\\n    \\tL, N, S, M = len(n), {j:i for i,j in enumerate(n)}",
                "codeTag": "Java"
            },
            {
                "id": 1890476,
                "title": "4sum",
                "content": "class Solution {\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                int start = j+1;\\n                int end = nums.length-1;\\n                while(end > start){\\n                    int sum = nums[i]+ nums[j] + nums[start] + nums[end];\\n                    if(sum == target){\\n                        set.add(Arrays.asList(nums[i], nums[j], nums[start++], nums[end--]));\\n                    }\\n                    else if (sum > target) end --;\\n                    else start++;\\n                }\\n            }\\n        }\\n          return new ArrayList<>(set);\\t\\n    }\\n}\\n\\n**If you like to understand the solution than please Upvote me**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                int start = j+1;\\n                int end = nums.length-1;\\n                while(end > start){\\n                    int sum = nums[i]+ nums[j] + nums[start] + nums[end];\\n                    if(sum == target){\\n                        set.add(Arrays.asList(nums[i], nums[j], nums[start++], nums[end--]));\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 8660,
                "title": "handle-ksum-yet-still-accepted-with-best-performance-16ms-in-c",
                "content": "    class Solution {\\n    private:\\n        const int K = 4;\\n        int size = 0;\\n        void search(vector<int>& nums, int pos, int k, int target, vector<int>& v, vector<vector<int>>& vv)\\n        {\\n            if(k == 2)\\n            {\\n                int l = pos, r = size-1;\\n                while(l < r)\\n                {\\n                    int t = nums[l]+nums[r];\\n                    if(t > target) r--;\\n                    else if(t < target) l++;\\n                    else \\n                    {\\n                        v[K-2] = nums[l++];\\n                        v[K-1] = nums[r--];\\n                        vv.push_back(v);\\n                        while(l<r && nums[l]==nums[l-1]) l++; //avoid duplicates;\\n                        while(l<r && nums[r]==nums[r+1]) r--; //avoid duplicates;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(int top = size-k; pos <= top; ++pos)\\n                {\\n                    int sum = 0;\\n                    for(int i = 0; i < k; i++) sum += nums[pos+i]; \\n                    if(sum > target) break; //avoid futile searching;\\n                    sum = nums[pos];\\n                    for(int i = 0; i < k-1; ++i) sum += nums[size-1-i];\\n                    if(sum < target) continue; //avoid futile searching;\\n                    v[K-k] = nums[pos];\\n                    search(nums, pos+1, k-1, target-nums[pos], v, vv);\\n                    while(pos<=top && nums[pos+1]==nums[pos]) pos++; //avoid duplicates;\\n                }\\n            }\\n        }\\n    public:\\n        //AC - 16ms - handle kSum;\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) \\n        {\\n            sort(nums.begin(), nums.end());\\n            size = nums.size();\\n            vector<vector<int>> vv;\\n            vector<int> v(K, 0);\\n            search(nums, 0, K, target, v, vv);\\n            return vv;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    private:\\n        const int K = 4;\\n        int size = 0;\\n        void search(vector<int>& nums, int pos, int k, int target, vector<int>& v, vector<vector<int>>& vv)\\n        {\\n            if(k == 2)\\n            {\\n                int l = pos, r = size-1;\\n                while(l < r)\\n                {\\n                    int t = nums[l]+nums[r];\\n                    if(t > target) r--;\\n                    else if(t < target) l++;\\n                    else \\n                    {\\n                        v[K-2] = nums[l++];\\n                        v[K-1] = nums[r--];\\n                        vv.push_back(v);\\n                        while(l<r && nums[l]==nums[l-1]) l++; //avoid duplicates;\\n                        while(l<r && nums[r]==nums[r+1]) r--; //avoid duplicates;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2725476,
                "title": "python-beginners-solution-easy",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans = set()\\n        nums.sort()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                k,l = j+1,len(nums)-1\\n                while k<l:\\n                    s = nums[i]+nums[j]+nums[k]+nums[l]\\n                    if s == target:\\n                        ans.add((nums[i],nums[j],nums[k],nums[l]))\\n                        l-=1\\n                        k+=1\\n                    elif s > target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n                  \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans = set()\\n        nums.sort()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                k,l = j+1,len(nums)-1\\n                while k<l:\\n                    s = nums[i]+nums[j]+nums[k]+nums[l]\\n                    if s == target:\\n                        ans.add((nums[i],nums[j],nums[k],nums[l]))\\n                        l-=1\\n                        k+=1\\n                    elif s > target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n                  \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899612,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = nums.sorted()\\n        var res: [[Int]] = []\\n        var i = 0\\n        \\n        while i < sorted.count - 3 {\\n            if i > 0, sorted[i] == sorted[i - 1] { i += 1; continue }\\n            var j = i + 1\\n            while j < sorted.count - 2 {\\n                if j - 1 > i, sorted[j] == sorted[j - 1] { j += 1; continue }\\n                var k = j + 1\\n                var l = sorted.count - 1\\n                \\n                while k < l {\\n                    let sum = sorted[i] + sorted[j] + sorted[k] + sorted[l]\\n                    if sum == target {\\n                        if k - 1 > j, sorted[k] == sorted[k - 1] { k += 1; continue }\\n                        res.append([sorted[i], sorted[j], sorted[k], sorted[l]])\\n                        k += 1\\n                    }\\n                    if sum < target {\\n                        k += 1\\n                    } else {\\n                        l -= 1\\n                    }\\n                }\\n                j += 1\\n            }\\n            i += 1\\n        }\\n\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = nums.sorted()\\n        var res: [[Int]] = []\\n        var i = 0\\n        \\n        while i < sorted.count - 3 {\\n            if i > 0, sorted[i] == sorted[i - 1] { i += 1; continue }\\n            var j = i + 1\\n            while j < sorted.count - 2 {\\n                if j - 1 > i, sorted[j] == sorted[j - 1] { j += 1; continue }\\n                var k = j + 1\\n                var l = sorted.count - 1\\n                \\n                while k < l {\\n                    let sum = sorted[i] + sorted[j] + sorted[k] + sorted[l]\\n                    if sum == target {\\n                        if k - 1 > j, sorted[k] == sorted[k - 1] { k += 1; continue }\\n                        res.append([sorted[i], sorted[j], sorted[k], sorted[l]])\\n                        k += 1\\n                    }\\n                    if sum < target {\\n                        k += 1\\n                    } else {\\n                        l -= 1\\n                    }\\n                }\\n                j += 1\\n            }\\n            i += 1\\n        }\\n\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574383,
                "title": "simple-hashmap-implementation-c-intution-explained",
                "content": "Intution : We take a unorederd map and then calculate 2 sum of all the possiblities of i and j pair and store it in the map besides there indexes and then we run a loop and for every i and j we do target - arr[i]-arr[j] and then try to find it in the map if it exists that means this is a possible answer qudraplet .\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        if(n<4) return ans;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                mp[nums[i]+nums[j]].push_back({i,j});//making 2 sum map\\n            }\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n               if(i>0 and nums[i]==nums[i-1])  continue;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j>i+1 and nums[j]==nums[j-1])  continue;\\n                int sum=target-nums[i]-nums[j];\\n                if(mp.find(sum)!=mp.end())\\n                {\\n                    for(auto it : mp[sum])\\n                    {\\n                        int k=it.first;\\n                        int l=it.second;\\n                        if(k>j){\\n                            if(!ans.empty()&& ans.back()[0]==nums[i]&&ans.back()[1]==nums[j]&&ans.back()[2]==nums[k]&&ans.back()[3]==nums[l]) continue;\\n                            vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                            ans.push_back(temp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Up Vote this pls if you understood**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        if(n<4) return ans;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                mp[nums[i]+nums[j]].push_back({i,j});//making 2 sum map\\n            }\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n               if(i>0 and nums[i]==nums[i-1])  continue;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j>i+1 and nums[j]==nums[j-1])  continue;\\n                int sum=target-nums[i]-nums[j];\\n                if(mp.find(sum)!=mp.end())\\n                {\\n                    for(auto it : mp[sum])\\n                    {\\n                        int k=it.first;\\n                        int l=it.second;\\n                        if(k>j){\\n                            if(!ans.empty()&& ans.back()[0]==nums[i]&&ans.back()[1]==nums[j]&&ans.back()[2]==nums[k]&&ans.back()[3]==nums[l]) continue;\\n                            vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                            ans.push_back(temp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598927,
                "title": "python-generalized-soln-for-ksum-with-explanation",
                "content": "Lets generalize  1sum,2sum,3sum,4sum... problems into ksum\\n1)As we know we that 1sum is simply as returning the elements in the lists which are equal to target\\n2)First we sort the given list then\\n3)We can solve ksums where k>2 by reducing them to 2sum recursively\\n4)Where we solve 2sum problem with two pointer approach\\n```\\nres = []\\ni = begin #left pointer\\nj = len(nums) - 1 #right pointer\\nwhile i < j: #where pointers dont cross each other\\n\\tif nums[i] + nums[j] == target: \\n\\t\\tres.append([nums[i], nums[j]]) # if found then nums[i] and nums[j] pair are one of the results hence we store these as pair\\n\\t\\twhile i < j and nums[i] == nums[i + 1]:    #to remove redundant pairs\\n\\t\\t\\ti += 1\\n\\t\\twhile i < j and nums[j] == nums[j - 1]: #to remove redundant pairs\\n\\t\\t\\tj -= 1\\n\\t\\ti += 1\\n\\t\\tj -= 1\\n\\t\\t#as we found the pair we move left pointer forward and right pointer backward in list\\n\\telif nums[i] + nums[j] > target:\\n\\t\\tj -= 1\\n\\t\\t#As the sum is > target we move right pointer holding larger value to 1 step left\\n\\telse:\\n\\t\\ti += 1\\n\\t\\t#As the sum is < target we move left pointer smaller value to 1 step right\\n\\n```\\n\\n5)For 3sum we iterate over each element and find 2sum solution .ie if current index is i and element is nums[i]\\n\\twe find 2sum solution for target = target- nums[i] in list from index i+1 to i = len(nums)-1 and then add nums[i] to the solution\\n6)For ksum we iterate over each element and find (k-1)sum solution recursively.\\n\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        def helper(nums,target,ksum,begin):\\n            if begin >= len(nums): #base condition\\n                return []\\n            if ksum == 2:  \\n\\t\\t\\t #two pointer approach as we do in 2sum problem\\n                res = []\\n                i = begin\\n                j = len(nums) - 1\\n                while i < j:\\n                    if nums[i] + nums[j] == target:\\n                        res.append([nums[i], nums[j]])\\n                        while i < j and nums[i] == nums[i + 1]:\\n                            i += 1\\n                        while i < j and nums[j] == nums[j - 1]:\\n                            j -= 1\\n                        i += 1\\n                        j -= 1\\n                    elif nums[i] + nums[j] > target:\\n                        j -= 1\\n                    else:\\n                        i += 1\\n                return res\\n            res = [] \\n            for i in range(begin, len(nums) - ksum + 1):\\n                if i > begin and nums[i] == nums[i - 1] or nums[i] + nums[-1] * (ksum - 1) < target:\\n                    continue\\n\\t\\t\\t\\t\\t# the first condition is to remove Duplicates \\n\\t\\t\\t\\t\\t# the second Condition is that if we consider element nums[i] whether we get required target or not\\n\\t\\t\\t\\t\\t#ie if we consider nums[i] which is smallest in current ksum size windown and ksum-1 times of largest number in the nums and still we get sum < target the we do not need to consider nums[i]\\n                if nums[i] + nums[i + 1] * (ksum - 1) > target:\\n                    break\\n\\t\\t\\t\\t\\t#Same as above   if nums[i] + nums[i + 1] * (ksum - 1) > target it means that remaining elements after i algo give result > target hence we exit from the loop\\n                r = helper(nums, target - nums[i], ksum - 1, i + 1)\\n                for elm in r:\\n                    elm.insert(0,nums[i])\\n\\t\\t\\t\\t\\t#We insert current nums[i] to the result of ksum-1 result\\n                for elm in r:\\n                    res.append(elm)\\n\\t\\t\\t\\t\\t#we store result of size ksum \\n            return res\\n\\n        nums.sort()\\n\\t\\tksum = 4\\n\\t\\t#ksum = 4 As we are finding 4sum here\\n\\t\\t# For generailized  case \\n\\t\\t#if ksum <1: return []\\n\\t\\t#if ksum ==1:\\n\\t\\t\\t# return  [target]*nums.count(target)\\n        return helper(nums, target, ksum, 0)\\n",
                "solutionTags": [],
                "code": "```\\nres = []\\ni = begin #left pointer\\nj = len(nums) - 1 #right pointer\\nwhile i < j: #where pointers dont cross each other\\n\\tif nums[i] + nums[j] == target: \\n\\t\\tres.append([nums[i], nums[j]]) # if found then nums[i] and nums[j] pair are one of the results hence we store these as pair\\n\\t\\twhile i < j and nums[i] == nums[i + 1]:    #to remove redundant pairs\\n\\t\\t\\ti += 1\\n\\t\\twhile i < j and nums[j] == nums[j - 1]: #to remove redundant pairs\\n\\t\\t\\tj -= 1\\n\\t\\ti += 1\\n\\t\\tj -= 1\\n\\t\\t#as we found the pair we move left pointer forward and right pointer backward in list\\n\\telif nums[i] + nums[j] > target:\\n\\t\\tj -= 1\\n\\t\\t#As the sum is > target we move right pointer holding larger value to 1 step left\\n\\telse:\\n\\t\\ti += 1\\n\\t\\t#As the sum is < target we move left pointer smaller value to 1 step right\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 418208,
                "title": "c-solution-8ms-beats-97",
                "content": "Runtime: 8 ms, faster than 97.93% of C++ online submissions for 4Sum.\\nMemory Usage: 8.9 MB, less than 100.00% of C++ online submissions for 4Sum.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        for(int i=0; i<n-3; i++)\\n        {\\n            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3] > target) break;\\n            if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3] < target) continue;\\n            \\n            for(int j=i+1; j<n-2; j++)\\n            {\\n                if(nums[j]+nums[j+1]+nums[j+2] > target - nums[i]) break;\\n                if(nums[j]+nums[n-1]+nums[n-2] < target - nums[i]) continue;\\n                int newTarget = target - nums[i] - nums[j];\\n                int start = j+1;\\n                int end = n-1;\\n                \\n                while(start < end)\\n                {\\n                    if(nums[start] + nums[end] < newTarget)\\n                        start++;\\n                    else if(nums[start] + nums[end] > newTarget)\\n                        end--;\\n                    else\\n                    {\\n                        res.push_back(vector<int> {nums[i], nums[j], nums[start], nums[end]});\\n                        start++;\\n                        end--;\\n                        while(start < end && nums[start] == res.back()[2]) start++;\\n                        while(start < end && nums[end] == res.back()[3]) end--;\\n                    }\\n                }\\n                \\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\\n            }\\n            \\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        for(int i=0; i<n-3; i++)\\n        {\\n            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3] > target) break;\\n            if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3] < target) continue;\\n            \\n            for(int j=i+1; j<n-2; j++)\\n            {\\n                if(nums[j]+nums[j+1]+nums[j+2] > target - nums[i]) break;\\n                if(nums[j]+nums[n-1]+nums[n-2] < target - nums[i]) continue;\\n                int newTarget = target - nums[i] - nums[j];\\n                int start = j+1;\\n                int end = n-1;\\n                \\n                while(start < end)\\n                {\\n                    if(nums[start] + nums[end] < newTarget)\\n                        start++;\\n                    else if(nums[start] + nums[end] > newTarget)\\n                        end--;\\n                    else\\n                    {\\n                        res.push_back(vector<int> {nums[i], nums[j], nums[start], nums[end]}",
                "codeTag": "Java"
            },
            {
                "id": 406570,
                "title": "python-easy-to-understand-25-lines-dictionary-o-n-3",
                "content": "```\\ntwo_sums = {}\\nfor i in range(len(nums)):\\n\\tfor j in range(i + 1, len(nums)):\\n\\t\\tif (target - nums[i] - nums[j]) in two_sums:\\n\\t\\t\\ttwo_sums[target - nums[i] - nums[j]].append([i, j])\\n\\t\\telse:\\n\\t\\t\\ttwo_sums[target - nums[i] - nums[j]] = [[i, j]]\\n\\nfour_sums = []\\nfor i in range(len(nums)):\\n\\tfor j in range(i + 1, len(nums)):\\n\\t\\ttemp = nums[i] + nums[j]\\n\\t\\tif temp in two_sums:\\n\\t\\t\\tfor twos in two_sums[temp]:\\n\\t\\t\\t\\tif not(twos[0] == i or\\n\\t\\t\\t\\ttwos[0] == j or\\n\\t\\t\\t\\ttwos[1] == i or\\n\\t\\t\\t\\ttwos[1] == j):\\n\\t\\t\\t\\t\\tfour_sums.append([nums[i], nums[j], nums[twos[0]], nums[twos[1]]])\\n\\nreturn sorted(list(set(map(lambda x: tuple(sorted(x)), four_sums))))\\n```\\n\\n* Highly suggest you solve [Two Sum](https://leetcode.com/problems/two-sum/) and maybe even [3Sum](https://leetcode.com/problems/3sum/) first\\n* How do you break up a 4Sum problem?\\n\\t* A simple approach is to find a pair of numbers first\\n\\t* Then find another pair such that the set of those 4 numbers adds up to `target`\\n\\n\\n* First dictionary iterates through the array and adds all `i, j` pairs to a dictionary\\n* Key in this case will be `target - nums[i] - nums[j]`\\n\\t* Why `target - nums[i] - nums[j]`? `target` in the first example in the code desc. is 0. `i - j` for say, 3rd (i) and 2nd (j) index is 1\\n\\t* Essentially, this is `target` *without* `nums[i]` and `nums[j]` i.e the number your second pair that you find later needs to add up to\\n\\t* This is because you have *removed* `nums[i]` and `nums[j]` from target\\n\\t* In a nutshell, you say that an entry `x` in your dictionary represents how much of `target` you need to find if you take an entry `i, j` from the list that is held in that entry\\'s value\\n\\n* After you build the dictionary, iterate through the array of numbers\\n* For each number, iterate through each number *after* it in the array (O(n^2))\\n* Add those two numbers up\\n\\t* See a pattern here? If the sum of these two numbers is in the dictionary we built, you know every permutation of two *other* numbers in the array that give you `target` when you add them up\\n\\t* Look at every pair of those and ignore pairs where one of the indices is the same\\n\\t\\t* If the index is the same, you are looking at the same element. You need 4 different elements to add up to `target`\\n\\t* Record all quadruplets this way\\n\\n\\n* Sort quadruplets and then sort the list of quadruplets\\n* Why do I have so many calls in the last line?\\n\\t* From right to left:\\n\\t\\t* `sorted(x)` sorts the quadruplet\\n\\t\\t* `tuple(sorted(x))` converts the sorted quadruplet into a tuple so it\\'s hashable\\n\\t\\t* `map` this for every element in `four_sums` i.e every quadruplet\\n\\t\\t* Convert the list of quadruplets into a `set` so you only have unique elements\\n\\t\\t\\t* This is why we had to `tuple`-fy every quadruplet - so we can hash it\\n\\t\\t* Convert said set of quadruplets into a `sorted` `list`\\n* Ta-da!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ntwo_sums = {}\\nfor i in range(len(nums)):\\n\\tfor j in range(i + 1, len(nums)):\\n\\t\\tif (target - nums[i] - nums[j]) in two_sums:\\n\\t\\t\\ttwo_sums[target - nums[i] - nums[j]].append([i, j])\\n\\t\\telse:\\n\\t\\t\\ttwo_sums[target - nums[i] - nums[j]] = [[i, j]]\\n\\nfour_sums = []\\nfor i in range(len(nums)):\\n\\tfor j in range(i + 1, len(nums)):\\n\\t\\ttemp = nums[i] + nums[j]\\n\\t\\tif temp in two_sums:\\n\\t\\t\\tfor twos in two_sums[temp]:\\n\\t\\t\\t\\tif not(twos[0] == i or\\n\\t\\t\\t\\ttwos[0] == j or\\n\\t\\t\\t\\ttwos[1] == i or\\n\\t\\t\\t\\ttwos[1] == j):\\n\\t\\t\\t\\t\\tfour_sums.append([nums[i], nums[j], nums[twos[0]], nums[twos[1]]])\\n\\nreturn sorted(list(set(map(lambda x: tuple(sorted(x)), four_sums))))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278435,
                "title": "c-same-as-3sum",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> FourSum(int[] nums, int target) {\\n        var n = nums.Length;\\n        Array.Sort(nums);\\n\\n        var result = new List<IList<int>>();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i - 1] == nums[i]) continue;\\n            for (int j = i + 1; j < n; j++) {\\n                if (j > i + 1 && nums[j - 1] == nums[j]) continue;\\n                var left = j + 1;\\n                var right = n - 1;\\n\\n                while (left < right) {\\n                    var sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.Add(new List<int>() { nums[i], nums[j], nums[left], nums[right] });\\n\\n                        while (left < right && nums[left] == nums[left + 1]) left++;\\n                        while (left < right && nums[right] == nums[right - 1]) right--;\\n                        \\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FourSum(int[] nums, int target) {\\n        var n = nums.Length;\\n        Array.Sort(nums);\\n\\n        var result = new List<IList<int>>();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i - 1] == nums[i]) continue;\\n            for (int j = i + 1; j < n; j++) {\\n                if (j > i + 1 && nums[j - 1] == nums[j]) continue;\\n                var left = j + 1;\\n                var right = n - 1;\\n\\n                while (left < right) {\\n                    var sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.Add(new List<int>() { nums[i], nums[j], nums[left], nums[right] });\\n\\n                        while (left < right && nums[left] == nums[left + 1]) left++;\\n                        while (left < right && nums[right] == nums[right - 1]) right--;\\n                        \\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8641,
                "title": "12ms-ksum-c-code",
                "content": "Thanks to the posts from others, it really helped me understand the problem! \\nI really liked @rikimberley's example for validity checking at levels of K higher than 2 and I liked the approaches I've seen for turning the problem into a KSum problem. Now I won't have to re-write my answer if they make a 5 sum problem!\\n\\n```\\nclass Solution {\\nprivate:\\n    // Valid for K >= 2\\n    void KSum(int k, vector<int>& nums, int l, int r, int target, vector<vector<int>>& retVal, vector<int>& cur, int ci ) \\n    {\\n        int i, mn, mx;\\n        int km1 = k - 1;\\n\\n        if ( r-l+1 < k ) return;\\n        \\n        while ( l < r )\\n        {\\n            mn = nums[l];\\n            mx = nums[r];\\n            \\n            // If K minus 1 largest + min < target, move to larger\\n            if ( ( mn + km1*mx ) < target ) l++;\\n            // If K minus 1 smaller + max > target, move to smaller\\n            else if ( ( km1*mn + mx ) > target ) r--;\\n            // If K * min > target, stop looking\\n            else if ( k*mn > target ) break;\\n            // If K * min == target, reached the threshold, check then stop looking\\n            else if ( k*mn == target )\\n            {\\n                if ( ( l + km1 <= r ) && ( mn == ( nums[l+km1] ) ) )\\n                {\\n                    for ( i = 0; i < k; i++ ) cur[ci+i] = mn;\\n                    retVal.push_back( cur );\\n                }\\n                break;\\n            }\\n            // If K * max < target, stop looking\\n            else if ( k*mx < target ) break;\\n            // If K * max == target, reached the threshold, check then stop looking\\n            else if ( k*mx == target )\\n            {\\n                if ( ( l <= r - km1 ) && ( mx == ( nums[r-km1] ) ) )\\n                {\\n                    for ( i = 0; i < k; i++ ) cur[ci+i] = mx;\\n                    retVal.push_back( cur );\\n                }\\n                break;                \\n            }\\n            // If K == 2, we found a match!\\n            else if ( k == 2 )\\n            {\\n                cur[ci] = mn;\\n                cur[ci+1] = mx;\\n                retVal.push_back( cur );\\n                l++;\\n                while ( ( l < r ) && ( nums[l] == mn ) ) l++;\\n                r--;\\n                while ( ( l < r ) && ( nums[r] == mx ) ) r--;\\n            }\\n            // Otherwise, convert the problem to a K-1 problem\\n            else\\n            {\\n                cur[ci] = mn;\\n                KSum( km1, nums, ++l, r, target - mn, retVal, cur, ci+1 );\\n                while ( ( l < r ) && ( nums[l] == nums[l-1] ) ) l++;\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) \\n    {\\n        vector<vector<int>> lRetVal;\\n        vector<int> lQuad( 4, 0 ); // Pre-allocate the size of the result\\n\\n        // Sort to provide a mechanism for avoiding duplicates\\n        sort( nums.begin(), nums.end() );\\n        \\n        KSum( 4, nums, 0, nums.size()-1, target, lRetVal, lQuad, 0 );\\n\\n        return( lRetVal );        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n    // Valid for K >= 2\\n    void KSum(int k, vector<int>& nums, int l, int r, int target, vector<vector<int>>& retVal, vector<int>& cur, int ci ) \\n    {\\n        int i, mn, mx;\\n        int km1 = k - 1;\\n\\n        if ( r-l+1 < k ) return;\\n        \\n        while ( l < r )\\n        {\\n            mn = nums[l];\\n            mx = nums[r];\\n            \\n            // If K minus 1 largest + min < target, move to larger\\n            if ( ( mn + km1*mx ) < target ) l++;\\n            // If K minus 1 smaller + max > target, move to smaller\\n            else if ( ( km1*mn + mx ) > target ) r--;\\n            // If K * min > target, stop looking\\n            else if ( k*mn > target ) break;\\n            // If K * min == target, reached the threshold, check then stop looking\\n            else if ( k*mn == target )\\n            {\\n                if ( ( l + km1 <= r ) && ( mn == ( nums[l+km1] ) ) )\\n                {\\n                    for ( i = 0; i < k; i++ ) cur[ci+i] = mn;\\n                    retVal.push_back( cur );\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2632038,
                "title": "c-solution-4sum-two-pointer-approach-using-two-sum-o-n-3",
                "content": "**1. Two Pointer Approach**\\n* Pre-requisites - [Two Sum](https://leetcode.com/problems/two-sum/) , [3Sum](https://leetcode.com/problems/3sum//) (For better understanding)\\n* Time Complexity - O(N^3)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        //start & end pointers\\n        int s, e;\\n        //initializing answer vector\\n        vector<vector<int>> ans;\\n        //initializing set\\n        set<vector<int>> st;\\n        sort(nums.begin(), nums.end());\\n        \\n        //Edge Case\\n        if(n < 4){\\n            return ans;\\n        }\\n        \\n        // fixing first element of quadruplets \\n        for(int i = 0; i < n; i++){\\n            // fixing second element of quadruplets \\n            for(int j = i+1; j < n; j++){\\n                // now we are left with 2SUM problem\\n                //intializing start and end\\n                s = j + 1;\\n                e = n - 1;\\n                \\n                while(s < e){\\n                    \\n                    if((long) nums[i] + nums[j] + nums[s] + nums[e] == target){\\n                        st.insert({nums[i], nums[j], nums[s], nums[e]});\\n                        s++, e--;\\n                    }\\n                    else if((long) nums[i] + nums[j] + nums[s] + nums[e] > target){\\n                        e--;\\n                    }\\n                    else{\\n                        s++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // storing elements of set into ans\\n        for(auto i: st)\\n            ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote if is helps :)",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        //start & end pointers\\n        int s, e;\\n        //initializing answer vector\\n        vector<vector<int>> ans;\\n        //initializing set\\n        set<vector<int>> st;\\n        sort(nums.begin(), nums.end());\\n        \\n        //Edge Case\\n        if(n < 4){\\n            return ans;\\n        }\\n        \\n        // fixing first element of quadruplets \\n        for(int i = 0; i < n; i++){\\n            // fixing second element of quadruplets \\n            for(int j = i+1; j < n; j++){\\n                // now we are left with 2SUM problem\\n                //intializing start and end\\n                s = j + 1;\\n                e = n - 1;\\n                \\n                while(s < e){\\n                    \\n                    if((long) nums[i] + nums[j] + nums[s] + nums[e] == target){\\n                        st.insert({nums[i], nums[j], nums[s], nums[e]});\\n                        s++, e--;\\n                    }\\n                    else if((long) nums[i] + nums[j] + nums[s] + nums[e] > target){\\n                        e--;\\n                    }\\n                    else{\\n                        s++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // storing elements of set into ans\\n        for(auto i: st)\\n            ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343144,
                "title": "javascript-solution-with-explanation",
                "content": "We will have 2 loops for 2 elements of quadruplets. Lets say for 2 loops we will use i and j for the interations. For finding next 2 elements we will use 2 pointer method.\\nIn 2 pointer method we will have 2 pointers left and right. Initially we will set left pointer as j+1 and right as length-1.\\n\\nWe will check the sum (nums[i] + nums[j] + nums[left] + nums[right]). If it is equal to target then we will push that quadruplets to result array. We need to increase left and right pointer. Because only changing one pointer will always give different sum (not equal to target)\\nIf sum is less than target then we need to increase only left pointer(not the right pointer) because we need to increase the sum value to match it with target value. If we decrease right pointer, we will have smaller element in the combination which will not increase overall sum.(Remember the array is sorted)\\nIf sum is greater than the target then we need to reduce right pointer (as per above logic)\\n\\nTo avoid duplicate entries, we need to take care whether each element is not repeating itself for same combinations of the other elements. Lets say we have array=[3,3,4,4,4,1,1,5] and target=16\\n``` \\n//first interation \\n [3,3,4,4,4,1,1,5]  \\n  i j l         r\\n  //here sum is 15 which is less than 16. we need to increment the left point. \\n  //As next element is also same as current element for left pointer we don\\'t need to consider that combination. \\n  //We need to increment the left pointer until we get different combination. \\n  \\n  //next interation should be\\n [3,3,4,4,4,1,1,5]  \\n  i j       l   r\\n```\\n\\nThis way we need to avoid duplicates for every elements. As the array is sorted all the same elements will be side by side and we can easily avoid using same value for the perticular element.\\n  \\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    nums.sort((a,b)=>a-b)      //First sort the array in ascending order\\n    let len = nums.length;\\n    let left=0, right=0, sum=0;\\n    let result = [];\\n    for(let i=0; i<len-3; i++){\\n        for(let j=i+1; j<len-2; j++){\\n            left = j+1;\\n            right = len-1;\\n            while(left < right){\\n                sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                if(sum === target){\\n                    result.push([nums[i], nums[j], nums[left], nums[right]])\\n                    while(nums[left]===nums[left+1]) left++;     //To avoid same values for left pointer\\n                    while(nums[right]===nums[right-1]) right--;  //To avoid same values for right pointer\\n                    left++;\\n                    right--;\\n                } else if (sum < target){\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n            }\\n            while(nums[j]===nums[j+1]) j++;\\n        }\\n        while(nums[i]===nums[i+1]) i++;\\n    }\\n    return result;\\n};\\n```\\n\\nTime complexity will be O(n^3) as there are 2 loops and in worst case left pointer will go till end of the array.\\nSpace complexity will be O(1) as we are not taking any extra space to store anything.\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "``` \\n//first interation \\n [3,3,4,4,4,1,1,5]  \\n  i j l         r\\n  //here sum is 15 which is less than 16. we need to increment the left point. \\n  //As next element is also same as current element for left pointer we don\\'t need to consider that combination. \\n  //We need to increment the left pointer until we get different combination. \\n  \\n  //next interation should be\\n [3,3,4,4,4,1,1,5]  \\n  i j       l   r\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    nums.sort((a,b)=>a-b)      //First sort the array in ascending order\\n    let len = nums.length;\\n    let left=0, right=0, sum=0;\\n    let result = [];\\n    for(let i=0; i<len-3; i++){\\n        for(let j=i+1; j<len-2; j++){\\n            left = j+1;\\n            right = len-1;\\n            while(left < right){\\n                sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                if(sum === target){\\n                    result.push([nums[i], nums[j], nums[left], nums[right]])\\n                    while(nums[left]===nums[left+1]) left++;     //To avoid same values for left pointer\\n                    while(nums[right]===nums[right-1]) right--;  //To avoid same values for right pointer\\n                    left++;\\n                    right--;\\n                } else if (sum < target){\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n            }\\n            while(nums[j]===nums[j+1]) j++;\\n        }\\n        while(nums[i]===nums[i+1]) i++;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3728285,
                "title": "most-optimal-solution-with-explanation-using-two-pointers-approach-c-and-java-code",
                "content": "\\n\\n# Approach\\n- Sort the input array nums in ascending order. Sorting the array helps in identifying unique quadruplets and allows us to use the two-pointer approach efficiently.\\n\\n- Iterate through each element in the array using a loop variable i from 0 to the second-to-last index.\\n\\n- Inside the first loop, check if the current element nums[i] is the same as the previous element nums[i-1]. If they are the same, it means we have already considered this element and generated quadruplets for it. In such cases, we continue to the next iteration to avoid duplicates.\\n\\n- Start a second loop with a variable j from i+1 to the last index. This loop represents the second element in the quadruplet.\\n\\n- Similar to step 3, check if the current element nums[j] is the same as the previous element nums[j-1]. If they are the same, continue to the next iteration to avoid duplicates.\\n\\n- Set two pointers k and l. k starts from j+1 (the next element after j) and moves forward, and l starts from the last index of the array and moves backward.\\n\\n- Enter a while loop where k is less than l. This loop iterates until k and l cross each other.\\n\\n- Calculate the sum of the current elements: nums[i] + nums[j] + nums[k] + nums[l].\\n\\n- If the sum is equal to the target, we have found a valid quadruplet. Create a temporary vector temp and store the elements nums[i], nums[j], nums[k], and nums[l] in it. Add this vector to the ans vector, which stores all the unique quadruplets.\\n\\n- Move the pointers k and l towards each other. Increment k and decrement l.\\n\\n- Check for any duplicate elements while moving the pointers. If the next element is the same as the previous one, increment k or decrement l until you find a different element. This step helps in avoiding duplicate quadruplets.\\n\\n- If the sum is greater than the target, decrement l to decrease the sum.\\n\\n- If the sum is less than the target, increment k to increase the sum.\\n\\n- After the second loop ends, continue to the next iteration of the first loop.\\n\\n- Finally, return the ans vector containing all the unique quadruplets.\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(1), O(n) to store the answer\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i< nums.size(); i++){\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            for(int j = i+1; j< nums.size(); j++){\\n                if(j> i+1 && nums[j] == nums[j-1]) continue;\\n                int k = j+1;\\n                int l = nums.size() - 1;\\n                while(k<l){\\n                    long long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if(sum == target){\\n                        vector <int> temp = {nums[i], nums[j], nums[k], nums[l]};\\n                        ans.push_back(temp);\\n                        k++;\\n                        l--;\\n                        while(k<l && nums[k] == nums[k-1]) k++;\\n                        while(k<l && nums[l] == nums[l+1]) l--;\\n                    }\\n                    else if(sum > target) l--;\\n                    else k++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length - 3; i++) {\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            \\n            for (int j = i + 1; j < nums.length - 2; j++) {\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n                \\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                \\n                while (k < l) {\\n                    long sum = (long) nums[i] + nums[j] + nums[k] + nums[l];\\n                    \\n                    if (sum == target) {\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(nums[i]);\\n                        temp.add(nums[j]);\\n                        temp.add(nums[k]);\\n                        temp.add(nums[l]);\\n                        ans.add(temp);\\n                        \\n                        k++;\\n                        l--;\\n                        \\n                        while (k < l && nums[k] == nums[k - 1]) {\\n                            k++;\\n                        }\\n                        \\n                        while (k < l && nums[l] == nums[l + 1]) {\\n                            l--;\\n                        }\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i< nums.size(); i++){\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            for(int j = i+1; j< nums.size(); j++){\\n                if(j> i+1 && nums[j] == nums[j-1]) continue;\\n                int k = j+1;\\n                int l = nums.size() - 1;\\n                while(k<l){\\n                    long long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if(sum == target){\\n                        vector <int> temp = {nums[i], nums[j], nums[k], nums[l]};\\n                        ans.push_back(temp);\\n                        k++;\\n                        l--;\\n                        while(k<l && nums[k] == nums[k-1]) k++;\\n                        while(k<l && nums[l] == nums[l+1]) l--;\\n                    }\\n                    else if(sum > target) l--;\\n                    else k++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length - 3; i++) {\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            \\n            for (int j = i + 1; j < nums.length - 2; j++) {\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n                \\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                \\n                while (k < l) {\\n                    long sum = (long) nums[i] + nums[j] + nums[k] + nums[l];\\n                    \\n                    if (sum == target) {\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(nums[i]);\\n                        temp.add(nums[j]);\\n                        temp.add(nums[k]);\\n                        temp.add(nums[l]);\\n                        ans.add(temp);\\n                        \\n                        k++;\\n                        l--;\\n                        \\n                        while (k < l && nums[k] == nums[k - 1]) {\\n                            k++;\\n                        }\\n                        \\n                        while (k < l && nums[l] == nums[l + 1]) {\\n                            l--;\\n                        }\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643620,
                "title": "python3-brute-force-better-optimal-full-explanation",
                "content": "- Approach\\n    - Brute-force\\n        - We keep four-pointers `i`, `j`, `k` and `l`. For every quadruplet, we find the sum of `A[i]+A[j]+A[k]+A[l]`\\n        - If this sum equals the target, we\\u2019ve found one of the quadruplets and add it to our data structure and continue with the rest\\n        - Time Complexity: $O(n^4)$\\n        - Space Complexity: $O(m)$ where m is the number of quadruplets\\n    - Better\\n        - We store the frequency of each element in a HashMap\\n        - Based on `a + b + c + d = target` we can say that `d = target - (a+b+c)` and based on this we fix 3 elements `a`, `b` and `c` and try to find the `-(a+b+c)` in HashMap\\n        - Time Complexity: $O(n^3)$\\n        - Space Complexity: $O(n + m)$ where m is the number of quadruplets\\n    - Optimal\\n        - To get the quadruplets in sorted order, we will sort the entire array in the first step and to get the unique quads, we will simply skip the duplicate numbers while moving the pointers\\n        - Fix 2 pointers `i` and `j` and move 2 pointers `lo` and `hi`\\n        - Based on `a + b + c + d = target` we can say that `c + d = target - (a+b)` and based on this we fix element as `a` and `b` then find `c` and `d` using two pointers `lo` and `hi` (same as in 3Sum Problem)\\n        - Time Complexity: $O(n^3)$\\n        - Space Complexity: $O(m)$ where m is the number of quadruplets\\n\\n```python\\n# Python3\\n# Brute-force Solution\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        ans = set()\\n        for i in range(n-3):\\n            for j in range(i+1, n-2):\\n                for k in range(j+1, n-1):\\n                    for l in range(k+1, n):\\n                        if nums[i] + nums[j] + nums[k] + nums[l] == target:\\n                            ans.add(tuple(sorted((nums[i], nums[j], nums[k], nums[l]))))\\n        \\n        res = []\\n        for i in ans:\\n            res += list(i),\\n        return res\\n```\\n\\n```python\\n# Python3\\n# Better Solution\\nfrom collections import defaultdict\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        ans = set()\\n        hmap = defaultdict(int)\\n        for i in nums:\\n            hmap[i] += 1\\n        \\n        for i in range(n-3):\\n            hmap[nums[i]] -= 1\\n            for j in range(i+1, n-2):\\n                hmap[nums[j]] -= 1\\n                for k in range(j+1, n-1):\\n                    hmap[nums[k]] -= 1\\n                    rem = target-(nums[i] + nums[j] + nums[k])\\n                    if rem in hmap and hmap[rem] > 0:\\n                        ans.add(tuple(sorted((nums[i], nums[j], nums[k], rem))))\\n                    hmap[nums[k]] += 1\\n                hmap[nums[j]] += 1\\n            hmap[nums[i]] += 1\\n        \\n        res = []\\n        for i in ans:\\n            res += list(i),\\n        return res\\n```\\n\\n```python\\n# Python3\\n# Optimal Solution\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        nums.sort()\\n        res = []\\n\\n        for i in range(n-3):\\n            # avoid the duplicates while moving i\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            for j in range(i+1, n-2):\\n                # avoid the duplicates while moving j\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n                lo = j + 1\\n                hi = n - 1\\n                while lo < hi:\\n                    temp = nums[i] + nums[j] + nums[lo] + nums[hi]\\n                    if temp == target:\\n                        res += [nums[i], nums[j], nums[lo], nums[hi]],\\n\\n                        # skip duplicates\\n                        while lo < hi and nums[lo] == nums[lo + 1]:\\n                            lo += 1\\n                        lo += 1\\n                        while lo < hi and nums[hi] == nums[hi - 1]:\\n                            hi -= 1\\n                        hi -= 1\\n                    elif temp < target:\\n                        lo += 1\\n                    else:\\n                        hi -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```python\\n# Python3\\n# Brute-force Solution\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        ans = set()\\n        for i in range(n-3):\\n            for j in range(i+1, n-2):\\n                for k in range(j+1, n-1):\\n                    for l in range(k+1, n):\\n                        if nums[i] + nums[j] + nums[k] + nums[l] == target:\\n                            ans.add(tuple(sorted((nums[i], nums[j], nums[k], nums[l]))))\\n        \\n        res = []\\n        for i in ans:\\n            res += list(i),\\n        return res\\n```\n```python\\n# Python3\\n# Better Solution\\nfrom collections import defaultdict\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        ans = set()\\n        hmap = defaultdict(int)\\n        for i in nums:\\n            hmap[i] += 1\\n        \\n        for i in range(n-3):\\n            hmap[nums[i]] -= 1\\n            for j in range(i+1, n-2):\\n                hmap[nums[j]] -= 1\\n                for k in range(j+1, n-1):\\n                    hmap[nums[k]] -= 1\\n                    rem = target-(nums[i] + nums[j] + nums[k])\\n                    if rem in hmap and hmap[rem] > 0:\\n                        ans.add(tuple(sorted((nums[i], nums[j], nums[k], rem))))\\n                    hmap[nums[k]] += 1\\n                hmap[nums[j]] += 1\\n            hmap[nums[i]] += 1\\n        \\n        res = []\\n        for i in ans:\\n            res += list(i),\\n        return res\\n```\n```python\\n# Python3\\n# Optimal Solution\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        nums.sort()\\n        res = []\\n\\n        for i in range(n-3):\\n            # avoid the duplicates while moving i\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            for j in range(i+1, n-2):\\n                # avoid the duplicates while moving j\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n                lo = j + 1\\n                hi = n - 1\\n                while lo < hi:\\n                    temp = nums[i] + nums[j] + nums[lo] + nums[hi]\\n                    if temp == target:\\n                        res += [nums[i], nums[j], nums[lo], nums[hi]],\\n\\n                        # skip duplicates\\n                        while lo < hi and nums[lo] == nums[lo + 1]:\\n                            lo += 1\\n                        lo += 1\\n                        while lo < hi and nums[hi] == nums[hi - 1]:\\n                            hi -= 1\\n                        hi -= 1\\n                    elif temp < target:\\n                        lo += 1\\n                    else:\\n                        hi -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366996,
                "title": "0ptimized-approach-java",
                "content": "# Intuition\\nfix two-pointers and then find the remaining two elements using two pointer technique as the array will be sorted at first.\\n\\n# Approach\\nSort the array, and then fix two pointers, so the remaining sum will be (target \\u2013 (nums[i] + nums[j])). Now we can fix two-pointers, one front, and another back, and easily use a two-pointer to find the remaining two numbers of the quad. In order to avoid duplications, we jump the duplicates, because taking duplicates will result in repeating quads. We can easily jump duplicates, by skipping the same elements by running a loop.\\n# Complexity\\n- Time complexity:\\nO(n^3)--> \\n2 nested for loops and the front pointer as well as the right pointer (Third nested loop)\\n\\n- Space complexity:\\nO(1)-->\\nGenerally the space complexity that is used to return the answer is ignored\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        if(n==0||n<3){\\n            return ans;\\n        }\\n        if(target==-294967296 || target==294967296){\\n            return ans;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int low=j+1;\\n                int high=n-1;\\n                int sum=target-nums[i]-nums[j];\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        List<Integer> temp=new ArrayList<>();\\n                        temp.add(nums[i]);\\n                        temp.add(nums[j]);\\n                        temp.add(nums[low]);\\n                        temp.add(nums[high]);\\n                        ans.add(temp);\\n                        while(low<high&&nums[low]==nums[low+1]){\\n                            low++;\\n                        }\\n                        while(low<high&&nums[high]==nums[high-1]){\\n                            high--;\\n                        }\\n                        low++;\\n                        high--;\\n                    }\\n                    else if(nums[low]+nums[high]<sum){\\n                        low++;\\n                    }\\n                    else{\\n                        high--;\\n                    }\\n                }\\n                while(j+1<n&&nums[j+1]==nums[j]){\\n                    j++;\\n                }\\n            }\\n            while(i+1<n&&nums[i+1]==nums[i]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        if(n==0||n<3){\\n            return ans;\\n        }\\n        if(target==-294967296 || target==294967296){\\n            return ans;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int low=j+1;\\n                int high=n-1;\\n                int sum=target-nums[i]-nums[j];\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        List<Integer> temp=new ArrayList<>();\\n                        temp.add(nums[i]);\\n                        temp.add(nums[j]);\\n                        temp.add(nums[low]);\\n                        temp.add(nums[high]);\\n                        ans.add(temp);\\n                        while(low<high&&nums[low]==nums[low+1]){\\n                            low++;\\n                        }\\n                        while(low<high&&nums[high]==nums[high-1]){\\n                            high--;\\n                        }\\n                        low++;\\n                        high--;\\n                    }\\n                    else if(nums[low]+nums[high]<sum){\\n                        low++;\\n                    }\\n                    else{\\n                        high--;\\n                    }\\n                }\\n                while(j+1<n&&nums[j+1]==nums[j]){\\n                    j++;\\n                }\\n            }\\n            while(i+1<n&&nums[i+1]==nums[i]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344761,
                "title": "python-simple-two-pointer-approach",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        nums.sort()\\n        for a in range(n):\\n            for b in range(a+1, n):\\n                c = b+1; d = n-1\\n                while c<d:\\n                    sums = nums[a]+nums[b]+nums[c]+nums[d]\\n                    if sums < target:\\n                        c += 1\\n                    elif sums > target:\\n                        d -= 1\\n                    else:\\n                        toappend = [nums[a],nums[b],nums[c],nums[d]]\\n                        if toappend not in res:\\n                            res.append(toappend)\\n                        c +=1\\n                        d-=1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        nums.sort()\\n        for a in range(n):\\n            for b in range(a+1, n):\\n                c = b+1; d = n-1\\n                while c<d:\\n                    sums = nums[a]+nums[b]+nums[c]+nums[d]\\n                    if sums < target:\\n                        c += 1\\n                    elif sums > target:\\n                        d -= 1\\n                    else:\\n                        toappend = [nums[a],nums[b],nums[c],nums[d]]\\n                        if toappend not in res:\\n                            res.append(toappend)\\n                        c +=1\\n                        d-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365829,
                "title": "java-simple-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result=new ArrayList<>();\\n        if(nums==null || nums.length<4){\\n            return result;\\n        }\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int low=j+1;\\n                int high=n-1;\\n                \\n                while(low<high){\\n                    int sum=nums[i]+nums[j]+nums[low]+nums[high];\\n                    if(sum==target){\\n                        List<Integer>list=new ArrayList<>();\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(nums[low]);\\n                        list.add(nums[high]);\\n                \\n                \\n                if(result.contains(list)==false){\\n                    result.add(list);\\n                }\\n                low++;\\n                high--;\\n                    }\\n             else if(sum<target){\\n                    low++;\\n                }\\n                else{\\n                    high--;\\n                }\\n                }\\n            }\\n        }\\n        return result;\\n                \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result=new ArrayList<>();\\n        if(nums==null || nums.length<4){\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 517139,
                "title": "c-generalized-to-ksum",
                "content": "# Generalization to k-sum problems\\n\\nFor `k >= 3`, the following solution achieves the best time complexity possible which is `O( n^{k-1} )`.\\n```c++\\n\\tvoid kSum(vector<int>& nums, int target, int k, int start, vector<vector<int>>& res, vector<int>& curr, int sm){\\n        if(k == 2){\\n            int i = start, j = nums.size() - 1;\\n            target -= sm;\\n            while(i < j){\\n                if(nums[i] + nums[j] < target) i++;\\n                else if(nums[i] + nums[j] > target) j--;\\n                else{\\n                    curr[curr.size() - 2] = nums[i];\\n                    curr[curr.size() - 1] = nums[j];\\n                    res.push_back(curr);\\n                    while(i + 1 < j && nums[i] == nums[i + 1]) i++;\\n                    i++;\\n                    while(i < j - 1 && nums[j] == nums[j - 1]) j--;\\n                    j--;\\n                }\\n            }\\n            return;\\n        }\\n        for(int i = start; i + k - 1 < nums.size(); i++){\\n            curr[curr.size() - k] = nums[i];\\n            kSum(nums, target, k - 1, i + 1, res, curr, sm + nums[i]);\\n            while(i + 1 < nums.size() && nums[i] == nums[i + 1]) i++;\\n        }\\n    }\\n    \\n    inline vector<vector<int>> kSumWrapper(vector<int>& nums, int target, int k){\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        vector<int> curr(k, 0);\\n        kSum(nums, target, k, 0, res, curr, 0);\\n        return res;\\n    }\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        return kSumWrapper(nums, target, 4);\\n    }\\n```\\n\\n************************************************************************************************\\n\\nFor `k == 2`, the above solution does not achieve the best time complexity possible. One should instead use hash-table approach to achieve `O(n)` time complexity.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\n\\tvoid kSum(vector<int>& nums, int target, int k, int start, vector<vector<int>>& res, vector<int>& curr, int sm){\\n        if(k == 2){\\n            int i = start, j = nums.size() - 1;\\n            target -= sm;\\n            while(i < j){\\n                if(nums[i] + nums[j] < target) i++;\\n                else if(nums[i] + nums[j] > target) j--;\\n                else{\\n                    curr[curr.size() - 2] = nums[i];\\n                    curr[curr.size() - 1] = nums[j];\\n                    res.push_back(curr);\\n                    while(i + 1 < j && nums[i] == nums[i + 1]) i++;\\n                    i++;\\n                    while(i < j - 1 && nums[j] == nums[j - 1]) j--;\\n                    j--;\\n                }\\n            }\\n            return;\\n        }\\n        for(int i = start; i + k - 1 < nums.size(); i++){\\n            curr[curr.size() - k] = nums[i];\\n            kSum(nums, target, k - 1, i + 1, res, curr, sm + nums[i]);\\n            while(i + 1 < nums.size() && nums[i] == nums[i + 1]) i++;\\n        }\\n    }\\n    \\n    inline vector<vector<int>> kSumWrapper(vector<int>& nums, int target, int k){\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        vector<int> curr(k, 0);\\n        kSum(nums, target, k, 0, res, curr, 0);\\n        return res;\\n    }\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        return kSumWrapper(nums, target, 4);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 440321,
                "title": "c-4ms-99-88-9-1mb-94-74-2-pointers-within-2-for-loops",
                "content": "* Runtime: 4 ms, faster than 99.88% of C++ online submissions for 4Sum.\\n* Memory Usage: 9.1 MB, less than 94.74% of C++ online submissions for 4Sum.\\n\\n```\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL; }();\\n\\nclass Solution {\\npublic:\\nvector< vector<int> > fourSum(vector<int>& nums, int target) {\\n\\tvector< vector<int> > result;\\n\\tsize_t n = nums.size();\\n\\tif (n < 4) \\treturn result;\\n\\n\\n\\tsort(nums.begin(), nums.end());\\n\\tfor (int i = 0; i < n-3; ++i) {\\n\\t\\tif (target <= 0 && nums[i] > 0) break;\\n\\n\\t\\tif (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;\\n\\t\\tif (nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\tif (i > 0 && nums[i] == nums[i-1]) continue;\\n\\n\\t\\tfor (int j = i+1; j < n - 2; ++j) {\\n\\t\\t\\tif (nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) break;\\n\\t\\t\\tif (nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t\\tif (j > i+1 && nums[j] == nums[j-1]) continue;\\n\\n\\t\\t\\tint left = j+1, right = n-1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\t\\t\\t\\tif (sum == target) \\n                {\\n\\t\\t\\t\\t\\tresult.push_back({nums[i], nums[j], nums[left], nums[right]});\\n\\t\\t\\t\\t\\tint last_left = nums[left], last_right = nums[right];\\n\\t\\t\\t\\t\\twhile (left < right && nums[left] == last_left) ++left;\\n\\t\\t\\t\\t\\twhile (left < right && nums[right] == last_right) --right;\\n\\t\\t\\t\\t} \\n                else if (sum < target) { ++left; } \\n                else { --right; }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL; }();\\n\\nclass Solution {\\npublic:\\nvector< vector<int> > fourSum(vector<int>& nums, int target) {\\n\\tvector< vector<int> > result;\\n\\tsize_t n = nums.size();\\n\\tif (n < 4) \\treturn result;\\n\\n\\n\\tsort(nums.begin(), nums.end());\\n\\tfor (int i = 0; i < n-3; ++i) {\\n\\t\\tif (target <= 0 && nums[i] > 0) break;\\n\\n\\t\\tif (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;\\n\\t\\tif (nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\tif (i > 0 && nums[i] == nums[i-1]) continue;\\n\\n\\t\\tfor (int j = i+1; j < n - 2; ++j) {\\n\\t\\t\\tif (nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) break;\\n\\t\\t\\tif (nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t\\tif (j > i+1 && nums[j] == nums[j-1]) continue;\\n\\n\\t\\t\\tint left = j+1, right = n-1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\t\\t\\t\\tif (sum == target) \\n                {\\n\\t\\t\\t\\t\\tresult.push_back({nums[i], nums[j], nums[left], nums[right]});\\n\\t\\t\\t\\t\\tint last_left = nums[left], last_right = nums[right];\\n\\t\\t\\t\\t\\twhile (left < right && nums[left] == last_left) ++left;\\n\\t\\t\\t\\t\\twhile (left < right && nums[right] == last_right) --right;\\n\\t\\t\\t\\t} \\n                else if (sum < target) { ++left; } \\n                else { --right; }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238725,
                "title": "ksum-java-solution-intuitive-and-clean",
                "content": "The idea is to decompose the K sum problem into classic 2 sum problem. \\nIn Two sum problem, we use head and tail pointer to find the solution.\\n```java\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> res = new LinkedList<>();\\n        if(nums == null || nums.length == 0){\\n            return res;\\n        }\\n        Arrays.sort(nums);\\n        return kSum(4, nums,0,target);\\n    }\\n\\n    public List<List<Integer>> kSum(int k, int[] nums, int startIndex, int target){\\n        List<List<Integer>> res = new LinkedList<>();\\n        if(k > nums.length - startIndex){\\n            return res;\\n        }\\n        if(k == 2){\\n            int i = startIndex, j = nums.length-1;\\n            while(i < j){\\n                if(nums[i] + nums[j] == target){\\n                    List<Integer> temp = new LinkedList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    res.add(temp);\\n                    while(i < j && nums[i] == nums[++i]);\\n                    while(i < j && nums[j] == nums[--j]);\\n                }\\n                else if(nums[i] + nums[j] < target){\\n                    i++;\\n                }\\n                else{\\n                    j--;\\n                }\\n            }\\n            return res;\\n        }\\n        else{\\n            for(int i = startIndex; i < nums.length; i++){\\n                if(i > startIndex && nums[i] == nums[i-1]){\\n                    continue;\\n                }\\n                List<List<Integer>> tempLists = kSum(k - 1, nums, i + 1, target - nums[i]);\\n                for(List<Integer> temp : tempLists){\\n                    temp.add(0,nums[i]);\\n                    res.add(temp);\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> res = new LinkedList<>();\\n        if(nums == null || nums.length == 0){\\n            return res;\\n        }\\n        Arrays.sort(nums);\\n        return kSum(4, nums,0,target);\\n    }\\n\\n    public List<List<Integer>> kSum(int k, int[] nums, int startIndex, int target){\\n        List<List<Integer>> res = new LinkedList<>();\\n        if(k > nums.length - startIndex){\\n            return res;\\n        }\\n        if(k == 2){\\n            int i = startIndex, j = nums.length-1;\\n            while(i < j){\\n                if(nums[i] + nums[j] == target){\\n                    List<Integer> temp = new LinkedList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    res.add(temp);\\n                    while(i < j && nums[i] == nums[++i]);\\n                    while(i < j && nums[j] == nums[--j]);\\n                }\\n                else if(nums[i] + nums[j] < target){\\n                    i++;\\n                }\\n                else{\\n                    j--;\\n                }\\n            }\\n            return res;\\n        }\\n        else{\\n            for(int i = startIndex; i < nums.length; i++){\\n                if(i > startIndex && nums[i] == nums[i-1]){\\n                    continue;\\n                }\\n                List<List<Integer>> tempLists = kSum(k - 1, nums, i + 1, target - nums[i]);\\n                for(List<Integer> temp : tempLists){\\n                    temp.add(0,nums[i]);\\n                    res.add(temp);\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218940,
                "title": "o-n-2-method-with-cpp",
                "content": "It is very tricky that for cpp user, it would not be that much easier to implement the O(n^2) method since the deduplicate process is a bit disgusting. Here, I would share my code that solve such problem with built-in unique() function so as to implement the O(n^2) method. If you have any better method, please tell me. \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        if (nums.size() == 0)\\n            return result;\\n        \\n        unordered_map<int, vector<pair<int, int>>> map;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                map[target - nums[i] - nums[j]].push_back({i, j});\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int temp = nums[i] + nums[j];\\n                if (map.find(temp) != map.end()) {\\n                    for (auto p : map[temp]) {\\n                        if (p.first == i || p.first == j ||\\n                            p.second == i || p.second == j)\\n                            continue;                        \\n                        result.push_back({nums[p.first], nums[p.second], nums[i], nums[j]});\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < result.size(); ++i) {\\n            sort(result[i].begin(), result[i].end());\\n        }\\n        sort(result.begin(), result.end());\\n        result.erase(unique(result.begin(), result.end()), result.end());\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        if (nums.size() == 0)\\n            return result;\\n        \\n        unordered_map<int, vector<pair<int, int>>> map;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                map[target - nums[i] - nums[j]].push_back({i, j});\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int temp = nums[i] + nums[j];\\n                if (map.find(temp) != map.end()) {\\n                    for (auto p : map[temp]) {\\n                        if (p.first == i || p.first == j ||\\n                            p.second == i || p.second == j)\\n                            continue;                        \\n                        result.push_back({nums[p.first], nums[p.second], nums[i], nums[j]});\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < result.size(); ++i) {\\n            sort(result[i].begin(), result[i].end());\\n        }\\n        sort(result.begin(), result.end());\\n        result.erase(unique(result.begin(), result.end()), result.end());\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8604,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**4Sum** https://leetcode.com/problems/4sum/\\n\\n* Brute force solution will be O(N^4).\\n* Optimized solution will be O(N^3). We will first sort the input. Then we will use the two pointer technique.\\n* We will use the same optimizations which we used in 3SUM problem to avoid duplicates. \\n* Reference: https://discuss.leetcode.com/topic/75883/python-solution-with-detailed-explanation\\n```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        N, result = len(nums), []\\n        for i in range(N):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            for j in range(i+1, N):\\n                if j > i+1 and nums[j] == nums[j-1]:\\n                    continue\\n                x = target - nums[i] - nums[j]\\n                s,e = j+1, N-1\\n                while s < e:\\n                    if nums[s]+nums[e] == x:\\n                        result.append([nums[i], nums[j], nums[s], nums[e]])\\n                        s = s+1\\n                        while s < e and nums[s] == nums[s-1]:\\n                            s = s+1\\n                    elif nums[s]+nums[e] < x:\\n                        s = s+1\\n                    else:\\n                        e = e-1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        N, result = len(nums), []\\n        for i in range(N):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            for j in range(i+1, N):\\n                if j > i+1 and nums[j] == nums[j-1]:\\n                    continue\\n                x = target - nums[i] - nums[j]\\n                s,e = j+1, N-1\\n                while s < e:\\n                    if nums[s]+nums[e] == x:\\n                        result.append([nums[i], nums[j], nums[s], nums[e]])\\n                        s = s+1\\n                        while s < e and nums[s] == nums[s-1]:\\n                            s = s+1\\n                    elif nums[s]+nums[e] < x:\\n                        s = s+1\\n                    else:\\n                        e = e-1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8736,
                "title": "a-java-solution-with-two-pointers",
                "content": "     public List<List<Integer>> fourSum(int[] nums, int target) {\\n        \\tList<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\tif (nums == null || nums.length < 4) {\\n        \\t\\treturn result;\\n        \\t}\\n        \\tArrays.sort(nums);\\n        \\tfor (int i = 0; i < nums.length - 3; i ++) {\\n        \\t\\tfor (int j = i + 1; j < nums.length - 2; j ++) {\\n        \\t\\t\\tint head = j + 1;\\n        \\t\\t\\tint tail = nums.length - 1;\\n        \\t\\t\\twhile (head < tail) {\\n        \\t\\t\\t\\tint tempSum = nums[i] + nums[j] + nums[head] + nums[tail];\\n        \\t\\t\\t\\tif (tempSum == target) {\\n        \\t\\t\\t\\t\\tList<Integer> item = new ArrayList<Integer>();\\n        \\t\\t\\t\\t\\titem.add(nums[i]);\\n        \\t\\t\\t\\t\\titem.add(nums[j]);\\n        \\t\\t\\t\\t\\titem.add(nums[head]);\\n        \\t\\t\\t\\t\\titem.add(nums[tail]);\\n        \\t\\t\\t\\t\\tif (result.contains(item) == false) {\\n        \\t\\t\\t\\t\\t\\tresult.add(item);\\n        \\t\\t\\t\\t\\t} \\n        \\t\\t\\t\\t\\thead ++;\\n        \\t\\t\\t\\t\\ttail --;\\n        \\t\\t\\t\\t} else if (tempSum < target) {\\n        \\t\\t\\t\\t\\thead ++;\\n        \\t\\t\\t\\t} else {\\n        \\t\\t\\t\\t\\ttail --;\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\treturn result;\\n        }",
                "solutionTags": [],
                "code": "     public List<List<Integer>> fourSum(int[] nums, int target) {\\n        \\tList<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\tif (nums == null || nums.length < 4) {\\n        \\t\\treturn result;\\n        \\t}\\n        \\tArrays.sort(nums);\\n        \\tfor (int i = 0; i < nums.length - 3; i ++) {\\n        \\t\\tfor (int j = i + 1; j < nums.length - 2; j ++) {\\n        \\t\\t\\tint head = j + 1;\\n        \\t\\t\\tint tail = nums.length - 1;\\n        \\t\\t\\twhile (head < tail) {\\n        \\t\\t\\t\\tint tempSum = nums[i] + nums[j] + nums[head] + nums[tail];\\n        \\t\\t\\t\\tif (tempSum == target) {\\n        \\t\\t\\t\\t\\tList<Integer> item = new ArrayList<Integer>();\\n        \\t\\t\\t\\t\\titem.add(nums[i]);\\n        \\t\\t\\t\\t\\titem.add(nums[j]);\\n        \\t\\t\\t\\t\\titem.add(nums[head]);\\n        \\t\\t\\t\\t\\titem.add(nums[tail]);\\n        \\t\\t\\t\\t\\tif (result.contains(item) == false) {\\n        \\t\\t\\t\\t\\t\\tresult.add(item);\\n        \\t\\t\\t\\t\\t} \\n        \\t\\t\\t\\t\\thead ++;\\n        \\t\\t\\t\\t\\ttail --;\\n        \\t\\t\\t\\t} else if (tempSum < target) {\\n        \\t\\t\\t\\t\\thead ++;\\n        \\t\\t\\t\\t} else {\\n        \\t\\t\\t\\t\\ttail --;\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\treturn result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3917506,
                "title": "two-pointer-approach-easy-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&& nums[i]==nums[i-1])continue;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j!=(i+1) && nums[j]==nums[j-1])continue;\\n                int k=j+1;\\n                int l=n-1;\\n                while(k<l)\\n                {\\n                    long long  sum=nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n                    if(sum==target)\\n                    {\\n                    vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                    v.push_back(temp);\\n                    k=k+1;\\n                    l=l-1;\\n                    while(k<l && nums[k]==nums[k-1])k=k+1;\\n                    while(k<l && nums[l]==nums[l+1])l=l-1;\\n                    }\\n                    else if(sum<target)\\n                    {\\n                        k++;\\n                    }\\n                    else{l--;}\\n                }\\n            }\\n        } \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&& nums[i]==nums[i-1])continue;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j!=(i+1) && nums[j]==nums[j-1])continue;\\n                int k=j+1;\\n                int l=n-1;\\n                while(k<l)\\n                {\\n                    long long  sum=nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n                    if(sum==target)\\n                    {\\n                    vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                    v.push_back(temp);\\n                    k=k+1;\\n                    l=l-1;\\n                    while(k<l && nums[k]==nums[k-1])k=k+1;\\n                    while(k<l && nums[l]==nums[l+1])l=l-1;\\n                    }\\n                    else if(sum<target)\\n                    {\\n                        k++;\\n                    }\\n                    else{l--;}\\n                }\\n            }\\n        } \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609498,
                "title": "best-o-n-3-solution",
                "content": "# Approach\\nUsing Two Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^3)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> quadruplets;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0 && nums[i] == nums[i-1])\\n                continue;\\n            for (int j = i+1; j < n; j++) {\\n                if (j != i+1 && nums[j] == nums[j-1])\\n                    continue;\\n                int k = j+1, l = n-1; \\n                while (k < l) {\\n                    long long sum = nums[i] + nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        vector<int> temp = {nums[i], nums[j], nums[k], nums[l]};\\n                        quadruplets.push_back(temp);\\n                        k++;\\n                        l--;\\n                        while (k < l && nums[k] == nums[k-1]) k++;\\n                        while (k < l && nums[l] == nums[l+1]) l--;\\n                    } else if (sum > target) {\\n                        l--;\\n                    } else {\\n                        k++;\\n                    }\\n                }   \\n            }\\n        }\\n        return quadruplets;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> quadruplets;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0 && nums[i] == nums[i-1])\\n                continue;\\n            for (int j = i+1; j < n; j++) {\\n                if (j != i+1 && nums[j] == nums[j-1])\\n                    continue;\\n                int k = j+1, l = n-1; \\n                while (k < l) {\\n                    long long sum = nums[i] + nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        vector<int> temp = {nums[i], nums[j], nums[k], nums[l]};\\n                        quadruplets.push_back(temp);\\n                        k++;\\n                        l--;\\n                        while (k < l && nums[k] == nums[k-1]) k++;\\n                        while (k < l && nums[l] == nums[l+1]) l--;\\n                    } else if (sum > target) {\\n                        l--;\\n                    } else {\\n                        k++;\\n                    }\\n                }   \\n            }\\n        }\\n        return quadruplets;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440192,
                "title": "c-using-3-sum-easy-explanation-beginner-friendly",
                "content": "UPVOTE AGAR SAWAL ASAAN KIYA AAPKE LIYE \\uD83D\\uDE42.\\n# Advice\\nDONT GO DIRECTLY TO SOLUTION.UNDERSTAND THE FLOW/APPROACH.\\nYOU MUST BE KNOWING HOW TO SOLVE TWO SUM PROBLEM .\\n\\n# Intuition\\nI HAVE SOLVED 3SUM USING 2 SUM .THAT\\'S WHY I GOT INTUTION TO SOLVE FOUR SOME(\\uD83D\\uDE01) USING 3 SUM .\\n\\n# Approach\\n1. IN AN ARRAY AT INDEX I, I TAKE THE ARRAY ELEMENT IN FOUR SUM CONSIDERATION IF NOT PREVIOUSLY TAKEN AND STORE IT IN A VARIABLE A=NUMS[I] .THEN ASK THREE SUM TO FIND TARGET-NUMS[I] IN REMAINING ARRAY.\\n\\n2. AGAIN IN ARRAY AT INDEX I, TAKE THE ARRAY ELEMENT IN FOUR SUM CONSIDERATION IF NOT PREVIOUSLY TAKEN AND STORE IT IN A VARIABLE B=NUMS[I].THEN ASK FOR TWO SUM TO FIND TARGET-NUMS[I] IN REMAINING ARRAY.\\n\\n3. SIMPLE TWO SUM PROBLEM\\uD83D\\uDE0E.\\n\\n```\\nwhile(i<j){\\n            if(target==nums[i]+nums[j]){\\n                //STORE IN ANS \\n                ans.push_back({a,b,nums[i],nums[j]});\\n        // DISTINCT SUBARRAY SHOULD BE INSIDE VECTOR<VECTOR<INT>>ANS.\\n                i++,j--;\\n                while(j>i && nums[j]==nums[j+1])j--;\\n                while(i<j&&nums[i]==nums[i-1])i++;\\n            }\\n            else if(nums[i]+nums[j]>target)j--;\\n            else{\\n                ++i;\\n            }\\n        }\\n\\n```\\nEXAMPLE : LET ARRAY[-2,-2,-1,0,1,1,2,2].TARGET=0.\\n![WhatsApp Image 2023-04-21 at 12.06.57.jpg](https://assets.leetcode.com/users/images/13d0d6d0-ab45-404e-a022-9768e9af6854_1682059109.5560734.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void twosum(vector<int>&nums,int i,long long target,vector<vector<int>>&ans,int a ,int b){\\n        int n =nums.size();\\n        int j=n-1;\\n\\n        while(i<j){\\n            if(target==nums[i]+nums[j]){\\n                ans.push_back({a,b,nums[i],nums[j]});\\n                i++,j--;\\n                while(j>i && nums[j]==nums[j+1])j--;\\n                while(i<j&&nums[i]==nums[i-1])i++;\\n            }\\n            else if(nums[i]+nums[j]>target)j--;\\n            else{\\n                ++i;\\n            }\\n        }\\n        return;\\n    }\\n    void threesum(vector<vector<int>>&ans,vector<int>& nums,int j,long long target,int a ) {\\n        int n =nums.size();\\n        twosum(nums,j+1,target-nums[j],ans,a,nums[j]);\\n\\n        for(int i =j+1;i<n-2;i++){\\n            if(nums[i]==nums[i-1])continue;\\n            int b=nums[i];\\n            twosum(nums,i+1,target-nums[i],ans,a,b);\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int t) {\\n        long long target=t;\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n =nums.size();\\n\\n        if(n>=4)threesum(ans,nums,1,target-nums[0],nums[0]);\\n        if(nums[0]>0 && nums[0]>target)return ans;\\n\\n        for(int i=1;i<n-3;i++){\\n            if(nums[i]==nums[i-1])continue;\\n            int a=nums[i];\\n            threesum(ans,nums,i+1,target-nums[i],a);\\n        }\\n        return ans ;\\n    }\\n};\\n```\\nTHANK YOU \\nCODE BY:) AMAN MAURYA",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwhile(i<j){\\n            if(target==nums[i]+nums[j]){\\n                //STORE IN ANS \\n                ans.push_back({a,b,nums[i],nums[j]});\\n        // DISTINCT SUBARRAY SHOULD BE INSIDE VECTOR<VECTOR<INT>>ANS.\\n                i++,j--;\\n                while(j>i && nums[j]==nums[j+1])j--;\\n                while(i<j&&nums[i]==nums[i-1])i++;\\n            }\\n            else if(nums[i]+nums[j]>target)j--;\\n            else{\\n                ++i;\\n            }\\n        }\\n\\n```\n```\\nclass Solution {\\npublic:\\n    void twosum(vector<int>&nums,int i,long long target,vector<vector<int>>&ans,int a ,int b){\\n        int n =nums.size();\\n        int j=n-1;\\n\\n        while(i<j){\\n            if(target==nums[i]+nums[j]){\\n                ans.push_back({a,b,nums[i],nums[j]});\\n                i++,j--;\\n                while(j>i && nums[j]==nums[j+1])j--;\\n                while(i<j&&nums[i]==nums[i-1])i++;\\n            }\\n            else if(nums[i]+nums[j]>target)j--;\\n            else{\\n                ++i;\\n            }\\n        }\\n        return;\\n    }\\n    void threesum(vector<vector<int>>&ans,vector<int>& nums,int j,long long target,int a ) {\\n        int n =nums.size();\\n        twosum(nums,j+1,target-nums[j],ans,a,nums[j]);\\n\\n        for(int i =j+1;i<n-2;i++){\\n            if(nums[i]==nums[i-1])continue;\\n            int b=nums[i];\\n            twosum(nums,i+1,target-nums[i],ans,a,b);\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int t) {\\n        long long target=t;\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n =nums.size();\\n\\n        if(n>=4)threesum(ans,nums,1,target-nums[0],nums[0]);\\n        if(nums[0]>0 && nums[0]>target)return ans;\\n\\n        for(int i=1;i<n-3;i++){\\n            if(nums[i]==nums[i-1])continue;\\n            int a=nums[i];\\n            threesum(ans,nums,i+1,target-nums[i],a);\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817670,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        map<vector<int>, int> mp;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=i+1; j<nums.size(); j++) {\\n                int l = j + 1, r = nums.size() - 1; \\n                while(l < r) {\\n                    long long sum = (long long) nums[i] + nums[j] + nums[l] + nums[r];\\n                    if(sum == target) {\\n                        mp[{nums[i], nums[j], nums[l], nums[r]}]++;\\n                        if(mp[{nums[i], nums[j], nums[l], nums[r]}] == 1) ans.push_back({nums[i], nums[j], nums[l], nums[r]});\\n                        l++;\\n                        r--;\\n                    }\\n                    else if(sum < target) l++;\\n                    else if(sum > target) r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        map<vector<int>, int> mp;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=i+1; j<nums.size(); j++) {\\n                int l = j + 1, r = nums.size() - 1; \\n                while(l < r) {\\n                    long long sum = (long long) nums[i] + nums[j] + nums[l] + nums[r];\\n                    if(sum == target) {\\n                        mp[{nums[i], nums[j], nums[l], nums[r]}]++;\\n                        if(mp[{nums[i], nums[j], nums[l], nums[r]}] == 1) ans.push_back({nums[i], nums[j], nums[l], nums[r]});\\n                        l++;\\n                        r--;\\n                    }\\n                    else if(sum < target) l++;\\n                    else if(sum > target) r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682974,
                "title": "java-2-approaches-brute-and-optimal",
                "content": "### **Please Upvote** :D\\n##### 1. Brute force approach (TLE - 288/291 passed):\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int n = nums.length;\\n        if (n < 4) return new ArrayList<>(); // it\\'d still be handled even if we don\\'t write this condition\\n        Arrays.sort(nums);\\n\\n        Set<List<Integer>> ans = new HashSet<>();\\n\\n        for (int i = 0; i < n; i++) \\n            for (int j =  i + 1; j < n; j++) \\n                for (int k =  j + 1; k < n; k++) \\n                    for (int l = k + 1; l < n; l++) \\n                        if (nums[i] + nums[j] + nums[k] + nums[l] == target) \\n                            ans.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));\\n\\n        return new ArrayList(ans);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 4) => O(n ^ 4)\\n// SC: O(1) - Ignoring output array\\n```\\n##### 2. Optimal solution (Two pointers):\\nWe iterate using the first for loop and find the remaining 3 elements by the same **[3Sum](https://leetcode.com/problems/3sum/discuss/2397624/JAVA-or-3-approaches)** approach.\\n\\nOr we can say, we find the first two elements using nested for loops and find the remaining 2 elements by the **[TwoSum](https://leetcode.com/problems/two-sum/discuss/2345909/Java-solution-(brute-force-and-optimized))** approach.\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int n = nums.length;\\n\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n\\n                long target2 = (long) target - (long) nums[i] - (long) nums[j];\\n                int lo = j + 1, hi = n - 1;\\n\\n                while (lo < hi) {\\n                    int twoSum = nums[lo] + nums[hi];\\n\\n                    if (twoSum < target2) lo++;\\n                    else if (twoSum > target2) hi--;\\n                    else {\\n                        List<Integer> quad = Arrays.asList(nums[i], nums[j], nums[lo], nums[hi]);\\n                        ans.add(quad);\\n\\n                        while (lo < hi && nums[lo] == quad.get(2)) lo++;\\n                        while (lo < hi && nums[hi] == quad.get(3)) hi--;\\n                    }\\n                }\\n\\n                while (j + 1 < n && nums[j] == nums[j + 1]) j++;\\n            }\\n\\n            while (i + 1 < n && nums[i] == nums[i + 1]) i++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 3) => O(n ^ 3)\\n// SC: O(1) - ignoring the output array\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int n = nums.length;\\n        if (n < 4) return new ArrayList<>(); // it\\'d still be handled even if we don\\'t write this condition\\n        Arrays.sort(nums);\\n\\n        Set<List<Integer>> ans = new HashSet<>();\\n\\n        for (int i = 0; i < n; i++) \\n            for (int j =  i + 1; j < n; j++) \\n                for (int k =  j + 1; k < n; k++) \\n                    for (int l = k + 1; l < n; l++) \\n                        if (nums[i] + nums[j] + nums[k] + nums[l] == target) \\n                            ans.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));\\n\\n        return new ArrayList(ans);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 4) => O(n ^ 4)\\n// SC: O(1) - Ignoring output array\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int n = nums.length;\\n\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n\\n                long target2 = (long) target - (long) nums[i] - (long) nums[j];\\n                int lo = j + 1, hi = n - 1;\\n\\n                while (lo < hi) {\\n                    int twoSum = nums[lo] + nums[hi];\\n\\n                    if (twoSum < target2) lo++;\\n                    else if (twoSum > target2) hi--;\\n                    else {\\n                        List<Integer> quad = Arrays.asList(nums[i], nums[j], nums[lo], nums[hi]);\\n                        ans.add(quad);\\n\\n                        while (lo < hi && nums[lo] == quad.get(2)) lo++;\\n                        while (lo < hi && nums[hi] == quad.get(3)) hi--;\\n                    }\\n                }\\n\\n                while (j + 1 < n && nums[j] == nums[j + 1]) j++;\\n            }\\n\\n            while (i + 1 < n && nums[i] == nums[i + 1]) i++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 3) => O(n ^ 3)\\n// SC: O(1) - ignoring the output array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531547,
                "title": "bruteforce-to-better-to-optimal-c-multiple-solutions",
                "content": "```cpp\\ntypedef long long ll;\\n\\n\\n// Bruteforce | O(n^4) time | O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        set<vector<int>> st;\\n        sort(nums.begin(), nums.end());\\n        for (int i =0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    for (int t = k + 1; t < n; t++) {\\n                        if ((ll)nums[i] + nums[j] + nums[k] + nums[t] == (ll)target) {\\n                            vector<int> quad = {nums[i], nums[j], nums[k], nums[t]};\\n                            st.insert(quad);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> res(st.begin(), st.end());\\n        return res;\\n    }\\n};\\n\\n\\n// Bruteforce | O(n^4) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i =0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    for (int t = k + 1; t < n; t++) {\\n                        if ((ll)nums[i] + nums[j] + nums[k] + nums[t] == (ll)target) {\\n                            vector<int> quad = {nums[i], nums[j], nums[k], nums[t]};\\n                            res.push_back(quad);\\n                        }\\n                        while (t < n - 1 && nums[t] == nums[t + 1]) t++;\\n                    }\\n                    while (k < n - 1 && nums[k] == nums[k + 1]) k++;\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n// Optimal | O(n^3 * log(n)) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    ll sumOfThree = (ll)nums[i] + (ll)nums[j] + (ll)nums[k];\\n                    int fourthNum = target - sumOfThree;\\n                    if (binary_search(nums.begin() + k + 1, nums.end(), fourthNum)) {\\n                        vector<int> quad = {nums[i], nums[j], nums[k], fourthNum};\\n                        res.push_back(quad);\\n                    }\\n                    while (k < n - 1 && nums[k] == nums[k + 1]) k++;\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n// Most Optimal | O(n^3) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                int l = j + 1, r = n - 1;\\n                ll remSum = (ll)target - (ll)nums[i] - (ll)nums[j];\\n                while (l < r) {\\n                    ll sumOfLastTwo = nums[l] + nums[r];\\n                    if (sumOfLastTwo < remSum) l++;\\n                    else if (sumOfLastTwo > remSum) r--;\\n                    else {\\n                        vector<int> quad = {nums[i], nums[j], nums[l], nums[r]};\\n                        res.push_back(quad);\\n                        while (l < r && nums[l] == quad[2]) l++;\\n                        while (l < r && nums[r] == quad[3]) r--;\\n                    }\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\ntypedef long long ll;\\n\\n\\n// Bruteforce | O(n^4) time | O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        set<vector<int>> st;\\n        sort(nums.begin(), nums.end());\\n        for (int i =0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    for (int t = k + 1; t < n; t++) {\\n                        if ((ll)nums[i] + nums[j] + nums[k] + nums[t] == (ll)target) {\\n                            vector<int> quad = {nums[i], nums[j], nums[k], nums[t]};\\n                            st.insert(quad);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> res(st.begin(), st.end());\\n        return res;\\n    }\\n};\\n\\n\\n// Bruteforce | O(n^4) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i =0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    for (int t = k + 1; t < n; t++) {\\n                        if ((ll)nums[i] + nums[j] + nums[k] + nums[t] == (ll)target) {\\n                            vector<int> quad = {nums[i], nums[j], nums[k], nums[t]};\\n                            res.push_back(quad);\\n                        }\\n                        while (t < n - 1 && nums[t] == nums[t + 1]) t++;\\n                    }\\n                    while (k < n - 1 && nums[k] == nums[k + 1]) k++;\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n// Optimal | O(n^3 * log(n)) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    ll sumOfThree = (ll)nums[i] + (ll)nums[j] + (ll)nums[k];\\n                    int fourthNum = target - sumOfThree;\\n                    if (binary_search(nums.begin() + k + 1, nums.end(), fourthNum)) {\\n                        vector<int> quad = {nums[i], nums[j], nums[k], fourthNum};\\n                        res.push_back(quad);\\n                    }\\n                    while (k < n - 1 && nums[k] == nums[k + 1]) k++;\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n// Most Optimal | O(n^3) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                int l = j + 1, r = n - 1;\\n                ll remSum = (ll)target - (ll)nums[i] - (ll)nums[j];\\n                while (l < r) {\\n                    ll sumOfLastTwo = nums[l] + nums[r];\\n                    if (sumOfLastTwo < remSum) l++;\\n                    else if (sumOfLastTwo > remSum) r--;\\n                    else {\\n                        vector<int> quad = {nums[i], nums[j], nums[l], nums[r]};\\n                        res.push_back(quad);\\n                        while (l < r && nums[l] == quad[2]) l++;\\n                        while (l < r && nums[r] == quad[3]) r--;\\n                    }\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902903,
                "title": "extension-of-2-sum-solution-works-in-o-n-3",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                # two sum problem solution\\n                new_target = target - (nums[i] + nums[j])\\n                start = j+1\\n                end = n-1\\n                while end > start:\\n                    if(nums[start] + nums[end] == new_target):\\n                        ans.add((nums[i], nums[j], nums[start], nums[end]))\\n                        end -= 1\\n                        start += 1\\n                    elif nums[start] + nums[end] > new_target:\\n                        end -= 1\\n                    else:\\n                        start += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                # two sum problem solution\\n                new_target = target - (nums[i] + nums[j])\\n                start = j+1\\n                end = n-1\\n                while end > start:\\n                    if(nums[start] + nums[end] == new_target):\\n                        ans.add((nums[i], nums[j], nums[start], nums[end]))\\n                        end -= 1\\n                        start += 1\\n                    elif nums[start] + nums[end] > new_target:\\n                        end -= 1\\n                    else:\\n                        start += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341570,
                "title": "4sum-two-pointer-commented",
                "content": "```\\n vector<vector<int>> fourSum(vector<int> nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        //store in set as we need unique quadruplets  only\\n        set<vector<int>> res;\\n        \\n        //less than 4 no ans\\n        if(n < 4) return ans;\\n        \\n        sort(begin(nums),end(nums));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                //choose two pointer \\n                int l = j+1 , r = n-1;\\n                //calc rest req sum\\n                int req = target-nums[i]-nums[j];\\n                while(l < r){\\n                    //if it is our sum take it and inc or dec pointer if we nums[l]==nums[l+1], or otherwise.\\n                    if((nums[l]+nums[r]) == req){\\n                        //take it\\n                        res.insert({nums[i],nums[j],nums[l],nums[r]});\\n                        if(nums[l] == nums[l+1]) l++;\\n                        else r--;\\n                    }\\n                    //if the sum is greater than require dec last pointer to dec sum\\n                    else if((nums[l]+nums[r]) > req){\\n                        r--;\\n                    }\\n                    //otherwise inc\\n                    else{\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(auto it : res){\\n            ans.push_back(it);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<vector<int>> fourSum(vector<int> nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        //store in set as we need unique quadruplets  only\\n        set<vector<int>> res;\\n        \\n        //less than 4 no ans\\n        if(n < 4) return ans;\\n        \\n        sort(begin(nums),end(nums));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                //choose two pointer \\n                int l = j+1 , r = n-1;\\n                //calc rest req sum\\n                int req = target-nums[i]-nums[j];\\n                while(l < r){\\n                    //if it is our sum take it and inc or dec pointer if we nums[l]==nums[l+1], or otherwise.\\n                    if((nums[l]+nums[r]) == req){\\n                        //take it\\n                        res.insert({nums[i],nums[j],nums[l],nums[r]});\\n                        if(nums[l] == nums[l+1]) l++;\\n                        else r--;\\n                    }\\n                    //if the sum is greater than require dec last pointer to dec sum\\n                    else if((nums[l]+nums[r]) > req){\\n                        r--;\\n                    }\\n                    //otherwise inc\\n                    else{\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(auto it : res){\\n            ans.push_back(it);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 624935,
                "title": "dp-twosum-style-python-solution",
                "content": "The idea is that fourSum is just two twoSums\\n1. We can treat the input like an N x N matrix of summed values \\nwhere eg. nums[0][1] is nums[0] + nums[1]\\nTo avoid duplicate calculations we only traverse half the matrix\\nstopping right before nums[i][i] because that would be a number plus itself\\n\\n2. Similar to twoSum, we keep track of sums we\\'ve seen so far\\nand find the other half we need to add up to the target\\nhave = nums[r] - nums[c] basically a new two sum\\nneed = target - have\\nHere we\\'re keeping track of the indexes in an array, with a key of their sum\\n\\n3. If we find it, make sure that all indexes are unique by counting a unique set\\nand making sure they add to up four. Then storying in a set\\n\\n112 ms\\nO(N^2)\\n\\t\\t\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        # Store a dp style table of [row][col] for each two sum\\n        dp = {}\\n        res = set()\\n        seen = defaultdict(list)\\n        # 1\\n        for r in range(len(nums)):\\n            for c in range(r):\\n                have = nums[r] + nums[c]\\n                need = target - have\\n                # 2\\n                if need in seen:\\n                    # 3\\n                    for r1,c1 in seen[need]:\\n                        if len({r1,c1,r,c}) == 4:\\n                            res.add( tuple(sorted([nums[r1],nums[c1],nums[r],nums[c]])) ) \\n                seen[have].append((r, c))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        # Store a dp style table of [row][col] for each two sum\\n        dp = {}\\n        res = set()\\n        seen = defaultdict(list)\\n        # 1\\n        for r in range(len(nums)):\\n            for c in range(r):\\n                have = nums[r] + nums[c]\\n                need = target - have\\n                # 2\\n                if need in seen:\\n                    # 3\\n                    for r1,c1 in seen[need]:\\n                        if len({r1,c1,r,c}) == 4:\\n                            res.add( tuple(sorted([nums[r1],nums[c1],nums[r],nums[c]])) ) \\n                seen[have].append((r, c))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292934,
                "title": "python-hashmap-64ms",
                "content": "Refer from [Python 140ms beats 100%, and works for N-sum (N>=2)](https://leetcode.com/problems/4sum/discuss/8545/Python-140ms-beats-100-and-works-for-N-sum-(Ngreater2)), some optimization is made for the sorted nums. Use defaultdict to improve the performance of hashmap.\\n\\n```\\nimport collections\\n\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        if len(nums) < 4 or 4*nums[0] > target or 4*nums[-1] < target: return []\\n        # use defaultdic for better performance\\n        total_map = collections.defaultdict(list)\\n        results = set()\\n        \\n        for num1 in range(len(nums)-1):\\n            for num2 in range(num1 + 1, len(nums)):\\n                diff = target - nums[num1] - nums[num2]\\n                total_map[diff].append((num1, num2))\\n\\n                    \\n        for num1 in range(len(nums) - 3):\\n            for num2 in range(num1 + 1, len(nums)):\\n                total = nums[num1] + nums[num2]\\n                if total in total_map:\\n                    for pair in total_map[total]:\\n                        # Exclude the case pair[0] or pair[1] is num1 or num2\\n                        if pair[0] > num2:\\n                            #Cannot add list directly. Python thinks list is unhashable\\n                            results.add((nums[num1], nums[num2], nums[pair[0]], nums[pair[1]]))\\n        \\n        return [list(result) for result in results]\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        if len(nums) < 4 or 4*nums[0] > target or 4*nums[-1] < target: return []\\n        # use defaultdic for better performance\\n        total_map = collections.defaultdict(list)\\n        results = set()\\n        \\n        for num1 in range(len(nums)-1):\\n            for num2 in range(num1 + 1, len(nums)):\\n                diff = target - nums[num1] - nums[num2]\\n                total_map[diff].append((num1, num2))\\n\\n                    \\n        for num1 in range(len(nums) - 3):\\n            for num2 in range(num1 + 1, len(nums)):\\n                total = nums[num1] + nums[num2]\\n                if total in total_map:\\n                    for pair in total_map[total]:\\n                        # Exclude the case pair[0] or pair[1] is num1 or num2\\n                        if pair[0] > num2:\\n                            #Cannot add list directly. Python thinks list is unhashable\\n                            results.add((nums[num1], nums[num2], nums[pair[0]], nums[pair[1]]))\\n        \\n        return [list(result) for result in results]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169493,
                "title": "java-o-n-2-using-heckloads-of-dicts-and-maps",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Set<Set<Integer>> set = new HashSet<>();\\n        Map<Integer, Set<Set<Integer>>> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int sum = nums[i] + nums[j];\\n                Set<Integer> indicesSet = new HashSet(Arrays.asList(i , j));\\n                int diff = target - sum;\\n                if (map.containsKey(diff)) {\\n                    for (Set<Integer> s : map.get(diff)) {\\n                        Set<Integer> ans = new HashSet<>(indicesSet);\\n                        for (Integer idx : s) {\\n                            ans.add(idx);\\n                        }\\n                        set.add(ans);\\n                    }\\n                }\\n                if (map.containsKey(sum)) {\\n                    map.get(sum).add(indicesSet);\\n                } else {\\n                    map.put(sum, new HashSet<>());\\n                    map.get(sum).add(indicesSet);\\n                }\\n            }\\n        }\\n        \\n        Set<List<Integer>> ans = new HashSet<>();\\n        for (Set<Integer> s : set) {\\n            if (s.size() == 4) {\\n                List<Integer> a = new ArrayList<>();\\n                for (Integer idx : s) {\\n                    a.add(nums[idx]);\\n                }\\n                Collections.sort(a);\\n                ans.add(a);\\n            }\\n        }\\n        return new ArrayList<List<Integer>>(ans);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Set<Set<Integer>> set = new HashSet<>();\\n        Map<Integer, Set<Set<Integer>>> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int sum = nums[i] + nums[j];\\n                Set<Integer> indicesSet = new HashSet(Arrays.asList(i , j));\\n                int diff = target - sum;\\n                if (map.containsKey(diff)) {\\n                    for (Set<Integer> s : map.get(diff)) {\\n                        Set<Integer> ans = new HashSet<>(indicesSet);\\n                        for (Integer idx : s) {\\n                            ans.add(idx);\\n                        }\\n                        set.add(ans);\\n                    }\\n                }\\n                if (map.containsKey(sum)) {\\n                    map.get(sum).add(indicesSet);\\n                } else {\\n                    map.put(sum, new HashSet<>());\\n                    map.get(sum).add(indicesSet);\\n                }\\n            }\\n        }\\n        \\n        Set<List<Integer>> ans = new HashSet<>();\\n        for (Set<Integer> s : set) {\\n            if (s.size() == 4) {\\n                List<Integer> a = new ArrayList<>();\\n                for (Integer idx : s) {\\n                    a.add(nums[idx]);\\n                }\\n                Collections.sort(a);\\n                ans.add(a);\\n            }\\n        }\\n        return new ArrayList<List<Integer>>(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165059,
                "title": "my-javascript-solution-beats-88",
                "content": "To add another layer of index (I chose `start`) to 3Sum (`i, lo, hi`), we just need to wrap the 3Sum loops with another for loop, and change the starting index of `i` to `i = start + 1`.\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    // sort\\n    nums = nums.sort((a,b) => a - b)\\n    \\n    var answer = []\\n    if (nums.length < 4) return answer\\n    \\n    for (var start = 0; start <= nums.length - 4; start++) {\\n        if (start > 0 && nums[start] == nums[start - 1]) continue\\n        var _target = target - nums[start]\\n\\t\\t\\t\\t\\n        for (var i = start + 1; i <= nums.length - 3; i++) {\\n            if (i > start + 1 && nums[i] == nums[i - 1]) continue\\n            \\n            for (var lo = i + 1, hi = nums.length - 1; lo < hi; /* blank */) {\\n                var sum = nums[i] + nums[lo] + nums[hi]\\n                \\n                if (sum === _target) {\\n                    answer.push([nums[start], nums[i], nums[lo], nums[hi]])\\n                    while (lo < hi && nums[lo] == nums[lo + 1]) lo++\\n                    while (lo < hi && nums[hi] == nums[hi - 1]) hi--\\n                    lo++\\n                    hi--\\n                }\\n                else if (sum > _target) {\\n                    hi--\\n                }\\n                else {\\n                    lo++\\n                }\\n            }\\n        }\\n    }\\n    \\n    return answer\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    // sort\\n    nums = nums.sort((a,b) => a - b)\\n    \\n    var answer = []\\n    if (nums.length < 4) return answer\\n    \\n    for (var start = 0; start <= nums.length - 4; start++) {\\n        if (start > 0 && nums[start] == nums[start - 1]) continue\\n        var _target = target - nums[start]\\n\\t\\t\\t\\t\\n        for (var i = start + 1; i <= nums.length - 3; i++) {\\n            if (i > start + 1 && nums[i] == nums[i - 1]) continue\\n            \\n            for (var lo = i + 1, hi = nums.length - 1; lo < hi; /* blank */) {\\n                var sum = nums[i] + nums[lo] + nums[hi]\\n                \\n                if (sum === _target) {\\n                    answer.push([nums[start], nums[i], nums[lo], nums[hi]])\\n                    while (lo < hi && nums[lo] == nums[lo + 1]) lo++\\n                    while (lo < hi && nums[hi] == nums[hi - 1]) hi--\\n                    lo++\\n                    hi--\\n                }\\n                else if (sum > _target) {\\n                    hi--\\n                }\\n                else {\\n                    lo++\\n                }\\n            }\\n        }\\n    }\\n    \\n    return answer\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8599,
                "title": "golang-concise-26ms-solution",
                "content": "Just pick the first element and then for the remaining array, apply 3 sum.\\n`O(n^3)` .\\n\\n```\\nfunc fourSum(nums []int, target int) [][]int {\\n\\tsort.Ints(nums)\\n\\tvar res [][]int\\n\\tfor i := 0; i < len(nums)-3; i++ {\\n\\t\\tif i != 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tthreeSum(&res, nums[i], nums[i+1:], target-nums[i])\\n\\t}\\n\\treturn res\\n}\\n\\nfunc threeSum(res *[][]int, first int, nums []int, target int) {\\n\\tnlen := len(nums)\\n\\tfor i := 0; i < nlen-2; i++ {\\n\\t\\tif i != 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tleft, right := i+1, nlen-1\\n\\t\\tfor left < right {\\n\\t\\t\\tsum := nums[i] + nums[left] + nums[right]\\n\\t\\t\\tif sum == target {\\n\\t\\t\\t\\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left+1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right-1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t\\tright--\\n\\t\\t\\t} else if sum < target {\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left+1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right-1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tright--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc fourSum(nums []int, target int) [][]int {\\n\\tsort.Ints(nums)\\n\\tvar res [][]int\\n\\tfor i := 0; i < len(nums)-3; i++ {\\n\\t\\tif i != 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tthreeSum(&res, nums[i], nums[i+1:], target-nums[i])\\n\\t}\\n\\treturn res\\n}\\n\\nfunc threeSum(res *[][]int, first int, nums []int, target int) {\\n\\tnlen := len(nums)\\n\\tfor i := 0; i < nlen-2; i++ {\\n\\t\\tif i != 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tleft, right := i+1, nlen-1\\n\\t\\tfor left < right {\\n\\t\\t\\tsum := nums[i] + nums[left] + nums[right]\\n\\t\\t\\tif sum == target {\\n\\t\\t\\t\\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left+1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right-1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t\\tright--\\n\\t\\t\\t} else if sum < target {\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left+1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right-1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tright--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8678,
                "title": "a-typical-best-solution-accepted-as-8ms-in-c-well-commented",
                "content": "    void sort(int* nums, int begin, int end)\\n    {\\n        int l = begin;\\n        int r = end;\\n        int v = nums[l+(r-l)/2];\\n        while(l <= r)\\n        {\\n            while(nums[l] < v) l++;\\n            while(nums[r] > v) r--;\\n            if(l <= r)\\n            {\\n                int t = nums[l];\\n                nums[l] = nums[r];\\n                nums[r] = t;\\n                l++; r--;\\n            }\\n        }\\n        if(begin < r)\\n            sort(nums, begin, r);\\n        if(l < end)\\n            sort(nums, l, end);\\n    }\\n    \\n    //AC - 8ms;\\n    int** fourSum(int* nums, int size, int target, int* returnSize)\\n    {\\n        sort(nums, 0, size-1);\\n        int** arr = (int**)malloc(sizeof(int*));\\n        *returnSize = 0;\\n        for(int i = 0; i < size-3; i++)\\n        {\\n            if(i && nums[i]==nums[i-1]) continue;\\n            int t0 = target-nums[i]; //target for 3Sum;\\n            for(int j = i+1; j < size-2; j++)\\n            {\\n                if(j!=i+1 && nums[j]==nums[j-1]) continue; //the start position should be handled carefully, it's i+1 while removing redundancy;\\n                int t1 = t0-nums[j]; //target for 2Sum;\\n                if(nums[j+1]+nums[j+2] > t1) break; //the possible least sum is even bigger than the target - just try the next first candidate - i+1;\\n                if(nums[size-1]+nums[size-2] < t1) continue; //the possible maximal sum is smaller than the target - just try the next second candidate to make it bigger - j+1;\\n                int l = j+1;\\n                int r = size-1;\\n                while(l < r) //2Sum problem;\\n                {\\n                    int t2 = nums[l]+nums[r];\\n                    if(t1 > t2) l++;\\n                    else if(t1 < t2) r--;\\n                    else\\n                    {\\n                        if(!*returnSize || (*returnSize && (nums[i]!=arr[*returnSize-1][0]\\n                                        || nums[j]!=arr[*returnSize-1][1]\\n                                        || nums[l]!=arr[*returnSize-1][2]))) //avoid duplicates;\\n                        {\\n                            *returnSize += 1;\\n                            arr = (int**)realloc(arr, sizeof(int*)*(*returnSize));\\n                            arr[*returnSize-1] = (int*)malloc(sizeof(int)*4);\\n                            arr[*returnSize-1][0] = nums[i];\\n                            arr[*returnSize-1][1] = nums[j];\\n                            arr[*returnSize-1][2] = nums[l];\\n                            arr[*returnSize-1][3] = nums[r];\\n                        }\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "    void sort(int* nums, int begin, int end)\\n    {\\n        int l = begin;\\n        int r = end;\\n        int v = nums[l+(r-l)/2];\\n        while(l <= r)\\n        {\\n            while(nums[l] < v) l++;\\n            while(nums[r] > v) r--;\\n            if(l <= r)\\n            {\\n                int t = nums[l];\\n                nums[l] = nums[r];\\n                nums[r] = t;\\n                l++; r--;\\n            }\\n        }\\n        if(begin < r)\\n            sort(nums, begin, r);\\n        if(l < end)\\n            sort(nums, l, end);\\n    }\\n    \\n    //AC - 8ms;\\n    int** fourSum(int* nums, int size, int target, int* returnSize)\\n    {\\n        sort(nums, 0, size-1);\\n        int** arr = (int**)malloc(sizeof(int*));\\n        *returnSize = 0;\\n        for(int i = 0; i < size-3; i++)\\n        {\\n            if(i && nums[i]==nums[i-1]) continue;\\n            int t0 = target-nums[i]; //target for 3Sum;\\n            for(int j = i+1; j < size-2; j++)\\n            {\\n                if(j!=i+1 && nums[j]==nums[j-1]) continue; //the start position should be handled carefully, it's i+1 while removing redundancy;\\n                int t1 = t0-nums[j]; //target for 2Sum;\\n                if(nums[j+1]+nums[j+2] > t1) break; //the possible least sum is even bigger than the target - just try the next first candidate - i+1;\\n                if(nums[size-1]+nums[size-2] < t1) continue; //the possible maximal sum is smaller than the target - just try the next second candidate to make it bigger - j+1;\\n                int l = j+1;\\n                int r = size-1;\\n                while(l < r) //2Sum problem;\\n                {\\n                    int t2 = nums[l]+nums[r];\\n                    if(t1 > t2) l++;\\n                    else if(t1 < t2) r--;\\n                    else\\n                    {\\n                        if(!*returnSize || (*returnSize && (nums[i]!=arr[*returnSize-1][0]\\n                                        || nums[j]!=arr[*returnSize-1][1]\\n                                        || nums[l]!=arr[*returnSize-1][2]))) //avoid duplicates;\\n                        {\\n                            *returnSize += 1;\\n                            arr = (int**)realloc(arr, sizeof(int*)*(*returnSize));\\n                            arr[*returnSize-1] = (int*)malloc(sizeof(int)*4);\\n                            arr[*returnSize-1][0] = nums[i];\\n                            arr[*returnSize-1][1] = nums[j];\\n                            arr[*returnSize-1][2] = nums[l];\\n                            arr[*returnSize-1][3] = nums[r];\\n                        }\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 8686,
                "title": "c-implementation-with-carefully-pruning-accelerates-a-lot-from-100ms-to-16ms",
                "content": "First thanks to the post from  @cx1992 \\n\\nI will just say that with out the 2 using of the \\n\\n      if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\\n\\n      if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\\n\\nThe runing time without these two lines cost 100ms.\\n\\nBut with these lines, cost 16ms !\\n\\nHere is the final implementation \\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>> result;\\n            int n=nums.size();\\n            if(n<4)  return result;\\n            sort(nums.begin(), nums.end());\\n            for(int i=0; i<n-3; i++){\\n                if(i>0 && nums[i]==nums[i-1])  continue;\\n                /** cut edge to accelerate the speed **/\\n                if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\\n                if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\\n                for(int j=i+1; j<n-2; j++){\\n                    if(j>i+1 && nums[j]==nums[j-1])  continue;\\n                    /** cut edge to accelerate the speed **/\\n                    if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target)  break;\\n                    if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target)  continue;\\n                    /** jia bi process **/\\n                    int start=j+1, end=n-1;\\n                    while(start < end){\\n                        int sum=nums[start]+nums[end]+nums[i]+nums[j];\\n                        if(sum<target)  start++;\\n                        else if(sum>target)  end--;\\n                        else{\\n                            result.push_back(vector<int>{nums[i], nums[j], nums[start], nums[end]});\\n                            start++; end--;\\n                            while(nums[start-1]==nums[start] && start<end)  start++;\\n                            while(nums[end+1]==nums[end] && start<end)  end--;\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>> result;\\n            int n=nums.size();\\n            if(n<4)  return result;\\n            sort(nums.begin(), nums.end());\\n            for(int i=0; i<n-3; i++){\\n                if(i>0 && nums[i]==nums[i-1])  continue;\\n                /** cut edge to accelerate the speed **/\\n                if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\\n                if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\\n                for(int j=i+1; j<n-2; j++){\\n                    if(j>i+1 && nums[j]==nums[j-1])  continue;\\n                    /** cut edge to accelerate the speed **/\\n                    if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target)  break;\\n                    if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target)  continue;\\n                    /** jia bi process **/\\n                    int start=j+1, end=n-1;\\n                    while(start < end){\\n                        int sum=nums[start]+nums[end]+nums[i]+nums[j];\\n                        if(sum<target)  start++;\\n                        else if(sum>target)  end--;\\n                        else{\\n                            result.push_back(vector<int>{nums[i], nums[j], nums[start], nums[end]}",
                "codeTag": "Java"
            },
            {
                "id": 8709,
                "title": "c-easy-way-to-handle-duplication",
                "content": "        \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        for (unsigned int i=0; i<nums.size(); i++) {\\n            if (i>0 && nums[i]==nums[i-1])\\n                continue; // avoid duplication for i\\n            for (unsigned int j=i+1; j<nums.size(); j++) {\\n                if (j>i+1 && nums[j]==nums[j-1])\\n                    continue; // avoid duplication for j\\n                int l = j+1, r = nums.size()-1;\\n                while (l < r) {\\n                    int s = nums[i]+nums[j]+nums[l]+nums[r];\\n                    if (s > target)\\n                        r--;\\n                    else if (s < target)\\n                        l++;\\n                    else {\\n                        res.push_back({nums[i], nums[j], nums[l], nums[r]});\\n                        while (l < r && nums[l]==nums[l+1])\\n                            l++; // avoid duplication for l\\n                        while (l < r && nums[r]==nums[r-1])\\n                            r--; // avoid duplication for r\\n                        l++; r--;\\n                    }\\n                }\\n            }\\n         }\\n         return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "        \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        for (unsigned int i=0; i<nums.size(); i++) {\\n            if (i>0 && nums[i]==nums[i-1])\\n                continue; // avoid duplication for i\\n            for (unsigned int j=i+1; j<nums.size(); j++) {\\n                if (j>i+1 && nums[j]==nums[j-1])\\n                    continue; // avoid duplication for j\\n                int l = j+1, r = nums.size()-1;\\n                while (l < r) {\\n                    int s = nums[i]+nums[j]+nums[l]+nums[r];\\n                    if (s > target)\\n                        r--;\\n                    else if (s < target)\\n                        l++;\\n                    else {\\n                        res.push_back({nums[i], nums[j], nums[l], nums[r]});\\n                        while (l < r && nums[l]==nums[l+1])\\n                            l++; // avoid duplication for l\\n                        while (l < r && nums[r]==nums[r-1])\\n                            r--; // avoid duplication for r\\n                        l++; r--;\\n                    }\\n                }\\n            }\\n         }\\n         return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 8722,
                "title": "simple-solution-in-javascript",
                "content": "    var fourSum = function(nums, target) {\\n        var ret = [];\\n        \\n        if(nums.length == 0)\\n            return ret;\\n            \\n        nums.sort(function(a,b){\\n            return a - b;    \\n        });\\n            \\n        for(var i = 0; i < nums.length; i++){\\n            var target2 = target - nums[i];\\n            \\n            for(var j = i + 1; j < nums.length; j++){\\n                var target3 = target2 - nums[j];\\n                \\n                var front = j + 1;\\n                var back = nums.length - 1;\\n                \\n                while(front < back){\\n                    var sum = nums[front] + nums[back];\\n                \\n                    if(sum < target3)\\n                        front++;\\n                        \\n                    else if(sum > target3)\\n                        back--;\\n                    \\n                    else{\\n                        var temp = new Array(4);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[front];\\n                        temp[3] = nums[back];\\n                        ret.push(temp);\\n                        \\n                        while(front < back && nums[front] === temp[2])\\n                            front++;\\n                            \\n                        while(front < back && nums[back] === temp[3])\\n                            back--;\\n                    }\\n                }\\n                \\n                while(j + 1 < nums.length && nums[j + 1] === nums[j]) ++j;\\n            }\\n            \\n            while(i + 1 < nums.length && nums[i + 1] === nums[i]) ++i;\\n        }\\n        \\n        return ret;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var fourSum = function(nums, target) {\\n        var ret = [];\\n        \\n        if(nums.length == 0)\\n            return ret;\\n            \\n        nums.sort(function(a,b){\\n            return a - b;    \\n        });\\n            \\n        for(var i = 0; i < nums.length; i++){\\n            var target2 = target - nums[i];\\n            \\n            for(var j = i + 1; j < nums.length; j++){\\n                var target3 = target2 - nums[j];\\n                \\n                var front = j + 1;\\n                var back = nums.length - 1;\\n                \\n                while(front < back){\\n                    var sum = nums[front] + nums[back];\\n                \\n                    if(sum < target3)\\n                        front++;\\n                        \\n                    else if(sum > target3)\\n                        back--;\\n                    \\n                    else{\\n                        var temp = new Array(4);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[front];\\n                        temp[3] = nums[back];\\n                        ret.push(temp);\\n                        \\n                        while(front < back && nums[front] === temp[2])\\n                            front++;\\n                            \\n                        while(front < back && nums[back] === temp[3])\\n                            back--;\\n                    }\\n                }\\n                \\n                while(j + 1 < nums.length && nums[j + 1] === nums[j]) ++j;\\n            }\\n            \\n            while(i + 1 < nums.length && nums[i + 1] === nums[i]) ++i;\\n        }\\n        \\n        return ret;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 8720,
                "title": "is-there-really-a-o-n-2-solution",
                "content": "The general k-sum problem is discussed here http://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem. The optimal solution is said to be O(N^(K/2) logN) in general for even K.\\n\\nI understand for some special cases there are faster solutions but I have seen not a single solution in the discuss which is O(N^2) (even some are claimed to be O(N^2)).\\n\\nPlease answer this question after you checked the following case:\\nNum has 2N elements of N -1s and N 1s. Target is 0. \\n\\nI modified @Chomolungma code which I think is O(N^2). After removing the number of repeating elements to at most 4, the size of duplicates can be bounded by a constant which leads to O(N^2).\\n\\n    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            results=set()\\n            num.sort()\\n            new_num=[]\\n            filter=dict()\\n            for x in num:\\n                if x not in filter:\\n                    filter[x]=1\\n                    new_num.append(x)\\n                elif filter[x]<4:\\n                    filter[x]+=1;\\n                    new_num.append(x)\\n            pairs=[[x,y] for x in xrange(len(new_num)) for y in xrange(x+1,len(new_num))]        \\n            twoSums=dict()\\n            for pair in pairs:\\n                if new_num[pair[0]]+new_num[pair[1]] in twoSums:\\n                    twoSums[new_num[pair[0]]+new_num[pair[1]]].append(pair)\\n                else:\\n                    twoSums[new_num[pair[0]]+new_num[pair[1]]]=[pair]\\n    \\n            for num1 in twoSums:\\n                num2=target-num1\\n                if num2 >= num1 and num2 in twoSums:\\n                    combinations=[pair1+pair2 for pair1 in twoSums[num1] for pair2 in twoSums[num2] if pair1[1]<pair2[0]]\\n                    for comb in combinations:\\n                        results.add(tuple([new_num[i] for i in comb]))\\n            return [list(sums) for sums in results]",
                "solutionTags": [],
                "code": "The general k-sum problem is discussed here http://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem. The optimal solution is said to be O(N^(K/2) logN) in general for even K.\\n\\nI understand for some special cases there are faster solutions but I have seen not a single solution in the discuss which is O(N^2) (even some are claimed to be O(N^2)).\\n\\nPlease answer this question after you checked the following case:\\nNum has 2N elements of N -1s and N 1s. Target is 0. \\n\\nI modified @Chomolungma code which I think is O(N^2). After removing the number of repeating elements to at most 4, the size of duplicates can be bounded by a constant which leads to O(N^2).\\n\\n    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            results=set()\\n            num.sort()\\n            new_num=[]\\n            filter=dict()\\n            for x in num:\\n                if x not in filter:\\n                    filter[x]=1\\n                    new_num.append(x)\\n                elif filter[x]<4:\\n                    filter[x]+=1;\\n                    new_num.append(x)\\n            pairs=[[x,y] for x in xrange(len(new_num)) for y in xrange(x+1,len(new_num))]        \\n            twoSums=dict()\\n            for pair in pairs:\\n                if new_num[pair[0]]+new_num[pair[1]] in twoSums:\\n                    twoSums[new_num[pair[0]]+new_num[pair[1]]].append(pair)\\n                else:\\n                    twoSums[new_num[pair[0]]+new_num[pair[1]]]=[pair]\\n    \\n            for num1 in twoSums:\\n                num2=target-num1\\n                if num2 >= num1 and num2 in twoSums:\\n                    combinations=[pair1+pair2 for pair1 in twoSums[num1] for pair2 in twoSums[num2] if pair1[1]<pair2[0]]\\n                    for comb in combinations:\\n                        results.add(tuple([new_num[i] for i in comb]))\\n            return [list(sums) for sums in results]",
                "codeTag": "Java"
            },
            {
                "id": 8761,
                "title": "any-better-solution-than-o-n-3",
                "content": "I am using a very traditional way to solve this question. I wonder if there is better time complexity.\\n\\n    public class Solution {\\n    \\tpublic List<List<Integer>> fourSum(int[] num, int target) {\\n    \\t\\tList<List<Integer>> results = new LinkedList<List<Integer>>();\\n    \\t\\tif (num == null || num.length < 4)\\n    \\t\\t\\treturn results;\\n    \\t\\tArrays.sort(num);\\n    \\n    \\t\\tfor (int s = 0; s < num.length - 3; s++) {\\n    \\t\\t\\tif (s > 0 && num[s] == num[s - 1]) \\tcontinue;\\n    \\t\\t\\t\\n    \\n    \\t\\t\\tfor (int e = num.length - 1; e >= s + 3; e--) {\\n    \\t\\t\\t\\tif (e < num.length - 1 && num[e] == num[e + 1]) continue;\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tint local = target - num[s] - num[e];\\n    \\t\\t\\t\\tint j = s + 1;\\n    \\t\\t\\t\\tint k = e - 1;\\n    \\t\\t\\t\\twhile (j < k) {\\n    \\n    \\t\\t\\t\\t\\tif (j > s + 1 && num[j] == num[j - 1]) {\\n    \\t\\t\\t\\t\\t\\tj++;\\n    \\t\\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\tif (k < e - 1 && num[k] == num[k + 1]) {\\n    \\t\\t\\t\\t\\t\\tk--;\\n    \\t\\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t\\tif ((num[j] + num[k]) > local)\\n    \\t\\t\\t\\t\\t\\tk--;\\n    \\t\\t\\t\\t\\telse if ((num[j] + num[k]) < local)\\n    \\t\\t\\t\\t\\t\\tj++;\\n    \\t\\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\t\\tresults.add(new ArrayList<Integer>(Arrays.asList(\\n    \\t\\t\\t\\t\\t\\t\\t\\tnum[s], num[j++], num[k--], num[e])));\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn results;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\tpublic List<List<Integer>> fourSum(int[] num, int target) {\\n    \\t\\tList<List<Integer>> results = new LinkedList<List<Integer>>();\\n    \\t\\tif (num == null || num.length < 4)\\n    \\t\\t\\treturn results;\\n    \\t\\tArrays.sort(num);\\n    \\n    \\t\\tfor (int s = 0; s < num.length - 3; s++) {\\n    \\t\\t\\tif (s > 0 && num[s] == num[s - 1]) \\tcontinue;\\n    \\t\\t\\t\\n    \\n    \\t\\t\\tfor (int e = num.length - 1; e >= s + 3; e--) {\\n    \\t\\t\\t\\tif (e < num.length - 1 && num[e] == num[e + 1]) continue;\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tint local = target - num[s] - num[e];\\n    \\t\\t\\t\\tint j = s + 1;\\n    \\t\\t\\t\\tint k = e - 1;\\n    \\t\\t\\t\\twhile (j < k) {\\n    \\n    \\t\\t\\t\\t\\tif (j > s + 1 && num[j] == num[j - 1]) {\\n    \\t\\t\\t\\t\\t\\tj++;\\n    \\t\\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3944331,
                "title": "brute-force-optimised-hashset-approach",
                "content": "# Brute Force--->O(N^4)--->[TLE]\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        n=len(nums)\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                for k in range(j+1,n-1):\\n                    for l in range(k+1,n):\\n                        temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                        sorted_num=sorted([nums[i],nums[j],nums[k],nums[l]])\\n                        if temp==target and sorted_num not in ans:\\n                            ans.append(sorted_num)\\n        return ans\\n```\\n# Optimised Approach-->Two Pointers Appraoch ----> O(N^3)---->[Accepted]\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        n=len(nums)\\n        nums.sort()\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                k=j+1\\n                l=n-1\\n                while k<l:\\n                    temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                    sorted_num=sorted([nums[i],nums[j],nums[k],nums[l]])\\n                    if temp==target and sorted_num not in ans:\\n                        ans.append(sorted_num)\\n                    elif temp>target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n        return ans\\n ```\\n # Using Hashset----->O(N^3)---->[Accepted]\\n ```\\n class Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=set()\\n        n=len(nums)\\n        nums.sort()\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                k=j+1\\n                l=n-1\\n                while k<l:\\n                    temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                    if temp==target:\\n                        ans.add((nums[i],nums[j],nums[k],nums[l]))\\n                        k+=1\\n                    elif temp>target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n        return list(ans)\\n ```\\n # please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        n=len(nums)\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                for k in range(j+1,n-1):\\n                    for l in range(k+1,n):\\n                        temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                        sorted_num=sorted([nums[i],nums[j],nums[k],nums[l]])\\n                        if temp==target and sorted_num not in ans:\\n                            ans.append(sorted_num)\\n        return ans\\n```\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        n=len(nums)\\n        nums.sort()\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                k=j+1\\n                l=n-1\\n                while k<l:\\n                    temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                    sorted_num=sorted([nums[i],nums[j],nums[k],nums[l]])\\n                    if temp==target and sorted_num not in ans:\\n                        ans.append(sorted_num)\\n                    elif temp>target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n        return ans\\n ```\n```\\n class Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=set()\\n        n=len(nums)\\n        nums.sort()\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                k=j+1\\n                l=n-1\\n                while k<l:\\n                    temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                    if temp==target:\\n                        ans.add((nums[i],nums[j],nums[k],nums[l]))\\n                        k+=1\\n                    elif temp>target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n        return list(ans)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3822225,
                "title": "java-efficient-solution-for-4-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n         Arrays.sort(nums);\\n         List<List<Integer>> q=new ArrayList<>();\\n         int n=nums.length;\\n         for(int i=0;i<n-3;i++)\\n         {\\n             if(i>0&&nums[i]==nums[i-1])\\n             {\\n                 continue;\\n             }\\n             for(int j=i+1;j<n;j++)\\n             {\\n                 if(j>i+1&&nums[j]==nums[j-1])\\n                 {\\n                     continue;\\n                 }\\n                 int k=j+1;\\n                 int l=n-1;\\n                 while(k<l)\\n                 {\\n                    long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if(target==sum)\\n                    {\\n                        ArrayList<Integer> al=new ArrayList<>();\\n                        al.add(nums[i]);\\n                        al.add(nums[j]);\\n                        al.add(nums[k]);\\n                        al.add(nums[l]);\\n                        Collections.sort(al);\\n                        q.add(al);\\n                        k++;\\n                        l--;\\n\\n                    \\n                    while(k<l&&nums[l]==nums[l+1])\\n                    {\\n                        l--;\\n                    }\\n                    while(k<l&&nums[k]==nums[k-1])\\n                    {\\n                        k++;\\n                    }\\n                    }\\n                    else if(sum<target)\\n                    {\\n                        k++;\\n                    }\\n                    else\\n                    {\\n                        l--;\\n                    }\\n                 }\\n             }\\n         }\\n\\n         return q;\\n           \\n        }\\n      \\n       \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n         Arrays.sort(nums);\\n         List<List<Integer>> q=new ArrayList<>();\\n         int n=nums.length;\\n         for(int i=0;i<n-3;i++)\\n         {\\n             if(i>0&&nums[i]==nums[i-1])\\n             {\\n                 continue;\\n             }\\n             for(int j=i+1;j<n;j++)\\n             {\\n                 if(j>i+1&&nums[j]==nums[j-1])\\n                 {\\n                     continue;\\n                 }\\n                 int k=j+1;\\n                 int l=n-1;\\n                 while(k<l)\\n                 {\\n                    long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if(target==sum)\\n                    {\\n                        ArrayList<Integer> al=new ArrayList<>();\\n                        al.add(nums[i]);\\n                        al.add(nums[j]);\\n                        al.add(nums[k]);\\n                        al.add(nums[l]);\\n                        Collections.sort(al);\\n                        q.add(al);\\n                        k++;\\n                        l--;\\n\\n                    \\n                    while(k<l&&nums[l]==nums[l+1])\\n                    {\\n                        l--;\\n                    }\\n                    while(k<l&&nums[k]==nums[k-1])\\n                    {\\n                        k++;\\n                    }\\n                    }\\n                    else if(sum<target)\\n                    {\\n                        k++;\\n                    }\\n                    else\\n                    {\\n                        l--;\\n                    }\\n                 }\\n             }\\n         }\\n\\n         return q;\\n           \\n        }\\n      \\n       \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227678,
                "title": "very-easy-detailed-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nList<List<Integer>>ans=new ArrayList<>();\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(i!=0 && nums[i]==nums[i-1]) continue;\\n\\n            for(int j=i+1;j<n;j++){\\n\\n                if(j!=i+1 && nums[j]==nums[j-1]) continue;\\n\\n                int k=j+1;\\n                int l=n-1;\\n\\n                while(k < l){\\n                    long sum=nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n\\n                    if(sum < target){\\n                        k++;\\n                    }\\n                    else if(sum > target){\\n                        l--;\\n                    }\\n                    else{\\n                        List<Integer>temp=Arrays.asList(nums[i],nums[j],nums[k],nums[l]);\\n                        ans.add(temp);\\n                        k++;\\n                        l--;\\n\\n                        while(k < l && nums[k]==nums[k-1]) k++;\\n\\n                        while(k < l && nums[l]==nums[l+1]) l--;\\n\\n                    }\\n                }\\n            }    \\n\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nList<List<Integer>>ans=new ArrayList<>();\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(i!=0 && nums[i]==nums[i-1]) continue;\\n\\n            for(int j=i+1;j<n;j++){\\n\\n                if(j!=i+1 && nums[j]==nums[j-1]) continue;\\n\\n                int k=j+1;\\n                int l=n-1;\\n\\n                while(k < l){\\n                    long sum=nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n\\n                    if(sum < target){\\n                        k++;\\n                    }\\n                    else if(sum > target){\\n                        l--;\\n                    }\\n                    else{\\n                        List<Integer>temp=Arrays.asList(nums[i],nums[j],nums[k],nums[l]);\\n                        ans.add(temp);\\n                        k++;\\n                        l--;\\n\\n                        while(k < l && nums[k]==nums[k-1]) k++;\\n\\n                        while(k < l && nums[l]==nums[l+1]) l--;\\n\\n                    }\\n                }\\n            }    \\n\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055691,
                "title": "94-javascript-fast-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/U4cX-QMlmgA\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    let res = []\\n    nums.sort((a,b)=>a-b)\\n\\n    for(let i =0; i< nums.length-3;i++){\\n        for(let j =i+1; j<nums.length-2;j++){\\n            let f = nums[i];\\n            let s = nums[j];\\n            let left = j+1;\\n            let right = nums.length-1;\\n            while(left<right){\\n                let sum = f + s + nums[left] + nums[right];\\n                if(sum < target) left++\\n                else if(sum > target) right--\\n                else {\\n                    res.push([f,s,nums[left],nums[right]]);\\n                    while(nums[left] == nums[left+1])left++\\n                    while(nums[right] == nums[right-1]) right--\\n                    left++\\n                    right--\\n                }\\n            }\\n            while(nums[j] == nums[j+1]) j++\\n        }\\n        while(nums[i] == nums[i+1]) i++\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    let res = []\\n    nums.sort((a,b)=>a-b)\\n\\n    for(let i =0; i< nums.length-3;i++){\\n        for(let j =i+1; j<nums.length-2;j++){\\n            let f = nums[i];\\n            let s = nums[j];\\n            let left = j+1;\\n            let right = nums.length-1;\\n            while(left<right){\\n                let sum = f + s + nums[left] + nums[right];\\n                if(sum < target) left++\\n                else if(sum > target) right--\\n                else {\\n                    res.push([f,s,nums[left],nums[right]]);\\n                    while(nums[left] == nums[left+1])left++\\n                    while(nums[right] == nums[right-1]) right--\\n                    left++\\n                    right--\\n                }\\n            }\\n            while(nums[j] == nums[j+1]) j++\\n        }\\n        while(nums[i] == nums[i+1]) i++\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3008845,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        if(nums.size()<4)\\n            return {};\\n        set<vector<int>> ans;\\n        long long int x,sum;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-3;i++)\\n        {\\n            for(int j=i+1;j<nums.size()-2;j++)\\n            {\\n                x=nums[i]+nums[j];\\n                int p=j+1,q=nums.size()-1;\\n                while(p<q)\\n                {\\n                    sum=nums[p]+nums[q];\\n                    if(sum+x==target)\\n                    {\\n                        ans.insert({nums[i],nums[j],nums[p],nums[q]});\\n                      p++;\\n                    }\\n                    else if(sum+x<target)\\n                        p++;\\n                    else if(sum+x>target)\\n                        q--;\\n                }\\n            }\\n        }\\n        vector<vector<int>> vc(ans.begin(), ans.end());\\n        return vc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        if(nums.size()<4)\\n            return {};\\n        set<vector<int>> ans;\\n        long long int x,sum;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-3;i++)\\n        {\\n            for(int j=i+1;j<nums.size()-2;j++)\\n            {\\n                x=nums[i]+nums[j];\\n                int p=j+1,q=nums.size()-1;\\n                while(p<q)\\n                {\\n                    sum=nums[p]+nums[q];\\n                    if(sum+x==target)\\n                    {\\n                        ans.insert({nums[i],nums[j],nums[p],nums[q]});\\n                      p++;\\n                    }\\n                    else if(sum+x<target)\\n                        p++;\\n                    else if(sum+x>target)\\n                        q--;\\n                }\\n            }\\n        }\\n        vector<vector<int>> vc(ans.begin(), ans.end());\\n        return vc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999541,
                "title": "super-easy-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^3)+O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787026,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/4-sum.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nvar fourSum = function (nums, target) {\\n    let solutionArrays = [];\\n\\n    // Sort the array\\n    sortedNums = nums.sort((a, b) => a - b);\\n\\n    // Loop through the array (excluding the last 3 entries)\\n    for (let i = 0; i < sortedNums.length - 3; i++) {\\n        // Check if this is the same number as the last one\\n        if (i > 0 && sortedNums[i] == sortedNums[i - 1]) {\\n            continue;\\n        }\\n\\n        // Loop through the remaining numbers\\n        for (let j = i + 1; j < sortedNums.length - 2; j++) {\\n            // Check if this is the same number as the last one\\n            if (j > i + 1 && sortedNums[j] == sortedNums[j - 1]) {\\n                continue;\\n            }\\n\\n            // Establish a window from the next number to the end of the array\\n            let left = j + 1;\\n            let right = sortedNums.length - 1;\\n\\n            // Run until the window is closed\\n            while (left < right) {\\n                // Add together the current numbers, and each side of the window\\n                const total =\\n                    sortedNums[i] +\\n                    sortedNums[j] +\\n                    sortedNums[left] +\\n                    sortedNums[right];\\n\\n                // If we\\'ve reached an answer, add it to the array of answers\\n                if (total == target) {\\n                    solutionArrays.push([\\n                        sortedNums[i],\\n                        sortedNums[j],\\n                        sortedNums[left],\\n                        sortedNums[right],\\n                    ]);\\n\\n                    // Move the left-hand edge of the window to the right until it reaches a different number\\n                    do {\\n                        left++;\\n                    } while (sortedNums[left] == sortedNums[left - 1]);\\n\\n                    // Move the right-hand edge of the window to the left until it reaches a different number\\n                    do {\\n                        right--;\\n                    } while (sortedNums[right] == sortedNums[right + 1]);\\n                }\\n                // If we\\'re too low\\n                else if (total < target) {\\n                    left++;\\n                }\\n                // If we\\'re too high\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n    }\\n\\n    return solutionArrays;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fourSum = function (nums, target) {\\n    let solutionArrays = [];\\n\\n    // Sort the array\\n    sortedNums = nums.sort((a, b) => a - b);\\n\\n    // Loop through the array (excluding the last 3 entries)\\n    for (let i = 0; i < sortedNums.length - 3; i++) {\\n        // Check if this is the same number as the last one\\n        if (i > 0 && sortedNums[i] == sortedNums[i - 1]) {\\n            continue;\\n        }\\n\\n        // Loop through the remaining numbers\\n        for (let j = i + 1; j < sortedNums.length - 2; j++) {\\n            // Check if this is the same number as the last one\\n            if (j > i + 1 && sortedNums[j] == sortedNums[j - 1]) {\\n                continue;\\n            }\\n\\n            // Establish a window from the next number to the end of the array\\n            let left = j + 1;\\n            let right = sortedNums.length - 1;\\n\\n            // Run until the window is closed\\n            while (left < right) {\\n                // Add together the current numbers, and each side of the window\\n                const total =\\n                    sortedNums[i] +\\n                    sortedNums[j] +\\n                    sortedNums[left] +\\n                    sortedNums[right];\\n\\n                // If we\\'ve reached an answer, add it to the array of answers\\n                if (total == target) {\\n                    solutionArrays.push([\\n                        sortedNums[i],\\n                        sortedNums[j],\\n                        sortedNums[left],\\n                        sortedNums[right],\\n                    ]);\\n\\n                    // Move the left-hand edge of the window to the right until it reaches a different number\\n                    do {\\n                        left++;\\n                    } while (sortedNums[left] == sortedNums[left - 1]);\\n\\n                    // Move the right-hand edge of the window to the left until it reaches a different number\\n                    do {\\n                        right--;\\n                    } while (sortedNums[right] == sortedNums[right + 1]);\\n                }\\n                // If we\\'re too low\\n                else if (total < target) {\\n                    left++;\\n                }\\n                // If we\\'re too high\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n    }\\n\\n    return solutionArrays;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2204217,
                "title": "c-handling-runtime-error-handling-duplicates-fully-explained-easy-solution",
                "content": "**Please Upvote if you found this helpful.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) \\n    {\\n        vector<vector<int>> res;\\n        int n = nums.size(); \\n        sort(nums.begin(),nums.end());\\n        for(int i= 0; i< n-3; i++) \\n        {\\n            long long target_3 = target - nums[i];\\n            for (int j= i+1; j< n-2; j++) \\n            {\\n                long long target_2 = target_3 - nums[j];\\n                int front = j + 1;\\n                int back = n - 1;\\n                while(front < back) \\n                {\\n                    long long two_sum = nums[front] + nums[back];\\n                    if (two_sum < target_2)\\n                    {\\n                        front++;\\n                    }\\n                    else if (two_sum > target_2)\\n                    {\\n                        back--;\\n                    }\\n                    else \\n                    {\\n\\n                        vector<int> quadruplet(4, 0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[3] = nums[back];\\n                        res.push_back(quadruplet);\\n\\n                        // Processing the duplicates of number 3\\n                        while (front < back && nums[front] == quadruplet[2])\\n                        {\\n                            front++;\\n                        }\\n\\n                        // Processing the duplicates of number 4\\n                        while (front < back && nums[back] == quadruplet[3])\\n                        {\\n                            back--;\\n                        }\\n                    }\\n                }\\n\\n                // Processing the duplicates of number 2\\n                while(j + 1 < n-2 && nums[j + 1] == nums[j])\\n                {\\n                    j++;\\n                }\\n            }\\n\\n            // Processing the duplicates of number 1\\n            while (i + 1 < n-3 && nums[i + 1] == nums[i])\\n            {\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) \\n    {\\n        vector<vector<int>> res;\\n        int n = nums.size(); \\n        sort(nums.begin(),nums.end());\\n        for(int i= 0; i< n-3; i++) \\n        {\\n            long long target_3 = target - nums[i];\\n            for (int j= i+1; j< n-2; j++) \\n            {\\n                long long target_2 = target_3 - nums[j];\\n                int front = j + 1;\\n                int back = n - 1;\\n                while(front < back) \\n                {\\n                    long long two_sum = nums[front] + nums[back];\\n                    if (two_sum < target_2)\\n                    {\\n                        front++;\\n                    }\\n                    else if (two_sum > target_2)\\n                    {\\n                        back--;\\n                    }\\n                    else \\n                    {\\n\\n                        vector<int> quadruplet(4, 0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[3] = nums[back];\\n                        res.push_back(quadruplet);\\n\\n                        // Processing the duplicates of number 3\\n                        while (front < back && nums[front] == quadruplet[2])\\n                        {\\n                            front++;\\n                        }\\n\\n                        // Processing the duplicates of number 4\\n                        while (front < back && nums[back] == quadruplet[3])\\n                        {\\n                            back--;\\n                        }\\n                    }\\n                }\\n\\n                // Processing the duplicates of number 2\\n                while(j + 1 < n-2 && nums[j + 1] == nums[j])\\n                {\\n                    j++;\\n                }\\n            }\\n\\n            // Processing the duplicates of number 1\\n            while (i + 1 < n-3 && nums[i + 1] == nums[i])\\n            {\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924194,
                "title": "js-generic-k-sum-recursive-two-pointer",
                "content": "```\\n\\n//approach: Two Pointer\\n//it\\'s a array problem. \\n//\\n//since solving 2Sum, 3Sum, now tackling 4Sum, I\\'m convinced, # could only go up, \\n//so it\\'s more like a generic \\'KSum\\' problem.\\n//we can use loop like we did for 3Sum, where we will have 1 extra loop, before we hit while loop, \\n//same for 5Sum, where we will have 3 for loop, before we hit the while loop, \\n//same goes for increasing number, the for loop, will only increase before we hit the while loop, \\n//so to avoid having large number of for loop to tackle this K Sum problem, \\n//...I\\'m implementing a generalized solution, that could work with any number using backtracking\\n// backtracking technique I use is: \\n// loop(usually), choose(pushing a value in a storage/container), explore(recursive call), unchoose(removing the lates value previously pushed in, from the container)\\n//\\n//we want to sort the array, as we can avoid duplicates in a efficient manner, \\n//then we will recurse through the array elements, until we have 2 element \\n//once we got 2 element, we can basically, send that 2 element for while loop (similar to 2Sum problem)\\nvar fourSum = function(nums, target) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let store = new Array();\\n    let result = new Array();\\n    function helper(start, target, k){\\n        \\n        //base case: is just, when we have k === 2, \\n       //we do the opposite of it, base case technically would be two sum approach after if statement\\n        if(k !== 2){\\n            \\n            //looping until we have K values remaining since it\\'s 4Sum, we want 4 values remaining\\n            //we will have 4 pointers, if we have done the for loop way so, yea\\n            //like 2 for loop pointers, and one left pointer and one right pointer\\n            //since we already have one for loop, so we want to have 3 pointers remaining, so thats why (k+1)\\n            //we looping till (nums.length-k+1)\\n            for(let i = start; i < nums.length-k+1; i++){\\n                \\n                //skip if same element\\n                if(i > start && nums[i] === nums[i-1]) continue;\\n                \\n                //choose\\n                store.push(nums[i]);\\n                \\n                //explore\\n                helper(i+1, target-nums[i], k-1);\\n                \\n                //unchoose\\n                store.pop();\\n                \\n            }\\n            return;\\n        }\\n        \\n        let left = start;\\n        let right = nums.length-1;\\n        \\n        while(left < right){\\n            if(nums[left] + nums[right] > target)\\n                right--;\\n            else if (nums[left] + nums[right] < target)\\n                left++;\\n            else{\\n                let arr = new Array().concat(store);\\n                arr.push(nums[left]);\\n                arr.push(nums[right]);\\n                result.push(arr);\\n                \\n                //skip all the duplicates that left and right have stumbled on\\n                while(left < right && nums[left] === nums[left+1]) left++;\\n                while(left < right && nums[right] === nums[right-1]) right--;\\n                \\n                //one more increment, because we have already worked with this number\\n                //if while loop had worked, we would end with let\\'s say [0, 0, 3]\\n                //end of that 0, we would need to move that 3\\n                left++;\\n                right--;\\n                \\n            }\\n        }\\n    }\\n    \\n    //k= 4 (since it\\'s 4 sum)\\n    //target = target(given)\\n    //left = 0(since we want to start from the beginning of the array)\\n    helper(0, target, 4); \\n    \\n    return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\n//approach: Two Pointer\\n//it\\'s a array problem. \\n//\\n//since solving 2Sum, 3Sum, now tackling 4Sum, I\\'m convinced, # could only go up, \\n//so it\\'s more like a generic \\'KSum\\' problem.\\n//we can use loop like we did for 3Sum, where we will have 1 extra loop, before we hit while loop, \\n//same for 5Sum, where we will have 3 for loop, before we hit the while loop, \\n//same goes for increasing number, the for loop, will only increase before we hit the while loop, \\n//so to avoid having large number of for loop to tackle this K Sum problem, \\n//...I\\'m implementing a generalized solution, that could work with any number using backtracking\\n// backtracking technique I use is: \\n// loop(usually), choose(pushing a value in a storage/container), explore(recursive call), unchoose(removing the lates value previously pushed in, from the container)\\n//\\n//we want to sort the array, as we can avoid duplicates in a efficient manner, \\n//then we will recurse through the array elements, until we have 2 element \\n//once we got 2 element, we can basically, send that 2 element for while loop (similar to 2Sum problem)\\nvar fourSum = function(nums, target) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let store = new Array();\\n    let result = new Array();\\n    function helper(start, target, k){\\n        \\n        //base case: is just, when we have k === 2, \\n       //we do the opposite of it, base case technically would be two sum approach after if statement\\n        if(k !== 2){\\n            \\n            //looping until we have K values remaining since it\\'s 4Sum, we want 4 values remaining\\n            //we will have 4 pointers, if we have done the for loop way so, yea\\n            //like 2 for loop pointers, and one left pointer and one right pointer\\n            //since we already have one for loop, so we want to have 3 pointers remaining, so thats why (k+1)\\n            //we looping till (nums.length-k+1)\\n            for(let i = start; i < nums.length-k+1; i++){\\n                \\n                //skip if same element\\n                if(i > start && nums[i] === nums[i-1]) continue;\\n                \\n                //choose\\n                store.push(nums[i]);\\n                \\n                //explore\\n                helper(i+1, target-nums[i], k-1);\\n                \\n                //unchoose\\n                store.pop();\\n                \\n            }\\n            return;\\n        }\\n        \\n        let left = start;\\n        let right = nums.length-1;\\n        \\n        while(left < right){\\n            if(nums[left] + nums[right] > target)\\n                right--;\\n            else if (nums[left] + nums[right] < target)\\n                left++;\\n            else{\\n                let arr = new Array().concat(store);\\n                arr.push(nums[left]);\\n                arr.push(nums[right]);\\n                result.push(arr);\\n                \\n                //skip all the duplicates that left and right have stumbled on\\n                while(left < right && nums[left] === nums[left+1]) left++;\\n                while(left < right && nums[right] === nums[right-1]) right--;\\n                \\n                //one more increment, because we have already worked with this number\\n                //if while loop had worked, we would end with let\\'s say [0, 0, 3]\\n                //end of that 0, we would need to move that 3\\n                left++;\\n                right--;\\n                \\n            }\\n        }\\n    }\\n    \\n    //k= 4 (since it\\'s 4 sum)\\n    //target = target(given)\\n    //left = 0(since we want to start from the beginning of the array)\\n    helper(0, target, 4); \\n    \\n    return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1701791,
                "title": "c-easy-approach-faster-than-91-o-n-3-two-pointer-approach",
                "content": "\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> ans;\\n        int n= nums.size();\\n        \\n        // If length of array is smaller than 4 then no quadruplet can be formed.\\n        if(n<4) return ans;\\n        \\n        sort(nums.begin(),nums.end()); // to apply two pointer approach\\n        \\n        for(int i=0 ; i<n ; i++){\\n            \\n            long long int a = nums[i];\\n            \\n            for(int j=i+1 ; j<n ; j++){\\n                \\n                long long int b= nums[j];\\n                \\n                // two element are now fixed one at i and other at j\\n                \\n                // applying two pointer approach over the remaining two\\n                \\n                int s = j+1;\\n                int e = n-1;\\n                \\n                \\n                while(s<e){\\n                    \\n                    long long int x = nums[s];\\n                    long long int y = nums[e];\\n                    \\n                    long long int sum = x+y+a+b;\\n                    \\n                    if(sum == target){\\n                        // Need to make all a,b,c,d back to int as ans is a vector of vector of int\\n                        ans.push_back({int(a),int(b),int(x),int(y)});\\n                        \\n                        // skipping same value of x and y\\n                        \\n                        while(s<e and nums[s] == x){\\n                            s++;\\n                        }\\n                        \\n                        while(s<e and nums[e] == y){\\n                            e--;\\n                        }\\n                        \\n                    }\\n                    \\n                    else if(sum > target){\\n                        e--;\\n                    }\\n                    \\n                    else{\\n                        s++;\\n                    }\\n                    \\n                }\\n                \\n                // skipping same value at jth point\\n            \\n                while(j+1<n and nums[j+1] == nums[j]){\\n                    j++;\\n                }  \\n                \\n            }\\n            // skipping same value at ith point\\n            while(i+1<n and nums[i+1] == nums[i]){\\n                i++;\\n            } \\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> ans;\\n        int n= nums.size();\\n        \\n        // If length of array is smaller than 4 then no quadruplet can be formed.\\n        if(n<4) return ans;\\n        \\n        sort(nums.begin(),nums.end()); // to apply two pointer approach\\n        \\n        for(int i=0 ; i<n ; i++){\\n            \\n            long long int a = nums[i];\\n            \\n            for(int j=i+1 ; j<n ; j++){\\n                \\n                long long int b= nums[j];\\n                \\n                // two element are now fixed one at i and other at j\\n                \\n                // applying two pointer approach over the remaining two\\n                \\n                int s = j+1;\\n                int e = n-1;\\n                \\n                \\n                while(s<e){\\n                    \\n                    long long int x = nums[s];\\n                    long long int y = nums[e];\\n                    \\n                    long long int sum = x+y+a+b;\\n                    \\n                    if(sum == target){\\n                        // Need to make all a,b,c,d back to int as ans is a vector of vector of int\\n                        ans.push_back({int(a),int(b),int(x),int(y)});\\n                        \\n                        // skipping same value of x and y\\n                        \\n                        while(s<e and nums[s] == x){\\n                            s++;\\n                        }\\n                        \\n                        while(s<e and nums[e] == y){\\n                            e--;\\n                        }\\n                        \\n                    }\\n                    \\n                    else if(sum > target){\\n                        e--;\\n                    }\\n                    \\n                    else{\\n                        s++;\\n                    }\\n                    \\n                }\\n                \\n                // skipping same value at jth point\\n            \\n                while(j+1<n and nums[j+1] == nums[j]){\\n                    j++;\\n                }  \\n                \\n            }\\n            // skipping same value at ith point\\n            while(i+1<n and nums[i+1] == nums[i]){\\n                i++;\\n            } \\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1080758,
                "title": "python-amazing-solution-o-n-2-easy-understanding",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = set()\\n        \\n        def makeLegalPairs(list1: List[int], list2: List[int]):\\n            for (i, j) in list1:\\n                for (k, l) in list2:\\n                    if i!=k and i!=l and j!=k and j!=l:\\n                        new = sorted([nums[i], nums[j], nums[k], nums[l]])\\n                        res.add(tuple(new))\\n        \\n        helper = defaultdict(list)\\n        for index1 in range(len(nums)):\\n            for index2 in range(index1 + 1, len(nums)):\\n                helper[nums[index1] + nums[index2]].append((index1, index2))\\n        \\n        if not target and len(nums) >= 4 and nums[-1] == 0: return [[0,0,0,0]]\\n\\t\\tsave = set(helper.keys())\\n        for num in helper:\\n            tmp = target - num\\n            if tmp in save:\\n                makeLegalPairs(helper[num], helper[tmp])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = set()\\n        \\n        def makeLegalPairs(list1: List[int], list2: List[int]):\\n            for (i, j) in list1:\\n                for (k, l) in list2:\\n                    if i!=k and i!=l and j!=k and j!=l:\\n                        new = sorted([nums[i], nums[j], nums[k], nums[l]])\\n                        res.add(tuple(new))\\n        \\n        helper = defaultdict(list)\\n        for index1 in range(len(nums)):\\n            for index2 in range(index1 + 1, len(nums)):\\n                helper[nums[index1] + nums[index2]].append((index1, index2))\\n        \\n        if not target and len(nums) >= 4 and nums[-1] == 0: return [[0,0,0,0]]\\n\\t\\tsave = set(helper.keys())\\n        for num in helper:\\n            tmp = target - num\\n            if tmp in save:\\n                makeLegalPairs(helper[num], helper[tmp])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1047540,
                "title": "rust-loop-solution",
                "content": "Runtime: 12 ms, faster than 74.29% of Rust online submissions for 4Sum.\\nMemory Usage: 2 MB, less than 97.14% of Rust online submissions for 4Sum.\\n```\\nimpl Solution {\\n    pub fn four_sum(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\\n        let mut res: Vec<Vec<i32>> = vec![];\\n        if nums.len() < 4 {\\n            return res;\\n        }\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        for i in 0..nums.len() - 1 {\\n            if i > 0 && nums[i] == nums[i - 1] {\\n                continue;\\n            }\\n\\n            for j in i + 1..nums.len() - 2 {\\n                if j > i + 1 && nums[j] == nums[j - 1] {\\n                    continue;\\n                }\\n\\n                let (mut left, mut right) = (j + 1, nums.len() - 1);\\n                while left < right {\\n                    let tmp = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if tmp == target {\\n                        res.push([nums[i], nums[j], nums[left], nums[right]].to_vec());\\n                        left += 1;\\n                        right -= 1;\\n\\n                        while left < right && nums[left] == nums[left - 1] {\\n                            left += 1;\\n                        }\\n                        while left < right && nums[right] == nums[right + 1] {\\n                            right -= 1;\\n                        }\\n                    } else if tmp < target {\\n                        left += 1;\\n                    } else if tmp > target {\\n                        right -= 1;\\n                    }\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn four_sum(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\\n        let mut res: Vec<Vec<i32>> = vec![];\\n        if nums.len() < 4 {\\n            return res;\\n        }\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        for i in 0..nums.len() - 1 {\\n            if i > 0 && nums[i] == nums[i - 1] {\\n                continue;\\n            }\\n\\n            for j in i + 1..nums.len() - 2 {\\n                if j > i + 1 && nums[j] == nums[j - 1] {\\n                    continue;\\n                }\\n\\n                let (mut left, mut right) = (j + 1, nums.len() - 1);\\n                while left < right {\\n                    let tmp = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if tmp == target {\\n                        res.push([nums[i], nums[j], nums[left], nums[right]].to_vec());\\n                        left += 1;\\n                        right -= 1;\\n\\n                        while left < right && nums[left] == nums[left - 1] {\\n                            left += 1;\\n                        }\\n                        while left < right && nums[right] == nums[right + 1] {\\n                            right -= 1;\\n                        }\\n                    } else if tmp < target {\\n                        left += 1;\\n                    } else if tmp > target {\\n                        right -= 1;\\n                    }\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935755,
                "title": "n-3-solution-with-4-pointers",
                "content": "We basically explore the array using 4 pointers: i, j, p and q. i and j are the outer pointers, and p and q are the inner pointers. i and j start at the edges and are incremented/decremented towards the middle of the array. p and q start between i and j, and we test for the solution (a + b + c + d == target). Whenever a combination is found, it is added to the result and we increment/decrement the pointers to guarantee no repetition.\\n\\nThis is only possible because we sorted the array at the beginning. We rely on this property to decide whether to move p, q or both, when looking for a smaller/bigger sum.\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            while (i > 0 && i < nums.length - 1 && nums[i-1] == nums[i]) i++; // avoid repetitions\\n            int a = nums[i];\\n\\n            for (int j = nums.length - 1; j >= 0; j--) {\\n                while (j < nums.length - 1 && j > 0 && nums[j] == nums[j+1]) j--; // avoid repetitions\\n                int d = nums[j];\\n                \\n                int p = i + 1;\\n                int q = j - 1;\\n                while (p < q) {\\n                    int b = nums[p];\\n                    int c = nums[q];\\n\\n                    int sum = a + b + c + d;\\n                    if (sum == target) {\\n                        result.add(List.of(a, b, c, d));\\n                        p++;\\n                        while(p < j && nums[p] == nums[p-1]) p++; // avoid repetitions\\n                        \\n                        q--;\\n                        while(i < q && nums[q] == nums[q+1]) q--; // avoid repetitions\\n                    }\\n                    else if (sum < target) { // sum is too small. Increment p so that we can look for bigger sums\\n                        p++;\\n                    } else { // sum is too big. Decrement q so that we can look for smaller sums\\n                        q--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            while (i > 0 && i < nums.length - 1 && nums[i-1] == nums[i]) i++; // avoid repetitions\\n            int a = nums[i];\\n\\n            for (int j = nums.length - 1; j >= 0; j--) {\\n                while (j < nums.length - 1 && j > 0 && nums[j] == nums[j+1]) j--; // avoid repetitions\\n                int d = nums[j];\\n                \\n                int p = i + 1;\\n                int q = j - 1;\\n                while (p < q) {\\n                    int b = nums[p];\\n                    int c = nums[q];\\n\\n                    int sum = a + b + c + d;\\n                    if (sum == target) {\\n                        result.add(List.of(a, b, c, d));\\n                        p++;\\n                        while(p < j && nums[p] == nums[p-1]) p++; // avoid repetitions\\n                        \\n                        q--;\\n                        while(i < q && nums[q] == nums[q+1]) q--; // avoid repetitions\\n                    }\\n                    else if (sum < target) { // sum is too small. Increment p so that we can look for bigger sums\\n                        p++;\\n                    } else { // sum is too big. Decrement q so that we can look for smaller sums\\n                        q--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502570,
                "title": "java-solution-faster-than-100-by-runtime",
                "content": "```\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n        //\\u5B9A\\u4E49\\u8FD4\\u56DE\\u503C\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (nums == null || nums.length < 4) return ans;\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        for (int i = 0; i < len - 3; i++) {\\n            /*\\u5F53k\\u7684\\u503C\\u4E0E\\u524D\\u9762\\u7684\\u503C\\u76F8\\u7B49\\u65F6\\u5FFD\\u7565*/\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5C0F\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5C0F\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5927\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5927\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F*/\\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target)\\n                break;\\n            /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5927\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5927\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5C0F\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5C0F\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n            if (nums[i] + nums[len - 1] + nums[len - 2] + nums[len - 3] < target)\\n                continue;\\n            for (int j = i + 1; j < len - 2; j++) {\\n                /*\\u5F53j\\u7684\\u503C\\u4E0E\\u524D\\u9762\\u7684\\u503C\\u76F8\\u7B49\\u65F6\\u5FFD\\u7565*/\\n                if (j > i + 1 && nums[j] == nums[j - 1])\\n                    continue;\\n                int l = j + 1, r = len - 1;\\n                /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5C0F\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5C0F\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5927\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5927\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target)\\n                    break;\\n                /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5927\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5927\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5C0F\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5C0F\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n                if (nums[i] + nums[j] + nums[r - 1] + nums[r] < target)\\n                    continue;\\n                while (l < r) {\\n                    int curr = nums[i] + nums[j] + nums[l] + nums[r];\\n                    if (target == curr) {\\n                        ans.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));\\n                        /*\\u53BB\\u91CD*/\\n                        l++;\\n                        while (l < r && nums[l] == nums[l - 1]) l++;\\n                        r--;\\n                        while (r > l && nums[r] == nums[r + 1]) r--;\\n                    } else if (target > curr) {\\n                        l++;\\n                    } else\\n                        r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n        //\\u5B9A\\u4E49\\u8FD4\\u56DE\\u503C\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (nums == null || nums.length < 4) return ans;\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        for (int i = 0; i < len - 3; i++) {\\n            /*\\u5F53k\\u7684\\u503C\\u4E0E\\u524D\\u9762\\u7684\\u503C\\u76F8\\u7B49\\u65F6\\u5FFD\\u7565*/\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5C0F\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5C0F\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5927\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5927\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F*/\\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target)\\n                break;\\n            /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5927\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5927\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5C0F\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5C0F\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n            if (nums[i] + nums[len - 1] + nums[len - 2] + nums[len - 3] < target)\\n                continue;\\n            for (int j = i + 1; j < len - 2; j++) {\\n                /*\\u5F53j\\u7684\\u503C\\u4E0E\\u524D\\u9762\\u7684\\u503C\\u76F8\\u7B49\\u65F6\\u5FFD\\u7565*/\\n                if (j > i + 1 && nums[j] == nums[j - 1])\\n                    continue;\\n                int l = j + 1, r = len - 1;\\n                /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5C0F\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5C0F\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5927\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5927\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target)\\n                    break;\\n                /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5927\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5927\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5C0F\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5C0F\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n                if (nums[i] + nums[j] + nums[r - 1] + nums[r] < target)\\n                    continue;\\n                while (l < r) {\\n                    int curr = nums[i] + nums[j] + nums[l] + nums[r];\\n                    if (target == curr) {\\n                        ans.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));\\n                        /*\\u53BB\\u91CD*/\\n                        l++;\\n                        while (l < r && nums[l] == nums[l - 1]) l++;\\n                        r--;\\n                        while (r > l && nums[r] == nums[r + 1]) r--;\\n                    } else if (target > curr) {\\n                        l++;\\n                    } else\\n                        r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482856,
                "title": "javascript",
                "content": "Runtime: 108 ms, faster than 52.32% of JavaScript online submissions for 4Sum.\\nMemory Usage: 36.3 MB, less than 100.00% of JavaScript online submissions for 4Sum.\\n\\n```\\nvar fourSum = function(nums, target) {\\n  const sortedNums = nums.sort((a, b) => a - b);\\n  let resultArr = [];\\n  for (i = 0; i < sortedNums.length - 3; i++) {\\n    if (i > 0 && sortedNums[i] === sortedNums[i - 1]) {\\n      continue;\\n    }\\n    for (j = i + 1; j < sortedNums.length - 2; j++) {\\n      // \\u8981\\u8003\\u8651 j = i + 1\\u7684\\u60C5\\u51B5\\uFF0C\\u8FD9\\u662F\\u5408\\u7406\\u7684\\n      if (j > i + 1 && sortedNums[j] === sortedNums[j - 1]) {\\n        continue;\\n      }\\n      let left = j + 1;\\n      let right = sortedNums.length - 1;\\n      while (left < right) {\\n        const sum =\\n          sortedNums[i] + sortedNums[j] + sortedNums[left] + sortedNums[right];\\n        if (sum < target) {\\n          left++;\\n        } else if (sum > target) {\\n          right--;\\n        } else {\\n          resultArr.push([\\n            sortedNums[i],\\n            sortedNums[j],\\n            sortedNums[left],\\n            sortedNums[right]\\n          ]);\\n          while (left < right && sortedNums[left] === sortedNums[left + 1]) {\\n            left++;\\n          }\\n          while (left < right && sortedNums[right] === sortedNums[right - 1]) {\\n            right--;\\n          }\\n          left++;\\n          right--;\\n        }\\n      }\\n    }\\n  }\\n  return resultArr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar fourSum = function(nums, target) {\\n  const sortedNums = nums.sort((a, b) => a - b);\\n  let resultArr = [];\\n  for (i = 0; i < sortedNums.length - 3; i++) {\\n    if (i > 0 && sortedNums[i] === sortedNums[i - 1]) {\\n      continue;\\n    }\\n    for (j = i + 1; j < sortedNums.length - 2; j++) {\\n      // \\u8981\\u8003\\u8651 j = i + 1\\u7684\\u60C5\\u51B5\\uFF0C\\u8FD9\\u662F\\u5408\\u7406\\u7684\\n      if (j > i + 1 && sortedNums[j] === sortedNums[j - 1]) {\\n        continue;\\n      }\\n      let left = j + 1;\\n      let right = sortedNums.length - 1;\\n      while (left < right) {\\n        const sum =\\n          sortedNums[i] + sortedNums[j] + sortedNums[left] + sortedNums[right];\\n        if (sum < target) {\\n          left++;\\n        } else if (sum > target) {\\n          right--;\\n        } else {\\n          resultArr.push([\\n            sortedNums[i],\\n            sortedNums[j],\\n            sortedNums[left],\\n            sortedNums[right]\\n          ]);\\n          while (left < right && sortedNums[left] === sortedNums[left + 1]) {\\n            left++;\\n          }\\n          while (left < right && sortedNums[right] === sortedNums[right - 1]) {\\n            right--;\\n          }\\n          left++;\\n          right--;\\n        }\\n      }\\n    }\\n  }\\n  return resultArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405970,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        pairs = collections.defaultdict(list)\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                pairs[nums[i]+nums[j]].append((i, j))\\n        \\n        res = set()\\n        \\n        for s, ps in pairs.items():\\n            for a, b in ps:\\n                if target - s in pairs:\\n                    for k,v in pairs[target-s]:\\n                        if a != k and a != v and b != k and b != v:\\n                            res.add(tuple((sorted([nums[i] for i in [a,b,k,v]]))))\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        pairs = collections.defaultdict(list)\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                pairs[nums[i]+nums[j]].append((i, j))\\n        \\n        res = set()\\n        \\n        for s, ps in pairs.items():\\n            for a, b in ps:\\n                if target - s in pairs:\\n                    for k,v in pairs[target-s]:\\n                        if a != k and a != v and b != k and b != v:\\n                            res.add(tuple((sorted([nums[i] for i in [a,b,k,v]]))))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 385651,
                "title": "python-4sum-1-3sum",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if i == 0 or nums[i] > nums[i-1]:\\n                diff = target - nums[i]\\n                threeSums = self.threeSum(nums[i+1:], diff)\\n                for threeSum in threeSums:\\n                    res.append([nums[i]] + threeSum)\\n        return res\\n                \\n        \\n    def threeSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        if len(nums) < 3: return res\\n\\n        for i in range(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            l, r = i + 1, len(nums) - 1\\n            while l < r :\\n                s = nums[i] + nums[l] + nums[r]\\n                if s == target:\\n                    res.append([nums[i] ,nums[l] ,nums[r]])\\n                    l += 1; r -= 1\\n                    while l < r and nums[l] == nums[l - 1]: l += 1\\n                    while l < r and nums[r] == nums[r + 1]: r -= 1\\n                elif s < target :\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if i == 0 or nums[i] > nums[i-1]:\\n                diff = target - nums[i]\\n                threeSums = self.threeSum(nums[i+1:], diff)\\n                for threeSum in threeSums:\\n                    res.append([nums[i]] + threeSum)\\n        return res\\n                \\n        \\n    def threeSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        if len(nums) < 3: return res\\n\\n        for i in range(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            l, r = i + 1, len(nums) - 1\\n            while l < r :\\n                s = nums[i] + nums[l] + nums[r]\\n                if s == target:\\n                    res.append([nums[i] ,nums[l] ,nums[r]])\\n                    l += 1; r -= 1\\n                    while l < r and nums[l] == nums[l - 1]: l += 1\\n                    while l < r and nums[r] == nums[r + 1]: r -= 1\\n                elif s < target :\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 236899,
                "title": "java-solution-4sum",
                "content": "**Solution 1: Reduce 4-Sum Problem to 3-Sum and 2-Sum sub-problems - Accepted in 20 ms**\\n\\nTime complexity: `O(n^3)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n\\tpublic List<List<Integer>> fourSum(int[] A, int target) \\n\\t{\\n\\t\\tList<List<Integer>> list = new ArrayList<>();\\n\\t\\tArrays.sort(A);\\n\\n\\t\\tfor(int i = 0; i < A.length; i++) \\n\\t\\t{\\n\\t\\t\\tif(i == 0 || A[i] != A[i - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tthreeSum(list, A, i + 1, A.length - 1, target - A[i], A[i]);\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n\\n\\t// Three Sum Problem: list.add(Arrays.asList(w, the three numbers))\\n\\tprivate void threeSum(List<List<Integer>> list, int[] A, int start, int end, int target, int w) \\n\\t{\\n\\t\\tfor(int j = start; j < end; j++) \\n\\t\\t{\\n\\t\\t\\tif(j == start || A[j] != A[j - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\ttwoSum(list, A, j + 1, A.length - 1, target - A[j], w, A[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Two Sum Problem: list.add(Arrays.asList(w, x, the two numbers))\\n\\tprivate void twoSum(List<List<Integer>> list, int[] A, int start, int end, int target, int w, int x) \\n\\t{\\n\\t\\twhile(start < end) \\n\\t\\t{\\n\\t\\t\\tint y = A[start];\\n\\t\\t\\tint z = A[end];\\n\\n\\t\\t\\tif(y + z == target) \\n\\t\\t\\t{\\n\\t\\t\\t\\tlist.add(Arrays.asList(w, x, y, z));\\n\\t\\t\\t\\twhile(start < end && A[start] == A[start + 1]) start++;\\n\\t\\t\\t\\twhile(start < end && A[end] == A[end - 1]) \\t   end--;\\n                start++; end--;\\n\\t\\t\\t}\\n\\t\\t\\telse if(y + z < target)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tend--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n**Solution 2: General Solution for K Sum - Accepted in 31 ms**\\n\\nTime complexity: `O(n ^ (k - 1))`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic List<List<Integer>> fourSum(int[] A, int target)\\n\\t{\\n\\t\\tArrays.sort(A);\\n\\t\\treturn kSum(A, 0, A.length - 1, target, 4);\\n\\t}\\n\\n\\tprivate List<List<Integer>> kSum(int[] A, int start, int end, int target, int k)\\n\\t{\\n\\t\\tList<List<Integer>> list = new ArrayList<>();\\n\\t\\t\\n\\t\\tif(k == 2)\\n\\t\\t{\\n\\t\\t\\twhile(start < end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(A[start] + A[end] == target)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlist.add(new LinkedList<Integer>(Arrays.asList(A[start], target - A[start])));\\n\\t\\t\\t\\t\\twhile(start < end && A[start] == A[start + 1]) start++;\\n\\t\\t\\t\\t\\twhile(start < end && A[end] == A[end - 1])     end--;\\n\\t\\t\\t\\t\\tstart++; end--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (A[start] + A[end] < target)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstart++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse // Reduce kSum to (k - 1)sum\\n\\t\\t{\\n\\t\\t\\tfor(int i = start; i < A.length - k + 1 && A[i] * k <= target; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i == start || A[i] != A[i - 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tList<List<Integer>> mainList = kSum(A, i + 1, A.length - 1, target - A[i], k - 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor(List<Integer> subList : mainList)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsubList.add(0, A[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlist.addAll(mainList);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n\\tpublic List<List<Integer>> fourSum(int[] A, int target) \\n\\t{\\n\\t\\tList<List<Integer>> list = new ArrayList<>();\\n\\t\\tArrays.sort(A);\\n\\n\\t\\tfor(int i = 0; i < A.length; i++) \\n\\t\\t{\\n\\t\\t\\tif(i == 0 || A[i] != A[i - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tthreeSum(list, A, i + 1, A.length - 1, target - A[i], A[i]);\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n\\n\\t// Three Sum Problem: list.add(Arrays.asList(w, the three numbers))\\n\\tprivate void threeSum(List<List<Integer>> list, int[] A, int start, int end, int target, int w) \\n\\t{\\n\\t\\tfor(int j = start; j < end; j++) \\n\\t\\t{\\n\\t\\t\\tif(j == start || A[j] != A[j - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\ttwoSum(list, A, j + 1, A.length - 1, target - A[j], w, A[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Two Sum Problem: list.add(Arrays.asList(w, x, the two numbers))\\n\\tprivate void twoSum(List<List<Integer>> list, int[] A, int start, int end, int target, int w, int x) \\n\\t{\\n\\t\\twhile(start < end) \\n\\t\\t{\\n\\t\\t\\tint y = A[start];\\n\\t\\t\\tint z = A[end];\\n\\n\\t\\t\\tif(y + z == target) \\n\\t\\t\\t{\\n\\t\\t\\t\\tlist.add(Arrays.asList(w, x, y, z));\\n\\t\\t\\t\\twhile(start < end && A[start] == A[start + 1]) start++;\\n\\t\\t\\t\\twhile(start < end && A[end] == A[end - 1]) \\t   end--;\\n                start++; end--;\\n\\t\\t\\t}\\n\\t\\t\\telse if(y + z < target)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tend--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic List<List<Integer>> fourSum(int[] A, int target)\\n\\t{\\n\\t\\tArrays.sort(A);\\n\\t\\treturn kSum(A, 0, A.length - 1, target, 4);\\n\\t}\\n\\n\\tprivate List<List<Integer>> kSum(int[] A, int start, int end, int target, int k)\\n\\t{\\n\\t\\tList<List<Integer>> list = new ArrayList<>();\\n\\t\\t\\n\\t\\tif(k == 2)\\n\\t\\t{\\n\\t\\t\\twhile(start < end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(A[start] + A[end] == target)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlist.add(new LinkedList<Integer>(Arrays.asList(A[start], target - A[start])));\\n\\t\\t\\t\\t\\twhile(start < end && A[start] == A[start + 1]) start++;\\n\\t\\t\\t\\t\\twhile(start < end && A[end] == A[end - 1])     end--;\\n\\t\\t\\t\\t\\tstart++; end--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (A[start] + A[end] < target)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstart++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse // Reduce kSum to (k - 1)sum\\n\\t\\t{\\n\\t\\t\\tfor(int i = start; i < A.length - k + 1 && A[i] * k <= target; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i == start || A[i] != A[i - 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tList<List<Integer>> mainList = kSum(A, i + 1, A.length - 1, target - A[i], k - 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor(List<Integer> subList : mainList)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsubList.add(0, A[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlist.addAll(mainList);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175770,
                "title": "beats-79-java-with-explanations",
                "content": "**Thought**\\n```\\nfourSum(target) = {nums[i], threeSum(target - nums[i])}\\nthreeSum(target) = {nums[j], twoSum(target - nums[j])}\\ntwoSum(target) can be solved by Two-pointers.\\n```\\n\\n**Code**\\n```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        List<List<Integer>> threeSumResult, fourSumResult  = new ArrayList<>();\\n        for (int i = 0; i < n - 1; i++) {\\n            if (nums[i] * 4 > target)\\n                return fourSumResult;\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            threeSumResult = threeSum(nums, target - nums[i], i + 1);\\n            if (threeSumResult.isEmpty())\\n                continue;\\n            for (List<Integer> list : threeSumResult) {\\n                if (!list.isEmpty()) {\\n                    list.add(nums[i]);\\n                    fourSumResult.add(new ArrayList<>(list));\\n                }\\n            }\\n        }\\n        return fourSumResult;\\n    }\\n    \\n    private List<List<Integer>> threeSum(int[] nums, int target, int startIndex) {\\n        int n = nums.length;\\n        List<List<Integer>> twoSumResult, threeSumResult = new ArrayList<>();\\n        for (int i = startIndex; i < n - 1; i++) {\\n            if (nums[i] * 3 > target)\\n                return threeSumResult;\\n            if (i > startIndex && nums[i] == nums[i - 1])\\n                continue;\\n            twoSumResult= twoSum(nums, target - nums[i], i + 1);\\n            if (twoSumResult.isEmpty())\\n                continue;\\n            for (List<Integer> list : twoSumResult) {\\n                if (!list.isEmpty()) {\\n                    list.add(nums[i]);\\n                    threeSumResult.add(new ArrayList<>(list));\\n                }\\n            }\\n        }\\n        return threeSumResult ;\\n    }\\n    \\n    private List<List<Integer>> twoSum(int[] nums, int target, int startIndex) {\\n        int n = nums.length;\\n        int lo = startIndex, hi = n - 1;\\n        if (nums[lo] * 2 > target)\\n            return new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> curResult = null;\\n        while (lo < hi) {\\n            if (nums[lo] + nums[hi] == target) {\\n                curResult = new ArrayList<>();\\n                curResult.add(nums[lo]);\\n                curResult.add(nums[hi]);\\n                result.add(new ArrayList<>(curResult));\\n                lo++;\\n                while (lo < nums.length && lo > 0 && nums[lo] == nums[lo - 1]) \\n                    lo++;\\n                hi--;\\n                while (hi < nums.length && hi > 0 && nums[hi] == nums[hi + 1])\\n                    hi--;\\n            } \\n            else if (nums[lo] + nums[hi] < target) {\\n                lo++;\\n                while (lo < nums.length && lo > 0  && nums[lo] == nums[lo - 1]) \\n                    lo++;\\n            }\\n            else {\\n                hi--;\\n                while (hi < nums.length && hi > 0 && nums[hi] == nums[hi + 1]) \\n                    hi--;\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\nfourSum(target) = {nums[i], threeSum(target - nums[i])}\\nthreeSum(target) = {nums[j], twoSum(target - nums[j])}\\ntwoSum(target) can be solved by Two-pointers.\\n```\n```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        List<List<Integer>> threeSumResult, fourSumResult  = new ArrayList<>();\\n        for (int i = 0; i < n - 1; i++) {\\n            if (nums[i] * 4 > target)\\n                return fourSumResult;\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            threeSumResult = threeSum(nums, target - nums[i], i + 1);\\n            if (threeSumResult.isEmpty())\\n                continue;\\n            for (List<Integer> list : threeSumResult) {\\n                if (!list.isEmpty()) {\\n                    list.add(nums[i]);\\n                    fourSumResult.add(new ArrayList<>(list));\\n                }\\n            }\\n        }\\n        return fourSumResult;\\n    }\\n    \\n    private List<List<Integer>> threeSum(int[] nums, int target, int startIndex) {\\n        int n = nums.length;\\n        List<List<Integer>> twoSumResult, threeSumResult = new ArrayList<>();\\n        for (int i = startIndex; i < n - 1; i++) {\\n            if (nums[i] * 3 > target)\\n                return threeSumResult;\\n            if (i > startIndex && nums[i] == nums[i - 1])\\n                continue;\\n            twoSumResult= twoSum(nums, target - nums[i], i + 1);\\n            if (twoSumResult.isEmpty())\\n                continue;\\n            for (List<Integer> list : twoSumResult) {\\n                if (!list.isEmpty()) {\\n                    list.add(nums[i]);\\n                    threeSumResult.add(new ArrayList<>(list));\\n                }\\n            }\\n        }\\n        return threeSumResult ;\\n    }\\n    \\n    private List<List<Integer>> twoSum(int[] nums, int target, int startIndex) {\\n        int n = nums.length;\\n        int lo = startIndex, hi = n - 1;\\n        if (nums[lo] * 2 > target)\\n            return new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> curResult = null;\\n        while (lo < hi) {\\n            if (nums[lo] + nums[hi] == target) {\\n                curResult = new ArrayList<>();\\n                curResult.add(nums[lo]);\\n                curResult.add(nums[hi]);\\n                result.add(new ArrayList<>(curResult));\\n                lo++;\\n                while (lo < nums.length && lo > 0 && nums[lo] == nums[lo - 1]) \\n                    lo++;\\n                hi--;\\n                while (hi < nums.length && hi > 0 && nums[hi] == nums[hi + 1])\\n                    hi--;\\n            } \\n            else if (nums[lo] + nums[hi] < target) {\\n                lo++;\\n                while (lo < nums.length && lo > 0  && nums[lo] == nums[lo - 1]) \\n                    lo++;\\n            }\\n            else {\\n                hi--;\\n                while (hi < nums.length && hi > 0 && nums[hi] == nums[hi + 1]) \\n                    hi--;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 171054,
                "title": "java-solution-with-explain-really-easy-to-understand",
                "content": "I checked a lot of discussion with their answer. Most of them are hard to read, they all focus on showing their  number of lines of code, or speed of their code, which is boring.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        //fix two numbers, two pointer to other two numbers.\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length - 3; i++) {\\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) { //our pointer(based on first number) is larger(pass) than target, stop searching.\\n                break;\\n            }\\n            if (nums[i] + nums[nums.length - 1] + nums[nums.length - 2] + nums[nums.length - 3] < target) {\\n                continue; //first candidate is too small.\\n            }\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue; // this value is already visited, skip to avoid duplicated value.\\n            }\\n            for (int j = i + 1; j < nums.length - 2; j++) {\\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {\\n                    break; // our pointer based on second number is passed the target, stop searching.\\n                }\\n                if (nums[i] + nums[j] + nums[nums.length - 1] + nums[nums.length - 2] < target) { //j is too small\\n                    continue;\\n                }\\n                if (j > i + 1 && nums[j] == nums[j - 1]) { //here should be j > i + 1, because j can be equal to i at j = i + 1\\n                    continue;  // this value is already visited, skip to avoid duplicated value.\\n                }\\n                //Two pointer.\\n                int start = j + 1;\\n                int end = nums.length - 1;\\n                \\n                while (start < end) {\\n                    int sum = nums[i] + nums[j] + nums[start] + nums[end];\\n                    \\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));\\n                        \\n                        while (start < end && nums[start] == nums[start + 1]) {\\n                            start++; // skip duplicated value.\\n                        }\\n                        while (start < end && nums[end] == nums[end - 1]) {\\n                            end--;\\n                        }\\n                        start++;\\n                        end--;\\n                    } else if (sum < target) {\\n                        start++;\\n                    } else {\\n                        end--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        //fix two numbers, two pointer to other two numbers.\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length - 3; i++) {\\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) { //our pointer(based on first number) is larger(pass) than target, stop searching.\\n                break;\\n            }\\n            if (nums[i] + nums[nums.length - 1] + nums[nums.length - 2] + nums[nums.length - 3] < target) {\\n                continue; //first candidate is too small.\\n            }\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue; // this value is already visited, skip to avoid duplicated value.\\n            }\\n            for (int j = i + 1; j < nums.length - 2; j++) {\\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {\\n                    break; // our pointer based on second number is passed the target, stop searching.\\n                }\\n                if (nums[i] + nums[j] + nums[nums.length - 1] + nums[nums.length - 2] < target) { //j is too small\\n                    continue;\\n                }\\n                if (j > i + 1 && nums[j] == nums[j - 1]) { //here should be j > i + 1, because j can be equal to i at j = i + 1\\n                    continue;  // this value is already visited, skip to avoid duplicated value.\\n                }\\n                //Two pointer.\\n                int start = j + 1;\\n                int end = nums.length - 1;\\n                \\n                while (start < end) {\\n                    int sum = nums[i] + nums[j] + nums[start] + nums[end];\\n                    \\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));\\n                        \\n                        while (start < end && nums[start] == nums[start + 1]) {\\n                            start++; // skip duplicated value.\\n                        }\\n                        while (start < end && nums[end] == nums[end - 1]) {\\n                            end--;\\n                        }\\n                        start++;\\n                        end--;\\n                    } else if (sum < target) {\\n                        start++;\\n                    } else {\\n                        end--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143219,
                "title": "my-java-recursive-solution-for-any-k-sum-problem",
                "content": "This is my lastested version of kSum, I simplified the previous code to make it easier to read.\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int k = 4;\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        if (nums == null || nums.length < k) return list;\\n        Arrays.sort(nums);\\n        List<Integer> track = new ArrayList<Integer>();\\n        kSum(nums, target, k, 0, track, list);\\n        return list;\\n    }\\n    private void kSum(int[] nums, int target, int k, int index, List<Integer> track, List<List<Integer>> list) {\\n        if (k == 2) {\\n            int i = index; int j = nums.length - 1;\\n            while (i < j) {\\n                int sum = nums[i] + nums[j];\\n                if (sum == target) {\\n                    List<Integer> temp = new ArrayList<Integer>(track);\\n                    temp.add(nums[i]); temp.add(nums[j]);\\n                    list.add(temp);\\n                    while (i < j && nums[i] == nums[i + 1]) i ++;\\n                    while (i < j && nums[j] == nums[j - 1]) j --;\\n                    i ++; j --;\\n                } else if (sum > target) {\\n                    while (i < j && nums[j] == nums[j - 1]) j --;\\n                    j --;\\n                } else {\\n                    while (i < j && nums[i] == nums[i + 1]) i ++;\\n                    i ++;\\n                }\\n            }\\n            return;\\n        }\\n        for (int i = index; i <= nums.length - k; i ++) {\\n            if (i > index && nums[i] == nums[i - 1]) continue;\\n            track.add(nums[i]);\\n            kSum(nums, target - nums[i], k - 1, i + 1, track, list);\\n            track.remove(track.size() - 1);\\n        }\\n    }\\n}\\n```\\nPrevious kSum code.\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\\n        if (nums == null || nums.length < 4) return result;\\n        Arrays.sort(nums);\\n        // since this problem ask for the solution of 4 sum, so I just pass 4 to the method. But you can change 4 to any other K\\n        return findSum(nums, target, 0, 4, result);\\n    }\\n    private List<List<Integer>> findSum(int[] nums, int target, int start, int k, List<List<Integer>> result) {\\n        if (k == 2) {\\n            // Do two sum\\n            List<List<Integer>> curr = new LinkedList<List<Integer>>();\\n            int left = start;\\n            int right = nums.length - 1;\\n            while (left < right) {\\n                if (nums[left] + nums[right] == target) {\\n                    List<Integer> list = new LinkedList<Integer>();\\n                    list.add(nums[left]); list.add(nums[right]);\\n                    curr.add(list);\\n                    while (left < right && nums[left] == nums[left + 1]) left ++;\\n                    while (left < right && nums[right] == nums[right - 1]) right --;\\n                    left ++; right --;\\n                } else if (nums[left] + nums[right] > target) right --;\\n                else left ++;\\n            }\\n            return curr;\\n        }\\n        \\n        List<List<Integer>> curr = new LinkedList<List<Integer>>();\\n        for (int i = start; i < nums.length - k + 1; i ++) {\\n            for (List<Integer> l : findSum(nums, target - nums[i], i + 1, k - 1, result)) {\\n                l.add(nums[i]);\\n                curr.add(l);\\n            }\\n            while (i < nums.length - k && nums[i] == nums[i + 1]) i ++;\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int k = 4;\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        if (nums == null || nums.length < k) return list;\\n        Arrays.sort(nums);\\n        List<Integer> track = new ArrayList<Integer>();\\n        kSum(nums, target, k, 0, track, list);\\n        return list;\\n    }\\n    private void kSum(int[] nums, int target, int k, int index, List<Integer> track, List<List<Integer>> list) {\\n        if (k == 2) {\\n            int i = index; int j = nums.length - 1;\\n            while (i < j) {\\n                int sum = nums[i] + nums[j];\\n                if (sum == target) {\\n                    List<Integer> temp = new ArrayList<Integer>(track);\\n                    temp.add(nums[i]); temp.add(nums[j]);\\n                    list.add(temp);\\n                    while (i < j && nums[i] == nums[i + 1]) i ++;\\n                    while (i < j && nums[j] == nums[j - 1]) j --;\\n                    i ++; j --;\\n                } else if (sum > target) {\\n                    while (i < j && nums[j] == nums[j - 1]) j --;\\n                    j --;\\n                } else {\\n                    while (i < j && nums[i] == nums[i + 1]) i ++;\\n                    i ++;\\n                }\\n            }\\n            return;\\n        }\\n        for (int i = index; i <= nums.length - k; i ++) {\\n            if (i > index && nums[i] == nums[i - 1]) continue;\\n            track.add(nums[i]);\\n            kSum(nums, target - nums[i], k - 1, i + 1, track, list);\\n            track.remove(track.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\\n        if (nums == null || nums.length < 4) return result;\\n        Arrays.sort(nums);\\n        // since this problem ask for the solution of 4 sum, so I just pass 4 to the method. But you can change 4 to any other K\\n        return findSum(nums, target, 0, 4, result);\\n    }\\n    private List<List<Integer>> findSum(int[] nums, int target, int start, int k, List<List<Integer>> result) {\\n        if (k == 2) {\\n            // Do two sum\\n            List<List<Integer>> curr = new LinkedList<List<Integer>>();\\n            int left = start;\\n            int right = nums.length - 1;\\n            while (left < right) {\\n                if (nums[left] + nums[right] == target) {\\n                    List<Integer> list = new LinkedList<Integer>();\\n                    list.add(nums[left]); list.add(nums[right]);\\n                    curr.add(list);\\n                    while (left < right && nums[left] == nums[left + 1]) left ++;\\n                    while (left < right && nums[right] == nums[right - 1]) right --;\\n                    left ++; right --;\\n                } else if (nums[left] + nums[right] > target) right --;\\n                else left ++;\\n            }\\n            return curr;\\n        }\\n        \\n        List<List<Integer>> curr = new LinkedList<List<Integer>>();\\n        for (int i = start; i < nums.length - k + 1; i ++) {\\n            for (List<Integer> l : findSum(nums, target - nums[i], i + 1, k - 1, result)) {\\n                l.add(nums[i]);\\n                curr.add(l);\\n            }\\n            while (i < nums.length - k && nums[i] == nums[i + 1]) i ++;\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8733,
                "title": "16ms-c-solution-with-pruning",
                "content": "Sometimes I got 12ms :)\\n\\nI just did some pruning when scan through the first two elements.   The other 2 elements are determined the same as in 2sum.\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>>  result;\\n            if(nums.size() < 4) return result;\\n            \\n            vector<int> solution(4,0);\\n            std::sort(nums.begin(),nums.end());\\n            int sum,a,b,c,d,Max_d_when_a_increase = nums.size() - 1,Max_d_when_b_increase;\\n            \\n            //a,b,c,d are the four index\\n            //Max_d_when_a_increase is the max possible d when a increase. To have the same sum, when a increase, d can only decrease\\n            //Max_d_when_b_increase is the max possible d when b increase\\n            \\n            for( a = 0; a < Max_d_when_a_increase - 2;a++ )\\n            {\\n                //remove dupilcate & do pruning if a too small or too big\\n                if((a>0 && nums[a] == nums[a-1])\\n                || nums[a] + nums[Max_d_when_a_increase] + nums[Max_d_when_a_increase-1] + nums[Max_d_when_a_increase-2] < target) continue;\\n                if(nums[a]+nums[a+1]+nums[a+2]+nums[a+3] > target) break;            \\n    \\n                //update Max_d_when_a_increase\\n                sum = nums[a]+nums[a+1]+nums[a+2];\\n                while(sum+nums[Max_d_when_a_increase] > target)Max_d_when_a_increase--;\\n                Max_d_when_b_increase = Max_d_when_a_increase;\\n    \\n                solution[0] = nums[a];\\n                for( b=a+1; b < Max_d_when_b_increase - 1;b++)\\n                {\\n                    //remove dupilcate & do pruning if b too small or too big\\n                    if((b>a+1 && nums[b] == nums[b-1])\\n                    || nums[a] + nums[b] + nums[Max_d_when_b_increase-1] + nums[Max_d_when_b_increase] < target) continue;\\n                    sum = nums[a] + nums[b]+nums[b+1];\\n                    if(sum + nums[b+2] > target) break;\\n                    \\n                    //update Max_d_when_b_increase\\n                    while(sum+nums[Max_d_when_b_increase]>target) Max_d_when_b_increase--;\\n    \\n                    solution[1] = nums[b];\\n                    c = b+1;\\n                    d = Max_d_when_b_increase;\\n                    sum = nums[a] + nums[b];\\n                    while(c < d)//this are the same as two sum\\n                        if(sum + nums[c] + nums[d] == target)\\n                        {\\n                            solution[2]=nums[c];\\n                            solution[3]=nums[d];\\n                            result.push_back(solution);\\n                            \\n                            do{c++;}while(c < d && nums[c] == nums[c-1]);\\n                            do{d--;}while(c < d && nums[d] == nums[d+1]);\\n                        }\\n                        else if(sum + nums[c] + nums[d] < target) \\n                            do{c++;}while(c < d && nums[c] == nums[c-1]);\\n                        else do{d--;}while(c < d && nums[d] == nums[d+1]);\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>>  result;\\n            if(nums.size() < 4) return result;\\n            \\n            vector<int> solution(4,0);\\n            std::sort(nums.begin(),nums.end());\\n            int sum,a,b,c,d,Max_d_when_a_increase = nums.size() - 1,Max_d_when_b_increase;\\n            \\n            //a,b,c,d are the four index\\n            //Max_d_when_a_increase is the max possible d when a increase. To have the same sum, when a increase, d can only decrease\\n            //Max_d_when_b_increase is the max possible d when b increase\\n            \\n            for( a = 0; a < Max_d_when_a_increase - 2;a++ )\\n            {\\n                //remove dupilcate & do pruning if a too small or too big\\n                if((a>0 && nums[a] == nums[a-1])\\n                || nums[a] + nums[Max_d_when_a_increase] + nums[Max_d_when_a_increase-1] + nums[Max_d_when_a_increase-2] < target) continue;\\n                if(nums[a]+nums[a+1]+nums[a+2]+nums[a+3] > target) break;            \\n    \\n                //update Max_d_when_a_increase\\n                sum = nums[a]+nums[a+1]+nums[a+2];\\n                while(sum+nums[Max_d_when_a_increase] > target)Max_d_when_a_increase--;\\n                Max_d_when_b_increase = Max_d_when_a_increase;\\n    \\n                solution[0] = nums[a];\\n                for( b=a+1; b < Max_d_when_b_increase - 1;b++)\\n                {\\n                    //remove dupilcate & do pruning if b too small or too big\\n                    if((b>a+1 && nums[b] == nums[b-1])\\n                    || nums[a] + nums[b] + nums[Max_d_when_b_increase-1] + nums[Max_d_when_b_increase] < target) continue;\\n                    sum = nums[a] + nums[b]+nums[b+1];\\n                    if(sum + nums[b+2] > target) break;\\n                    \\n                    //update Max_d_when_b_increase\\n                    while(sum+nums[Max_d_when_b_increase]>target) Max_d_when_b_increase--;\\n    \\n                    solution[1] = nums[b];\\n                    c = b+1;\\n                    d = Max_d_when_b_increase;\\n                    sum = nums[a] + nums[b];\\n                    while(c < d)//this are the same as two sum\\n                        if(sum + nums[c] + nums[d] == target)\\n                        {\\n                            solution[2]=nums[c];\\n                            solution[3]=nums[d];\\n                            result.push_back(solution);\\n                            \\n                            do{c++;}",
                "codeTag": "Java"
            },
            {
                "id": 3263647,
                "title": "3-solutions-explained-c",
                "content": "## APPROACH 1 (Take NotTake)\\n**NOTE** : this approach throws TLE\\n\\n**Intuition** :- \\n1. Firstly sort the given array(since we want all the unique combinations, also after sorting all the duplicates will be adjacent to each other).\\n2. Use the take & notTake approach to find all the possible combinations that gives a sum of target. \\n3. If target == 0 && size of currentAns == 4, then we have got a valid combination, so add it to the set(we are using a set since we want all the unique quads).\\n4. If we have exhausted the array or size of currentAns exceeds 4 then simply return.\\n5. Finally store the values of the set in the answer array and return answer.\\n\\n- Time Complexity = O(nlogn) + O(logn * 2^n)\\nO(nlogn) -> sorting \\nO(2^n) -> since at each index we are having two options i.e. to take or not take\\nO(logn) -> insertion in the set\\n\\n- Space Complexity = O(n), since we are using a set\\n\\n\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    void allCombinations(int currentIndex, int target, vector<int>&nums, vector<int>currentAns, \\n                    set<vector<int>>&st)\\n    {\\n        //valid combination\\n        if(target == 0 && currentAns.size() == 4)\\n        {\\n            st.insert(currentAns);\\n            return;\\n        }\\n        \\n        //invalid combination\\n        if(currentIndex == nums.size() || currentAns.size() >= 4)\\n            return ;\\n        \\n        \\n        //take\\n        currentAns.push_back(nums[currentIndex]);\\n        allCombinations(currentIndex+1,target-nums[currentIndex],nums,currentAns,st);\\n        currentAns.pop_back();\\n        \\n        //not take\\n        allCombinations(currentIndex+1,target,nums,currentAns,st);\\n    }\\n    \\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        vector<int>currentAns;\\n        set<vector<int>>st;\\n        vector<vector<int>>ans;\\n        \\n        sort(nums.begin(),nums.end());\\n        allCombinations(0,target,nums,currentAns,st);\\n        \\n        for(auto current : st)\\n            ans.push_back(current);\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n\\n## APPROACH 2 (3 Pointers + Binary Search)\\n**Intuition** :- \\n1. Sort the given array, since we want unique combinations in answer array & after sortin all the duplicates will be adjacent to each other.\\n2. Take three pointers i,j and k. Such that i starts from 0, j starts from i+1 and k starts from j+1 and all of them goes till n.\\n3. Now, sum the values present at i,j and k-th index and find the remaining value to make target, i.e. remaining = target - nums[i] - nums[j] - nums[k].\\n4. Now search if this remaining value is present in the right half(i.e. from k+1 to n) or not.\\n5. If remaining is present in the right half, then it means that we have got a valid combination of size 4 that gives target.\\n6. So insert it into the set, we are using a set because we want only unique quadruplets.\\n7. Finally store the values of set in answer vector and return ans.\\n\\n- Time Complexity = O(nlogn) + O(logn * n^3)\\nO(nlogn) -> for sorting\\nO(logn * n^3) -> longn is for binary search and n^3 is for the 3 loops\\n\\n- Space Complexity = O(n), since we are using a set\\n\\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    //binary search\\n    bool isPresent(int start, int end, long long target, vector<int>&nums)\\n    {\\n        if(start > end)\\n            return false;\\n        \\n        int mid = start + (end-start)/2;\\n        \\n        if(nums[mid] == target)\\n            return true;\\n        \\n        else if(nums[mid] < target)\\n            return isPresent(mid+1,end,target,nums);\\n        \\n        return isPresent(start,mid-1,target,nums);\\n    }\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        int n = nums.size();\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                for(int k = j+1; k < n; k++)\\n                {\\n                    long long val = (long long)nums[i]+(long long)nums[j]+(long long)nums[k];\\n                    long long remaining = target - val;\\n                    \\n                    //implement binary search to check if remaining is present in the right part of array\\n                    if(isPresent(k+1,n-1,remaining,nums))\\n                    {\\n                        vector<int>temp(4,-1);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[k];\\n                        temp[3] = remaining;\\n                        \\n                        st.insert(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //storing all the valid combinations from set to ans vector\\n        for(auto current : st)\\n            ans.push_back(current);\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n\\n## APPROACH 3 (OPTIMAL SOLUTION : 2 Pointers + two Sum)\\n**Intuition** :- \\n1. Sort the array, since we want only unique quadruplets and after sorting all duplicates will be adjacent to each other.\\n2. Take two iterators i ad j such that i starts from 0 and j starts from i+1 and goes till n.\\n3. Now calculate the remaining value, i.e. remaining  = target - nums[i] - nums[j].\\n4. Now we\\'ll take two pointers start & end, start = j+1 & end = n-1.\\n5. If nums[start] + nums[end] > target, then we\\'ll decrement end.\\n6. If nums[start] + nums[end] < target, then we\\'ll increment start.\\n7. If numd[start] + nums[end] == target, it means we have got a valid combination, so we\\'ll create a temp vector and will add it to answer.\\nNow since have used the values at start & end and we want unique combinations, so we\\'ll skip all the values that equal temp[2] by incrementing start and\\nthat are equal to temp[3] by by decrementing end.\\n8.Finally return ans.\\n\\n- Time Complexity = O(n^3)\\n\\n- Space Complexity = O(1)\\n\\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        vector<vector<int>>ans;\\n        \\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                long long remaining = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                \\n                int start = j+1;\\n                int end = n-1;\\n                \\n                while(start < end)\\n                {\\n                    if(nums[start] + nums[end] > remaining)\\n                        end--;\\n                    \\n                    else if(nums[start] + nums[end] < remaining)\\n                        start++;\\n                    \\n                    //valid combination (nums[start] + nums[end] == remaining)\\n                    else\\n                    {\\n                        vector<int>temp(4,-1);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[start];\\n                        temp[3] = nums[end];\\n                    \\n                        ans.push_back(temp);\\n                        \\n                        //skip the duplicates\\n                        while(start < end && nums[start] == temp[2])\\n                            start++;\\n                        while(end > start && nums[end] == temp[3])\\n                            end--;\\n                    }\\n                }\\n                while(j < n-1 && nums[j] == nums[j+1])\\n                    j++;\\n            }\\n            while(i < n-1 && nums[i] == nums[i+1])\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2462f240-7461-4c7c-bd17-ea74d9091ad3_1678092631.7170804.png)\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    void allCombinations(int currentIndex, int target, vector<int>&nums, vector<int>currentAns, \\n                    set<vector<int>>&st)\\n    {\\n        //valid combination\\n        if(target == 0 && currentAns.size() == 4)\\n        {\\n            st.insert(currentAns);\\n            return;\\n        }\\n        \\n        //invalid combination\\n        if(currentIndex == nums.size() || currentAns.size() >= 4)\\n            return ;\\n        \\n        \\n        //take\\n        currentAns.push_back(nums[currentIndex]);\\n        allCombinations(currentIndex+1,target-nums[currentIndex],nums,currentAns,st);\\n        currentAns.pop_back();\\n        \\n        //not take\\n        allCombinations(currentIndex+1,target,nums,currentAns,st);\\n    }\\n    \\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        vector<int>currentAns;\\n        set<vector<int>>st;\\n        vector<vector<int>>ans;\\n        \\n        sort(nums.begin(),nums.end());\\n        allCombinations(0,target,nums,currentAns,st);\\n        \\n        for(auto current : st)\\n            ans.push_back(current);\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    //binary search\\n    bool isPresent(int start, int end, long long target, vector<int>&nums)\\n    {\\n        if(start > end)\\n            return false;\\n        \\n        int mid = start + (end-start)/2;\\n        \\n        if(nums[mid] == target)\\n            return true;\\n        \\n        else if(nums[mid] < target)\\n            return isPresent(mid+1,end,target,nums);\\n        \\n        return isPresent(start,mid-1,target,nums);\\n    }\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        int n = nums.size();\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                for(int k = j+1; k < n; k++)\\n                {\\n                    long long val = (long long)nums[i]+(long long)nums[j]+(long long)nums[k];\\n                    long long remaining = target - val;\\n                    \\n                    //implement binary search to check if remaining is present in the right part of array\\n                    if(isPresent(k+1,n-1,remaining,nums))\\n                    {\\n                        vector<int>temp(4,-1);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[k];\\n                        temp[3] = remaining;\\n                        \\n                        st.insert(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //storing all the valid combinations from set to ans vector\\n        for(auto current : st)\\n            ans.push_back(current);\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        vector<vector<int>>ans;\\n        \\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                long long remaining = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                \\n                int start = j+1;\\n                int end = n-1;\\n                \\n                while(start < end)\\n                {\\n                    if(nums[start] + nums[end] > remaining)\\n                        end--;\\n                    \\n                    else if(nums[start] + nums[end] < remaining)\\n                        start++;\\n                    \\n                    //valid combination (nums[start] + nums[end] == remaining)\\n                    else\\n                    {\\n                        vector<int>temp(4,-1);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[start];\\n                        temp[3] = nums[end];\\n                    \\n                        ans.push_back(temp);\\n                        \\n                        //skip the duplicates\\n                        while(start < end && nums[start] == temp[2])\\n                            start++;\\n                        while(end > start && nums[end] == temp[3])\\n                            end--;\\n                    }\\n                }\\n                while(j < n-1 && nums[j] == nums[j+1])\\n                    j++;\\n            }\\n            while(i < n-1 && nums[i] == nums[i+1])\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138504,
                "title": "java-easy-to-understand-accepted",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i = 0; i < nums.length - 3; i++) {\\n            for(int j = i + 1; j < nums.length - 2; j++) {\\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                while(k < l) {\\n                    long sum = (long)nums[i] + (long)nums[j] + (long)nums[k] + (long)nums[l];\\n                    if(sum == target){\\n                        set.add(List.of(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    else if(sum < target)\\n                        k++;\\n                    else\\n                        l--;\\n                }\\n            }\\n        }\\n        return new ArrayList<>(set);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i = 0; i < nums.length - 3; i++) {\\n            for(int j = i + 1; j < nums.length - 2; j++) {\\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                while(k < l) {\\n                    long sum = (long)nums[i] + (long)nums[j] + (long)nums[k] + (long)nums[l];\\n                    if(sum == target){\\n                        set.add(List.of(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    else if(sum < target)\\n                        k++;\\n                    else\\n                        l--;\\n                }\\n            }\\n        }\\n        return new ArrayList<>(set);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864893,
                "title": "two-pointer-easy-approach-java-easy",
                "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int tar) {\\n    long target =(long)tar;\\n    Arrays.sort(nums);\\n    List<List<Integer>> res=new ArrayList<>();\\n    List<Integer> temp=new ArrayList<>();\\n        helper(nums,target,res,temp);\\n        \\n        \\n        return res;\\n    }\\n    static void helper(int nums[],long target,List<List<Integer>> res,List<Integer> temp){\\n        \\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                            int k=j+1;\\n            int last=nums.length-1;\\n            \\n            while(k<last){\\n                long sum=(long)nums[i]+nums[j]+nums[k]+nums[last];\\n                if(sum==target){\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[k]);\\n                    temp.add(nums[last]);\\n                    \\n                    if(!res.contains(temp)){\\n                        res.add(new ArrayList<>(temp));\\n                    }\\n                    temp.clear();\\n                    k++;\\n                    last--;\\n                    \\n                }\\n                else if(sum>target){\\n                    last--;\\n                }\\n                else{\\n                        k++;\\n                }\\n                \\n            }\\n                \\n            }\\n            \\n            \\n            \\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int tar) {\\n    long target =(long)tar;\\n    Arrays.sort(nums);\\n    List<List<Integer>> res=new ArrayList<>();\\n    List<Integer> temp=new ArrayList<>();\\n        helper(nums,target,res,temp);\\n        \\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2798064,
                "title": "easy-and-optimized-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n     {\\n\\n      vector<vector<int>> v;\\n      sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size(); i++){\\n        if(i != 0 && nums[i] == nums[i - 1]) continue;\\n        for(int j = i + 1; j < nums.size(); j++)\\n        {\\n          if(j != i + 1 && nums[j] == nums[j - 1]) continue;\\n          int k = j + 1;\\n          int l = nums.size() - 1;\\n          while(k < l){\\n            long long int sum = (long long) nums[i] + (long long) nums[j] + (long long) nums[k] + (long long) nums[l];\\n            if(target - sum == 0)\\n            {\\n              v.push_back({nums[i], nums[j], nums[k], nums[l]});\\n              k++;\\n              while(k < l && nums[k] == nums[k - 1]) k++;\\n            }\\n            else if(sum < target) k++;\\n            else l--;\\n          }\\n          \\n        }\\n      }\\n      \\n      return v;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n     {\\n\\n      vector<vector<int>> v;\\n      sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size(); i++){\\n        if(i != 0 && nums[i] == nums[i - 1]) continue;\\n        for(int j = i + 1; j < nums.size(); j++)\\n        {\\n          if(j != i + 1 && nums[j] == nums[j - 1]) continue;\\n          int k = j + 1;\\n          int l = nums.size() - 1;\\n          while(k < l){\\n            long long int sum = (long long) nums[i] + (long long) nums[j] + (long long) nums[k] + (long long) nums[l];\\n            if(target - sum == 0)\\n            {\\n              v.push_back({nums[i], nums[j], nums[k], nums[l]});\\n              k++;\\n              while(k < l && nums[k] == nums[k - 1]) k++;\\n            }\\n            else if(sum < target) k++;\\n            else l--;\\n          }\\n          \\n        }\\n      }\\n      \\n      return v;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773994,
                "title": "java-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n     long[] nums=new long[num.length];\\n     for(int z=0;z<nums.length;z++){\\n         nums[z]=(long)num[z];\\n     } \\n     Arrays.sort(nums);\\n     long sum=0;\\n     HashSet<List<Integer>> set=new HashSet();\\n     List<List<Integer>> ar=new ArrayList();\\n    \\n       for(int i=0;i<nums.length;i++){\\n           if(i>0 && nums[i]==nums[i-1]) continue;\\n           for(int j=i+1;j<nums.length;j++){\\n               if(j>i+1 && nums[j]==nums[j-1]) continue;\\n               int k=j+1;\\n               int l=nums.length-1;\\n               while(k<l){\\n                   sum=nums[i]+nums[j]+nums[k]+nums[l];\\n                   if(sum>target){\\n                       \\n                       l--;\\n                   }\\n                else if(sum==target){\\n                     List<Integer>ar1=new ArrayList();\\n                    ar1.add((int)nums[i]);\\n                    ar1.add((int)nums[j]);\\n                    ar1.add((int)nums[k]);\\n                    ar1.add((int)nums[l]);   \\n                    set.add(ar1);\\n                    k++;\\n                          }\\n               \\n               else{\\n                   k++;\\n               }\\n           }                  \\n       }\\n        \\n    }for(List<Integer> res:set){\\n        ar.add(res);\\n    }  \\n    return ar;\\n   \\n}}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n     long[] nums=new long[num.length];\\n     for(int z=0;z<nums.length;z++){\\n         nums[z]=(long)num[z];\\n     } \\n     Arrays.sort(nums);\\n     long sum=0;\\n     HashSet<List<Integer>> set=new HashSet();\\n     List<List<Integer>> ar=new ArrayList();\\n    \\n       for(int i=0;i<nums.length;i++){\\n           if(i>0 && nums[i]==nums[i-1]) continue;\\n           for(int j=i+1;j<nums.length;j++){\\n               if(j>i+1 && nums[j]==nums[j-1]) continue;\\n               int k=j+1;\\n               int l=nums.length-1;\\n               while(k<l){\\n                   sum=nums[i]+nums[j]+nums[k]+nums[l];\\n                   if(sum>target){\\n                       \\n                       l--;\\n                   }\\n                else if(sum==target){\\n                     List<Integer>ar1=new ArrayList();\\n                    ar1.add((int)nums[i]);\\n                    ar1.add((int)nums[j]);\\n                    ar1.add((int)nums[k]);\\n                    ar1.add((int)nums[l]);   \\n                    set.add(ar1);\\n                    k++;\\n                          }\\n               \\n               else{\\n                   k++;\\n               }\\n           }                  \\n       }\\n        \\n    }for(List<Integer> res:set){\\n        ar.add(res);\\n    }  \\n    return ar;\\n   \\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745816,
                "title": "c-easy-sol-constant-space-approach",
                "content": "* Please upvote if you like my sol.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        long  n = nums.size();\\n        if(n<4) return {};\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        \\n        for(long i=0;i<n;i++){\\n            \\n            for(long j = i+1;j<n;j++){\\n                \\n                long long x = long(target) - long(nums[i])-long(nums[j]);\\n                long l = j+1,r=n-1;\\n                while(r>l){\\n                    \\n                    if(nums[l]+nums[r]>x) r--;\\n                    else if(nums[l]+nums[r]<x) l++;\\n                    else {\\n                        ans.push_back({nums[i],nums[j],nums[l++],nums[r--]});\\n                        while(l<r and nums[l]==nums[l-1]) l++;\\n                        while(l<r and nums[r]==nums[r+1]) r--;\\n                    }\\n                }\\n                while(j + 1 < n && nums[j + 1] == nums[j]) ++j;\\n            }\\n            while (i + 1 < n && nums[i + 1] == nums[i]) ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        long  n = nums.size();\\n        if(n<4) return {};\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        \\n        for(long i=0;i<n;i++){\\n            \\n            for(long j = i+1;j<n;j++){\\n                \\n                long long x = long(target) - long(nums[i])-long(nums[j]);\\n                long l = j+1,r=n-1;\\n                while(r>l){\\n                    \\n                    if(nums[l]+nums[r]>x) r--;\\n                    else if(nums[l]+nums[r]<x) l++;\\n                    else {\\n                        ans.push_back({nums[i],nums[j],nums[l++],nums[r--]});\\n                        while(l<r and nums[l]==nums[l-1]) l++;\\n                        while(l<r and nums[r]==nums[r+1]) r--;\\n                    }\\n                }\\n                while(j + 1 < n && nums[j + 1] == nums[j]) ++j;\\n            }\\n            while (i + 1 < n && nums[i + 1] == nums[i]) ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689946,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length - 3; i++) {\\n            for(int j = i + 1; j < nums.length - 2; j++) {\\n                long res = (nums[i] + nums[j]);\\n                long remSum = target - res;\\n                int front = j + 1, back = nums.length - 1;\\n                while(front < back) {\\n                    long twoSum = nums[front] + nums[back];\\n                    if(twoSum < remSum) front++;\\n                    else if(twoSum > remSum) back--;\\n                    else {\\n                        List<Integer> sum = new ArrayList<>();\\n                        sum.add(nums[i]);\\n                        sum.add(nums[j]);\\n                        sum.add(nums[front]);\\n                        sum.add(nums[back]);\\n                        ans.add(sum);\\n                        \\n                        while(front < back && nums[front] == sum.get(2)) front++;\\n                        while(front < back && nums[back] == sum.get(3)) back--;\\n                    }\\n                }\\n                while(i < nums.length - 1 && nums[i + 1] == nums[i]) i++;\\n                while(j < nums.length - 1 && nums[j + 1] == nums[j]) j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length - 3; i++) {\\n            for(int j = i + 1; j < nums.length - 2; j++) {\\n                long res = (nums[i] + nums[j]);\\n                long remSum = target - res;\\n                int front = j + 1, back = nums.length - 1;\\n                while(front < back) {\\n                    long twoSum = nums[front] + nums[back];\\n                    if(twoSum < remSum) front++;\\n                    else if(twoSum > remSum) back--;\\n                    else {\\n                        List<Integer> sum = new ArrayList<>();\\n                        sum.add(nums[i]);\\n                        sum.add(nums[j]);\\n                        sum.add(nums[front]);\\n                        sum.add(nums[back]);\\n                        ans.add(sum);\\n                        \\n                        while(front < back && nums[front] == sum.get(2)) front++;\\n                        while(front < back && nums[back] == sum.get(3)) back--;\\n                    }\\n                }\\n                while(i < nums.length - 1 && nums[i + 1] == nums[i]) i++;\\n                while(j < nums.length - 1 && nums[j + 1] == nums[j]) j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765703,
                "title": "python-2-pointers-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        if len(nums) < 4:\\n            return []\\n        quad = []\\n        nums.sort()\\n        for i in range(len(nums) - 3):\\n            for j in range(i + 1, len(nums) - 2):\\n                sumA = nums[i] + nums[j]\\n                left = j + 1\\n                right = len(nums) - 1\\n                while left < right:\\n                    sumB = sumA + nums[left] + nums[right]\\n                    if sumB == target:\\n                        quad.append((nums[i], nums[j], nums[left], nums[right]))\\n                        left += 1\\n                        right -= 1\\n                    elif sumB < target:\\n                         left += 1\\n                    else:\\n                         right -= 1\\n        return (set(quad))\\n\\n                        \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        if len(nums) < 4:\\n            return []\\n        quad = []\\n        nums.sort()\\n        for i in range(len(nums) - 3):\\n            for j in range(i + 1, len(nums) - 2):\\n                sumA = nums[i] + nums[j]\\n                left = j + 1\\n                right = len(nums) - 1\\n                while left < right:\\n                    sumB = sumA + nums[left] + nums[right]\\n                    if sumB == target:\\n                        quad.append((nums[i], nums[j], nums[left], nums[right]))\\n                        left += 1\\n                        right -= 1\\n                    elif sumB < target:\\n                         left += 1\\n                    else:\\n                         right -= 1\\n        return (set(quad))\\n\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741754,
                "title": "java-4sum-solution-java-two-pointer",
                "content": "*Runtime is 22sec beating about 60% + submissions*\\nTime Complexity O(n^3)\\nTo understand this solution you must be aware of 2Sum solution using sorting.\\nBut don\\'t worry I\\'ll try to explain it real quick:\\n**2Sum Solution for 4Sum using two pointer**\\n1. We need to find two elements summing to given target.\\n2. Sort the array\\n3. Place 1st pointer(start) at 0 and 2nd pointer(end) at arr.length - 1\\n4. Loop and add location to compare the sum with target\\n5. Increment or decrement start or end accordingly\\nSomething like this:\\n```\\n// start = 0, end = nums.length - 1\\n// Note : nums is sorted\\n\\t\\twhile(start < end){ \\n                    if(target == nums[start]+nums[end]){\\n                        return new int[2] {start, end};\\n\\t\\t\\t\\t\\t\\t\\n                    }else if(temp < nums[start]+nums[end]){\\n                        end--;\\n                    }\\n                    else{\\n                        start++;\\n                    }\\n```\\nNow for **4Sum** \\nWhat we do is create 2 level loop and then do the above code and change them according to the question:\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\t\\n\\t\\t// Sorting the array so we can use two pointer concept\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList();\\n        int n = nums.length;\\n\\t\\t\\n\\t\\t// 1st level loop, n-3 beacuse after i there should be another 3 elements \\n\\t\\t// to get into the result\\n        for(int i=0; i<n-3; i++){\\n\\t\\t\\t//  checking if duplicate is present or not\\n            if(i>0 && nums[i-1] == nums[i]) continue;\\n\\t\\t\\t\\n\\t\\t\\t// Same as outer loop\\n            for(int j=i+1; j< n-2; j++){\\n\\t\\t\\t\\t// Checking for duplicates\\n                if(j > i+1 && nums[j-1] == nums[j]) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Defining variables for 2Sum type problem solution\\n                int start = j + 1;\\n                int end = n -1;\\n                int temp = target - nums[i] - nums[j];\\n\\t\\t\\t\\t// Here temp becomes the temporary target\\n                while(start < end){\\n                    // Check if equal\\n                    if(temp == nums[start]+nums[end]){\\n\\t\\t\\t\\t\\t\\t// Adding to the result\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t//Checking if any duplicates present \\n                        while(start<end && nums[start] == nums[start+1]) start++;\\n                        while(start<end && nums[end] == nums[end-1]) end--;\\n                        start++;\\n                        end--;\\n                    }else if(temp < nums[start]+nums[end]){\\n                        end--;\\n                    }\\n                    else{\\n                        start++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\nIf this helped please make sure to **upvote** and help others as well. Also share you thought and any easier solution.\\n**Thanks**\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n// start = 0, end = nums.length - 1\\n// Note : nums is sorted\\n\\t\\twhile(start < end){ \\n                    if(target == nums[start]+nums[end]){\\n                        return new int[2] {start, end};\\n\\t\\t\\t\\t\\t\\t\\n                    }else if(temp < nums[start]+nums[end]){\\n                        end--;\\n                    }\\n                    else{\\n                        start++;\\n                    }\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\t\\n\\t\\t// Sorting the array so we can use two pointer concept\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList();\\n        int n = nums.length;\\n\\t\\t\\n\\t\\t// 1st level loop, n-3 beacuse after i there should be another 3 elements \\n\\t\\t// to get into the result\\n        for(int i=0; i<n-3; i++){\\n\\t\\t\\t//  checking if duplicate is present or not\\n            if(i>0 && nums[i-1] == nums[i]) continue;\\n\\t\\t\\t\\n\\t\\t\\t// Same as outer loop\\n            for(int j=i+1; j< n-2; j++){\\n\\t\\t\\t\\t// Checking for duplicates\\n                if(j > i+1 && nums[j-1] == nums[j]) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Defining variables for 2Sum type problem solution\\n                int start = j + 1;\\n                int end = n -1;\\n                int temp = target - nums[i] - nums[j];\\n\\t\\t\\t\\t// Here temp becomes the temporary target\\n                while(start < end){\\n                    // Check if equal\\n                    if(temp == nums[start]+nums[end]){\\n\\t\\t\\t\\t\\t\\t// Adding to the result\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t//Checking if any duplicates present \\n                        while(start<end && nums[start] == nums[start+1]) start++;\\n                        while(start<end && nums[end] == nums[end-1]) end--;\\n                        start++;\\n                        end--;\\n                    }else if(temp < nums[start]+nums[end]){\\n                        end--;\\n                    }\\n                    else{\\n                        start++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538652,
                "title": "python-10-lines-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        ans, n = [], len(nums)\\n        nums.sort()\\n        for a in range(n):\\n            for b in range(a+1, n):\\n                c = b+1; d = n-1\\n                while c<d:\\n                    sums = nums[a]+nums[b]+nums[c]+nums[d]\\n                    if sums < target: c += 1\\n                    elif sums > target: d -= 1\\n                    else:\\n                        to_append = [nums[a],nums[b],nums[c],nums[d]]\\n                        if to_append not in ans:\\n                            ans.append(to_append)\\n                        c +=1; d-=1\\n        return ans\\n```\\nstart by sorting the `nums` array, and iterates through the length of `nums` array, \\n- A is the first district number, iterates through 0 to (n-1)\\n- B is the second distict number, iterates through `a+1` to (n-1)\\n- C is the third distict number, iterates through `b+1` until before idx for `d`\\n- D is the last distict number.\\n\\nIn each iteration, we calculate the sums of a+b+c+d,\\n- if sum is equal to target and not yet included into answer, then `[a,b,c,d]` stored to ans. \\n- if the sum < target, increment `c`\\n- if sum > target, decrement `d`\\n\\nrepeat the whole process until all conditions exhausted.\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        ans, n = [], len(nums)\\n        nums.sort()\\n        for a in range(n):\\n            for b in range(a+1, n):\\n                c = b+1; d = n-1\\n                while c<d:\\n                    sums = nums[a]+nums[b]+nums[c]+nums[d]\\n                    if sums < target: c += 1\\n                    elif sums > target: d -= 1\\n                    else:\\n                        to_append = [nums[a],nums[b],nums[c],nums[d]]\\n                        if to_append not in ans:\\n                            ans.append(to_append)\\n                        c +=1; d-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510015,
                "title": "python-o-n-2-with-o-n-extra-memory",
                "content": "```\\nfrom collections import defaultdict, Counter\\n\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        c = Counter(nums)\\n        nums = [i for i in c for j in range(min(4, c[i]))] # get rid of any extraneous duplicates\\n        \\n        pair_sums = {} # mapping of 2-tuple of indices to their sum\\n        sum_pairs = defaultdict(list) # mapping between sum and all pairs with that sum\\n        quadruplets = set() # all 4-sums, sorted by value\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                a, b = nums[i], nums[j]\\n                pair_sums[(i, j)] = a + b\\n                sum_pairs[a+b].append((i, j))\\n                \\n        for i,j in pair_sums:\\n            pair_target = target - pair_sums[(i,j)] # pair_sums[(i,j)] + pair_target = target\\n            for k,l in sum_pairs[pair_target]:\\n                if len(set((i,j,k,l))) == 4:\\n                    quadruplets.add(tuple(sorted((nums[i], nums[j], nums[k], nums[l]))))\\n        return list(quadruplets)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, Counter\\n\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        c = Counter(nums)\\n        nums = [i for i in c for j in range(min(4, c[i]))] # get rid of any extraneous duplicates\\n        \\n        pair_sums = {} # mapping of 2-tuple of indices to their sum\\n        sum_pairs = defaultdict(list) # mapping between sum and all pairs with that sum\\n        quadruplets = set() # all 4-sums, sorted by value\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                a, b = nums[i], nums[j]\\n                pair_sums[(i, j)] = a + b\\n                sum_pairs[a+b].append((i, j))\\n                \\n        for i,j in pair_sums:\\n            pair_target = target - pair_sums[(i,j)] # pair_sums[(i,j)] + pair_target = target\\n            for k,l in sum_pairs[pair_target]:\\n                if len(set((i,j,k,l))) == 4:\\n                    quadruplets.add(tuple(sorted((nums[i], nums[j], nums[k], nums[l]))))\\n        return list(quadruplets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493634,
                "title": "simple-cpp-sorting",
                "content": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<vector<int>>v;\\n        if(n<4) return {};\\n        else{\\n            sort(nums.begin(),nums.end());\\n            for(int i=0;i<n-3;i++){\\n                if(i>0 && nums[i]==nums[i-1]) continue;\\n                for(int j=i+1;j<n-2;j++){\\n                    if(j>i+1 && nums[j]==nums[j-1]) continue;\\n                    \\n                    int val=target-nums[i]-nums[j];\\n                    int l=j+1;\\n                    int h=n-1;\\n                    while(l<h){\\n                        if(nums[l]+nums[h]==val){\\n                            vector<int>v1;\\n                            v1.push_back(nums[i]);\\n                            v1.push_back(nums[j]);\\n                            v1.push_back(nums[l]);\\n                            v1.push_back(nums[h]);\\n                            v.push_back(v1);\\n                            v1.clear();\\n                            while(l<h && nums[l]==nums[l+1]) l++;\\n                            while(l<h && nums[h]==nums[h-1]) h--;\\n                            l++;\\n                            h--;\\n                        }\\n                        else if(nums[l]+nums[h]<val) l++;\\n                        else if(nums[l]+nums[h]>val) h--;\\n                    }\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<vector<int>>v;\\n        if(n<4) return {};\\n        else{\\n            sort(nums.begin(),nums.end());\\n            for(int i=0;i<n-3;i++){\\n                if(i>0 && nums[i]==nums[i-1]) continue;\\n                for(int j=i+1;j<n-2;j++){\\n                    if(j>i+1 && nums[j]==nums[j-1]) continue;\\n                    \\n                    int val=target-nums[i]-nums[j];\\n                    int l=j+1;\\n                    int h=n-1;\\n                    while(l<h){\\n                        if(nums[l]+nums[h]==val){\\n                            vector<int>v1;\\n                            v1.push_back(nums[i]);\\n                            v1.push_back(nums[j]);\\n                            v1.push_back(nums[l]);\\n                            v1.push_back(nums[h]);\\n                            v.push_back(v1);\\n                            v1.clear();\\n                            while(l<h && nums[l]==nums[l+1]) l++;\\n                            while(l<h && nums[h]==nums[h-1]) h--;\\n                            l++;\\n                            h--;\\n                        }\\n                        else if(nums[l]+nums[h]<val) l++;\\n                        else if(nums[l]+nums[h]>val) h--;\\n                    }\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1412755,
                "title": "c-handles-duplicate-values-beginner-friendly-2-sum-modification",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(n<4) return result;\\n        int i,j, first,last,current;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1]) continue;\\n            for(j=i+1;j<n;j++)\\n            {\\n                current = target - nums[i]- nums[j];\\n                first=j+1;\\n                last=n-1;\\n                while(first<last)\\n                {\\n                    if(nums[first]+nums[last]<current)\\n                    {\\n                        first++;\\n                    }\\n                    else if(nums[first]+nums[last]>current)\\n                    {\\n                        last--;\\n                    }\\n                    else\\n                    {\\n                        vector<int> res1(4,0);\\n                        res1[0]=(nums[i]); res1[1]=(nums[j]); res1[2]=(nums[first]); res1[3]=(nums[last]);\\n                        result.push_back(res1);\\n                        while(first<last and nums[first]==res1[2]) ++first;\\n                        while(first<last and nums[last]==res1[3]) --last;\\n                           \\n                    }\\n                }\\n                while(j+1<n and nums[j+1]==nums[j]) ++j;\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(n<4) return result;\\n        int i,j, first,last,current;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1]) continue;\\n            for(j=i+1;j<n;j++)\\n            {\\n                current = target - nums[i]- nums[j];\\n                first=j+1;\\n                last=n-1;\\n                while(first<last)\\n                {\\n                    if(nums[first]+nums[last]<current)\\n                    {\\n                        first++;\\n                    }\\n                    else if(nums[first]+nums[last]>current)\\n                    {\\n                        last--;\\n                    }\\n                    else\\n                    {\\n                        vector<int> res1(4,0);\\n                        res1[0]=(nums[i]); res1[1]=(nums[j]); res1[2]=(nums[first]); res1[3]=(nums[last]);\\n                        result.push_back(res1);\\n                        while(first<last and nums[first]==res1[2]) ++first;\\n                        while(first<last and nums[last]==res1[3]) --last;\\n                           \\n                    }\\n                }\\n                while(j+1<n and nums[j+1]==nums[j]) ++j;\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341498,
                "title": "easy-to-understand-comments-added",
                "content": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> st; // to store unqiue vector\\n        vector<vector<int>> ans;// to store ans\\n        int n = nums.size();// calculating size\\n        if(n < 4)// because a, b,c, d should not same\\n            return ans; \\n        sort(nums.begin(), nums.end());\\n        int d = n-1;\\n\\n        for(int a=0; a<d-2; a++){\\n            for(int b=a+1; b<d-1; b++){\\n                for(int c=b+1,d=n-1; c<d; c++){\\n                    if(nums[a] + nums[b] + nums[c] + nums[d] > target)\\n                    {\\n                        d--;// a,b,c are on minimum and d is pointing on max so reducing d to next lower value\\n                        c--;// to keep c on same position b/c c will increment due to for loop\\n                    }\\n                    else if(nums[a] + nums[b] + nums[c] + nums[d] == target){\\n                        st.insert({nums[a], nums[b], nums[c], nums[d]});// storing one of the possible ans\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it:st)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n\\t\\n```\\n**Do UpVote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> st; // to store unqiue vector\\n        vector<vector<int>> ans;// to store ans\\n        int n = nums.size();// calculating size\\n        if(n < 4)// because a, b,c, d should not same\\n            return ans; \\n        sort(nums.begin(), nums.end());\\n        int d = n-1;\\n\\n        for(int a=0; a<d-2; a++){\\n            for(int b=a+1; b<d-1; b++){\\n                for(int c=b+1,d=n-1; c<d; c++){\\n                    if(nums[a] + nums[b] + nums[c] + nums[d] > target)\\n                    {\\n                        d--;// a,b,c are on minimum and d is pointing on max so reducing d to next lower value\\n                        c--;// to keep c on same position b/c c will increment due to for loop\\n                    }\\n                    else if(nums[a] + nums[b] + nums[c] + nums[d] == target){\\n                        st.insert({nums[a], nums[b], nums[c], nums[d]});// storing one of the possible ans\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it:st)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341323,
                "title": "python-solution",
                "content": "Hope it helps\\n\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        quadruplets = []\\n        unique = set()\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(n - 3):\\n            for j in range(i + 1, n - 2):\\n                start = j + 1\\n                end = n - 1\\n                while start < end:\\n                    if nums[start] + nums[end] == target - nums[i] - nums[j]:\\n                        if (nums[i], nums[j], nums[start], nums[end]) not in unique:\\n                            unique.add((nums[i], nums[j], nums[start], nums[end]))\\n                            quadruplets.append([nums[i], nums[j], nums[start], nums[end]])\\n                        start += 1\\n                        end -= 1\\n                    elif nums[start] + nums[end] < target - nums[i] - nums[j]:\\n                        start += 1\\n                    else:\\n                        end -= 1\\n                \\n        return quadruplets\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        quadruplets = []\\n        unique = set()\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(n - 3):\\n            for j in range(i + 1, n - 2):\\n                start = j + 1\\n                end = n - 1\\n                while start < end:\\n                    if nums[start] + nums[end] == target - nums[i] - nums[j]:\\n                        if (nums[i], nums[j], nums[start], nums[end]) not in unique:\\n                            unique.add((nums[i], nums[j], nums[start], nums[end]))\\n                            quadruplets.append([nums[i], nums[j], nums[start], nums[end]])\\n                        start += 1\\n                        end -= 1\\n                    elif nums[start] + nums[end] < target - nums[i] - nums[j]:\\n                        start += 1\\n                    else:\\n                        end -= 1\\n                \\n        return quadruplets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295328,
                "title": "very-intutive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();        \\n        vector<vector<int>> ans;\\n        if(n<4)\\n            return ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int target_3=target-nums[i]; //target_3 is required target from now\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                \\n                int target_2=target_3-nums[j]; //target_2 is required target from now\\n                \\n                // now we can imagine as a two sum problem from here\\n                \\n                int low=j+1;\\n                int high=n-1;\\n                \\n                while(low<high)\\n                {\\n                    \\n                    int two_sum=nums[low]+nums[high];\\n                    \\n                    if(two_sum>target_2)\\n                    {\\n                        high--;\\n                    }\\n                    else if(two_sum<target_2)\\n                    {\\n                        low++;\\n                    }\\n                    else\\n                    {\\n                        \\n                        vector<int>quadruplet(4);// temporary vector to store quadruplets \\n                        \\n                        quadruplet[0]=nums[i];\\n                        quadruplet[1]=nums[j];\\n                        quadruplet[2]=nums[low];\\n                        quadruplet[3]=nums[high];\\n                        \\n                        ans.push_back(quadruplet);\\n                        \\n                        /// remove duplicates of number 3\\n                        \\n                        while(low<high&&nums[low]==quadruplet[2])\\n                            low++;\\n                        \\n                         /// remove duplicates of number 4\\n                        \\n                        while(low<high&&nums[high]==quadruplet[3])\\n                            high--;\\n                        \\n                        \\n                    }\\n                }\\n                \\n                 /// remove duplicates of number 2\\n                        \\n                 while(j+1<n&&nums[j+1]==nums[j])\\n                        j++;\\n                        \\n                \\n                \\n            }\\n            \\n             /// remove duplicates of number 1\\n                        \\n                while(i+1<n&&nums[i+1]==nums[i])\\n                            i++;\\n                        \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();        \\n        vector<vector<int>> ans;\\n        if(n<4)\\n            return ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int target_3=target-nums[i]; //target_3 is required target from now\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                \\n                int target_2=target_3-nums[j]; //target_2 is required target from now\\n                \\n                // now we can imagine as a two sum problem from here\\n                \\n                int low=j+1;\\n                int high=n-1;\\n                \\n                while(low<high)\\n                {\\n                    \\n                    int two_sum=nums[low]+nums[high];\\n                    \\n                    if(two_sum>target_2)\\n                    {\\n                        high--;\\n                    }\\n                    else if(two_sum<target_2)\\n                    {\\n                        low++;\\n                    }\\n                    else\\n                    {\\n                        \\n                        vector<int>quadruplet(4);// temporary vector to store quadruplets \\n                        \\n                        quadruplet[0]=nums[i];\\n                        quadruplet[1]=nums[j];\\n                        quadruplet[2]=nums[low];\\n                        quadruplet[3]=nums[high];\\n                        \\n                        ans.push_back(quadruplet);\\n                        \\n                        /// remove duplicates of number 3\\n                        \\n                        while(low<high&&nums[low]==quadruplet[2])\\n                            low++;\\n                        \\n                         /// remove duplicates of number 4\\n                        \\n                        while(low<high&&nums[high]==quadruplet[3])\\n                            high--;\\n                        \\n                        \\n                    }\\n                }\\n                \\n                 /// remove duplicates of number 2\\n                        \\n                 while(j+1<n&&nums[j+1]==nums[j])\\n                        j++;\\n                        \\n                \\n                \\n            }\\n            \\n             /// remove duplicates of number 1\\n                        \\n                while(i+1<n&&nums[i+1]==nums[i])\\n                            i++;\\n                        \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243001,
                "title": "c-solution-same-as-3sum-with-explanation",
                "content": "```\\n    /*\\n     * Approach followed is similar to 3 sum where first we sort the\\n     * input array in increasing order and traverse first loop start\\n     * with index i and second loop traverse from i + 1, now we need\\n     * to find 2 nos using Binary search that sums up to target.\\n    */\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // variable to store the result\\n        vector<vector<int>> res;\\n        \\n        // check if we have sufficient elements to find the quadruplets\\n        if (nums.size() < 4) {\\n            // no sufficient elemets for finding quadruplets\\n            return res;\\n        }\\n        \\n        // Sort the input array in increasing order\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        // variable to define remaining target\\n        int target_2;\\n        \\n        // Temp variables\\n        int a, b, c, d;\\n        \\n        // Traverse and find all quadruplets\\n        for (int i = 0; i < n; i++) {\\n            a = nums[i];\\n            \\n            for (int j = i + 1; j < n; j++) {\\n                b = nums[j];\\n                \\n                // a + b + c + d = target\\n                // => c + d = target - a - b\\n                target_2 = target - a - b;\\n                \\n                // Need to find the remaning two numbers that sum up to target_2\\n                // defining k & l indicies\\n                int k = j + 1;\\n                int l = n - 1;\\n                \\n                // Traverse remainig elements such that sum is equal to target_2\\n                // using binary search\\n                while (k < l) {\\n                    c = nums[k];\\n                    d = nums[l];\\n                    \\n                    // check if the sum is equal to target_2\\n                    if (c + d == target_2) {\\n                        // sum of the nums is zero, found a triplet\\n                        res.push_back({a, b, c, d});\\n                        \\n                        // check if the next element is a duplicate, if so\\n                        // exclude it as duplicate triplets are not allowed\\n                        while (k < l && nums[k] == c) {\\n                            // duplicate, exclude this\\n                            k++;\\n                        }\\n                        \\n                        while (k < l && nums[l] == d) {\\n                            // duplicate, exclude this\\n                            l--;\\n                        }\\n                    }\\n                    else {\\n                        // check if the sum is greater than target, if so reduce k\\n                        // if sum is less than target, then reduce j\\n                        c + d > target_2 ? --l : ++k;\\n                    }\\n                }\\n                \\n                // Check if the next element is duplicate, if so exclude it\\n                while (j + 1 < n && nums[j + 1] == b) {\\n                    j++;\\n                }\\n            }\\n\\n            // check if the next element is duplicate, if so exclude it\\n            while (i + 1 < n && nums[i + 1] == a) {\\n                i++;\\n            }\\n        }\\n        \\n        // return the quadruplets\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Approach followed is similar to 3 sum where first we sort the\\n     * input array in increasing order and traverse first loop start\\n     * with index i and second loop traverse from i + 1, now we need\\n     * to find 2 nos using Binary search that sums up to target.\\n    */\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // variable to store the result\\n        vector<vector<int>> res;\\n        \\n        // check if we have sufficient elements to find the quadruplets\\n        if (nums.size() < 4) {\\n            // no sufficient elemets for finding quadruplets\\n            return res;\\n        }\\n        \\n        // Sort the input array in increasing order\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        // variable to define remaining target\\n        int target_2;\\n        \\n        // Temp variables\\n        int a, b, c, d;\\n        \\n        // Traverse and find all quadruplets\\n        for (int i = 0; i < n; i++) {\\n            a = nums[i];\\n            \\n            for (int j = i + 1; j < n; j++) {\\n                b = nums[j];\\n                \\n                // a + b + c + d = target\\n                // => c + d = target - a - b\\n                target_2 = target - a - b;\\n                \\n                // Need to find the remaning two numbers that sum up to target_2\\n                // defining k & l indicies\\n                int k = j + 1;\\n                int l = n - 1;\\n                \\n                // Traverse remainig elements such that sum is equal to target_2\\n                // using binary search\\n                while (k < l) {\\n                    c = nums[k];\\n                    d = nums[l];\\n                    \\n                    // check if the sum is equal to target_2\\n                    if (c + d == target_2) {\\n                        // sum of the nums is zero, found a triplet\\n                        res.push_back({a, b, c, d});\\n                        \\n                        // check if the next element is a duplicate, if so\\n                        // exclude it as duplicate triplets are not allowed\\n                        while (k < l && nums[k] == c) {\\n                            // duplicate, exclude this\\n                            k++;\\n                        }\\n                        \\n                        while (k < l && nums[l] == d) {\\n                            // duplicate, exclude this\\n                            l--;\\n                        }\\n                    }\\n                    else {\\n                        // check if the sum is greater than target, if so reduce k\\n                        // if sum is less than target, then reduce j\\n                        c + d > target_2 ? --l : ++k;\\n                    }\\n                }\\n                \\n                // Check if the next element is duplicate, if so exclude it\\n                while (j + 1 < n && nums[j + 1] == b) {\\n                    j++;\\n                }\\n            }\\n\\n            // check if the next element is duplicate, if so exclude it\\n            while (i + 1 < n && nums[i + 1] == a) {\\n                i++;\\n            }\\n        }\\n        \\n        // return the quadruplets\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156100,
                "title": "100-faster-c-4-sum",
                "content": "\\n***Do upvote if you found it helpful to keep me motivated to post more*** \\n***For better understanding make a dry run***\\n```\\n class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& num, int target) {\\n    vector<vector<int>> res;\\n    if(num.empty())\\n    return res;\\n    int n=num.size();\\n    int i,j;\\n    sort(num.begin(),num.end()); // sort the array\\n    for(i=0;i<n;i++)\\n    {\\n        for(j=i+1;j<n;j++)\\n        {\\n            int target2;\\n            target2=target-num[i]-num[j];\\n            int front=j+1;\\n            int back=n-1;\\n            while(front<back)\\n            {\\n                int sum=num[front]+num[back];\\n                if(target2<sum) // decrement from end\\n                back--;\\n                else if(target2>sum) // increment from start\\n                front++;\\n                else\\n                 {\\n                 vector<int> v(4,0);\\n                 v[0]=num[i];\\n                 v[1]=num[j];\\n                 v[2]=num[front];\\n                 v[3]=num[back];\\n                 res.push_back(v);\\n\\t\\t\\t\\t \\n                 while(front<back && num[front]==v[2])\\n                     front++;\\n                 while(front<back && num[back]==v[3])\\n                     back--;\\n                }\\n                \\n             while(j+1<n && num[j+1]==num[j])\\n                j++;\\n            }\\n\\t\\t\\t\\n         while(i+1<n && num[i+1]==num[i])\\n            i++;  \\n        }\\n    }\\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& num, int target) {\\n    vector<vector<int>> res;\\n    if(num.empty())\\n    return res;\\n    int n=num.size();\\n    int i,j;\\n    sort(num.begin(),num.end()); // sort the array\\n    for(i=0;i<n;i++)\\n    {\\n        for(j=i+1;j<n;j++)\\n        {\\n            int target2;\\n            target2=target-num[i]-num[j];\\n            int front=j+1;\\n            int back=n-1;\\n            while(front<back)\\n            {\\n                int sum=num[front]+num[back];\\n                if(target2<sum) // decrement from end\\n                back--;\\n                else if(target2>sum) // increment from start\\n                front++;\\n                else\\n                 {\\n                 vector<int> v(4,0);\\n                 v[0]=num[i];\\n                 v[1]=num[j];\\n                 v[2]=num[front];\\n                 v[3]=num[back];\\n                 res.push_back(v);\\n\\t\\t\\t\\t \\n                 while(front<back && num[front]==v[2])\\n                     front++;\\n                 while(front<back && num[back]==v[3])\\n                     back--;\\n                }\\n                \\n             while(j+1<n && num[j+1]==num[j])\\n                j++;\\n            }\\n\\t\\t\\t\\n         while(i+1<n && num[i+1]==num[i])\\n            i++;  \\n        }\\n    }\\n       return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101552,
                "title": "easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& s, int k) {\\n     int z=s.size();\\n    if(s.size()<4) return {};\\n    int arr[z];\\n    int p=0;\\n    for(int i=0;i<z;i++)\\n    {\\n        arr[p]=s[i];\\n        p++;\\n    }\\n    sort(arr,arr+z);\\n    vector<int>v1;\\n        \\n    set<vector<int>>st;\\n    vector<vector<int>>v;\\n       \\n    for(int i=0;i<z-3;i++)\\n    {\\n        for(int j=i+1;j<z-2;j++)\\n        {\\n            int l=j+1;\\n            int r=z-1;\\n            while(l<r)\\n            {\\n                if(arr[i]+arr[j]+arr[l]+arr[r]==k)\\n                {\\n                    v1.push_back(arr[i]);\\n                    v1.push_back(arr[j]);\\n                     v1.push_back(arr[l]);\\n                     v1.push_back(arr[r]);\\n                    if(!st.count(v1))\\n                    {\\n                        st.insert(v1);\\n                        v.push_back(v1);\\n                    }\\n                     v1.clear();\\n                     l++;\\n                     r--;\\n                     \\n                    \\n                }\\n                if(arr[i]+arr[j]+arr[l]+arr[r]<k)\\n                {\\n                l++;\\n                }\\n                \\n                else if(arr[i]+arr[j]+arr[l]+arr[r]>k)\\n                {\\n                   r--;\\n                    \\n                }\\n            }\\n            \\n        }\\n      \\n    }\\n    return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& s, int k) {\\n     int z=s.size();\\n    if(s.size()<4) return {};\\n    int arr[z];\\n    int p=0;\\n    for(int i=0;i<z;i++)\\n    {\\n        arr[p]=s[i];\\n        p++;\\n    }\\n    sort(arr,arr+z);\\n    vector<int>v1;\\n        \\n    set<vector<int>>st;\\n    vector<vector<int>>v;\\n       \\n    for(int i=0;i<z-3;i++)\\n    {\\n        for(int j=i+1;j<z-2;j++)\\n        {\\n            int l=j+1;\\n            int r=z-1;\\n            while(l<r)\\n            {\\n                if(arr[i]+arr[j]+arr[l]+arr[r]==k)\\n                {\\n                    v1.push_back(arr[i]);\\n                    v1.push_back(arr[j]);\\n                     v1.push_back(arr[l]);\\n                     v1.push_back(arr[r]);\\n                    if(!st.count(v1))\\n                    {\\n                        st.insert(v1);\\n                        v.push_back(v1);\\n                    }\\n                     v1.clear();\\n                     l++;\\n                     r--;\\n                     \\n                    \\n                }\\n                if(arr[i]+arr[j]+arr[l]+arr[r]<k)\\n                {\\n                l++;\\n                }\\n                \\n                else if(arr[i]+arr[j]+arr[l]+arr[r]>k)\\n                {\\n                   r--;\\n                    \\n                }\\n            }\\n            \\n        }\\n      \\n    }\\n    return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019809,
                "title": "c-detailed-explanation-3-sum-successor",
                "content": "First of all solve [two sum](https://leetcode.com/problems/two-sum/) & [3 sum](https://leetcode.com/problems/3sum/) , then you will get better idea to solve this problem and will be able to under my comments solution.\\n\\n### T = O(n^3) & S = O(1)\\n\\n```\\n vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       // T = O(n^3) & S = O(1)\\n        vector<vector<int>> res; // creating a result vector\\n        if(nums.empty()) { // If no element in given vector then empty vector iss returned\\n            return res;\\n        }\\n        int n = nums.size();  // size of given vector\\n        sort(nums.begin(), nums.end());  // sort the array in O(nlog(n)) for optimizing solution\\n        \\n        for(int i = 0; i < n; i++) {    // i pointer from 0 to n\\n            for(int j = i+1; j < n; j++) {  // j pointer from i+1 to n\\n                int rem = target - nums[i] - nums[j]; // remaining value to find\\n                int front = j+1;   // left pointer  just after j\\n                int back = n-1;    // right pointer at last index\\n                \\n                while(front < back) { // loop till front and back pointer donot cross over\\n                    int two_sum = nums[front] + nums[back]; // now come to two sum problem where we need to check for rem\\n                    if(two_sum < rem) front++;  // if(rem > two_sum) then logically we have to move front pointer ahead to increase value close to rem\\n                               \\n                    else if(two_sum > rem) back--; // if(rem < two_sum) then logically move back pointer to back to minimise value to come closer to rem value \\n                    \\n                    else {           // if (rem == two_sum) then we got the quadruplet (i, j, front, back indexed values)\\n                        vector<int> quadruplet(4, 0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[3] = nums[back];\\n                        res.push_back(quadruplet);\\n                        \\n                        // processing the duplicates of number 3\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n                        \\n                        // processing the duplicates of number 4\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n                // processing the duplicates of number 2\\n                while(j + 1 < n && nums[j + 1] == nums[j]) ++j;\\n            }\\n             // processing the duplicates of number 1\\n                while(i + 1 < n && nums[i + 1] == nums[i]) ++i;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       // T = O(n^3) & S = O(1)\\n        vector<vector<int>> res; // creating a result vector\\n        if(nums.empty()) { // If no element in given vector then empty vector iss returned\\n            return res;\\n        }\\n        int n = nums.size();  // size of given vector\\n        sort(nums.begin(), nums.end());  // sort the array in O(nlog(n)) for optimizing solution\\n        \\n        for(int i = 0; i < n; i++) {    // i pointer from 0 to n\\n            for(int j = i+1; j < n; j++) {  // j pointer from i+1 to n\\n                int rem = target - nums[i] - nums[j]; // remaining value to find\\n                int front = j+1;   // left pointer  just after j\\n                int back = n-1;    // right pointer at last index\\n                \\n                while(front < back) { // loop till front and back pointer donot cross over\\n                    int two_sum = nums[front] + nums[back]; // now come to two sum problem where we need to check for rem\\n                    if(two_sum < rem) front++;  // if(rem > two_sum) then logically we have to move front pointer ahead to increase value close to rem\\n                               \\n                    else if(two_sum > rem) back--; // if(rem < two_sum) then logically move back pointer to back to minimise value to come closer to rem value \\n                    \\n                    else {           // if (rem == two_sum) then we got the quadruplet (i, j, front, back indexed values)\\n                        vector<int> quadruplet(4, 0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[3] = nums[back];\\n                        res.push_back(quadruplet);\\n                        \\n                        // processing the duplicates of number 3\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n                        \\n                        // processing the duplicates of number 4\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n                // processing the duplicates of number 2\\n                while(j + 1 < n && nums[j + 1] == nums[j]) ++j;\\n            }\\n             // processing the duplicates of number 1\\n                while(i + 1 < n && nums[i + 1] == nums[i]) ++i;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850376,
                "title": "c-simple-easy-to-understand-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // T.C --> O(n^3) because n^2 for loop inside loop and n for 2 pointer technique  \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        if(n<4) return ans;\\n        // Sort the vector\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-3;++i) {\\n            for(int j=i+1;j<n-2;++j) {\\n                int target2 = target - (nums[i] + nums[j]);\\n                // 2_Sum for j+1 to n-1 or 2_pointer technique\\n                int left = j+1;\\n                int right = n-1;\\n                while(left < right) {\\n                    int sum = nums[left] + nums[right];\\n                    if(sum > target2) --right;\\n                    else if(sum < target2) ++left;\\n                    else {\\n                        vector<int> sub({ nums[i], nums[j], nums[left], nums[right] });\\n                        ans.push_back(sub);\\n                        // to avoid duplicates\\n                        while(left < right && nums[left] == sub[2]) ++left;\\n                        while(left < right && nums[right] == sub[3]) --right;\\n                    }\\n                }\\n                // to avoid duplicates\\n                while(j+1 < n && nums[j] == nums[j+1]) ++j;\\n            }\\n            // to avoid duplicates\\n            while(i+1 < n && nums[i] == nums[i+1]) ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // T.C --> O(n^3) because n^2 for loop inside loop and n for 2 pointer technique  \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        if(n<4) return ans;\\n        // Sort the vector\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-3;++i) {\\n            for(int j=i+1;j<n-2;++j) {\\n                int target2 = target - (nums[i] + nums[j]);\\n                // 2_Sum for j+1 to n-1 or 2_pointer technique\\n                int left = j+1;\\n                int right = n-1;\\n                while(left < right) {\\n                    int sum = nums[left] + nums[right];\\n                    if(sum > target2) --right;\\n                    else if(sum < target2) ++left;\\n                    else {\\n                        vector<int> sub({ nums[i], nums[j], nums[left], nums[right] });\\n                        ans.push_back(sub);\\n                        // to avoid duplicates\\n                        while(left < right && nums[left] == sub[2]) ++left;\\n                        while(left < right && nums[right] == sub[3]) --right;\\n                    }\\n                }\\n                // to avoid duplicates\\n                while(j+1 < n && nums[j] == nums[j+1]) ++j;\\n            }\\n            // to avoid duplicates\\n            while(i+1 < n && nums[i] == nums[i+1]) ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577019,
                "title": "c-simple-o-n-2-solution-using-hashing-detailed-explanantion",
                "content": "```\\n/*\\n    https://leetcode.com/problems/4sum/\\n    \\n    Idea is to use a multi map to save the number pairs, if \\n    there exists a + b + c + d = target, then that means we will see 4 diff numbers.\\n    So we use two loops to pick a pair of numbers, initially when we had a and b, we look for target - (a+b)\\n    in the hash table, it might not be there, then push the current pair, so when we are at c and d and look\\n    for target - (c+d), that time we will get the (a,b) pair in the hash table. \\n    \\n    TC: O(N^2) + O(NlogN)\\n    SC: O(N)\\n*/\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& arr, int target) {\\n        vector<vector<int>> result;\\n        multimap<int, pair<int, int>> mp;\\n        set<vector<int>> s;\\n\\n        for(int i = 0; i < arr.size(); i++) {\\n            for(int j = i + 1; j < arr.size(); j++) {\\n                // a + b = target - (c + d)\\n                // check if target - (c + d) exists in hash table\\n                int sum = arr[i] + arr[j];\\n                auto res = mp.equal_range(target - sum);\\n\\n                for(auto it = res.first; it != res.second; it++) {\\n                    int a = it->second.first;\\n                    int b = it->second.second;\\n                    \\n                    // check if the numbers are diff index wise also\\n                    if(a != i && a != j && b != i && b != j) {\\n                        vector<int> quadruplet = \\n                            {arr[a], arr[b], arr[i], arr[j]};\\n\\n                        sort(begin(quadruplet), end(quadruplet));\\n                        if(s.find(quadruplet) == s.end()) {\\n                            s.emplace(quadruplet);\\n                            result.emplace_back(move(quadruplet));\\n                        }\\n                    }\\n                }\\n                // insert the current pair\\n                mp.emplace(make_pair(sum, make_pair(i, j)));\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/4sum/\\n    \\n    Idea is to use a multi map to save the number pairs, if \\n    there exists a + b + c + d = target, then that means we will see 4 diff numbers.\\n    So we use two loops to pick a pair of numbers, initially when we had a and b, we look for target - (a+b)\\n    in the hash table, it might not be there, then push the current pair, so when we are at c and d and look\\n    for target - (c+d), that time we will get the (a,b) pair in the hash table. \\n    \\n    TC: O(N^2) + O(NlogN)\\n    SC: O(N)\\n*/\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& arr, int target) {\\n        vector<vector<int>> result;\\n        multimap<int, pair<int, int>> mp;\\n        set<vector<int>> s;\\n\\n        for(int i = 0; i < arr.size(); i++) {\\n            for(int j = i + 1; j < arr.size(); j++) {\\n                // a + b = target - (c + d)\\n                // check if target - (c + d) exists in hash table\\n                int sum = arr[i] + arr[j];\\n                auto res = mp.equal_range(target - sum);\\n\\n                for(auto it = res.first; it != res.second; it++) {\\n                    int a = it->second.first;\\n                    int b = it->second.second;\\n                    \\n                    // check if the numbers are diff index wise also\\n                    if(a != i && a != j && b != i && b != j) {\\n                        vector<int> quadruplet = \\n                            {arr[a], arr[b], arr[i], arr[j]};\\n\\n                        sort(begin(quadruplet), end(quadruplet));\\n                        if(s.find(quadruplet) == s.end()) {\\n                            s.emplace(quadruplet);\\n                            result.emplace_back(move(quadruplet));\\n                        }\\n                    }\\n                }\\n                // insert the current pair\\n                mp.emplace(make_pair(sum, make_pair(i, j)));\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518661,
                "title": "ksum-java",
                "content": "My versions of kSum with list keep track of used elements\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<> ();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<> ();\\n        kSum(nums, target, 4, result, list, 0);\\n        return result;\\n    }\\n    private void kSum(int[] nums, int target, int k, List<List<Integer>> result, List<Integer> list, int index) {\\n        if (k == 2) {\\n            int start = index;\\n            int end = nums.length - 1;\\n            while (start < end) {\\n                if (nums[start] + nums[end] == target) {\\n                    list.add(nums[start]);\\n                    list.add(nums[end]);\\n                    result.add(new ArrayList<> (list));\\n                    list.remove(list.size() - 1);\\n                    list.remove(list.size() - 1);\\n                    while (start < end && nums[start] == nums[start + 1]) {\\n                        start++;\\n                    }\\n                    start++;\\n                    while (start < end && nums[end] == nums[end - 1]) {\\n                        end--;\\n                    }\\n                    end--;\\n                } else if (nums[start] + nums[end] > target) {\\n                    end--;\\n                } else {\\n                    start++;\\n                }\\n            }\\n            return;\\n        }\\n        for (int i = index; i < nums.length; i++) {\\n            if (i == index || nums[i] != nums[i - 1]) {\\n                list.add(nums[i]);\\n                kSum(nums, target - nums[i], k - 1, result, list, i + 1);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<> ();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<> ();\\n        kSum(nums, target, 4, result, list, 0);\\n        return result;\\n    }\\n    private void kSum(int[] nums, int target, int k, List<List<Integer>> result, List<Integer> list, int index) {\\n        if (k == 2) {\\n            int start = index;\\n            int end = nums.length - 1;\\n            while (start < end) {\\n                if (nums[start] + nums[end] == target) {\\n                    list.add(nums[start]);\\n                    list.add(nums[end]);\\n                    result.add(new ArrayList<> (list));\\n                    list.remove(list.size() - 1);\\n                    list.remove(list.size() - 1);\\n                    while (start < end && nums[start] == nums[start + 1]) {\\n                        start++;\\n                    }\\n                    start++;\\n                    while (start < end && nums[end] == nums[end - 1]) {\\n                        end--;\\n                    }\\n                    end--;\\n                } else if (nums[start] + nums[end] > target) {\\n                    end--;\\n                } else {\\n                    start++;\\n                }\\n            }\\n            return;\\n        }\\n        for (int i = index; i < nums.length; i++) {\\n            if (i == index || nums[i] != nums[i - 1]) {\\n                list.add(nums[i]);\\n                kSum(nums, target - nums[i], k - 1, result, list, i + 1);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395655,
                "title": "java-dp-nsum-solution-65-in-time-and-100-in-memory",
                "content": "```\\n/*\\n\\t65% in time and 100% in memory.\\n\\t\\n    This is actually a solution for N Sum.\\n\\n    DP solution: Sort the array first. Recursion down to the twoSum level and \\n\\tget all solutions for every specific threeSum (scanning array from left to right).\\n\\t\\n\\tFor example, if you want all answers for threeSum, you need to know all twoSum answers for each condition.\\n\\tLet\\'s assume [n1, n2, n3] is one answer for the threeSum problem. \\n\\tOne condition (starting condition) could be n1 = nums[0], \\n\\tthen [n2, n3] will only be picked from index 1 to length-1. \\n\\tThen the next condition is n1 = nums[1], then all [n2, n3] solutions are from index 2 to length-1.\\n\\t\\n    Once you sovle all threeSum problem, then recursion back to do the same thing for fourSum, etc...\\n     */\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        // We want the answer of N Sum\\n        int N = 4;\\n\\n        // Filter out all impossible inputs\\n        if (nums.length < N) return new ArrayList<>();\\n\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        nSum(nums, target, 0, ans, N);\\n        return ans;\\n    }\\n    private void nSum(int[] nums, int target, int leftIndex, List<List<Integer>> ans, int n) {\\n        if (n > 2) {\\n            for (int i = leftIndex; i < nums.length-n+1; i++) {\\n\\t\\t\\t\\t// A bit performance improvement.\\n                // Just skip the iteration if the integer is same as the previous array item.\\n                if (i > leftIndex && nums[i] == nums[i-1]) continue;\\n\\t\\t\\t\\t\\n                nSum(nums, target-nums[i], i+1, ans, n-1);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// For example, if we are calculating fourSum and the line above this line produces answers for threeSum (the recursion call), which\\n\\t\\t\\t\\t// means some (only part of. the other part of the ans is found fourSum solutions) of the answers in the variable \"ans\" contains threeSums\\n\\t\\t\\t\\t// solutions.  This line is just adding the integer to those threeSum answers to assemble fourSum answers.\\n                for (List<Integer> lst : ans) if (lst.size() == n-1) lst.add(nums[i]);\\n            }\\n        } else _easyTwoSum(nums, target, leftIndex, ans);\\n    }\\n    private void _easyTwoSum(int[] nums, int target, int l, List<List<Integer>> ans) {\\n        int r = nums.length-1;\\n        int ol = l, or = r;\\n\\t\\t\\n\\t\\t// Moving two markers from two ends inwards until they meet.\\n        while (l < r) {\\n            if (nums[l] + nums[r] == target) {\\n                ans.add(new ArrayList<>(Arrays.asList(nums[l], nums[r])));\\n                l++;\\n                r--;\\n            } else {\\n                if (nums[l] + nums[r] > target) r--;\\n                else l++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// A bit performance gain.\\n\\t\\t\\t// Skip the iterations that have duplicated values in the array.\\n            while (l > ol && nums[l] == nums[l-1] && l < r) l++;\\n            while (r < or && nums[r] == nums[r+1] && l < r) r--;\\n        }\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\t65% in time and 100% in memory.\\n\\t\\n    This is actually a solution for N Sum.\\n\\n    DP solution: Sort the array first. Recursion down to the twoSum level and \\n\\tget all solutions for every specific threeSum (scanning array from left to right).\\n\\t\\n\\tFor example, if you want all answers for threeSum, you need to know all twoSum answers for each condition.\\n\\tLet\\'s assume [n1, n2, n3] is one answer for the threeSum problem. \\n\\tOne condition (starting condition) could be n1 = nums[0], \\n\\tthen [n2, n3] will only be picked from index 1 to length-1. \\n\\tThen the next condition is n1 = nums[1], then all [n2, n3] solutions are from index 2 to length-1.\\n\\t\\n    Once you sovle all threeSum problem, then recursion back to do the same thing for fourSum, etc...\\n     */\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        // We want the answer of N Sum\\n        int N = 4;\\n\\n        // Filter out all impossible inputs\\n        if (nums.length < N) return new ArrayList<>();\\n\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        nSum(nums, target, 0, ans, N);\\n        return ans;\\n    }\\n    private void nSum(int[] nums, int target, int leftIndex, List<List<Integer>> ans, int n) {\\n        if (n > 2) {\\n            for (int i = leftIndex; i < nums.length-n+1; i++) {\\n\\t\\t\\t\\t// A bit performance improvement.\\n                // Just skip the iteration if the integer is same as the previous array item.\\n                if (i > leftIndex && nums[i] == nums[i-1]) continue;\\n\\t\\t\\t\\t\\n                nSum(nums, target-nums[i], i+1, ans, n-1);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// For example, if we are calculating fourSum and the line above this line produces answers for threeSum (the recursion call), which\\n\\t\\t\\t\\t// means some (only part of. the other part of the ans is found fourSum solutions) of the answers in the variable \"ans\" contains threeSums\\n\\t\\t\\t\\t// solutions.  This line is just adding the integer to those threeSum answers to assemble fourSum answers.\\n                for (List<Integer> lst : ans) if (lst.size() == n-1) lst.add(nums[i]);\\n            }\\n        } else _easyTwoSum(nums, target, leftIndex, ans);\\n    }\\n    private void _easyTwoSum(int[] nums, int target, int l, List<List<Integer>> ans) {\\n        int r = nums.length-1;\\n        int ol = l, or = r;\\n\\t\\t\\n\\t\\t// Moving two markers from two ends inwards until they meet.\\n        while (l < r) {\\n            if (nums[l] + nums[r] == target) {\\n                ans.add(new ArrayList<>(Arrays.asList(nums[l], nums[r])));\\n                l++;\\n                r--;\\n            } else {\\n                if (nums[l] + nums[r] > target) r--;\\n                else l++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// A bit performance gain.\\n\\t\\t\\t// Skip the iterations that have duplicated values in the array.\\n            while (l > ol && nums[l] == nums[l-1] && l < r) l++;\\n            while (r < or && nums[r] == nums[r+1] && l < r) r--;\\n        }\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 370622,
                "title": "a-general-way-to-solve-x-sum-xsum",
                "content": "**\\u4E00\\u79CD\\u89E3\\u51B3XSum\\u7C7B\\u4F3C\\u7684\\u9898\\uFF08\\u5176\\u4E2DX\\u4E3A\\u4EFB\\u610F\\u5927\\u4E8E2\\u7684\\u6B63\\u6574\\u6570\\uFF09\\u7684\\u901A\\u7528\\u89E3\\u6CD5\\uFF1A**\\n```\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        // \\u6392\\u5E8F\\n        Arrays.sort(nums);\\n\\n        List<Integer> numsList = new ArrayList<>();\\n        for (int num : nums) {\\n            numsList.add(num);\\n        }\\n\\n        return findX(numsList, 4, target);\\n    }\\n\\n    /**\\n     * \\u4ECEsource\\u4E2D\\u627E\\u51FAsize\\u4E2A\\u6570\\uFF0C\\u4F7F\\u4E4B\\u548C\\u4E3Asum\\uFF0C\\u5E76\\u8FD4\\u56DE\\u6240\\u6709\\u7684\\u5E8F\\u5217\\uFF08\\u4E0D\\u91CD\\u590D\\uFF09\\n     *\\n     * @param source \\u5E8F\\u5217\\n     * @param size   \\u4E2A\\u6570\\n     * @param sum    \\u603B\\u548C\\n     */\\n    public List<List<Integer>> findX(List<Integer> source, int size, int sum) {\\n        List<List<Integer>> list = new ArrayList<>();\\n\\n        // \\u7528\\u4E8C\\u5206\\u6CD5\\u627E\\u5230\\u6240\\u9700\\u8981\\u7684\\u503C\\n        if (size == 1) {\\n            int leftIndex = 0;\\n            int rightIndex = source.size() - 1;\\n            while (rightIndex - leftIndex > 1) {\\n                int middleIndex = (leftIndex + rightIndex) / 2;\\n\\n                if (sum < source.get(middleIndex)) {\\n                    rightIndex = middleIndex;\\n                } else if (sum > source.get(middleIndex)) {\\n                    leftIndex = middleIndex;\\n                } else {\\n                    List<Integer> ans = new ArrayList<>();\\n                    ans.add(sum);\\n                    list.add(ans);\\n                    break;\\n                }\\n            }\\n\\n            // rightIndex - leftIndex == 1 \\u7684\\u60C5\\u51B5\\n            if (list.size() == 0) {\\n                if (sum == source.get(leftIndex) || sum == source.get(rightIndex)) {\\n                    List<Integer> ans = new ArrayList<>();\\n                    ans.add(sum);\\n                    list.add(ans);\\n                }\\n            }\\n\\n            return list;\\n        }\\n\\n        for (int i = 0; i < source.size() - size + 1; i++) {\\n            // \\u529B\\u6C42\\u4E0D\\u91CD\\u590D\\n            if (i > 0 && source.get(i).equals(source.get(i - 1))) {\\n                continue;\\n            }\\n\\n            int thisNum = source.get(i);\\n\\n            // \\u83B7\\u53D6\\u5269\\u4F59\\u90E8\\u5206\\u7684\\u5E8F\\u5217\\n            List<List<Integer>> tempList = findX(source.subList(i + 1, source.size()), size - 1, sum - thisNum);\\n\\n            // \\u62FC\\u4E0A\\u7B2C\\u4E00\\u4E2A\\u6570\\n            for (List<Integer> temp : tempList) {\\n                temp.add(0, thisNum);\\n                list.add(temp);\\n            }\\n        }\\n\\n        return list;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        // \\u6392\\u5E8F\\n        Arrays.sort(nums);\\n\\n        List<Integer> numsList = new ArrayList<>();\\n        for (int num : nums) {\\n            numsList.add(num);\\n        }\\n\\n        return findX(numsList, 4, target);\\n    }\\n\\n    /**\\n     * \\u4ECEsource\\u4E2D\\u627E\\u51FAsize\\u4E2A\\u6570\\uFF0C\\u4F7F\\u4E4B\\u548C\\u4E3Asum\\uFF0C\\u5E76\\u8FD4\\u56DE\\u6240\\u6709\\u7684\\u5E8F\\u5217\\uFF08\\u4E0D\\u91CD\\u590D\\uFF09\\n     *\\n     * @param source \\u5E8F\\u5217\\n     * @param size   \\u4E2A\\u6570\\n     * @param sum    \\u603B\\u548C\\n     */\\n    public List<List<Integer>> findX(List<Integer> source, int size, int sum) {\\n        List<List<Integer>> list = new ArrayList<>();\\n\\n        // \\u7528\\u4E8C\\u5206\\u6CD5\\u627E\\u5230\\u6240\\u9700\\u8981\\u7684\\u503C\\n        if (size == 1) {\\n            int leftIndex = 0;\\n            int rightIndex = source.size() - 1;\\n            while (rightIndex - leftIndex > 1) {\\n                int middleIndex = (leftIndex + rightIndex) / 2;\\n\\n                if (sum < source.get(middleIndex)) {\\n                    rightIndex = middleIndex;\\n                } else if (sum > source.get(middleIndex)) {\\n                    leftIndex = middleIndex;\\n                } else {\\n                    List<Integer> ans = new ArrayList<>();\\n                    ans.add(sum);\\n                    list.add(ans);\\n                    break;\\n                }\\n            }\\n\\n            // rightIndex - leftIndex == 1 \\u7684\\u60C5\\u51B5\\n            if (list.size() == 0) {\\n                if (sum == source.get(leftIndex) || sum == source.get(rightIndex)) {\\n                    List<Integer> ans = new ArrayList<>();\\n                    ans.add(sum);\\n                    list.add(ans);\\n                }\\n            }\\n\\n            return list;\\n        }\\n\\n        for (int i = 0; i < source.size() - size + 1; i++) {\\n            // \\u529B\\u6C42\\u4E0D\\u91CD\\u590D\\n            if (i > 0 && source.get(i).equals(source.get(i - 1))) {\\n                continue;\\n            }\\n\\n            int thisNum = source.get(i);\\n\\n            // \\u83B7\\u53D6\\u5269\\u4F59\\u90E8\\u5206\\u7684\\u5E8F\\u5217\\n            List<List<Integer>> tempList = findX(source.subList(i + 1, source.size()), size - 1, sum - thisNum);\\n\\n            // \\u62FC\\u4E0A\\u7B2C\\u4E00\\u4E2A\\u6570\\n            for (List<Integer> temp : tempList) {\\n                temp.add(0, thisNum);\\n                list.add(temp);\\n            }\\n        }\\n\\n        return list;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313867,
                "title": "java-solution-runtime-3-ms-faster-than-100-00-memory-usage-36-7-mb-less-than-99-95",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (nums == null || nums.length < 4) return res;\\n        Arrays.sort(nums);\\n        if (nums[0] + nums[1] + nums[2] + nums[3] > target ||\\n            nums[nums.length-1] + nums[nums.length-2] + nums[nums.length-3] + nums[nums.length-4] < target)\\n            return res;\\n        int len_3 = nums.length - 3;\\n        int len_2 = nums.length - 2;\\n        int len_1 = nums.length - 1;\\n        int last_i = nums[0] - 1;\\n        for (int i = 0; i < len_3; i++) {\\n            if (nums[i] == last_i) continue;\\n            last_i = nums[i];\\n            int last_j = last_i - 1;\\n            for (int j = i + 1; j < len_2; j++) {\\n                if (nums[j] == last_j) continue;\\n                last_j = nums[j];\\n                int innerTarget = target - last_i - last_j;\\n                if (nums[j+1] + nums[j+2] > innerTarget || nums[nums.length-1] + nums[nums.length-2] < innerTarget) continue;\\n                int left = j + 1, right = len_1;\\n                while (left < right) {\\n                    int innerSum = nums[left] + nums[right];\\n                    if (innerSum == innerTarget) {\\n                        res.add(Arrays.asList(last_i, last_j, nums[left], nums[right]));\\n                        left++;\\n                        right--;\\n                        while (nums[left] == nums[left-1] && left < right) left++;\\n                        while (nums[right] == nums[right+1] && left < right) right--;\\n                    } else if (innerSum < innerTarget) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\nIn addition to the conventional algorithm, the key points are in the 6th line and the 21st line.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (nums == null || nums.length < 4) return res;\\n        Arrays.sort(nums);\\n        if (nums[0] + nums[1] + nums[2] + nums[3] > target ||\\n            nums[nums.length-1] + nums[nums.length-2] + nums[nums.length-3] + nums[nums.length-4] < target)\\n            return res;\\n        int len_3 = nums.length - 3;\\n        int len_2 = nums.length - 2;\\n        int len_1 = nums.length - 1;\\n        int last_i = nums[0] - 1;\\n        for (int i = 0; i < len_3; i++) {\\n            if (nums[i] == last_i) continue;\\n            last_i = nums[i];\\n            int last_j = last_i - 1;\\n            for (int j = i + 1; j < len_2; j++) {\\n                if (nums[j] == last_j) continue;\\n                last_j = nums[j];\\n                int innerTarget = target - last_i - last_j;\\n                if (nums[j+1] + nums[j+2] > innerTarget || nums[nums.length-1] + nums[nums.length-2] < innerTarget) continue;\\n                int left = j + 1, right = len_1;\\n                while (left < right) {\\n                    int innerSum = nums[left] + nums[right];\\n                    if (innerSum == innerTarget) {\\n                        res.add(Arrays.asList(last_i, last_j, nums[left], nums[right]));\\n                        left++;\\n                        right--;\\n                        while (nums[left] == nums[left-1] && left < right) left++;\\n                        while (nums[right] == nums[right+1] && left < right) right--;\\n                    } else if (innerSum < innerTarget) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308118,
                "title": "java-3ms-pruning-solution-which-beats-100-with-explanation",
                "content": "The basic idea is turning 4Sum into 3Sum. In order to improve efficiency, there are some tricks to jump out of current traversal:\\n1. duplicate removal\\n2. current num is too small\\n3. current num is too large\\n\\nThe details are shown is the following code with comment:\\n\\n```\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n    Arrays.sort(nums);\\n    List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n    for(int i = 0; i < nums.length - 3; i++) {\\n        if( i > 0 && nums[i] == nums[i - 1] ) // remove duplicate\\n            continue;\\n        if( nums[i] + 3 * nums[nums.length - 1] < target ) // current num is too small\\n            continue;\\n        if( nums[i] * 4 > target ) // current num is too large\\n            break;\\n        for(int j = i + 1; j < nums.length - 2; j++) {\\n            if( j > i + 1 && nums[j] == nums[j - 1] ) // duplicate removal\\n                continue;\\n            if( nums[i] + nums[j] + 2 * nums[nums.length - 1] < target ) // current num is too small\\n                continue;\\n            if( nums[i] + nums[j] * 3 > target ) // current num is too large\\n                break;\\n            int begin = j + 1, end = nums.length - 1;\\n            while( begin < end ) {\\n                int sum = nums[i] + nums[j] + nums[begin] + nums[end];\\n                if( sum > target ) \\n                    end--;\\n                else if( sum < target )\\n                    begin++;\\n                else if( sum == target ) {\\n                    if( begin == j + 1 || nums[begin] != nums[begin - 1] ) {\\n                        List<Integer> currentList = new ArrayList<Integer>();\\n                        currentList.add(nums[i]);\\n                        currentList.add(nums[j]);\\n                        currentList.add(nums[begin]);\\n                        currentList.add(nums[end]);\\n                        resultList.add(currentList);\\n                    }\\n                    begin++;\\n                    end--;\\n                }\\n            }\\n        }\\n    }\\n    return resultList;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n    Arrays.sort(nums);\\n    List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n    for(int i = 0; i < nums.length - 3; i++) {\\n        if( i > 0 && nums[i] == nums[i - 1] ) // remove duplicate\\n            continue;\\n        if( nums[i] + 3 * nums[nums.length - 1] < target ) // current num is too small\\n            continue;\\n        if( nums[i] * 4 > target ) // current num is too large\\n            break;\\n        for(int j = i + 1; j < nums.length - 2; j++) {\\n            if( j > i + 1 && nums[j] == nums[j - 1] ) // duplicate removal\\n                continue;\\n            if( nums[i] + nums[j] + 2 * nums[nums.length - 1] < target ) // current num is too small\\n                continue;\\n            if( nums[i] + nums[j] * 3 > target ) // current num is too large\\n                break;\\n            int begin = j + 1, end = nums.length - 1;\\n            while( begin < end ) {\\n                int sum = nums[i] + nums[j] + nums[begin] + nums[end];\\n                if( sum > target ) \\n                    end--;\\n                else if( sum < target )\\n                    begin++;\\n                else if( sum == target ) {\\n                    if( begin == j + 1 || nums[begin] != nums[begin - 1] ) {\\n                        List<Integer> currentList = new ArrayList<Integer>();\\n                        currentList.add(nums[i]);\\n                        currentList.add(nums[j]);\\n                        currentList.add(nums[begin]);\\n                        currentList.add(nums[end]);\\n                        resultList.add(currentList);\\n                    }\\n                    begin++;\\n                    end--;\\n                }\\n            }\\n        }\\n    }\\n    return resultList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8548,
                "title": "python-a-generalization-from-2sum-ad-3sum",
                "content": "```\\nclass Solution(object):\\n\\n    def fourSum(self,nums,target):\\n        solution2 = []\\n        solution3=[]\\n        solution = []\\n        nums.sort()\\n        for ai,a in enumerate(nums):\\n            if ai > 0 and a == nums[ai-1]:\\n                solution2 = self.two_some(nums[ai+1:],target-2*a,[a,a])\\n                if solution2:solution+=solution2\\n            else:\\n                solution3 = self.three_some(nums[ai+1:],target-a,[a])\\n                if solution3:solution+=solution3\\n        return solution\\n\\n    def three_some(self,nums,target,a):\\n        solution = []\\n        for idx,tgt in enumerate(nums):\\n            if idx>0 and nums[idx] == nums[idx-1]:continue\\n            path = {}\\n            vist = set()\\n            for i in xrange(idx+1,len(nums)):\\n                if nums[i] not in path:\\n                    path[target-tgt-nums[i]] = nums[i]\\n                elif nums[i] in path and nums[i] not in vist:\\n                    solution.append(a+[tgt,path[nums[i]],nums[i]])\\n                    vist.add(nums[i])\\n        return solution\\n\\n    def two_some(self,nums, target,b):\\n        path = {}\\n        solution = []\\n        for i in nums:\\n            if i in path:\\n                return solution.append(b+[path[i],i])\\n            else:\\n                path[target-i] = i\\n        return solution \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def fourSum(self,nums,target):\\n        solution2 = []\\n        solution3=[]\\n        solution = []\\n        nums.sort()\\n        for ai,a in enumerate(nums):\\n            if ai > 0 and a == nums[ai-1]:\\n                solution2 = self.two_some(nums[ai+1:],target-2*a,[a,a])\\n                if solution2:solution+=solution2\\n            else:\\n                solution3 = self.three_some(nums[ai+1:],target-a,[a])\\n                if solution3:solution+=solution3\\n        return solution\\n\\n    def three_some(self,nums,target,a):\\n        solution = []\\n        for idx,tgt in enumerate(nums):\\n            if idx>0 and nums[idx] == nums[idx-1]:continue\\n            path = {}\\n            vist = set()\\n            for i in xrange(idx+1,len(nums)):\\n                if nums[i] not in path:\\n                    path[target-tgt-nums[i]] = nums[i]\\n                elif nums[i] in path and nums[i] not in vist:\\n                    solution.append(a+[tgt,path[nums[i]],nums[i]])\\n                    vist.add(nums[i])\\n        return solution\\n\\n    def two_some(self,nums, target,b):\\n        path = {}\\n        solution = []\\n        for i in nums:\\n            if i in path:\\n                return solution.append(b+[path[i],i])\\n            else:\\n                path[target-i] = i\\n        return solution \\n```",
                "codeTag": "Java"
            },
            {
                "id": 8580,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& a, int target) {\\n        std::sort(a.begin(), a.end());\\n        set<vector<int>> set;\\n        for (int i = 0; i + 3 < a.size(); i++) {\\n            for (int j = i + 1; j + 2 < a.size(); j++) {\\n                for (int k = j + 1, l = a.size() - 1; k < l; ) {\\n                    int sum = a[i] + a[j] + a[k] + a[l];\\n                    if (sum == target) {\\n                        set.insert(vector<int>({ a[i], a[j], a[k], a[l] }));\\n                        k++;\\n                        l--;\\n                    }\\n                    else if (sum < target) {\\n                        k++;\\n                    }\\n                    else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> res;\\n        for (auto group : set) {\\n            res.push_back(group);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& a, int target) {\\n        std::sort(a.begin(), a.end());\\n        set<vector<int>> set;\\n        for (int i = 0; i + 3 < a.size(); i++) {\\n            for (int j = i + 1; j + 2 < a.size(); j++) {\\n                for (int k = j + 1, l = a.size() - 1; k < l; ) {\\n                    int sum = a[i] + a[j] + a[k] + a[l];\\n                    if (sum == target) {\\n                        set.insert(vector<int>({ a[i], a[j], a[k], a[l] }));\\n                        k++;\\n                        l--;\\n                    }\\n                    else if (sum < target) {\\n                        k++;\\n                    }\\n                    else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> res;\\n        for (auto group : set) {\\n            res.push_back(group);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8584,
                "title": "short-javascript-using-several-maps",
                "content": "```\\nvar fourSum = function(nums, target) {\\n    const counts = new Map();  // counts of elements in `nums`\\n    const aPlusB = new Map();  // sum tuples e.g. 5 => [[2, 3], [1, 4], ... ]\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        counts.set(nums[i], (counts.get(nums[i]) || 0) + 1);\\n        for (let j = i + 1; j < nums.length; j++) {\\n            let a = nums[i], b = nums[j];\\n            aPlusB.set(a + b, [...aPlusB.get(a + b) || [], [a, b]]);\\n        }\\n    }\\n    counts.set(nums[nums.length - 1], (counts.get(nums[nums.length - 1]) || 0) + 1);\\n    const res = new Set();  // Sets are unique, so no worries about duplicates\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        for (let j = i + 1; j < nums.length; j++) {\\n            let c = nums[i], d = nums[j];\\n            if (!aPlusB.has(target - c - d)) continue;  // move on if wrong sum\\n            aPlusB.get(target - c - d)\\n                .forEach(ab => {\\n                    const abcd = [...ab, c, d];\\n                    if (!abcd.some(e => abcd.reduce((qty, a) => qty + (a === e), 0) > counts.get(e))) {\\n                        res.add(abcd.sort().join(','));\\n                    }\\n                });\\n        }\\n    }\\n    return [...res].map(abcd => abcd.split(',').map(e => parseInt(e)));\\n};\\n```\\nThis isn't particularly fast but gets the job done.\\n\\n1. Remember the `[a, b]` pairs keyed by their sum.\\n2. Find the `[c, d]` tuple which satisfies a + b + c + d = target.\\n3. If `nums` can supply the 4-tuple, add `[a, b, c, d]` to the unique set of results keyed by their sorted value.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fourSum = function(nums, target) {\\n    const counts = new Map();  // counts of elements in `nums`\\n    const aPlusB = new Map();  // sum tuples e.g. 5 => [[2, 3], [1, 4], ... ]\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        counts.set(nums[i], (counts.get(nums[i]) || 0) + 1);\\n        for (let j = i + 1; j < nums.length; j++) {\\n            let a = nums[i], b = nums[j];\\n            aPlusB.set(a + b, [...aPlusB.get(a + b) || [], [a, b]]);\\n        }\\n    }\\n    counts.set(nums[nums.length - 1], (counts.get(nums[nums.length - 1]) || 0) + 1);\\n    const res = new Set();  // Sets are unique, so no worries about duplicates\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        for (let j = i + 1; j < nums.length; j++) {\\n            let c = nums[i], d = nums[j];\\n            if (!aPlusB.has(target - c - d)) continue;  // move on if wrong sum\\n            aPlusB.get(target - c - d)\\n                .forEach(ab => {\\n                    const abcd = [...ab, c, d];\\n                    if (!abcd.some(e => abcd.reduce((qty, a) => qty + (a === e), 0) > counts.get(e))) {\\n                        res.add(abcd.sort().join(','));\\n                    }\\n                });\\n        }\\n    }\\n    return [...res].map(abcd => abcd.split(',').map(e => parseInt(e)));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8616,
                "title": "simple-java-solution-for-4-sum-3-sum-2-sum-any-sum",
                "content": "Any improvement is welcome.\\nUpdated: recursive stop at twoSum. Time Complexity of kSum is max( O(n^(k-1)), O(nlogn)).\\n```\\npublic class Solution {\\n    private List<List<Integer>> nSum(int[] nums, int start, int n, int target){\\n        List<List<Integer>> result = new LinkedList<>();\\n        // target is too small or too large so that there won't be solutions.\\n        if (target < nums[start]*n || target > nums[nums.length - 1]*n){\\n            return result;\\n        }\\n        \\n        for (int i = start, end = nums.length - n + 1; i < end; ++i){\\n            // avoid duplicated solutions\\n            if (i > start && nums[i - 1] == nums[i]){\\n                continue;\\n            }\\n\\n            if (n == 2){\\n                int required = target - nums[i];\\n                \\n                while(nums[end] > required){\\n                    end--;\\n                }\\n                if (nums[end] < required){\\n                    continue;\\n                }\\n                if (i >= end){\\n                    break;\\n                }\\n                \\n                // duplicated solution\\n                if (end + 1 < nums.length && nums[end+1] == nums[end]){\\n                    continue;\\n                }\\n                \\n                // get two sum\\n                result.add(new LinkedList<Integer>(Arrays.asList(nums[i], nums[end])));\\n                continue;\\n            }\\n            \\n            for (List<Integer> list : nSum(nums, i + 1, n - 1, target - nums[i])){\\n                list.add(nums[i]);\\n                result.add(list);\\n            }\\n            \\n        }\\n        return result;\\n    }\\n    \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if (nums.length == 0){\\n            return Arrays.asList();\\n        }\\n        Arrays.sort(nums);\\n        return nSum(nums, 0, 4, target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private List<List<Integer>> nSum(int[] nums, int start, int n, int target){\\n        List<List<Integer>> result = new LinkedList<>();\\n        // target is too small or too large so that there won't be solutions.\\n        if (target < nums[start]*n || target > nums[nums.length - 1]*n){\\n            return result;\\n        }\\n        \\n        for (int i = start, end = nums.length - n + 1; i < end; ++i){\\n            // avoid duplicated solutions\\n            if (i > start && nums[i - 1] == nums[i]){\\n                continue;\\n            }\\n\\n            if (n == 2){\\n                int required = target - nums[i];\\n                \\n                while(nums[end] > required){\\n                    end--;\\n                }\\n                if (nums[end] < required){\\n                    continue;\\n                }\\n                if (i >= end){\\n                    break;\\n                }\\n                \\n                // duplicated solution\\n                if (end + 1 < nums.length && nums[end+1] == nums[end]){\\n                    continue;\\n                }\\n                \\n                // get two sum\\n                result.add(new LinkedList<Integer>(Arrays.asList(nums[i], nums[end])));\\n                continue;\\n            }\\n            \\n            for (List<Integer> list : nSum(nums, i + 1, n - 1, target - nums[i])){\\n                list.add(nums[i]);\\n                result.add(list);\\n            }\\n            \\n        }\\n        return result;\\n    }\\n    \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if (nums.length == 0){\\n            return Arrays.asList();\\n        }\\n        Arrays.sort(nums);\\n        return nSum(nums, 0, 4, target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8692,
                "title": "python-beats-86-07-may-be-better",
                "content": "    class Solution(object):\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result=[]\\n        length=len(nums)\\n        nums.sort()\\n        for i in range(0,length-3):\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            if nums[i]*4>target:\\n                break\\n            for j in range(length-1,i+2,-1):\\n                if j!=length-1 and nums[j]==nums[j+1]:\\n                    continue\\n                if nums[j]*4<target:\\n                    break\\n                sub2=target-nums[i]-nums[j]\\n                low,high=i+1,j-1\\n                while low<high:\\n                    sum2=nums[low]+nums[high]\\n                    if sum2>sub2:\\n                        high-=1\\n                    elif sum2<sub2:\\n                        low+=1\\n                    else:\\n                        ans = [nums[i],nums[low],nums[high],nums[j]]\\n                        ans.sort()\\n                        result.append(ans)\\n                        while low<high and nums[low+1]==nums[low]:\\n                            low+=1\\n                        while low<high and nums[high-1]==nums[high]:\\n                            high-=1\\n                        high,low=high-1,low+1\\n        return result\\n                    \\nmake sure `nums[i]!=nums[i+1]` to avoid duplication and unnecessary computations<br>\\nand when`nums[i]*4 > target`,It'll be impossible to get another answer.<br>\\nand when `nums[j]*4 < target`,It should turn to next loop\\nmaybe in some situations:use`nums[i]+nums[i+1]+nums[i+2]+nums[i+3]`wil be better.I am just for convenience..",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result=[]\\n        length=len(nums)\\n        nums.sort()\\n        for i in range(0,length-3):\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            if nums[i]*4>target:\\n                break\\n            for j in range(length-1,i+2,-1):\\n                if j!=length-1 and nums[j]==nums[j+1]:\\n                    continue\\n                if nums[j]*4<target:\\n                    break\\n                sub2=target-nums[i]-nums[j]\\n                low,high=i+1,j-1\\n                while low<high:\\n                    sum2=nums[low]+nums[high]\\n                    if sum2>sub2:\\n                        high-=1\\n                    elif sum2<sub2:\\n                        low+=1\\n                    else:\\n                        ans = [nums[i],nums[low],nums[high],nums[j]]\\n                        ans.sort()\\n                        result.append(ans)\\n                        while low<high and nums[low+1]==nums[low]:\\n                            low+=1\\n                        while low<high and nums[high-1]==nums[high]:\\n                            high-=1\\n                        high,low=high-1,low+1\\n        return result\\n                    \\nmake sure `nums[i]!=nums[i+1]` to avoid duplication and unnecessary computations<br>\\nand when`nums[i]*4 > target`,It'll be impossible to get another answer.<br>\\nand when `nums[j]*4 < target`,It should turn to next loop\\nmaybe in some situations:use`nums[i]+nums[i+1]+nums[i+2]+nums[i+3]`wil be better.I am just for convenience..",
                "codeTag": "Java"
            },
            {
                "id": 8700,
                "title": "easy-to-understand-java-solution-using-nsum",
                "content": "    public class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            return nSum(nums, 4, 0, target);\\n        }\\n        \\n        public List<List<Integer>> nSum(int[] nums, int n, int idx, int target) {\\n            if (n == 2) return twoSum(nums, idx, target);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            for (int i = idx; i <= nums.length - n; i++) {\\n                List<List<Integer>> temp = nSum(nums, n - 1, i + 1, target - nums[i]);\\n                for (List<Integer> l : temp) {\\n                    l.add(0, nums[i]);\\n                }\\n                result.addAll(temp);\\n                int t = nums[i];\\n                while (i <= nums.length - n && nums[i] == t) {\\n                    i++;\\n                }\\n                i--;\\n            }\\n            return result;\\n        }\\n        \\n        public List<List<Integer>> twoSum(int[] nums, int idx, int target) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            int ptr1 = idx, ptr2 = nums.length - 1;\\n            while (ptr1 < ptr2) {\\n                if (nums[ptr1] + nums[ptr2] == target) {\\n                    List<Integer> temp = new ArrayList<Integer>();\\n                    temp.add(nums[ptr1]);\\n                    temp.add(nums[ptr2]);\\n                    result.add(temp);\\n                    int t = nums[ptr1];\\n                    while (ptr1 < ptr2 && nums[ptr1] == t) {\\n                        ptr1++;\\n                    }\\n                } else if (nums[ptr1] + nums[ptr2] < target) {\\n                    ptr1++;\\n                } else {\\n                    ptr2--;\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            return nSum(nums, 4, 0, target);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 8690,
                "title": "share-my-c-code-8ms-beats-100",
                "content": "add some condition to break or continue the loop by checking the maxinum and mininum.\\n\\n\\tint comp(const void* p, const void* q){ \\n\\t    return (*(int*) p - *(int*) q); \\n\\t}\\n\\n\\tint** fourSum(int* nums, int numsSize, int target, int* returnSize) {\\n\\t    if(nums ==NULL)\\treturn 0;\\n\\t    if(numsSize <4) return 0;\\n\\t    int **Ans = (int**)malloc(200*sizeof(int*));\\n\\t  \\tqsort(nums,numsSize,sizeof(int),comp);\\n\\t  \\tint a,b,c,d,count=0;;\\n\\t  \\tfor(a=0; a < numsSize-3;a++){\\n\\t  \\t\\t// check [a,x,x,x] mininum\\n\\t  \\t\\tif(nums[a]+nums[a+1]+nums[a+2]+nums[a+3]>target)\\t\\n\\t  \\t\\t\\tbreak;\\n\\t  \\t\\t// check [a,x,x,x] maxinum\\n\\t  \\t\\tif(nums[a]+nums[numsSize-3]+nums[numsSize-2]+nums[numsSize-1]<target)\\n\\t  \\t\\t\\tcontinue;\\n\\t  \\t\\tfor(b=a+1;b<numsSize-2;b++){\\n\\t  \\t\\t\\t// check [a,b,x,x] mininu\\n\\t  \\t\\t\\tif(nums[a]+nums[b]+nums[b+1]+nums[b+2]>target)\\n\\t  \\t\\t\\t\\tbreak;  \\t\\n\\t  \\t\\t\\t// check [a,b,x,x] maxinum\\t\\t\\t\\n\\t  \\t\\t\\tif(nums[a]+nums[b]+nums[numsSize-2]+nums[numsSize-1]<target)\\n\\t  \\t\\t\\t\\tcontinue;\\n\\t  \\t\\t\\tfor(c=b+1,d = (numsSize-1);c<d;){\\n\\t  \\t\\t\\t\\tif(nums[a]+nums[b]+nums[c]+nums[d]>target){\\n\\t  \\t\\t\\t\\t\\td--;\\n\\t  \\t\\t\\t\\t}\\n\\t  \\t\\t\\t\\telse if(nums[a]+nums[b]+nums[c]+nums[d]<target){\\n\\t  \\t\\t\\t\\t\\tc++;\\n\\t  \\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tAns[count] = (int*)malloc(4*sizeof(int));\\n\\t\\t\\t\\t\\t\\tAns[count][0]=nums[a];\\n\\t\\t\\t\\t\\t\\tAns[count][1]=nums[b];\\n\\t\\t\\t\\t\\t\\tAns[count][2]=nums[c];\\n\\t\\t\\t\\t\\t\\tAns[count][3]=nums[d];\\n\\t\\t\\t\\t\\t\\twhile(c<d && Ans[count][2]==nums[c]) c++;\\t\\n\\t\\t\\t\\t\\t\\twhile(c<d && Ans[count][3]==nums[d]) d--;\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tif(count % 200 == 0)\\n\\t\\t\\t\\t\\t\\t    Ans = (int**)realloc(Ans,sizeof(int*)*(count+200));\\n\\t  \\t\\t\\t\\t}\\n\\t  \\t\\t\\t}\\n\\t  \\t\\t\\twhile(b<numsSize-1 && nums[b+1] == nums[b]) b++;\\t\\n\\t  \\t\\t}\\n\\t  \\t\\twhile(a<numsSize-1 && nums[a+1] == nums[a]) a++;\\t\\t\\n\\t  \\t}\\n\\t  \\t*returnSize = count;\\n\\t  \\treturn (int**)realloc(Ans,sizeof(int*)*count);\\n\\t}",
                "solutionTags": [],
                "code": "add some condition to break or continue the loop by checking the maxinum and mininum.\\n\\n\\tint comp(const void* p, const void* q){ \\n\\t    return (*(int*) p - *(int*) q); \\n\\t}\\n\\n\\tint** fourSum(int* nums, int numsSize, int target, int* returnSize) {\\n\\t    if(nums ==NULL)\\treturn 0;\\n\\t    if(numsSize <4) return 0;\\n\\t    int **Ans = (int**)malloc(200*sizeof(int*));\\n\\t  \\tqsort(nums,numsSize,sizeof(int),comp);\\n\\t  \\tint a,b,c,d,count=0;;\\n\\t  \\tfor(a=0; a < numsSize-3;a++){\\n\\t  \\t\\t// check [a,x,x,x] mininum\\n\\t  \\t\\tif(nums[a]+nums[a+1]+nums[a+2]+nums[a+3]>target)\\t\\n\\t  \\t\\t\\tbreak;\\n\\t  \\t\\t// check [a,x,x,x] maxinum\\n\\t  \\t\\tif(nums[a]+nums[numsSize-3]+nums[numsSize-2]+nums[numsSize-1]<target)\\n\\t  \\t\\t\\tcontinue;\\n\\t  \\t\\tfor(b=a+1;b<numsSize-2;b++){\\n\\t  \\t\\t\\t// check [a,b,x,x] mininu\\n\\t  \\t\\t\\tif(nums[a]+nums[b]+nums[b+1]+nums[b+2]>target)\\n\\t  \\t\\t\\t\\tbreak;  \\t\\n\\t  \\t\\t\\t// check [a,b,x,x] maxinum\\t\\t\\t\\n\\t  \\t\\t\\tif(nums[a]+nums[b]+nums[numsSize-2]+nums[numsSize-1]<target)\\n\\t  \\t\\t\\t\\tcontinue;\\n\\t  \\t\\t\\tfor(c=b+1,d = (numsSize-1);c<d;){\\n\\t  \\t\\t\\t\\tif(nums[a]+nums[b]+nums[c]+nums[d]>target){\\n\\t  \\t\\t\\t\\t\\td--;\\n\\t  \\t\\t\\t\\t}\\n\\t  \\t\\t\\t\\telse if(nums[a]+nums[b]+nums[c]+nums[d]<target){\\n\\t  \\t\\t\\t\\t\\tc++;\\n\\t  \\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tAns[count] = (int*)malloc(4*sizeof(int));\\n\\t\\t\\t\\t\\t\\tAns[count][0]=nums[a];\\n\\t\\t\\t\\t\\t\\tAns[count][1]=nums[b];\\n\\t\\t\\t\\t\\t\\tAns[count][2]=nums[c];\\n\\t\\t\\t\\t\\t\\tAns[count][3]=nums[d];\\n\\t\\t\\t\\t\\t\\twhile(c<d && Ans[count][2]==nums[c]) c++;\\t\\n\\t\\t\\t\\t\\t\\twhile(c<d && Ans[count][3]==nums[d]) d--;\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tif(count % 200 == 0)\\n\\t\\t\\t\\t\\t\\t    Ans = (int**)realloc(Ans,sizeof(int*)*(count+200));\\n\\t  \\t\\t\\t\\t}\\n\\t  \\t\\t\\t}\\n\\t  \\t\\t\\twhile(b<numsSize-1 && nums[b+1] == nums[b]) b++;\\t\\n\\t  \\t\\t}\\n\\t  \\t\\twhile(a<numsSize-1 && nums[a+1] == nums[a]) a++;\\t\\t\\n\\t  \\t}\\n\\t  \\t*returnSize = count;\\n\\t  \\treturn (int**)realloc(Ans,sizeof(int*)*count);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 8738,
                "title": "my-concise-c-solution-based-on-3sum",
                "content": "     vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size()<=3) return vector<vector<int>>();\\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-3;i++){\\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            for(int j=i+1;j<nums.size()-2;j++){\\n                if(j>i+1 && nums[j]==nums[j-1]) continue;\\n                int k=j+1;\\n                int l=nums.size()-1;\\n                while(k<l){\\n                    if(k>j+1 && nums[k]==nums[k-1]){ k++; continue;}\\n                    if(l<nums.size()-1 && nums[l]==nums[l+1]){ l--; continue;}\\n                    int val=nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(val==target){\\n                        res.push_back(vector<int>{nums[i],nums[j],nums[k],nums[l]});\\n                        k++;\\n                        l--;\\n                    }\\n                    else if(val<target)\\n                        k++;\\n                    else\\n                        l--;\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size()<=3) return vector<vector<int>>();\\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-3;i++){\\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            for(int j=i+1;j<nums.size()-2;j++){\\n                if(j>i+1 && nums[j]==nums[j-1]) continue;\\n                int k=j+1;\\n                int l=nums.size()-1;\\n                while(k<l){\\n                    if(k>j+1 && nums[k]==nums[k-1]){ k++; continue;}\\n                    if(l<nums.size()-1 && nums[l]==nums[l+1]){ l--; continue;}\\n                    int val=nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(val==target){\\n                        res.push_back(vector<int>{nums[i],nums[j],nums[k],nums[l]});\\n                        k++;\\n                        l--;\\n                    }\\n                    else if(val<target)\\n                        k++;\\n                    else\\n                        l--;\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 8601,
                "title": "share-my-ac-o-n2-python-solution",
                "content": "1: Create the sum for each pair, like this: [sum,list_of_pairs]\\n\\n2; sort the pairs by key.\\n\\n3: find the match condition pairs, and filter them out.\\n\\n\\n\\n    def fourSum(self, num, target):\\n        num=sorted(num);\\n        sum2={}\\n        for i in range(len(num)):\\n            for j in range(i+1,len(num)):\\n                sumij=num[i]+num[j];\\n                if(sumij not in sum2):\\n                    sum2[sumij]=[];\\n                sum2[sumij].append((i,j));\\n        sum2 = sorted(sum2.items(), key=lambda x:x[0])\\n        \\n        res=set();\\n        i,j=0,len(sum2)-1;\\n        while(i<=j):\\n            total=sum2[i][0]+sum2[j][0];\\n            if(total==target):\\n                for k1 in range(len(sum2[i][1])):\\n                    for k2 in range(len(sum2[j][1])):\\n                        a,b=sum2[i][1][k1];\\n                        c,d=sum2[j][1][k2];\\n                        items= set([a,b,c,d]);\\n                        if(len(items)==4):\\n                            newItem=[num[fi] for fi in items];\\n                            newItem=tuple(sorted(newItem));\\n                            res.add((newItem));\\n                i+=1;\\n                j-=1;\\n            elif(total<target):\\n                i+=1;\\n            else:\\n                j-=1;\\n\\n        resNums= [];\\n        for item in res:\\n            resNums.append([i for i in item]);\\n        return resNums;",
                "solutionTags": [
                    "Python"
                ],
                "code": "1: Create the sum for each pair, like this: [sum,list_of_pairs]\\n\\n2; sort the pairs by key.\\n\\n3: find the match condition pairs, and filter them out.\\n\\n\\n\\n    def fourSum(self, num, target):\\n        num=sorted(num);\\n        sum2={}\\n        for i in range(len(num)):\\n            for j in range(i+1,len(num)):\\n                sumij=num[i]+num[j];\\n                if(sumij not in sum2):\\n                    sum2[sumij]=[];\\n                sum2[sumij].append((i,j));\\n        sum2 = sorted(sum2.items(), key=lambda x:x[0])\\n        \\n        res=set();\\n        i,j=0,len(sum2)-1;\\n        while(i<=j):\\n            total=sum2[i][0]+sum2[j][0];\\n            if(total==target):\\n                for k1 in range(len(sum2[i][1])):\\n                    for k2 in range(len(sum2[j][1])):\\n                        a,b=sum2[i][1][k1];\\n                        c,d=sum2[j][1][k2];\\n                        items= set([a,b,c,d]);\\n                        if(len(items)==4):\\n                            newItem=[num[fi] for fi in items];\\n                            newItem=tuple(sorted(newItem));\\n                            res.add((newItem));\\n                i+=1;\\n                j-=1;\\n            elif(total<target):\\n                i+=1;\\n            else:\\n                j-=1;\\n\\n        resNums= [];\\n        for item in res:\\n            resNums.append([i for i in item]);\\n        return resNums;",
                "codeTag": "Python3"
            },
            {
                "id": 3716167,
                "title": "4sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        s = set()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                l = j+1\\n                r = len(nums)-1\\n                while l<r:\\n                    if nums[i] + nums[j] + nums[l] + nums[r]<target:\\n                        l+=1\\n                    elif nums[i] + nums[j] + nums[l] + nums[r]>target:\\n                        r-=1\\n                    elif nums[i] + nums[j] + nums[l] + nums[r]==target:\\n                        s.add((nums[i],nums[j],nums[l],nums[r]))\\n                        l+=1\\n                        r-=1\\n        return list(s)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        s = set()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                l = j+1\\n                r = len(nums)-1\\n                while l<r:\\n                    if nums[i] + nums[j] + nums[l] + nums[r]<target:\\n                        l+=1\\n                    elif nums[i] + nums[j] + nums[l] + nums[r]>target:\\n                        r-=1\\n                    elif nums[i] + nums[j] + nums[l] + nums[r]==target:\\n                        s.add((nums[i],nums[j],nums[l],nums[r]))\\n                        l+=1\\n                        r-=1\\n        return list(s)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661494,
                "title": "c-2-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i>0 && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            for(int j=i+1;j<n;j++){\\n                if(j>i+1 && nums[j]==nums[j-1]){\\n                    continue;\\n                }\\n                int k = j+1;\\n                int l = n-1;\\n                while(k<l){\\n                    long long sum = nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n                    if(sum==target){\\n                        vector<int>res = {nums[i],nums[j],nums[k],nums[l]};\\n                        ans.push_back(res);\\n                        k++;\\n                        l--;\\n                        while(k<l && nums[k]==nums[k-1]){\\n                            k++;\\n                        }while(k<l && nums[l]==nums[l+1]){\\n                            l--;\\n                        }\\n                    }else if(sum<target){\\n                        k++;\\n                    }else{\\n                        l--;\\n                    }\\n                }\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i>0 && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            for(int j=i+1;j<n;j++){\\n                if(j>i+1 && nums[j]==nums[j-1]){\\n                    continue;\\n                }\\n                int k = j+1;\\n                int l = n-1;\\n                while(k<l){\\n                    long long sum = nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n                    if(sum==target){\\n                        vector<int>res = {nums[i],nums[j],nums[k],nums[l]};\\n                        ans.push_back(res);\\n                        k++;\\n                        l--;\\n                        while(k<l && nums[k]==nums[k-1]){\\n                            k++;\\n                        }while(k<l && nums[l]==nums[l+1]){\\n                            l--;\\n                        }\\n                    }else if(sum<target){\\n                        k++;\\n                    }else{\\n                        l--;\\n                    }\\n                }\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633185,
                "title": "o-n-n-n-c-solution-without-map-set-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        for(int i=0; i<n; i++){\\n            if(i && nums[i] == nums[i-1]) continue;\\n            for(int j=i+1; j<n; j++){\\n                if(j>i+1 && nums[j] == nums[j-1]) continue;\\n                int k = j+1, l = n-1;\\n                while(k<l){\\n                    long long sum = (long long)nums[i] + nums[j] + nums[k] + nums[l];\\n                    if(sum == target) ans.push_back({nums[i], nums[j], nums[k], nums[l]});\\n                    if(sum <= target){\\n                        int temp = nums[k];\\n                        while(k < n && nums[k] == temp) k++;\\n                    }\\n                    else{\\n                        int temp = nums[l];\\n                        while(l>=0 && nums[l] == temp) l--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        for(int i=0; i<n; i++){\\n            if(i && nums[i] == nums[i-1]) continue;\\n            for(int j=i+1; j<n; j++){\\n                if(j>i+1 && nums[j] == nums[j-1]) continue;\\n                int k = j+1, l = n-1;\\n                while(k<l){\\n                    long long sum = (long long)nums[i] + nums[j] + nums[k] + nums[l];\\n                    if(sum == target) ans.push_back({nums[i], nums[j], nums[k], nums[l]});\\n                    if(sum <= target){\\n                        int temp = nums[k];\\n                        while(k < n && nums[k] == temp) k++;\\n                    }\\n                    else{\\n                        int temp = nums[l];\\n                        while(l>=0 && nums[l] == temp) l--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615198,
                "title": "o-n-3-c-solution-easy-to-understand-3-approaches",
                "content": "### BRUTE FORCE :\\n\\nRun 4 loops to traverse each element and if it equals sum store into ans. One thing to take care of is that it should not contain duplicates so for this purpose we make use of set but in a set we also need to keep the elements in a specific order to check for duplicates for ex 1 2 3 4 and 3 1 2 4 are both same quads but will be treated distinct by set thus we sort these quads and then store in a set to remove duplicates.\\n\\nAt last we create our ans vector and copy all the elements of the set.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       set<vector<int>> s;\\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=i+1;j<n;j++)\\n           {\\n               for(int k=j+1;k<n;k++)\\n               {\\n                   for(int l=k+1;l<n;l++)\\n                   {\\n                       long long sum=nums[i]+nums[j];\\n                       sum+=nums[k];\\n                       sum+=nums[l];\\n                       if(sum==target)\\n                       {\\n                           vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                           sort(temp.begin(),temp.end());\\n                           s.insert(temp);\\n                       }\\n                   }\\n               }\\n           }\\n       } \\n       vector<vector<int>> ans(s.begin(),s.end());\\n       return ans;\\n    }\\n};\\n```\\n\\n- Time Complexity : O(N^4)\\n- Space Complexity : O(2 * no. of the quadruplets) as we are using a set data structure and a list to store the quads.\\n\\n### Better Approach :\\n\\nWe will use 3loops now instead of 4 and use a hashset to find the fourth element. We need to find all unique combination so we need the elem at i,j,k but to find 4th element we check in the hashset whether the elem is present or not if it is not present then we add nums[k] into the ahshset and then move k in this fashion numbers between j and k will be stored in hashset uniquely and we can find a combination that gives the target without requiring 4th loop here j and k works as window start and end to find a variable.\\n\\nbefore k loop hashset must be defined because as j moves a new window will be formed.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       set<vector<int>> s;\\n       \\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=i+1;j<n;j++)\\n           {\\n               set<long long> hash;\\n               for(int k=j+1;k<n;k++)\\n               {\\n                   \\n                       long long sum=nums[i]+nums[j];\\n                       sum+=nums[k];\\n                       long long remains=target-sum;\\n                       if(hash.find(remains)!=hash.end())\\n                       {\\n                           vector<int> temp={nums[i],nums[j],nums[k],(int)remains};\\n                           sort(temp.begin(),temp.end());\\n                           s.insert(temp);\\n                       }\\n                       hash.insert(nums[k]);\\n                   \\n               }\\n           }\\n       } \\n       vector<vector<int>> ans(s.begin(),s.end());\\n       return ans;\\n    }\\n};\\n```\\n\\n- Time Complexity : O(N^3 log (M)) M is unique elements stored in hashset.\\n- Space Complexity : O(2 * no. of the quadruplets)+O(N)\\n\\n**Reason:**\\n\\nwe are using a set data structure and a list to store the quads. This results in the first term. And the second space is taken by the set data structure we are using to store the array elements. At most, the set can contain approximately all the array elements and so the space complexity is O(N).\\n\\n### Optimal Approach :\\n\\nWe now use two pointer approach initially we sort the array and keep i and j positions as fixed then we use two pointer to keep track of sum if sum is equal then we include it in ans and if it is less we move k pointer and if it is greater we shift l pointer to left. To deal with duplicate values we will make a comparison inside each loop whenever i>0 this means i is not at 0h position we need to check whether the previous elem that i was pointing to is the same element value that i is currently pointing to if yes then we continue the loop until i find a new value same goes for j but j>i+1 now for k and l when we have found sum==target then we need to shift both k and l k++ and l\\u2014 but what if they both again point to the same element value as previous for this we need to add a while loop for k and l as well to continue incrementing and decrementing value of k and l respectively until a new value is found also k<l should always be satisfied during these iterations.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       sort(nums.begin(),nums.end());\\n       vector<vector<int>> ans;\\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           if(i>0 && nums[i]==nums[i-1]) continue;\\n           for(int j=i+1;j<n;j++)\\n           {\\n               if(j>i+1 && nums[j]==nums[j-1]) continue;\\n               int k=j+1;\\n               int l=n-1;\\n               while(k<l)\\n               {\\n                   long long sum=nums[i]+nums[j];\\n                   sum+=nums[k];\\n                   sum+=nums[l];\\n                   if(sum==target)\\n                   {\\n                       vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                       ans.push_back(temp);\\n                       k++;l--;\\n                       while(k<l && nums[k]==nums[k-1]) k++;\\n                       while(k<l && nums[l]==nums[l+1]) l--;\\n                   }\\n                   else if(sum<target)\\n                        k++;\\n                   else\\n                        l--;\\n               }\\n               \\n           }\\n       } \\n       return ans;\\n    }\\n};\\n```\\n- Time Complexity : O(N^3) + O(NlogN)\\n\\nEach of the pointers i and j, is running for approximately N times. And both the pointers k and l combined can run for approximately N times including the operation of skipping duplicates. So the total time complexity will be O(N3). NlogN is for sorting the array.\\n\\n- Space Complexity : O(no. of quadruplets),\\xA0***This space is only used to store the answer. We are not using any extra space to solve this problem.***\\xA0So, from that perspective, space complexity can be written as O(1).\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       set<vector<int>> s;\\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=i+1;j<n;j++)\\n           {\\n               for(int k=j+1;k<n;k++)\\n               {\\n                   for(int l=k+1;l<n;l++)\\n                   {\\n                       long long sum=nums[i]+nums[j];\\n                       sum+=nums[k];\\n                       sum+=nums[l];\\n                       if(sum==target)\\n                       {\\n                           vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                           sort(temp.begin(),temp.end());\\n                           s.insert(temp);\\n                       }\\n                   }\\n               }\\n           }\\n       } \\n       vector<vector<int>> ans(s.begin(),s.end());\\n       return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       set<vector<int>> s;\\n       \\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=i+1;j<n;j++)\\n           {\\n               set<long long> hash;\\n               for(int k=j+1;k<n;k++)\\n               {\\n                   \\n                       long long sum=nums[i]+nums[j];\\n                       sum+=nums[k];\\n                       long long remains=target-sum;\\n                       if(hash.find(remains)!=hash.end())\\n                       {\\n                           vector<int> temp={nums[i],nums[j],nums[k],(int)remains};\\n                           sort(temp.begin(),temp.end());\\n                           s.insert(temp);\\n                       }\\n                       hash.insert(nums[k]);\\n                   \\n               }\\n           }\\n       } \\n       vector<vector<int>> ans(s.begin(),s.end());\\n       return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       sort(nums.begin(),nums.end());\\n       vector<vector<int>> ans;\\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           if(i>0 && nums[i]==nums[i-1]) continue;\\n           for(int j=i+1;j<n;j++)\\n           {\\n               if(j>i+1 && nums[j]==nums[j-1]) continue;\\n               int k=j+1;\\n               int l=n-1;\\n               while(k<l)\\n               {\\n                   long long sum=nums[i]+nums[j];\\n                   sum+=nums[k];\\n                   sum+=nums[l];\\n                   if(sum==target)\\n                   {\\n                       vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                       ans.push_back(temp);\\n                       k++;l--;\\n                       while(k<l && nums[k]==nums[k-1]) k++;\\n                       while(k<l && nums[l]==nums[l+1]) l--;\\n                   }\\n                   else if(sum<target)\\n                        k++;\\n                   else\\n                        l--;\\n               }\\n               \\n           }\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444947,
                "title": "solving-the-4sum-problem-on-leetcode-a-step-by-step-guide",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to fix two indices i and j in the input array and use two pointers left and right to find all possible pairs of elements nums[k] and nums[l] such that nums[i] + nums[j] + nums[k] + nums[l] = target.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter handling the base case we move to main solution part.\\n\\nTo do this, we\\'ll first sort the input array in ascending order. This allows us to easily eliminate duplicates and move the pointers left and right based on the sum of the four elements.\\n\\nWe\\'ll loop over all possible pairs of i and j, then use the two pointers left and right to find all possible pairs of k and l that add up to the target. We\\'ll increment left if the sum of the four elements is less than the target, and decrement right if the sum is greater than the target.\\n\\nIf the sum of the four elements is equal to the target, we add the quadruplet [nums[i], nums[j], nums[k], nums[l]] to a set to eliminate duplicates.\\n\\nOnce we\\'ve looped over all possible quadruplets, we\\'ll convert the set to a list and return it. That\\'s it! We done with this problem\\n**\\n***if u are confused y i used loops till n-3 and n-2 so, here is explaination for that too:*****\\n\\nwe use n-3 and n-2 as the upper bounds because we need at least 4 elements to form a valid quadruplet.\\n\\nBy starting the first loop at 0 and going up to n-3, we ensure that we have at least 3 elements after the current index to form a quadruplet.\\n\\nSimilarly, by starting the second loop at i+1 and going up to n-2, we ensure that we have at least 2 elements after the current index to form a quadruplet with the current element.\\n\\nIf we used <n as the upper bound in these loops, we would be considering all possible combinations of 4 or more elements in the input array, including those that don\\'t form a valid quadruplet. This would lead to unnecessary computation and longer running time.\\n\\nTherefore, using n-3 and n-2 as the upper bounds is a more efficient way to iterate over all possible quadruplets in the input array.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(n^3), since we use nested loops to iterate over all possible quadruplets. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n), since we use a set to store unique quadruplets.\\n\\n\\n****Hope this helps! Let me know if you have any questions.**\\n**\\n\\n********DO UPVOTE!** **\\n**Peace Out:)******\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n           set<vector<int>> s;\\n        vector<vector<int>> ans;\\n        \\n        if (nums.size()<4) {\\n            return ans;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        for (int i=0; i<n-3; i++) {\\n            for (int j=i+1; j<n-2; j++) {\\n                int low = j+1;\\n                int high = n-1;\\n                \\n                while (low<high) {\\n                  long long sum = (long long)nums[i] + nums[j] + nums[low] + nums[high];                    \\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[low], nums[high]});\\n                        low++;\\n                        high--;\\n                    }\\n                    else if (sum<target) {\\n                        low++;\\n                    }\\n                    else {\\n                        high--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (auto x : s) {\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n           set<vector<int>> s;\\n        vector<vector<int>> ans;\\n        \\n        if (nums.size()<4) {\\n            return ans;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        for (int i=0; i<n-3; i++) {\\n            for (int j=i+1; j<n-2; j++) {\\n                int low = j+1;\\n                int high = n-1;\\n                \\n                while (low<high) {\\n                  long long sum = (long long)nums[i] + nums[j] + nums[low] + nums[high];                    \\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[low], nums[high]});\\n                        low++;\\n                        high--;\\n                    }\\n                    else if (sum<target) {\\n                        low++;\\n                    }\\n                    else {\\n                        high--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (auto x : s) {\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569729,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1564576,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1643461,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1576905,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1569477,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1565074,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1569530,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1570712,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1565936,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1576376,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1569729,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1564576,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1643461,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1576905,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1569477,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1565074,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1569530,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1570712,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1565936,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1576376,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1568214,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1871117,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1576606,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 2014354,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1568836,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1996655,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1978288,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1576834,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1576650,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1575179,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1571047,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 1568837,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 1576306,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 1571883,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2070353,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2069020,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2061755,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2060509,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2045743,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2045583,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2043272,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 2041575,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 2032562,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 2017943,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1991619,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1983044,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1973054,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1971678,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1971642,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1968387,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1966221,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1963190,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1959734,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1957460,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1951675,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1947853,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1938894,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1938526,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1932441,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1930318,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1913615,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1908688,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1901515,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1897797,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1875014,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1874752,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1874583,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1853364,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1853054,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1850059,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1849938,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1842157,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1836635,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1835733,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1830666,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1820115,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1813309,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1809982,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1807714,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1805487,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1792521,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1791814,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1787331,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1787220,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1784650,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1778937,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1772280,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1764835,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1762313,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1758542,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1752589,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1746855,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1741836,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1740291,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1731417,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1725638,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1725607,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1725249,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1722548,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1722469,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1717743,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1713969,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1713123,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1711533,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1700158,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1671266,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1665683,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1656318,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1648664,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1641554,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            }
        ]
    }
]