[
    {
        "title": "Minimum Operations to Make Array Equal II",
        "question_content": "You are given two integer arrays nums1 and nums2 of equal length n and an integer k. You can perform the following operation on nums1:\n\n\tChoose two indexes i and j and increment nums1[i] by k and decrement nums1[j] by k. In other words, nums1[i] = nums1[i] + k and nums1[j] = nums1[j] - k.\n\nnums1 is said to be equal to nums2 if for all indices i such that 0 <= i < n, nums1[i] == nums2[i].\nReturn the minimum number of operations required to make nums1 equal to nums2. If it is impossible to make them equal, return -1.\n&nbsp;\nExample 1:\n\nInput: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3\nOutput: 2\nExplanation: In 2 operations, we can transform nums1 to nums2.\n1st operation: i = 2, j = 0. After applying the operation, nums1 = [1,3,4,4].\n2nd operation: i = 2, j = 3. After applying the operation, nums1 = [1,3,7,1].\nOne can prove that it is impossible to make arrays equal in fewer operations.\nExample 2:\n\nInput: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1\nOutput: -1\nExplanation: It can be proved that it is impossible to make the two arrays equal.\n\n&nbsp;\nConstraints:\n\n\tn == nums1.length == nums2.length\n\t2 <= n <= 105\n\t0 <= nums1[i], nums2[j] <= 109\n\t0 <= k <= 105",
        "solutions": [
            {
                "id": 3082031,
                "title": "c-plus-minus-count-intuitive-efficient-approach",
                "content": "# Intuition\\nFor making nums1 as nums2, we are adding k at any index and substracting k from another index and continue this process until they both are equal (According to the question).\\n\\nWhen the element of nums1 is greater than nums2 we need to decrese it and if it is lesser we need to increase it by using k.\\n\\nSo to keep track of it, I used p_diff and n_diff and at last there difference must be 0 which insures it can be possible to make nums1 as nums2 by using p_diff/k or n_diff/k steps.\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        if(k==0) //if k is 0 then we can do nothing\\n        {\\n            //if nums1 and nums2 are equal operations will be 0 \\n            //otherwise it is impossible to make them equal\\n            if(nums1==nums2) return 0; \\n            return -1;\\n        }\\n        \\n        //p_diff stores positive difference between nums1[i] and nums2[i] \\n        //n_diff stores negative difference between nums1[i] and nums2[i] \\n        long long p_diff=0, n_diff=0; \\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            if(nums1[i] >= nums2[i])\\n            {\\n                //we need to check whether we can make them equal by using k\\n                if((nums1[i]-nums2[i])%k==0) \\n                    p_diff += nums1[i]-nums2[i];\\n                else\\n                    return -1;\\n            } \\n            else \\n            {\\n                //we need to check whether we can make them equal by using k\\n                if((nums2[i]-nums1[i])%k==0)\\n                    n_diff += nums2[i]-nums1[i];\\n                else\\n                    return -1;\\n            }\\n        }\\n        \\n        long long ans=-1;\\n        //if both difference(p_diff,n_diff) are equal, we can make nums1 equals to nums2\\n        if(p_diff-n_diff==0) ans = (p_diff/k);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n# Please upvote if it helps...\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        if(k==0) //if k is 0 then we can do nothing\\n        {\\n            //if nums1 and nums2 are equal operations will be 0 \\n            //otherwise it is impossible to make them equal\\n            if(nums1==nums2) return 0; \\n            return -1;\\n        }\\n        \\n        //p_diff stores positive difference between nums1[i] and nums2[i] \\n        //n_diff stores negative difference between nums1[i] and nums2[i] \\n        long long p_diff=0, n_diff=0; \\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            if(nums1[i] >= nums2[i])\\n            {\\n                //we need to check whether we can make them equal by using k\\n                if((nums1[i]-nums2[i])%k==0) \\n                    p_diff += nums1[i]-nums2[i];\\n                else\\n                    return -1;\\n            } \\n            else \\n            {\\n                //we need to check whether we can make them equal by using k\\n                if((nums2[i]-nums1[i])%k==0)\\n                    n_diff += nums2[i]-nums1[i];\\n                else\\n                    return -1;\\n            }\\n        }\\n        \\n        long long ans=-1;\\n        //if both difference(p_diff,n_diff) are equal, we can make nums1 equals to nums2\\n        if(p_diff-n_diff==0) ans = (p_diff/k);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082129,
                "title": "very-simple-and-easy-to-understand-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long up = 0, down = 0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(nums1[i] == nums2[i]) continue;\\n            int t = abs(nums1[i] - nums2[i]);\\n            if(k == 0) return -1;\\n            else if( t % k == 0){\\n                if(nums1[i] > nums2[i]) down += t/k;\\n                else up += t/k;\\n            }\\n            else return -1;\\n        }\\n        return (up==down)?up: -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long up = 0, down = 0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(nums1[i] == nums2[i]) continue;\\n            int t = abs(nums1[i] - nums2[i]);\\n            if(k == 0) return -1;\\n            else if( t % k == 0){\\n                if(nums1[i] > nums2[i]) down += t/k;\\n                else up += t/k;\\n            }\\n            else return -1;\\n        }\\n        return (up==down)?up: -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082021,
                "title": "java-python-3-modulos-and-balance-check-w-brief-explanation-and-analysis",
                "content": "\\n1. Traverse `nums1` and `nums2` and check if each of the corresponding difference is divisible by `k`;  If not, impossible to make the two arrays equal; \\n2. If yes, accumulate the difference to `bal`, which will be `0` after traversal if it is possible to make the two arrays equal;\\n3. Accumulate the times of the positive difference of `k`, and return it if `bal == 0`.\\n\\n```java\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            return Arrays.equals(nums1, nums2) ? 0 : -1;\\n        }\\n        long ops = 0, bal = 0;\\n        for (int i = 0; i < nums1.length; ++i) {\\n            int diff = nums1[i] - nums2[i];\\n            if (diff % k != 0) {\\n                return -1;\\n            }\\n            if (diff > 0) {\\n                ops += diff / k;\\n            }\\n            bal += diff;\\n        } \\n        return bal == 0 ? ops : -1;        \\n    }\\n```\\n```python\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if k == 0:\\n            return 0 if nums1 == nums2 else -1\\n        ops = bal = 0\\n        for a, b in zip(nums1, nums2):\\n            if (a - b) % k != 0:\\n                return -1\\n            bal += a - b\\n            if a > b:\\n                ops += (a - b) // k\\n        return ops if bal == 0 else -1       \\n```\\n\\n**Analysis**\\n\\nTime: `O(n)`, space: `O(1)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            return Arrays.equals(nums1, nums2) ? 0 : -1;\\n        }\\n        long ops = 0, bal = 0;\\n        for (int i = 0; i < nums1.length; ++i) {\\n            int diff = nums1[i] - nums2[i];\\n            if (diff % k != 0) {\\n                return -1;\\n            }\\n            if (diff > 0) {\\n                ops += diff / k;\\n            }\\n            bal += diff;\\n        } \\n        return bal == 0 ? ops : -1;        \\n    }\\n```\n```python\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if k == 0:\\n            return 0 if nums1 == nums2 else -1\\n        ops = bal = 0\\n        for a, b in zip(nums1, nums2):\\n            if (a - b) % k != 0:\\n                return -1\\n            bal += a - b\\n            if a > b:\\n                ops += (a - b) // k\\n        return ops if bal == 0 else -1       \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3082588,
                "title": "greedy",
                "content": "If `n1[i] < n2[i]`, we need to increase it using `n2[i] - n1[i]) / k` operations. Otherwise, we need to decrease it.\\n\\nWe sum the number of `inc` and `dec` operations. \\n\\nIf the number of both operations is the same, we can make the array equal using `inc` operations.\\n\\n**C++**\\n```cpp\\nlong long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n    long long inc = 0, dec = 0;\\n    for (int i = 0; i < n1.size(); ++i)\\n        if (n1[i] != n2[i]) {\\n            if (k == 0 || abs(n1[i] - n2[i]) % k != 0)\\n                return -1;\\n            inc += max(0, (n2[i] - n1[i]) / k);\\n            dec += max(0, (n1[i] - n2[i]) / k);\\n        }\\n    return inc != dec ? -1 : inc;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n    long long inc = 0, dec = 0;\\n    for (int i = 0; i < n1.size(); ++i)\\n        if (n1[i] != n2[i]) {\\n            if (k == 0 || abs(n1[i] - n2[i]) % k != 0)\\n                return -1;\\n            inc += max(0, (n2[i] - n1[i]) / k);\\n            dec += max(0, (n1[i] - n2[i]) / k);\\n        }\\n    return inc != dec ? -1 : inc;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082043,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        \\n    int n = nums1.length;\\n    long[] diff = new long[n];\\n    for (int i = 0; i < n; i++) {\\n        diff[i] = nums2[i] - nums1[i];\\n    }\\n    if(k==0){\\n        for(int i=0;i<n;i++)\\n            if(diff[i]!=0)return -1;\\n        return 0;\\n    }\\n    long ans = 0;\\n    long sum=0;\\n    for (int i = 0; i < n; i++) {\\n        sum+=diff[i];\\n        if (diff[i] % k != 0) {\\n            return -1;\\n        }\\n        ans += Math.abs(diff[i] / k);\\n    }\\n\\n    return sum==0? ans/2:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        \\n    int n = nums1.length;\\n    long[] diff = new long[n];\\n    for (int i = 0; i < n; i++) {\\n        diff[i] = nums2[i] - nums1[i];\\n    }\\n    if(k==0){\\n        for(int i=0;i<n;i++)\\n            if(diff[i]!=0)return -1;\\n        return 0;\\n    }\\n    long ans = 0;\\n    long sum=0;\\n    for (int i = 0; i < n; i++) {\\n        sum+=diff[i];\\n        if (diff[i] % k != 0) {\\n            return -1;\\n        }\\n        ans += Math.abs(diff[i] / k);\\n    }\\n\\n    return sum==0? ans/2:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082387,
                "title": "c-easy-detailed-explanation-o-n-o-1",
                "content": "# Approach\\n- If `k = 0`, check if `nums1 = nums2` return `0` otherwise `-1`.\\n- I have initialized 3 variables `sum`, `diff` and `posCount` each store totalSum of operations, current difference between `i`th element and required positive operations respectively.\\n- In each iteration I\\'ve calculated `diff` then checked if `diff % k != 0` return -1, because this difference can not be covered with multiple of `k`.\\n- If `diff > 0` then add `diff` to `posCount` to store required positive operations.\\n- After the loop if `sum != 0` then return `-1`, because that left part of sum will never be filled after any number of operations.\\n- In last return `posCount`, operation for positive counts will automatically cover negative as well.\\n\\n# Complexity\\n- Time complexity: O(n), single iteration of loop\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1), few variables have been used means constant space utilization.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#### Go through this code once you\\'ll understand everything\\uD83D\\uDC47 \\n###### Please comment down below if have any doubt.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        if(k==0){\\n            if(nums1 == nums2)\\n                return 0;\\n            return -1;\\n        }\\n        \\n        int n = nums1.size();\\n        long long diff, sum = 0, posCount = 0;\\n        \\n        for(int i=0;i<n;i++){\\n\\n            diff = nums2[i]-nums1[i];\\n            if(diff % k != 0)\\n                return -1;\\n\\n            diff = diff / k;\\n            sum += diff;\\n\\n            if(diff > 0)\\n                posCount += diff;\\n\\n        }\\n        \\n        if(sum != 0)\\n            return -1;\\n        \\n        return posCount;\\n        \\n    }\\n};\\n```\\n# Please upvote, if you find this helpful\\uD83D\\uDE4F \\n#### Thank you in advance :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        if(k==0){\\n            if(nums1 == nums2)\\n                return 0;\\n            return -1;\\n        }\\n        \\n        int n = nums1.size();\\n        long long diff, sum = 0, posCount = 0;\\n        \\n        for(int i=0;i<n;i++){\\n\\n            diff = nums2[i]-nums1[i];\\n            if(diff % k != 0)\\n                return -1;\\n\\n            diff = diff / k;\\n            sum += diff;\\n\\n            if(diff > 0)\\n                posCount += diff;\\n\\n        }\\n        \\n        if(sum != 0)\\n            return -1;\\n        \\n        return posCount;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082223,
                "title": "python3-very-easy-solution",
                "content": "- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        s=0\\n        c=0\\n        if k==0:\\n            if nums1==nums2:\\n                return 0\\n            return -1\\n        for i in range(len(nums1)):\\n            if abs(nums1[i]-nums2[i])%k!=0:\\n                return -1\\n            if nums1[i]>nums2[i]:\\n                c+=abs(nums1[i]-nums2[i])\\n            else:\\n                s+=abs(nums1[i]-nums2[i])\\n        if s!=c:\\n            return -1\\n        return s//k\\n            \\n        \\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        s=0\\n        c=0\\n        if k==0:\\n            if nums1==nums2:\\n                return 0\\n            return -1\\n        for i in range(len(nums1)):\\n            if abs(nums1[i]-nums2[i])%k!=0:\\n                return -1\\n            if nums1[i]>nums2[i]:\\n                c+=abs(nums1[i]-nums2[i])\\n            else:\\n                s+=abs(nums1[i]-nums2[i])\\n        if s!=c:\\n            return -1\\n        return s//k\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082060,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long up = 0, down = 0;\\n        for(int i = 0; i < nums1.length; i++){\\n            if(nums1[i] == nums2[i]) continue;\\n            int abs = Math.abs(nums1[i] - nums2[i]);\\n            if(k == 0) return -1;\\n            else if( abs % k == 0){\\n                if(nums1[i] > nums2[i]) down += abs/k;\\n                else up += abs/k;\\n            }\\n            else return -1;\\n        }\\n        return (up==down)?up: -1;\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long up = 0, down = 0;\\n        for(int i = 0; i < nums1.length; i++){\\n            if(nums1[i] == nums2[i]) continue;\\n            int abs = Math.abs(nums1[i] - nums2[i]);\\n            if(k == 0) return -1;\\n            else if( abs % k == 0){\\n                if(nums1[i] > nums2[i]) down += abs/k;\\n                else up += abs/k;\\n            }\\n            else return -1;\\n        }\\n        return (up==down)?up: -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083088,
                "title": "python-3-9-lines-w-explanation-t-m-697-ms-31-mb",
                "content": "Some considerations:\\n- If `k==0`, the answer is either`-1`or`0`, depending whether `nums1 != nums2`.\\n- For each `i`,`nums1[i]-num2[i] == quo * k`where`quo` is the number of moves on `nums1[i], num2[i]`, so it follows that`(nums1[i]-num2[i])%k == 0`for each `i`if the arrays can be made equal.\\n- A solution exists if and only if the sum of all `quo` is zero, because  each move does not change the value of `sum(nums1)+sum(nums2)`.\\n- The value of `sum(abs(quo))`for of all `quo`increases by two for each move, which is equivalent to saying that the number of moves should be `sum(abs(ni))//2`.\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n\\n        if not k: return -(nums1 != nums2)\\n\\n        sm = smAbs = 0\\n\\n        for i in range(len(nums1)):\\n\\n            diff = nums1[i]-nums2[i] \\n\\n            if diff%k: return -1\\n            quo = diff//k\\n\\n            sm   += quo\\n            smAbs+= abs(quo)\\n\\n        return -1 if sm else smAbs//2\\n```\\n[https://leetcode.com/problems/minimum-operations-to-make-array-equal-ii/submissions/882632843/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n\\n        if not k: return -(nums1 != nums2)\\n\\n        sm = smAbs = 0\\n\\n        for i in range(len(nums1)):\\n\\n            diff = nums1[i]-nums2[i] \\n\\n            if diff%k: return -1\\n            quo = diff//k\\n\\n            sm   += quo\\n            smAbs+= abs(quo)\\n\\n        return -1 if sm else smAbs//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082467,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        \\n        \\n        long add = 0;\\n        long sub = 0;\\n        for(int i = 0; i < nums1.length; i++){\\n            int diff = nums1[i] - nums2[i];\\n            if(k != 0){\\n                if(diff % k != 0){\\n                    return -1;\\n                }\\n                if(diff > 0){\\n                    add = add + diff/k;\\n\\n                }else if(diff < 0){\\n                    sub = sub + (-diff)/k;\\n                }\\n            }else{\\n                if(diff != 0){\\n                    return -1;\\n                }\\n            }\\n            \\n        }\\n        return add == sub ? add : -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        \\n        \\n        long add = 0;\\n        long sub = 0;\\n        for(int i = 0; i < nums1.length; i++){\\n            int diff = nums1[i] - nums2[i];\\n            if(k != 0){\\n                if(diff % k != 0){\\n                    return -1;\\n                }\\n                if(diff > 0){\\n                    add = add + diff/k;\\n\\n                }else if(diff < 0){\\n                    sub = sub + (-diff)/k;\\n                }\\n            }else{\\n                if(diff != 0){\\n                    return -1;\\n                }\\n            }\\n            \\n        }\\n        return add == sub ? add : -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082109,
                "title": "java-straightforward",
                "content": "One operation is either adding k or removing k to a number.\\nWe compute the differences first. If one of them is not a multiple of k, it\\'s impossible.\\nThe number of operations that add k must be the same as the number of operations that remove k.\\n\\n```\\nclass Solution {\\n\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        long posOps = 0;\\n        long negOps = 0;\\n        if(k == 0) return Arrays.equals(nums1, nums2) ? 0 : -1; // avoid division by 0\\n        for (int i = 0; i < n; i++) {\\n            int diff = nums1[i] - nums2[i];\\n            if (diff % k != 0) return -1;\\n            int op = diff/k;\\n            if(op > 0) posOps += op;\\n            else negOps -= op;\\n        }\\n\\n        if(posOps != negOps) return -1;\\n        return posOps;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        long posOps = 0;\\n        long negOps = 0;\\n        if(k == 0) return Arrays.equals(nums1, nums2) ? 0 : -1; // avoid division by 0\\n        for (int i = 0; i < n; i++) {\\n            int diff = nums1[i] - nums2[i];\\n            if (diff % k != 0) return -1;\\n            int op = diff/k;\\n            if(op > 0) posOps += op;\\n            else negOps -= op;\\n        }\\n\\n        if(posOps != negOps) return -1;\\n        return posOps;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082025,
                "title": "c-plus-minus",
                "content": "\\n**<<<<<<UpVote**\\n\\n\\n**Just find the Difference  Array  (Nums1- Nums2) and if Sum of positive is Equal to sum of Negative then we  can have possible answer**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0) {\\n            if(nums1==nums2) return 0;\\n            else return -1;\\n        }\\n        int n=nums1.size();\\n        vector<int> diff(n,0);\\n        for(int i=0;i<n;i++){\\n            diff[i]=nums1[i]-nums2[i];\\n        }\\n        long long plus=0,minus=0;\\n        for(auto num: diff) {\\n            if(num<0) minus+=num;\\n            if(num>0) plus+=num;\\n        }\\n        if(plus==abs(minus)) {\\n            if(plus%k==0) {\\n                return plus/k;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0) {\\n            if(nums1==nums2) return 0;\\n            else return -1;\\n        }\\n        int n=nums1.size();\\n        vector<int> diff(n,0);\\n        for(int i=0;i<n;i++){\\n            diff[i]=nums1[i]-nums2[i];\\n        }\\n        long long plus=0,minus=0;\\n        for(auto num: diff) {\\n            if(num<0) minus+=num;\\n            if(num>0) plus+=num;\\n        }\\n        if(plus==abs(minus)) {\\n            if(plus%k==0) {\\n                return plus/k;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084238,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        unordered_map<long long, long long> mp;\\n        int n=nums1.size();\\n        if(k==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums1[i]!=nums2[i])\\n                    return -1;\\n            }\\n            return 0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            long long d=nums1[i]-nums2[i];\\n            if(d==0)\\n                continue;\\n            if(abs(d)%k)\\n                return -1;\\n            mp[d]++;\\n        }\\n        long long a=0, b=0, ans=0;\\n        for(auto it:mp)\\n        {\\n            long long d=it.first;\\n            if(d>0)\\n            {\\n                a+=((d/k) * it.second);\\n            }\\n            else if(d<0)\\n            {\\n                b+=((abs(d)/k) * it.second);\\n            }\\n        }\\n        if(a==b)\\n            return a;\\n        return -1;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        unordered_map<long long, long long> mp;\\n        int n=nums1.size();\\n        if(k==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums1[i]!=nums2[i])\\n                    return -1;\\n            }\\n            return 0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            long long d=nums1[i]-nums2[i];\\n            if(d==0)\\n                continue;\\n            if(abs(d)%k)\\n                return -1;\\n            mp[d]++;\\n        }\\n        long long a=0, b=0, ans=0;\\n        for(auto it:mp)\\n        {\\n            long long d=it.first;\\n            if(d>0)\\n            {\\n                a+=((d/k) * it.second);\\n            }\\n            else if(d<0)\\n            {\\n                b+=((abs(d)/k) * it.second);\\n            }\\n        }\\n        if(a==b)\\n            return a;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082038,
                "title": "c-very-easy-o-n",
                "content": "\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& a, vector<int>& b, int k) {\\n        int n = a.size();\\n        \\n        bool isOk = true;\\n        for(int i = 0; i < n; i++) \\n            if(a[i] != b[i]) isOk = false;\\n        \\n        if(isOk) return 0;\\n        \\n        if(k == 0) return -1;\\n        \\n        long long inc = 0, dec = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(a[i] == b[i]) continue;\\n            \\n            if(a[i] > b[i]) {\\n                if((a[i] - b[i]) % k != 0) return -1;\\n                dec += (a[i] - b[i]) / k;\\n            }else {\\n                if((b[i] - a[i]) % k != 0) return -1;\\n                inc += (b[i] - a[i]) / k;\\n            }\\n        }\\n        if(inc != dec) return -1;\\n        return inc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& a, vector<int>& b, int k) {\\n        int n = a.size();\\n        \\n        bool isOk = true;\\n        for(int i = 0; i < n; i++) \\n            if(a[i] != b[i]) isOk = false;\\n        \\n        if(isOk) return 0;\\n        \\n        if(k == 0) return -1;\\n        \\n        long long inc = 0, dec = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(a[i] == b[i]) continue;\\n            \\n            if(a[i] > b[i]) {\\n                if((a[i] - b[i]) % k != 0) return -1;\\n                dec += (a[i] - b[i]) / k;\\n            }else {\\n                if((b[i] - a[i]) % k != 0) return -1;\\n                inc += (b[i] - a[i]) / k;\\n            }\\n        }\\n        if(inc != dec) return -1;\\n        return inc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832771,
                "title": "100-beats-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            for(int i = 0; i < nums1.size(); i++){\\n                if(nums1[i] != nums2[i])return -1;\\n            }\\n            return 0;\\n        }\\n        long long int a = 0,b=0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(nums1[i]==nums2[i])continue;\\n            else if(nums1[i]>nums2[i]){\\n                if((nums1[i]-nums2[i])%k){\\n                    return -1;\\n                }else{\\n                    a += (nums1[i]-nums2[i])/k;\\n                }\\n            }else{\\n                if((-nums1[i]+nums2[i])%k){\\n                    return -1;\\n                }else{\\n                    b += (-nums1[i]+nums2[i])/k;\\n                }\\n            }\\n        }\\n        if(a==b)return a;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            for(int i = 0; i < nums1.size(); i++){\\n                if(nums1[i] != nums2[i])return -1;\\n            }\\n            return 0;\\n        }\\n        long long int a = 0,b=0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(nums1[i]==nums2[i])continue;\\n            else if(nums1[i]>nums2[i]){\\n                if((nums1[i]-nums2[i])%k){\\n                    return -1;\\n                }else{\\n                    a += (nums1[i]-nums2[i])/k;\\n                }\\n            }else{\\n                if((-nums1[i]+nums2[i])%k){\\n                    return -1;\\n                }else{\\n                    b += (-nums1[i]+nums2[i])/k;\\n                }\\n            }\\n        }\\n        if(a==b)return a;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083481,
                "title": "c-solution-simple-and-easy-explanation-o-n-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we have to make nums1 equal to nums2 by increamenting or decreamenting the elements of nums1 by the positive integer k.\\n\\n1. If at any point nums1[i] == nums2[i] then there is no need to change as that element is in right form.\\n\\n2. If both the elements are not equal which means we have to change the value of element in nums1 by increamenting or decreamenting it by the value k(given), which means value k cannot be zero and the difference is the multiple of k .\\n\\n3. Also maintain the another variable sum for storing the sum and at the end if sum is not zero then return -1 as we have to perform increament and decreament by k at the same time on two different positions.\\n\\n4. And at the end returrn ans/2 as increament and decreament is to be done at same time in one single operation. \\n\\n# Please upvote it you find it helpful\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long ans = 0, sum = 0;\\n        for (int i = 0 ; i < nums1.size() ; i++){\\n            if (nums1[i] != nums2[i]){\\n                long long dif = nums1[i]-nums2[i];\\n                if (k == 0 || abs(dif) % k) return -1;\\n                ans += abs(dif)/k;\\n                sum += dif;\\n            }\\n        }\\n        return sum == 0? ans/2 : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long ans = 0, sum = 0;\\n        for (int i = 0 ; i < nums1.size() ; i++){\\n            if (nums1[i] != nums2[i]){\\n                long long dif = nums1[i]-nums2[i];\\n                if (k == 0 || abs(dif) % k) return -1;\\n                ans += abs(dif)/k;\\n                sum += dif;\\n            }\\n        }\\n        return sum == 0? ans/2 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082543,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long n = nums1.size(), inc = 0, dec = 0;\\n        if(!k) {\\n            for(int i=0; i<n; i++) {\\n                if(nums1[i] != nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(nums1[i] > nums2[i]) {\\n                if((nums1[i] - nums2[i]) % k) return -1;\\n                dec += nums1[i] - nums2[i];\\n            }\\n            else if(nums1[i] < nums2[i]) {\\n                if((nums2[i] - nums1[i]) % k) return -1;\\n                inc += nums2[i] - nums1[i];\\n            }\\n        }\\n        return inc != dec ? -1 : inc / k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long n = nums1.size(), inc = 0, dec = 0;\\n        if(!k) {\\n            for(int i=0; i<n; i++) {\\n                if(nums1[i] != nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(nums1[i] > nums2[i]) {\\n                if((nums1[i] - nums2[i]) % k) return -1;\\n                dec += nums1[i] - nums2[i];\\n            }\\n            else if(nums1[i] < nums2[i]) {\\n                if((nums2[i] - nums1[i]) % k) return -1;\\n                inc += nums2[i] - nums1[i];\\n            }\\n        }\\n        return inc != dec ? -1 : inc / k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082409,
                "title": "python-balance-of-diff-o-n",
                "content": "```python\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if nums1 == nums2:\\n            return 0\\n\\n        if k == 0:\\n            return -1\\n\\n        # get positive and negative sum of diffs\\n        lo, hi = 0, 0\\n        for a, b in zip(nums1, nums2):\\n            d = a - b\\n            if d % k != 0:\\n                return -1\\n\\n            if d < 0:\\n                lo += d\\n            else:\\n                hi += d\\n\\n        # not balanced\\n        if lo + hi != 0:\\n            return -1\\n        \\n        return hi // k\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if nums1 == nums2:\\n            return 0\\n\\n        if k == 0:\\n            return -1\\n\\n        # get positive and negative sum of diffs\\n        lo, hi = 0, 0\\n        for a, b in zip(nums1, nums2):\\n            d = a - b\\n            if d % k != 0:\\n                return -1\\n\\n            if d < 0:\\n                lo += d\\n            else:\\n                hi += d\\n\\n        # not balanced\\n        if lo + hi != 0:\\n            return -1\\n        \\n        return hi // k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082291,
                "title": "c-solution-sad-truth-k-0",
                "content": "# Code\\n```\\nclass Solution {\\n  public: long long minOperations(vector < int > & nums1, vector < int > & nums2, int k) \\n    {\\n    int n = nums1.size();\\n    if (nums1 == nums2)\\n    return 0;\\n    else if (nums1 != nums2 && k == 0)\\n    return -1;\\n    long long int inc = 0;\\n    long long int dec = 0;\\n    for (int i = 0; i < n; i++) \\n    {\\n      int diff = nums1[i] - nums2[i];\\n      if (abs(diff) % k != 0)\\n        return -1;\\n      inc += (abs(diff) / k);\\n      dec += diff;\\n    }\\n    int ans = 0;\\n    if (dec != 0)\\n      return -1;\\n    else\\n      return inc / 2;\\n  }\\n};\\n```\\n\\n![images.jfif](https://assets.leetcode.com/users/images/5f8f2947-e2bd-4b3f-92ee-205a82237ec8_1674320164.9017406.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public: long long minOperations(vector < int > & nums1, vector < int > & nums2, int k) \\n    {\\n    int n = nums1.size();\\n    if (nums1 == nums2)\\n    return 0;\\n    else if (nums1 != nums2 && k == 0)\\n    return -1;\\n    long long int inc = 0;\\n    long long int dec = 0;\\n    for (int i = 0; i < n; i++) \\n    {\\n      int diff = nums1[i] - nums2[i];\\n      if (abs(diff) % k != 0)\\n        return -1;\\n      inc += (abs(diff) / k);\\n      dec += diff;\\n    }\\n    int ans = 0;\\n    if (dec != 0)\\n      return -1;\\n    else\\n      return inc / 2;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082212,
                "title": "c-simple-easy-to-understand",
                "content": "\\n```\\nlong long minOperations(vector<int>& nums1, vector<int>& nums2, int k) \\n{\\n    long long  sum=0;\\n    long long count=0;\\n    if(k==0)\\n    {\\n        for(int i=0;i<nums1.size();i++)\\n    {\\n        if(nums2[i]!=nums1[i]){return -1;}\\n    }\\n        return 0;\\n    }\\n    for(int i=0;i<nums1.size();i++)\\n    {\\n        if((nums2[i]-nums1[i])%k != 0){return -1;}\\n        else\\n        {\\n            if((nums2[i]-nums1[i]) > 0)\\n            {\\n                count+=((nums2[i]-nums1[i])/k);\\n            }\\n            sum+=(nums2[i]-nums1[i]);\\n        }\\n    }\\n    if(sum!=0)\\n    {\\n        return -1;\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long minOperations(vector<int>& nums1, vector<int>& nums2, int k) \\n{\\n    long long  sum=0;\\n    long long count=0;\\n    if(k==0)\\n    {\\n        for(int i=0;i<nums1.size();i++)\\n    {\\n        if(nums2[i]!=nums1[i]){return -1;}\\n    }\\n        return 0;\\n    }\\n    for(int i=0;i<nums1.size();i++)\\n    {\\n        if((nums2[i]-nums1[i])%k != 0){return -1;}\\n        else\\n        {\\n            if((nums2[i]-nums1[i]) > 0)\\n            {\\n                count+=((nums2[i]-nums1[i])/k);\\n            }\\n            sum+=(nums2[i]-nums1[i]);\\n        }\\n    }\\n    if(sum!=0)\\n    {\\n        return -1;\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082094,
                "title": "java-explained-using-comments",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        // if both arrays are equal already, \\n        // we don\\'t need to perform any operation\\n        if (Arrays.equals(nums1, nums2)) {\\n            return 0;\\n        }\\n        // if k is 0, arrays should be equal already\\n        if (k == 0) {\\n            return Arrays.equals(nums1, nums2)? 0 : -1;\\n        }\\n        \\n        // posOps -> Positive operations, negOps -> Negative operations\\n        // They will store how many positive operations (+k) and\\n        // how many negative operations (-k) we will perform respectively\\n        long posOps = 0, negOps = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            int diff = nums1[i] - nums2[i];     // get the difference\\n            // the difference should be divisible by k, very basic stuff\\n            if (diff % k != 0) {    // if not\\n                return -1;    // its not possible to make thearrays equal\\n            }\\n            if (diff < 0) {  // means nums1[i] < nums2[i]\\n                // we will have to perform a +k operation\\n                posOps += -diff / k;  // add the number of operations\\n            } else {         // means nums1[i] > nums2[i]\\n                // we will have to perform a -k operation\\n                negOps += diff / k;   // add the number of operations\\n            }\\n        }\\n        \\n        // now when we perform a positive operation, we perform a negative operation at the same time\\n        // so number of +ve operations should be equal to number of -ve operations\\n        // if yes, we would return either posOp or negOp\\n        // because we are ot performing negOp + posOp operations\\n        // 1 -ve operation and 1 +ve operation is one whole operation\\n        // because we are performing them simultaneously\\n        // if not equal we will return -1\\n        return (posOps == negOps)? posOps : -1;\\n    }\\n}\\n\\n```\\n---\\n#### Clean solution:\\n``` java []\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (Arrays.equals(nums1, nums2)) {\\n            return 0;\\n        }\\n        if (k == 0) {\\n            return Arrays.equals(nums1, nums2)? 0 : -1;\\n        }\\n        \\n        long posOps = 0, negOps = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            int diff = nums1[i] - nums2[i];     \\n            if (diff % k != 0) {    \\n                return -1;    \\n            }\\n            if (diff < 0) {  \\n                posOps += (-diff / k);  \\n            } else {         \\n                negOps += (diff / k);   \\n            }\\n        }\\n    \\n        return (posOps == negOps)? posOp : -1;\\n    }\\n}\\n```\\n---\\n#### Time complexity: $$O(n)$$\\n#### Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        // if both arrays are equal already, \\n        // we don\\'t need to perform any operation\\n        if (Arrays.equals(nums1, nums2)) {\\n            return 0;\\n        }\\n        // if k is 0, arrays should be equal already\\n        if (k == 0) {\\n            return Arrays.equals(nums1, nums2)? 0 : -1;\\n        }\\n        \\n        // posOps -> Positive operations, negOps -> Negative operations\\n        // They will store how many positive operations (+k) and\\n        // how many negative operations (-k) we will perform respectively\\n        long posOps = 0, negOps = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            int diff = nums1[i] - nums2[i];     // get the difference\\n            // the difference should be divisible by k, very basic stuff\\n            if (diff % k != 0) {    // if not\\n                return -1;    // its not possible to make thearrays equal\\n            }\\n            if (diff < 0) {  // means nums1[i] < nums2[i]\\n                // we will have to perform a +k operation\\n                posOps += -diff / k;  // add the number of operations\\n            } else {         // means nums1[i] > nums2[i]\\n                // we will have to perform a -k operation\\n                negOps += diff / k;   // add the number of operations\\n            }\\n        }\\n        \\n        // now when we perform a positive operation, we perform a negative operation at the same time\\n        // so number of +ve operations should be equal to number of -ve operations\\n        // if yes, we would return either posOp or negOp\\n        // because we are ot performing negOp + posOp operations\\n        // 1 -ve operation and 1 +ve operation is one whole operation\\n        // because we are performing them simultaneously\\n        // if not equal we will return -1\\n        return (posOps == negOps)? posOps : -1;\\n    }\\n}\\n\\n```\n``` java []\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (Arrays.equals(nums1, nums2)) {\\n            return 0;\\n        }\\n        if (k == 0) {\\n            return Arrays.equals(nums1, nums2)? 0 : -1;\\n        }\\n        \\n        long posOps = 0, negOps = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            int diff = nums1[i] - nums2[i];     \\n            if (diff % k != 0) {    \\n                return -1;    \\n            }\\n            if (diff < 0) {  \\n                posOps += (-diff / k);  \\n            } else {         \\n                negOps += (diff / k);   \\n            }\\n        }\\n    \\n        return (posOps == negOps)? posOp : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888647,
                "title": "beats-98-simple-increment-and-decrement-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0)\\n        {\\n            if(nums1==nums2)return 0;\\n            else\\n            return -1;\\n        }\\n        bool ans = true;\\n        long long incr = 0;\\n        long long dcr = 0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int diff;\\n            if(nums1[i]>=nums2[i])\\n            {\\n                diff = nums1[i]-nums2[i];\\n                if(diff%k!=0)\\n                {\\n                    ans = false;\\n                    break;\\n                }\\n                dcr+=(diff)/k;\\n            }\\n            else\\n            {\\n                diff = nums2[i]-nums1[i];\\n                if(diff%k!=0)\\n                {\\n                    ans = false;\\n                    break;\\n                }\\n                incr+=(diff)/k;\\n            }\\n        }\\n        if(!ans)return -1;\\n\\n        if(dcr==incr)return dcr;\\n        else\\n        return -1;\\n\\n    }\\n};\\n//please upvote if you liked it :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0)\\n        {\\n            if(nums1==nums2)return 0;\\n            else\\n            return -1;\\n        }\\n        bool ans = true;\\n        long long incr = 0;\\n        long long dcr = 0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int diff;\\n            if(nums1[i]>=nums2[i])\\n            {\\n                diff = nums1[i]-nums2[i];\\n                if(diff%k!=0)\\n                {\\n                    ans = false;\\n                    break;\\n                }\\n                dcr+=(diff)/k;\\n            }\\n            else\\n            {\\n                diff = nums2[i]-nums1[i];\\n                if(diff%k!=0)\\n                {\\n                    ans = false;\\n                    break;\\n                }\\n                incr+=(diff)/k;\\n            }\\n        }\\n        if(!ans)return -1;\\n\\n        if(dcr==incr)return dcr;\\n        else\\n        return -1;\\n\\n    }\\n};\\n//please upvote if you liked it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735924,
                "title": "c-easy-short-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n$$nums1$$ can be made equal to $$nums2$$ only when when:\\n1) The difference of every element at index $$i$$ in both the arrays is divisible by k : $$( nums1[i] - nums2[i] ) \\\\% k == 0$$\\n2) The total sum of differences that we calculated in step 1 is equal to zero: $$\\\\sum_{i=0}^{n-1}nums1[i] - nums2[i] $$, where n is the size of the arrays.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long sum {};\\n        long count {};\\n        if(k==0){\\n            if(nums2 == nums1) return 0;\\n            else return -1;\\n        }\\n\\n        for(int i=0; i<nums1.size(); i++){\\n            sum+= nums1[i] - nums2[i];\\n            if(abs(sum)%k==0){\\n                count+= abs(nums1[i] - nums2[i])/k;\\n            }\\n            else return -1;\\n        }\\n        if(sum==0) return count/2;\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long sum {};\\n        long count {};\\n        if(k==0){\\n            if(nums2 == nums1) return 0;\\n            else return -1;\\n        }\\n\\n        for(int i=0; i<nums1.size(); i++){\\n            sum+= nums1[i] - nums2[i];\\n            if(abs(sum)%k==0){\\n                count+= abs(nums1[i] - nums2[i])/k;\\n            }\\n            else return -1;\\n        }\\n        if(sum==0) return count/2;\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484958,
                "title": "greedy-simple-and-efficient-solution-o-n-c",
                "content": "# Intuition\\n**BASE CASES**\\n1)If Sum of both arrays are not equal the we cannot make them equal\\n2 ) if Absolute difference between elements at index i is not divisible by k then we cannot make them equal.\\n3)If K==0 then input arrays must equal else return -1;\\n**IN All OTHER CASES WE CAN FIND THE NUMBER OF OPERATIONS GREEDILY**\\n\\n# Approach\\n**GREEDY APPROACH**\\nConsider Num1= [6,3] ,Nums2 = [3,6],K=3;\\nNumber of operations of converting element at index 0 :\\n 6 to 3 is One Single operation that is 6-k ==>6-3=3.\\nNumber of operations of converting element at index 1:\\n 3 to 6 is One Single operation that is 3+k ==>3+3=6.\\nTotal 2 operations are required for converting nums1==nums2.\\nBut WE Can Count Increment And Decrement AS **ONE** Single operation.\\nSO we return (Operations)/2. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n       if(k==0)\\n       {\\n           if(nums1==nums2) return 0;\\n           return -1;\\n       }\\n       long long sum1=0;\\n       long long sum2=0;\\n       long long operations=0;\\n       int n=nums1.size(),diff;\\n       for(int i=0;i<n;i++)\\n       {\\n           diff=abs(nums1[i]-nums2[i]);\\n          if(diff%k) return -1;\\n          operations=(long long)operations+diff/k;\\n          sum1=(long long)sum1+nums1[i];\\n          sum2=(long long)sum2+nums2[i];\\n\\n       } \\n       if(sum1!=sum2) return -1;\\n       return operations/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n       if(k==0)\\n       {\\n           if(nums1==nums2) return 0;\\n           return -1;\\n       }\\n       long long sum1=0;\\n       long long sum2=0;\\n       long long operations=0;\\n       int n=nums1.size(),diff;\\n       for(int i=0;i<n;i++)\\n       {\\n           diff=abs(nums1[i]-nums2[i]);\\n          if(diff%k) return -1;\\n          operations=(long long)operations+diff/k;\\n          sum1=(long long)sum1+nums1[i];\\n          sum2=(long long)sum2+nums2[i];\\n\\n       } \\n       if(sum1!=sum2) return -1;\\n       return operations/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464211,
                "title": "easy-approach-greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n         long long decre = 0;\\n         long long incre = 0;\\n        \\n        \\n        for(int i = 0; i < nums1.size(); i++) {\\n            if(nums1[i] == nums2[i])\\n                continue;\\n\\n            if(nums1[i] != nums2[i] && k==0)\\n                    return -1;\\n            \\n            if(abs(nums1[i] - nums2[i]) % k != 0)\\n                return -1;\\n            \\n            \\n            if(nums1[i] > nums2[i]) {\\n                decre += (nums1[i] - nums2[i]) / k;\\n            }\\n            else {\\n                incre += (nums2[i] - nums1[i]) / k;\\n            }\\n        }\\n        \\n        if(incre == decre)\\n            return decre;\\n    \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n         long long decre = 0;\\n         long long incre = 0;\\n        \\n        \\n        for(int i = 0; i < nums1.size(); i++) {\\n            if(nums1[i] == nums2[i])\\n                continue;\\n\\n            if(nums1[i] != nums2[i] && k==0)\\n                    return -1;\\n            \\n            if(abs(nums1[i] - nums2[i]) % k != 0)\\n                return -1;\\n            \\n            \\n            if(nums1[i] > nums2[i]) {\\n                decre += (nums1[i] - nums2[i]) / k;\\n            }\\n            else {\\n                incre += (nums2[i] - nums1[i]) / k;\\n            }\\n        }\\n        \\n        if(incre == decre)\\n            return decre;\\n    \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105100,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n     long add=0,sub=0;\\n     for(int i=0;i<nums1.length;i++)\\n     {\\n         if(k==0&&nums1[i]!=nums2[i])return -1;\\n         if(nums1[i]==nums2[i])continue;\\n         else if(nums1[i]<nums2[i]){\\n             int val1=nums2[i]-nums1[i];\\n             if(val1%k==0)add+=(val1/k);\\n             else return -1;\\n         }else{\\n             int val2=nums1[i]-nums2[i];\\n             if(val2%k==0)sub+=(val2/k);\\n             else return -1;\\n         }\\n     }\\n     return add==sub?add:-1;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n     long add=0,sub=0;\\n     for(int i=0;i<nums1.length;i++)\\n     {\\n         if(k==0&&nums1[i]!=nums2[i])return -1;\\n         if(nums1[i]==nums2[i])continue;\\n         else if(nums1[i]<nums2[i]){\\n             int val1=nums2[i]-nums1[i];\\n             if(val1%k==0)add+=(val1/k);\\n             else return -1;\\n         }else{\\n             int val2=nums1[i]-nums2[i];\\n             if(val2%k==0)sub+=(val2/k);\\n             else return -1;\\n         }\\n     }\\n     return add==sub?add:-1;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086160,
                "title": "simple-easy-c-solution",
                "content": "# Intuition\\nSimple approach would be to consider all the cases in which arrays cannot be made equal with given values. And if none of the conditions are staisfied then finding out minimum moves to maked arrays equal through smiple calculations and observation.\\n\\n# Approach\\nLet us first consider all the cases in which arrays cannot be made equal\\n1. k is 0 and arrays are not equal from the statrt. Since k is 0, no elements can be altered.\\n2. At any index i, (nums1[i]-nums2[i])%k is not equal to 0. Since at any moment, we can increase or decrease an element by k, difference between elements of two arrays present at same position needs to be divisible by k.\\n3. Number of increments and decrements made while making arrays equal are not same.\\nFor example: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3\\nHere there is 1 decrement each at index 0 and index 3, and 2 increments at index 2, thus making these arrays possible to be made equal.\\n\\nNow that we have seen cases in which we will return -1, let us see how to calculate minimum number of operations required to make arrays equal.\\nLet us take same example: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3\\nHere, we can conclude through observation that\\n**No. of increments = No. of decrements = Min no. of operations = 2**\\n\\n# Complexity\\n- Time complexity:\\n**O(n)**\\nwhere n = number of elements in nums1\\n\\n- Space complexity:\\n**O(n)**\\nwhere n = number of elements in nums1\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0)\\n        {\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                if(nums1[i] != nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<nums1.size();i++)\\n            if((nums1[i]-nums2[i])%k != 0) return -1;\\n        vector<int> v;\\n        for(int i=0;i<nums1.size();i++)\\n            v.push_back((nums1[i]-nums2[i])/k);\\n        for(auto i:v)\\n            sum += i;\\n        if(sum != 0) return -1;\\n        long long int ans=0;\\n        for(auto i:v)\\n        {\\n            if(i>0)\\n                ans+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0)\\n        {\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                if(nums1[i] != nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        long long int sum=0;\\n        for(int i=0;i<nums1.size();i++)\\n            if((nums1[i]-nums2[i])%k != 0) return -1;\\n        vector<int> v;\\n        for(int i=0;i<nums1.size();i++)\\n            v.push_back((nums1[i]-nums2[i])/k);\\n        for(auto i:v)\\n            sum += i;\\n        if(sum != 0) return -1;\\n        long long int ans=0;\\n        for(auto i:v)\\n        {\\n            if(i>0)\\n                ans+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085181,
                "title": "easy-js-you-will-get-it",
                "content": "# Approach\\nCount the difference of each pair.\\nMany edge cases to take care of.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar minOperations = function (nums1, nums2, k) {\\n  let posSum = 0, negSum = 0;\\n  for (let i = 0; i < nums1.length; i++) {\\n    let diff = nums1[i] - nums2[i];\\n    diff > 0 ? posSum += diff : negSum += diff;\\n    }\\n  if (posSum === 0 && negSum === 0) return 0;\\n  if (posSum + negSum !== 0 || posSum < k || k === 0 || posSum % k) return -1;\\n  return posSum / k;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar minOperations = function (nums1, nums2, k) {\\n  let posSum = 0, negSum = 0;\\n  for (let i = 0; i < nums1.length; i++) {\\n    let diff = nums1[i] - nums2[i];\\n    diff > 0 ? posSum += diff : negSum += diff;\\n    }\\n  if (posSum === 0 && negSum === 0) return 0;\\n  if (posSum + negSum !== 0 || posSum < k || k === 0 || posSum % k) return -1;\\n  return posSum / k;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083268,
                "title": "c-java-python3-difference",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7c339707e031611c80809107e7a667b2c6b6f7f0) for solutions of biweekly 96. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long ans = 0, total = 0; \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            int diff = nums1[i] - nums2[i]; \\n            if (k == 0 && diff || k && diff % k) return -1; \\n            if (k) ans += abs(diff) / k; \\n            total += diff; \\n        }\\n        return total == 0 ? ans/2 : -1; \\n    }\\n}; \\n```\\n**Java**\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long ans = 0, total = 0; \\n        for (int i = 0; i < nums1.length; ++i) {\\n            int diff = nums1[i] - nums2[i]; \\n            if (k == 0 && diff > 0 || k > 0 && diff % k != 0) return -1; \\n            if (k > 0) ans += Math.abs(diff) / k; \\n            total += diff; \\n        }\\n        return total == 0 ? ans/2 : -1; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        ans = total = 0 \\n        for x, y in zip(nums1, nums2): \\n            diff = x-y\\n            if k == 0 and diff or k and abs(diff) % k: return -1 \\n            if k: ans += abs(diff)//k\\n            total += diff\\n        return ans//2 if total == 0 else -1 \\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long ans = 0, total = 0; \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            int diff = nums1[i] - nums2[i]; \\n            if (k == 0 && diff || k && diff % k) return -1; \\n            if (k) ans += abs(diff) / k; \\n            total += diff; \\n        }\\n        return total == 0 ? ans/2 : -1; \\n    }\\n}; \\n```\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long ans = 0, total = 0; \\n        for (int i = 0; i < nums1.length; ++i) {\\n            int diff = nums1[i] - nums2[i]; \\n            if (k == 0 && diff > 0 || k > 0 && diff % k != 0) return -1; \\n            if (k > 0) ans += Math.abs(diff) / k; \\n            total += diff; \\n        }\\n        return total == 0 ? ans/2 : -1; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        ans = total = 0 \\n        for x, y in zip(nums1, nums2): \\n            diff = x-y\\n            if k == 0 and diff or k and abs(diff) % k: return -1 \\n            if k: ans += abs(diff)//k\\n            total += diff\\n        return ans//2 if total == 0 else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083116,
                "title": "cpp-easy-to-understand-solution-runs-fast",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will first check if k is 0 or not if 0 then we will check weather array is eqal or not ; many got wa due to this Xd .\\n\\n2. Now to make the elements equal num1[i] and num2[i] diffrence must be divisible by k  since then only we will be able to make them equal\\n\\n3. now we will take two variable inc and dec and then we will check for Diffrence:\\n    a .  if diffrence is negative then we will increse by k until that become equal to nums2[i] that\\'s why i have added quotient to inc\\nand then we will check if inc == dec since we are told to do these operation similtaneously so they increase and decrease operation should be equal \\n\\n    b. else we return -1; \\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& arr, vector<int>& brr, int k) {\\n        \\tlong long inc = 0, dec = 0;\\n\\tlong long n = arr.size();\\n        if(k==0){\\n            if(arr!=brr){\\n                return -1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n\\tfor (int i = 0 ; i < n ; i++) {\\n\\t\\tlong long diff = arr[i] - brr[i];\\n\\t\\tif (abs(arr[i] - brr[i]) % k != 0) {\\n\\t\\t\\treturn -1;\\n\\t\\t} else {\\n\\t\\t\\tif (diff < 0) {\\n\\t\\t\\t\\tinc += (abs(diff) / k);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdec += (diff / k);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\t// cout << inc << \" \" << dec << nline;\\n\\tif (inc == dec)\\n\\t\\treturn inc;\\n\\telse\\n\\t\\treturn -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& arr, vector<int>& brr, int k) {\\n        \\tlong long inc = 0, dec = 0;\\n\\tlong long n = arr.size();\\n        if(k==0){\\n            if(arr!=brr){\\n                return -1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n\\tfor (int i = 0 ; i < n ; i++) {\\n\\t\\tlong long diff = arr[i] - brr[i];\\n\\t\\tif (abs(arr[i] - brr[i]) % k != 0) {\\n\\t\\t\\treturn -1;\\n\\t\\t} else {\\n\\t\\t\\tif (diff < 0) {\\n\\t\\t\\t\\tinc += (abs(diff) / k);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdec += (diff / k);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\t// cout << inc << \" \" << dec << nline;\\n\\tif (inc == dec)\\n\\t\\treturn inc;\\n\\telse\\n\\t\\treturn -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3082205,
                "title": "c-o-n-simple-code-explained-with-comments",
                "content": "# Intuition\\nIf (nums[2] - nums[1]) is not divisible by k, simply return false.\\nExample, 8 can\\'t be reached by adding or subtracting 2 from 5 any number of times.\\n\\nMoreover, the number of times we increase any number of array should equal the numbers we decrease.  \\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        //division by 0, Simply check if both the arrays are equal\\n        if(k==0){\\n            if(nums1==nums2){\\n                return 0;\\n            }\\n            else return -1;\\n        }\\n\\n        long long inc=0; //It stores the number of times an element is increased\\n        long long dec=0; //It stores the number of times an element is decreased\\n\\n        for(int i=0;i<nums1.size();i++){\\n            //if nums[2] is not reachable from nums[1]\\n            if(abs(nums2[i]-nums1[i])%k!=0){\\n                return -1;\\n            }\\n            else{\\n                int temp=abs(nums2[i]-nums1[i])/k;//Number of operations required   \\n                if(nums2[i]>nums1[i]){\\n                    inc+=temp; //if nums1[i] is increased\\n                } \\n                else dec+=temp; //if nums1[i] is decreased\\n            }\\n        }\\n        //Total number of increases should be equal to the total number of decreases\\n        if(inc==dec){\\n            return inc;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        //division by 0, Simply check if both the arrays are equal\\n        if(k==0){\\n            if(nums1==nums2){\\n                return 0;\\n            }\\n            else return -1;\\n        }\\n\\n        long long inc=0; //It stores the number of times an element is increased\\n        long long dec=0; //It stores the number of times an element is decreased\\n\\n        for(int i=0;i<nums1.size();i++){\\n            //if nums[2] is not reachable from nums[1]\\n            if(abs(nums2[i]-nums1[i])%k!=0){\\n                return -1;\\n            }\\n            else{\\n                int temp=abs(nums2[i]-nums1[i])/k;//Number of operations required   \\n                if(nums2[i]>nums1[i]){\\n                    inc+=temp; //if nums1[i] is increased\\n                } \\n                else dec+=temp; //if nums1[i] is decreased\\n            }\\n        }\\n        //Total number of increases should be equal to the total number of decreases\\n        if(inc==dec){\\n            return inc;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082174,
                "title": "java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n\\tpublic long minOperations(int[] nums1, int[] nums2, double k) {\\n\\t\\tlong count = 0, total = 0;\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\t\\t\\tif (nums1[i] != nums2[i] && (k == 0 || (nums1[i] - nums2[i]) % k != 0)) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tcount += Math.max(0, (nums1[i] - nums2[i]) / k);\\n\\t\\t\\ttotal += nums1[i] - nums2[i];\\n\\t\\t}\\n\\t\\treturn total == 0 ? count : -1;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic long minOperations(int[] nums1, int[] nums2, double k) {\\n\\t\\tlong count = 0, total = 0;\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\t\\t\\tif (nums1[i] != nums2[i] && (k == 0 || (nums1[i] - nums2[i]) % k != 0)) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tcount += Math.max(0, (nums1[i] - nums2[i]) / k);\\n\\t\\t\\ttotal += nums1[i] - nums2[i];\\n\\t\\t}\\n\\t\\treturn total == 0 ? count : -1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464250,
                "title": "c-beats-98-easy-simple-greedy-approach-completely-explained",
                "content": "![sol.jpg](https://assets.leetcode.com/users/images/b5652e0e-23cc-46f5-8ea2-6f5582f3a5f3_1682704949.6114554.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long plus_opr=0;\\n                long long neg_opr=0;\\n                if(k == 0 && nums1 != nums2) return -1;\\n                if(k == 0 && nums1 == nums2) return 0;\\n    for(int i=0;i<nums1.size();i++){\\n        if(nums1[i]<nums2[i]){\\n            if((nums2[i]-nums1[i]) % k == 0){\\n                plus_opr+=((nums2[i]-nums1[i])/k);\\n            }\\n            else return -1;\\n        }\\n           else if(nums1[i]>nums2[i]){\\n               if((nums1[i]-nums2[i]) % k == 0){\\n                neg_opr+=((nums1[i]-nums2[i])/k);\\n            }\\n                        else return -1;\\n           }\\n        \\n    }\\n    if(plus_opr != neg_opr) return -1;\\n    return (plus_opr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long plus_opr=0;\\n                long long neg_opr=0;\\n                if(k == 0 && nums1 != nums2) return -1;\\n                if(k == 0 && nums1 == nums2) return 0;\\n    for(int i=0;i<nums1.size();i++){\\n        if(nums1[i]<nums2[i]){\\n            if((nums2[i]-nums1[i]) % k == 0){\\n                plus_opr+=((nums2[i]-nums1[i])/k);\\n            }\\n            else return -1;\\n        }\\n           else if(nums1[i]>nums2[i]){\\n               if((nums1[i]-nums2[i]) % k == 0){\\n                neg_opr+=((nums1[i]-nums2[i])/k);\\n            }\\n                        else return -1;\\n           }\\n        \\n    }\\n    if(plus_opr != neg_opr) return -1;\\n    return (plus_opr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112439,
                "title": "c-greedy-faster-easy-to-understand",
                "content": "* ***Greedy***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n = nums1.size();\\n        \\n        // inc will keep count of no. of operations required to make smaller no. of nums1 equal to no. of nums2\\n        \\n        // dec will keep count of no. of operations required to make larger no. of nums1 equal to no. of nums2\\n        \\n        long long inc = 0, dec = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] > nums1[i])\\n            {\\n                // if we can\\'t increment no. of nums1, then return -1\\n                \\n                if(k == 0 || (nums2[i] - nums1[i]) % k != 0)\\n                {\\n                    return -1;\\n                }\\n                \\n                // increment inc\\n                \\n                inc += (nums2[i] - nums1[i]) / k;\\n            }\\n            else if(nums1[i] > nums2[i])\\n            {\\n                // if we can\\'t decrement nums1, then return -1\\n                \\n                if(k == 0 || (nums1[i] - nums2[i]) % k != 0)\\n                {\\n                    return -1;\\n                }\\n                \\n                // increment dec\\n                \\n                dec += (nums1[i] - nums2[i]) / k;\\n            }\\n        }\\n        \\n        // if no. of inc == dec, then return any one of them\\n        \\n        if(inc == dec)\\n        {\\n            return inc;\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n = nums1.size();\\n        \\n        // inc will keep count of no. of operations required to make smaller no. of nums1 equal to no. of nums2\\n        \\n        // dec will keep count of no. of operations required to make larger no. of nums1 equal to no. of nums2\\n        \\n        long long inc = 0, dec = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums2[i] > nums1[i])\\n            {\\n                // if we can\\'t increment no. of nums1, then return -1\\n                \\n                if(k == 0 || (nums2[i] - nums1[i]) % k != 0)\\n                {\\n                    return -1;\\n                }\\n                \\n                // increment inc\\n                \\n                inc += (nums2[i] - nums1[i]) / k;\\n            }\\n            else if(nums1[i] > nums2[i])\\n            {\\n                // if we can\\'t decrement nums1, then return -1\\n                \\n                if(k == 0 || (nums1[i] - nums2[i]) % k != 0)\\n                {\\n                    return -1;\\n                }\\n                \\n                // increment dec\\n                \\n                dec += (nums1[i] - nums2[i]) / k;\\n            }\\n        }\\n        \\n        // if no. of inc == dec, then return any one of them\\n        \\n        if(inc == dec)\\n        {\\n            return inc;\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102026,
                "title": "java-easy-solution-upvote-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Tried to find the pattern\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Difference between the elements of both the array at same index must be divisble by give value of k.\\n\\n   \\n![WhatsApp Image 2023-01-26 at 19.51.50.jpeg](https://assets.leetcode.com/users/images/0bb4a85f-0f43-4106-bd73-b98d266d065f_1674743190.346076.jpeg)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long diff = 0;\\n        long sum = 0;\\n        long ans = -1;\\n        for(int i = 0; i<nums1.length; i++)\\n        {\\n            if((Math.abs(nums1[i]-nums2[i])!=0 && Math.abs(nums1[i]-nums2[i]) < k ) ||((k!=0)&&(Math.abs(nums1[i]-nums2[i])%k) !=0))\\n            {\\n            return -1;\\n            }\\n            diff += (nums1[i] - nums2[i]);\\n            sum+= Math.abs(nums1[i] - nums2[i]);\\n        }\\n        if( diff == 0 && k!=0)\\n        {\\n            if(sum % (k*2) == 0 && sum >=(k*2))\\n            {\\n                sum = sum/2;\\n                ans = sum/k;\\n            }\\n            else if (sum == 0 && diff == 0)\\n            {\\n                ans = 0;\\n            }\\n            else\\n            {\\n                ans = -1;\\n            }\\n        }\\n        else\\n        {\\n            if(sum == 0 && diff == 0)\\n            {\\n                ans = 0;\\n            }\\n            else if(diff != 0 && k !=0)\\n            {\\n                ans = -1;\\n            }\\n            else if(diff == 0 && (k == 0&&sum!=0))\\n            {\\n                ans = -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long diff = 0;\\n        long sum = 0;\\n        long ans = -1;\\n        for(int i = 0; i<nums1.length; i++)\\n        {\\n            if((Math.abs(nums1[i]-nums2[i])!=0 && Math.abs(nums1[i]-nums2[i]) < k ) ||((k!=0)&&(Math.abs(nums1[i]-nums2[i])%k) !=0))\\n            {\\n            return -1;\\n            }\\n            diff += (nums1[i] - nums2[i]);\\n            sum+= Math.abs(nums1[i] - nums2[i]);\\n        }\\n        if( diff == 0 && k!=0)\\n        {\\n            if(sum % (k*2) == 0 && sum >=(k*2))\\n            {\\n                sum = sum/2;\\n                ans = sum/k;\\n            }\\n            else if (sum == 0 && diff == 0)\\n            {\\n                ans = 0;\\n            }\\n            else\\n            {\\n                ans = -1;\\n            }\\n        }\\n        else\\n        {\\n            if(sum == 0 && diff == 0)\\n            {\\n                ans = 0;\\n            }\\n            else if(diff != 0 && k !=0)\\n            {\\n                ans = -1;\\n            }\\n            else if(diff == 0 && (k == 0&&sum!=0))\\n            {\\n                ans = -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100098,
                "title": "greedy-c-o-n-time-o-1-space",
                "content": "\\tlong long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long up = 0;\\n        long long d = 0;\\n        if(nums1 == nums2) return 0;\\n        if(k==0) return -1;  \\n\\t\\t//n1 = 4,3,1  n2 = 1,3,7\\n        for(int i=0; i<nums1.size();  i++){\\n            int t = abs(nums1[i]-nums2[i]); \\n\\t\\t\\t//t = 3 so t%3 = 0 \\n            if(t%k == 0){// if(n1>n2) then increse upcnt and t/k will give the value how much u have to increase \\n                if(nums1[i]>nums2[i]) up+=t/k;\\n                else d +=t/k;// else u have to increase the dcnt;\\n            }\\n            else return -1;\\n        }\\n\\t\\t// if both are equal then means given condition is satisfied return up else return -1 both are cnot be equal at given condition /\\n        return (d==up)?up:-1;\\n    }\\n\\t\\n\\t\\n**Upvote if you find the solution helpfull**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "\\tlong long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long up = 0;\\n        long long d = 0;\\n        if(nums1 == nums2) return 0;\\n        if(k==0) return -1;  \\n\\t\\t//n1 = 4,3,1  n2 = 1,3,7\\n        for(int i=0; i<nums1.size();  i++){\\n            int t = abs(nums1[i]-nums2[i]); \\n\\t\\t\\t//t = 3 so t%3 = 0 \\n            if(t%k == 0){// if(n1>n2) then increse upcnt and t/k will give the value how much u have to increase \\n                if(nums1[i]>nums2[i]) up+=t/k;\\n                else d +=t/k;// else u have to increase the dcnt;\\n            }\\n            else return -1;\\n        }\\n\\t\\t// if both are equal then means given condition is satisfied return up else return -1 both are cnot be equal at given condition /\\n        return (d==up)?up:-1;\\n    }\\n\\t\\n\\t\\n**Upvote if you find the solution helpfull**",
                "codeTag": "Unknown"
            },
            {
                "id": 3094810,
                "title": "easy-to-understand-c-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            for(int i=0;i<nums1.size();i++){\\n                if(nums1[i]!=nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        long long sum1=0,sum2=0;\\n        long long count=0;\\n        for(int i=0;i<nums1.size();i++){\\n            if(abs(nums1[i]-nums2[i])%k!=0) return -1;\\n            count+=abs(nums1[i]-nums2[i]);\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        if(sum1!=sum2) return -1;\\n        return (long long)count/(2*k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            for(int i=0;i<nums1.size();i++){\\n                if(nums1[i]!=nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        long long sum1=0,sum2=0;\\n        long long count=0;\\n        for(int i=0;i<nums1.size();i++){\\n            if(abs(nums1[i]-nums2[i])%k!=0) return -1;\\n            count+=abs(nums1[i]-nums2[i]);\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        if(sum1!=sum2) return -1;\\n        return (long long)count/(2*k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086594,
                "title": "python-o-n-explained",
                "content": "# Approach\\n- We can modify one array while keeping the other one same.\\n- But here won\\'t modify any array just simulate the modification and count number of operations.\\n- Suppose we will modify second array to convert it into first one.\\n- Iterate through the array and find difference between elements at i<sup>th</sup> position in both arrays.\\n- This difference should be divisible by k, if it is not then conversion is not possible.\\n- simultaneously we will maintain two variables for increment `p` and for decrement `m`.\\n- Accordingly for each element we will update `p` and `m` variables.\\n- now according to the question we will perform both increment and decrement in one operation, that means values of `p` and `m` should be equal.\\n- If it is equal then return (p+m)/2\\n- Else it is not possible, return -1.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if k == 0:\\n            if nums1 == nums2:\\n                return 0\\n            else:\\n                return -1\\n            \\n        p = m = 0\\n        for i in range(len(nums1)):\\n            if abs(nums1[i]-nums2[i])%k==0:\\n                if nums1[i]>nums2[i]:\\n                    p += (abs(nums1[i]-nums2[i])//k)\\n                elif nums1[i]<nums2[i]:\\n                    m += (abs(nums1[i]-nums2[i])//k)\\n                else:\\n                    continue\\n            else:\\n                return -1\\n            \\n        if p == m:\\n            return (p+m)//2\\n        else:\\n            return -1\\n```\\n-------------------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if k == 0:\\n            if nums1 == nums2:\\n                return 0\\n            else:\\n                return -1\\n            \\n        p = m = 0\\n        for i in range(len(nums1)):\\n            if abs(nums1[i]-nums2[i])%k==0:\\n                if nums1[i]>nums2[i]:\\n                    p += (abs(nums1[i]-nums2[i])//k)\\n                elif nums1[i]<nums2[i]:\\n                    m += (abs(nums1[i]-nums2[i])//k)\\n                else:\\n                    continue\\n            else:\\n                return -1\\n            \\n        if p == m:\\n            return (p+m)//2\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086292,
                "title": "easy-and-beginner-friendly-solution-please-do-upvote-if-you-find-it-helpfull",
                "content": "# Intuition\\ncheck the edge cases \\n\\n# Approach\\njust traverse the loop and calculate difference and then check whether nums1 is greater or lesser if it is greater increment by diff/k because it tell us how many time we have to increment and same for decrement and at last check whether increment count is equal to decrement count .if it is then return either increment or decrement.\\n\\n# Complexity\\n- Time complexity:\\n  O(N)- As we traverse the loop only single time\\n\\n- Space complexity:\\n O(1)-As we have just taken variables inc,dec,diff.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){ // check for zero \\n            for(int i=0;i<nums1.size();i++){\\n                if(nums1[i]!=nums2[i]){\\n                    return -1;\\n                }\\n\\n                \\n            }\\n            return 0;\\n        }\\n        \\n        long long int diff=0;\\n        long long int inc=0;\\n        long long int dec=0;\\n        for(int i=0;i<nums1.size();i++){\\n            if(abs(nums1[i]-nums2[i])%k!=0){ \\n                return -1;\\n            }\\n            diff=abs(nums1[i]-nums2[i]);\\n            if(nums1[i]==nums2[i]){\\n                continue;\\n            }\\n            if(nums1[i]>nums2[i]){\\n                dec+=diff/k; // no of times to decrement\\n            }\\n            else{\\n                inc+=diff/k; no of times to increment\\n\\n            }\\n        }\\n        if(inc==dec){\\n            return inc;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){ // check for zero \\n            for(int i=0;i<nums1.size();i++){\\n                if(nums1[i]!=nums2[i]){\\n                    return -1;\\n                }\\n\\n                \\n            }\\n            return 0;\\n        }\\n        \\n        long long int diff=0;\\n        long long int inc=0;\\n        long long int dec=0;\\n        for(int i=0;i<nums1.size();i++){\\n            if(abs(nums1[i]-nums2[i])%k!=0){ \\n                return -1;\\n            }\\n            diff=abs(nums1[i]-nums2[i]);\\n            if(nums1[i]==nums2[i]){\\n                continue;\\n            }\\n            if(nums1[i]>nums2[i]){\\n                dec+=diff/k; // no of times to decrement\\n            }\\n            else{\\n                inc+=diff/k; no of times to increment\\n\\n            }\\n        }\\n        if(inc==dec){\\n            return inc;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085813,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        \\n        \\n        long long int n = nums1.size(),m=nums2.size();\\n        \\n        if(n!=m)\\n            return -1;\\n        \\n        long long int i=0;\\n        \\n        long long int plus=0,minus=0;\\n        \\n        while(i < n)\\n        {\\n            if(nums1[i] > nums2[i])\\n            {\\n                if(k != 0 && (nums1[i]-nums2[i])%k == 0)\\n                {\\n                    minus += (nums1[i]-nums2[i])/k;\\n                }\\n                else\\n                {\\n                    return -1;\\n                }\\n            }\\n            \\n            else if(nums1[i] < nums2[i])\\n            {\\n                if(k != 0 && (nums2[i] - nums1[i])%k == 0)\\n                {\\n                    plus += (nums2[i]-nums1[i])/k;\\n                }\\n                else\\n                {\\n                    return -1;\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        if(plus == minus)\\n            return plus;\\n        \\n        return -1;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        \\n        \\n        long long int n = nums1.size(),m=nums2.size();\\n        \\n        if(n!=m)\\n            return -1;\\n        \\n        long long int i=0;\\n        \\n        long long int plus=0,minus=0;\\n        \\n        while(i < n)\\n        {\\n            if(nums1[i] > nums2[i])\\n            {\\n                if(k != 0 && (nums1[i]-nums2[i])%k == 0)\\n                {\\n                    minus += (nums1[i]-nums2[i])/k;\\n                }\\n                else\\n                {\\n                    return -1;\\n                }\\n            }\\n            \\n            else if(nums1[i] < nums2[i])\\n            {\\n                if(k != 0 && (nums2[i] - nums1[i])%k == 0)\\n                {\\n                    plus += (nums2[i]-nums1[i])/k;\\n                }\\n                else\\n                {\\n                    return -1;\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        if(plus == minus)\\n            return plus;\\n        \\n        return -1;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085704,
                "title": "simple-and-easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0 && nums1!=nums2)return -1;\\n        else if(k==0 && nums1==nums2)return 0;\\n        long long ans = 0;\\n        long long res = 0;\\n        long long ans1 = 0;\\n        int c = 0;\\n        int c1 = 0;\\n        for(int i=0;i<nums1.size();i++){\\n            res = nums1[i]-nums2[i];\\n            if(res%k==0){\\n                ans += abs(res)/k;\\n            }\\n            else{\\n                return -1;\\n            }\\n\\n            if(res>0){\\n                c+= res/k;\\n            }\\n            if(res<0){\\n                c1+= abs(res)/k;\\n            }\\n\\n        }\\n        if(c!=c1)return -1;\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0 && nums1!=nums2)return -1;\\n        else if(k==0 && nums1==nums2)return 0;\\n        long long ans = 0;\\n        long long res = 0;\\n        long long ans1 = 0;\\n        int c = 0;\\n        int c1 = 0;\\n        for(int i=0;i<nums1.size();i++){\\n            res = nums1[i]-nums2[i];\\n            if(res%k==0){\\n                ans += abs(res)/k;\\n            }\\n            else{\\n                return -1;\\n            }\\n\\n            if(res>0){\\n                c+= res/k;\\n            }\\n            if(res<0){\\n                c1+= abs(res)/k;\\n            }\\n\\n        }\\n        if(c!=c1)return -1;\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085484,
                "title": "minimum-operations-to-make-array-equal-ii-biweekly-easy-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int size = nums1.size();\\n        if(k==0 ){\\n            if(nums1==nums2)return 0;\\n        else return -1;}\\n        vector<long long>v;\\n        // vector<long long>n;\\n        for(int i = 0; i < size ; ++i){\\n            int diff = nums1[i] - nums2[i];\\n            if(diff % k != 0 && diff != 0)return -1;\\n            v.push_back(diff);\\n            \\n        }\\n        long long sum1 = 0 ,sum2 = 0;\\n        for(int i = 0;i<v.size();++i){\\n            if(v[i]<0){v[i] *=- 1;\\n                      sum2+=v[i];}\\n            else sum1 += v[i];\\n        }\\n        if(sum1 != sum2) return -1;\\n        // if(k==0)return -1;\\n        return sum1/k;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int size = nums1.size();\\n        if(k==0 ){\\n            if(nums1==nums2)return 0;\\n        else return -1;}\\n        vector<long long>v;\\n        // vector<long long>n;\\n        for(int i = 0; i < size ; ++i){\\n            int diff = nums1[i] - nums2[i];\\n            if(diff % k != 0 && diff != 0)return -1;\\n            v.push_back(diff);\\n            \\n        }\\n        long long sum1 = 0 ,sum2 = 0;\\n        for(int i = 0;i<v.size();++i){\\n            if(v[i]<0){v[i] *=- 1;\\n                      sum2+=v[i];}\\n            else sum1 += v[i];\\n        }\\n        if(sum1 != sum2) return -1;\\n        // if(k==0)return -1;\\n        return sum1/k;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085386,
                "title": "c-counting",
                "content": "# Intuition\\nFor every operation, you are doing two things :\\n1) Subtract k from an element\\n2) Add k to **another** element\\n\\nThis means that number of additions required has to be equal to number of subtractions required for any solution to work.\\n\\n# Approach\\nFirst check if it is at all possible to reduce element in first array to element in 2nd array.\\n\\nThis can be done by checking if two elements belong to same equivalence class or not.\\n\\ni.e nums1[i]%k = nums2[i]%k\\n \\nThen we go on to calcuate number of additions and subtractions and compare them if they are equal or not.\\n\\nIn case they are equal then number of operations required = number of additions/subtractions.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long nAdd = 0;\\n        long long nSub = 0;\\n        \\n        if(k == 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(nums1[i] != nums2[i])\\n                    return -1;\\n            }\\n            return 0;\\n        }\\n        \\n        \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums1[i]%k != nums2[i]%k)\\n                return -1;\\n            else\\n            {\\n                if(nums1[i] > nums2[i])\\n                    nSub += (nums1[i] - nums2[i])/k;\\n                else\\n                    nAdd += (nums2[i] - nums1[i])/k;\\n            }\\n        }\\n        \\n        if(nSub != nAdd)\\n            return -1;\\n        \\n        return nAdd;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long nAdd = 0;\\n        long long nSub = 0;\\n        \\n        if(k == 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n            {\\n                if(nums1[i] != nums2[i])\\n                    return -1;\\n            }\\n            return 0;\\n        }\\n        \\n        \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums1[i]%k != nums2[i]%k)\\n                return -1;\\n            else\\n            {\\n                if(nums1[i] > nums2[i])\\n                    nSub += (nums1[i] - nums2[i])/k;\\n                else\\n                    nAdd += (nums2[i] - nums1[i])/k;\\n            }\\n        }\\n        \\n        if(nSub != nAdd)\\n            return -1;\\n        \\n        return nAdd;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085258,
                "title": "go-clean-solution",
                "content": "**Time complexity**: O(n) time, because we iterate multiple times on the input arrays\\n**Space complexity**: O(1), because we store computational result in nums1 \\n\\nEnjoy:\\n```\\nfunc minOperations(nums1 []int, nums2 []int, k int) int64 {\\n  if k == 0 {\\n    for i := range nums1 {\\n      if nums1[i] != nums2[i] {\\n        return -1\\n      }\\n    }\\n    return 0\\n  }\\n  \\n  // Compute k-diff, store it in nums1\\n  for i := range nums1 {\\n    diff := nums2[i] - nums1[i]\\n    if diff % k != 0 {\\n      return -1\\n    }\\n    \\n    nums1[i] = diff / k\\n  }\\n  \\n  positivesSum := 0\\n  negativesSum := 0\\n  for i := range nums1 {\\n    if nums1[i] > 0 {\\n      positivesSum += nums1[i]\\n    } else if nums1[i] < 0 {\\n      negativesSum += nums1[i]\\n    }\\n  }\\n  \\n  if positivesSum != -negativesSum {\\n    return -1\\n  }\\n  return int64(positivesSum)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minOperations(nums1 []int, nums2 []int, k int) int64 {\\n  if k == 0 {\\n    for i := range nums1 {\\n      if nums1[i] != nums2[i] {\\n        return -1\\n      }\\n    }\\n    return 0\\n  }\\n  \\n  // Compute k-diff, store it in nums1\\n  for i := range nums1 {\\n    diff := nums2[i] - nums1[i]\\n    if diff % k != 0 {\\n      return -1\\n    }\\n    \\n    nums1[i] = diff / k\\n  }\\n  \\n  positivesSum := 0\\n  negativesSum := 0\\n  for i := range nums1 {\\n    if nums1[i] > 0 {\\n      positivesSum += nums1[i]\\n    } else if nums1[i] < 0 {\\n      negativesSum += nums1[i]\\n    }\\n  }\\n  \\n  if positivesSum != -negativesSum {\\n    return -1\\n  }\\n  return int64(positivesSum)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3085074,
                "title": "c-rust-6-lines-only-o-n-100-faster-for-rust",
                "content": "**Intuition**\\n- Traverse through the array\\n\\t- If `k == 0` ensure there is no difference between items in both arrays for same index.\\n\\t- Else ensure that:\\n\\t\\t- Their total sum for difference of items in same index is zero\\n\\t\\t- After that, the result should be half of the total steps to attain that distance\\n\\n**Solution**\\n\\nC++\\n```c++\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k,\\n                            long long steps = 0, long long sum = 0) {        \\n        for (int i = 0; i < nums1.size(); i++) {\\n            auto diff = nums2[i] - nums1[i];\\n            if (k) {\\n                if (diff % k != 0) return -1;\\n                sum += diff;\\n                steps += abs(diff) / k;\\n            } else if (diff) return -1;\\n        }\\n        return sum ? -1: steps >> 1;\\n    }\\n};\\n```\\n\\nRust:\\n```rust\\nimpl Solution {\\n    pub fn min_operations(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> i64 {\\n        let (mut steps, mut sum) = (0, 0);\\n        for i in 0..nums1.len() {\\n            let diff = nums2[i] - nums1[i];\\n            if k != 0 {\\n                if diff % k != 0 { return -1; }\\n                sum += diff;\\n                steps += (diff as i64).abs() / k as i64;\\n            } else if diff != 0 { return -1; }\\n        }\\n        if sum != 0 { return -1; }\\n        steps / 2\\n    }\\n}\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k,\\n                            long long steps = 0, long long sum = 0) {        \\n        for (int i = 0; i < nums1.size(); i++) {\\n            auto diff = nums2[i] - nums1[i];\\n            if (k) {\\n                if (diff % k != 0) return -1;\\n                sum += diff;\\n                steps += abs(diff) / k;\\n            } else if (diff) return -1;\\n        }\\n        return sum ? -1: steps >> 1;\\n    }\\n};\\n```\n```rust\\nimpl Solution {\\n    pub fn min_operations(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> i64 {\\n        let (mut steps, mut sum) = (0, 0);\\n        for i in 0..nums1.len() {\\n            let diff = nums2[i] - nums1[i];\\n            if k != 0 {\\n                if diff % k != 0 { return -1; }\\n                sum += diff;\\n                steps += (diff as i64).abs() / k as i64;\\n            } else if diff != 0 { return -1; }\\n        }\\n        if sum != 0 { return -1; }\\n        steps / 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084936,
                "title": "easy-to-inderstand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long int in = 0, d = 0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(nums1[i]==nums2[i])continue;\\n            if(k==0)return -1;\\n            int x = abs(nums1[i]-nums2[i]);\\n            if(x%k)return -1;\\n            if(nums1[i]>nums2[i]){\\n                in += (x/k);\\n            }else{\\n                d += (x/k);\\n            }\\n        }\\n        if(in==d)return in;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long int in = 0, d = 0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(nums1[i]==nums2[i])continue;\\n            if(k==0)return -1;\\n            int x = abs(nums1[i]-nums2[i]);\\n            if(x%k)return -1;\\n            if(nums1[i]>nums2[i]){\\n                in += (x/k);\\n            }else{\\n                d += (x/k);\\n            }\\n        }\\n        if(in==d)return in;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083261,
                "title": "python-simple-greedy-one-linear-run",
                "content": "# Intuition\\nFind equilibrum if possible following 3 simple rules:\\n1. If k is 0, then difference between all positions in nums1 and nums2 should 0, no steps needed.\\n2. If any position diference is not divisible with k then it is not possbile to level up with k size increase or decrease work.\\n3. to reach equilibrum, sum of all diferences should be zero.\\nIf all these passes sum up positive difference divided by k, this is amount of steps need to reach equilibrum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        s = result = 0\\n        for a, b in zip(nums1, nums2):\\n            if k == 0: \\n                if a-b: return -1\\n            elif abs(a-b) % k != 0: return -1\\n            else:\\n                s += a-b\\n                if a-b > 0: result += (a-b) // k\\n\\n        return -1 if s != 0 else result\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        s = result = 0\\n        for a, b in zip(nums1, nums2):\\n            if k == 0: \\n                if a-b: return -1\\n            elif abs(a-b) % k != 0: return -1\\n            else:\\n                s += a-b\\n                if a-b > 0: result += (a-b) // k\\n\\n        return -1 if s != 0 else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082893,
                "title": "javascript-o-n-time-o-1-memory",
                "content": "```\\nvar minOperations = function(nums1, nums2, k) {\\n    \\n    let count = 0, balance = 0;\\n    \\n    for(let i = 0; i < nums1.length; i++) {\\n        \\n        const diff = nums1[i] - nums2[i];\\n        \\n        if(diff % k) return -1;\\n        \\n        if(k === 0 && diff !== 0) return -1;\\n        \\n        count += diff > 0 ? diff / k : 0;\\n        balance += diff;\\n    }\\n    \\n    return balance === 0 ? count : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar minOperations = function(nums1, nums2, k) {\\n    \\n    let count = 0, balance = 0;\\n    \\n    for(let i = 0; i < nums1.length; i++) {\\n        \\n        const diff = nums1[i] - nums2[i];\\n        \\n        if(diff % k) return -1;\\n        \\n        if(k === 0 && diff !== 0) return -1;\\n        \\n        count += diff > 0 ? diff / k : 0;\\n        balance += diff;\\n    }\\n    \\n    return balance === 0 ? count : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082805,
                "title": "c-efficient-approach-by-just-using-loops-and-arrays-efficient-code-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        //handling case of k==0&& initially arrays not equal\\n        if(k==0&&nums1!=nums2){\\n            return -1;\\n        }\\n        if(nums1==nums2){\\n            return 0;\\n        }\\n        long long s1=0,s2=0;\\n         for(auto &i:nums1){\\n            s1+=i;\\n        }\\n        for(auto &i:nums2){\\n            s2+=i;\\n        }\\n        //will be handling the -1 case here->sums not equal\\n        if(s1!=s2){\\n            return -1;\\n        }\\n        long long res=0;\\n        vector<int>ans;\\n        //now, we will store the differences between the elements at same indexes to analyse\\n        for(int i=0;i<nums1.size();i++){\\n            if(nums1[i]!=nums2[i]){\\n                ans.push_back(abs(nums2[i]-nums1[i]));\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<ans.size();i++){\\n            //exceptional cases which we wont include in the ans..\\n            if(k>ans[i]||ans[i]%k!=0){\\n                cnt++;\\n            }\\n            //to calcluate the values in ans array\\n            res+=(ans[i]/k);\\n        }\\n        //if any one value found give -1\\n        if(cnt>=1){\\n            return -1;\\n        }\\n       \\n        return res/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        //handling case of k==0&& initially arrays not equal\\n        if(k==0&&nums1!=nums2){\\n            return -1;\\n        }\\n        if(nums1==nums2){\\n            return 0;\\n        }\\n        long long s1=0,s2=0;\\n         for(auto &i:nums1){\\n            s1+=i;\\n        }\\n        for(auto &i:nums2){\\n            s2+=i;\\n        }\\n        //will be handling the -1 case here->sums not equal\\n        if(s1!=s2){\\n            return -1;\\n        }\\n        long long res=0;\\n        vector<int>ans;\\n        //now, we will store the differences between the elements at same indexes to analyse\\n        for(int i=0;i<nums1.size();i++){\\n            if(nums1[i]!=nums2[i]){\\n                ans.push_back(abs(nums2[i]-nums1[i]));\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<ans.size();i++){\\n            //exceptional cases which we wont include in the ans..\\n            if(k>ans[i]||ans[i]%k!=0){\\n                cnt++;\\n            }\\n            //to calcluate the values in ans array\\n            res+=(ans[i]/k);\\n        }\\n        //if any one value found give -1\\n        if(cnt>=1){\\n            return -1;\\n        }\\n       \\n        return res/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082520,
                "title": "python-one-iteration",
                "content": "Check if the sum of the elements in nums1 is equal to the sum of the elements in nums2, and if not, return -1.\\n\\nThe approach is to iterate through the elements of nums1 and nums2 in parallel using the zip function and check if the absolute difference between the elements is divisible by k, and add to count. If it is not, return -1.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if sum(nums1) != sum(nums2): \\n            return -1\\n        count = 0\\n        for num1, num2 in zip(nums1, nums2):\\n            if k == 0:\\n                if num1 != num2: \\n                    return -1    \\n            else:\\n                if abs(num1 - num2) % k: \\n                    return -1\\n                else:\\n                    count += abs(num1 - num2) // k\\n        return count //2\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if sum(nums1) != sum(nums2): \\n            return -1\\n        count = 0\\n        for num1, num2 in zip(nums1, nums2):\\n            if k == 0:\\n                if num1 != num2: \\n                    return -1    \\n            else:\\n                if abs(num1 - num2) % k: \\n                    return -1\\n                else:\\n                    count += abs(num1 - num2) // k\\n        return count //2\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082452,
                "title": "easy-af-for-beginners-like-me",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& a, vector<int>& b, int k) {\\n        if(k==0)\\n            return a==b?0:-1;\\n        \\n        long long add, sub;\\n        add=sub=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++){\\n            if( a[i]%k != b[i]%k )return -1;\\n            \\n            if(a[i]>b[i])\\n                sub+=((a[i]-b[i])/k);\\n            else\\n                add+=((b[i]-a[i])/k);\\n        }\\n        return (add == sub)?add:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& a, vector<int>& b, int k) {\\n        if(k==0)\\n            return a==b?0:-1;\\n        \\n        long long add, sub;\\n        add=sub=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++){\\n            if( a[i]%k != b[i]%k )return -1;\\n            \\n            if(a[i]>b[i])\\n                sub+=((a[i]-b[i])/k);\\n            else\\n                add+=((b[i]-a[i])/k);\\n        }\\n        return (add == sub)?add:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082433,
                "title": "c-o-n-solution-2-counters-method-simplest-and-easiest-code",
                "content": "# Intuition\\n\\nWe have to check whether we can make the two vectors/arrays equal or not. We can do this by considering divisibilty of difference between the consecutive elements and (k).\\n\\n# Method 1: Brute Force\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long m1=0,m2=0;\\n        for(auto x: nums1) m1+=x;    //calculate sum of nums1\\n        for(auto x: nums2) m2+=x;    //calculate sum of nums2\\n        if(k==0){         //if (k==0) then we cannot alter the array\\n            if(nums1==nums2) {   //If arrays are equal\\n                return 0;\\n            }\\n            else {               //If arrays are not equal\\n                return -1;\\n            }\\n        }\\n        if(m1!=m2){             //If sum of arrays are not equal,\\n                                //then we can\\'t make it equal\\n            return -1;\\n        }\\n        long long res=0;\\n        for(int i=0;i<n;i++){\\n            if (nums1[i] < nums2[i]) {  \\n                int diff = nums2[i] - nums1[i];  //Difference\\n                if (diff % k != 0) {     //Condition for divisibility\\n                    return -1;\\n                }\\n                res += diff / k;\\n            } \\n            else if (nums1[i] > nums2[i]) {\\n                int diff = nums1[i] - nums2[i];\\n                if (diff % k != 0) return -1;\\n                res += diff / k;\\n            }\\n        }\\n        return res/2;   //Final ans\\n    }\\n};\\n```\\n# Method 2: Optimized Code \\n# Code\\n```\\nlong long minOperations(vector<int>& a, vector<int>& b, int k) {\\n        int n=a.size();   //size of vector\\n        long long ans=0;  //ans vector\\n        long long l=0,r=0;  // 2 pointers\\n        if(k==0) return (a==b)?0:-1; //if (k==0) condition\\n        for(int i=0;i<n;i++){\\n            if(a[i]==b[i]) continue; //for equal elements\\n            int d=abs(a[i]-b[i]);    //difference of elements\\n            if(d%k!=0) return -1;    //check for divisibility by k \\n            else{\\n                if(a[i]<b[i]) l+=(d/k);   //if b[i] is greater\\n                else r+=(d/k);            //if a[i] is greater\\n            }\\n        }\\n        return (l==r)? l: -1;  //checking total sum for both vectors\\n}\\n```\\nUPVOTE guys if found useful \\uD83E\\uDD20\\uD83D\\uDE00",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        long long m1=0,m2=0;\\n        for(auto x: nums1) m1+=x;    //calculate sum of nums1\\n        for(auto x: nums2) m2+=x;    //calculate sum of nums2\\n        if(k==0){         //if (k==0) then we cannot alter the array\\n            if(nums1==nums2) {   //If arrays are equal\\n                return 0;\\n            }\\n            else {               //If arrays are not equal\\n                return -1;\\n            }\\n        }\\n        if(m1!=m2){             //If sum of arrays are not equal,\\n                                //then we can\\'t make it equal\\n            return -1;\\n        }\\n        long long res=0;\\n        for(int i=0;i<n;i++){\\n            if (nums1[i] < nums2[i]) {  \\n                int diff = nums2[i] - nums1[i];  //Difference\\n                if (diff % k != 0) {     //Condition for divisibility\\n                    return -1;\\n                }\\n                res += diff / k;\\n            } \\n            else if (nums1[i] > nums2[i]) {\\n                int diff = nums1[i] - nums2[i];\\n                if (diff % k != 0) return -1;\\n                res += diff / k;\\n            }\\n        }\\n        return res/2;   //Final ans\\n    }\\n};\\n```\n```\\nlong long minOperations(vector<int>& a, vector<int>& b, int k) {\\n        int n=a.size();   //size of vector\\n        long long ans=0;  //ans vector\\n        long long l=0,r=0;  // 2 pointers\\n        if(k==0) return (a==b)?0:-1; //if (k==0) condition\\n        for(int i=0;i<n;i++){\\n            if(a[i]==b[i]) continue; //for equal elements\\n            int d=abs(a[i]-b[i]);    //difference of elements\\n            if(d%k!=0) return -1;    //check for divisibility by k \\n            else{\\n                if(a[i]<b[i]) l+=(d/k);   //if b[i] is greater\\n                else r+=(d/k);            //if a[i] is greater\\n            }\\n        }\\n        return (l==r)? l: -1;  //checking total sum for both vectors\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082421,
                "title": "simple-fully-explained-solution-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, if nums2[i] is greater than nums1[i], we will need to do increase operation and if its negative we need to do decrease operartion. \\nOne thing we can understand is that one increase operation needed by any index can be paired together by a decrease operation of any other index and vice versa. \\nSo our main logic is going to be :\\n\\nOne plus operation will cancel one minus operation, so we maintain a counter \\'cur\\' which indicates current need of operations whether positive or negative.\\nAnd in the end, if cur is ZERO, then we can always find a solution to make arrays equal. If cur is non zero, then no matter how u try to inc or decr the numbers, it will be like a see saw operation but never be neutralized. \\n\\nIf answer exists,the answer would be : Number of operations needed by either the plus or minus operation. So in this case is stored number of minus operations in our \\'minus\\' integer. \\n\\nNumber of steps to make one index equal is ---> (nums2[i]-nums1[i])/k\\n\\nBase case : If k is zero, we cant make them equal unless they already are. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            if(nums1==nums2) return 0;\\n            return -1;\\n        }\\n        long long int minus=0;\\n        long long int ans=0; long long int cur=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long int val=nums2[i]-nums1[i];\\n            if((val)%k!=0) return -1;\\n            if(val<0) minus-=(val/k);\\n            cur+=(val/k);\\n        }\\n        if(cur) return -1;\\n        return minus;\\n    }\\n};    \\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/dd5ab0ec-c9ff-4763-97bf-0226d7b9cf66_1674321458.738556.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            if(nums1==nums2) return 0;\\n            return -1;\\n        }\\n        long long int minus=0;\\n        long long int ans=0; long long int cur=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long int val=nums2[i]-nums1[i];\\n            if((val)%k!=0) return -1;\\n            if(val<0) minus-=(val/k);\\n            cur+=(val/k);\\n        }\\n        if(cur) return -1;\\n        return minus;\\n    }\\n};    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082345,
                "title": "c-difference-vector-o-n",
                "content": "**Just Take care of the following conditions:-**\\n1. if both the arrays are equal simply return 0 .\\n2. Create a new array and just store the diffrence of nums1 and nums2(nums1-nums2)\\n3. if the accumulation of the new array is not 0 means no answer exists so return -1 or k==0 than also!\\n4. else calculate either all positive value or all negative values sum\\n5. if the new sum is divisible by k return res/k else return -1! \\n\\n**Upvote if it was helpful !**\\n```\\nclass Solution\\n{\\npublic:\\n  long long minOperations(vector<int> &nums1, vector<int> &nums2, int k)\\n  {\\n    if (nums1 == nums2)\\n      return 0;\\n    long long ans = -1;\\n    int n = nums1.size();\\n    vector<int> v(n);\\n    for (int i = 0; i < n; i++)\\n    {\\n      v[i] = nums1[i] - nums2[i];\\n    }\\n    long long sum = 0;\\n    for (auto &it : v)\\n      sum += it;\\n    if (sum != 0 || k == 0)\\n      return ans;\\n\\n    long long res = 0;\\n    for (auto &it : v)\\n    {\\n      if (it > 0)\\n        res += it;\\n    }\\n\\treturn res%k==0 ? res/k:-1;  \\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  long long minOperations(vector<int> &nums1, vector<int> &nums2, int k)\\n  {\\n    if (nums1 == nums2)\\n      return 0;\\n    long long ans = -1;\\n    int n = nums1.size();\\n    vector<int> v(n);\\n    for (int i = 0; i < n; i++)\\n    {\\n      v[i] = nums1[i] - nums2[i];\\n    }\\n    long long sum = 0;\\n    for (auto &it : v)\\n      sum += it;\\n    if (sum != 0 || k == 0)\\n      return ans;\\n\\n    long long res = 0;\\n    for (auto &it : v)\\n    {\\n      if (it > 0)\\n        res += it;\\n    }\\n\\treturn res%k==0 ? res/k:-1;  \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082293,
                "title": "c-intuition-and-approach",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought is to check if and can we actually convert, to do this we substract nums1[i] from nums2[i] and then if we get the summation as 0, it is possible(most probably), if not then no. Next task to find min operations, we add all the positive integers and then if the summation is divisible by k, then the answer is summation/k else -1.\\n\\n# Complexity\\n- Time complexity:\\nLet the size of nums1 be n\\nSince we traverse twice, complexity: O(n)+O(n) = 2*O(n) = O(n)\\n\\n- Space complexity:\\nO(1), since we use just variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long sum=0, ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            nums1[i]-=nums2[i];\\n            if(k==0 && nums1[i]) return -1;\\n            sum+=nums1[i];\\n        }\\n        if(k==0) return 0;\\n        if(sum)\\n            return -1;\\n        \\n        for(auto i:nums1){\\n            if(i>0)\\n                ans+=i;\\n        }\\n        return ans%k==0?ans/k:-1;\\n    }\\n};\\n```\\n\\nUpvote if this helps! Cheers!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long sum=0, ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            nums1[i]-=nums2[i];\\n            if(k==0 && nums1[i]) return -1;\\n            sum+=nums1[i];\\n        }\\n        if(k==0) return 0;\\n        if(sum)\\n            return -1;\\n        \\n        for(auto i:nums1){\\n            if(i>0)\\n                ans+=i;\\n        }\\n        return ans%k==0?ans/k:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082282,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> v;\\n        int n=nums1.size();\\n        int long sum1=0,sum2=0;\\n       long long  int count=0;\\n        for(int i=0; i<n; i++){\\n             sum1+=nums1[i];\\n             sum2+=nums2[i];\\n            int m=abs(nums1[i]-nums2[i]);\\n            v.push_back(m);\\n            if(m==0){count++;}\\n        }\\n        if(count==n){return 0;}\\n        if(k==0&&count==n){return 0;}\\n        if(k==0&&count!=n){return -1;}\\n        if(sum1!=sum2){return -1;}\\n        int l=v.size()-count;\\n        \\n       long int i=0,j=0;\\n         count=0;\\n    while(i<v.size()){\\n        if(v[i]%k==0&&v[i]!=0){\\n            count+=v[i]/k;\\n            l--;\\n        }\\n        i++;\\n    }\\n     if(l==0){return count/2;}\\n     \\n        return -1;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> v;\\n        int n=nums1.size();\\n        int long sum1=0,sum2=0;\\n       long long  int count=0;\\n        for(int i=0; i<n; i++){\\n             sum1+=nums1[i];\\n             sum2+=nums2[i];\\n            int m=abs(nums1[i]-nums2[i]);\\n            v.push_back(m);\\n            if(m==0){count++;}\\n        }\\n        if(count==n){return 0;}\\n        if(k==0&&count==n){return 0;}\\n        if(k==0&&count!=n){return -1;}\\n        if(sum1!=sum2){return -1;}\\n        int l=v.size()-count;\\n        \\n       long int i=0,j=0;\\n         count=0;\\n    while(i<v.size()){\\n        if(v[i]%k==0&&v[i]!=0){\\n            count+=v[i]/k;\\n            l--;\\n        }\\n        i++;\\n    }\\n     if(l==0){return count/2;}\\n     \\n        return -1;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082254,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long sum =0 ;\\n        \\n        for(auto x: nums1){\\n            sum+=x ;\\n        }\\n        for(auto x: nums2){\\n            sum-=x ;\\n        }\\n        if(sum!=0) return -1 ;\\n        if(nums1==nums2) return 0 ;\\n        if(k==0) return -1 ;\\n        for(int i=0;i<nums1.size();i++){\\n            \\n            int x= abs(nums1[i]-nums2[i]);\\n            if(x%k!=0) return -1 ;\\n        }\\n        \\n        long long int p=0;\\n        long long int q=0 ;\\n        for(int i=0;i<nums1.size();i++){\\n            if(nums1[i]>nums2[i]) p+= (nums1[i]-nums2[i])/k ;\\n            else q+= (nums2[i]-nums1[i])/k ;\\n        }\\n        if(p!=q) return -1 ;\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long sum =0 ;\\n        \\n        for(auto x: nums1){\\n            sum+=x ;\\n        }\\n        for(auto x: nums2){\\n            sum-=x ;\\n        }\\n        if(sum!=0) return -1 ;\\n        if(nums1==nums2) return 0 ;\\n        if(k==0) return -1 ;\\n        for(int i=0;i<nums1.size();i++){\\n            \\n            int x= abs(nums1[i]-nums2[i]);\\n            if(x%k!=0) return -1 ;\\n        }\\n        \\n        long long int p=0;\\n        long long int q=0 ;\\n        for(int i=0;i<nums1.size();i++){\\n            if(nums1[i]>nums2[i]) p+= (nums1[i]-nums2[i])/k ;\\n            else q+= (nums2[i]-nums1[i])/k ;\\n        }\\n        if(p!=q) return -1 ;\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082183,
                "title": "easy-simple-c-o-n-o-1-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust maintain two values increase and decrease and then at last check if sum of both them are 0 then check if increase%k == 0 if it is then no. of operation will be increase/k.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust maintain two values increase and decrease and then at last check if sum of both them are 0 then check if increase%k == 0 if it is then no. of operation will be increase/k.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        if(k == 0)\\n            return nums1 == nums2 ? 0 : -1;\\n\\n        long long increase = 0;\\n        long long decrease = 0;\\n\\n        for(int i = 0; i<nums1.size(); i++){\\n            int target = (nums1[i]-nums2[i]);\\n            if(target > 0){\\n                increase += target;\\n            } else {\\n                decrease += target;\\n            }\\n        }\\n        if( (increase + decrease) == 0){\\n            if(increase%k == 0){\\n                return increase/k;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        if(k == 0)\\n            return nums1 == nums2 ? 0 : -1;\\n\\n        long long increase = 0;\\n        long long decrease = 0;\\n\\n        for(int i = 0; i<nums1.size(); i++){\\n            int target = (nums1[i]-nums2[i]);\\n            if(target > 0){\\n                increase += target;\\n            } else {\\n                decrease += target;\\n            }\\n        }\\n        if( (increase + decrease) == 0){\\n            if(increase%k == 0){\\n                return increase/k;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082139,
                "title": "brute-force-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) \\n    {           \\n        if(nums1 == nums2)\\n            return 0;\\n        \\n        if( nums1 != nums2 && k == 0 ){\\n            return -1;\\n        }\\n        \\n        long long dif=0;\\n        long long summ=0;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if( abs(nums1[i]-nums2[i]) % k !=0 )\\n                return -1;\\n            \\n            dif = dif + (nums1[i]-nums2[i]);\\n            summ= summ+ abs(nums1[i]-nums2[i])/k;\\n        }\\n        if(dif!=0)\\n            return -1;\\n        return summ/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) \\n    {           \\n        if(nums1 == nums2)\\n            return 0;\\n        \\n        if( nums1 != nums2 && k == 0 ){\\n            return -1;\\n        }\\n        \\n        long long dif=0;\\n        long long summ=0;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if( abs(nums1[i]-nums2[i]) % k !=0 )\\n                return -1;\\n            \\n            dif = dif + (nums1[i]-nums2[i]);\\n            summ= summ+ abs(nums1[i]-nums2[i])/k;\\n        }\\n        if(dif!=0)\\n            return -1;\\n        return summ/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082127,
                "title": "c-basic-checks",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            for(int i=0;i<nums1.size();i++){\\n                if(nums1[i]!=nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        long long sum1=0,sum2=0;\\n        for(auto i : nums1){\\n            sum1 += i;\\n        }\\n        for(auto i : nums2){\\n            sum2 += i;\\n        }\\n        if(sum1 != sum2 || nums1.size() != nums2.size()) return -1;\\n        long long ans=0,cnt=0;\\n        for(int i=0;i<nums1.size();i++){\\n            if(nums1[i]!=nums2[i]){\\n                if(nums1[i]>nums2[i] && (nums1[i]-nums2[i])%k == 0){\\n                    ans += (nums1[i]-nums2[i])/k;\\n                    cnt += (nums1[i]-nums2[i]);\\n                }else if(nums1[i]<nums2[i] && (nums2[i]-nums1[i])%k==0){\\n                    ans += (nums2[i]-nums1[i])/k;\\n                    cnt += (nums1[i]-nums2[i]);\\n                }else{\\n                    return -1;\\n                }\\n            }\\n        }\\n        if(cnt != 0) return -1;\\n        return ans/2;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            for(int i=0;i<nums1.size();i++){\\n                if(nums1[i]!=nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        long long sum1=0,sum2=0;\\n        for(auto i : nums1){\\n            sum1 += i;\\n        }\\n        for(auto i : nums2){\\n            sum2 += i;\\n        }\\n        if(sum1 != sum2 || nums1.size() != nums2.size()) return -1;\\n        long long ans=0,cnt=0;\\n        for(int i=0;i<nums1.size();i++){\\n            if(nums1[i]!=nums2[i]){\\n                if(nums1[i]>nums2[i] && (nums1[i]-nums2[i])%k == 0){\\n                    ans += (nums1[i]-nums2[i])/k;\\n                    cnt += (nums1[i]-nums2[i]);\\n                }else if(nums1[i]<nums2[i] && (nums2[i]-nums1[i])%k==0){\\n                    ans += (nums2[i]-nums1[i])/k;\\n                    cnt += (nums1[i]-nums2[i]);\\n                }else{\\n                    return -1;\\n                }\\n            }\\n        }\\n        if(cnt != 0) return -1;\\n        return ans/2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082107,
                "title": "easy-short-efficient-clean-code",
                "content": "```c++\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    long long minOperations(vector<int>&u, vector<int>&v, int k) {\\n        if(k==0){\\n            return (u==v?0:-1);\\n        }\\n        ll sz=u.size(), p=0, n=0; // +ve and -ve diffs\\n        for(ll i=0;i<sz;++i){\\n            ll dis=abs(u[i]-v[i]);\\n            if(dis%k){ // can never be made 0\\n                return -1;\\n            }\\n            if(u[i]>v[i]){\\n                p+=dis;\\n            }\\n            else{\\n                n+=dis;\\n            }\\n        }\\n        // if total number of extras are not the same as the total number of deficiencies, there can never be a balance\\n        return ( p == n ? p/k : -1 ); // total / unit size == number of units\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    long long minOperations(vector<int>&u, vector<int>&v, int k) {\\n        if(k==0){\\n            return (u==v?0:-1);\\n        }\\n        ll sz=u.size(), p=0, n=0; // +ve and -ve diffs\\n        for(ll i=0;i<sz;++i){\\n            ll dis=abs(u[i]-v[i]);\\n            if(dis%k){ // can never be made 0\\n                return -1;\\n            }\\n            if(u[i]>v[i]){\\n                p+=dis;\\n            }\\n            else{\\n                n+=dis;\\n            }\\n        }\\n        // if total number of extras are not the same as the total number of deficiencies, there can never be a balance\\n        return ( p == n ? p/k : -1 ); // total / unit size == number of units\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082026,
                "title": "take-care-of-zero",
                "content": "```\\nclass Solution \\n{\\n    public long minOperations(int[] nums1, int[] nums2, int k)\\n    {\\n        int n = nums1.length;\\n        long pos=0,neg=0,eq=0;\\n        for(int i= 0 ; i < n ;i++)\\n        {\\n            int diff= nums1[i]-nums2[i];\\n            if(nums1[i] == nums2[i]) eq++;\\n            if(k!=0 && diff<0) neg+= Math.abs(diff)/k; // no of negative operations \\n            if(k!=0 && diff>0) pos+= Math.abs(diff)/k; // no of positive operations \\n            if(k!=0 && Math.abs(diff) % k !=0 ) return -1; \\n        }\\n        if(k == 0 && eq == n) return 0; \\n        if(k == 0 && eq!= n) return -1; \\n        if(pos == neg) return pos;  \\n        else return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public long minOperations(int[] nums1, int[] nums2, int k)\\n    {\\n        int n = nums1.length;\\n        long pos=0,neg=0,eq=0;\\n        for(int i= 0 ; i < n ;i++)\\n        {\\n            int diff= nums1[i]-nums2[i];\\n            if(nums1[i] == nums2[i]) eq++;\\n            if(k!=0 && diff<0) neg+= Math.abs(diff)/k; // no of negative operations \\n            if(k!=0 && diff>0) pos+= Math.abs(diff)/k; // no of positive operations \\n            if(k!=0 && Math.abs(diff) % k !=0 ) return -1; \\n        }\\n        if(k == 0 && eq == n) return 0; \\n        if(k == 0 && eq!= n) return -1; \\n        if(pos == neg) return pos;  \\n        else return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073839,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n        if (k == 0) return n1 == n2 ? 0 : -1;\\n        long long ans = 0, numUp = 0, numDown = 0;\\n        for (int i = 0; i < n1.size(); ++i){\\n            if ((n1[i] - n2[i]) % k != 0) return -1;\\n            int dif = abs(n2[i] - n1[i]) / k;\\n            if (n1[i] < n2[i]) numUp += dif;\\n            else numDown += dif;\\n            ans += dif;\\n        }\\n        return numUp == numDown ? ans / 2 : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n        if (k == 0) return n1 == n2 ? 0 : -1;\\n        long long ans = 0, numUp = 0, numDown = 0;\\n        for (int i = 0; i < n1.size(); ++i){\\n            if ((n1[i] - n2[i]) % k != 0) return -1;\\n            int dif = abs(n2[i] - n1[i]) / k;\\n            if (n1[i] < n2[i]) numUp += dif;\\n            else numDown += dif;\\n            ans += dif;\\n        }\\n        return numUp == numDown ? ans / 2 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985522,
                "title": "greedy-counting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        using LL = long long;\\n        LL s1, s2;\\n\\n        s1 = accumulate(nums1.begin(), nums1.end(), 0LL);\\n        s2 = accumulate(nums2.begin(), nums2.end(), 0LL);\\n\\n        if (s1 != s2)\\n        return -1;\\n\\n        if (k == 0)\\n        return nums1 == nums2 ? 0 : -1;\\n\\n        LL r1, r2;\\n        r1 = r2 = 0;\\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            int d = nums1[i] - nums2[i];\\n            if (d % k != 0) return -1;\\n            else if (d > 0)\\n            r1 += d/k;\\n            else if (d < 0)\\n            r2 += d/k;\\n        }\\n        \\n        return (r1 + r2) ? -1 : r1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        using LL = long long;\\n        LL s1, s2;\\n\\n        s1 = accumulate(nums1.begin(), nums1.end(), 0LL);\\n        s2 = accumulate(nums2.begin(), nums2.end(), 0LL);\\n\\n        if (s1 != s2)\\n        return -1;\\n\\n        if (k == 0)\\n        return nums1 == nums2 ? 0 : -1;\\n\\n        LL r1, r2;\\n        r1 = r2 = 0;\\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            int d = nums1[i] - nums2[i];\\n            if (d % k != 0) return -1;\\n            else if (d > 0)\\n            r1 += d/k;\\n            else if (d < 0)\\n            r2 += d/k;\\n        }\\n        \\n        return (r1 + r2) ? -1 : r1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983787,
                "title": "java-solution-based-on-math-principles-beats-100-in-time-comparison",
                "content": "# Intuition\\nmy first thought was trying to think when it isn\\'t possible that both arrays will be equal?\\nto visual this i thought of a graph. where for every i, f(i) = nums1[i]-nums2[i]. \\nThen i thought that i need that sum(f(i))==0.\\nX = [f(i)| f(i) > 0].\\nY = [f(i)| f(i) < 0]\\nthan: sum(X) + sum(Y) == 0 -> sum(X) == -sum(Y).\\nalso, for every f(i) since it will be added or decreased by k, must hold: f(i) % k == 0.\\n\\nso two request are made-\\n 1. For all i such that: nums1[i]-nums2[i] % k != 0. \\n 2. possetiveSum == negetiveSum: for all f(i) > 0 -> sum(f(i)) = possetiveSum, for all f(i) < 0 -> sum(f(i)) = negetiveSum. \\n\\n# Approach\\nThe solution is very simple once this obbservatin is made. just go over the arrays simuntainecly and check the requests hold.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        /**\\n        it will be possible only if \\n        for every 0<=i<=n nums1[i]-nums2[i] % k == 0 ;\\n        && \\n        sum(nums1[i]-nums2[i]) == 0\\n        algo- if both request are met. then devide the possitive sum of nums1-nums2 by k.\\n         */\\n        long possitiveSum = 0;\\n        long negetiveSum = 0;\\n        int len = nums1.length-1;\\n        int temp;\\n        if( k != 0){\\n            for(; 0 <= len ; len--){\\n                temp = nums1[len] - nums2[len];\\n\\n                if(temp % k != 0){\\n                    return -1;\\n                }\\n                if( temp > 0){\\n                \\n                    possitiveSum += temp;\\n                }\\n                else{\\n                \\n                    negetiveSum += temp;\\n                }\\n            }\\n            if(possitiveSum == -negetiveSum){\\n                return possitiveSum / k;\\n            }\\n            return -1;\\n               \\n        }\\n        else{\\n            for(; 0 <= len ; len--){\\n                if(nums1[len] != nums2[len]){\\n                    return -1;\\n                }\\n            }\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        /**\\n        it will be possible only if \\n        for every 0<=i<=n nums1[i]-nums2[i] % k == 0 ;\\n        && \\n        sum(nums1[i]-nums2[i]) == 0\\n        algo- if both request are met. then devide the possitive sum of nums1-nums2 by k.\\n         */\\n        long possitiveSum = 0;\\n        long negetiveSum = 0;\\n        int len = nums1.length-1;\\n        int temp;\\n        if( k != 0){\\n            for(; 0 <= len ; len--){\\n                temp = nums1[len] - nums2[len];\\n\\n                if(temp % k != 0){\\n                    return -1;\\n                }\\n                if( temp > 0){\\n                \\n                    possitiveSum += temp;\\n                }\\n                else{\\n                \\n                    negetiveSum += temp;\\n                }\\n            }\\n            if(possitiveSum == -negetiveSum){\\n                return possitiveSum / k;\\n            }\\n            return -1;\\n               \\n        }\\n        else{\\n            for(; 0 <= len ; len--){\\n                if(nums1[len] != nums2[len]){\\n                    return -1;\\n                }\\n            }\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974550,
                "title": "easy-to-understand-c-beats-91-in-time",
                "content": "\\n\\n# Approach\\n- if sum of arrays is not equal return -1. (as we are adding subtracting k, so sum should be same)\\n- if difference between elements is not divisible by k, return -1, since we can only add or subtrack k in each operation.\\n- else, calculate the differece/k (calculates the operations required) for all the elements, and divide by 2, and return it.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(!k) return nums1 == nums2?0:-1;\\n        long long s =0;\\n        int n = nums1.size();\\n        long long ans =0;\\n        for(int i =0;i<n;i++){\\n            s+= nums1[i];\\n            s-=nums2[i];\\n            if(abs(nums1[i]-nums2[i])%k!=0) return -1;\\n            else{\\n                ans+= abs(nums1[i]-nums2[i])/k;\\n            }\\n        }\\n        if(s) return -1;\\n        return ans%2?-1:ans/2;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(!k) return nums1 == nums2?0:-1;\\n        long long s =0;\\n        int n = nums1.size();\\n        long long ans =0;\\n        for(int i =0;i<n;i++){\\n            s+= nums1[i];\\n            s-=nums2[i];\\n            if(abs(nums1[i]-nums2[i])%k!=0) return -1;\\n            else{\\n                ans+= abs(nums1[i]-nums2[i])/k;\\n            }\\n        }\\n        if(s) return -1;\\n        return ans%2?-1:ans/2;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955108,
                "title": "golang-simple-solution",
                "content": "# Code\\n```go\\nfunc minOperations(nums1 []int, nums2 []int, k int) int64 {\\n\\tif k == 0 {\\n\\t\\tif reflect.DeepEqual(nums1, nums2) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\treturn -1\\n\\t}\\n\\tpositive, negative := 0, 0\\n\\tfor i := range nums1 {\\n\\t\\tdiff := nums1[i] - nums2[i]\\n\\t\\tif diff % k != 0 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\tif diff == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif diff > 0 {\\n\\t\\t\\tpositive += diff/k\\n\\t\\t} else {\\n\\t\\t\\tnegative -= diff/k\\n\\t\\t}\\n\\t}\\n\\tif positive != negative {\\n\\t\\treturn -1\\n\\t}\\n\\treturn int64(positive)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minOperations(nums1 []int, nums2 []int, k int) int64 {\\n\\tif k == 0 {\\n\\t\\tif reflect.DeepEqual(nums1, nums2) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\treturn -1\\n\\t}\\n\\tpositive, negative := 0, 0\\n\\tfor i := range nums1 {\\n\\t\\tdiff := nums1[i] - nums2[i]\\n\\t\\tif diff % k != 0 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\tif diff == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif diff > 0 {\\n\\t\\t\\tpositive += diff/k\\n\\t\\t} else {\\n\\t\\t\\tnegative -= diff/k\\n\\t\\t}\\n\\t}\\n\\tif positive != negative {\\n\\t\\treturn -1\\n\\t}\\n\\treturn int64(positive)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937440,
                "title": "java-o-n-100-faster-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            for (int i = 0; i < nums1.length; i++) \\n                if (nums1[i] != nums2[i]) return -1;\\n            return 0;\\n        }\\n        long toSubstract = 0, toAdd = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            int diff = nums2[i] - nums1[i];\\n            if (diff % k != 0) return -1;\\n            if (diff > 0) toAdd += diff;\\n            else toSubstract += -diff;\\n        }\\n        \\n        if (toAdd != toSubstract) return -1;\\n        return toAdd / k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            for (int i = 0; i < nums1.length; i++) \\n                if (nums1[i] != nums2[i]) return -1;\\n            return 0;\\n        }\\n        long toSubstract = 0, toAdd = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            int diff = nums2[i] - nums1[i];\\n            if (diff % k != 0) return -1;\\n            if (diff > 0) toAdd += diff;\\n            else toSubstract += -diff;\\n        }\\n        \\n        if (toAdd != toSubstract) return -1;\\n        return toAdd / k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862644,
                "title": "easy-intuitive-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long cnt = 0;\\n        long long ans = 0;\\n        long long pos=0,neg=0;\\n        if(k==0)\\n            return nums1==nums2?0:-1;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(abs(nums1[i]-nums2[i])%k !=0)\\n                return -1;\\n            \\n            ans += (1LL*nums1[i]-1LL*nums2[i])/k;\\n            if(nums1[i]>nums2[i]) pos += (1LL*nums1[i]-1LL*nums2[i])/k;\\n            else neg += (1LL*nums2[i]-1LL*nums1[i])/k;\\n            cnt = max(cnt,max(pos,abs(neg)));\\n        }\\n        return ans==0?cnt:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long cnt = 0;\\n        long long ans = 0;\\n        long long pos=0,neg=0;\\n        if(k==0)\\n            return nums1==nums2?0:-1;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(abs(nums1[i]-nums2[i])%k !=0)\\n                return -1;\\n            \\n            ans += (1LL*nums1[i]-1LL*nums2[i])/k;\\n            if(nums1[i]>nums2[i]) pos += (1LL*nums1[i]-1LL*nums2[i])/k;\\n            else neg += (1LL*nums2[i]-1LL*nums1[i])/k;\\n            cnt = max(cnt,max(pos,abs(neg)));\\n        }\\n        return ans==0?cnt:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840459,
                "title": "ruby-o-n",
                "content": "```ruby\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @param {Integer} k\\n# @return {Integer}\\ndef min_operations(nums1, nums2, k)\\n  return (nums1 == nums2 ? 0 : -1) if k == 0\\n  return -1 if nums1.sum != nums2.sum\\n  res = 0\\n  for idx in 0...nums1.length\\n    diff = nums1[idx] - nums2[idx]\\n    return -1 if diff % k != 0\\n    res += diff / k if diff > 0\\n  end\\n  res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @param {Integer} k\\n# @return {Integer}\\ndef min_operations(nums1, nums2, k)\\n  return (nums1 == nums2 ? 0 : -1) if k == 0\\n  return -1 if nums1.sum != nums2.sum\\n  res = 0\\n  for idx in 0...nums1.length\\n    diff = nums1[idx] - nums2[idx]\\n    return -1 if diff % k != 0\\n    res += diff / k if diff > 0\\n  end\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3807004,
                "title": "accumulative-differences",
                "content": "# Intuition\\nIterate through the elements for each difference calculate the ops and keep track the accumulated diffs.\\nIf you like my solution please vote, thanks!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, a1: List[int], a2: List[int], k: int) -> int:\\n        if k == 0:\\n            return 0 if a1 == a2 else -1\\n        n, r, diff, allDiffs = len(a1), 0, 0, 0\\n        for i in range(n):\\n            diff = a1[i] - a2[i]\\n            if diff:\\n                if diff % k:\\n                    return -1\\n                if diff > 0:\\n                    r += diff // k\\n                allDiffs += diff\\n        return r if allDiffs == 0 else -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, a1: List[int], a2: List[int], k: int) -> int:\\n        if k == 0:\\n            return 0 if a1 == a2 else -1\\n        n, r, diff, allDiffs = len(a1), 0, 0, 0\\n        for i in range(n):\\n            diff = a1[i] - a2[i]\\n            if diff:\\n                if diff % k:\\n                    return -1\\n                if diff > 0:\\n                    r += diff // k\\n                allDiffs += diff\\n        return r if allDiffs == 0 else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733974,
                "title": "rust-python-linear-time-constant-space-with-explanation",
                "content": "# Intuition\\n\\nlets look at the obvious edge case first. If `k == 0`, then the only way me can make them equal if they are equal already.\\n\\nIf the first elements of arrays are `a` and `b`. The only way to modify `a` to make it equal to `b` is to add or remove `k` a few times. More specifically `(a - b) / k` times. And if `a - b` not divisible by `k`, then this is not possible.\\n\\nThis is almost the whole process. You iterate over all of the positions and store the absolute values of those changes. In the end you divide them by two. The only other important addition that the values we add and remove should at the end be equal to zero. So we check it at the end\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn min_operations(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> i64 {\\n    let n = nums1.len();\\n    if k == 0 {\\n      for i in 0 .. n {\\n        if nums1[i] != nums2[i] {\\n          return -1;\\n        }\\n      }\\n      return 0;\\n    }\\n\\n    let (mut res, mut remainder) = (0, 0);\\n    for i in 0 .. n {\\n      let diff = nums1[i] - nums2[i];\\n      if diff % k != 0 {\\n        return -1;\\n      }\\n\\n      let v = (diff / k) as i64;\\n      res += v.abs();\\n      remainder += v;\\n    }\\n\\n    if remainder == 0 {\\n      return res / 2;\\n    }\\n    return -1;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n    if k == 0:\\n      return 0 if nums1 == nums2 else -1\\n\\n    res, remainder = 0, 0\\n    for v1, v2 in zip(nums1, nums2):\\n      diff = v1 - v2\\n      if diff % k != 0:\\n        return -1\\n      \\n      v = diff //k\\n      res += abs(v)\\n      remainder += v\\n    \\n    if remainder == 0:\\n      return res // 2\\n    \\n    return -1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn min_operations(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> i64 {\\n    let n = nums1.len();\\n    if k == 0 {\\n      for i in 0 .. n {\\n        if nums1[i] != nums2[i] {\\n          return -1;\\n        }\\n      }\\n      return 0;\\n    }\\n\\n    let (mut res, mut remainder) = (0, 0);\\n    for i in 0 .. n {\\n      let diff = nums1[i] - nums2[i];\\n      if diff % k != 0 {\\n        return -1;\\n      }\\n\\n      let v = (diff / k) as i64;\\n      res += v.abs();\\n      remainder += v;\\n    }\\n\\n    if remainder == 0 {\\n      return res / 2;\\n    }\\n    return -1;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n    if k == 0:\\n      return 0 if nums1 == nums2 else -1\\n\\n    res, remainder = 0, 0\\n    for v1, v2 in zip(nums1, nums2):\\n      diff = v1 - v2\\n      if diff % k != 0:\\n        return -1\\n      \\n      v = diff //k\\n      res += abs(v)\\n      remainder += v\\n    \\n    if remainder == 0:\\n      return res // 2\\n    \\n    return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721903,
                "title": "python-3-o-n-with-explanation-and-comments",
                "content": "# Approach\\n- Each +k operation must be offset by a -k operation\\n- Therefore, the number of operations where we add k must be equal to the operations where we subtract k\\n- Edge cases: Arrays already equal or k is 0\\n\\n# Approach\\n\\n- Calculate the difference between integers at each array position\\n- Add the difference to our positive/negative integer based on its sign\\n- Check if this difference is divisible by k. Return -1 if not\\n- At end, return positive // k which is the number of operations required\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n\\n        n = len(nums1)\\n        positive = negative = 0\\n\\n        # check if two arrays are already equal\\n        if nums1 == nums2:\\n            return 0\\n\\n        # if k == 0 and lists were not equal, case is impossible\\n        if not k:\\n            return -1\\n\\n        for i in range(n):\\n            diff = nums1[i] - nums2[i]\\n\\n            # sum up negative and positive differences\\n            if diff > 0:\\n                positive += diff\\n            elif diff < 0:\\n                negative += diff\\n            \\n            # if difference is not divisible by k, case is impossible\\n            if diff % k != 0:\\n                return -1\\n        \\n        # check negative difference = positive difference, and that it is divisible by k\\n        if positive != abs(negative) or positive % k:\\n            return -1\\n        \\n        return positive // k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n\\n        n = len(nums1)\\n        positive = negative = 0\\n\\n        # check if two arrays are already equal\\n        if nums1 == nums2:\\n            return 0\\n\\n        # if k == 0 and lists were not equal, case is impossible\\n        if not k:\\n            return -1\\n\\n        for i in range(n):\\n            diff = nums1[i] - nums2[i]\\n\\n            # sum up negative and positive differences\\n            if diff > 0:\\n                positive += diff\\n            elif diff < 0:\\n                negative += diff\\n            \\n            # if difference is not divisible by k, case is impossible\\n            if diff % k != 0:\\n                return -1\\n        \\n        # check negative difference = positive difference, and that it is divisible by k\\n        if positive != abs(negative) or positive % k:\\n            return -1\\n        \\n        return positive // k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715869,
                "title": "100-faster-than-all",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        ios_base::sync_with_stdio(0), cin.tie(0);\\n        \\n        if(k==0){\\n            if(nums1==nums2)\\n                return 0;\\n            else\\n                return -1;\\n        }\\n        \\n        long long sum=0;\\n        long long diff;\\n        long long step=0;\\n        for(int i=0;i<nums1.size();i++){\\n              diff = nums1[i] - nums2[i];\\n             if(diff%k!=0)\\n                 return -1;\\n             sum+=diff;\\n             step+=(abs(diff)/k);\\n        }\\n        if(sum!=0)\\n            return -1;\\n        return step/2;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        ios_base::sync_with_stdio(0), cin.tie(0);\\n        \\n        if(k==0){\\n            if(nums1==nums2)\\n                return 0;\\n            else\\n                return -1;\\n        }\\n        \\n        long long sum=0;\\n        long long diff;\\n        long long step=0;\\n        for(int i=0;i<nums1.size();i++){\\n              diff = nums1[i] - nums2[i];\\n             if(diff%k!=0)\\n                 return -1;\\n             sum+=diff;\\n             step+=(abs(diff)/k);\\n        }\\n        if(sum!=0)\\n            return -1;\\n        return step/2;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684907,
                "title": "beats-80-easy-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long inc = 0;\\n        long long dec = 0;\\n        for(int i = 0; i<nums1.size(); i++){\\n            if(k == 0){\\n                if(nums1[i] != nums2[i]) return -1;\\n            }\\n            else {\\n                if(nums1[i] < nums2[i]){\\n                    if((nums2[i] - nums1[i])%k) return -1;\\n                    else inc += (nums2[i] - nums1[i])/k;\\n                }\\n                else if(nums1[i] > nums2[i]){\\n                    if((nums1[i] - nums2[i])%k) return -1;\\n                    else dec += (nums1[i] - nums2[i])/k;\\n                }\\n            }\\n        }\\n        if(inc!=dec) return -1;\\n        else return inc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long inc = 0;\\n        long long dec = 0;\\n        for(int i = 0; i<nums1.size(); i++){\\n            if(k == 0){\\n                if(nums1[i] != nums2[i]) return -1;\\n            }\\n            else {\\n                if(nums1[i] < nums2[i]){\\n                    if((nums2[i] - nums1[i])%k) return -1;\\n                    else inc += (nums2[i] - nums1[i])/k;\\n                }\\n                else if(nums1[i] > nums2[i]){\\n                    if((nums1[i] - nums2[i])%k) return -1;\\n                    else dec += (nums1[i] - nums2[i])/k;\\n                }\\n            }\\n        }\\n        if(inc!=dec) return -1;\\n        else return inc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666960,
                "title": "very-easy-explanation-beats-99-positive-negative-count-beginner-approach",
                "content": "# Intuition\\nWe have to only keep track of positive and negative differences\\n\\n# Approach\\nJust look into code and try to dry run\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0) //if k is 0 then check for equality of both if they are equal then return 0\\n        {\\n            \\n            if(nums1==nums2) return 0; \\n            return -1;//addition and subtraction of 0 will have no effect on elements\\n        }\\n        \\n        //pos stores positive difference of nums1[i] and nums2[i] \\n        //neg stores negative difference of nums1[i] and nums2[i]\\n        // another way :=>another imp obs is the summation of all elemnts of nums2 should\\n        //be equal to  the summation of all elemnts of nums1 ,then only they can \\n        //be modified to make them equal\\n        \\n        long long pos=0, neg=0; \\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            if(nums1[i] >= nums2[i])\\n            {\\n                //if their difference is divided by k then its possible to make them equal\\n                if((nums1[i]-nums2[i])%k==0) \\n                    pos += nums1[i]-nums2[i];\\n                else\\n                    return -1;\\n            } \\n            else \\n            {\\n                //if their difference is divided by k then its possible to make them equal\\n                if((nums2[i]-nums1[i])%k==0)\\n                    neg += nums2[i]-nums1[i];\\n                else\\n                    return -1;\\n            }\\n        }\\n        \\n        long long ans=-1;\\n        //if both difference(p_diff,n_diff) are equal, we can make nums1 equals to nums2\\n        //so that during pairing we can take same add and same subtraction hence condition\\n        //is we have to always take in pair for addition and subtraction\\n        //so posdiff should be equal to negdiff\\n        if(pos==neg) ans = (pos/k);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0) //if k is 0 then check for equality of both if they are equal then return 0\\n        {\\n            \\n            if(nums1==nums2) return 0; \\n            return -1;//addition and subtraction of 0 will have no effect on elements\\n        }\\n        \\n        //pos stores positive difference of nums1[i] and nums2[i] \\n        //neg stores negative difference of nums1[i] and nums2[i]\\n        // another way :=>another imp obs is the summation of all elemnts of nums2 should\\n        //be equal to  the summation of all elemnts of nums1 ,then only they can \\n        //be modified to make them equal\\n        \\n        long long pos=0, neg=0; \\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            if(nums1[i] >= nums2[i])\\n            {\\n                //if their difference is divided by k then its possible to make them equal\\n                if((nums1[i]-nums2[i])%k==0) \\n                    pos += nums1[i]-nums2[i];\\n                else\\n                    return -1;\\n            } \\n            else \\n            {\\n                //if their difference is divided by k then its possible to make them equal\\n                if((nums2[i]-nums1[i])%k==0)\\n                    neg += nums2[i]-nums1[i];\\n                else\\n                    return -1;\\n            }\\n        }\\n        \\n        long long ans=-1;\\n        //if both difference(p_diff,n_diff) are equal, we can make nums1 equals to nums2\\n        //so that during pairing we can take same add and same subtraction hence condition\\n        //is we have to always take in pair for addition and subtraction\\n        //so posdiff should be equal to negdiff\\n        if(pos==neg) ans = (pos/k);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665249,
                "title": "clean-and-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& v1, vector<int>& v2, int k) {\\n        if(k == 0) return v1 == v2 ? 0 : -1;\\n        int n = v1.size();\\n        long long count = 0, sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            long long diff = v1[i] - v2[i];\\n            if(diff % k) return -1;\\n            if(diff > 0) count += (diff / k);\\n            sum += diff;\\n        }\\n        return sum == 0 ? count : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& v1, vector<int>& v2, int k) {\\n        if(k == 0) return v1 == v2 ? 0 : -1;\\n        int n = v1.size();\\n        long long count = 0, sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            long long diff = v1[i] - v2[i];\\n            if(diff % k) return -1;\\n            if(diff > 0) count += (diff / k);\\n            sum += diff;\\n        }\\n        return sum == 0 ? count : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570468,
                "title": "beats-100-easy-solution-js-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize two variables, count and balance, to keep track of the count of valid differences and the overall balance, respectively.\\n\\nStart a loop that iterates over the elements of the nums1 array using the index variable i.\\n\\nCalculate the difference between the corresponding elements of nums1 and nums2 arrays and store it in the variable diff. This step determines the difference between the two numbers at the same index.\\n\\nCheck if the remainder of diff divided by k is non-zero. If the condition is true, it means that the difference is not divisible by k, and the function immediately returns -1, indicating an invalid result.\\n\\nCheck if k is equal to 0 and diff is non-zero. If both conditions are true, it means that k is 0, and dividing by zero is not allowed. In this case, the function returns -1, indicating an invalid result.\\n\\nUpdate the count variable by adding the division of diff by k, but only if diff is greater than 0. This step accumulates the count of differences that are positive and divisible by k. If diff is negative or not divisible by k, it does not contribute to the count.\\n\\nUpdate the balance variable by adding the value of diff. This step keeps track of the cumulative sum of all differences between the corresponding elements of the arrays.\\n\\nAfter the loop, check if the balance variable is equal to 0. If it is, it means that the overall balance of the differences is zero, indicating a balanced situation. In this case, the function returns the value of count, which represents the count of valid differences. If the balance is not zero, the function returns -1, indicating an unbalanced situation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar minOperations = function(nums1, nums2, k) {\\n    let count = 0, balance = 0;\\n    for(let i = 0; i < nums1.length; i++) {\\n        const diff = nums1[i] - nums2[i];\\n        if(diff % k) return -1;\\n        if(k === 0 && diff !== 0) return -1;   \\n        count += diff > 0 ? diff / k : 0;\\n        balance += diff;\\n    }\\n    return balance === 0 ? count : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar minOperations = function(nums1, nums2, k) {\\n    let count = 0, balance = 0;\\n    for(let i = 0; i < nums1.length; i++) {\\n        const diff = nums1[i] - nums2[i];\\n        if(diff % k) return -1;\\n        if(k === 0 && diff !== 0) return -1;   \\n        count += diff > 0 ? diff / k : 0;\\n        balance += diff;\\n    }\\n    return balance === 0 ? count : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3535900,
                "title": "java-easy",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n\\n        int diff = 0;\\n        long steps = 0;\\n        int balance = 0;\\n\\n        if(k == 0){\\n            for(int i = 0; i < nums1.length; i++){\\n                if(nums1[i] != nums2[i])\\n                    return -1;\\n            }\\n        }else{\\n            for(int i = 0; i < nums1.length; i++){\\n                diff = nums1[i] - nums2[i];\\n                if(diff % k != 0)\\n                    return -1;\\n                if(diff > 0)\\n                    steps += diff/k;\\n                balance += diff;\\n            }\\n        }\\n        return balance == 0 ? steps : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n\\n        int diff = 0;\\n        long steps = 0;\\n        int balance = 0;\\n\\n        if(k == 0){\\n            for(int i = 0; i < nums1.length; i++){\\n                if(nums1[i] != nums2[i])\\n                    return -1;\\n            }\\n        }else{\\n            for(int i = 0; i < nums1.length; i++){\\n                diff = nums1[i] - nums2[i];\\n                if(diff % k != 0)\\n                    return -1;\\n                if(diff > 0)\\n                    steps += diff/k;\\n                balance += diff;\\n            }\\n        }\\n        return balance == 0 ? steps : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508452,
                "title": "c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public long MinOperations(int[] nums1, int[] nums2, int k) {\\n        long decrease = 0, increase = 0;\\n        int max = 0, min = 0;\\n        for(int i = 0; i < nums1.Length;i++){\\n            if(nums1[i] == nums2[i]) continue;\\n            if(k == 0) return -1;\\n            max = Math.Max(nums1[i],nums2[i]);\\n            min = Math.Min(nums1[i],nums2[i]);   \\n            if((max - min) % k != 0) return -1;\\n            int steps = ((max - min) / k);\\n            if(nums1[i] > nums2[i]) decrease+= steps;\\n            else increase+= steps;\\n        }\\n        if(decrease != increase) return -1;\\n        return increase;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinOperations(int[] nums1, int[] nums2, int k) {\\n        long decrease = 0, increase = 0;\\n        int max = 0, min = 0;\\n        for(int i = 0; i < nums1.Length;i++){\\n            if(nums1[i] == nums2[i]) continue;\\n            if(k == 0) return -1;\\n            max = Math.Max(nums1[i],nums2[i]);\\n            min = Math.Min(nums1[i],nums2[i]);   \\n            if((max - min) % k != 0) return -1;\\n            int steps = ((max - min) / k);\\n            if(nums1[i] > nums2[i]) decrease+= steps;\\n            else increase+= steps;\\n        }\\n        if(decrease != increase) return -1;\\n        return increase;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432655,
                "title": "o-m-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor change nums1 to nums2 diff between ith index of both array should be 0  or multiple of k. i just need to count how much opeartion i should perform to change nums1[i] to nums2[i] like if nums1[i] = 1 nums2[i] = 7 and k = 3 so we need 2 opeartion((nums1[i] - nums2[i]) / k)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        \\n        int sum = 0;\\n        long incOp = 0;\\n    //this for if k == 0 if both arrays were equals then 0 op will req if both are not equal we cant make them equal\\n        if(k == 0) {\\n           \\n            for(int s = 0; s < nums1.length; s++) {\\n                if(nums1[s] != nums2[s]) {\\n                    return -1;\\n                }\\n            }\\n            return 0;\\n        }\\n        for(int i = 0; i < nums1.length; i++) {\\n              \\t  \\n            if(nums1[i] - nums2[i] > 0 && (nums1[i] - nums2[i]) % k == 0) {   \\n                sum += nums1[i] - nums2[i];\\n                incOp += (nums1[i] - nums2[i]) / k;\\n            }\\n            else if (nums2[i] - nums1[i] >= 0 && (nums1[i] - nums2[i]) % k == 0) {\\n                sum -= (nums2[i] - nums1[i]);\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n\\n        if(sum != 0) {\\n            return -1;\\n        }\\n        return incOp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        \\n        int sum = 0;\\n        long incOp = 0;\\n    //this for if k == 0 if both arrays were equals then 0 op will req if both are not equal we cant make them equal\\n        if(k == 0) {\\n           \\n            for(int s = 0; s < nums1.length; s++) {\\n                if(nums1[s] != nums2[s]) {\\n                    return -1;\\n                }\\n            }\\n            return 0;\\n        }\\n        for(int i = 0; i < nums1.length; i++) {\\n              \\t  \\n            if(nums1[i] - nums2[i] > 0 && (nums1[i] - nums2[i]) % k == 0) {   \\n                sum += nums1[i] - nums2[i];\\n                incOp += (nums1[i] - nums2[i]) / k;\\n            }\\n            else if (nums2[i] - nums1[i] >= 0 && (nums1[i] - nums2[i]) % k == 0) {\\n                sum -= (nums2[i] - nums1[i]);\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n\\n        if(sum != 0) {\\n            return -1;\\n        }\\n        return incOp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365506,
                "title": "simple-c-o-n-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        ll pos=0, neg=0, size=nums1.size();\\n        if(k!=0){\\n            for(int i=0; i<size; i++){\\n                if(nums1[i]>nums2[i]){\\n                    if((1L*nums1[i]-nums2[i])%k) return -1;\\n                    neg+=1L*nums1[i]-nums2[i];\\n                }\\n                else if(nums1[i]<nums2[i]){\\n                    if((1L*nums2[i]-nums1[i])%k) return -1;\\n                    pos+=1L*nums2[i]-nums1[i];\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0; i<size; i++)\\n                if(nums1[i]!=nums2[i]) return -1;\\n        }\\n        return pos==neg?k==0?0:pos/k:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        ll pos=0, neg=0, size=nums1.size();\\n        if(k!=0){\\n            for(int i=0; i<size; i++){\\n                if(nums1[i]>nums2[i]){\\n                    if((1L*nums1[i]-nums2[i])%k) return -1;\\n                    neg+=1L*nums1[i]-nums2[i];\\n                }\\n                else if(nums1[i]<nums2[i]){\\n                    if((1L*nums2[i]-nums1[i])%k) return -1;\\n                    pos+=1L*nums2[i]-nums1[i];\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0; i<size; i++)\\n                if(nums1[i]!=nums2[i]) return -1;\\n        }\\n        return pos==neg?k==0?0:pos/k:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358381,
                "title": "java-o-n-3ms-easy-solution-beginner-friendly-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n    if(k==0) return Arrays.equals(nums1,nums2)?0:-1;\\n \\n        long total=0; // stores the total difference we should be 0 at else return -1\\n        long pos=0; // stores only positive difference becasuse the negative difference should same for total to be 0 return any one as answer\\n        for(int i=0;i<nums1.length;i++){\\n            int n=nums1[i]-nums2[i];\\n            // check if by adding k the number can be achieved if not return zero\\n            if(n%k!=0){\\n                return -1;\\n            }\\n       \\n            total+=n;\\n            if(n>0){\\n                // if positive adding the number to pos\\n                pos+=n;\\n            }\\n            \\n            \\n        }\\n        // if positive difference and negative difference arent equal it wont be 0 so return -1 as in 1 step we have to add and subtract k at the same time\\n        if(total!=0) return -1;\\n        // total positive difference as k can be added in one step total steps = pos/k\\n        return pos/k;\\n\\n        \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n    if(k==0) return Arrays.equals(nums1,nums2)?0:-1;\\n \\n        long total=0; // stores the total difference we should be 0 at else return -1\\n        long pos=0; // stores only positive difference becasuse the negative difference should same for total to be 0 return any one as answer\\n        for(int i=0;i<nums1.length;i++){\\n            int n=nums1[i]-nums2[i];\\n            // check if by adding k the number can be achieved if not return zero\\n            if(n%k!=0){\\n                return -1;\\n            }\\n       \\n            total+=n;\\n            if(n>0){\\n                // if positive adding the number to pos\\n                pos+=n;\\n            }\\n            \\n            \\n        }\\n        // if positive difference and negative difference arent equal it wont be 0 so return -1 as in 1 step we have to add and subtract k at the same time\\n        if(total!=0) return -1;\\n        // total positive difference as k can be added in one step total steps = pos/k\\n        return pos/k;\\n\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352235,
                "title": "js-javascript-simple-solution-o-n",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar minOperations = function(nums1, nums2, k) {\\n    if (k === 0){\\n        for (let i = 0; i < nums1.length; i++){\\n            if (nums1[i] !== nums2[i]) return -1 \\n        }\\n        return 0\\n    }\\n    let counter = 0\\n    let posCounter = 0\\n    for (let i = 0; i < nums1.length; i++){\\n        let dif = nums1[i] - nums2[i]\\n        if (dif % k) return -1\\n        counter += dif / k\\n        posCounter += Math.abs(dif / k)\\n    }\\n    return counter  === 0 ? (posCounter === 0 ? 0 : posCounter / 2) : -1\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar minOperations = function(nums1, nums2, k) {\\n    if (k === 0){\\n        for (let i = 0; i < nums1.length; i++){\\n            if (nums1[i] !== nums2[i]) return -1 \\n        }\\n        return 0\\n    }\\n    let counter = 0\\n    let posCounter = 0\\n    for (let i = 0; i < nums1.length; i++){\\n        let dif = nums1[i] - nums2[i]\\n        if (dif % k) return -1\\n        counter += dif / k\\n        posCounter += Math.abs(dif / k)\\n    }\\n    return counter  === 0 ? (posCounter === 0 ? 0 : posCounter / 2) : -1\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337758,
                "title": "c-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long balance = 0;\\n        long long moves = 0;\\n        if(k == 0) return nums1 == nums2 ? 0 : -1;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(abs(nums1[i] - nums2[i]) % k != 0) return -1;\\n            balance += nums2[i] - nums1[i];\\n            if(nums1[i] < nums2[i]) moves += (nums2[i] - nums1[i]) / k;\\n        }\\n        if(balance != 0) return -1;\\n        return moves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long balance = 0;\\n        long long moves = 0;\\n        if(k == 0) return nums1 == nums2 ? 0 : -1;\\n        for(int i = 0; i < nums1.size(); i++){\\n            if(abs(nums1[i] - nums2[i]) % k != 0) return -1;\\n            balance += nums2[i] - nums1[i];\\n            if(nums1[i] < nums2[i]) moves += (nums2[i] - nums1[i]) / k;\\n        }\\n        if(balance != 0) return -1;\\n        return moves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337010,
                "title": "java-basic-check-difference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if(k==0){\\n            if(Arrays.toString(nums1).equals(Arrays.toString(nums2)))return 0;\\n            else return -1;\\n        }\\n        long ans = 0, sum = 0,sum2 = 0;\\n        int l = nums1.length;\\n        long pos = 0, neg = 0;\\n        // for(int a:nums1)sum+=a;\\n        // for(int a:nums2)sum2+=a;\\n        // if(sum!=sum2)return -1;\\n        for(int i = 0;i<l;i++){\\n            long diff = nums1[i] - nums2[i];\\n            if(diff%k!=0)return -1;\\n            if(diff>0)pos+= diff/k;\\n            else neg+= Math.abs(diff/k);\\n            \\n        }\\n\\n        if(pos==neg)return pos;\\n        else return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if(k==0){\\n            if(Arrays.toString(nums1).equals(Arrays.toString(nums2)))return 0;\\n            else return -1;\\n        }\\n        long ans = 0, sum = 0,sum2 = 0;\\n        int l = nums1.length;\\n        long pos = 0, neg = 0;\\n        // for(int a:nums1)sum+=a;\\n        // for(int a:nums2)sum2+=a;\\n        // if(sum!=sum2)return -1;\\n        for(int i = 0;i<l;i++){\\n            long diff = nums1[i] - nums2[i];\\n            if(diff%k!=0)return -1;\\n            if(diff>0)pos+= diff/k;\\n            else neg+= Math.abs(diff/k);\\n            \\n        }\\n\\n        if(pos==neg)return pos;\\n        else return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332742,
                "title": "simple-and-easy-to-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n\\n        if k == 0:\\n            if nums1 == nums2:\\n                return 0\\n            else:\\n                return -1\\n\\n        toAdd = 0\\n        toSub = 0\\n\\n        for i in range(len(nums1)):\\n            if abs(nums1[i]-nums2[i]) % k != 0:\\n                return -1\\n\\n            if nums1[i] > nums2[i]:\\n                toSub += nums1[i]-nums2[i]\\n            elif nums2[i] > nums1[i]:\\n                toAdd += nums2[i]-nums1[i]\\n\\n        if toSub != toAdd:\\n            return -1\\n\\n        return toAdd//k\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n\\n        if k == 0:\\n            if nums1 == nums2:\\n                return 0\\n            else:\\n                return -1\\n\\n        toAdd = 0\\n        toSub = 0\\n\\n        for i in range(len(nums1)):\\n            if abs(nums1[i]-nums2[i]) % k != 0:\\n                return -1\\n\\n            if nums1[i] > nums2[i]:\\n                toSub += nums1[i]-nums2[i]\\n            elif nums2[i] > nums1[i]:\\n                toAdd += nums2[i]-nums1[i]\\n\\n        if toSub != toAdd:\\n            return -1\\n\\n        return toAdd//k\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326938,
                "title": "minimum-operations-to-make-two-arrays-equal-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n745 ms\\n\\n- Space complexity:\\n30.5 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        s = 0\\n        c = 0\\n        if k==0:\\n            if nums1==nums2:\\n                return 0\\n            return -1\\n        for i in range(len(nums1)): \\n            if abs(nums1[i]-nums2[i])%k!=0:\\n                return -1\\n            if nums1[i]>nums2[i]:\\n                c+=abs(nums1[i]-nums2[i])\\n            else:\\n                s+=abs(nums1[i]-nums2[i])\\n        if s!=c:\\n            return -1\\n        \\n        return s//k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        s = 0\\n        c = 0\\n        if k==0:\\n            if nums1==nums2:\\n                return 0\\n            return -1\\n        for i in range(len(nums1)): \\n            if abs(nums1[i]-nums2[i])%k!=0:\\n                return -1\\n            if nums1[i]>nums2[i]:\\n                c+=abs(nums1[i]-nums2[i])\\n            else:\\n                s+=abs(nums1[i]-nums2[i])\\n        if s!=c:\\n            return -1\\n        \\n        return s//k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323378,
                "title": "simple-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        long long ans=0,chk=0;\\n        for(int i=0;i<n;i++){\\n            if(k==0){\\n                if(nums1[i]!=nums2[i])  return -1;\\n                continue;\\n            }\\n            if(nums1[i]%k!=nums2[i]%k)   return -1;\\n            ans+=abs(nums1[i]/k-nums2[i]/k);\\n            chk+=nums1[i]/k-nums2[i]/k;\\n        }\\n        if(chk!=0)   return -1;\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n=nums1.size();\\n        long long ans=0,chk=0;\\n        for(int i=0;i<n;i++){\\n            if(k==0){\\n                if(nums1[i]!=nums2[i])  return -1;\\n                continue;\\n            }\\n            if(nums1[i]%k!=nums2[i]%k)   return -1;\\n            ans+=abs(nums1[i]/k-nums2[i]/k);\\n            chk+=nums1[i]/k-nums2[i]/k;\\n        }\\n        if(chk!=0)   return -1;\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281393,
                "title": "c-solution-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n         \\n        int n=nums1.size();\\n        long long operations_neg=0;\\n        long long operations_pos=0;\\n        long long curr_sum=0;\\n        \\n         if(k==0){\\n              if(nums1==nums2) return 0;\\n              else             return -1;\\n         }\\n               \\n     for(int i=0;i<n;++i){\\n\\n         // if nums1[i]-nums2[i] not divisible by k not possible to make nums1 to nums2\\n         if( ( nums1[i]-nums2[i] )%k !=0 ) return -1; \\n         else{  \\n             \\n             \\n             if((nums1[i]-nums2[i])/k < 0 ) operations_neg +=(nums1[i]-nums2[i])/k;  // no of negative operations to do to make nums1 equals to nums2 at index i\\n             else                           operations_pos +=(nums1[i]-nums2[i])/k;   // no of positive operations to do to make nums1 equals to nums2 at index i\\n          }\\n     }\\n       // if our operations are balanced its possible else not \\n        return (operations_pos + operations_neg )==0?operations_pos:-1;  \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n         \\n        int n=nums1.size();\\n        long long operations_neg=0;\\n        long long operations_pos=0;\\n        long long curr_sum=0;\\n        \\n         if(k==0){\\n              if(nums1==nums2) return 0;\\n              else             return -1;\\n         }\\n               \\n     for(int i=0;i<n;++i){\\n\\n         // if nums1[i]-nums2[i] not divisible by k not possible to make nums1 to nums2\\n         if( ( nums1[i]-nums2[i] )%k !=0 ) return -1; \\n         else{  \\n             \\n             \\n             if((nums1[i]-nums2[i])/k < 0 ) operations_neg +=(nums1[i]-nums2[i])/k;  // no of negative operations to do to make nums1 equals to nums2 at index i\\n             else                           operations_pos +=(nums1[i]-nums2[i])/k;   // no of positive operations to do to make nums1 equals to nums2 at index i\\n          }\\n     }\\n       // if our operations are balanced its possible else not \\n        return (operations_pos + operations_neg )==0?operations_pos:-1;  \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266124,
                "title": "easy-and-clean-solution-with-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long sum1 = 0;\\n        long sum2 = 0;\\n        long minOperations = 0;\\n        for(int i = 0 ; i < nums1.length; i++)\\n        {\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        if(sum1 != sum2)\\n        return -1;\\n\\n        for(int i = 0; i < nums1.length; i++)\\n        {\\n            if(nums1[i] == nums2[i])\\n            continue;\\n            else if(nums1[i] > nums2[i])\\n            {\\n                if(k == 0 || ((nums1[i] - nums2[i]) % k != 0))\\n                return -1;\\n                else\\n                {\\n                    long val = (nums1[i] - nums2[i]) / k;\\n                    minOperations+=val;\\n                }\\n            }\\n            else if(nums2[i] > nums1[i])\\n            {\\n                if(k == 0 || ((nums2[i] - nums1[i]) % k != 0))\\n                return -1;\\n            }\\n        }\\n        return minOperations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long sum1 = 0;\\n        long sum2 = 0;\\n        long minOperations = 0;\\n        for(int i = 0 ; i < nums1.length; i++)\\n        {\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        if(sum1 != sum2)\\n        return -1;\\n\\n        for(int i = 0; i < nums1.length; i++)\\n        {\\n            if(nums1[i] == nums2[i])\\n            continue;\\n            else if(nums1[i] > nums2[i])\\n            {\\n                if(k == 0 || ((nums1[i] - nums2[i]) % k != 0))\\n                return -1;\\n                else\\n                {\\n                    long val = (nums1[i] - nums2[i]) / k;\\n                    minOperations+=val;\\n                }\\n            }\\n            else if(nums2[i] > nums1[i])\\n            {\\n                if(k == 0 || ((nums2[i] - nums1[i]) % k != 0))\\n                return -1;\\n            }\\n        }\\n        return minOperations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261778,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar minOperations = function(nums1, nums2, k) {\\n   let resp= 0;\\n   let resm=0;\\n   for(let i=0; i<nums1.length; i++){\\n       if(nums1[i]>nums2[i]){\\n           if((nums1[i]-nums2[i])%k==0){\\n               resm+=(nums1[i]-nums2[i])/k\\n           }else{\\n               return -1;\\n           }\\n       }else if(nums1[i]<nums2[i]){\\n           if((nums2[i]-nums1[i])%k==0){\\n               resp+=(nums2[i]-nums1[i])/k\\n           }else{\\n               return -1;\\n           }\\n       }\\n   } \\n   if(resp==resm){\\n       return resp;\\n   }else{\\n       return -1;\\n   }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number}\\n */\\nvar minOperations = function(nums1, nums2, k) {\\n   let resp= 0;\\n   let resm=0;\\n   for(let i=0; i<nums1.length; i++){\\n       if(nums1[i]>nums2[i]){\\n           if((nums1[i]-nums2[i])%k==0){\\n               resm+=(nums1[i]-nums2[i])/k\\n           }else{\\n               return -1;\\n           }\\n       }else if(nums1[i]<nums2[i]){\\n           if((nums2[i]-nums1[i])%k==0){\\n               resp+=(nums2[i]-nums1[i])/k\\n           }else{\\n               return -1;\\n           }\\n       }\\n   } \\n   if(resp==resm){\\n       return resp;\\n   }else{\\n       return -1;\\n   }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3249333,
                "title": "java-math-and-clear-explanations",
                "content": "# Approach\\n1. Fail fast: if k == 0, check if the two arrays are equal. Yes? return 0, else -1\\n2. The logic is to check if the diff between each nums1[i] nums2[i] is divisible by k.\\nIf not, you cannot obtain nums2[i] by adding /removing k any number of times.\\n   - EG: nums1[i]=3 , nums2[i]=7, k = 3. The diff is 4. You cannot obtain 4 from 3. \\n    - nums1[i]=3 , nums2[i]=7, k = 2. diff = 4: you can obtain 4 by adding 2 two times\\n3. Figuring this mechanism, apply a fail fast mechanism: if diff % k != 0, return -1\\n4. Else, use two variables (minusDiff, plusDiff) to add the negative and positive diff between each pair nums1[i], nums2[i]. This is because we need to match the negative diff with the positive diff\\n5. At the end, if minusDiff + plusDiff != 0, return -1 (the two differences cannot balance each other), else return plusDiff / k.\\n    - EG: minusDiff = -6, plusDiff = 6, k = 2. 6/2 = 3. We can balance them in 3 steps: (+2/-2), (+2/-2),(+2/-2).\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            return Arrays.equals(nums1, nums2) ? 0 : -1;\\n        }\\n        long minusDiff = 0, plusDiff = 0, diff;\\n        for (int i = 0; i < nums1.length; i++) {\\n            diff = nums1[i] - nums2[i];\\n            if (diff % k != 0) {\\n                return -1;\\n            }\\n            if (diff > 0) {\\n                plusDiff += diff;\\n            } else if (diff < 0) {\\n                minusDiff += diff;\\n            }\\n        }\\n        return Math.abs(minusDiff) != plusDiff ? -1 : plusDiff / k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            return Arrays.equals(nums1, nums2) ? 0 : -1;\\n        }\\n        long minusDiff = 0, plusDiff = 0, diff;\\n        for (int i = 0; i < nums1.length; i++) {\\n            diff = nums1[i] - nums2[i];\\n            if (diff % k != 0) {\\n                return -1;\\n            }\\n            if (diff > 0) {\\n                plusDiff += diff;\\n            } else if (diff < 0) {\\n                minusDiff += diff;\\n            }\\n        }\\n        return Math.abs(minusDiff) != plusDiff ? -1 : plusDiff / k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223937,
                "title": "easiest-o-n-c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question is comparitively easy as it given in the medium category. You only need to check whether the diff of two value is multiple of k or not.\\n\\n# Approach\\n1. check whether the array are already equal or not if yes the return 0 else check for k==0 return 0 else return -1.\\n2. calcluate the diff bet values if it multiple of k and diff   is positive the increment countpositive += diff/k;\\nelse countnegative += diff/k;\\n3. check if countositive + countnegative ==0\\n     return countpositive\\nelse return -1\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0)\\n            return nums1 == nums2 ? 0 : -1;\\n        long long pos=0,neg=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long diff = nums1[i]-nums2[i];\\n            if(diff%k){\\n                return -1;\\n            }\\n            else if(diff>0)\\n             pos+=diff/k;\\n            else \\n             neg+=diff/k;\\n        }\\n        if(pos+neg== 0)\\n         return pos;\\n        else \\n        return -1;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0)\\n            return nums1 == nums2 ? 0 : -1;\\n        long long pos=0,neg=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long diff = nums1[i]-nums2[i];\\n            if(diff%k){\\n                return -1;\\n            }\\n            else if(diff>0)\\n             pos+=diff/k;\\n            else \\n             neg+=diff/k;\\n        }\\n        if(pos+neg== 0)\\n         return pos;\\n        else \\n        return -1;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223936,
                "title": "easiest-o-n-c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question is comparitively easy as it given in the medium category. You only need to check whether the diff of two value is multiple of k or not.\\n\\n# Approach\\n1. check whether the array are already equal or not if yes the return 0 else check for k==0 return 0 else return -1.\\n2. calcluate the diff bet values if it multiple of k and diff   is positive the increment countpositive += diff/k;\\nelse countnegative += diff/k;\\n3. check if countositive + countnegative ==0\\n     return countpositive\\nelse return -1\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0)\\n            return nums1 == nums2 ? 0 : -1;\\n        long long pos=0,neg=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long diff = nums1[i]-nums2[i];\\n            if(diff%k){\\n                return -1;\\n            }\\n            else if(diff>0)\\n             pos+=diff/k;\\n            else \\n             neg+=diff/k;\\n        }\\n        if(pos+neg== 0)\\n         return pos;\\n        else \\n        return -1;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0)\\n            return nums1 == nums2 ? 0 : -1;\\n        long long pos=0,neg=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long diff = nums1[i]-nums2[i];\\n            if(diff%k){\\n                return -1;\\n            }\\n            else if(diff>0)\\n             pos+=diff/k;\\n            else \\n             neg+=diff/k;\\n        }\\n        if(pos+neg== 0)\\n         return pos;\\n        else \\n        return -1;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160389,
                "title": "c-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n        long long int c1=0,c2=0;\\n        if(k==0)\\n        {\\n            for(int i=0;i<n1.size();i++)\\n            if(n1[i]!=n2[i]) return -1;\\n            return 0;\\n        }\\n        for(int i=0;i<n1.size();i++)\\n        {\\n              if(n1[i]>n2[i])\\n              {\\n                  if(abs(n1[i]-n2[i])%k!=0)\\n                  return -1;\\n                  c1+=abs(n1[i]-n2[i])/k;\\n              }\\n              else if(n1[i]<n2[i])\\n              {\\n                  if(abs(n1[i]-n2[i])%k!=0)\\n                  return -1;\\n                  c2+=abs(n1[i]-n2[i])/k;\\n              }\\n        }\\n        if(c1!=c2)\\n        return -1;\\n        else\\n        return c1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n        long long int c1=0,c2=0;\\n        if(k==0)\\n        {\\n            for(int i=0;i<n1.size();i++)\\n            if(n1[i]!=n2[i]) return -1;\\n            return 0;\\n        }\\n        for(int i=0;i<n1.size();i++)\\n        {\\n              if(n1[i]>n2[i])\\n              {\\n                  if(abs(n1[i]-n2[i])%k!=0)\\n                  return -1;\\n                  c1+=abs(n1[i]-n2[i])/k;\\n              }\\n              else if(n1[i]<n2[i])\\n              {\\n                  if(abs(n1[i]-n2[i])%k!=0)\\n                  return -1;\\n                  c2+=abs(n1[i]-n2[i])/k;\\n              }\\n        }\\n        if(c1!=c2)\\n        return -1;\\n        else\\n        return c1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139074,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums1==nums2)\\n        {\\n            return 0;\\n        }\\n        if(k==0)\\n        {\\n            return -1;\\n        }\\n        vector<long long> nums;\\n        for(long long i=0;i<nums1.size();i++)\\n        {\\n            nums.push_back(nums1[i]-nums2[i]);\\n        }\\n        for(long long i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%k!=0)\\n            {\\n                return -1;\\n            }\\n        }\\n        long long x=0;\\n        long long y=0;\\n        for(long long i=0;i<nums.size();i++)\\n        {\\n            x+=nums[i];\\n        }\\n        if(x==0)\\n        {\\n            for(long long i=0;i<nums.size();i++)\\n            {\\n                y+=abs(nums[i]/k);\\n            }\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n        return y/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums1==nums2)\\n        {\\n            return 0;\\n        }\\n        if(k==0)\\n        {\\n            return -1;\\n        }\\n        vector<long long> nums;\\n        for(long long i=0;i<nums1.size();i++)\\n        {\\n            nums.push_back(nums1[i]-nums2[i]);\\n        }\\n        for(long long i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%k!=0)\\n            {\\n                return -1;\\n            }\\n        }\\n        long long x=0;\\n        long long y=0;\\n        for(long long i=0;i<nums.size();i++)\\n        {\\n            x+=nums[i];\\n        }\\n        if(x==0)\\n        {\\n            for(long long i=0;i<nums.size();i++)\\n            {\\n                y+=abs(nums[i]/k);\\n            }\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n        return y/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132994,
                "title": "c-simple-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n\\n\\n- Space complexity:\\n- O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        if(k==0)\\n         {\\n             if(nums1!=nums2)\\n               return -1;\\n             else \\n               return 0;\\n         }\\n        vector<long long> vt;\\n\\n        for(int i=0;i<nums1.size();i++)\\n           vt.push_back(nums1[i]-nums2[i]);\\n        int sum=accumulate(vt.begin(),vt.end(),0);\\n        \\n        if(sum==0)\\n          {\\n              bool flag=false;\\n              for(int i=0;i<vt.size();i++)\\n               {\\n                   if(vt[i]%k!=0)\\n                     {\\n                         flag=true;\\n                         break;\\n                     }\\n               }\\n              if(flag)\\n               {\\n                   return -1;\\n               }\\n               else\\n               {\\n                  long long result=0;\\n                  for(int i=0;i<vt.size();i++)\\n                   {\\n                       if(vt[i]>0)\\n                        result+=vt[i]/k;\\n                   }\\n                   return result;\\n               }\\n          }\\n        else\\n         return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        if(k==0)\\n         {\\n             if(nums1!=nums2)\\n               return -1;\\n             else \\n               return 0;\\n         }\\n        vector<long long> vt;\\n\\n        for(int i=0;i<nums1.size();i++)\\n           vt.push_back(nums1[i]-nums2[i]);\\n        int sum=accumulate(vt.begin(),vt.end(),0);\\n        \\n        if(sum==0)\\n          {\\n              bool flag=false;\\n              for(int i=0;i<vt.size();i++)\\n               {\\n                   if(vt[i]%k!=0)\\n                     {\\n                         flag=true;\\n                         break;\\n                     }\\n               }\\n              if(flag)\\n               {\\n                   return -1;\\n               }\\n               else\\n               {\\n                  long long result=0;\\n                  for(int i=0;i<vt.size();i++)\\n                   {\\n                       if(vt[i]>0)\\n                        result+=vt[i]/k;\\n                   }\\n                   return result;\\n               }\\n          }\\n        else\\n         return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132938,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long int p=0,q=0,c;\\n        int j=0,l;\\n        int s1=nums1.size();\\n        for(int i=0;i<s1;i++){\\n            if(nums1[i]==nums2[i]){\\n                continue;\\n            }else if(k==0){\\n                return -1;\\n            }else if(nums1[i]>nums2[i]){\\n                j=1;\\n                c=nums1[i]-nums2[i];\\n                if(c%k==0){\\n                    p+=c/k;\\n                }else return -1;\\n            }else{\\n                j=1;\\n                c=nums2[i]-nums1[i];\\n                if(c%k==0){\\n                    q+=c/k;\\n              \\n                }else return -1;\\n            }\\n        }\\n        if(p==0 and j==0){\\n            return 0;\\n        }else if(p==q and j==1 and p!=0){\\n            return p;\\n        }else return -1;\\n  \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long int p=0,q=0,c;\\n        int j=0,l;\\n        int s1=nums1.size();\\n        for(int i=0;i<s1;i++){\\n            if(nums1[i]==nums2[i]){\\n                continue;\\n            }else if(k==0){\\n                return -1;\\n            }else if(nums1[i]>nums2[i]){\\n                j=1;\\n                c=nums1[i]-nums2[i];\\n                if(c%k==0){\\n                    p+=c/k;\\n                }else return -1;\\n            }else{\\n                j=1;\\n                c=nums2[i]-nums1[i];\\n                if(c%k==0){\\n                    q+=c/k;\\n              \\n                }else return -1;\\n            }\\n        }\\n        if(p==0 and j==0){\\n            return 0;\\n        }else if(p==q and j==1 and p!=0){\\n            return p;\\n        }else return -1;\\n  \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128371,
                "title": "easy-beinner-friendly-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long int sum = 0;\\n        long long int p=0,m=0;\\n        if(k==0)\\n        {\\n            return nums1==nums2?0:-1;\\n        }\\n        for(int i = 0;i<nums1.size();i++)\\n        {\\n            sum+=nums1[i]-nums2[i];\\n            if(abs(nums1[i]-nums2[i])%k!=0)\\n                return -1;\\n            else if(nums1[i]-nums2[i]<0)\\n                m+=-(nums1[i]-nums2[i])/k;\\n            else if((nums1[i]-nums2[i])>0)\\n            {\\n                p+=(nums1[i]-nums2[i])/k;\\n            }\\n        }\\n        //cout<<p<<m<<sum;\\n        if(sum) return -1;\\n        if(p == m)\\n            return p;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long int sum = 0;\\n        long long int p=0,m=0;\\n        if(k==0)\\n        {\\n            return nums1==nums2?0:-1;\\n        }\\n        for(int i = 0;i<nums1.size();i++)\\n        {\\n            sum+=nums1[i]-nums2[i];\\n            if(abs(nums1[i]-nums2[i])%k!=0)\\n                return -1;\\n            else if(nums1[i]-nums2[i]<0)\\n                m+=-(nums1[i]-nums2[i])/k;\\n            else if((nums1[i]-nums2[i])>0)\\n            {\\n                p+=(nums1[i]-nums2[i])/k;\\n            }\\n        }\\n        //cout<<p<<m<<sum;\\n        if(sum) return -1;\\n        if(p == m)\\n            return p;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3125436,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums1`\\n */\\nclass Solution {\\n public:\\n  long long minOperations(const vector<int> &nums1, const vector<int> &nums2, const int k) {\\n    if (k == 0) {\\n      return nums1 == nums2 ? 0LL : -1LL;\\n    }\\n\\n    if (accumulate(nums1.begin(), nums1.end(), 0LL) != accumulate(nums2.begin(), nums2.end(), 0LL)) {\\n      return -1LL;\\n    }\\n    \\n    const int n = static_cast<int>(nums1.size());\\n    long long operations = 0LL;\\n    for (int i = 0; i < n; ++i) {\\n      const int diff = abs(nums1[i] - nums2[i]);\\n      if (diff % k != 0) {\\n        operations = -2LL;\\n        break;\\n      }\\n      operations += diff / k;\\n    }\\n    return operations / 2;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums1`\\n */\\nclass Solution {\\n public:\\n  long long minOperations(const vector<int> &nums1, const vector<int> &nums2, const int k) {\\n    if (k == 0) {\\n      return nums1 == nums2 ? 0LL : -1LL;\\n    }\\n\\n    if (accumulate(nums1.begin(), nums1.end(), 0LL) != accumulate(nums2.begin(), nums2.end(), 0LL)) {\\n      return -1LL;\\n    }\\n    \\n    const int n = static_cast<int>(nums1.size());\\n    long long operations = 0LL;\\n    for (int i = 0; i < n; ++i) {\\n      const int diff = abs(nums1[i] - nums2[i]);\\n      if (diff % k != 0) {\\n        operations = -2LL;\\n        break;\\n      }\\n      operations += diff / k;\\n    }\\n    return operations / 2;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122093,
                "title": "no-abs-solution-beats-100",
                "content": "# Intuition\\nBesides when k==0, in total you must have the same number of increases and decreases, which themselves must be multiples of k.  As long as this is true we can just return the positive total divided by k.\\n\\n# Complexity\\n- Time complexity:\\nLinear\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinOperations(int[] nums1, int[] nums2, int k) {\\n        long negative = 0;\\n        long positive = 0;\\n        for (int i = 0; i < nums1.Length; ++i) {\\n            if (k == 0) {\\n                if (nums1[i] == nums2[i]) continue;\\n                else return -1;\\n            }\\n            int val = nums1[i] - nums2[i];\\n            if (val % k != 0) return -1;\\n\\n            if (val < 0) negative += val;\\n            else if (val > 0) positive += val;\\n        }\\n        if (k == 0) return 0;\\n        if (negative + positive != 0) return -1;\\n        return positive / k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinOperations(int[] nums1, int[] nums2, int k) {\\n        long negative = 0;\\n        long positive = 0;\\n        for (int i = 0; i < nums1.Length; ++i) {\\n            if (k == 0) {\\n                if (nums1[i] == nums2[i]) continue;\\n                else return -1;\\n            }\\n            int val = nums1[i] - nums2[i];\\n            if (val % k != 0) return -1;\\n\\n            if (val < 0) negative += val;\\n            else if (val > 0) positive += val;\\n        }\\n        if (k == 0) return 0;\\n        if (negative + positive != 0) return -1;\\n        return positive / k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122060,
                "title": "golang-math-greedy",
                "content": "# Code\\n```\\nfunc abs(a int) int {\\n    if a > 0 {\\n        return a\\n    }\\n    return -a\\n}\\nfunc minOperations(nums1 []int, nums2 []int, k int) int64 {\\n    var ans, possible int64 = 0, 0\\n    var n int = len(nums1)\\n    for i := 0; i < n; i++ {\\n        diff := nums1[i] - nums2[i]\\n        if k == 0 {\\n            if diff == 0 {continue}\\n            return -1\\n        }\\n        if diff % k != 0 {\\n            return -1\\n        }\\n        diff /= k\\n        possible += int64(diff)\\n        ans += int64(abs(diff))\\n    }\\n    if possible == 0 {\\n        return ans >> 1\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc abs(a int) int {\\n    if a > 0 {\\n        return a\\n    }\\n    return -a\\n}\\nfunc minOperations(nums1 []int, nums2 []int, k int) int64 {\\n    var ans, possible int64 = 0, 0\\n    var n int = len(nums1)\\n    for i := 0; i < n; i++ {\\n        diff := nums1[i] - nums2[i]\\n        if k == 0 {\\n            if diff == 0 {continue}\\n            return -1\\n        }\\n        if diff % k != 0 {\\n            return -1\\n        }\\n        diff /= k\\n        possible += int64(diff)\\n        ans += int64(abs(diff))\\n    }\\n    if possible == 0 {\\n        return ans >> 1\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3122023,
                "title": "c-math-greedy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long ans = 0, possible = 0;\\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            int diff = nums1[i] - nums2[i];\\n            if(k == 0) {\\n                if(diff == 0) continue;\\n                else return -1;\\n            }\\n            if(diff % k) return -1;\\n            diff /= k;\\n            possible += diff;\\n            ans += abs(diff);\\n        }\\n        return possible == 0? ans / 2: -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long ans = 0, possible = 0;\\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++) {\\n            int diff = nums1[i] - nums2[i];\\n            if(k == 0) {\\n                if(diff == 0) continue;\\n                else return -1;\\n            }\\n            if(diff % k) return -1;\\n            diff /= k;\\n            possible += diff;\\n            ans += abs(diff);\\n        }\\n        return possible == 0? ans / 2: -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121998,
                "title": "python3-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNotice every operation does not change the sum of nums1. If sum(nums1) != sum(nums2), it\\'s impossible to make two array equal. Meanwhile, nums1[i] - nums2[i] must be times of k, or it is impossible to change nums1[i] to nums2[i]. As increasing ops is equal to decreasing ops, we accumulate inc ops here.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if k == 0: return 0 if nums1 == nums2 else -1\\n        if sum(nums1) != sum(nums2): return -1\\n        ans = 0\\n        for v1, v2 in zip(nums1, nums2):\\n            if (v1 - v2) % k: return -1\\n            if v1 < v2: ans += (v2 - v1) // k\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if k == 0: return 0 if nums1 == nums2 else -1\\n        if sum(nums1) != sum(nums2): return -1\\n        ans = 0\\n        for v1, v2 in zip(nums1, nums2):\\n            if (v1 - v2) % k: return -1\\n            if v1 < v2: ans += (v2 - v1) // k\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121153,
                "title": "python-greedy-o-n",
                "content": "For each pair `(nums1[i], nums2[i])`, we calculate `remainder = abs(nums1[i]-nums2[i]) % k`.\\n\\nIf `remainder != 0`, return `-1`; Otherwise, add `abs(nums1[i]-nums2[i]) // k` to result.\\n\\nIf final result is not `-1`, divide it by `2`. Because we counted operations for both `nums1[i] > nums2[i]` and `nums1[j] < nums2[j]`.\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if nums1 == nums2:\\n            return 0\\n        elif k == 0 or sum(nums1) != sum(nums2):\\n            return -1\\n        ans = 0\\n        for x1, x2 in zip(nums1, nums2):\\n            if abs(x1-x2) % k != 0:  # have to check every pair x1 != x2, both x1 > x2 and x1 < x2\\n                return -1\\n            ans += abs(x1-x2) // k\\n        return ans//2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        if nums1 == nums2:\\n            return 0\\n        elif k == 0 or sum(nums1) != sum(nums2):\\n            return -1\\n        ans = 0\\n        for x1, x2 in zip(nums1, nums2):\\n            if abs(x1-x2) % k != 0:  # have to check every pair x1 != x2, both x1 > x2 and x1 < x2\\n                return -1\\n            ans += abs(x1-x2) // k\\n        return ans//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119242,
                "title": "c-easy-and-simple-solution-base-case",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long count=0;\\n        long long pos=0;\\n        long long neg=0;\\n        for(int i=0;i<nums1.size();i++){\\n            \\n            long long diff=nums1[i]-nums2[i];\\n            if(diff!=0 && k==0) return -1;\\n             \\n            if(k!=0 && diff%k!=0) return -1;\\n            int a=abs(diff);\\n            if(nums1[i]<nums2[i]){\\n                count+=a/k;\\n                pos+=a/k;\\n            }else if(nums1[i]>nums2[i]){\\n                neg+=a/k;\\n                count+=a/k;\\n            }\\n        }\\n        if(pos!=neg) return -1;\\n        count=count/2;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long count=0;\\n        long long pos=0;\\n        long long neg=0;\\n        for(int i=0;i<nums1.size();i++){\\n            \\n            long long diff=nums1[i]-nums2[i];\\n            if(diff!=0 && k==0) return -1;\\n             \\n            if(k!=0 && diff%k!=0) return -1;\\n            int a=abs(diff);\\n            if(nums1[i]<nums2[i]){\\n                count+=a/k;\\n                pos+=a/k;\\n            }else if(nums1[i]>nums2[i]){\\n                neg+=a/k;\\n                count+=a/k;\\n            }\\n        }\\n        if(pos!=neg) return -1;\\n        count=count/2;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117989,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount the operation performing on pair of element to change in nums2 to nums1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor k=0, check if nums1 is equal to nums2 then return 0, \\nfor k=0 we are checking explicitly becouse we can\\'t devide int by 0.\\n\\nafter this maintain two variable for increment and decrement the value.\\n\\nif (nums1[i]-nums2[i]) is not divisible by k then it is impossible to change nums1 into nums2.\\n\\nelse: take difference b\\\\w nums1[i]-nums2[i] and see if the value have to increment or decrement.\\n\\nif nums1[i] has to increment, increase the inc variable by difference / k, and vice versa for nums1[i] has to decrement.\\n\\nat last check if the number of time increment and decrement is equal then return any of them, other wise return -1.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        if(k==0){\\n            if(nums1==nums2){return 0;}\\n            return -1;\\n            }\\n\\n        int n = nums1.size();\\n        long long inc=0, dec=0;\\n        for(int i=0;i<n;i++){\\n\\n            if(abs(nums1[i]-nums2[i])%k !=0){return -1;}\\n            \\n            if(nums1[i]<nums2[i]){\\n                inc+= (nums2[i]-nums1[i])/k;\\n            }\\n            else{\\n                dec+=(nums1[i]-nums2[i])/k;\\n            }\\n        }\\n\\n        return (inc==dec)? inc : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        if(k==0){\\n            if(nums1==nums2){return 0;}\\n            return -1;\\n            }\\n\\n        int n = nums1.size();\\n        long long inc=0, dec=0;\\n        for(int i=0;i<n;i++){\\n\\n            if(abs(nums1[i]-nums2[i])%k !=0){return -1;}\\n            \\n            if(nums1[i]<nums2[i]){\\n                inc+= (nums2[i]-nums1[i])/k;\\n            }\\n            else{\\n                dec+=(nums1[i]-nums2[i])/k;\\n            }\\n        }\\n\\n        return (inc==dec)? inc : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109739,
                "title": "c-solution-simple-approach-subtract-both-arrays",
                "content": "class Solution {\\npublic:\\n*       long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long pstv=0,ngtv=0,diff;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            diff= nums1[i]-nums2[i];\\n            if(k==0)\\n            {\\n                if(diff==0)\\n                    continue;\\n                else\\n                    return -1;\\n            }\\n            if(diff%k!=0)\\n                return -1;\\n            if(diff>0)\\n                pstv+=diff/k;\\n            else if(diff<0)\\n                ngtv+= abs(diff)/k;\\n        }\\n        if(pstv!=ngtv)\\n            return -1;\\n        return pstv;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n*       long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long pstv=0,ngtv=0,diff;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            diff= nums1[i]-nums2[i];\\n            if(k==0)\\n            {\\n                if(diff==0)\\n                    continue;\\n                else\\n                    return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3108557,
                "title": "easy-and-step-by-step-logic-building-approach-for-beginners",
                "content": "# Intuition\\n<!-- Easy step by step solution for beginners -->\\n\\n\\n# Approach\\n<!-- Describe -->\\nPlease upvote if you like the solution.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        //check if sum of both vectors is equal if not we can\\'t \\n        //make it equal since we are adding and subtracting the same number\\n        long long int s1=0;\\n        long long int s2=0;\\n        \\n        for(int i=0; i<nums1.size(); i++)\\n            s1+=nums1[i];\\n        for(int j=0; j<nums2.size(); j++)\\n            s2+=nums2[j];\\n        \\n        if(s1!=s2)\\n            return -1;\\n        \\n        if(k==0  && nums1!=nums2)\\n            return -1;\\n        else if(k==0 && nums1==nums2)\\n            return 0;\\n        \\n        vector <int> absdiff;\\n        \\n        for(int i=0; i<nums1.size(); i++){\\n            long long int d = (nums1[i]-nums2[i]);\\n            absdiff.push_back(d);\\n        }\\n        \\n        bool flag=true;\\n        for(int i=0; i<absdiff.size(); i++)\\n        {\\n            int r= absdiff[i]%k;\\n            if(r!=0)\\n            {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        if(flag==false)\\n            return -1;\\n        \\n        long long ans=0;\\n        for(int i=0; i<absdiff.size(); i++)\\n        {\\n            absdiff[i]=absdiff[i]/k;\\n            if(absdiff[i]>0)\\n                ans+=absdiff[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        //check if sum of both vectors is equal if not we can\\'t \\n        //make it equal since we are adding and subtracting the same number\\n        long long int s1=0;\\n        long long int s2=0;\\n        \\n        for(int i=0; i<nums1.size(); i++)\\n            s1+=nums1[i];\\n        for(int j=0; j<nums2.size(); j++)\\n            s2+=nums2[j];\\n        \\n        if(s1!=s2)\\n            return -1;\\n        \\n        if(k==0  && nums1!=nums2)\\n            return -1;\\n        else if(k==0 && nums1==nums2)\\n            return 0;\\n        \\n        vector <int> absdiff;\\n        \\n        for(int i=0; i<nums1.size(); i++){\\n            long long int d = (nums1[i]-nums2[i]);\\n            absdiff.push_back(d);\\n        }\\n        \\n        bool flag=true;\\n        for(int i=0; i<absdiff.size(); i++)\\n        {\\n            int r= absdiff[i]%k;\\n            if(r!=0)\\n            {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        if(flag==false)\\n            return -1;\\n        \\n        long long ans=0;\\n        for(int i=0; i<absdiff.size(); i++)\\n        {\\n            absdiff[i]=absdiff[i]/k;\\n            if(absdiff[i]>0)\\n                ans+=absdiff[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107584,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n  class Solution \\n{\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        if(k==0) \\n        {\\n            if(nums1==nums2) return 0; \\n            return -1;\\n        }\\n        \\n        long long p_diff=0, n_diff=0; \\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            if(nums1[i] >= nums2[i])\\n            {\\n                if((nums1[i]-nums2[i])%k==0) \\n                    p_diff += nums1[i]-nums2[i];\\n                else\\n                    return -1;\\n            } \\n            else \\n            {\\n                if((nums2[i]-nums1[i])%k==0)\\n                    n_diff += nums2[i]-nums1[i];\\n                else\\n                    return -1;\\n            }\\n        }\\n        \\n        long long ans=-1;\\n        \\n        if(p_diff-n_diff==0) ans = (p_diff/k);\\n        return ans;\\n        \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n  class Solution \\n{\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        if(k==0) \\n        {\\n            if(nums1==nums2) return 0; \\n            return -1;\\n        }\\n        \\n        long long p_diff=0, n_diff=0; \\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            if(nums1[i] >= nums2[i])\\n            {\\n                if((nums1[i]-nums2[i])%k==0) \\n                    p_diff += nums1[i]-nums2[i];\\n                else\\n                    return -1;\\n            } \\n            else \\n            {\\n                if((nums2[i]-nums1[i])%k==0)\\n                    n_diff += nums2[i]-nums1[i];\\n                else\\n                    return -1;\\n            }\\n        }\\n        \\n        long long ans=-1;\\n        \\n        if(p_diff-n_diff==0) ans = (p_diff/k);\\n        return ans;\\n        \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107324,
                "title": "just-count-up-and-down-numbers-of-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\neasy approach, so may just look at the code\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n\\n        long up=0, down=0;\\n        for(int i=0;i<nums1.length;i++) {\\n            int delta = nums1[i]-nums2[i];\\n            if(k==0) {\\n                if(delta!=0)\\n                    return -1;\\n                else\\n                    continue;\\n            }\\n            if((delta)%k!=0)\\n                return -1;\\n            if(delta>0) {\\n                down += delta/k;    \\n            } else {\\n                up -= delta/k;\\n            }\\n        }\\n        if(up==down)\\n            return up;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n\\n        long up=0, down=0;\\n        for(int i=0;i<nums1.length;i++) {\\n            int delta = nums1[i]-nums2[i];\\n            if(k==0) {\\n                if(delta!=0)\\n                    return -1;\\n                else\\n                    continue;\\n            }\\n            if((delta)%k!=0)\\n                return -1;\\n            if(delta>0) {\\n                down += delta/k;    \\n            } else {\\n                up -= delta/k;\\n            }\\n        }\\n        if(up==down)\\n            return up;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106256,
                "title": "java-simple-solution-using-simple-maths",
                "content": "# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        if(k==0) {\\n            for(int i=0;i<n;i++) \\n                if(nums1[i] != nums2[i])\\n                    return -1;\\n            return 0;\\n        }\\n        long neg = 0, pos = 0;\\n        for(int i=0;i<n;i++) {\\n            nums1[i] = nums1[i]-nums2[i];\\n            if(nums1[i]%k != 0)\\n                return -1;\\n            if(nums1[i]<0)\\n                neg += nums1[i];\\n            if(nums1[i]>0)\\n                pos += nums1[i];\\n        }\\n        if(pos + neg != 0)\\n            return -1;\\n        return pos/k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        if(k==0) {\\n            for(int i=0;i<n;i++) \\n                if(nums1[i] != nums2[i])\\n                    return -1;\\n            return 0;\\n        }\\n        long neg = 0, pos = 0;\\n        for(int i=0;i<n;i++) {\\n            nums1[i] = nums1[i]-nums2[i];\\n            if(nums1[i]%k != 0)\\n                return -1;\\n            if(nums1[i]<0)\\n                neg += nums1[i];\\n            if(nums1[i]>0)\\n                pos += nums1[i];\\n        }\\n        if(pos + neg != 0)\\n            return -1;\\n        return pos/k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104458,
                "title": "easy-solution-c-simple-traversal",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n            \\n        if(k == 0) {\\n            return nums1 == nums2 ? 0 : -1;\\n        }\\n        \\n        long long poscount = 0, negcount = 0;\\n        \\n        for(int i = 0 ; i < nums1.size(); i++){\\n            long long diff = nums1[i] - nums2[i];\\n            \\n            if(diff%k) return -1;\\n            else if(diff > 0) poscount += diff/k;\\n            else negcount += diff/k;\\n        }\\n        \\n        if(poscount + negcount == 0) return poscount;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n            \\n        if(k == 0) {\\n            return nums1 == nums2 ? 0 : -1;\\n        }\\n        \\n        long long poscount = 0, negcount = 0;\\n        \\n        for(int i = 0 ; i < nums1.size(); i++){\\n            long long diff = nums1[i] - nums2[i];\\n            \\n            if(diff%k) return -1;\\n            else if(diff > 0) poscount += diff/k;\\n            else negcount += diff/k;\\n        }\\n        \\n        if(poscount + negcount == 0) return poscount;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102804,
                "title": "2541-minimum-operations-to-make-array-equal-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if(k==0){ if(Arrays.compare(nums1,nums2)==0) return 0;\\n          return -1;\\n        }\\n        long cnt =0,minus = 0 ;\\n        for(int i = 0 ; i < nums1.length ; i++){\\n            if(nums1[i] != nums2[i]){\\n                if(nums1[i]>nums2[i]){\\n                   if((nums1[i]-nums2[i])%k!=0){\\n                       return -1;\\n                   }\\n                   else{\\n                       cnt += (long)(nums1[i]-nums2[i])/k;\\n                   }\\n                }\\n                else{\\n                     if((nums2[i]-nums1[i])%k!=0){\\n                       return -1;\\n                   }\\n                   else{\\n                       minus += (long)(nums2[i]-nums1[i])/k;\\n                   }\\n                }\\n            }\\n        }\\n        if(cnt==minus)return cnt;\\n        else{\\n            if(cnt>minus){\\n                if(cnt-minus > 1)return -1;\\n                return cnt;\\n            }\\n            else{\\n                if(minus-cnt >1)return -1;\\n                return minus;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if(k==0){ if(Arrays.compare(nums1,nums2)==0) return 0;\\n          return -1;\\n        }\\n        long cnt =0,minus = 0 ;\\n        for(int i = 0 ; i < nums1.length ; i++){\\n            if(nums1[i] != nums2[i]){\\n                if(nums1[i]>nums2[i]){\\n                   if((nums1[i]-nums2[i])%k!=0){\\n                       return -1;\\n                   }\\n                   else{\\n                       cnt += (long)(nums1[i]-nums2[i])/k;\\n                   }\\n                }\\n                else{\\n                     if((nums2[i]-nums1[i])%k!=0){\\n                       return -1;\\n                   }\\n                   else{\\n                       minus += (long)(nums2[i]-nums1[i])/k;\\n                   }\\n                }\\n            }\\n        }\\n        if(cnt==minus)return cnt;\\n        else{\\n            if(cnt>minus){\\n                if(cnt-minus > 1)return -1;\\n                return cnt;\\n            }\\n            else{\\n                if(minus-cnt >1)return -1;\\n                return minus;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101394,
                "title": "easy-elegant-o-1-space-simple-mathematics-specially-for-beginner-s",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            // corner case;\\n            for(int i=0;i<nums1.size();i++)\\n                if(nums1[i]!=nums2[i])\\n                    return -1;\\n            return 0; // already equal;\\n        }\\n        vector<ll>vec;\\n        for(int i=0;i<nums1.size();i++)\\n            vec.push_back(nums2[i]-nums1[i]);\\n        \\n        ll posSum=0,negSum=0;\\n        for(auto x: vec){\\n            if(abs(x)%k!=0)\\n                return -1;\\n            if(x<0)\\n                negSum+=x;\\n            else\\n                posSum+=x;\\n        }\\n        \\n        if(negSum+posSum==0) // if this is possible and all the x\\'s are divisble by k\\n            return posSum/k;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            // corner case;\\n            for(int i=0;i<nums1.size();i++)\\n                if(nums1[i]!=nums2[i])\\n                    return -1;\\n            return 0; // already equal;\\n        }\\n        vector<ll>vec;\\n        for(int i=0;i<nums1.size();i++)\\n            vec.push_back(nums2[i]-nums1[i]);\\n        \\n        ll posSum=0,negSum=0;\\n        for(auto x: vec){\\n            if(abs(x)%k!=0)\\n                return -1;\\n            if(x<0)\\n                negSum+=x;\\n            else\\n                posSum+=x;\\n        }\\n        \\n        if(negSum+posSum==0) // if this is possible and all the x\\'s are divisble by k\\n            return posSum/k;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101317,
                "title": "make-difference-array-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        int[] arr=new int[nums1.length];\\n        long sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i]-nums2[i];\\n            if(k!=0){\\n                if(arr[i]%k!=0) return -1;\\n            }\\n            sum+=arr[i];\\n        }\\n         for(int i=0;i<arr.length;i++){\\n            if(arr[i]!=0 && k==0) return -1;\\n        }\\n        if(k==0) return 0;\\n        if(sum!=0) return -1;\\n        sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>=0) sum+=arr[i];\\n        }\\n        if(sum%k!=0) return -1;\\n        return sum/k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        int[] arr=new int[nums1.length];\\n        long sum=0;\\n        for(int i=0;i<nums1.length;i++){\\n            arr[i]=nums1[i]-nums2[i];\\n            if(k!=0){\\n                if(arr[i]%k!=0) return -1;\\n            }\\n            sum+=arr[i];\\n        }\\n         for(int i=0;i<arr.length;i++){\\n            if(arr[i]!=0 && k==0) return -1;\\n        }\\n        if(k==0) return 0;\\n        if(sum!=0) return -1;\\n        sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>=0) sum+=arr[i];\\n        }\\n        if(sum%k!=0) return -1;\\n        return sum/k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100496,
                "title": "easy-one-way-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse for Loop and then let compiler do its work.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTravse array and handle some corner cases.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n//MD ARHAM KALAM ANSARI\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums1==nums2) return 0;\\n        if(k==0) \\n        {\\n            if(nums1==nums2) return 0;\\n            else return -1;\\n        }\\n        long long a1=0,a2=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(nums1[i]-nums2[i]>0 and (nums1[i]-nums2[i])%k==0)\\n            {\\n                a1+=nums1[i]-nums2[i];\\n            }\\n            else if(nums1[i]-nums2[i]<0 and (nums2[i]-nums1[i])%k==0)\\n            {\\n                a2+=nums1[i]-nums2[i];\\n            }\\n            else if((nums1[i]-nums2[i])%k!=0) return -1;\\n        }\\n        if(a1==abs(a2) and a1!=0 and a2!=0)\\n        {\\n            return a1/k;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//MD ARHAM KALAM ANSARI\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums1==nums2) return 0;\\n        if(k==0) \\n        {\\n            if(nums1==nums2) return 0;\\n            else return -1;\\n        }\\n        long long a1=0,a2=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(nums1[i]-nums2[i]>0 and (nums1[i]-nums2[i])%k==0)\\n            {\\n                a1+=nums1[i]-nums2[i];\\n            }\\n            else if(nums1[i]-nums2[i]<0 and (nums2[i]-nums1[i])%k==0)\\n            {\\n                a2+=nums1[i]-nums2[i];\\n            }\\n            else if((nums1[i]-nums2[i])%k!=0) return -1;\\n        }\\n        if(a1==abs(a2) and a1!=0 and a2!=0)\\n        {\\n            return a1/k;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099953,
                "title": "very-easy-java-solution-understandable-linear-time-complexity-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        int n=nums1.length;\\n        //base case\\n        if(Arrays.equals(nums1,nums2)) return 0;\\n        if(k==0) return -1;\\n\\n        long incrementCount=0,decrementCount=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums1[i]!=nums2[i]){\\n                if(nums1[i]>nums2[i] && (nums1[i]-nums2[i])%k==0){\\n                    decrementCount+=(nums1[i]-nums2[i])/k;\\n                }else if((nums1[i]-nums2[i])%k!=0) return -1;\\n                if(nums1[i]<nums2[i] && (nums2[i]-nums1[i])%k==0){\\n                   incrementCount+=(nums2[i]-nums1[i])/k;\\n                }else if((nums2[i]-nums1[i])%k!=0) return -1;\\n            }\\n        }\\n       \\n        return (incrementCount==decrementCount) && (incrementCount!=0 && decrementCount!=0)?incrementCount:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        int n=nums1.length;\\n        //base case\\n        if(Arrays.equals(nums1,nums2)) return 0;\\n        if(k==0) return -1;\\n\\n        long incrementCount=0,decrementCount=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums1[i]!=nums2[i]){\\n                if(nums1[i]>nums2[i] && (nums1[i]-nums2[i])%k==0){\\n                    decrementCount+=(nums1[i]-nums2[i])/k;\\n                }else if((nums1[i]-nums2[i])%k!=0) return -1;\\n                if(nums1[i]<nums2[i] && (nums2[i]-nums1[i])%k==0){\\n                   incrementCount+=(nums2[i]-nums1[i])/k;\\n                }else if((nums2[i]-nums1[i])%k!=0) return -1;\\n            }\\n        }\\n       \\n        return (incrementCount==decrementCount) && (incrementCount!=0 && decrementCount!=0)?incrementCount:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099012,
                "title": "java-linear-time-complexity-solution",
                "content": "## Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n## Code\\n```\\nclass Solution {\\n    public long minOperations(int[] a, int[] b, int k) {\\n        if(k == 0 ) {\\n            for(int i=0;i<a.length;i++){\\n                 if(a[i] != b[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        long diff = 0, ans=0;\\n        for(int i=0;i<a.length;i++){\\n            if(Math.abs(a[i]-b[i])%k != 0) return -1;\\n            ans += Math.max(a[i] - b[i], 0)/k;\\n            diff += a[i] - b[i];\\n        }\\n        if(diff != 0) return -1;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] a, int[] b, int k) {\\n        if(k == 0 ) {\\n            for(int i=0;i<a.length;i++){\\n                 if(a[i] != b[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        long diff = 0, ans=0;\\n        for(int i=0;i<a.length;i++){\\n            if(Math.abs(a[i]-b[i])%k != 0) return -1;\\n            ans += Math.max(a[i] - b[i], 0)/k;\\n            diff += a[i] - b[i];\\n        }\\n        if(diff != 0) return -1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098632,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long minOperations(int[] nums1, int[] nums2, int k) {\\n    long ans = 0, def, sum = 0;\\n    if(k == 0){\\n      for(int i = 0; i != nums1.length; i++)\\n        if(nums2[i] != nums1[i]) return -1;\\n      return 0; \\n    }  \\n\\n    for(int i = 0; i != nums1.length; i++)\\n      if( Math.abs(def = nums2[i] - nums1[i])%k != 0) return -1;\\n      else {\\n        ans += Math.abs(def);\\n        sum += def;  \\n      }\\n          \\n    if(sum != 0) return -1;\\n    return (ans / k) / 2;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long minOperations(int[] nums1, int[] nums2, int k) {\\n    long ans = 0, def, sum = 0;\\n    if(k == 0){\\n      for(int i = 0; i != nums1.length; i++)\\n        if(nums2[i] != nums1[i]) return -1;\\n      return 0; \\n    }  \\n\\n    for(int i = 0; i != nums1.length; i++)\\n      if( Math.abs(def = nums2[i] - nums1[i])%k != 0) return -1;\\n      else {\\n        ans += Math.abs(def);\\n        sum += def;  \\n      }\\n          \\n    if(sum != 0) return -1;\\n    return (ans / k) / 2;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097787,
                "title": "simple-swift-solution-with-pseudo-code",
                "content": "# Pseudo Code\\n1. If k == 0, return 0 if nums1 == nums2, otherwise return -1\\n2. Initialize ops = 0, bal = 0\\n3. Iterate through nums1\\n4. Calculate diff = nums1[i] - nums2[i]\\n5. If diff % k != 0, return -1\\n6. If diff > 0, ops += diff / k\\n7. bal += diff\\n8. Return bal == 0 ? ops : -1\\n\\n# Complexity\\n> Time complexity: O(n)\\n> Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func minOperations(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {\\n        if k == 0 {\\n            return nums1 == nums2 ? 0 : -1\\n        }\\n        var ops = 0, bal = 0\\n        for i in 0 ..< nums1.count {\\n            let diff = nums1[i] - nums2[i]\\n            if diff % k != 0 {\\n                return -1\\n            }\\n            if diff > 0 {\\n                ops += diff / k\\n            }\\n            bal += diff\\n        } \\n        return bal == 0 ? ops : -1        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minOperations(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {\\n        if k == 0 {\\n            return nums1 == nums2 ? 0 : -1\\n        }\\n        var ops = 0, bal = 0\\n        for i in 0 ..< nums1.count {\\n            let diff = nums1[i] - nums2[i]\\n            if diff % k != 0 {\\n                return -1\\n            }\\n            if diff > 0 {\\n                ops += diff / k\\n            }\\n            bal += diff\\n        } \\n        return bal == 0 ? ops : -1        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097596,
                "title": "java-easy-solution",
                "content": "# Intuition\\nThe logic base on we will check each number of array nums1 and array nums2 => cause we must check whether the difference value between them is divided by 3 or not. \\nFor example: if the first value is 2 and the second value is 9 with k = 4 => the difference value between them is 7 % 4 != 0 => it means that we can not execute any operation to make 2 becomes 9.\\n# Approach\\n+ The first condition we will check the number operations that allows us execute \\n=> if k == 0, so we will check for each value of nums1 with each value of nums2 => if they are not equals => return -1;\\n+ We will declare two variables nums1_diff and nums1_diff => they mean: \\nnums1_diff is the total values if the value of nums1 greater than or equal value of nums2.\\nnums2_diff is the total values if the value of nums2 greater than value of nums1.\\nThen we will check if nums1_diff == nums2_diff it means that the number operaions that we need to execute to makes them equal then the result is nums1_diff/k or nums2_diff/k both of them are the same. \\n# Complexity\\n- Time complexity:\\nK == 0 Arrays.equals(nums1, nums2) => it takes => O(N) \\nCheck each value of nums1 with nums2 => it takes => O(N)\\n=> O(2N) => O(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            return Arrays.equals(nums1, nums2) ? 0 : -1;\\n        }\\n        long nums1_diff = 0, nums2_diff = 0;\\n        int len = nums1.length-1;\\n        for(int i = 0; i <= len; i++){\\n            if (nums1[i] >= nums2[i]) {\\n                if ((nums1[i] - nums2[i]) % k == 0) {\\n                    nums1_diff += nums1[i] - nums2[i];\\n                } else {\\n                    return -1;\\n                }\\n            }else{\\n                if ((nums2[i] - nums1[i]) % k == 0) {\\n                    nums2_diff += nums2[i] - nums1[i];\\n                }else{\\n                    return -1;\\n                }\\n            }\\n        }\\n        long ans = -1;\\n        return (nums1_diff - nums2_diff == 0) ? nums1_diff/k : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            return Arrays.equals(nums1, nums2) ? 0 : -1;\\n        }\\n        long nums1_diff = 0, nums2_diff = 0;\\n        int len = nums1.length-1;\\n        for(int i = 0; i <= len; i++){\\n            if (nums1[i] >= nums2[i]) {\\n                if ((nums1[i] - nums2[i]) % k == 0) {\\n                    nums1_diff += nums1[i] - nums2[i];\\n                } else {\\n                    return -1;\\n                }\\n            }else{\\n                if ((nums2[i] - nums1[i]) % k == 0) {\\n                    nums2_diff += nums2[i] - nums1[i];\\n                }else{\\n                    return -1;\\n                }\\n            }\\n        }\\n        long ans = -1;\\n        return (nums1_diff - nums2_diff == 0) ? nums1_diff/k : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097557,
                "title": "simple-c-solution-very-easy",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {        \\n            int n = nums1.size();\\n\\n            if(k == 0) return nums1 == nums2 ? 0 : -1;\\n            \\n            long long posDiff = 0;\\n            long long negDiff = 0;\\n            \\n            for(int idx = 0; idx < n; ++idx) {\\n                int diff = abs(nums1[idx] - nums2[idx]);\\n                if(diff % k != 0) return -1;\\n                if(nums1[idx] > nums2[idx]) posDiff += diff / k;\\n                else negDiff += diff / k;\\n            }\\n\\n            return posDiff == negDiff ? posDiff : -1;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {        \\n            int n = nums1.size();\\n\\n            if(k == 0) return nums1 == nums2 ? 0 : -1;\\n            \\n            long long posDiff = 0;\\n            long long negDiff = 0;\\n            \\n            for(int idx = 0; idx < n; ++idx) {\\n                int diff = abs(nums1[idx] - nums2[idx]);\\n                if(diff % k != 0) return -1;\\n                if(nums1[idx] > nums2[idx]) posDiff += diff / k;\\n                else negDiff += diff / k;\\n            }\\n\\n            return posDiff == negDiff ? posDiff : -1;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094931,
                "title": "simple-c-solution-using-greedy-method",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long count=0,count1=0;\\n        bool b=true;\\n        if(k==0)\\n        {\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                if(nums1[i]!=nums2[i])\\n                return -1;\\n            }\\n            return 0;\\n        }\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(nums1[i]<nums2[i])\\n            {\\n                if((nums2[i]-nums1[i])%k==0)\\n                count+=(nums2[i]-nums1[i])/k;\\n                else\\n                b=false;\\n            }\\n            else if(nums1[i]>nums2[i])\\n            {\\n                if((nums1[i]-nums2[i])%k==0)\\n                count1+=(nums1[i]-nums2[i])/k;\\n                else\\n                b=false;\\n            }\\n            \\n        }\\n        if(!b || count!=count1)\\n        return -1;\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long count=0,count1=0;\\n        bool b=true;\\n        if(k==0)\\n        {\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                if(nums1[i]!=nums2[i])\\n                return -1;\\n            }\\n            return 0;\\n        }\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(nums1[i]<nums2[i])\\n            {\\n                if((nums2[i]-nums1[i])%k==0)\\n                count+=(nums2[i]-nums1[i])/k;\\n                else\\n                b=false;\\n            }\\n            else if(nums1[i]>nums2[i])\\n            {\\n                if((nums1[i]-nums2[i])%k==0)\\n                count1+=(nums1[i]-nums2[i])/k;\\n                else\\n                b=false;\\n            }\\n            \\n        }\\n        if(!b || count!=count1)\\n        return -1;\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094579,
                "title": "simple-c-solution-using-array-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            if(nums1==nums2){\\n                return 0;\\n            }\\n            return -1;\\n        }\\n        long long neg=0;\\n        long long pos=0;\\n        for(int i=0;i<nums1.size();i++){\\n            int diff=(nums2[i]-nums1[i]);\\n            if(diff%k!=0){\\n                return -1;\\n            }\\n            else if(diff<0){\\n                neg+=(diff/k);\\n            }\\n            else{\\n                pos+=(diff/k);\\n            }\\n        }\\n        if(neg+pos!=0){\\n            return -1;\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(k==0){\\n            if(nums1==nums2){\\n                return 0;\\n            }\\n            return -1;\\n        }\\n        long long neg=0;\\n        long long pos=0;\\n        for(int i=0;i<nums1.size();i++){\\n            int diff=(nums2[i]-nums1[i]);\\n            if(diff%k!=0){\\n                return -1;\\n            }\\n            else if(diff<0){\\n                neg+=(diff/k);\\n            }\\n            else{\\n                pos+=(diff/k);\\n            }\\n        }\\n        if(neg+pos!=0){\\n            return -1;\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094263,
                "title": "a-few-solutions",
                "content": "Perform a linear scan of each value `a` and `b` of the input arrays `A` and `B` correspondingly.  If any difference `diff = a - b` is *not* evenly divisible by `K` immediately return `-1`, otherwise we `take` the absolute difference divided by `K` and accumulate the increments `inc` and decrements `dec` that we `take` to ensure \"balance.\"  If the increments `inc` and decrements `dec` are *not* equal, then we return `-1` (ie. *not* a \"balanced\" solution).\\n\\nNote: for the corner case when `K == 0`, then we return `0` if-and-only-if `A == B` otherwise `-1`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minOperations(A: IntArray, B: IntArray, K: Int): Long {\\n        if (K == 0)\\n            return if (A.contentEquals(B)) 0 else -1\\n        var (inc, dec) = Pair(0L, 0L)\\n        for ((a, b) in A zip B) {\\n            var diff = a - b\\n            if (diff % K != 0)\\n                return -1\\n            var take = Math.abs(diff) / K\\n            inc += if (0 < diff) take else 0\\n            dec += if (diff < 0) take else 0\\n        }\\n        return if (inc == dec) inc else -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minOperations = (A, B, K, inc = 0, dec = 0) => {\\n    if (!K)\\n        return _.isEqual(A, B) ? 0 : -1;\\n    for (let [a, b] of _.zip(A, B)) {\\n        let diff = a - b;\\n        if (diff % K)\\n            return -1;\\n        let take = Math.floor(Math.abs(diff) / K);\\n        inc += 0 < diff ? take : 0;\\n        dec += diff < 0 ? take : 0;\\n    }\\n    return inc == dec ? inc : -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minOperations(self, A: List[int], B: List[int], K: int, inc = 0, dec = 0) -> int:\\n        if not K:\\n            return 0 if A == B else -1\\n        for a, b in zip(A, B):\\n            diff = a - b\\n            if diff % K:\\n                return -1\\n            take = abs(diff) // K\\n            inc += take if diff < 0 else 0\\n            dec += take if 0 < diff else 0\\n        return inc if inc == dec else -1\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn min_operations(A: VI, B: VI, K: i32) -> i64 {\\n        if K == 0 {\\n            return if A == B { 0 } else { -1 };\\n        }\\n        let (mut inc, mut dec) = (0 as i64, 0 as i64);\\n        for (a, b) in A.iter().zip(B) {\\n            let diff = a - b;\\n            if diff % K != 0 {\\n                return -1;\\n            }\\n            let take = diff.abs() as i64 / K as i64;\\n            inc += if 0 < diff { take } else { 0 };\\n            dec += if diff < 0 { take } else { 0 };\\n        }\\n        if inc == dec { inc } else { -1 }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    LL minOperations(VI& A, VI& B, int K, LL inc = {}, LL dec = {}) {\\n        if (!K)\\n            return A == B ? 0 : -1;\\n        for (auto i{ 0 }; i < A.size(); ++i) {\\n            auto diff = A[i] - B[i];\\n            if (diff % K)\\n                return -1;\\n            auto take = abs(diff) / K;\\n            inc += 0 < diff ? take : 0;\\n            dec += diff < 0 ? take : 0;\\n        }\\n        return inc == dec ? inc : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minOperations(A: IntArray, B: IntArray, K: Int): Long {\\n        if (K == 0)\\n            return if (A.contentEquals(B)) 0 else -1\\n        var (inc, dec) = Pair(0L, 0L)\\n        for ((a, b) in A zip B) {\\n            var diff = a - b\\n            if (diff % K != 0)\\n                return -1\\n            var take = Math.abs(diff) / K\\n            inc += if (0 < diff) take else 0\\n            dec += if (diff < 0) take else 0\\n        }\\n        return if (inc == dec) inc else -1\\n    }\\n}\\n```\n```\\nlet minOperations = (A, B, K, inc = 0, dec = 0) => {\\n    if (!K)\\n        return _.isEqual(A, B) ? 0 : -1;\\n    for (let [a, b] of _.zip(A, B)) {\\n        let diff = a - b;\\n        if (diff % K)\\n            return -1;\\n        let take = Math.floor(Math.abs(diff) / K);\\n        inc += 0 < diff ? take : 0;\\n        dec += diff < 0 ? take : 0;\\n    }\\n    return inc == dec ? inc : -1;\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, A: List[int], B: List[int], K: int, inc = 0, dec = 0) -> int:\\n        if not K:\\n            return 0 if A == B else -1\\n        for a, b in zip(A, B):\\n            diff = a - b\\n            if diff % K:\\n                return -1\\n            take = abs(diff) // K\\n            inc += take if diff < 0 else 0\\n            dec += take if 0 < diff else 0\\n        return inc if inc == dec else -1\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn min_operations(A: VI, B: VI, K: i32) -> i64 {\\n        if K == 0 {\\n            return if A == B { 0 } else { -1 };\\n        }\\n        let (mut inc, mut dec) = (0 as i64, 0 as i64);\\n        for (a, b) in A.iter().zip(B) {\\n            let diff = a - b;\\n            if diff % K != 0 {\\n                return -1;\\n            }\\n            let take = diff.abs() as i64 / K as i64;\\n            inc += if 0 < diff { take } else { 0 };\\n            dec += if diff < 0 { take } else { 0 };\\n        }\\n        if inc == dec { inc } else { -1 }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    LL minOperations(VI& A, VI& B, int K, LL inc = {}, LL dec = {}) {\\n        if (!K)\\n            return A == B ? 0 : -1;\\n        for (auto i{ 0 }; i < A.size(); ++i) {\\n            auto diff = A[i] - B[i];\\n            if (diff % K)\\n                return -1;\\n            auto take = abs(diff) / K;\\n            inc += 0 < diff ? take : 0;\\n            dec += diff < 0 ? take : 0;\\n        }\\n        return inc == dec ? inc : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093883,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n\\n\\n        if(k==0){\\n            for(int i=0;i<nums1.length;i++){\\n                if(nums1[i]!=nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n\\n      long pos=0;\\n      long neg=0;\\n      for(int i=0;i<nums1.length;i++){\\n          long t=Math.abs(nums1[i]-nums2[i]);\\n          long q=t/k;\\n          if(t%k==0){\\n              long x=nums1[i]-nums2[i];\\n              if(x>0){ \\n                  pos=pos+q;\\n              }\\n              else{\\n                  neg=neg+q;\\n              }\\n          }\\n          else{\\n              return -1;\\n          }\\n      }\\n      if(pos==neg) return pos;\\n      return -1;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n\\n\\n        if(k==0){\\n            for(int i=0;i<nums1.length;i++){\\n                if(nums1[i]!=nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n\\n      long pos=0;\\n      long neg=0;\\n      for(int i=0;i<nums1.length;i++){\\n          long t=Math.abs(nums1[i]-nums2[i]);\\n          long q=t/k;\\n          if(t%k==0){\\n              long x=nums1[i]-nums2[i];\\n              if(x>0){ \\n                  pos=pos+q;\\n              }\\n              else{\\n                  neg=neg+q;\\n              }\\n          }\\n          else{\\n              return -1;\\n          }\\n      }\\n      if(pos==neg) return pos;\\n      return -1;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093430,
                "title": "simple-ts-solution",
                "content": "# Intuition\\nIterate throught the arrays and compare $$[i]$$ items. If they are equal -- go to the next iteration. Otherwise check wether it\\'s possible to divide the $$diff$$ by $$k$$ without $$reminder$$.\\nIf the $$reminder$$ exists it means that we cannot make the first array equal to the second one. In other case add the result of $$diff / k$$ (aka $$localCount$$) to the $$buff$$ and the absolute value of $$localCount$$ to the $$count$$ variable -- we change the balance of substractions/additions in $$buff$$ and operations number in $$count$$.\\n\\nIn the end you should check the $$buff$$ and if it\\'s not $$0$$, it means that the number of subtractions was not equal of the number of additions, we cannot solve the problem. Otherwise divide the $$count$$ by $$2$$ and this will be the answer.\\n\\n\\n# Code\\n```\\nfunction minOperations(nums1: number[], nums2: number[], k: number): number {\\n    let buff = 0;\\n    let count = 0;\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        const diff = nums1[i] - nums2[i];\\n\\n        if (diff === 0) {\\n            continue;\\n        }\\n\\n        if (diff % k !== 0) {\\n            buff = k + 1;\\n            break;\\n        }\\n\\n        const localCount = diff / k;\\n\\n        buff += localCount;\\n        count += Math.abs(localCount);\\n    }\\n\\n    return buff === 0 ? count / 2 : -1;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minOperations(nums1: number[], nums2: number[], k: number): number {\\n    let buff = 0;\\n    let count = 0;\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        const diff = nums1[i] - nums2[i];\\n\\n        if (diff === 0) {\\n            continue;\\n        }\\n\\n        if (diff % k !== 0) {\\n            buff = k + 1;\\n            break;\\n        }\\n\\n        const localCount = diff / k;\\n\\n        buff += localCount;\\n        count += Math.abs(localCount);\\n    }\\n\\n    return buff === 0 ? count / 2 : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3092762,
                "title": "c-simple-o-n-one-pass-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe difference of each entry of `nums1`, `nums2` should be multiple of k. In addition, the sum of `nums1` should be equal to `nums2`. \\n\\nThe answer is the sum of positive difference of $\\\\sum_{i: nums1[i] - nums2[i] > 0} nums1[i] - nums2[i]$ divided by k.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy algorithm. Find the elementwise positive and negative differences between two arrays and check if it is possible to make the arrays equal using the criteria: \\n1. The difference of each entry of `nums1`, `nums2` should be multiples of k.\\n2. The sum of `nums1` should be equal to `nums2`. \\n\\nA special case happens when $k = 0$. If any entry of nums1, nums2 are different, it is impossible to make two arrays equal. The answer exists only when nums1, nums2 are elementwise equal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long res = 0, ups = 0, downs = 0;\\n        int n = nums1.size();\\n        if (k == 0) {\\n            if (nums1 == nums2) {return 0;}\\n            return -1;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            int x = nums1[i] - nums2[i];\\n            if (x % k) return -1;\\n            if (x > 0)      {ups   +=  x/k;}\\n            else if (x < 0) {downs += -x/k;}\\n        }\\n        if (ups != downs) return -1;\\n        return ups;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long res = 0, ups = 0, downs = 0;\\n        int n = nums1.size();\\n        if (k == 0) {\\n            if (nums1 == nums2) {return 0;}\\n            return -1;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            int x = nums1[i] - nums2[i];\\n            if (x % k) return -1;\\n            if (x > 0)      {ups   +=  x/k;}\\n            else if (x < 0) {downs += -x/k;}\\n        }\\n        if (ups != downs) return -1;\\n        return ups;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092601,
                "title": "golang-one-pass",
                "content": "```\\nfunc minOperations(n1 []int, n2 []int, k int) int64 {\\n\\tif k == 0 {\\n\\t\\tfor i := 0; i < len(n1); i++ {\\n\\t\\t\\tif n1[i] != n2[i] {\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0\\n\\t}\\n\\tabs := func(x int) int {\\n\\t\\tif x > 0 {\\n\\t\\t\\treturn x\\n\\t\\t}\\n\\t\\treturn -x\\n\\t}\\n\\tdm, ip, a := 0, 0, 0\\n\\tfor i := 0; i < len(n1); i++ {\\n\\t\\tif n1[i] == n2[i] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\td := abs(n1[i] - n2[i])\\n\\t\\tif d%k != 0 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\tc := d / k\\n\\t\\ta += c\\n\\t\\tif n1[i] > n2[i] {\\n\\t\\t\\tdm += c\\n\\t\\t\\tip -= c\\n\\t\\t} else {\\n\\t\\t\\tdm -= c\\n\\t\\t\\tip += c\\n\\t\\t}\\n\\t}\\n\\tif dm != 0 || ip != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn int64(a / 2)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minOperations(n1 []int, n2 []int, k int) int64 {\\n\\tif k == 0 {\\n\\t\\tfor i := 0; i < len(n1); i++ {\\n\\t\\t\\tif n1[i] != n2[i] {\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0\\n\\t}\\n\\tabs := func(x int) int {\\n\\t\\tif x > 0 {\\n\\t\\t\\treturn x\\n\\t\\t}\\n\\t\\treturn -x\\n\\t}\\n\\tdm, ip, a := 0, 0, 0\\n\\tfor i := 0; i < len(n1); i++ {\\n\\t\\tif n1[i] == n2[i] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\td := abs(n1[i] - n2[i])\\n\\t\\tif d%k != 0 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\tc := d / k\\n\\t\\ta += c\\n\\t\\tif n1[i] > n2[i] {\\n\\t\\t\\tdm += c\\n\\t\\t\\tip -= c\\n\\t\\t} else {\\n\\t\\t\\tdm -= c\\n\\t\\t\\tip += c\\n\\t\\t}\\n\\t}\\n\\tif dm != 0 || ip != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn int64(a / 2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3092190,
                "title": "simple-java-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long res = 0, sum = 0;\\n        if (k == 0) {\\n            for (int i = 0; i < nums1.length; i++) {\\n                if (nums1[i] != nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        for (int i = 0; i < nums1.length; i++) {\\n            if ((nums1[i] - nums2[i]) % k != 0) return -1;\\n            if (nums1[i] > nums2[i]) {\\n                res += (nums1[i] - nums2[i]) / k;\\n            }\\n            sum += (nums1[i] - nums2[i]) / k;\\n        }\\n        return sum == 0 ? res : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long res = 0, sum = 0;\\n        if (k == 0) {\\n            for (int i = 0; i < nums1.length; i++) {\\n                if (nums1[i] != nums2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        for (int i = 0; i < nums1.length; i++) {\\n            if ((nums1[i] - nums2[i]) % k != 0) return -1;\\n            if (nums1[i] > nums2[i]) {\\n                res += (nums1[i] - nums2[i]) / k;\\n            }\\n            sum += (nums1[i] - nums2[i]) / k;\\n        }\\n        return sum == 0 ? res : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091792,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long a=0,b=0;\\n        for(int i=0;i<nums1.length;i++){\\n            if(nums1[i]==nums2[i])\\n            continue;    \\n           int w=Math.abs(nums1[i]-nums2[i]); \\n           if(k==0)\\n           return -1;\\n           else if(w%k == 0){\\n               if(nums1[i]>nums2[i]){\\n                   a+=(long)w/k;\\n               }\\n               else{\\n                   b+=(long)w/k;\\n               }\\n               \\n           }  \\n           else{\\n               return -1;\\n\\n           }    \\n\\n        }       \\n        if(a==b)\\n        return a;\\n        else{\\n            return -1;\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        long a=0,b=0;\\n        for(int i=0;i<nums1.length;i++){\\n            if(nums1[i]==nums2[i])\\n            continue;    \\n           int w=Math.abs(nums1[i]-nums2[i]); \\n           if(k==0)\\n           return -1;\\n           else if(w%k == 0){\\n               if(nums1[i]>nums2[i]){\\n                   a+=(long)w/k;\\n               }\\n               else{\\n                   b+=(long)w/k;\\n               }\\n               \\n           }  \\n           else{\\n               return -1;\\n\\n           }    \\n\\n        }       \\n        if(a==b)\\n        return a;\\n        else{\\n            return -1;\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091765,
                "title": "why-greedy-works-explaination",
                "content": "I got stuck during the contest since I was trying to find the best match between two elements to make them equal. When I saw the solution from others, I realize that I don\\'t need to do this. \\n\\nJust think about an optimal solution, when seeing two elements(nums1[i] and nums2[i]) from their respect array, the best operation is to add k to the small one or deduct k from the bigger one. What is the best way to do this? It\\'s not necessarry to make the decision right away because we don\\'t need to give the detail. Let\\'s add k to nums2[i], and plus op2(operation to nums2) with \"diff/k\" if nums1[i] > nums2[i]. Otherwise, add k to nums1[i], and plus op1(operation to nums1) with \"diff/k\" if nums1[i] < nums2[i].\\nFinally, op1 or op2 is the answer if they\\'re equivalent, otherwise -1. \\n\\nEither adding k to a smaller one or subtracting k to a bigger one is equivalent operation because we only need the total number of operation instead of detail assignment to each element.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            return Arrays.equals(nums1,nums2) ? 0 : -1;\\n        }\\n        int n = nums1.length;\\n        long op1 = 0,op2 = 0;\\n        for (int i=0;i<n;i++) {\\n            if (nums1[i] == nums2[i]) continue;\\n            long diff = Math.abs(nums1[i] - nums2[i]);\\n            if (diff%k == 0) {\\n                if (nums1[i] > nums2[i]) op2 += diff/k;\\n                else op1 += diff/k;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        \\n        return op1 == op2 ? op1: -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            return Arrays.equals(nums1,nums2) ? 0 : -1;\\n        }\\n        int n = nums1.length;\\n        long op1 = 0,op2 = 0;\\n        for (int i=0;i<n;i++) {\\n            if (nums1[i] == nums2[i]) continue;\\n            long diff = Math.abs(nums1[i] - nums2[i]);\\n            if (diff%k == 0) {\\n                if (nums1[i] > nums2[i]) op2 += diff/k;\\n                else op1 += diff/k;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        \\n        return op1 == op2 ? op1: -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091764,
                "title": "why-greedy-works-explaination",
                "content": "I got stuck during the contest since I was trying to find the best match between two elements to make them equal. When I saw the solution from others, I realize that I don\\'t need to do this. \\n\\nJust think about an optimal solution, when seeing two elements(nums1[i] and nums2[i]) from their respect array, the best operation is to add k to the small one or deduct k from the bigger one. What is the best way to do this? It\\'s not necessarry to make the decision right away because we don\\'t need to give the detail. Let\\'s add k to nums2[i], and plus op2(operation to nums2) with \"diff/k\" if nums1[i] > nums2[i]. Otherwise, add k to nums1[i], and plus op1(operation to nums1) with \"diff/k\" if nums1[i] < nums2[i].\\nFinally, op1 or op2 is the answer if they\\'re equivalent, otherwise -1. \\n\\nEither adding k to a smaller one or subtracting k to a bigger one is equivalent operation because we only need the total number of operation instead of detail assignment to each element.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            return Arrays.equals(nums1,nums2) ? 0 : -1;\\n        }\\n        int n = nums1.length;\\n        long op1 = 0,op2 = 0;\\n        for (int i=0;i<n;i++) {\\n            if (nums1[i] == nums2[i]) continue;\\n            long diff = Math.abs(nums1[i] - nums2[i]);\\n            if (diff%k == 0) {\\n                if (nums1[i] > nums2[i]) op2 += diff/k;\\n                else op1 += diff/k;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        \\n        return op1 == op2 ? op1: -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) {\\n            return Arrays.equals(nums1,nums2) ? 0 : -1;\\n        }\\n        int n = nums1.length;\\n        long op1 = 0,op2 = 0;\\n        for (int i=0;i<n;i++) {\\n            if (nums1[i] == nums2[i]) continue;\\n            long diff = Math.abs(nums1[i] - nums2[i]);\\n            if (diff%k == 0) {\\n                if (nums1[i] > nums2[i]) op2 += diff/k;\\n                else op1 += diff/k;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        \\n        return op1 == op2 ? op1: -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091714,
                "title": "easy-best-solution-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums1==nums2)\\n            return 0;\\n        if(k==0)\\n            return -1;\\n        long size=nums1.size(),neg_oper=0,pos_oper=0;\\n        for(int i=0;i<size;i++){\\n            nums1[i]-=nums2[i];\\n            if(abs(nums1[i])%k)\\n                return -1;\\n            if(nums1[i]<0)\\n                neg_oper+=abs(nums1[i])/k;\\n            else if(nums1[i]>0)\\n                pos_oper+=nums1[i]/k;\\n        }\\n        if(neg_oper!=pos_oper)\\n            return -1;\\n        return neg_oper;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums1==nums2)\\n            return 0;\\n        if(k==0)\\n            return -1;\\n        long size=nums1.size(),neg_oper=0,pos_oper=0;\\n        for(int i=0;i<size;i++){\\n            nums1[i]-=nums2[i];\\n            if(abs(nums1[i])%k)\\n                return -1;\\n            if(nums1[i]<0)\\n                neg_oper+=abs(nums1[i])/k;\\n            else if(nums1[i]>0)\\n                pos_oper+=nums1[i]/k;\\n        }\\n        if(neg_oper!=pos_oper)\\n            return -1;\\n        return neg_oper;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091355,
                "title": "easy-beginner-friendly-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums1==nums2)return 0;\\n        if(k==0) return -1;\\n        long long sum=0,a=0,n=nums1.size();\\n        for(long long i=0;i<n;i++){\\n            if(nums1[i]!=nums2[i]){\\n                long long x=nums1[i]-nums2[i];\\n                sum+=x;\\n                if(x%k!=0)return -1;\\n                if(x>0)a+=x;\\n            }\\n        }\\n        return sum!=0?-1:a/k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums1==nums2)return 0;\\n        if(k==0) return -1;\\n        long long sum=0,a=0,n=nums1.size();\\n        for(long long i=0;i<n;i++){\\n            if(nums1[i]!=nums2[i]){\\n                long long x=nums1[i]-nums2[i];\\n                sum+=x;\\n                if(x%k!=0)return -1;\\n                if(x>0)a+=x;\\n            }\\n        }\\n        return sum!=0?-1:a/k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091301,
                "title": "simple-beginner-friendly-main-logic-in-4-lines",
                "content": "\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long positive=0,negative=0;\\n        if(k==0) return nums1==nums2 ? 0 : -1;\\n        \\n\\n        for(int i=0;i<nums1.size();i++){\\n\\n            int diff = nums1[i] - nums2[i];\\n            if((diff%k)!=0) return -1;\\n            if(diff>0) positive += diff;\\n            else negative += diff;\\n\\n        }\\n        \\n        return positive + negative !=0 ? -1 : positive/k;\\n        \\n    }\\n};\\n```\\n\\nHope you like it , kindly upvote it.",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n        long long positive=0,negative=0;\\n        if(k==0) return nums1==nums2 ? 0 : -1;\\n        \\n\\n        for(int i=0;i<nums1.size();i++){\\n\\n            int diff = nums1[i] - nums2[i];\\n            if((diff%k)!=0) return -1;\\n            if(diff>0) positive += diff;\\n            else negative += diff;\\n\\n        }\\n        \\n        return positive + negative !=0 ? -1 : positive/k;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089867,
                "title": "java-simple-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Method:\\ncheck first if we can make the array equal. it can be done using basic ideas:\\n- number of operation in num1 must be equal to number of operation in num2.\\n- the difference between num1[i] and num2[i] mus be divisible by k.\\n- the total value added in num1 and num2 sum must be zero.(Conservating both side same number as adding and subtracting).\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] num1, int[] num2, int k) {\\n        if(k==0){\\n            for(int i=0;i<num1.length;i++){\\n                if(num1[i]!=num2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        int counter=0;\\n        long ans=0;\\n        for(int i=0;i<num1.length;i++){\\n            if((num1[i]-num2[i])%k!=0) return -1;\\n            int n= (num1[i]-num2[i])/k;\\n            counter+=n;\\n            if((n)>0) ans=ans+n;\\n        }\\n        if(counter!=0) return -1;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] num1, int[] num2, int k) {\\n        if(k==0){\\n            for(int i=0;i<num1.length;i++){\\n                if(num1[i]!=num2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        int counter=0;\\n        long ans=0;\\n        for(int i=0;i<num1.length;i++){\\n            if((num1[i]-num2[i])%k!=0) return -1;\\n            int n= (num1[i]-num2[i])/k;\\n            counter+=n;\\n            if((n)>0) ans=ans+n;\\n        }\\n        if(counter!=0) return -1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088888,
                "title": "java-one-pass",
                "content": "```\\n    //1.one pass\\n    //Runtime: 3ms 100%; Memory: 60.3MB 88%\\n    //Time: O(N); Space: O(1)\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) return Arrays.equals(nums1, nums2) ? 0 : -1;\\n        long res = 0, total = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            int val = nums1[i] - nums2[i];\\n            if (val == 0) continue;\\n            if (val % k != 0) return -1;\\n            total += val;\\n            if (val > 0) res += val / k;\\n        }\\n        return total == 0 ? res : -1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //1.one pass\\n    //Runtime: 3ms 100%; Memory: 60.3MB 88%\\n    //Time: O(N); Space: O(1)\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if (k == 0) return Arrays.equals(nums1, nums2) ? 0 : -1;\\n        long res = 0, total = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            int val = nums1[i] - nums2[i];\\n            if (val == 0) continue;\\n            if (val % k != 0) return -1;\\n            total += val;\\n            if (val > 0) res += val / k;\\n        }\\n        return total == 0 ? res : -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3088819,
                "title": "very-simple-logic-solution-begineer-friendly-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n//     [4,3,1,4], nums2 = [1,3,7,1], k = 3\\n//         // 1 3 4 4         1 1 3 7\\n//         -3 0 6 -3\\n    \\n    long long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n        if(n1==n2) return 0;\\n        if(k==0 and n1!=n2) return -1;\\n        int n=n1.size();\\n        vector<int>v(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(n1[i]==n2[i]) continue;\\n            else{\\n                if(n1[i]>n2[i]){\\n                    v[i]=n2[i]-n1[i];\\n                    if(v[i]%k!=0) return -1;\\n                    v[i]=v[i]/k;\\n                }\\n                else{\\n                     v[i]=n2[i]-n1[i];\\n                    if(v[i]%k!=0) return -1;\\n                    v[i]=v[i]/k;\\n                }\\n            }\\n        }\\n        long long int sm=0;\\n        for(auto it:v) sm+=it;\\n        if(sm!=0) return -1;\\n        long long int cnt=0;\\n        for(auto it:v){\\n            if(it>0) cnt+=it;\\n        }\\n        return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n//     [4,3,1,4], nums2 = [1,3,7,1], k = 3\\n//         // 1 3 4 4         1 1 3 7\\n//         -3 0 6 -3\\n    \\n    long long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n        if(n1==n2) return 0;\\n        if(k==0 and n1!=n2) return -1;\\n        int n=n1.size();\\n        vector<int>v(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(n1[i]==n2[i]) continue;\\n            else{\\n                if(n1[i]>n2[i]){\\n                    v[i]=n2[i]-n1[i];\\n                    if(v[i]%k!=0) return -1;\\n                    v[i]=v[i]/k;\\n                }\\n                else{\\n                     v[i]=n2[i]-n1[i];\\n                    if(v[i]%k!=0) return -1;\\n                    v[i]=v[i]/k;\\n                }\\n            }\\n        }\\n        long long int sm=0;\\n        for(auto it:v) sm+=it;\\n        if(sm!=0) return -1;\\n        long long int cnt=0;\\n        for(auto it:v){\\n            if(it>0) cnt+=it;\\n        }\\n        return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088388,
                "title": "minimum-operations-to-make-array-equal-ii-explained-c-easy-to-understand",
                "content": "**Best Solution **\\n Using Greedy Approach !!!\\n* First Calculated the difference between Each Element of The 2 arrays\\n* Now Sort The Difference Array..\\n* Now Since the Array is Sorted , make a leftSum for sum of all -ve Elements & rightSum for all +ve Elements..\\n* If leftSum == rightSum : Then return the RightSum / k as Answer...\\n* Else Return -1 \\nIf k == 0 then check if firstArray == second Array return 0 Else return -1;\\n```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n         // nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3\\n        int n = nums1.size();\\n        if(k==0) return (nums1 == nums2) ? 0 : -1;\\n        vector<long long int> diff(n);\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            diff[i] = nums1[i] - nums2[i];\\n            if(diff[i]%k!=0) return -1;\\n        }\\n        sort(diff.begin() , diff.end());\\n        long long int l = 0,r = 0;\\n        long long int lsm = 0 , rsm = 0;\\n        while(l<n && diff[l]<0)\\n        {\\n            lsm += diff[l];\\n            l++;\\n        }\\n        while(l<n)\\n        {\\n            rsm += diff[l];\\n            l++;\\n        }\\n        // cout<<lsm<<\" \"<<rsm;\\n        if(abs(lsm) == rsm )\\n        {\\n            if(lsm%k==0)\\n            {\\n                long long int ans = rsm/k;\\n                return ans;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& nums1, vector<int>& nums2, int k) {\\n         // nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3\\n        int n = nums1.size();\\n        if(k==0) return (nums1 == nums2) ? 0 : -1;\\n        vector<long long int> diff(n);\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            diff[i] = nums1[i] - nums2[i];\\n            if(diff[i]%k!=0) return -1;\\n        }\\n        sort(diff.begin() , diff.end());\\n        long long int l = 0,r = 0;\\n        long long int lsm = 0 , rsm = 0;\\n        while(l<n && diff[l]<0)\\n        {\\n            lsm += diff[l];\\n            l++;\\n        }\\n        while(l<n)\\n        {\\n            rsm += diff[l];\\n            l++;\\n        }\\n        // cout<<lsm<<\" \"<<rsm;\\n        if(abs(lsm) == rsm )\\n        {\\n            if(lsm%k==0)\\n            {\\n                long long int ans = rsm/k;\\n                return ans;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3088311,
                "title": "java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n\\n        long ans = 0l;\\n        long val = 0l;\\n\\n        for(int i=0; i<nums1.length; i++){\\n\\n            if(nums1[i] > nums2[i]){\\n                int diff = nums1[i] - nums2[i];\\n\\n                if(k == 0 || diff%k != 0){ return -1l; }\\n\\n                val -= diff;\\n                ans += (diff/k);\\n\\n            }\\n            else if(nums1[i] < nums2[i]){\\n                int diff = nums2[i] - nums1[i];\\n\\n                if(k == 0 || diff%k != 0){ return -1l; }\\n\\n                val += diff;\\n                ans += (diff/k);\\n                \\n            }\\n\\n        }\\n\\n        return val == 0 ?(ans/2) :-1l;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n\\n        long ans = 0l;\\n        long val = 0l;\\n\\n        for(int i=0; i<nums1.length; i++){\\n\\n            if(nums1[i] > nums2[i]){\\n                int diff = nums1[i] - nums2[i];\\n\\n                if(k == 0 || diff%k != 0){ return -1l; }\\n\\n                val -= diff;\\n                ans += (diff/k);\\n\\n            }\\n            else if(nums1[i] < nums2[i]){\\n                int diff = nums2[i] - nums1[i];\\n\\n                if(k == 0 || diff%k != 0){ return -1l; }\\n\\n                val += diff;\\n                ans += (diff/k);\\n                \\n            }\\n\\n        }\\n\\n        return val == 0 ?(ans/2) :-1l;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088170,
                "title": "golang-101-ms-9-1-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\nfunc minOperations(nums1 []int, nums2 []int, k int) int64 {\\n\\tif k == 0 {\\n\\t\\tfor i := range nums1 {\\n\\t\\t\\tif nums1[i] != nums2[i] {\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0\\n\\t}\\n\\tvar positive, negative int\\n\\tfor i := range nums1 {\\n\\t\\tdiff := nums1[i] - nums2[i]\\n\\t\\tif diff%k != 0 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\tif diff >= 0 {\\n\\t\\t\\tpositive += diff\\n\\t\\t} else {\\n\\t\\t\\tnegative += diff\\n\\t\\t}\\n\\t}\\n\\tif positive != -negative {\\n\\t\\treturn -1\\n\\t}\\n\\treturn int64(positive / k)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minOperations(nums1 []int, nums2 []int, k int) int64 {\\n\\tif k == 0 {\\n\\t\\tfor i := range nums1 {\\n\\t\\t\\tif nums1[i] != nums2[i] {\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0\\n\\t}\\n\\tvar positive, negative int\\n\\tfor i := range nums1 {\\n\\t\\tdiff := nums1[i] - nums2[i]\\n\\t\\tif diff%k != 0 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\tif diff >= 0 {\\n\\t\\t\\tpositive += diff\\n\\t\\t} else {\\n\\t\\t\\tnegative += diff\\n\\t\\t}\\n\\t}\\n\\tif positive != -negative {\\n\\t\\treturn -1\\n\\t}\\n\\treturn int64(positive / k)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3087976,
                "title": "java-my-thought-on-performing-operations-that-are-hard-to-simulate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe should only consider the start state and the final state.\\nProblems of this type are often sovled by math method.\\nWe can not show the result is the least number of operations, and we don\\'t know what exact operations it need.\\nWe only consider the best case, there always exists a series of operations that has the least step, could get to the final state.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst consider the cases that could not get the final state.\\nWhen the diff is not a multiple of k.\\nWhen the sum of all the diffs is not 0.\\n\\nThen consider the least steps.\\nDon\\'t try to simulate the process. Only consider the best case. \\nBest case: No step is a waste. Every step helps us to reduce the difference.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        //0 6  3 -9\\n        if(k==0){\\n            if(Arrays.equals(nums1, nums2)){\\n                return 0;\\n            }else{\\n                return -1;\\n            }\\n        }\\n        long pos=0, neg=0;\\n        int n=nums1.length;\\n        for(int i=0;i<n;i++){\\n            int diff=nums2[i]-nums1[i];\\n            if(diff%k!=0){\\n                return -1;\\n            }\\n            if(diff>0){\\n                pos+=diff/k;\\n            }\\n            else{\\n                neg+=diff/k;\\n            }\\n        }\\n        if(pos+neg!=0){\\n            return -1;\\n        }\\n        return pos;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        //0 6  3 -9\\n        if(k==0){\\n            if(Arrays.equals(nums1, nums2)){\\n                return 0;\\n            }else{\\n                return -1;\\n            }\\n        }\\n        long pos=0, neg=0;\\n        int n=nums1.length;\\n        for(int i=0;i<n;i++){\\n            int diff=nums2[i]-nums1[i];\\n            if(diff%k!=0){\\n                return -1;\\n            }\\n            if(diff>0){\\n                pos+=diff/k;\\n            }\\n            else{\\n                neg+=diff/k;\\n            }\\n        }\\n        if(pos+neg!=0){\\n            return -1;\\n        }\\n        return pos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087851,
                "title": "7-lines-scala-solution",
                "content": "# Code\\n```\\n  def minOperations(nums1: Array[Int], nums2: Array[Int], k: Int): Long = {\\n    lazy val (_neg,_pos) = (nums1 zip nums2).toList.map{case (a,b) => a - b}\\n      .filter(_ != 0).groupBy(identity).mapValues(_.size).partition{_._1 < 0}\\n    lazy val (neg,pos) = (_neg.map{case (a,b) => -a -> b}.toMap, _pos.toMap)\\n    lazy val counts = List(neg,pos).map(_.map{case (x,v) => (x.toLong/k)*v}.sum)\\n    if(k==0) {if((nums1 zip nums2).forall{case (a,b) => a==b}) 0 else -1}\\n    else if(((neg.keys)++(pos.keys)).exists{x=>x%k!=0} || counts(0)!=counts(1)) -1\\n    else counts.head\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  def minOperations(nums1: Array[Int], nums2: Array[Int], k: Int): Long = {\\n    lazy val (_neg,_pos) = (nums1 zip nums2).toList.map{case (a,b) => a - b}\\n      .filter(_ != 0).groupBy(identity).mapValues(_.size).partition{_._1 < 0}\\n    lazy val (neg,pos) = (_neg.map{case (a,b) => -a -> b}.toMap, _pos.toMap)\\n    lazy val counts = List(neg,pos).map(_.map{case (x,v) => (x.toLong/k)*v}.sum)\\n    if(k==0) {if((nums1 zip nums2).forall{case (a,b) => a==b}) 0 else -1}\\n    else if(((neg.keys)++(pos.keys)).exists{x=>x%k!=0} || counts(0)!=counts(1)) -1\\n    else counts.head\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3087667,
                "title": "golang-solution-pos-neg-explanation",
                "content": "# Intuition\\nWe don\\'t need to use indices or actually perform the operations. We only need to know if this is possible and how many operations we need to apply on the arrays. \\n\\n# Approach\\nFirst, we need to check if the arrays are equal (return 0), and not equal to 0 (return -1).\\nThen, iterate over the `nums1` and:\\n1. Calculate a mod, for example, if we have a difference between `nums1[i]` and `nums2[i]` = 5 and k is equal to 10, we may immediately return -1, since we can\\'t apply any operations according to the rules.\\n2. Use the `pos` variable to sum all positive steps.\\n3. Use the `neg` variable to sum all negative steps.\\n4. If `neg` + `pos` != 0, we have an unbalanced difference. We don\\'t have enough numbers to subtract and add to negative to make the arrays the same. Return -1.\\n5. The last step is to divide the positive number by k and get the number of steps.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ - we use only few stack variables.\\n\\n# Code\\n```\\nimport (\\n\\t\"math\"\\n)\\n\\nfunc minOperations(nums1 []int, nums2 []int, k int) int64 {\\n\\tif len(nums1) == 0 {\\n\\t\\treturn -1\\n\\t}\\n    \\n    noDiff := true\\n\\tfor i := 0; i < len(nums1); i++ {\\n\\t\\tif nums1[i] != nums2[i] {\\n\\t\\t\\tnoDiff = false\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tif noDiff {\\n\\t\\treturn 0\\n\\t}\\n    \\n\\tpos := 0\\n\\tneg := 0\\n\\n\\tfor i := 0; i < len(nums1); i++ {\\n\\t\\tif math.Mod(math.Abs(float64(nums2[i]-nums1[i])), float64(k)) != 0 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\n\\t\\tval := nums2[i] - nums1[i]\\n\\t\\tif val == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif val > 0 {\\n\\t\\t\\tpos += val\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tneg += val\\n\\t}\\n\\n\\tif neg+pos != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\treturn int64(pos / k)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport (\\n\\t\"math\"\\n)\\n\\nfunc minOperations(nums1 []int, nums2 []int, k int) int64 {\\n\\tif len(nums1) == 0 {\\n\\t\\treturn -1\\n\\t}\\n    \\n    noDiff := true\\n\\tfor i := 0; i < len(nums1); i++ {\\n\\t\\tif nums1[i] != nums2[i] {\\n\\t\\t\\tnoDiff = false\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tif noDiff {\\n\\t\\treturn 0\\n\\t}\\n    \\n\\tpos := 0\\n\\tneg := 0\\n\\n\\tfor i := 0; i < len(nums1); i++ {\\n\\t\\tif math.Mod(math.Abs(float64(nums2[i]-nums1[i])), float64(k)) != 0 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\n\\t\\tval := nums2[i] - nums1[i]\\n\\t\\tif val == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif val > 0 {\\n\\t\\t\\tpos += val\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tneg += val\\n\\t}\\n\\n\\tif neg+pos != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\treturn int64(pos / k)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3087342,
                "title": "java-simple-2-heaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) -> (assuming half goes to positive and half to negative)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if(k == 0) return (Arrays.equals(nums1, nums2)) ? 0 : -1;\\n       PriorityQueue<Long> pos = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n       PriorityQueue<Long> neg = new PriorityQueue<>();\\n       for(int i = 0; i < nums1.length; i++) {\\n           Long ans = (long)(nums1[i] - nums2[i]);\\n           if(ans % k != 0) return -1l;\\n           if(ans > 0) pos.add(ans / k);\\n           else if(ans < 0) neg.add(ans / k);\\n       }\\n       long steps = 0l;\\n       while(!pos.isEmpty() && !neg.isEmpty()) {\\n           Long poters = pos.poll();\\n           Long nutters = neg.poll();\\n           steps += Math.min(poters, Math.abs(nutters));\\n           Long pend = poters + nutters;\\n           if(pend > 0) pos.add(pend);\\n           else if(pend < 0) neg.add(pend);\\n       }\\n       if(!pos.isEmpty() || !neg.isEmpty()) return -1l;\\n       return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minOperations(int[] nums1, int[] nums2, int k) {\\n        if(k == 0) return (Arrays.equals(nums1, nums2)) ? 0 : -1;\\n       PriorityQueue<Long> pos = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n       PriorityQueue<Long> neg = new PriorityQueue<>();\\n       for(int i = 0; i < nums1.length; i++) {\\n           Long ans = (long)(nums1[i] - nums2[i]);\\n           if(ans % k != 0) return -1l;\\n           if(ans > 0) pos.add(ans / k);\\n           else if(ans < 0) neg.add(ans / k);\\n       }\\n       long steps = 0l;\\n       while(!pos.isEmpty() && !neg.isEmpty()) {\\n           Long poters = pos.poll();\\n           Long nutters = neg.poll();\\n           steps += Math.min(poters, Math.abs(nutters));\\n           Long pend = poters + nutters;\\n           if(pend > 0) pos.add(pend);\\n           else if(pend < 0) neg.add(pend);\\n       }\\n       if(!pos.isEmpty() || !neg.isEmpty()) return -1l;\\n       return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087198,
                "title": "dart-100",
                "content": "\\nIf you Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minOperations(List<int> nums1, List<int> nums2, int k) {\\n       if (k==0 ){\\n            int i=0 ;\\n            for(; i<nums1.length ; i++){\\n            if(nums1[i]!=nums2[i])return -1;\\n        }\\n        return 0 ;\\n        }\\n        int p=0, n=0 ;\\n        \\n         \\n        for(int i=0; i<nums1.length; i++){\\n            if(nums1[i]!=nums2[i]){\\n                if(nums1[i]>nums2[i]){\\n                int r= nums1[i]- nums2[i];\\n                if(r%k != 0)return -1;\\n                p+= r~/k ;\\n                nums1[i]= nums2[i];\\n                \\n            }else {\\n                int r= nums2[i]- nums1[i];\\n                if(r%k != 0)return -1;\\n                n+= r~/k ;\\n                nums1[i]= nums2[i];\\n            }\\n            }\\n            \\n            \\n        }\\n        return p == n ? p : -1 ;\\n  }\\n}\\n```\\n\\n\\n\\nPls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding :)",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minOperations(List<int> nums1, List<int> nums2, int k) {\\n       if (k==0 ){\\n            int i=0 ;\\n            for(; i<nums1.length ; i++){\\n            if(nums1[i]!=nums2[i])return -1;\\n        }\\n        return 0 ;\\n        }\\n        int p=0, n=0 ;\\n        \\n         \\n        for(int i=0; i<nums1.length; i++){\\n            if(nums1[i]!=nums2[i]){\\n                if(nums1[i]>nums2[i]){\\n                int r= nums1[i]- nums2[i];\\n                if(r%k != 0)return -1;\\n                p+= r~/k ;\\n                nums1[i]= nums2[i];\\n                \\n            }else {\\n                int r= nums2[i]- nums1[i];\\n                if(r%k != 0)return -1;\\n                n+= r~/k ;\\n                nums1[i]= nums2[i];\\n            }\\n            }\\n            \\n            \\n        }\\n        return p == n ? p : -1 ;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087141,
                "title": "c-single-pass-modulo-diff-count-77ms-71-1mb",
                "content": "Nice problem with a few interesting edge cases; what we want to check here if each couple of matching values (ie: values at the same index in `n1` and `n2`) is reachable adding/subtracting multiples of `k` and if the overall difference is `== 0` (ie: we have enough building blocks to increase the lower values taking from the higher numbers) or not.\\n\\nTo do so, we will start with a few support variables:\\n* `len` will store the length of the input vectors;\\n* `res` will be our usual accumulator variable set to count the number of operations we do to try and make the two vectors equivalent;\\n* `debt` will store the overall sum of differences between the pairs;\\n* `diff` will store the difference between specific pairs.\\n\\nWe will also have to deal with a tricky edge case (wrong submission and penalty received \\uD83D\\uDE1E), when we get `k == 0`: in this case we will compare each value and `return` `-1` as soon as wee find a mismatch, `0` otherwise (there would be no way to change anything moving `0` values around anyway).\\n\\nNow, time for our main loop, going with `i` to explore each cell from `0` to `len` and:\\n* assign `n1[i]` to `a` and `n2[i]` to `b`;\\n* check if we can reach `b` from `a` in jumps of `k`, which means both values must have the same value `% k`, otherwise we can stop here and `return` `-1`;\\n* compute the current difference `diff` as `a - b`;\\n* increase `res` by how many operations it would be to add/remove values, which is `abs(diff) / k`;\\n* increase `debt` by `diff`.\\n\\nOnce done, we will `return` `res >> 1` (we were counting double operations, since we only count when we move away/add from a cell, ignoring where we add it) if `debt == 0` (ie: we took as many blocks as we need to add to make each value in `n1` match the same value in `n2`), `-1` otherwise.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n        // support variables\\n        int len = n1.size();\\n        long long res = 0, debt = 0, diff;\\n        // edge case - k == 0\\n        if (!k) {\\n            for (int i = 0; i < len; i++) {\\n                if (n1[i] != n2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        // parsing n1 and n2\\n        for (int i = 0, a, b; i < len; i++) {\\n            a = n1[i], b = n2[i];\\n            if (a % k != b % k) return -1;\\n            diff = a - b;\\n            res += abs(diff) / k;\\n            debt += diff;\\n        }\\n        return !debt ? res >> 1 : -1;\\n    }\\n};\\n```\\nBut we can do better, actually, doing only one modulo operation (it\\'s expensive) directly on `diff` in the main loop:\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n        // support variables\\n        int len = n1.size();\\n        long long res = 0, debt = 0, diff;\\n        // edge case - k == 0\\n        if (!k) {\\n            for (int i = 0; i < len; i++) {\\n                if (n1[i] != n2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        // parsing n1 and n2\\n        for (int i = 0, a, b; i < len; i++) {\\n            diff = n1[i] - n2[i];\\n            if (diff % k != 0) return -1;\\n            res += abs(diff) / k;\\n            debt += diff;\\n        }\\n        return !debt ? res >> 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n        // support variables\\n        int len = n1.size();\\n        long long res = 0, debt = 0, diff;\\n        // edge case - k == 0\\n        if (!k) {\\n            for (int i = 0; i < len; i++) {\\n                if (n1[i] != n2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        // parsing n1 and n2\\n        for (int i = 0, a, b; i < len; i++) {\\n            a = n1[i], b = n2[i];\\n            if (a % k != b % k) return -1;\\n            diff = a - b;\\n            res += abs(diff) / k;\\n            debt += diff;\\n        }\\n        return !debt ? res >> 1 : -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long minOperations(vector<int>& n1, vector<int>& n2, int k) {\\n        // support variables\\n        int len = n1.size();\\n        long long res = 0, debt = 0, diff;\\n        // edge case - k == 0\\n        if (!k) {\\n            for (int i = 0; i < len; i++) {\\n                if (n1[i] != n2[i]) return -1;\\n            }\\n            return 0;\\n        }\\n        // parsing n1 and n2\\n        for (int i = 0, a, b; i < len; i++) {\\n            diff = n1[i] - n2[i];\\n            if (diff % k != 0) return -1;\\n            res += abs(diff) / k;\\n            debt += diff;\\n        }\\n        return !debt ? res >> 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1768073,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (k==0) testcase :("
                    },
                    {
                        "username": "simply-alex",
                        "content": "that and num1 == num2..."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Got an error for not considering k = 0. Even after taking it into consideration, failed to make it Run for all testcases \\uD83E\\uDD7A\\uD83E\\uDD7A\\n47 out of 49 test cases passed."
                    },
                    {
                        "username": "arghyadas",
                        "content": "// say inc==dec\\nif (k==0 && inc==0) return 0;\\nif (k==0 && inc!=0) return -1;"
                    },
                    {
                        "username": "amit24x",
                        "content": "***Guys, Don\\'t Lose Hope, Maximum students got the error in Question 2 for not considering k = 0.***"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "upvote if you got runtime on  k=0 :)"
                    },
                    {
                        "username": "praveer230",
                        "content": "credits for this intutition here : https://crackitjobs.com/maximum-subsequence-score-leetcode-solution-2542-in-python-c-java-crackitjobs/\\n\\nThe function takes in two arrays nums1 and nums2 and an integer k as input.\\nThe function checks if k is equal to 0. If it is, it checks whether nums1 and nums2 are equal. If they are, it returns 0, otherwise it returns -1.\\nIf k is not equal to 0, the function initializes two variables p_diff and n_diff to 0.\\nThe function then iterates over the elements of the arrays nums1 and nums2 and for each element, it compares the values of the corresponding elements in the two arrays.\\nIf the value of the element in nums1 is greater than or equal to the value of the corresponding element in nums2, it adds the difference to p_diff.\\nIf the value of the element in nums1 is less than the value of the corresponding element in nums2, it adds the difference to n_diff.\\nAfter the loop is finished, the function checks if p_diff - n_diff is equal to 0 and p_diff is divisible by k.\\nIf both conditions are true, the function calculates the value of ans by dividing p_diff by k and assigns it to ans.\\nThe function then returns ans, which is the minimum number of operations required to make nums1 equal to nums2 using the operation described above.\\nIt is important to note that the above implementation assumes that the input arrays are of the same length, otherwise it will throw an error when comparing elements in the for loop.\\n"
                    },
                    {
                        "username": "user1084vL",
                        "content": "Using a cumulative sum for p_diff and n_diff doesn\\'t work here at all, since you can only change one value at a time. As an example, if nums1=[1,2,3,4,5,6], nums2=[2,1,4,3,6,5], and k=3, p_diff==n_diff and p_diff%3==0, but you can\\'t actually get nums2 by changing the values of nums1 by k. Like mentioned above, you need to check each difference individually for divisibility."
                    },
                    {
                        "username": "sushant-sinha",
                        "content": "Just use one variable instead of p_diff and n_diff\\n\\n```long numberOfTimesOperationNeeded=0;```\\n\\nUse ```(nums2[i]-nums1[i])/k``` to retain the signs... this will indicate whether the element in nums1 is greater or smaller than its corresponding element in nums2.\\n\\nWhen you\\'re done traversing the arrays... ```numberOfTimesOperationNeeded``` will naturally have 0 if it is possible to achieve the solution."
                    },
                    {
                        "username": "martind1337",
                        "content": "I can\\'t see my issue with one of the test cases that has a lot of 1s and 100000000s, is it the size of my variables somehow? I get a massive minus number somehow"
                    },
                    {
                        "username": "ptchen1",
                        "content": "Overflow. Use longs"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "no, it was"
                    },
                    {
                        "username": "mrping_11",
                        "content": "there is one in 6 hours"
                    }
                ]
            },
            {
                "id": 1768163,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (k==0) testcase :("
                    },
                    {
                        "username": "simply-alex",
                        "content": "that and num1 == num2..."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Got an error for not considering k = 0. Even after taking it into consideration, failed to make it Run for all testcases \\uD83E\\uDD7A\\uD83E\\uDD7A\\n47 out of 49 test cases passed."
                    },
                    {
                        "username": "arghyadas",
                        "content": "// say inc==dec\\nif (k==0 && inc==0) return 0;\\nif (k==0 && inc!=0) return -1;"
                    },
                    {
                        "username": "amit24x",
                        "content": "***Guys, Don\\'t Lose Hope, Maximum students got the error in Question 2 for not considering k = 0.***"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "upvote if you got runtime on  k=0 :)"
                    },
                    {
                        "username": "praveer230",
                        "content": "credits for this intutition here : https://crackitjobs.com/maximum-subsequence-score-leetcode-solution-2542-in-python-c-java-crackitjobs/\\n\\nThe function takes in two arrays nums1 and nums2 and an integer k as input.\\nThe function checks if k is equal to 0. If it is, it checks whether nums1 and nums2 are equal. If they are, it returns 0, otherwise it returns -1.\\nIf k is not equal to 0, the function initializes two variables p_diff and n_diff to 0.\\nThe function then iterates over the elements of the arrays nums1 and nums2 and for each element, it compares the values of the corresponding elements in the two arrays.\\nIf the value of the element in nums1 is greater than or equal to the value of the corresponding element in nums2, it adds the difference to p_diff.\\nIf the value of the element in nums1 is less than the value of the corresponding element in nums2, it adds the difference to n_diff.\\nAfter the loop is finished, the function checks if p_diff - n_diff is equal to 0 and p_diff is divisible by k.\\nIf both conditions are true, the function calculates the value of ans by dividing p_diff by k and assigns it to ans.\\nThe function then returns ans, which is the minimum number of operations required to make nums1 equal to nums2 using the operation described above.\\nIt is important to note that the above implementation assumes that the input arrays are of the same length, otherwise it will throw an error when comparing elements in the for loop.\\n"
                    },
                    {
                        "username": "user1084vL",
                        "content": "Using a cumulative sum for p_diff and n_diff doesn\\'t work here at all, since you can only change one value at a time. As an example, if nums1=[1,2,3,4,5,6], nums2=[2,1,4,3,6,5], and k=3, p_diff==n_diff and p_diff%3==0, but you can\\'t actually get nums2 by changing the values of nums1 by k. Like mentioned above, you need to check each difference individually for divisibility."
                    },
                    {
                        "username": "sushant-sinha",
                        "content": "Just use one variable instead of p_diff and n_diff\\n\\n```long numberOfTimesOperationNeeded=0;```\\n\\nUse ```(nums2[i]-nums1[i])/k``` to retain the signs... this will indicate whether the element in nums1 is greater or smaller than its corresponding element in nums2.\\n\\nWhen you\\'re done traversing the arrays... ```numberOfTimesOperationNeeded``` will naturally have 0 if it is possible to achieve the solution."
                    },
                    {
                        "username": "martind1337",
                        "content": "I can\\'t see my issue with one of the test cases that has a lot of 1s and 100000000s, is it the size of my variables somehow? I get a massive minus number somehow"
                    },
                    {
                        "username": "ptchen1",
                        "content": "Overflow. Use longs"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "no, it was"
                    },
                    {
                        "username": "mrping_11",
                        "content": "there is one in 6 hours"
                    }
                ]
            },
            {
                "id": 1768094,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (k==0) testcase :("
                    },
                    {
                        "username": "simply-alex",
                        "content": "that and num1 == num2..."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Got an error for not considering k = 0. Even after taking it into consideration, failed to make it Run for all testcases \\uD83E\\uDD7A\\uD83E\\uDD7A\\n47 out of 49 test cases passed."
                    },
                    {
                        "username": "arghyadas",
                        "content": "// say inc==dec\\nif (k==0 && inc==0) return 0;\\nif (k==0 && inc!=0) return -1;"
                    },
                    {
                        "username": "amit24x",
                        "content": "***Guys, Don\\'t Lose Hope, Maximum students got the error in Question 2 for not considering k = 0.***"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "upvote if you got runtime on  k=0 :)"
                    },
                    {
                        "username": "praveer230",
                        "content": "credits for this intutition here : https://crackitjobs.com/maximum-subsequence-score-leetcode-solution-2542-in-python-c-java-crackitjobs/\\n\\nThe function takes in two arrays nums1 and nums2 and an integer k as input.\\nThe function checks if k is equal to 0. If it is, it checks whether nums1 and nums2 are equal. If they are, it returns 0, otherwise it returns -1.\\nIf k is not equal to 0, the function initializes two variables p_diff and n_diff to 0.\\nThe function then iterates over the elements of the arrays nums1 and nums2 and for each element, it compares the values of the corresponding elements in the two arrays.\\nIf the value of the element in nums1 is greater than or equal to the value of the corresponding element in nums2, it adds the difference to p_diff.\\nIf the value of the element in nums1 is less than the value of the corresponding element in nums2, it adds the difference to n_diff.\\nAfter the loop is finished, the function checks if p_diff - n_diff is equal to 0 and p_diff is divisible by k.\\nIf both conditions are true, the function calculates the value of ans by dividing p_diff by k and assigns it to ans.\\nThe function then returns ans, which is the minimum number of operations required to make nums1 equal to nums2 using the operation described above.\\nIt is important to note that the above implementation assumes that the input arrays are of the same length, otherwise it will throw an error when comparing elements in the for loop.\\n"
                    },
                    {
                        "username": "user1084vL",
                        "content": "Using a cumulative sum for p_diff and n_diff doesn\\'t work here at all, since you can only change one value at a time. As an example, if nums1=[1,2,3,4,5,6], nums2=[2,1,4,3,6,5], and k=3, p_diff==n_diff and p_diff%3==0, but you can\\'t actually get nums2 by changing the values of nums1 by k. Like mentioned above, you need to check each difference individually for divisibility."
                    },
                    {
                        "username": "sushant-sinha",
                        "content": "Just use one variable instead of p_diff and n_diff\\n\\n```long numberOfTimesOperationNeeded=0;```\\n\\nUse ```(nums2[i]-nums1[i])/k``` to retain the signs... this will indicate whether the element in nums1 is greater or smaller than its corresponding element in nums2.\\n\\nWhen you\\'re done traversing the arrays... ```numberOfTimesOperationNeeded``` will naturally have 0 if it is possible to achieve the solution."
                    },
                    {
                        "username": "martind1337",
                        "content": "I can\\'t see my issue with one of the test cases that has a lot of 1s and 100000000s, is it the size of my variables somehow? I get a massive minus number somehow"
                    },
                    {
                        "username": "ptchen1",
                        "content": "Overflow. Use longs"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "no, it was"
                    },
                    {
                        "username": "mrping_11",
                        "content": "there is one in 6 hours"
                    }
                ]
            },
            {
                "id": 1777837,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (k==0) testcase :("
                    },
                    {
                        "username": "simply-alex",
                        "content": "that and num1 == num2..."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Got an error for not considering k = 0. Even after taking it into consideration, failed to make it Run for all testcases \\uD83E\\uDD7A\\uD83E\\uDD7A\\n47 out of 49 test cases passed."
                    },
                    {
                        "username": "arghyadas",
                        "content": "// say inc==dec\\nif (k==0 && inc==0) return 0;\\nif (k==0 && inc!=0) return -1;"
                    },
                    {
                        "username": "amit24x",
                        "content": "***Guys, Don\\'t Lose Hope, Maximum students got the error in Question 2 for not considering k = 0.***"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "upvote if you got runtime on  k=0 :)"
                    },
                    {
                        "username": "praveer230",
                        "content": "credits for this intutition here : https://crackitjobs.com/maximum-subsequence-score-leetcode-solution-2542-in-python-c-java-crackitjobs/\\n\\nThe function takes in two arrays nums1 and nums2 and an integer k as input.\\nThe function checks if k is equal to 0. If it is, it checks whether nums1 and nums2 are equal. If they are, it returns 0, otherwise it returns -1.\\nIf k is not equal to 0, the function initializes two variables p_diff and n_diff to 0.\\nThe function then iterates over the elements of the arrays nums1 and nums2 and for each element, it compares the values of the corresponding elements in the two arrays.\\nIf the value of the element in nums1 is greater than or equal to the value of the corresponding element in nums2, it adds the difference to p_diff.\\nIf the value of the element in nums1 is less than the value of the corresponding element in nums2, it adds the difference to n_diff.\\nAfter the loop is finished, the function checks if p_diff - n_diff is equal to 0 and p_diff is divisible by k.\\nIf both conditions are true, the function calculates the value of ans by dividing p_diff by k and assigns it to ans.\\nThe function then returns ans, which is the minimum number of operations required to make nums1 equal to nums2 using the operation described above.\\nIt is important to note that the above implementation assumes that the input arrays are of the same length, otherwise it will throw an error when comparing elements in the for loop.\\n"
                    },
                    {
                        "username": "user1084vL",
                        "content": "Using a cumulative sum for p_diff and n_diff doesn\\'t work here at all, since you can only change one value at a time. As an example, if nums1=[1,2,3,4,5,6], nums2=[2,1,4,3,6,5], and k=3, p_diff==n_diff and p_diff%3==0, but you can\\'t actually get nums2 by changing the values of nums1 by k. Like mentioned above, you need to check each difference individually for divisibility."
                    },
                    {
                        "username": "sushant-sinha",
                        "content": "Just use one variable instead of p_diff and n_diff\\n\\n```long numberOfTimesOperationNeeded=0;```\\n\\nUse ```(nums2[i]-nums1[i])/k``` to retain the signs... this will indicate whether the element in nums1 is greater or smaller than its corresponding element in nums2.\\n\\nWhen you\\'re done traversing the arrays... ```numberOfTimesOperationNeeded``` will naturally have 0 if it is possible to achieve the solution."
                    },
                    {
                        "username": "martind1337",
                        "content": "I can\\'t see my issue with one of the test cases that has a lot of 1s and 100000000s, is it the size of my variables somehow? I get a massive minus number somehow"
                    },
                    {
                        "username": "ptchen1",
                        "content": "Overflow. Use longs"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "no, it was"
                    },
                    {
                        "username": "mrping_11",
                        "content": "there is one in 6 hours"
                    }
                ]
            },
            {
                "id": 1768308,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (k==0) testcase :("
                    },
                    {
                        "username": "simply-alex",
                        "content": "that and num1 == num2..."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Got an error for not considering k = 0. Even after taking it into consideration, failed to make it Run for all testcases \\uD83E\\uDD7A\\uD83E\\uDD7A\\n47 out of 49 test cases passed."
                    },
                    {
                        "username": "arghyadas",
                        "content": "// say inc==dec\\nif (k==0 && inc==0) return 0;\\nif (k==0 && inc!=0) return -1;"
                    },
                    {
                        "username": "amit24x",
                        "content": "***Guys, Don\\'t Lose Hope, Maximum students got the error in Question 2 for not considering k = 0.***"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "upvote if you got runtime on  k=0 :)"
                    },
                    {
                        "username": "praveer230",
                        "content": "credits for this intutition here : https://crackitjobs.com/maximum-subsequence-score-leetcode-solution-2542-in-python-c-java-crackitjobs/\\n\\nThe function takes in two arrays nums1 and nums2 and an integer k as input.\\nThe function checks if k is equal to 0. If it is, it checks whether nums1 and nums2 are equal. If they are, it returns 0, otherwise it returns -1.\\nIf k is not equal to 0, the function initializes two variables p_diff and n_diff to 0.\\nThe function then iterates over the elements of the arrays nums1 and nums2 and for each element, it compares the values of the corresponding elements in the two arrays.\\nIf the value of the element in nums1 is greater than or equal to the value of the corresponding element in nums2, it adds the difference to p_diff.\\nIf the value of the element in nums1 is less than the value of the corresponding element in nums2, it adds the difference to n_diff.\\nAfter the loop is finished, the function checks if p_diff - n_diff is equal to 0 and p_diff is divisible by k.\\nIf both conditions are true, the function calculates the value of ans by dividing p_diff by k and assigns it to ans.\\nThe function then returns ans, which is the minimum number of operations required to make nums1 equal to nums2 using the operation described above.\\nIt is important to note that the above implementation assumes that the input arrays are of the same length, otherwise it will throw an error when comparing elements in the for loop.\\n"
                    },
                    {
                        "username": "user1084vL",
                        "content": "Using a cumulative sum for p_diff and n_diff doesn\\'t work here at all, since you can only change one value at a time. As an example, if nums1=[1,2,3,4,5,6], nums2=[2,1,4,3,6,5], and k=3, p_diff==n_diff and p_diff%3==0, but you can\\'t actually get nums2 by changing the values of nums1 by k. Like mentioned above, you need to check each difference individually for divisibility."
                    },
                    {
                        "username": "sushant-sinha",
                        "content": "Just use one variable instead of p_diff and n_diff\\n\\n```long numberOfTimesOperationNeeded=0;```\\n\\nUse ```(nums2[i]-nums1[i])/k``` to retain the signs... this will indicate whether the element in nums1 is greater or smaller than its corresponding element in nums2.\\n\\nWhen you\\'re done traversing the arrays... ```numberOfTimesOperationNeeded``` will naturally have 0 if it is possible to achieve the solution."
                    },
                    {
                        "username": "martind1337",
                        "content": "I can\\'t see my issue with one of the test cases that has a lot of 1s and 100000000s, is it the size of my variables somehow? I get a massive minus number somehow"
                    },
                    {
                        "username": "ptchen1",
                        "content": "Overflow. Use longs"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "no, it was"
                    },
                    {
                        "username": "mrping_11",
                        "content": "there is one in 6 hours"
                    }
                ]
            },
            {
                "id": 1768497,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (k==0) testcase :("
                    },
                    {
                        "username": "simply-alex",
                        "content": "that and num1 == num2..."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Got an error for not considering k = 0. Even after taking it into consideration, failed to make it Run for all testcases \\uD83E\\uDD7A\\uD83E\\uDD7A\\n47 out of 49 test cases passed."
                    },
                    {
                        "username": "arghyadas",
                        "content": "// say inc==dec\\nif (k==0 && inc==0) return 0;\\nif (k==0 && inc!=0) return -1;"
                    },
                    {
                        "username": "amit24x",
                        "content": "***Guys, Don\\'t Lose Hope, Maximum students got the error in Question 2 for not considering k = 0.***"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "upvote if you got runtime on  k=0 :)"
                    },
                    {
                        "username": "praveer230",
                        "content": "credits for this intutition here : https://crackitjobs.com/maximum-subsequence-score-leetcode-solution-2542-in-python-c-java-crackitjobs/\\n\\nThe function takes in two arrays nums1 and nums2 and an integer k as input.\\nThe function checks if k is equal to 0. If it is, it checks whether nums1 and nums2 are equal. If they are, it returns 0, otherwise it returns -1.\\nIf k is not equal to 0, the function initializes two variables p_diff and n_diff to 0.\\nThe function then iterates over the elements of the arrays nums1 and nums2 and for each element, it compares the values of the corresponding elements in the two arrays.\\nIf the value of the element in nums1 is greater than or equal to the value of the corresponding element in nums2, it adds the difference to p_diff.\\nIf the value of the element in nums1 is less than the value of the corresponding element in nums2, it adds the difference to n_diff.\\nAfter the loop is finished, the function checks if p_diff - n_diff is equal to 0 and p_diff is divisible by k.\\nIf both conditions are true, the function calculates the value of ans by dividing p_diff by k and assigns it to ans.\\nThe function then returns ans, which is the minimum number of operations required to make nums1 equal to nums2 using the operation described above.\\nIt is important to note that the above implementation assumes that the input arrays are of the same length, otherwise it will throw an error when comparing elements in the for loop.\\n"
                    },
                    {
                        "username": "user1084vL",
                        "content": "Using a cumulative sum for p_diff and n_diff doesn\\'t work here at all, since you can only change one value at a time. As an example, if nums1=[1,2,3,4,5,6], nums2=[2,1,4,3,6,5], and k=3, p_diff==n_diff and p_diff%3==0, but you can\\'t actually get nums2 by changing the values of nums1 by k. Like mentioned above, you need to check each difference individually for divisibility."
                    },
                    {
                        "username": "sushant-sinha",
                        "content": "Just use one variable instead of p_diff and n_diff\\n\\n```long numberOfTimesOperationNeeded=0;```\\n\\nUse ```(nums2[i]-nums1[i])/k``` to retain the signs... this will indicate whether the element in nums1 is greater or smaller than its corresponding element in nums2.\\n\\nWhen you\\'re done traversing the arrays... ```numberOfTimesOperationNeeded``` will naturally have 0 if it is possible to achieve the solution."
                    },
                    {
                        "username": "martind1337",
                        "content": "I can\\'t see my issue with one of the test cases that has a lot of 1s and 100000000s, is it the size of my variables somehow? I get a massive minus number somehow"
                    },
                    {
                        "username": "ptchen1",
                        "content": "Overflow. Use longs"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "no, it was"
                    },
                    {
                        "username": "mrping_11",
                        "content": "there is one in 6 hours"
                    }
                ]
            },
            {
                "id": 1768226,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (k==0) testcase :("
                    },
                    {
                        "username": "simply-alex",
                        "content": "that and num1 == num2..."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Got an error for not considering k = 0. Even after taking it into consideration, failed to make it Run for all testcases \\uD83E\\uDD7A\\uD83E\\uDD7A\\n47 out of 49 test cases passed."
                    },
                    {
                        "username": "arghyadas",
                        "content": "// say inc==dec\\nif (k==0 && inc==0) return 0;\\nif (k==0 && inc!=0) return -1;"
                    },
                    {
                        "username": "amit24x",
                        "content": "***Guys, Don\\'t Lose Hope, Maximum students got the error in Question 2 for not considering k = 0.***"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "upvote if you got runtime on  k=0 :)"
                    },
                    {
                        "username": "praveer230",
                        "content": "credits for this intutition here : https://crackitjobs.com/maximum-subsequence-score-leetcode-solution-2542-in-python-c-java-crackitjobs/\\n\\nThe function takes in two arrays nums1 and nums2 and an integer k as input.\\nThe function checks if k is equal to 0. If it is, it checks whether nums1 and nums2 are equal. If they are, it returns 0, otherwise it returns -1.\\nIf k is not equal to 0, the function initializes two variables p_diff and n_diff to 0.\\nThe function then iterates over the elements of the arrays nums1 and nums2 and for each element, it compares the values of the corresponding elements in the two arrays.\\nIf the value of the element in nums1 is greater than or equal to the value of the corresponding element in nums2, it adds the difference to p_diff.\\nIf the value of the element in nums1 is less than the value of the corresponding element in nums2, it adds the difference to n_diff.\\nAfter the loop is finished, the function checks if p_diff - n_diff is equal to 0 and p_diff is divisible by k.\\nIf both conditions are true, the function calculates the value of ans by dividing p_diff by k and assigns it to ans.\\nThe function then returns ans, which is the minimum number of operations required to make nums1 equal to nums2 using the operation described above.\\nIt is important to note that the above implementation assumes that the input arrays are of the same length, otherwise it will throw an error when comparing elements in the for loop.\\n"
                    },
                    {
                        "username": "user1084vL",
                        "content": "Using a cumulative sum for p_diff and n_diff doesn\\'t work here at all, since you can only change one value at a time. As an example, if nums1=[1,2,3,4,5,6], nums2=[2,1,4,3,6,5], and k=3, p_diff==n_diff and p_diff%3==0, but you can\\'t actually get nums2 by changing the values of nums1 by k. Like mentioned above, you need to check each difference individually for divisibility."
                    },
                    {
                        "username": "sushant-sinha",
                        "content": "Just use one variable instead of p_diff and n_diff\\n\\n```long numberOfTimesOperationNeeded=0;```\\n\\nUse ```(nums2[i]-nums1[i])/k``` to retain the signs... this will indicate whether the element in nums1 is greater or smaller than its corresponding element in nums2.\\n\\nWhen you\\'re done traversing the arrays... ```numberOfTimesOperationNeeded``` will naturally have 0 if it is possible to achieve the solution."
                    },
                    {
                        "username": "martind1337",
                        "content": "I can\\'t see my issue with one of the test cases that has a lot of 1s and 100000000s, is it the size of my variables somehow? I get a massive minus number somehow"
                    },
                    {
                        "username": "ptchen1",
                        "content": "Overflow. Use longs"
                    },
                    {
                        "username": "72engineers",
                        "content": "So...there is no regular weekly contest in this week?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "no, it was"
                    },
                    {
                        "username": "mrping_11",
                        "content": "there is one in 6 hours"
                    }
                ]
            }
        ]
    }
]