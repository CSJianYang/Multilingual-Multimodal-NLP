[
    {
        "title": "Kth Smallest Product of Two Sorted Arrays",
        "question_content": "Given two sorted 0-indexed integer arrays nums1 and nums2 as well as an integer k, return the kth (1-based) smallest product of nums1[i] * nums2[j] where 0 <= i < nums1.length and 0 <= j < nums2.length.\n&nbsp;\nExample 1:\n\nInput: nums1 = [2,5], nums2 = [3,4], k = 2\nOutput: 8\nExplanation: The 2 smallest products are:\n- nums1[0] * nums2[0] = 2 * 3 = 6\n- nums1[0] * nums2[1] = 2 * 4 = 8\nThe 2nd smallest product is 8.\n\nExample 2:\n\nInput: nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6\nOutput: 0\nExplanation: The 6 smallest products are:\n- nums1[0] * nums2[1] = (-4) * 4 = -16\n- nums1[0] * nums2[0] = (-4) * 2 = -8\n- nums1[1] * nums2[1] = (-2) * 4 = -8\n- nums1[1] * nums2[0] = (-2) * 2 = -4\n- nums1[2] * nums2[0] = 0 * 2 = 0\n- nums1[2] * nums2[1] = 0 * 4 = 0\nThe 6th smallest product is 0.\n\nExample 3:\n\nInput: nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3\nOutput: -6\nExplanation: The 3 smallest products are:\n- nums1[0] * nums2[4] = (-2) * 5 = -10\n- nums1[0] * nums2[3] = (-2) * 4 = -8\n- nums1[4] * nums2[0] = 2 * (-3) = -6\nThe 3rd smallest product is -6.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums1.length, nums2.length <= 5 * 104\n\t-105 <= nums1[i], nums2[j] <= 105\n\t1 <= k <= nums1.length * nums2.length\n\tnums1 and nums2 are sorted.",
        "solutions": [
            {
                "id": 1524159,
                "title": "python-binary-search-solution-explained",
                "content": "The idea of this problem is to use binary search: let `check(x)` be the answer to the question: how many products are less or equal than `x`. Then we use binary search and find the first moment where we have exactly `k` such numbers.\\n\\n1. If `n1` is positive, then values in `nums2 * n1` go in increasing order, so we use bisect to find number of values which are `<= x//n1`.\\n2. If `n1` is negative, then values in `nums2 * n1` going in decreasing order, so we need to take the right part.\\n3. If `n1` equal to `0`, than all values in `nums2 * n1` are equal to `0`. So, we update `total` only if `x >= 0`.\\n\\n#### Complexity\\nTime complexity is `O(n*log m* log N)`, where `n = len(nums1)`, `m = len(nums2)` and `N = 10**10 + 10` is the maximum value of product. Space complexity is `O(1)`\\n\\n\\n#### Code\\n```python\\nfrom bisect import bisect, bisect_left\\n\\nclass Solution:\\n    def kthSmallestProduct(self, nums1, nums2, k):\\n        def check(x):\\n            total = 0\\n            for n1 in nums1:\\n                if n1 > 0: total += bisect(nums2, x//n1)\\n                if n1 < 0: total += len(nums2) - bisect_left(nums2, ceil(x/n1))\\n                if n1 == 0 and x >= 0: total += len(nums2)\\n\\n            return total\\n\\n        beg, end = -10**10 - 1, 10**10 + 1\\n\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if check(mid) >= k:\\n                end = mid\\n            else:\\n                beg = mid\\n\\n        return beg + 1\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nfrom bisect import bisect, bisect_left\\n\\nclass Solution:\\n    def kthSmallestProduct(self, nums1, nums2, k):\\n        def check(x):\\n            total = 0\\n            for n1 in nums1:\\n                if n1 > 0: total += bisect(nums2, x//n1)\\n                if n1 < 0: total += len(nums2) - bisect_left(nums2, ceil(x/n1))\\n                if n1 == 0 and x >= 0: total += len(nums2)\\n\\n            return total\\n\\n        beg, end = -10**10 - 1, 10**10 + 1\\n\\n        while beg + 1 < end:\\n            mid = (beg + end)//2\\n            if check(mid) >= k:\\n                end = mid\\n            else:\\n                beg = mid\\n\\n        return beg + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524312,
                "title": "python-binary-search-o-m-n-log10-10",
                "content": "# **Intuition**\\nBinary search the result, and count the number of smaller product.\\n\\nWe can firstly consider the simple situation with no negatives.\\nThe base of this question is the two sum problem.\\n\\nIn two sum problem,\\nwe can count the number of pair with sum <= x.\\n\\nIn this two product problem,\\nwe need to count the number of pair with product <= x.\\n<br>\\n\\n# **Complexity**\\nTime `O((m+n)log10^10)`\\nSpace `O(n+m)`\\n<br>\\n\\n**Python**\\n```py\\n    def kthSmallestProduct(self, A, B, k):\\n        n, m = len(A), len(B)\\n        A1,A2 = [-a for a in A if a < 0][::-1], [a for a in A if a >= 0]\\n        B1,B2 = [-a for a in B if a < 0][::-1], [a for a in B if a >= 0]\\n\\n        neg = len(A1) * len(B2) + len(A2) * len(B1)\\n        if k > neg:\\n            k -= neg\\n            s = 1\\n        else:\\n            k = neg - k + 1\\n            B1, B2 = B2,B1\\n            s = -1\\n\\n        def count(A, B, x):\\n            res = 0\\n            j = len(B) - 1\\n            for i in xrange(len(A)):\\n                while j >= 0 and A[i] * B[j] > x:\\n                    j -= 1\\n                res += j + 1\\n            return res\\n\\n        left, right = 0, 10**10\\n        while left < right:\\n            mid = (left + right) / 2\\n            if count(A1, B1, mid) + count(A2, B2, mid) >= k:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left * s\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def kthSmallestProduct(self, A, B, k):\\n        n, m = len(A), len(B)\\n        A1,A2 = [-a for a in A if a < 0][::-1], [a for a in A if a >= 0]\\n        B1,B2 = [-a for a in B if a < 0][::-1], [a for a in B if a >= 0]\\n\\n        neg = len(A1) * len(B2) + len(A2) * len(B1)\\n        if k > neg:\\n            k -= neg\\n            s = 1\\n        else:\\n            k = neg - k + 1\\n            B1, B2 = B2,B1\\n            s = -1\\n\\n        def count(A, B, x):\\n            res = 0\\n            j = len(B) - 1\\n            for i in xrange(len(A)):\\n                while j >= 0 and A[i] * B[j] > x:\\n                    j -= 1\\n                res += j + 1\\n            return res\\n\\n        left, right = 0, 10**10\\n        while left < right:\\n            mid = (left + right) / 2\\n            if count(A1, B1, mid) + count(A2, B2, mid) >= k:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left * s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1527753,
                "title": "binary-search-and-two-pointers",
                "content": "There are a few problems like this. Generating products directly is expensive.\\n\\nHowever, finding how many products are *less* than a given number `m` can be done in a linear time by using the two pointers approach.  Initially, `p1` points to the first element in the first array, and `p2` - the last element in the second array. For each element `p1`, we move `p2` to the left if the product is higher than `m`. The number of products therefore is defined by the position of `p2` in each step.\\n\\nFor example, we have `19` products less than `15` for these arrays `[1, 2, 3, 4, 5] [1, 2, 3, 4, 5]`:\\n\\n| p1 | p2 | products |\\n| - | - | - | \\n|[1]|[5]|[1, 2, 3, 4, 5]\\n|[2]|[5]|[2,4,6,8,10]|\\n|[3]|[4]|[3, 6, 9, 12]|\\n|[4]|[3]|[4, 8, 12]|\\n|[5]|[2]|[5, 10]|\\n\\nSo, we binary-search for a value `m`, count products less than `m`, and return the smallest value where the number of products is exactly `k`.\\n\\nThe trick here is that we have both positive and negative numbers. I broke my head trying to figure out the pointers algebra. So, instead I just created new arrays for positives, negatives, and the reverse versions of those. The `count` function uses two pointers to count values.  We use the same function for all four cases, though we will need to pass array in the correct order, depending on:\\n- All numbers are non-negative (positive and zero).\\n\\t- Original order for both arrays\\n- All numbers are negative.\\n\\t- Reverse order for both arrays\\n- One array is negative, and the other is positive.\\n\\t- Reverse order for the positive one, original for negative.\\n\\n**C++**\\n```cpp\\nlong long count(vector<int>& n1, vector<int>& n2, long long m) {\\n    long long cnt = 0;\\n    for (int p1 = 0, p2 = n2.size() - 1; p1 < n1.size(); ++p1) {\\n        while (p2 >= 0 && (long long)n1[p1] * n2[p2] > m)\\n            --p2;\\n        cnt += p2 + 1;\\n    }\\n    return cnt;\\n}\\nlong long kthSmallestProduct(vector<int>& n1, vector<int>& n2, long long k) {\\n    auto lp = lower_bound(begin(n1), end(n1), 0), rp = lower_bound(begin(n2), end(n2), 0);\\n    vector<int> neg1(begin(n1), lp), neg2(begin(n2), rp);\\n    vector<int> pos1(lp, end(n1)), pos2(rp, end(n2));\\n    vector<int> pos1_r(rbegin(pos1), rend(pos1)), pos2_r(rbegin(pos2), rend(pos2));\\n    vector<int> neg1_r(rbegin(neg1), rend(neg1)), neg2_r(rbegin(neg2), rend(neg2)); \\n    long long l = -10000000000, r = 10000000000;\\n    while (l < r) {\\n        long long m = (l + r - 1) / 2, cnt = 0;\\n        if (m >= 0)\\n            cnt = count(neg1_r, neg2_r, m) + count(pos1, pos2, m) \\n                + neg1.size() * pos2.size() + neg2.size() * pos1.size();\\n        else\\n            cnt = count(pos2_r, neg1, m) + count(pos1_r, neg2, m);\\n        if (cnt < k) \\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long count(vector<int>& n1, vector<int>& n2, long long m) {\\n    long long cnt = 0;\\n    for (int p1 = 0, p2 = n2.size() - 1; p1 < n1.size(); ++p1) {\\n        while (p2 >= 0 && (long long)n1[p1] * n2[p2] > m)\\n            --p2;\\n        cnt += p2 + 1;\\n    }\\n    return cnt;\\n}\\nlong long kthSmallestProduct(vector<int>& n1, vector<int>& n2, long long k) {\\n    auto lp = lower_bound(begin(n1), end(n1), 0), rp = lower_bound(begin(n2), end(n2), 0);\\n    vector<int> neg1(begin(n1), lp), neg2(begin(n2), rp);\\n    vector<int> pos1(lp, end(n1)), pos2(rp, end(n2));\\n    vector<int> pos1_r(rbegin(pos1), rend(pos1)), pos2_r(rbegin(pos2), rend(pos2));\\n    vector<int> neg1_r(rbegin(neg1), rend(neg1)), neg2_r(rbegin(neg2), rend(neg2)); \\n    long long l = -10000000000, r = 10000000000;\\n    while (l < r) {\\n        long long m = (l + r - 1) / 2, cnt = 0;\\n        if (m >= 0)\\n            cnt = count(neg1_r, neg2_r, m) + count(pos1, pos2, m) \\n                + neg1.size() * pos2.size() + neg2.size() * pos1.size();\\n        else\\n            cnt = count(pos2_r, neg1, m) + count(pos1_r, neg2, m);\\n        if (cnt < k) \\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524349,
                "title": "java-double-binary-search-o-log10-10-x-mlogn",
                "content": "**Thinking Process**\\n* I can put the index pair for the two arrays in a priority queue and compute the answer gradually. However, the K can be up to 10^9. This will lead to TLE.\\n* The element can be negative. Maybe I need to know the number of negative elements and handle 4 different combinations: (negative array 1, negative array 2), (negative array 1, positive array 2), (positive array 1, negative array 2), (positive array 1, positive array 2). At least, I can know the number of products of each combination and locate k-th product among them.\\n* Even though I know which combination the k-th product belongs to, it doesn\\'t guarantee I can use the priority queue approach. I need another hint.\\n* Continue with above, I think I need some way to eliminate some number of products step by step to reach the goal.\\n* Since the array is sorted, if I turn my attention on nums1[i] x nums2[j], I can know there are j + 1 products which are less than or equal to nums1[i] x nums2[j] that are generated by nums1[i]. Then I realize that I should try the binary search.\\n\\n**Algorithm**\\n* Binary search the answer\\n* For each nums1[i], count the number of products that are less than or equal to the current guess\\n\\n**Quick Implementation during the contest** \\n```\\nclass Solution {\\n    static long INF = (long) 1e10;\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        int m = nums1.length, n = nums2.length;\\n        long lo = -INF - 1, hi = INF + 1;\\n        while (lo < hi) {            \\n            long mid = lo + ((hi - lo) >> 1), cnt = 0;\\n            for (int i : nums1) {\\n                if (0 <= i) {\\n                    int l = 0, r = n - 1, p = 0;\\n                    while (l <= r) {\\n                        int c = l + ((r - l) >> 1);\\n                        long mul = i * (long) nums2[c];\\n                        if (mul <= mid) {\\n                            p = c + 1;\\n                            l = c + 1;\\n                        } else r = c - 1;\\n                    }\\n                    cnt += p;\\n                } else {\\n                    int l = 0, r = n - 1, p = 0;\\n                    while (l <= r) {\\n                        int c = l + ((r - l) >> 1);\\n                        long mul = i * (long) nums2[c];\\n                        if (mul <= mid) {\\n                            p = n - c;\\n                            r = c - 1;\\n                        } else l = c + 1;\\n                    }\\n                    cnt += p;\\n                }\\n            }\\n            if (cnt >= k) {\\n                hi = mid;\\n            } else lo = mid + 1L;\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    static long INF = (long) 1e10;\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        int m = nums1.length, n = nums2.length;\\n        long lo = -INF - 1, hi = INF + 1;\\n        while (lo < hi) {            \\n            long mid = lo + ((hi - lo) >> 1), cnt = 0;\\n            for (int i : nums1) {\\n                if (0 <= i) {\\n                    int l = 0, r = n - 1, p = 0;\\n                    while (l <= r) {\\n                        int c = l + ((r - l) >> 1);\\n                        long mul = i * (long) nums2[c];\\n                        if (mul <= mid) {\\n                            p = c + 1;\\n                            l = c + 1;\\n                        } else r = c - 1;\\n                    }\\n                    cnt += p;\\n                } else {\\n                    int l = 0, r = n - 1, p = 0;\\n                    while (l <= r) {\\n                        int c = l + ((r - l) >> 1);\\n                        long mul = i * (long) nums2[c];\\n                        if (mul <= mid) {\\n                            p = n - c;\\n                            r = c - 1;\\n                        } else l = c + 1;\\n                    }\\n                    cnt += p;\\n                }\\n            }\\n            if (cnt >= k) {\\n                hi = mid;\\n            } else lo = mid + 1L;\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524343,
                "title": "c-answer-on-binary-search",
                "content": "The idea of this problem is to use binary search on answer -\\nLet check(x) be the answer to the question: how many products are less or equal than x. \\nThen we use binary search and find the first moment where we have exactly k such numbers .\\n```\\nclass Solution {\\npublic:\\n    bool check(long long midval,vector<int>& nums1, vector<int>& nums2, long long k){\\n        long long cnt=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long val=nums1[i];\\n                        \\n\\t\\t\\t//If val == 0, product of val and each element in nums2 will be 0. And if midval>=0, then because all\\n\\t\\t\\t//products are 0, all products will be smaller or equal to midval. So we can add all products in the answer\\n\\t\\t\\tif(val==0 and midval>=0)\\n                cnt+=nums2.size();\\n            \\n            else if(val>0)\\n                cnt+=findmaxIndex(nums2,val,midval);\\n            \\n            else if(val<0)\\n                cnt+=findminIndex(nums2,val,midval);\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    int findmaxIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  -1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return res+1;\\n    }\\n    \\n    int findminIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  r+1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return nums2.size()-res;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long l=-1e10,r=1e10,res=-1;\\n        while(l<=r){\\n            long long mid = (l+r)/2;\\n            // cout<<mid<<endl;\\n            if(check(mid,nums1,nums2,k)) {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAlso If you can try , try this - \"https://codingcompetitions.withgoogle.com/kickstart/round/0000000000201b77/0000000000201c95#problem\"",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long midval,vector<int>& nums1, vector<int>& nums2, long long k){\\n        long long cnt=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long val=nums1[i];\\n                        \\n\\t\\t\\t//If val == 0, product of val and each element in nums2 will be 0. And if midval>=0, then because all\\n\\t\\t\\t//products are 0, all products will be smaller or equal to midval. So we can add all products in the answer\\n\\t\\t\\tif(val==0 and midval>=0)\\n                cnt+=nums2.size();\\n            \\n            else if(val>0)\\n                cnt+=findmaxIndex(nums2,val,midval);\\n            \\n            else if(val<0)\\n                cnt+=findminIndex(nums2,val,midval);\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    int findmaxIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  -1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return res+1;\\n    }\\n    \\n    int findminIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  r+1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return nums2.size()-res;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long l=-1e10,r=1e10,res=-1;\\n        while(l<=r){\\n            long long mid = (l+r)/2;\\n            // cout<<mid<<endl;\\n            if(check(mid,nums1,nums2,k)) {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1524856,
                "title": "binary-search-with-detailed-explanation",
                "content": "***Note: credit goes to lee215 for the inverse/reverse trick***\\n\\n### Step 1. k\\'th smallest product for lists with only positive numbers\\n\\nImagine that there are only positive numbers, and we want to find the k\\'th smallest number.\\n\\nConsider the two lists `a=[1,2,3]` and `b=[1,5,8]`. Their products form a matrix:\\n\\n| - | 1 | 2 | 3 |\\n| --- | --- | --- | --- |\\n| __1__ | 1 | 2 | 3 |\\n| __5__ | 5 | 10 | 15 |\\n| __8__ | 8 | 18 | 24 |\\n\\nAssuming that we guess a number `x`, then it\\'s possible to quickly determine how many numbers are smaller than `x`. Just iterate row by row, moving a right pointer left until the condition is satisfied and count the number of elements before the pointer:\\n\\n```go\\nfunc count(a, b []int, val int) int {\\n\\tvar count int\\n\\tj := len(b) - 1\\n\\tfor i := range a {\\n\\t\\tfor j >= 0 && a[i]*b[j] > val {\\n\\t\\t\\tj--\\n\\t\\t}\\n\\t\\tcount += j + 1\\n\\t}\\n\\treturn count\\n}\\n```\\n\\nWith this approach, it\\'s easy to find the k\\'th positive number using binary search:\\n\\n```go\\nvar lo, hi int = 0, 1e10\\nfor lo < hi {\\n\\tmid := (lo + hi) / 2\\n\\tres := count(a, b, mid)\\n\\tif res >= int(k) {\\n\\t\\thi = mid\\n\\t} else {\\n\\t\\tlo = mid + 1\\n\\t}\\n}\\nreturn lo\\n```\\n\\n### Step 2. Mixed numbers\\n\\nSo far so good. The problem is with the negative numbers. When the lists contain negative numbers, then their products form a kind of criss-cross pattern. Positive numbers are the result of combining numbers diagonally across in the matrix, and negative numbers are the result of combining numbers vertically:\\n\\n```\\n \\\\ | - | + |\\n - | + | - |\\n + | - | + |\\n```\\n\\nIn order to search numbers, input lists are split into two halves:\\n\\n```bash\\na = [ -5, -2, -1, 0, 1, 2 ]\\n    |----[a1]---|---[a2]--]\\n\\nb = [ -8, -5, -2, 3, 5 ]\\n    |----[b1]---|-[b2]-|\\n```\\n\\nThe first thing to note is that the number of positive / negative numbers can be counted by multiplying the lengths of each section:\\n\\n```go\\nnegCount := len(a1)*len(b2) + len(b1)*len(a2)\\n```\\n\\nKnowing how many numbers exist, if a request is made for `k <= negCount`, then that product must be in one of the negative quadrants, and vice versa for `k > negCount`. This tells us which sections to combine when searching for an answer.\\n\\nHowever, simply multiplying elements in order from different segments yield different signs and orderings:\\n\\n| first | second | sign | order |\\n| --- | --- | --- | --- |\\n| a1 | b1 | + | desc |\\n| a1 | b2 | - | no order |\\n| a2 | b1 | - | no order |\\n| a2 | b2 | + | asc |\\n\\nThe first trick here is to reverse negative portions, which results in ordered outputs:\\n\\n| first | second | sign | order |\\n| --- | --- | --- | --- |\\n| rev(a1) | rev(b1) | + | asc |\\n| rev(a1) | b2 | - | desc |\\n| a2 | rev(b1) | - | desc |\\n| a2 | b2 | + | asc |\\n\\nAt this point it would be possible to write two different binary search functions, one for searching from the right, and one from the left. But there is one final trick to make the code cleaner. \\n\\nBy inverting negative values (making them positive), it\\'s possible to search in the same way for negative and positive numbers. However, the k\\'th result will no longer be the k\\'th smallest, but rather the k\\'th largest number:\\n\\n| first | second | sign | order |\\n| --- | --- | --- | --- |\\n| inv(rev(a1)) | inv(rev(b1)) | + | asc |\\n| inv(rev(a1)) | b2 | + | desc |\\n| a2 | inv(rev(b1)) | + | desc |\\n| a2 | b2 | + | asc |\\n\\n### Final solution:\\n\\n```go\\nfunc kthSmallestProduct(nums1 []int, nums2 []int, k int64) int64 {\\n\\taSplit := sort.SearchInts(nums1, 0)\\n\\tbSplit := sort.SearchInts(nums2, 0)\\n\\ta1, a2 := rev(inv(nums1[:aSplit])), nums1[aSplit:]\\n\\tb1, b2 := rev(inv(nums2[:bSplit])), nums2[bSplit:]\\n\\n\\tnegCount := len(a1)*len(b2) + len(b1)*len(a2)\\n\\n\\tsign := 1\\n\\tif int(k) > negCount {\\n\\t\\tk -= int64(negCount) // => kth smallest number from non-negative part\\n\\t} else {\\n\\t\\tk = int64(negCount) - k + 1 // => kth largest number after transform\\n\\t\\tb1, b2 = b2, b1             // swap to fix combination\\n\\t\\tsign = -1\\n\\t}\\n\\n\\tvar lo, hi int = 0, 1e10\\n\\tfor lo < hi {\\n\\t\\tmid := (lo + hi) / 2\\n\\t\\tif rcount(a1, b1, mid) + count(a2, b2, mid) >= int(k) {\\n\\t\\t\\thi = mid\\n\\t\\t} else {\\n\\t\\t\\tlo = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn int64(sign * lo)\\n}\\n\\nfunc count(a, b []int, val int) int {\\n\\tvar count int\\n\\tj := len(b) - 1\\n\\tfor i := range a {\\n\\t\\tfor j >= 0 && a[i]*b[j] > val {\\n\\t\\t\\tj--\\n\\t\\t}\\n\\t\\tcount += j + 1\\n\\t}\\n\\treturn count\\n}\\n\\nfunc inv(a []int) []int {\\n\\tfor i := range a {\\n\\t\\ta[i] = -a[i]\\n\\t}\\n\\treturn a\\n}\\n\\nfunc rev(a []int) []int {\\n\\tfor l, r := 0, len(a)-1; l < r; l, r = l+1, r-1 {\\n\\t\\ta[l], a[r] = a[r], a[l]\\n\\t}\\n\\treturn a\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc count(a, b []int, val int) int {\\n\\tvar count int\\n\\tj := len(b) - 1\\n\\tfor i := range a {\\n\\t\\tfor j >= 0 && a[i]*b[j] > val {\\n\\t\\t\\tj--\\n\\t\\t}\\n\\t\\tcount += j + 1\\n\\t}\\n\\treturn count\\n}\\n```\n```go\\nvar lo, hi int = 0, 1e10\\nfor lo < hi {\\n\\tmid := (lo + hi) / 2\\n\\tres := count(a, b, mid)\\n\\tif res >= int(k) {\\n\\t\\thi = mid\\n\\t} else {\\n\\t\\tlo = mid + 1\\n\\t}\\n}\\nreturn lo\\n```\n```\\n \\\\ | - | + |\\n - | + | - |\\n + | - | + |\\n```\n```bash\\na = [ -5, -2, -1, 0, 1, 2 ]\\n    |----[a1]---|---[a2]--]\\n\\nb = [ -8, -5, -2, 3, 5 ]\\n    |----[b1]---|-[b2]-|\\n```\n```go\\nnegCount := len(a1)*len(b2) + len(b1)*len(a2)\\n```\n```go\\nfunc kthSmallestProduct(nums1 []int, nums2 []int, k int64) int64 {\\n\\taSplit := sort.SearchInts(nums1, 0)\\n\\tbSplit := sort.SearchInts(nums2, 0)\\n\\ta1, a2 := rev(inv(nums1[:aSplit])), nums1[aSplit:]\\n\\tb1, b2 := rev(inv(nums2[:bSplit])), nums2[bSplit:]\\n\\n\\tnegCount := len(a1)*len(b2) + len(b1)*len(a2)\\n\\n\\tsign := 1\\n\\tif int(k) > negCount {\\n\\t\\tk -= int64(negCount) // => kth smallest number from non-negative part\\n\\t} else {\\n\\t\\tk = int64(negCount) - k + 1 // => kth largest number after transform\\n\\t\\tb1, b2 = b2, b1             // swap to fix combination\\n\\t\\tsign = -1\\n\\t}\\n\\n\\tvar lo, hi int = 0, 1e10\\n\\tfor lo < hi {\\n\\t\\tmid := (lo + hi) / 2\\n\\t\\tif rcount(a1, b1, mid) + count(a2, b2, mid) >= int(k) {\\n\\t\\t\\thi = mid\\n\\t\\t} else {\\n\\t\\t\\tlo = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn int64(sign * lo)\\n}\\n\\nfunc count(a, b []int, val int) int {\\n\\tvar count int\\n\\tj := len(b) - 1\\n\\tfor i := range a {\\n\\t\\tfor j >= 0 && a[i]*b[j] > val {\\n\\t\\t\\tj--\\n\\t\\t}\\n\\t\\tcount += j + 1\\n\\t}\\n\\treturn count\\n}\\n\\nfunc inv(a []int) []int {\\n\\tfor i := range a {\\n\\t\\ta[i] = -a[i]\\n\\t}\\n\\treturn a\\n}\\n\\nfunc rev(a []int) []int {\\n\\tfor l, r := 0, len(a)-1; l < r; l, r = l+1, r-1 {\\n\\t\\ta[l], a[r] = a[r], a[l]\\n\\t}\\n\\treturn a\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524526,
                "title": "c-2040-kth-smallest-product-of-two-sorted-arrays",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        \\n        auto fn = [&](double val) {\\n            long long ans = 0; \\n            for (auto& x : nums1) {\\n                if (x < 0) ans += nums2.end() - lower_bound(nums2.begin(), nums2.end(), ceil(val/x)); \\n                else if (x == 0) {\\n                    if (0 <= val) ans += nums2.size(); \\n                } else ans += upper_bound(nums2.begin(), nums2.end(), floor(val/x)) - nums2.begin(); \\n            }\\n            return ans; \\n        }; \\n        \\n        long long lo = -pow(10ll, 10), hi = pow(10ll, 10)+1;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo)/2; \\n            if (fn(mid) < k) lo = mid + 1; \\n            else hi = mid; \\n        }\\n        return lo; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        \\n        auto fn = [&](double val) {\\n            long long ans = 0; \\n            for (auto& x : nums1) {\\n                if (x < 0) ans += nums2.end() - lower_bound(nums2.begin(), nums2.end(), ceil(val/x)); \\n                else if (x == 0) {\\n                    if (0 <= val) ans += nums2.size(); \\n                } else ans += upper_bound(nums2.begin(), nums2.end(), floor(val/x)) - nums2.begin(); \\n            }\\n            return ans; \\n        }; \\n        \\n        long long lo = -pow(10ll, 10), hi = pow(10ll, 10)+1;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo)/2; \\n            if (fn(mid) < k) lo = mid + 1; \\n            else hi = mid; \\n        }\\n        return lo; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524578,
                "title": "java-binary-search-on-the-answer",
                "content": "Binary search on the answer and use a helper function to count the number of products that are less than mid.\\nSimilar problem from AtCoder - https://atcoder.jp/contests/abc155/tasks/abc155_d\\n\\n```\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        long lo = (long) -1e10;\\n        long hi = (long) 1e10;\\n        while (lo < hi) {\\n            final long mid = lo + hi + 1 >> 1;\\n            if (f(nums1, nums2, mid) < k) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    private static long f(int[] nums1, int[] nums2, long mid) {\\n        long count = 0;\\n        for (int num : nums1) {\\n            int lo = 0;\\n            int hi = nums2.length;\\n            if (num < 0) {\\n                while (lo < hi) {\\n                    final int m = lo + hi >>> 1;\\n                    if ((long) nums2[m] * num >= mid) {\\n                        lo = m + 1;\\n                    } else {\\n                        hi = m;\\n                    }\\n                }\\n                count += nums2.length - lo;\\n            } else {\\n                while (lo < hi) {\\n                    final int m = lo + hi >>> 1;\\n                    if ((long) nums2[m] * num < mid) {\\n                        lo = m + 1;\\n                    } else {\\n                        hi = m;\\n                    }\\n                }\\n                count += lo;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        long lo = (long) -1e10;\\n        long hi = (long) 1e10;\\n        while (lo < hi) {\\n            final long mid = lo + hi + 1 >> 1;\\n            if (f(nums1, nums2, mid) < k) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    private static long f(int[] nums1, int[] nums2, long mid) {\\n        long count = 0;\\n        for (int num : nums1) {\\n            int lo = 0;\\n            int hi = nums2.length;\\n            if (num < 0) {\\n                while (lo < hi) {\\n                    final int m = lo + hi >>> 1;\\n                    if ((long) nums2[m] * num >= mid) {\\n                        lo = m + 1;\\n                    } else {\\n                        hi = m;\\n                    }\\n                }\\n                count += nums2.length - lo;\\n            } else {\\n                while (lo < hi) {\\n                    final int m = lo + hi >>> 1;\\n                    if ((long) nums2[m] * num < mid) {\\n                        lo = m + 1;\\n                    } else {\\n                        hi = m;\\n                    }\\n                }\\n                count += lo;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1626617,
                "title": "java-solution-binary-search",
                "content": "So we want to find out k-th smallest product from the two sorted arrays. Let\\'s first find out the range of our answer. So the minimum value it can go is if we have elements -10^5 in both the arrays so the minimum value is -10^10 and similarly for maximum value it is 10^10. Now we can do a binary search in our range and for every current product we can check whether we have atleast k products that are less than current product. If we do have atleast k products that are less than current product then we move our window left, otherwise to the right.\\n\\nOk so now we know what we have to do, lets now see how would we do what we wanna do?\\n\\nSo we iterate over nums1 and count the number of products that are less than current product.\\nHere three cases arise:\\n1. currentElement = 0: 0 * any number in nums2 will be 0. So if current product>=0 then we know that the whole array(nums2) would be included in our count.\\n2. currentElement>0: then we find maximum index in nums2 such that currentElement * nums2[maxIndex] is less than equal to current product. Then we can add maxIndex+1 elements into our count as they are less that equal to current product.\\n3. currentElement<0: then we do exact reverse of what we did in the previous case. We find minimum element that satisfies currentElement * nums2[minIndex]<= current product.\\n\\nCode :\\n```\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        long l = (long)-1e11;\\n        long r = (long)1e11;\\n        long res = 0;\\n        while ( l<=r ) {\\n            long mid = (l+r)/2;\\n            // checking whether we have k at least k elements whose product is less than the current product\\n            // if yes then we know we have to move left\\n            if ( check(mid, nums1, nums2, k) ) {\\n                r = mid - 1;\\n                res = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean check ( long mid, int[] nums1, int[] nums2, long k ) {\\n        long cnt = 0;\\n        for ( int i=0; i<nums1.length; i++ ) {\\n            long val = (long) nums1[i];\\n            // if current element is 0 and we out current product is >= 0 then we can add the whole second array because 0*anything will be 0\\n            if ( val==0 && mid>=0 ) {\\n                cnt += nums2.length;\\n            } else if ( val<0 ) {\\n                // If we encounter negative value we find the minimum index in the second array such that this element * minIndexElement <= current product\\n                cnt += findMinIndex(val, mid, nums2);\\n            } else if ( val>0 ) {\\n                // if we encounter positive element we find max index in the second array such that this element * maxIndexElement <= current product\\n                cnt += findMaxIndex(val, mid, nums2);\\n            }\\n        }\\n        // if we have atleast k elements whose product is less than current product\\n        return cnt>=k;\\n    }\\n    public long findMaxIndex( long val, long mid, int[] nums2 ) {\\n        int l = 0;\\n        int r = nums2.length - 1;\\n        // when no element in second array when multiplied by the current element of the first array yields result less that current product we will return res+1 hence -1 + 1 hence 0 coz there are no elements which when multiplied by current element of the first array yield result less than current product.\\n        long res = -1;\\n        while ( l<=r ) {\\n            int m = (l+r)/2;\\n            if ( val*nums2[m]<=mid ) {\\n                // if our current product is >= val*current element then we move the window to right side in order to find max index with which when multiplied the element of the first array is still less than current product.\\n                res = (long)m;\\n                l = m + 1; \\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        // so we have found res+1 elements who satisfy our condition. +1 coz res would give index\\n        return res+1;\\n    }\\n    public long findMinIndex( long val, long mid, int[] nums2 ) {\\n        int l = 0;\\n        int r = nums2.length - 1;\\n        // when all elements of second array multiplied by current element of first array yield result > current product then we return 0 coz there are no elements which would yield us result.\\n        long res = r + 1;\\n        while ( l<=r ) {\\n            int m = (l+r)/2;\\n            if ( val*nums2[m]<=mid ) {\\n                r = m - 1;\\n                res = (long)m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return nums2.length - res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        long l = (long)-1e11;\\n        long r = (long)1e11;\\n        long res = 0;\\n        while ( l<=r ) {\\n            long mid = (l+r)/2;\\n            // checking whether we have k at least k elements whose product is less than the current product\\n            // if yes then we know we have to move left\\n            if ( check(mid, nums1, nums2, k) ) {\\n                r = mid - 1;\\n                res = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean check ( long mid, int[] nums1, int[] nums2, long k ) {\\n        long cnt = 0;\\n        for ( int i=0; i<nums1.length; i++ ) {\\n            long val = (long) nums1[i];\\n            // if current element is 0 and we out current product is >= 0 then we can add the whole second array because 0*anything will be 0\\n            if ( val==0 && mid>=0 ) {\\n                cnt += nums2.length;\\n            } else if ( val<0 ) {\\n                // If we encounter negative value we find the minimum index in the second array such that this element * minIndexElement <= current product\\n                cnt += findMinIndex(val, mid, nums2);\\n            } else if ( val>0 ) {\\n                // if we encounter positive element we find max index in the second array such that this element * maxIndexElement <= current product\\n                cnt += findMaxIndex(val, mid, nums2);\\n            }\\n        }\\n        // if we have atleast k elements whose product is less than current product\\n        return cnt>=k;\\n    }\\n    public long findMaxIndex( long val, long mid, int[] nums2 ) {\\n        int l = 0;\\n        int r = nums2.length - 1;\\n        // when no element in second array when multiplied by the current element of the first array yields result less that current product we will return res+1 hence -1 + 1 hence 0 coz there are no elements which when multiplied by current element of the first array yield result less than current product.\\n        long res = -1;\\n        while ( l<=r ) {\\n            int m = (l+r)/2;\\n            if ( val*nums2[m]<=mid ) {\\n                // if our current product is >= val*current element then we move the window to right side in order to find max index with which when multiplied the element of the first array is still less than current product.\\n                res = (long)m;\\n                l = m + 1; \\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        // so we have found res+1 elements who satisfy our condition. +1 coz res would give index\\n        return res+1;\\n    }\\n    public long findMinIndex( long val, long mid, int[] nums2 ) {\\n        int l = 0;\\n        int r = nums2.length - 1;\\n        // when all elements of second array multiplied by current element of first array yield result > current product then we return 0 coz there are no elements which would yield us result.\\n        long res = r + 1;\\n        while ( l<=r ) {\\n            int m = (l+r)/2;\\n            if ( val*nums2[m]<=mid ) {\\n                r = m - 1;\\n                res = (long)m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return nums2.length - res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524190,
                "title": "python3-binary-search",
                "content": "\\n```\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        \\n        def fn(val):\\n            \"\"\"Return count of products <= val.\"\"\"\\n            ans = 0\\n            for x in nums1: \\n                if x < 0: ans += len(nums2) - bisect_left(nums2, ceil(val/x))\\n                elif x == 0: \\n                    if 0 <= val: ans += len(nums2)\\n                else: ans += bisect_right(nums2, floor(val/x))\\n            return ans \\n            \\n        lo, hi = -10**10, 10**10 + 1\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if fn(mid) < k: lo = mid + 1\\n            else: hi = mid\\n        return lo \\n```\\n\\n```\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        neg = [x for x in nums1 if x < 0]\\n        pos = [x for x in nums1 if x >= 0]\\n        \\n        def fn(val):\\n            \"\"\"Return count of products <= val.\"\"\"\\n            ans = 0\\n            lo, hi = 0, len(nums2)-1\\n            for x in neg[::-1] + pos if val >= 0 else neg + pos[::-1]: \\n                if x < 0: \\n                    while lo < len(nums2) and x*nums2[lo] > val: lo += 1\\n                    ans += len(nums2) - lo\\n                elif x == 0: \\n                    if 0 <= val: ans += len(nums2)\\n                else: \\n                    while 0 <= hi and x*nums2[hi] > val: hi -= 1\\n                    ans += hi+1\\n            return ans \\n        \\n        lo, hi = -10**10, 10**10 + 1\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if fn(mid) < k: lo = mid + 1\\n            else: hi = mid\\n        return lo \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        \\n        def fn(val):\\n            \"\"\"Return count of products <= val.\"\"\"\\n            ans = 0\\n            for x in nums1: \\n                if x < 0: ans += len(nums2) - bisect_left(nums2, ceil(val/x))\\n                elif x == 0: \\n                    if 0 <= val: ans += len(nums2)\\n                else: ans += bisect_right(nums2, floor(val/x))\\n            return ans \\n            \\n        lo, hi = -10**10, 10**10 + 1\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if fn(mid) < k: lo = mid + 1\\n            else: hi = mid\\n        return lo \\n```\n```\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        neg = [x for x in nums1 if x < 0]\\n        pos = [x for x in nums1 if x >= 0]\\n        \\n        def fn(val):\\n            \"\"\"Return count of products <= val.\"\"\"\\n            ans = 0\\n            lo, hi = 0, len(nums2)-1\\n            for x in neg[::-1] + pos if val >= 0 else neg + pos[::-1]: \\n                if x < 0: \\n                    while lo < len(nums2) and x*nums2[lo] > val: lo += 1\\n                    ans += len(nums2) - lo\\n                elif x == 0: \\n                    if 0 <= val: ans += len(nums2)\\n                else: \\n                    while 0 <= hi and x*nums2[hi] > val: hi -= 1\\n                    ans += hi+1\\n            return ans \\n        \\n        lo, hi = -10**10, 10**10 + 1\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if fn(mid) < k: lo = mid + 1\\n            else: hi = mid\\n        return lo \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525595,
                "title": "o-m-n-using-old-algorithm-on-virtual-matrix",
                "content": "O(M+N) solution, where M and N are the lengths of the two arrays. Using an [O(n) solution for finding the kth-smallest element in a sorted n&times;n matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/O(n)-from-paper.-Yes-O(rows).). Applied to a virtual matrix I build. \"Virtual\" meaning I compute its elements on-the-fly, only the elements the algorithm needs to look at. Because building the whole matrix explicitly would take O(MN).\\n\\nFor example for the arrays `[-2,-1,0,1,2]` and `[-3,-1,2,4,5]` with `k=3`, I first figure out that there are ten negative products, so the kth-smallest product is negative. And thus I build the following virtual matrix of all negative products and find the 7-th smallest element (7 because k=3 and the four -\\u221E elements):\\n```\\n[-\\u221E, -\\u221E, -10, -8, -4]\\n[-\\u221E, -\\u221E,  -5, -4, -2]\\n[-6, -2,   \\u221E,  \\u221E,  \\u221E]\\n[-3, -1,   \\u221E,  \\u221E,  \\u221E]\\n[ \\u221E,  \\u221E,   \\u221E,  \\u221E,  \\u221E]\\n```\\nThe lower-left \"quadrant\" is the positive values from the first array multiplied with the negative values from the second array. The upper-right quadrant is negatives from first multiplied with positives from second.\\n\\nThe same arrays `[-2,-1,0,1,2]` and `[-3,-1,2,4,5]` but with `k=20` turns into finding the 9th-smallest element in the virtual matrix of *positive* products:\\n```\\n[-\\u221E, -\\u221E,  2,  4,  5]\\n[-\\u221E, -\\u221E,  4,  8, 10]\\n[ 1,  3,  \\u221E,  \\u221E,  \\u221E]\\n[ 2,  6,  \\u221E,  \\u221E,  \\u221E]\\n[ \\u221E,  \\u221E,  \\u221E,  \\u221E,  \\u221E]\\n```\\nLower-left are (negatives of first)&times;(negatives of second).\\nUpper-right are (positives of first)&times;(positives of second).\\n\\nThe solution code, the bottom half is the `kthSmallest` function from the old problem:\\n\\n```\\nclass Solution:\\n    def kthSmallestProduct(self, A, B, k):\\n        \\n        # Analyze negatives, positives, zeros\\n        negA = [a for a in A if a < 0]\\n        posA = [a for a in A if a > 0]\\n        negB = [b for b in B if b < 0]\\n        posB = [b for b in B if b > 0]\\n        nA, pA, nB, pB = map(len, (negA, posA, negB, posB))\\n        negatives = nA * pB + pA * nB\\n        positives = nA * nB + pA * pB\\n        zeros = len(A) * len(B) - negatives - positives\\n        \\n        # Configure the matrix and adjust k.\\n\\t\\t# A1 and A2 become the factors for the rows (top and bottom part)\\n\\t\\t# B1 and B2 become the factors for the columns (left and right part)\\n        if k <= negatives:\\n            A1, A2 = negA, posA[::-1]\\n            B1, B2 = negB, posB[::-1]\\n        else:\\n            k -= negatives\\n            if k <= zeros:\\n                return 0\\n            k -= zeros\\n            A1, A2 = posA, negA[::-1]\\n            B1, B2 = negB[::-1], posB\\n            \\n        # Build the virtual matrix\\n        a1, a2, b1, b2 = map(len, (A1, A2, B1, B2))\\n        k += a1 * b1\\n        m = len(A1 + A2)\\n        n = len(B1 + B2)\\n        class Row:\\n            def __init__(self, i):\\n                if i < a1:\\n                    get = lambda j: -inf if j < b1 else A1[i] * B2[j-b1] if j < n else inf\\n                elif i < m:\\n                    get = lambda j: A2[i-a1] * B1[j] if j < b1 else inf\\n                else:\\n                    get = lambda j: inf\\n                self.get = get\\n            def __getitem__(self, j):\\n                return self.get(j)\\n        matrix = list(map(Row, range(max(m, n))))\\n        \\n        # Debugging/visualization: print the matrix\\n        if 0:\\n            print(k)\\n            for i in range(len(matrix)):\\n                print([matrix[i][j] for j in range(len(matrix))])\\n                \\n        # Let the matrix solution do the hard work\\n        return self.kthSmallest(matrix, k)\\n\\n    def kthSmallest(self, matrix, k):\\n\\n        # The median-of-medians selection function.\\n        def pick(a, k):\\n            if k == 1:\\n                return min(a)\\n            groups = (a[i:i+5] for i in range(0, len(a), 5))\\n            medians = [sorted(group)[len(group) // 2] for group in groups]\\n            pivot = pick(medians, len(medians) // 2 + 1)\\n            smaller = [x for x in a if x < pivot]\\n            if k <= len(smaller):\\n                return pick(smaller, k)\\n            k -= len(smaller) + a.count(pivot)\\n            return pivot if k < 1 else pick([x for x in a if x > pivot], k)\\n\\n        # Find the k1-th and k2th smallest entries in the submatrix.\\n        def biselect(index, k1, k2):\\n\\n            # Provide the submatrix.\\n            n = len(index)\\n            def A(i, j):\\n                return matrix[index[i]][index[j]]\\n            \\n            # Base case.\\n            if n <= 2:\\n                nums = sorted(A(i, j) for i in range(n) for j in range(n))\\n                return nums[k1-1], nums[k2-1]\\n\\n            # Solve the subproblem.\\n            index_ = index[::2] + index[n-1+n%2:]\\n            k1_ = (k1 + 2*n) // 4 + 1 if n % 2 else n + 1 + (k1 + 3) // 4\\n            k2_ = (k2 + 3) // 4\\n            a, b = biselect(index_, k1_, k2_)\\n\\n            # Prepare ra_less, rb_more and L with saddleback search variants.\\n            ra_less = rb_more = 0\\n            L = []\\n            jb = n   # jb is the first where A(i, jb) is larger than b.\\n            ja = n   # ja is the first where A(i, ja) is larger than or equal to a.\\n            for i in range(n):\\n                while jb and A(i, jb - 1) > b:\\n                    jb -= 1\\n                while ja and A(i, ja - 1) >= a:\\n                    ja -= 1\\n                ra_less += ja\\n                rb_more += n - jb\\n                L.extend(A(i, j) for j in range(jb, ja))\\n                \\n            # Compute and return x and y.\\n            x = a if ra_less <= k1 - 1 else \\\\\\n                b if k1 + rb_more - n*n <= 0 else \\\\\\n                pick(L, k1 + rb_more - n*n)\\n            y = a if ra_less <= k2 - 1 else \\\\\\n                b if k2 + rb_more - n*n <= 0 else \\\\\\n                pick(L, k2 + rb_more - n*n)\\n            return x, y\\n\\n        # Set up and run the search.\\n        n = len(matrix)\\n        start = max(k - n*n + n-1, 0)\\n        k -= n*n - (n - start)**2\\n        return biselect(list(range(start, min(n, start+k))), k, k)[0]\\n```",
                "solutionTags": [],
                "code": "```\\n[-\\u221E, -\\u221E, -10, -8, -4]\\n[-\\u221E, -\\u221E,  -5, -4, -2]\\n[-6, -2,   \\u221E,  \\u221E,  \\u221E]\\n[-3, -1,   \\u221E,  \\u221E,  \\u221E]\\n[ \\u221E,  \\u221E,   \\u221E,  \\u221E,  \\u221E]\\n```\n```\\n[-\\u221E, -\\u221E,  2,  4,  5]\\n[-\\u221E, -\\u221E,  4,  8, 10]\\n[ 1,  3,  \\u221E,  \\u221E,  \\u221E]\\n[ 2,  6,  \\u221E,  \\u221E,  \\u221E]\\n[ \\u221E,  \\u221E,  \\u221E,  \\u221E,  \\u221E]\\n```\n```\\nclass Solution:\\n    def kthSmallestProduct(self, A, B, k):\\n        \\n        # Analyze negatives, positives, zeros\\n        negA = [a for a in A if a < 0]\\n        posA = [a for a in A if a > 0]\\n        negB = [b for b in B if b < 0]\\n        posB = [b for b in B if b > 0]\\n        nA, pA, nB, pB = map(len, (negA, posA, negB, posB))\\n        negatives = nA * pB + pA * nB\\n        positives = nA * nB + pA * pB\\n        zeros = len(A) * len(B) - negatives - positives\\n        \\n        # Configure the matrix and adjust k.\\n\\t\\t# A1 and A2 become the factors for the rows (top and bottom part)\\n\\t\\t# B1 and B2 become the factors for the columns (left and right part)\\n        if k <= negatives:\\n            A1, A2 = negA, posA[::-1]\\n            B1, B2 = negB, posB[::-1]\\n        else:\\n            k -= negatives\\n            if k <= zeros:\\n                return 0\\n            k -= zeros\\n            A1, A2 = posA, negA[::-1]\\n            B1, B2 = negB[::-1], posB\\n            \\n        # Build the virtual matrix\\n        a1, a2, b1, b2 = map(len, (A1, A2, B1, B2))\\n        k += a1 * b1\\n        m = len(A1 + A2)\\n        n = len(B1 + B2)\\n        class Row:\\n            def __init__(self, i):\\n                if i < a1:\\n                    get = lambda j: -inf if j < b1 else A1[i] * B2[j-b1] if j < n else inf\\n                elif i < m:\\n                    get = lambda j: A2[i-a1] * B1[j] if j < b1 else inf\\n                else:\\n                    get = lambda j: inf\\n                self.get = get\\n            def __getitem__(self, j):\\n                return self.get(j)\\n        matrix = list(map(Row, range(max(m, n))))\\n        \\n        # Debugging/visualization: print the matrix\\n        if 0:\\n            print(k)\\n            for i in range(len(matrix)):\\n                print([matrix[i][j] for j in range(len(matrix))])\\n                \\n        # Let the matrix solution do the hard work\\n        return self.kthSmallest(matrix, k)\\n\\n    def kthSmallest(self, matrix, k):\\n\\n        # The median-of-medians selection function.\\n        def pick(a, k):\\n            if k == 1:\\n                return min(a)\\n            groups = (a[i:i+5] for i in range(0, len(a), 5))\\n            medians = [sorted(group)[len(group) // 2] for group in groups]\\n            pivot = pick(medians, len(medians) // 2 + 1)\\n            smaller = [x for x in a if x < pivot]\\n            if k <= len(smaller):\\n                return pick(smaller, k)\\n            k -= len(smaller) + a.count(pivot)\\n            return pivot if k < 1 else pick([x for x in a if x > pivot], k)\\n\\n        # Find the k1-th and k2th smallest entries in the submatrix.\\n        def biselect(index, k1, k2):\\n\\n            # Provide the submatrix.\\n            n = len(index)\\n            def A(i, j):\\n                return matrix[index[i]][index[j]]\\n            \\n            # Base case.\\n            if n <= 2:\\n                nums = sorted(A(i, j) for i in range(n) for j in range(n))\\n                return nums[k1-1], nums[k2-1]\\n\\n            # Solve the subproblem.\\n            index_ = index[::2] + index[n-1+n%2:]\\n            k1_ = (k1 + 2*n) // 4 + 1 if n % 2 else n + 1 + (k1 + 3) // 4\\n            k2_ = (k2 + 3) // 4\\n            a, b = biselect(index_, k1_, k2_)\\n\\n            # Prepare ra_less, rb_more and L with saddleback search variants.\\n            ra_less = rb_more = 0\\n            L = []\\n            jb = n   # jb is the first where A(i, jb) is larger than b.\\n            ja = n   # ja is the first where A(i, ja) is larger than or equal to a.\\n            for i in range(n):\\n                while jb and A(i, jb - 1) > b:\\n                    jb -= 1\\n                while ja and A(i, ja - 1) >= a:\\n                    ja -= 1\\n                ra_less += ja\\n                rb_more += n - jb\\n                L.extend(A(i, j) for j in range(jb, ja))\\n                \\n            # Compute and return x and y.\\n            x = a if ra_less <= k1 - 1 else \\\\\\n                b if k1 + rb_more - n*n <= 0 else \\\\\\n                pick(L, k1 + rb_more - n*n)\\n            y = a if ra_less <= k2 - 1 else \\\\\\n                b if k2 + rb_more - n*n <= 0 else \\\\\\n                pick(L, k2 + rb_more - n*n)\\n            return x, y\\n\\n        # Set up and run the search.\\n        n = len(matrix)\\n        start = max(k - n*n + n-1, 0)\\n        k -= n*n - (n - start)**2\\n        return biselect(list(range(start, min(n, start+k))), k, k)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228934,
                "title": "c-both-approaches-2-pointer-binary-search-easy-to-understand",
                "content": "**Approach 1 : 2 pointers**\\n```\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        \\n        auto fn = [&](double val) {\\n            long long ans = 0; \\n            for (auto& x : nums1) {\\n                if (x < 0) ans += nums2.end() - lower_bound(nums2.begin(), nums2.end(), ceil(val/x)); \\n                else if (x == 0) {\\n                    if (0 <= val) ans += nums2.size(); \\n                } else ans += upper_bound(nums2.begin(), nums2.end(), floor(val/x)) - nums2.begin(); \\n            }\\n            return ans; \\n        }; \\n        \\n        long long lo = -pow(10ll, 10), hi = pow(10ll, 10)+1;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo)/2; \\n            if (fn(mid) < k) lo = mid + 1; \\n            else hi = mid; \\n        }\\n        return lo; \\n    }\\n};\\n\\n```\\n**Approach 2 : Binary Search**\\nThe idea of this problem is to use binary search on answer -\\nLet check(x) be the answer to the question: how many products are less or equal than x.\\nThen we use binary search and find the first moment where we have exactly k such numbers .\\n```\\nclass Solution {\\npublic:\\n    bool check(long long midval,vector<int>& nums1, vector<int>& nums2, long long k){\\n        long long cnt=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long val=nums1[i];\\n                        \\n\\t\\t\\t//If val == 0, product of val and each element in nums2 will be 0. And if midval>=0, then because all\\n\\t\\t\\t//products are 0, all products will be smaller or equal to midval. So we can add all products in the answer\\n\\t\\t\\tif(val==0 and midval>=0)\\n                cnt+=nums2.size();\\n            \\n            else if(val>0)\\n                cnt+=findmaxIndex(nums2,val,midval);\\n            \\n            else if(val<0)\\n                cnt+=findminIndex(nums2,val,midval);\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    int findmaxIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  -1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return res+1;\\n    }\\n    \\n    int findminIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  r+1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return nums2.size()-res;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long l=-1e10,r=1e10,res=-1;\\n        while(l<=r){\\n            long long mid = (l+r)/2;\\n            // cout<<mid<<endl;\\n            if(check(mid,nums1,nums2,k)) {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        \\n        auto fn = [&](double val) {\\n            long long ans = 0; \\n            for (auto& x : nums1) {\\n                if (x < 0) ans += nums2.end() - lower_bound(nums2.begin(), nums2.end(), ceil(val/x)); \\n                else if (x == 0) {\\n                    if (0 <= val) ans += nums2.size(); \\n                } else ans += upper_bound(nums2.begin(), nums2.end(), floor(val/x)) - nums2.begin(); \\n            }\\n            return ans; \\n        }; \\n        \\n        long long lo = -pow(10ll, 10), hi = pow(10ll, 10)+1;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo)/2; \\n            if (fn(mid) < k) lo = mid + 1; \\n            else hi = mid; \\n        }\\n        return lo; \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool check(long long midval,vector<int>& nums1, vector<int>& nums2, long long k){\\n        long long cnt=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long val=nums1[i];\\n                        \\n\\t\\t\\t//If val == 0, product of val and each element in nums2 will be 0. And if midval>=0, then because all\\n\\t\\t\\t//products are 0, all products will be smaller or equal to midval. So we can add all products in the answer\\n\\t\\t\\tif(val==0 and midval>=0)\\n                cnt+=nums2.size();\\n            \\n            else if(val>0)\\n                cnt+=findmaxIndex(nums2,val,midval);\\n            \\n            else if(val<0)\\n                cnt+=findminIndex(nums2,val,midval);\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    int findmaxIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  -1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return res+1;\\n    }\\n    \\n    int findminIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  r+1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return nums2.size()-res;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long l=-1e10,r=1e10,res=-1;\\n        while(l<=r){\\n            long long mid = (l+r)/2;\\n            // cout<<mid<<endl;\\n            if(check(mid,nums1,nums2,k)) {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2047680,
                "title": "java-binary-search-solution",
                "content": "# [2040. Kth Smallest Product of Two Sorted Arrays](https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/)\\n\\n**Please** \\uD83D\\uDD3C **upvote this post if you find the answer useful & do comment about your thoughts** \\uD83D\\uDCAC\\n\\n## Java | Binary Search Solution\\n\\n### Java Code\\n\\n```\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        return kthSmallest(nums1, nums2, k);\\n    }\\n\\n\\tpublic static long kthSmallest(int[] nums1, int[] nums2, long k) {\\n\\n\\t\\tlong lo = -1000_000_0000l;\\n\\t\\tlong hi = 1000_000_0000l;\\n\\t\\tlong ans = 0;\\n\\n\\t\\t// Binary Search\\n\\t\\twhile (lo <= hi) {\\n\\t\\t\\tlong mid = (lo + hi) / 2;\\n\\t\\t\\tif (countNumberOfElements(nums1, nums2, mid) >= k) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\t}\\n\\n\\tpublic static long countNumberOfElements(int[] arr1, int[] arr2, long Dot_pot) {\\n\\t\\tlong ans = 0;\\n\\t\\tfor (int e1 : arr1) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tif (e1 >= 0) {\\n\\t\\t\\t\\tint lo = 0;\\n\\t\\t\\t\\tint hi = arr2.length - 1;\\n\\t\\t\\t\\twhile (lo <= hi) {\\n\\t\\t\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\t\\t\\tif ((long) e1 * arr2[mid] <= Dot_pot) {\\n\\t\\t\\t\\t\\t\\tcount = mid + 1;\\n\\t\\t\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = ans + count;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\telse {\\n\\n\\t\\t\\t\\tint lo = 0;\\n\\t\\t\\t\\tint hi = arr2.length - 1;\\n\\t\\t\\t\\twhile (lo <= hi) {\\n\\t\\t\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\t\\t\\tif ((long) e1 * arr2[mid] <= Dot_pot) {\\n\\t\\t\\t\\t\\t\\tcount = arr2.length - mid;\\n\\t\\t\\t\\t\\t\\thi = mid - 1;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = ans + count;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        return kthSmallest(nums1, nums2, k);\\n    }\\n\\n\\tpublic static long kthSmallest(int[] nums1, int[] nums2, long k) {\\n\\n\\t\\tlong lo = -1000_000_0000l;\\n\\t\\tlong hi = 1000_000_0000l;\\n\\t\\tlong ans = 0;\\n\\n\\t\\t// Binary Search\\n\\t\\twhile (lo <= hi) {\\n\\t\\t\\tlong mid = (lo + hi) / 2;\\n\\t\\t\\tif (countNumberOfElements(nums1, nums2, mid) >= k) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\t}\\n\\n\\tpublic static long countNumberOfElements(int[] arr1, int[] arr2, long Dot_pot) {\\n\\t\\tlong ans = 0;\\n\\t\\tfor (int e1 : arr1) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tif (e1 >= 0) {\\n\\t\\t\\t\\tint lo = 0;\\n\\t\\t\\t\\tint hi = arr2.length - 1;\\n\\t\\t\\t\\twhile (lo <= hi) {\\n\\t\\t\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\t\\t\\tif ((long) e1 * arr2[mid] <= Dot_pot) {\\n\\t\\t\\t\\t\\t\\tcount = mid + 1;\\n\\t\\t\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = ans + count;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\telse {\\n\\n\\t\\t\\t\\tint lo = 0;\\n\\t\\t\\t\\tint hi = arr2.length - 1;\\n\\t\\t\\t\\twhile (lo <= hi) {\\n\\t\\t\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\t\\t\\tif ((long) e1 * arr2[mid] <= Dot_pot) {\\n\\t\\t\\t\\t\\t\\tcount = arr2.length - mid;\\n\\t\\t\\t\\t\\t\\thi = mid - 1;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = ans + count;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006069,
                "title": "java-binary-search-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        // 1. define search space\\n        long left = (long)-1e11;\\n        long right = (long)1e11;\\n        while(left < right){\\n            long mid = left + (right - left) / 2;\\n            if(countSmaller(nums1, nums2, mid) >= k){\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        // At the end, left is the product that has k smaller products before it, so the kth smallest product is left - 1\\n        return left - 1;\\n    }\\n    \\n    private long countSmaller(int[] nums1, int[] nums2, long product){\\n        long count = 0;\\n        for(int i = 0; i < nums1.length; i++){\\n            // count all nums2[j] such that nums1[i] * nums2[j] < product\\n            if(nums1[i] >= 0){\\n                int left = 0;\\n                int right = nums2.length;\\n                while(left < right){\\n                    int mid = left + (right - left) / 2;\\n                    // if nums1[i] > 0, find the first occurrence of nums2[j] where nums1[i] * nums2[j] >= product\\n                    if((long) nums1[i] * nums2[mid] < product){\\n                        left = mid + 1;\\n                    } else {\\n                        right = mid;\\n                    }   \\n                }\\n                count += left;\\n            } else {\\n                int left = 0;\\n                int right = nums2.length;\\n                while(left < right){\\n                    int mid = left + (right - left) / 2;\\n                    // since nums1[i] is negative, nums2 is sorted\\n                    // nums[j] * nums[i] will be in descending order from [0...nums2.length-1]\\n                    // take [-4,-2,0,3] as an example, product with a negative number will become smaller if the number gets bigger\\n                    // want to find the last nums2[j] such that nums1[i] * nums2[j] is not smaller than product\\n                    if((long) nums1[i] * nums2[mid] >= product){\\n                        left = mid + 1;\\n                    } else {\\n                        right = mid;\\n                    }\\n                }\\n                count += nums2.length - left;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        // 1. define search space\\n        long left = (long)-1e11;\\n        long right = (long)1e11;\\n        while(left < right){\\n            long mid = left + (right - left) / 2;\\n            if(countSmaller(nums1, nums2, mid) >= k){\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        // At the end, left is the product that has k smaller products before it, so the kth smallest product is left - 1\\n        return left - 1;\\n    }\\n    \\n    private long countSmaller(int[] nums1, int[] nums2, long product){\\n        long count = 0;\\n        for(int i = 0; i < nums1.length; i++){\\n            // count all nums2[j] such that nums1[i] * nums2[j] < product\\n            if(nums1[i] >= 0){\\n                int left = 0;\\n                int right = nums2.length;\\n                while(left < right){\\n                    int mid = left + (right - left) / 2;\\n                    // if nums1[i] > 0, find the first occurrence of nums2[j] where nums1[i] * nums2[j] >= product\\n                    if((long) nums1[i] * nums2[mid] < product){\\n                        left = mid + 1;\\n                    } else {\\n                        right = mid;\\n                    }   \\n                }\\n                count += left;\\n            } else {\\n                int left = 0;\\n                int right = nums2.length;\\n                while(left < right){\\n                    int mid = left + (right - left) / 2;\\n                    // since nums1[i] is negative, nums2 is sorted\\n                    // nums[j] * nums[i] will be in descending order from [0...nums2.length-1]\\n                    // take [-4,-2,0,3] as an example, product with a negative number will become smaller if the number gets bigger\\n                    // want to find the last nums2[j] such that nums1[i] * nums2[j] is not smaller than product\\n                    if((long) nums1[i] * nums2[mid] >= product){\\n                        left = mid + 1;\\n                    } else {\\n                        right = mid;\\n                    }\\n                }\\n                count += nums2.length - left;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526978,
                "title": "c-binary-search-explanation-with-examples",
                "content": "The idea is to use binary search on the answer.\\nWe are searching for the least x, such that there are at least k products less than or equal to x.\\n\\nFor each element in the array *a[n]* we perform a special binary search on the array *b[m]*, hence a total running time of *O(n.log(m).log(Range))*.\\nSince the order of *a* and *b* is irrelevant, this bound can further be improved to *O(min(n,m).log(max(n,m)).log(Range))*.\\n\\n*How exactly do we perform the search?*\\n\\nLet *the upper-bound of y* be the number of elements in *b* that are less than or equal to y.\\n\\nLet x\\u22650. Let w>0 be an element of *a* and we want to know how many products of w with an element of *b* are less than or equal to x.\\nThe numbers of these products is exactly *the upper-bound of (x div w)*, for instance:\\n\\nx=31, w=10, b=[-5, -4, -3, -3, -2, -1, 2, 3, 3, 4, 6, 12, 13].\\nThe number of products, less than or equal to 31 is 9.\\nThis corresponds to the range [-5, -4, -3, -3, -2, -1, 2, 3, 3], which directly corresponds to *the upper-bound of 3*.\\n\\nIn case w<0 we are interested in *m - the upper-bound of (x div w)-1*.\\nFor instance x=31, w=-10 in the above example.\\nThe valid range of products is [-3, -3, -2, -1, 2, 3, 3, 4, 6, 12, 13].\\nThe number of elemets here is exactly *m - the upper-bound of -4*, since the later corresponds to the remaining range [-5, -4].\\n\\nIn case x<0, we have some special cases, depending on whether w divides x or not.\\n\\nFor w>0 and w divides x we are again searching for *the upper-bound of (x div w)*.\\nFor instance x=-30, w=10 in the above example.\\nThe valid range is [-5, -4, -3, -3], which corresponds to the products [-50, -40, -30, -30], all less than or equal to -30.\\n\\nHowever if w does not divide x we are searching for *the upper-bound of (x div w)-1*.\\nFor instance x=-31, w=10. \\nThe valid range is now [-5, -4], which corresponds to the producuts [-50, -40].\\nNote that -3 is no longer in the valid range, since -30 > -31.\\n\\nFor w<0 and w divides x we are again searching for *m - the upper-bound of (x div w)-1*.\\nFor instance x=-30, w=-10. \\nThe valid range is now [3, 3, 4, 6, 12, 13], which corresponds to the products [-30, -30, -40, -60, -120, -130], all less than or equal to -30.\\n\\nHowever if w does not divide x we are searching for *m - the upper-bound of (x div w)*.\\nFor instance x=-31, w=-10.\\nThe valid range is now [4, 6, 12, 13], which corresponds to the products [-40, -60, -120, -130].\\nNote that 3 is now longer in the valid range, since -30 > -31.\\n\\nThe last remaining case is w=0, which is trivial, since all resulting products are equal to 0.\\nIn case x\\u22650, we have m products less than or equal to x and in case x<0 we have no such products.\\n\\nThe following C solution is a straight-forward illustration of the above idea.\\n```\\nint ub(int* a, int l, int r, long long x){\\n    int m;\\n    while (l <= r){\\n        m = (l+r)/2;\\n        if (a[m] <= x) l = m+1;\\n        else r = m-1;\\n    }\\n    \\n    return l;\\n}\\n\\nlong long kthSmallestProduct(int* a, int n, int* b, int m, long long k){\\n    long long r = (long long)(1e10), l = -r, x, c;\\n    \\n    int i;\\n    \\n    while (l <= r){\\n        x = (l+r)/2;\\n        \\n        c = 0;\\n        for (i = 0; i < n; i++){\\n            if (a[i] > 0) c += ub(b, 0, m-1, x/a[i] - (x<0 && x%a[i]));\\n            else if (a[i] < 0) c += m - ub(b, 0, m-1, x/a[i] - !(x<0 && x%a[i]));\\n            else if (x >= 0) c += m;\\n            \\n            if (c > k-1) break;\\n        }\\n        \\n        if (c <= k-1) l = x+1;\\n        else r = x-1;\\n    }\\n    \\n    return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint ub(int* a, int l, int r, long long x){\\n    int m;\\n    while (l <= r){\\n        m = (l+r)/2;\\n        if (a[m] <= x) l = m+1;\\n        else r = m-1;\\n    }\\n    \\n    return l;\\n}\\n\\nlong long kthSmallestProduct(int* a, int n, int* b, int m, long long k){\\n    long long r = (long long)(1e10), l = -r, x, c;\\n    \\n    int i;\\n    \\n    while (l <= r){\\n        x = (l+r)/2;\\n        \\n        c = 0;\\n        for (i = 0; i < n; i++){\\n            if (a[i] > 0) c += ub(b, 0, m-1, x/a[i] - (x<0 && x%a[i]));\\n            else if (a[i] < 0) c += m - ub(b, 0, m-1, x/a[i] - !(x<0 && x%a[i]));\\n            else if (x >= 0) c += m;\\n            \\n            if (c > k-1) break;\\n        }\\n        \\n        if (c <= k-1) l = x+1;\\n        else r = x-1;\\n    }\\n    \\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524594,
                "title": "c-binary-search-o-m-n-log-max-min-explained",
                "content": "1. Divide nums1 and nums2 into two parts by sign, with left half <= 0, right half > 0, denoted as l1, r1, l2, r2, so 4 combinations of subarrays of nums1 and nums2 in total, i.e. (l1, l2), (l1, r2), (r1, l2), (r1, r2)\\n2. Binary search the answer, which is guaranteed to be in the range of [Min, Max], where Min and Max are the minimum and maximum product. So initialize the search range as [left = Min, right = Max], for each mid = (left + right) >> 1, count how many products <= mid in the 4 combinations / matrices above. And reverse the subarrays to make the matrices sorted when necessary. \\n3. If the number of products <= mid is exactly k, return the Max product <= mid.\\n\\nNote: \\n1. For subarrays a[0, 1, ..., n - 1] and b[0, 1 ..., m - 1], their products can be represented as a matrix c[x][y] = a[x] * b[y] (We don\\'t really represent it because that would be O(nm) complexity). And for the matrix to be sorted: we actually mean every row and column are sorted ascendingly.\\n2. To find how many elements in a sorted matrix <= mid, please refer https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\n\\n\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    // refer: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\n    inline ll countInMatrix(vector<ll>& a, vector<ll>& b, ll mid, ll& Max) {\\n        ll n = a.size(), m = b.size();\\n        // matrix c[x][y] := a[x] * b[y]\\n        ll x = n - 1, y = 0;\\n        ll cnt = 0;\\n        \\n        while (x >= 0 && y < m) {\\n            if (a[x] * b[y] <= mid) {\\n                Max = max(Max, a[x] * b[y]);\\n                cnt += x + 1;\\n                y++;\\n            }\\n            else {\\n                x--;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n     \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        // divide into four combinations by positive / negative, represented in 4 sorted matrices\\n        // binary search by value\\n        // suppose mid = (left + right) >> 1; count how many elements <= mid in those 4 matrices\\n        \\n        ll n1 = nums1.size(), n2 = nums2.size();\\n        ll p1, p2;\\n        for (ll i = 0; i <= n1; ++i) {\\n            if (i == n1 || nums1[i] > 0) {\\n                p1 = i;\\n                break;\\n            }\\n        }\\n        for (ll i = 0; i <= n2; ++i) {\\n            if (i == n2 || nums2[i] > 0) {\\n                p2 = i;\\n                break;\\n            }\\n        }\\n        \\n        vector<ll> l1(nums1.begin(), nums1.begin() + p1);\\n        vector<ll> r1(nums1.begin() + p1, nums1.end());\\n        vector<ll> l2(nums2.begin(), nums2.begin() + p2);\\n        vector<ll> r2(nums2.begin() + p2, nums2.end());\\n        \\n        vector<ll> l1r(l1); // l1 reverse\\n        vector<ll> r1r(r1);\\n        vector<ll> l2r(l2);\\n        vector<ll> r2r(r2);\\n        reverse(l1r.begin(), l1r.end());\\n        reverse(r1r.begin(), r1r.end());\\n        reverse(l2r.begin(), l2r.end());\\n        reverse(r2r.begin(), r2r.end());\\n        \\n        ll left = LLONG_MAX, right = LLONG_MIN;\\n        vector<ll> t1 = {0, p1 - 1, p1, n1 - 1};\\n        vector<ll> t2 = {0, p2 - 1, p2, n2 - 1};\\n        for (ll i = 0; i < 4; ++i) {\\n            if (t1[i] < 0 || t1[i] >= n1) continue;\\n            for (ll j = 0; j < 4; ++j) {\\n                if (t2[j] < 0 || t2[j] >= n2) continue;\\n                left = min(left, (ll)nums1[t1[i]] * nums2[t2[j]]);\\n                right = max(right, (ll)nums1[t1[i]] * nums2[t2[j]]);\\n            }\\n        }\\n        \\n        while (left <= right) {\\n            ll mid = (left + right) >> 1;\\n            \\n            ll cur = 0;\\n            ll Max = LLONG_MIN;\\n            cur += countInMatrix(l1, r2r, mid, Max);\\n            cur += countInMatrix(l1r, l2r, mid, Max);\\n            cur += countInMatrix(r1r, l2, mid, Max);\\n            cur += countInMatrix(r1, r2, mid, Max);\\n            \\n            if (cur == k) return Max;\\n            else if (cur > k) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    // refer: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\n    inline ll countInMatrix(vector<ll>& a, vector<ll>& b, ll mid, ll& Max) {\\n        ll n = a.size(), m = b.size();\\n        // matrix c[x][y] := a[x] * b[y]\\n        ll x = n - 1, y = 0;\\n        ll cnt = 0;\\n        \\n        while (x >= 0 && y < m) {\\n            if (a[x] * b[y] <= mid) {\\n                Max = max(Max, a[x] * b[y]);\\n                cnt += x + 1;\\n                y++;\\n            }\\n            else {\\n                x--;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n     \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        // divide into four combinations by positive / negative, represented in 4 sorted matrices\\n        // binary search by value\\n        // suppose mid = (left + right) >> 1; count how many elements <= mid in those 4 matrices\\n        \\n        ll n1 = nums1.size(), n2 = nums2.size();\\n        ll p1, p2;\\n        for (ll i = 0; i <= n1; ++i) {\\n            if (i == n1 || nums1[i] > 0) {\\n                p1 = i;\\n                break;\\n            }\\n        }\\n        for (ll i = 0; i <= n2; ++i) {\\n            if (i == n2 || nums2[i] > 0) {\\n                p2 = i;\\n                break;\\n            }\\n        }\\n        \\n        vector<ll> l1(nums1.begin(), nums1.begin() + p1);\\n        vector<ll> r1(nums1.begin() + p1, nums1.end());\\n        vector<ll> l2(nums2.begin(), nums2.begin() + p2);\\n        vector<ll> r2(nums2.begin() + p2, nums2.end());\\n        \\n        vector<ll> l1r(l1); // l1 reverse\\n        vector<ll> r1r(r1);\\n        vector<ll> l2r(l2);\\n        vector<ll> r2r(r2);\\n        reverse(l1r.begin(), l1r.end());\\n        reverse(r1r.begin(), r1r.end());\\n        reverse(l2r.begin(), l2r.end());\\n        reverse(r2r.begin(), r2r.end());\\n        \\n        ll left = LLONG_MAX, right = LLONG_MIN;\\n        vector<ll> t1 = {0, p1 - 1, p1, n1 - 1};\\n        vector<ll> t2 = {0, p2 - 1, p2, n2 - 1};\\n        for (ll i = 0; i < 4; ++i) {\\n            if (t1[i] < 0 || t1[i] >= n1) continue;\\n            for (ll j = 0; j < 4; ++j) {\\n                if (t2[j] < 0 || t2[j] >= n2) continue;\\n                left = min(left, (ll)nums1[t1[i]] * nums2[t2[j]]);\\n                right = max(right, (ll)nums1[t1[i]] * nums2[t2[j]]);\\n            }\\n        }\\n        \\n        while (left <= right) {\\n            ll mid = (left + right) >> 1;\\n            \\n            ll cur = 0;\\n            ll Max = LLONG_MIN;\\n            cur += countInMatrix(l1, r2r, mid, Max);\\n            cur += countInMatrix(l1r, l2r, mid, Max);\\n            cur += countInMatrix(r1r, l2, mid, Max);\\n            cur += countInMatrix(r1, r2, mid, Max);\\n            \\n            if (cur == k) return Max;\\n            else if (cur > k) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642335,
                "title": "c-binary-search-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(long long midval,vector<int>& nums1, vector<int>& nums2, long long k){\\n        long long cnt=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long val=nums1[i];\\n\\t\\t\\tif(val==0 and midval>=0)\\n                cnt+=nums2.size();\\n            \\n            else if(val>0)\\n                cnt+=findmaxIndex(nums2,val,midval);\\n            \\n            else if(val<0)\\n                cnt+=findminIndex(nums2,val,midval);\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    int findmaxIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  -1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return res+1;\\n    }\\n    \\n    int findminIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  r+1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return nums2.size()-res;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long l=-1e10,r=1e10,res=-1;\\n        while(l<=r){\\n            long long mid = (l+r)/2;\\n            if(check(mid,nums1,nums2,k)) {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long midval,vector<int>& nums1, vector<int>& nums2, long long k){\\n        long long cnt=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long val=nums1[i];\\n\\t\\t\\tif(val==0 and midval>=0)\\n                cnt+=nums2.size();\\n            \\n            else if(val>0)\\n                cnt+=findmaxIndex(nums2,val,midval);\\n            \\n            else if(val<0)\\n                cnt+=findminIndex(nums2,val,midval);\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    int findmaxIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  -1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return res+1;\\n    }\\n    \\n    int findminIndex(vector<int>&nums2 , long long  val , long long midval)\\n    {\\n        int l = 0  , r = nums2.size()-1 , res=  r+1;\\n        while(l<=r)\\n        {\\n            long long mid = (l+r)/2;\\n            if(val*nums2[mid]<=midval)\\n            {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return nums2.size()-res;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long l=-1e10,r=1e10,res=-1;\\n        while(l<=r){\\n            long long mid = (l+r)/2;\\n            if(check(mid,nums1,nums2,k)) {\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372366,
                "title": "c-simple-binary-search-solution-with-comments-easy-to-understand",
                "content": "We can\\'t apply priority queue over here just because of the constraints, that would give us TLE.\\nBut we can apply *Binary Search* over here.\\n\\n**Approach**\\nWe can apply the Binary search over the range [-1e10,1e10] (minimum product of the pairs,maximum product of the pairs).We can count the number of pair products and decrease our search space accordingly\\n\\nNow the question arises, how can we count the number of pair products without getting tle?\\nThe answer is, we can apply Binary search here as well.\\n\\n**Keep this in mind -** There can be negative elements also and when we consider the negative element the logic got reversed.\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    long long countSmallerProducts(vector<int>& nums1, vector<int>& nums2, long long product){\\n        long long count=0;\\n        for(int num:nums1){\\n            if(num>=0){\\n                int l=0,h=nums2.size()-1,temp=-1;\\n                while(l<=h){\\n                    int mid=l+(h-l)/2;\\n                    if((long long)num*nums2[mid] <= product){\\n                        temp=mid;\\n                        l=mid+1;\\n                    }else h=mid-1;\\n                }\\n                count+=temp+1;\\n            }else{\\n                int l=0,h=nums2.size()-1,temp=nums2.size();\\n                while(l<=h){\\n                    int mid=l+(h-l)/2;\\n                    if((long long)num*nums2[mid] <= product){\\n                        temp=mid;\\n                        h=mid-1;\\n                    }else l=mid+1;\\n                }\\n                count+=(nums2.size()-temp);\\n            }\\n        }\\n        return count;\\n    }\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long s=-1e10,e=1e10,ans=0;\\n        \\n        \\n        while(s<=e){\\n            long long mid = (s+e)/2;\\n            if(countSmallerProducts(nums1,nums2,mid)>=k){\\n                ans=mid;\\n                e=mid-1;\\n            }else s=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countSmallerProducts(vector<int>& nums1, vector<int>& nums2, long long product){\\n        long long count=0;\\n        for(int num:nums1){\\n            if(num>=0){\\n                int l=0,h=nums2.size()-1,temp=-1;\\n                while(l<=h){\\n                    int mid=l+(h-l)/2;\\n                    if((long long)num*nums2[mid] <= product){\\n                        temp=mid;\\n                        l=mid+1;\\n                    }else h=mid-1;\\n                }\\n                count+=temp+1;\\n            }else{\\n                int l=0,h=nums2.size()-1,temp=nums2.size();\\n                while(l<=h){\\n                    int mid=l+(h-l)/2;\\n                    if((long long)num*nums2[mid] <= product){\\n                        temp=mid;\\n                        h=mid-1;\\n                    }else l=mid+1;\\n                }\\n                count+=(nums2.size()-temp);\\n            }\\n        }\\n        return count;\\n    }\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long s=-1e10,e=1e10,ans=0;\\n        \\n        \\n        while(s<=e){\\n            long long mid = (s+e)/2;\\n            if(countSmallerProducts(nums1,nums2,mid)>=k){\\n                ans=mid;\\n                e=mid-1;\\n            }else s=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163920,
                "title": "python-3-ac-solution-with-detailed-math-derivation",
                "content": "```\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        \"\"\"\\n        Binary Search\\n        find first number that makes countSmallerOrEqual(number) >= k\\n        return number\\n        \"\"\"\\n        boundary = [nums1[0]*nums2[0], nums1[0] * nums2[-1], nums1[-1] * nums2[0], nums1[-1] * nums2[-1]]\\n        low, high = min(boundary), max(boundary)\\n        while low + 1 < high:\\n            mid = low + (high - low) // 2\\n            if self.countSmallerOrEqual(mid, nums1, nums2) >= k:\\n                high = mid\\n            else:\\n                low = mid + 1\\n        if self.countSmallerOrEqual(low, nums1, nums2) >= k:\\n            return low\\n        else:\\n            return high\\n    \\n    def countSmallerOrEqual(self, m, nums1, nums2):\\n        \"\"\"\\n        Two pointers solution\\n        use monotonic property of both nums1 and nums2\\n        return the number of products nums1[i] * nums2[j] <= m\\n        l1, l2 = len(nums1), len(nums2)\\n           \\n        1) if m >= 0, \\n        ***Given nums1[i] < 0***\\n        find j such that nums2[j] >= m/nums1[i]\\n        i increases - > nums1[i] increases -> m/nums1[i] decreases -> index j decreases\\n        j monotonically moves left\\n        return j:l2 -> l2 - j + 1\\n        *** Given nums1[i] = 0\\n        return l2\\n        ***Given nums1[i] > 0***\\n        find j such that nums2[j] <= m/nums1[i]\\n        i increases - > nums1[i] increases -> m/nums1[i] decreases -> index j decreases\\n        j monotonically moves left\\n        return 0:j -> j + 1\\n\\n        2) if m < 0, \\n        ***Given nums1[i] < 0***\\n        find j such that nums2[j] >= m/nums1[i]\\n        i increases - > nums1[i] increases -> m/nums1[i] increases -> index j increases\\n        j monotonically moves right\\n        return j:l2 -> l2 - j + 1\\n        *** Given nums1[i] = 0\\n        return 0\\n        ***Given nums1[i] > 0***\\n        find j such that nums2[j] <= m/nums1[i]\\n        i increases - > nums1[i] increases -> m/nums1[i] increases -> index j increases\\n        j monotonically moves right\\n        return 0:j -> j + 1\\n        \\n        \"\"\"\\n        l1, l2 = len(nums1), len(nums2)\\n        ans = 0\\n        if m >= 0:\\n            j1, j2 = l2-1, l2-1\\n            for i in range(l1):\\n                if nums1[i] < 0:\\n                    while j1 >=0 and nums2[j1] >= m/nums1[i]:\\n                        j1 -= 1\\n                    ans += l2 - j1 - 1\\n                elif nums1[i] > 0:\\n                    while j2 >=0 and nums2[j2] > m/nums1[i]:\\n                        j2 -= 1\\n                    ans += j2 + 1\\n                else:\\n                    ans += l2\\n        else:\\n            j1, j2 = 0, 0\\n            for i in range(l1):\\n                if nums1[i] < 0:\\n                    while j1 < l2 and nums2[j1] < m/nums1[i]:\\n                        j1 += 1\\n                    ans += l2 - j1\\n                elif nums1[i] > 0:\\n                    while j2 < l2 and nums2[j2] <= m/nums1[i]:\\n                        j2 += 1\\n                    ans += j2\\n        return ans\\n```\\n                    \\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        \"\"\"\\n        Binary Search\\n        find first number that makes countSmallerOrEqual(number) >= k\\n        return number\\n        \"\"\"\\n        boundary = [nums1[0]*nums2[0], nums1[0] * nums2[-1], nums1[-1] * nums2[0], nums1[-1] * nums2[-1]]\\n        low, high = min(boundary), max(boundary)\\n        while low + 1 < high:\\n            mid = low + (high - low) // 2\\n            if self.countSmallerOrEqual(mid, nums1, nums2) >= k:\\n                high = mid\\n            else:\\n                low = mid + 1\\n        if self.countSmallerOrEqual(low, nums1, nums2) >= k:\\n            return low\\n        else:\\n            return high\\n    \\n    def countSmallerOrEqual(self, m, nums1, nums2):\\n        \"\"\"\\n        Two pointers solution\\n        use monotonic property of both nums1 and nums2\\n        return the number of products nums1[i] * nums2[j] <= m\\n        l1, l2 = len(nums1), len(nums2)\\n           \\n        1) if m >= 0, \\n        ***Given nums1[i] < 0***\\n        find j such that nums2[j] >= m/nums1[i]\\n        i increases - > nums1[i] increases -> m/nums1[i] decreases -> index j decreases\\n        j monotonically moves left\\n        return j:l2 -> l2 - j + 1\\n        *** Given nums1[i] = 0\\n        return l2\\n        ***Given nums1[i] > 0***\\n        find j such that nums2[j] <= m/nums1[i]\\n        i increases - > nums1[i] increases -> m/nums1[i] decreases -> index j decreases\\n        j monotonically moves left\\n        return 0:j -> j + 1\\n\\n        2) if m < 0, \\n        ***Given nums1[i] < 0***\\n        find j such that nums2[j] >= m/nums1[i]\\n        i increases - > nums1[i] increases -> m/nums1[i] increases -> index j increases\\n        j monotonically moves right\\n        return j:l2 -> l2 - j + 1\\n        *** Given nums1[i] = 0\\n        return 0\\n        ***Given nums1[i] > 0***\\n        find j such that nums2[j] <= m/nums1[i]\\n        i increases - > nums1[i] increases -> m/nums1[i] increases -> index j increases\\n        j monotonically moves right\\n        return 0:j -> j + 1\\n        \\n        \"\"\"\\n        l1, l2 = len(nums1), len(nums2)\\n        ans = 0\\n        if m >= 0:\\n            j1, j2 = l2-1, l2-1\\n            for i in range(l1):\\n                if nums1[i] < 0:\\n                    while j1 >=0 and nums2[j1] >= m/nums1[i]:\\n                        j1 -= 1\\n                    ans += l2 - j1 - 1\\n                elif nums1[i] > 0:\\n                    while j2 >=0 and nums2[j2] > m/nums1[i]:\\n                        j2 -= 1\\n                    ans += j2 + 1\\n                else:\\n                    ans += l2\\n        else:\\n            j1, j2 = 0, 0\\n            for i in range(l1):\\n                if nums1[i] < 0:\\n                    while j1 < l2 and nums2[j1] < m/nums1[i]:\\n                        j1 += 1\\n                    ans += l2 - j1\\n                elif nums1[i] > 0:\\n                    while j2 < l2 and nums2[j2] <= m/nums1[i]:\\n                        j2 += 1\\n                    ans += j2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721569,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    using ll =long long;\\n    ll find(vector<int>&nums1,vector<int>&nums2,ll product)\\n    {\\n        ll count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long val=nums1[i];\\n             if(val>=0)\\n            {\\n                ll l=0;\\n                ll r=m-1;\\n                ll ans=-1;\\n                while(l<=r)\\n                {\\n                    ll mid=(l+r)/2;\\n                    if((val*nums2[mid])<=product)\\n                    {\\n                        ans=mid;\\n                        l=mid+1;\\n                    }\\n                    else\\n                    {\\n                        r=mid-1;\\n                    }\\n                }\\n                count+=ans+1;\\n            }\\n            else\\n            {\\n                ll l=0;\\n                ll r=m-1;\\n                ll ans=m;\\n                while(l<=r)\\n                {\\n                    ll mid=(l+r)/2;\\n                    if((val*nums2[mid])<=product)\\n                    {\\n                        ans=mid;\\n                        r=mid-1;\\n                    }\\n                    else\\n                    {\\n                        l=mid+1;\\n                    }\\n                }\\n                count+=m-ans;\\n            }\\n        }\\n        return count;\\n    }\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) \\n    {\\n        n=nums1.size();\\n        m=nums2.size();\\n        ll f1=nums1[0];\\n        ll f2=nums1[n-1];\\n        ll f3=nums2[0];\\n        ll f4=nums2[m-1];\\n        ll l=min({f1*f2,f1*f3,f1*f4,f2*f3,f2*f4,f3*f4});\\n        ll r=max({f1*f2,f1*f3,f1*f4,f2*f3,f2*f4,f3*f4});\\n        ll ans=-1;\\n        while(l<=r)\\n        {\\n            ll mid=(l+r)/2;\\n            if(find(nums1,nums2,mid)>=k)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    using ll =long long;\\n    ll find(vector<int>&nums1,vector<int>&nums2,ll product)\\n    {\\n        ll count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long val=nums1[i];\\n             if(val>=0)\\n            {\\n                ll l=0;\\n                ll r=m-1;\\n                ll ans=-1;\\n                while(l<=r)\\n                {\\n                    ll mid=(l+r)/2;\\n                    if((val*nums2[mid])<=product)\\n                    {\\n                        ans=mid;\\n                        l=mid+1;\\n                    }\\n                    else\\n                    {\\n                        r=mid-1;\\n                    }\\n                }\\n                count+=ans+1;\\n            }\\n            else\\n            {\\n                ll l=0;\\n                ll r=m-1;\\n                ll ans=m;\\n                while(l<=r)\\n                {\\n                    ll mid=(l+r)/2;\\n                    if((val*nums2[mid])<=product)\\n                    {\\n                        ans=mid;\\n                        r=mid-1;\\n                    }\\n                    else\\n                    {\\n                        l=mid+1;\\n                    }\\n                }\\n                count+=m-ans;\\n            }\\n        }\\n        return count;\\n    }\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) \\n    {\\n        n=nums1.size();\\n        m=nums2.size();\\n        ll f1=nums1[0];\\n        ll f2=nums1[n-1];\\n        ll f3=nums2[0];\\n        ll f4=nums2[m-1];\\n        ll l=min({f1*f2,f1*f3,f1*f4,f2*f3,f2*f4,f3*f4});\\n        ll r=max({f1*f2,f1*f3,f1*f4,f2*f3,f2*f4,f3*f4});\\n        ll ans=-1;\\n        while(l<=r)\\n        {\\n            ll mid=(l+r)/2;\\n            if(find(nums1,nums2,mid)>=k)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531974,
                "title": "python-variation-of-finding-kth-value-in-2d-ascending-array",
                "content": "1) We split each sorted arrays into positive and negative parts pos1,neg1, pos2, neg2. \\n2) We can compute how many multiplied numbers are positive, negative or zeros. Return 0 if k falls between.\\n3) If k<=number of negatives, we need to check multiplied numbers from (pos1, neg2) and (pos2, neg1). Else we need to check multiplied numbers from (pos1,pos2) and (neg1, neg2). \\n4) If k<= number of negatives, just make negative parts positive and reverse the arrays neg1 and neg2. It does not matter, we can make the result negative. But in this case, kth smallest number would be actually the (number_of_negatives-k+1)th smallest number when we reverse the negaive parts with their absoulte values. \\n5) Now the problem is same as finding kth smallest number in a two dimensional array where numbers in each row/column is increasing since the 2D matrix can be thought of as `Val[row][col]= pair1[row]*pair2[col]`. We can compute the rank of an arbitrary value in each pairs in `O(m+n)` time. We just need to compute rank from the two pairs `O(logV)` time. \\n```\\nimport bisect\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        n1,n2 = len(nums1), len(nums2)\\n        l1, r1 = bisect.bisect_left(nums1, 0),bisect.bisect_right(nums1, 0)\\n        l2, r2 = bisect.bisect_left(nums2, 0),bisect.bisect_right(nums2, 0)\\n        num_of_negatives = l1*(n2-r2)+ l2*(n1-r1)\\n        num_of_positives = l1*l2+ (n1-r1)*(n2-r2)\\n        num_of_zeros = (r1-l1)*n2 + (r2-l2)*n1- (r1-l1)*(r2-l2)\\n        nums1_n, nums1_p = nums1[:l1], nums1[r1:]\\n        nums2_n, nums2_p = nums2[:l2], nums2[r2:]\\n        nums1_n, nums2_n = [-d for d in nums1_n], [-d for d in nums2_n]\\n        nums1_n.reverse(), nums2_n.reverse()\\n        if k<= num_of_negatives:\\n            return -self.compute(nums1_n, nums2_p, nums2_n, nums1_p, num_of_negatives-k+1)\\n        elif k<=num_of_negatives+num_of_zeros:\\n            return 0\\n        else:\\n            return self.compute(nums1_n, nums2_n, nums1_p, nums2_p, k-num_of_negatives-num_of_zeros)\\n    \\n    def compute(self, pair_1r,pair_1c, pair_2r, pair_2c, k):\\n        start,end = float(\\'inf\\'), float(\\'-inf\\')\\n        if pair_1r and pair_1c:\\n            start = min(pair_1r[0]*pair_1c[0], start)\\n            end = max(pair_1r[-1]*pair_1c[-1], end)\\n        if pair_2r and pair_2c:\\n            start = min(pair_2r[0]*pair_2c[0], start)\\n            end = max(pair_2r[-1]*pair_2c[-1], end)\\n        while start<end:\\n            mid = (start+end)//2\\n            k1, low1, high1 = self.get_rank(pair_1r,pair_1c, mid)\\n            k2, low2, high2 = self.get_rank(pair_2r,pair_2c, mid)\\n            if k1+k2==k:\\n                return max(low1,low2)\\n            elif k1+k2<k:\\n                start = min(high1, high2)\\n            else:\\n                end = max(low1, low2)\\n        return start\\n    def get_rank(self,pair_r, pair_c,mid):\\n        m, n = len(pair_r), len(pair_c)\\n        if m==0 or n==0:\\n            return 0, float(\\'-inf\\'), float(\\'inf\\')\\n        row, col = m-1, 0\\n        low, high = float(\\'-inf\\'), float(\\'inf\\')\\n        ans = 0\\n        while row>=0:\\n            while col<n and pair_r[row]*pair_c[col]<=mid:\\n                low = max(low, pair_r[row]*pair_c[col])\\n                col +=1\\n            if col<n: \\n                high = min(high, pair_r[row]*pair_c[col])\\n            ans += col\\n            row -= 1\\n        return ans, low, high\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        n1,n2 = len(nums1), len(nums2)\\n        l1, r1 = bisect.bisect_left(nums1, 0),bisect.bisect_right(nums1, 0)\\n        l2, r2 = bisect.bisect_left(nums2, 0),bisect.bisect_right(nums2, 0)\\n        num_of_negatives = l1*(n2-r2)+ l2*(n1-r1)\\n        num_of_positives = l1*l2+ (n1-r1)*(n2-r2)\\n        num_of_zeros = (r1-l1)*n2 + (r2-l2)*n1- (r1-l1)*(r2-l2)\\n        nums1_n, nums1_p = nums1[:l1], nums1[r1:]\\n        nums2_n, nums2_p = nums2[:l2], nums2[r2:]\\n        nums1_n, nums2_n = [-d for d in nums1_n], [-d for d in nums2_n]\\n        nums1_n.reverse(), nums2_n.reverse()\\n        if k<= num_of_negatives:\\n            return -self.compute(nums1_n, nums2_p, nums2_n, nums1_p, num_of_negatives-k+1)\\n        elif k<=num_of_negatives+num_of_zeros:\\n            return 0\\n        else:\\n            return self.compute(nums1_n, nums2_n, nums1_p, nums2_p, k-num_of_negatives-num_of_zeros)\\n    \\n    def compute(self, pair_1r,pair_1c, pair_2r, pair_2c, k):\\n        start,end = float(\\'inf\\'), float(\\'-inf\\')\\n        if pair_1r and pair_1c:\\n            start = min(pair_1r[0]*pair_1c[0], start)\\n            end = max(pair_1r[-1]*pair_1c[-1], end)\\n        if pair_2r and pair_2c:\\n            start = min(pair_2r[0]*pair_2c[0], start)\\n            end = max(pair_2r[-1]*pair_2c[-1], end)\\n        while start<end:\\n            mid = (start+end)//2\\n            k1, low1, high1 = self.get_rank(pair_1r,pair_1c, mid)\\n            k2, low2, high2 = self.get_rank(pair_2r,pair_2c, mid)\\n            if k1+k2==k:\\n                return max(low1,low2)\\n            elif k1+k2<k:\\n                start = min(high1, high2)\\n            else:\\n                end = max(low1, low2)\\n        return start\\n    def get_rank(self,pair_r, pair_c,mid):\\n        m, n = len(pair_r), len(pair_c)\\n        if m==0 or n==0:\\n            return 0, float(\\'-inf\\'), float(\\'inf\\')\\n        row, col = m-1, 0\\n        low, high = float(\\'-inf\\'), float(\\'inf\\')\\n        ans = 0\\n        while row>=0:\\n            while col<n and pair_r[row]*pair_c[col]<=mid:\\n                low = max(low, pair_r[row]*pair_c[col])\\n                col +=1\\n            if col<n: \\n                high = min(high, pair_r[row]*pair_c[col])\\n            ans += col\\n            row -= 1\\n        return ans, low, high\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524870,
                "title": "my-notes",
                "content": "My notes on this Q. You are welcome if it helped you otherwise let me know how I can improve.\\n\\nI know this is binary search but the implementation details killed me.\\n\\nThe first puzzle is what should the check function return. I see most solution is to return true if number of x*y <= answer is >= k. \\n\\nwhy both has =? Can we return true if number of x*y < answer is > k and still make it work? I still don\\'t know the answer.\\n\\nLet me explain why return true **if number of x*y <= answer is >= k** works with my binary search template:\\n\\n```\\nint start = 0, end = max_val;\\nwhile (start + 1 < end) {\\n\\tint mid = (start + end)/2;\\n\\t\\n\\tif (number of x*y <= mid is >= k) // we can tell the ans is in [start, mid]\\n\\t\\tend = mid;\\n    else\\n\\t   start = mid;\\n}\\n\\nif (number of x*y <= start is >= k) // if start is satsified then end will also return true, so return start.\\n\\treturn start;\\nelse\\n\\treturn end;\\n```\\nThis is when I feel my binary search template is not very good to solve this kind of questions, because I am not confident what check() should return.\\n\\nOk, the next step is to work on the check function. My C++ nlogn solution will TLE everytime, the complexity is 5*10^4 * log(5*10^4) * log(10^10) = 5 *10000 * 16 * 34 = 27,200,000. I will still mention as I keep getting WA during the contest.\\n```\\nans = 30, x = 4 then we are looking for y <=7\\nans = 30, x = -4 then we are looking for y >= -7\\nans = -30, x = 4 then we are looking for y <= -8  \\nans = -30, x = -4 then we are looking for y >= 8\\n```\\n \\nThe last two cases screwed me over. Below is the binary search check() function that will TLE.\\n```\\nclass Solution {\\npublic:\\n    // <= target\\n    bool check(long long target, vector<int> & nums1, vector<int> & nums2, long long k) {\\n        long long cnt = 0;\\n        for (int i = 0; i < nums1.size(); i++) {\\n            if (nums1[i] == 0) {\\n                if (target >= 0) {\\n                    cnt += nums2.size();\\n                }\\n            } else {\\n                if (nums1[i] < 0) {\\n                    // we need to patch the value by 1 \\n                    long long x = target / nums1[i];\\n                    if (target % nums1[i] != 0) {\\n                        if (target < 0)\\n                            x++;\\n                    }\\n                    auto it = lower_bound(nums2.begin(), nums2.end(), x);\\n                    cnt += nums2.size() - (it - nums2.begin());\\n                } else {\\n                    // we need to patch the value by 1 \\n                    long long x = target / nums1[i];\\n                    if (target % nums1[i] != 0) {\\n                        if (target < 0)\\n                            x--;\\n                    }\\n                    auto it = upper_bound(nums2.begin(), nums2.end(), x);\\n\\n                    cnt += it - nums2.begin();\\n                }\\n            }\\n        }\\n\\n        return cnt >= k;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long start = -1e10, end = 1e10;\\n        while (start + 1 < end) {\\n            long long mid = start + end >> 1;\\n            if (check(mid, nums1, nums2, k)) {\\n                end = mid;\\n            } else {\\n                start = mid;\\n            }\\n        }\\n        \\n        if (check(start, nums1, nums2, k))\\n            return start;\\n        \\n        return end;\\n    }\\n}; \\n```\\n\\nSo we need to do better and we can use two pointers to make it O(m+n). It is much easier if all numbers are positive. Otherwise we need to break it down into 4 scenarios to make sure monotonicity\\uFF08\\u5355\\u8C03\\u6027\\uFF09of x*y.\\n\\nThe idea is to separate the two array into two negatives and two positive(include 0) and count all 4 combinations.\\n\\n```\\ntypedef long long LL;\\n\\nclass Solution {\\npublic:\\n    vector<LL> neg1, neg2, pos1, pos2;\\n    \\n    // <= target\\n    bool check(long long target, long long k) {\\n        long long cnt = 0;\\n        \\n        if (target >= 0) {\\n            cnt += neg1.size() * pos2.size();\\n            cnt += neg2.size() * pos1.size();\\n            // neg1 and neg2\\n            LL i = 0, j = neg2.size()-1;\\n            for (; i < neg1.size(); i++) {\\n                while (j >= 0 && neg1[i] * neg2[j] <= target) {\\n                    j--;\\n                }\\n                \\n                cnt += (LL)neg2.size() - j - 1;\\n            }\\n            \\n            // pos1 and pos2\\n            i = 0, j = pos2.size()-1;\\n            for (; i < pos1.size(); i++) {\\n                while (j >= 0 && pos1[i] * pos2[j] > target) {\\n                    j--;\\n                }\\n                \\n                cnt += j + 1;\\n            }\\n           \\n        } else {\\n            // neg1 and pos2 \\n            LL i = 0, j = 0;\\n            for (; i < neg1.size(); i++) {\\n                while (j < pos2.size() && neg1[i] * pos2[j] > target) {\\n                    j++;\\n                }\\n                \\n                cnt += (LL)pos2.size() - j;\\n            }\\n            \\n            // pos1 and neg2\\n            i = 0, j = 0;\\n            for (; i < neg2.size(); i++) {\\n                while (j < pos1.size() && neg2[i] * pos1[j] > target) {\\n                    j++;\\n                }\\n                \\n                cnt += (LL)pos1.size() - j;\\n            }\\n            \\n        }\\n        \\n        return cnt >= k;\\n    }\\n    \\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long start = -1e10, end = 1e10;\\n        \\n        for (int num : nums1) {\\n            if (num < 0)\\n                neg1.push_back(num);\\n            else\\n                pos1.push_back(num);\\n        }\\n        \\n        for (int num : nums2) {\\n            if (num < 0)\\n                neg2.push_back(num);\\n            else\\n                pos2.push_back(num);\\n        }\\n        \\n      \\n        while (start + 1 < end) {\\n            long long mid = start + end >> 1;\\n            if (check(mid, k)) {\\n                end = mid;\\n            } else {\\n                start = mid;\\n            }\\n        }\\n        \\n        if (check(start, k))\\n            return start;\\n        \\n        return end;\\n    }\\n}; \\n```\\n",
                "solutionTags": [],
                "code": "```\\nint start = 0, end = max_val;\\nwhile (start + 1 < end) {\\n\\tint mid = (start + end)/2;\\n\\t\\n\\tif (number of x*y <= mid is >= k) // we can tell the ans is in [start, mid]\\n\\t\\tend = mid;\\n    else\\n\\t   start = mid;\\n}\\n\\nif (number of x*y <= start is >= k) // if start is satsified then end will also return true, so return start.\\n\\treturn start;\\nelse\\n\\treturn end;\\n```\n```\\nans = 30, x = 4 then we are looking for y <=7\\nans = 30, x = -4 then we are looking for y >= -7\\nans = -30, x = 4 then we are looking for y <= -8  \\nans = -30, x = -4 then we are looking for y >= 8\\n```\n```\\nclass Solution {\\npublic:\\n    // <= target\\n    bool check(long long target, vector<int> & nums1, vector<int> & nums2, long long k) {\\n        long long cnt = 0;\\n        for (int i = 0; i < nums1.size(); i++) {\\n            if (nums1[i] == 0) {\\n                if (target >= 0) {\\n                    cnt += nums2.size();\\n                }\\n            } else {\\n                if (nums1[i] < 0) {\\n                    // we need to patch the value by 1 \\n                    long long x = target / nums1[i];\\n                    if (target % nums1[i] != 0) {\\n                        if (target < 0)\\n                            x++;\\n                    }\\n                    auto it = lower_bound(nums2.begin(), nums2.end(), x);\\n                    cnt += nums2.size() - (it - nums2.begin());\\n                } else {\\n                    // we need to patch the value by 1 \\n                    long long x = target / nums1[i];\\n                    if (target % nums1[i] != 0) {\\n                        if (target < 0)\\n                            x--;\\n                    }\\n                    auto it = upper_bound(nums2.begin(), nums2.end(), x);\\n\\n                    cnt += it - nums2.begin();\\n                }\\n            }\\n        }\\n\\n        return cnt >= k;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long start = -1e10, end = 1e10;\\n        while (start + 1 < end) {\\n            long long mid = start + end >> 1;\\n            if (check(mid, nums1, nums2, k)) {\\n                end = mid;\\n            } else {\\n                start = mid;\\n            }\\n        }\\n        \\n        if (check(start, nums1, nums2, k))\\n            return start;\\n        \\n        return end;\\n    }\\n}; \\n```\n```\\ntypedef long long LL;\\n\\nclass Solution {\\npublic:\\n    vector<LL> neg1, neg2, pos1, pos2;\\n    \\n    // <= target\\n    bool check(long long target, long long k) {\\n        long long cnt = 0;\\n        \\n        if (target >= 0) {\\n            cnt += neg1.size() * pos2.size();\\n            cnt += neg2.size() * pos1.size();\\n            // neg1 and neg2\\n            LL i = 0, j = neg2.size()-1;\\n            for (; i < neg1.size(); i++) {\\n                while (j >= 0 && neg1[i] * neg2[j] <= target) {\\n                    j--;\\n                }\\n                \\n                cnt += (LL)neg2.size() - j - 1;\\n            }\\n            \\n            // pos1 and pos2\\n            i = 0, j = pos2.size()-1;\\n            for (; i < pos1.size(); i++) {\\n                while (j >= 0 && pos1[i] * pos2[j] > target) {\\n                    j--;\\n                }\\n                \\n                cnt += j + 1;\\n            }\\n           \\n        } else {\\n            // neg1 and pos2 \\n            LL i = 0, j = 0;\\n            for (; i < neg1.size(); i++) {\\n                while (j < pos2.size() && neg1[i] * pos2[j] > target) {\\n                    j++;\\n                }\\n                \\n                cnt += (LL)pos2.size() - j;\\n            }\\n            \\n            // pos1 and neg2\\n            i = 0, j = 0;\\n            for (; i < neg2.size(); i++) {\\n                while (j < pos1.size() && neg2[i] * pos1[j] > target) {\\n                    j++;\\n                }\\n                \\n                cnt += (LL)pos1.size() - j;\\n            }\\n            \\n        }\\n        \\n        return cnt >= k;\\n    }\\n    \\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long start = -1e10, end = 1e10;\\n        \\n        for (int num : nums1) {\\n            if (num < 0)\\n                neg1.push_back(num);\\n            else\\n                pos1.push_back(num);\\n        }\\n        \\n        for (int num : nums2) {\\n            if (num < 0)\\n                neg2.push_back(num);\\n            else\\n                pos2.push_back(num);\\n        }\\n        \\n      \\n        while (start + 1 < end) {\\n            long long mid = start + end >> 1;\\n            if (check(mid, k)) {\\n                end = mid;\\n            } else {\\n                start = mid;\\n            }\\n        }\\n        \\n        if (check(start, k))\\n            return start;\\n        \\n        return end;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524251,
                "title": "kotlin-double-binary-search",
                "content": "1. binary search answer\\n2. For each answer p, find out the number (product >= p). (iterate first array and binary search the second array)\\n\\n```\\n/**\\n * Double binary search\\n */\\nfun kthSmallestProduct(nums1: IntArray, nums2: IntArray, k: Long): Long {\\n\\n    val orderNums2 = nums2.toList()\\n    val reversedNums2 = nums2.reversed()\\n    fun doGetLessEqual(a: Long, p: Long, nums: List<Int>): Long {\\n        if (a * nums.first() > p) return 0\\n\\n        var l = 0\\n        var r = nums.size\\n        while (l < r) {\\n            val m = (l + r) / 2\\n            if (a * nums[m] > p) r = m\\n            else l = m + 1\\n        }\\n        return 1L * l\\n    }\\n\\n    fun getLessEqual(a: Long, p: Long): Long {\\n        if (a > 0) return doGetLessEqual(a, p, orderNums2)\\n        if (a < 0) return doGetLessEqual(a, p, reversedNums2)\\n\\n        return if (p >= 0) 1L * nums2.size else 0\\n    }\\n\\n\\n    // min and max will be in this list.\\n    val limits = listOf(\\n        1L * nums1[0] * nums2[0],\\n        1L * nums1[0] * nums2.last(),\\n        1L * nums1.last() * nums2[0],\\n        1L * nums1.last() * nums2.last()\\n    )\\n    var l = limits.min()!!\\n    var r = limits.max()!!\\n    while (l < r) {\\n        val m = l + (r - l) / 2\\n\\n        var lessEqualCnt = nums1.map { getLessEqual(1L * it, m) }.sum()\\n        if (lessEqualCnt >= k) r = m\\n        else l = m + 1\\n    }\\n\\n    return l\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Double binary search\\n */\\nfun kthSmallestProduct(nums1: IntArray, nums2: IntArray, k: Long): Long {\\n\\n    val orderNums2 = nums2.toList()\\n    val reversedNums2 = nums2.reversed()\\n    fun doGetLessEqual(a: Long, p: Long, nums: List<Int>): Long {\\n        if (a * nums.first() > p) return 0\\n\\n        var l = 0\\n        var r = nums.size\\n        while (l < r) {\\n            val m = (l + r) / 2\\n            if (a * nums[m] > p) r = m\\n            else l = m + 1\\n        }\\n        return 1L * l\\n    }\\n\\n    fun getLessEqual(a: Long, p: Long): Long {\\n        if (a > 0) return doGetLessEqual(a, p, orderNums2)\\n        if (a < 0) return doGetLessEqual(a, p, reversedNums2)\\n\\n        return if (p >= 0) 1L * nums2.size else 0\\n    }\\n\\n\\n    // min and max will be in this list.\\n    val limits = listOf(\\n        1L * nums1[0] * nums2[0],\\n        1L * nums1[0] * nums2.last(),\\n        1L * nums1.last() * nums2[0],\\n        1L * nums1.last() * nums2.last()\\n    )\\n    var l = limits.min()!!\\n    var r = limits.max()!!\\n    while (l < r) {\\n        val m = l + (r - l) / 2\\n\\n        var lessEqualCnt = nums1.map { getLessEqual(1L * it, m) }.sum()\\n        if (lessEqualCnt >= k) r = m\\n        else l = m + 1\\n    }\\n\\n    return l\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524221,
                "title": "python-numpy",
                "content": "It\\'s kind of rare to see a use case for np.searchsorted but it makes the code fairly concise.\\n\\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        A = np.sort(nums1)\\n        B = np.sort(nums2)\\n        Aneg, Azero, Apos = A[A < 0], A[A == 0], A[A > 0]\\n\\n        def f(x):\\n            # Count number of a * b <= x, casing on the sign of a\\n            countZero = len(Azero) * len(B) if x >= 0 else 0\\n            countPos = np.searchsorted(B, x // Apos, side=\"right\").sum()\\n            countNeg = len(Aneg) * len(B) - np.searchsorted(B, (-x - 1) // (-Aneg), side=\"right\").sum()\\n            return countNeg + countZero + countPos\\n\\n        lo = -(10 ** 10)\\n        hi = 10 ** 10\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if f(mid) >= k:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return hi\\n```\\n\\nProblem https://atcoder.jp/contests/abc155/tasks/abc155_d is similar.",
                "solutionTags": [],
                "code": "```python\\nimport numpy as np\\n\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        A = np.sort(nums1)\\n        B = np.sort(nums2)\\n        Aneg, Azero, Apos = A[A < 0], A[A == 0], A[A > 0]\\n\\n        def f(x):\\n            # Count number of a * b <= x, casing on the sign of a\\n            countZero = len(Azero) * len(B) if x >= 0 else 0\\n            countPos = np.searchsorted(B, x // Apos, side=\"right\").sum()\\n            countNeg = len(Aneg) * len(B) - np.searchsorted(B, (-x - 1) // (-Aneg), side=\"right\").sum()\\n            return countNeg + countZero + countPos\\n\\n        lo = -(10 ** 10)\\n        hi = 10 ** 10\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if f(mid) >= k:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return hi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754394,
                "title": "java-solution-binary-search-approach-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nBinary Search Approach Used\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n     public long kthSmallestProduct(int[] nums1, int[] nums2, long k)\\n    {\\n        long si = -1000_000_0000l;\\n        long ei = 1000_000_0000l;\\n        long ans = 0;\\n        while(si <= ei)\\n        {\\n            long mid = si + (ei - si) / 2;\\n            long count = 0;\\n            if(countofProduct(nums1,nums2,mid) >= k)\\n            {\\n                ans = mid;\\n                ei = mid - 1;\\n            }\\n            else\\n            {\\n                si = mid + 1;\\n            }\\n\\n\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n\\n    private static long countofProduct(int[] nums1, int[] nums2, long prod)\\n    {\\n        long res = 0;\\n        for(int e1 : nums1)\\n        {\\n            if(e1 >= 0)\\n            {\\n                int count = 0;\\n                int low = 0;\\n                int high = nums2.length - 1;\\n                while (low <= high)\\n                {\\n                    int mid = low + (high - low) / 2;\\n                    if((long) e1 * nums2[mid] <= prod)\\n                    {\\n                        count = mid + 1;\\n                        low = mid + 1;\\n                    }\\n                    else {\\n                        high = mid - 1;\\n                    }\\n                }\\n                res += count;\\n\\n            }\\n            else {\\n                int count = 0;\\n                int low = 0;\\n                int high = nums2.length - 1;\\n                while (low <= high)\\n                {\\n                    int mid = low + (high - low) / 2;\\n                    if((long) e1 * nums2[mid] <= prod)\\n                    {\\n                        count = nums2.length - mid;\\n                        high = mid - 1;\\n                    }\\n                    else {\\n                        low = mid + 1;\\n                    }\\n                }\\n                res += count;\\n            }\\n\\n        }\\n        return res;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n     public long kthSmallestProduct(int[] nums1, int[] nums2, long k)\\n    {\\n        long si = -1000_000_0000l;\\n        long ei = 1000_000_0000l;\\n        long ans = 0;\\n        while(si <= ei)\\n        {\\n            long mid = si + (ei - si) / 2;\\n            long count = 0;\\n            if(countofProduct(nums1,nums2,mid) >= k)\\n            {\\n                ans = mid;\\n                ei = mid - 1;\\n            }\\n            else\\n            {\\n                si = mid + 1;\\n            }\\n\\n\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n\\n    private static long countofProduct(int[] nums1, int[] nums2, long prod)\\n    {\\n        long res = 0;\\n        for(int e1 : nums1)\\n        {\\n            if(e1 >= 0)\\n            {\\n                int count = 0;\\n                int low = 0;\\n                int high = nums2.length - 1;\\n                while (low <= high)\\n                {\\n                    int mid = low + (high - low) / 2;\\n                    if((long) e1 * nums2[mid] <= prod)\\n                    {\\n                        count = mid + 1;\\n                        low = mid + 1;\\n                    }\\n                    else {\\n                        high = mid - 1;\\n                    }\\n                }\\n                res += count;\\n\\n            }\\n            else {\\n                int count = 0;\\n                int low = 0;\\n                int high = nums2.length - 1;\\n                while (low <= high)\\n                {\\n                    int mid = low + (high - low) / 2;\\n                    if((long) e1 * nums2[mid] <= prod)\\n                    {\\n                        count = nums2.length - mid;\\n                        high = mid - 1;\\n                    }\\n                    else {\\n                        low = mid + 1;\\n                    }\\n                }\\n                res += count;\\n            }\\n\\n        }\\n        return res;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543233,
                "title": "c-short-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n    #define all(a) begin(a), end(a)\\npublic:\\n    ll kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, ll k) {\\n        ll l = -1e10, r = 1e10;\\n        ll ans;\\n        while (l <= r) {\\n            ll m = (l+r) / 2;\\n            \\n            ll cnt = 0;\\n            for (int x : nums1) {\\n                if (x == 0) cnt += (m >= 0) * size(nums2);\\n                else if (x > 0) cnt += upper_bound(all(nums2), m / x - (m < 0 && m % x)) - begin(nums2);\\n                else cnt += end(nums2) - lower_bound(all(nums2), m / x + (m < 0 && m % x));\\n            }\\n            if (cnt < k) l = m+1;\\n            else ans = m, r = m-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    #define all(a) begin(a), end(a)\\npublic:\\n    ll kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, ll k) {\\n        ll l = -1e10, r = 1e10;\\n        ll ans;\\n        while (l <= r) {\\n            ll m = (l+r) / 2;\\n            \\n            ll cnt = 0;\\n            for (int x : nums1) {\\n                if (x == 0) cnt += (m >= 0) * size(nums2);\\n                else if (x > 0) cnt += upper_bound(all(nums2), m / x - (m < 0 && m % x)) - begin(nums2);\\n                else cnt += end(nums2) - lower_bound(all(nums2), m / x + (m < 0 && m % x));\\n            }\\n            if (cnt < k) l = m+1;\\n            else ans = m, r = m-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202236,
                "title": "binary-search-wtih-explnation-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given arrays are already sorted. We need find the $$k$$th smallest product.\\n\\n##### Brute Force approach:\\nWe can create a PriorityQueue with k Length and we can iterate each element in nums1 with each element in nums2. The product we can put in the Priority Queue. But this appraoch will take $$O( (n*m) log n)$$.\\n\\n##### Binary Search:\\nAs the arrays are already sorted, we can use BST to find the no of products which are less than or equal to current value. This current value can vary between Long.MIN_VALUE to Long.MAX_VALUE.\\n\\ne.g:\\n[1,2,3,4,5]\\n[1,2,3,4,5]\\nAll the products are \\n```\\n[ (1,2,3,4,5), (2,4,6,8,10), (3,6,9,12,15), (4,8,12,16,20), (5,10,15,20,25)]\\n```\\n\\nFor the given no 8, the no of products <= 8 are :\\n```\\n[ (1,2,3,4,5), (2,4,6,8), (3,6), (4,8), (5)]\\nAns = 5 + 4 + 2 + 2+ 1 = 14\\n```\\n\\nSo if we have a method which gives no of products which are less than equal to given value than we can use BST as follows to solve the problem.\\n\\n```\\nl = long.MIN_VALUE\\nh = long.MAX_VALUE\\nwhile(l < h)\\n{\\n    m = l +(h-l)/2;\\n    val = getProductsLessThanOrEqualToM(m);\\n    if(val >= k) h = m\\n    else l = m\\n}\\nreturn h\\n```\\n\\n##### How to get no of products less than given value\\n\\nFor simplicity lets consider both of our array only contains postive value.\\n\\n```\\nIndex: 0,1,2,3,4\\nNums1: 1,2,3,4,5\\nNums2: 1,2,3,4,5\\n\\nWe want to get all the products less than 8\\n[0, 4] -> 1 * 5 = 5 so it indicates all the index (0 to 3 also will have the product less than 8) => 5\\n\\n[1, 4] -> 2 * 5 = 10 which is greater than 8\\n[1, 3] -> 2 * 4 = 8 which is equal to 8. So all index b/w [0,3] also will have the product less than 8 => 4\\n\\n//we don\\'t need to consider [2,4] as [1,4] already not in the list\\n[2,3] -> 3 * 4 = 12 which is greater than 8\\n[2,2] -> 3 * 3 = 9  which is greater than 9\\n[2,1] -> 3 * 2 = 6 so all the index b/w [0,1] have the product less than 8 => 2\\n\\n[3,1] -> 4 * 2 => 8 so all the index b/w [0,1] have the product less than 8 =>2\\n\\n[4,1] -> 5 * 2 => 10  which is greater than 8\\n[4,0] -> 5 * 1 => 5 so the only 0 the index of nums2 will contibute => 1\\n\\nTotal ans: 5 + 4 + 2 + 2 + 1 = 14\\n\\n```\\n\\n##### How to handle postivie and negative nos?\\nWhen nums1 is positive and nums2 is positive.\\n\\n```\\n*\\n1,2,3,4,5\\n1,2,3,4,5\\n        *\\nThe start index:\\nfor nums1: 0\\nfor nums2: 4\\n```\\n\\nWhen nums1 is positive and nums2 is negative.\\n```\\n        *\\n1,2,3,4,5\\n-5,-4,-3,-2,-1\\n             *\\nThe start index:\\nfor nums1: 4\\nfor nums2: 4\\n```\\n\\nWhen nums1 is negative and nums2 is negative.\\n```\\n             *\\n-5,-4,-3,-2,-1\\n-5,-4,-3,-2,-1\\n*\\nThe start index:\\nfor nums1: 4\\nfor nums2: 0\\n```\\n\\nWhen nums1 is negative and nums2 is positive.\\n```\\n*\\n-5,-4,-3,-2,-1\\n1,2,3,4,5\\n*\\nThe start index:\\nfor nums1: 0\\nfor nums2: 0\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nn - no of elements in the array 1\\nm - no of elements in the array 2\\n- Time complexity: $$O( (n+m) log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxNegativeIndex(int[] nums)\\n    {\\n        var low = 0;//negtive no\\n        var high = nums.length -1;//not a negative no\\n        if(nums[low] > 0) return -1;//don\\'t not have any negative value\\n        if(nums[high] < 0) return high;//all numbers are negative\\n        while(low < high)\\n        {\\n            var m = (low + high + 1)/2;\\n            if(nums[m] < 0)\\n            {\\n                low = m;\\n            }else{\\n                if(high == m) break;\\n                high = m;\\n            }\\n        }\\n        return low;\\n    }\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        long low = Long.MIN_VALUE/2;//have less than k no product than this\\n        long high = Long.MAX_VALUE/2;//have atleast k no product less than this\\n        var negInd1 = findMaxNegativeIndex(nums1);\\n        var negInd2 = findMaxNegativeIndex(nums2);\\n        while(low < high)\\n        {\\n            long m = low + (high-low)/2;\\n            var val = getNoOfProductLessThan(m, nums1, nums2, negInd1, negInd2);\\n            if(k <= val){\\n                high = m;\\n            }else{\\n                 if(low == m) break;\\n                low = m;\\n            }\\n        }\\n\\n        return high;\\n    }\\n    public long getNoOfProductLessThan(long m, int[] nums1, int[] nums2, int f, int s)\\n    {\\n        var l1 = nums1.length;\\n        var l2 = nums2.length;\\n        \\n        long ans = 0;\\n\\n        //when nums1 pos and nums2 is pos\\n        var j = l2-1;\\n        for(int i = f+1; i < l1; i++)\\n        {\\n            //special case when nums1[i] == 0\\n            if(nums1[i] == 0)\\n            {\\n                if(m >= 0) ans+= l2;\\n                continue;\\n            }\\n            while(j > s && ( (long)nums1[i] * (long)nums2[j] > m)  )\\n            {\\n                j--;\\n            }\\n            if(j > s) ans+= j-s;\\n        }\\n\\n        //when nums1 pos and nums2 is neg\\n        j = s;\\n        for(int i = l1-1; i > f; i--)\\n        {\\n            if(nums1[i] == 0) break;\\n            while(j >= 0 && ( (long)nums1[i] * (long)nums2[j] > m)  )\\n            {\\n                j--;\\n            }\\n            if(j >= 0) ans += (j+1);\\n        }\\n\\n        //when nums1 neg and nums2 is neg\\n        j = 0;\\n        for(int i = f; i >= 0; i--)\\n        {\\n            while(j <= s && ( (long)nums1[i] * (long)nums2[j] > m)  )\\n            {\\n                j++;\\n            }\\n            if(j <= s) ans+= (s-j+1);\\n        }\\n\\n        //when nums1 neg and nums2 is pos\\n        j = s+1;\\n        for(int i = 0; i <= f; i++)\\n        {\\n            while(j < l2 && ( (long)nums1[i] * (long)nums2[j] > m)  )\\n            {\\n                j++;\\n            }\\n            if(j < l2) ans += (l2 - j);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n[ (1,2,3,4,5), (2,4,6,8,10), (3,6,9,12,15), (4,8,12,16,20), (5,10,15,20,25)]\\n```\n```\\n[ (1,2,3,4,5), (2,4,6,8), (3,6), (4,8), (5)]\\nAns = 5 + 4 + 2 + 2+ 1 = 14\\n```\n```\\nl = long.MIN_VALUE\\nh = long.MAX_VALUE\\nwhile(l < h)\\n{\\n    m = l +(h-l)/2;\\n    val = getProductsLessThanOrEqualToM(m);\\n    if(val >= k) h = m\\n    else l = m\\n}\\nreturn h\\n```\n```\\nIndex: 0,1,2,3,4\\nNums1: 1,2,3,4,5\\nNums2: 1,2,3,4,5\\n\\nWe want to get all the products less than 8\\n[0, 4] -> 1 * 5 = 5 so it indicates all the index (0 to 3 also will have the product less than 8) => 5\\n\\n[1, 4] -> 2 * 5 = 10 which is greater than 8\\n[1, 3] -> 2 * 4 = 8 which is equal to 8. So all index b/w [0,3] also will have the product less than 8 => 4\\n\\n//we don\\'t need to consider [2,4] as [1,4] already not in the list\\n[2,3] -> 3 * 4 = 12 which is greater than 8\\n[2,2] -> 3 * 3 = 9  which is greater than 9\\n[2,1] -> 3 * 2 = 6 so all the index b/w [0,1] have the product less than 8 => 2\\n\\n[3,1] -> 4 * 2 => 8 so all the index b/w [0,1] have the product less than 8 =>2\\n\\n[4,1] -> 5 * 2 => 10  which is greater than 8\\n[4,0] -> 5 * 1 => 5 so the only 0 the index of nums2 will contibute => 1\\n\\nTotal ans: 5 + 4 + 2 + 2 + 1 = 14\\n\\n```\n```\\n*\\n1,2,3,4,5\\n1,2,3,4,5\\n        *\\nThe start index:\\nfor nums1: 0\\nfor nums2: 4\\n```\n```\\n        *\\n1,2,3,4,5\\n-5,-4,-3,-2,-1\\n             *\\nThe start index:\\nfor nums1: 4\\nfor nums2: 4\\n```\n```\\n             *\\n-5,-4,-3,-2,-1\\n-5,-4,-3,-2,-1\\n*\\nThe start index:\\nfor nums1: 4\\nfor nums2: 0\\n```\n```\\n*\\n-5,-4,-3,-2,-1\\n1,2,3,4,5\\n*\\nThe start index:\\nfor nums1: 0\\nfor nums2: 0\\n```\n```\\nclass Solution {\\n    public int findMaxNegativeIndex(int[] nums)\\n    {\\n        var low = 0;//negtive no\\n        var high = nums.length -1;//not a negative no\\n        if(nums[low] > 0) return -1;//don\\'t not have any negative value\\n        if(nums[high] < 0) return high;//all numbers are negative\\n        while(low < high)\\n        {\\n            var m = (low + high + 1)/2;\\n            if(nums[m] < 0)\\n            {\\n                low = m;\\n            }else{\\n                if(high == m) break;\\n                high = m;\\n            }\\n        }\\n        return low;\\n    }\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        long low = Long.MIN_VALUE/2;//have less than k no product than this\\n        long high = Long.MAX_VALUE/2;//have atleast k no product less than this\\n        var negInd1 = findMaxNegativeIndex(nums1);\\n        var negInd2 = findMaxNegativeIndex(nums2);\\n        while(low < high)\\n        {\\n            long m = low + (high-low)/2;\\n            var val = getNoOfProductLessThan(m, nums1, nums2, negInd1, negInd2);\\n            if(k <= val){\\n                high = m;\\n            }else{\\n                 if(low == m) break;\\n                low = m;\\n            }\\n        }\\n\\n        return high;\\n    }\\n    public long getNoOfProductLessThan(long m, int[] nums1, int[] nums2, int f, int s)\\n    {\\n        var l1 = nums1.length;\\n        var l2 = nums2.length;\\n        \\n        long ans = 0;\\n\\n        //when nums1 pos and nums2 is pos\\n        var j = l2-1;\\n        for(int i = f+1; i < l1; i++)\\n        {\\n            //special case when nums1[i] == 0\\n            if(nums1[i] == 0)\\n            {\\n                if(m >= 0) ans+= l2;\\n                continue;\\n            }\\n            while(j > s && ( (long)nums1[i] * (long)nums2[j] > m)  )\\n            {\\n                j--;\\n            }\\n            if(j > s) ans+= j-s;\\n        }\\n\\n        //when nums1 pos and nums2 is neg\\n        j = s;\\n        for(int i = l1-1; i > f; i--)\\n        {\\n            if(nums1[i] == 0) break;\\n            while(j >= 0 && ( (long)nums1[i] * (long)nums2[j] > m)  )\\n            {\\n                j--;\\n            }\\n            if(j >= 0) ans += (j+1);\\n        }\\n\\n        //when nums1 neg and nums2 is neg\\n        j = 0;\\n        for(int i = f; i >= 0; i--)\\n        {\\n            while(j <= s && ( (long)nums1[i] * (long)nums2[j] > m)  )\\n            {\\n                j++;\\n            }\\n            if(j <= s) ans+= (s-j+1);\\n        }\\n\\n        //when nums1 neg and nums2 is pos\\n        j = s+1;\\n        for(int i = 0; i <= f; i++)\\n        {\\n            while(j < l2 && ( (long)nums1[i] * (long)nums2[j] > m)  )\\n            {\\n                j++;\\n            }\\n            if(j < l2) ans += (l2 - j);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742708,
                "title": "c-code-for-beginners-binary-search-reference-for-future-me",
                "content": "Binary search for the Kth value, in the isPossible function check how hany products can be formed from nums1, nums2 whose product is less than your assumed value. It should be greater than k, otherwise its quite obvious you would not get kth value if your number of elements are less than K\\n\\nTo find the products from both array, loop on array1 and binary search on array2 to find the count of products which can be less than your guessed value.\\n\\nIf your element in array1 is positive, obviously, you need to multiply it with smallest negatives to minimise the product and hopefully make it smaller than your guessed value\\nand\\nIf your element in array1 is negative, you need to multiply it with all the largest positives in array2 such that the product becomes less than guessed value\\n\\n```\\nclass Solution {\\npublic:\\n     int maximiseSmall(vector<int> &nums2 ,long long val ,long long midval){\\n        int l=0;\\n        int r=nums2.size()-1;\\n        int res= -1;\\n        while(l<=r){\\n            long long mid=(l+r)/2;\\n            if(val*nums2[mid]<=midval){  /* maximise the left side of nums2 as val is positive\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tand hence we need to have as many negative/small\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnumbers which are mostly found on left side */\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else{\\n                r=mid-1;\\n            }\\n        }\\n        return res+1;\\n    }\\n    \\n    int maximiseLarge(vector<int> &nums2 ,long long val ,long long midval){\\n        int l=0;\\n        int r=nums2.size()-1;\\n        int res=nums.size()+1;\\n        while(l<=r){\\n            long long mid=(l+r)/2;\\n            if(val*nums2[mid]<=midval){  /* maximise the right side of nums2 as val is negative\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    and hence we need to have as many positive/large\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnumbers which are mostly found on right side,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tas negative*positive=negative. So finally we subtract\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tres from nums2.size() to get how many numbers were on \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthe right side */\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return nums2.size()-res;\\n    }\\n    \\n    bool isPossible(vector<int> &nums1, vector<int> nums2, long long midval, long long k){\\n        long long cnt=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long val=nums1[i];                        \\n\\t\\t\\t/* If val == 0, product of val and each element in nums2 will be 0. And if midval>=0, \\n\\t\\t\\tthen because all products are 0, all products will be smaller or equal to midval. \\n\\t\\t\\tSo we can add all products in the answer */\\n\\t\\t\\tif(val==0 && midval>=0){\\n                cnt+=nums2.size();\\n            }\\n            else if(val>0){\\n                cnt+=maximiseSmall(nums2,val,midval);\\n            }\\n            else if(val<0){\\n                cnt+=maximiseLarge(nums2,val,midval);\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long low=-1e10;\\n        long long high=1e10;\\n        long long res=0;\\n        while(low<=high){\\n            long long mid=(high+low)/2;\\n            if(isPossible(nums1,nums2,mid,k)==true){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int maximiseSmall(vector<int> &nums2 ,long long val ,long long midval){\\n        int l=0;\\n        int r=nums2.size()-1;\\n        int res= -1;\\n        while(l<=r){\\n            long long mid=(l+r)/2;\\n            if(val*nums2[mid]<=midval){  /* maximise the left side of nums2 as val is positive\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tand hence we need to have as many negative/small\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnumbers which are mostly found on left side */\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else{\\n                r=mid-1;\\n            }\\n        }\\n        return res+1;\\n    }\\n    \\n    int maximiseLarge(vector<int> &nums2 ,long long val ,long long midval){\\n        int l=0;\\n        int r=nums2.size()-1;\\n        int res=nums.size()+1;\\n        while(l<=r){\\n            long long mid=(l+r)/2;\\n            if(val*nums2[mid]<=midval){  /* maximise the right side of nums2 as val is negative\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    and hence we need to have as many positive/large\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnumbers which are mostly found on right side,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tas negative*positive=negative. So finally we subtract\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tres from nums2.size() to get how many numbers were on \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthe right side */\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return nums2.size()-res;\\n    }\\n    \\n    bool isPossible(vector<int> &nums1, vector<int> nums2, long long midval, long long k){\\n        long long cnt=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long val=nums1[i];                        \\n\\t\\t\\t/* If val == 0, product of val and each element in nums2 will be 0. And if midval>=0, \\n\\t\\t\\tthen because all products are 0, all products will be smaller or equal to midval. \\n\\t\\t\\tSo we can add all products in the answer */\\n\\t\\t\\tif(val==0 && midval>=0){\\n                cnt+=nums2.size();\\n            }\\n            else if(val>0){\\n                cnt+=maximiseSmall(nums2,val,midval);\\n            }\\n            else if(val<0){\\n                cnt+=maximiseLarge(nums2,val,midval);\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long low=-1e10;\\n        long long high=1e10;\\n        long long res=0;\\n        while(low<=high){\\n            long long mid=(high+low)/2;\\n            if(isPossible(nums1,nums2,mid,k)==true){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211358,
                "title": "python-binary-search-clean-code",
                "content": "```\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        n = len(nums1)\\n        m = len(nums2)\\n        \\n        nPos = [num for num in nums1 if num >= 0]\\n        nNeg = [-num for num in nums1 if num < 0][::-1]\\n        mPos = [num for num in nums2 if num >= 0]\\n        mNeg = [-num for num in nums2 if num < 0][::-1]\\n        \\n        numOfNegatives = len(nPos) * len(mNeg) + len(mPos) * len(nNeg)\\n        sign = 1\\n        if k > numOfNegatives:\\n            k -= numOfNegatives\\n        else:\\n            k = numOfNegatives - k + 1\\n            temp = mPos\\n            mPos = mNeg\\n            mNeg = temp\\n            sign = -1\\n        \\n        \\n        def count(n, m, target):\\n            result = 0\\n            right = len(m) - 1\\n            \\n            for left in range(len(n)):\\n                while right >= 0 and n[left] * m[right] > target:\\n                    right -= 1\\n                result += right + 1\\n            return result\\n        \\n        \\n        left = 0\\n        right = 10**10\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            countPos = count(nPos, mPos, mid) + count(nNeg, mNeg, mid)\\n            \\n            if countPos >= k:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left * sign\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        n = len(nums1)\\n        m = len(nums2)\\n        \\n        nPos = [num for num in nums1 if num >= 0]\\n        nNeg = [-num for num in nums1 if num < 0][::-1]\\n        mPos = [num for num in nums2 if num >= 0]\\n        mNeg = [-num for num in nums2 if num < 0][::-1]\\n        \\n        numOfNegatives = len(nPos) * len(mNeg) + len(mPos) * len(nNeg)\\n        sign = 1\\n        if k > numOfNegatives:\\n            k -= numOfNegatives\\n        else:\\n            k = numOfNegatives - k + 1\\n            temp = mPos\\n            mPos = mNeg\\n            mNeg = temp\\n            sign = -1\\n        \\n        \\n        def count(n, m, target):\\n            result = 0\\n            right = len(m) - 1\\n            \\n            for left in range(len(n)):\\n                while right >= 0 and n[left] * m[right] > target:\\n                    right -= 1\\n                result += right + 1\\n            return result\\n        \\n        \\n        left = 0\\n        right = 10**10\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            countPos = count(nPos, mPos, mid) + count(nNeg, mNeg, mid)\\n            \\n            if countPos >= k:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left * sign\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997558,
                "title": "javascript-2-solutions-binary-search",
                "content": "**Time O((n + m) * log(10  ^ 10))**\\n```\\nvar kthSmallestProduct = function(nums1, nums2, k) {\\n    let rProduct = 10 ** 10, lProduct = -rProduct;\\n    const negativeNums1 = nums1.filter((num) => num < 0);\\n    const positiveNums1 = nums1.filter((num) => num >= 0);\\n    const negativeNums2 = nums2.filter((num) => num < 0);\\n    const positiveNums2 = nums2.filter((num) => num >= 0);\\n    const negativeNums1Reverse = [...negativeNums1].reverse();\\n    const positiveNums1Reverse = [...positiveNums1].reverse();\\n    const negativeNums2Reverse = [...negativeNums2].reverse();\\n    const positiveNums2Reverse = [...positiveNums2].reverse();\\n\\n    const findRank = (list1, list2, product) => {\\n        let rank = 0;\\n\\n        for (let i = list1.length - 1, j = 0; i >= 0; i--) {\\n\\t\\t\\tfor (; j < list2.length && list2[j] * list1[i] <= product; j++);\\n            rank += j;\\n        }\\n        \\n        return rank;\\n    };\\n\\n    while (lProduct < rProduct) {\\n        const midProduct = Math.floor((lProduct + rProduct) / 2);\\n\\n        if (midProduct >= 0) {\\n            var rank = negativeNums1.length * positiveNums2.length +\\n                negativeNums2.length * positiveNums1.length +\\n                findRank(negativeNums1Reverse, negativeNums2Reverse, midProduct) +\\n                findRank(positiveNums1, positiveNums2, midProduct)\\n        } else {\\n            var rank = findRank(positiveNums1Reverse, negativeNums2, midProduct) +\\n                findRank(positiveNums2Reverse, negativeNums1, midProduct);\\n        }\\n\\n        rank < k ? (lProduct = midProduct + 1) : (rProduct = midProduct);\\n    }\\n    \\n    return lProduct;\\n};\\n```\\n\\n**Time O(n * log(m) * log(10 ^ 10))**\\n```\\nvar kthSmallestProduct = function(nums1, nums2, k) {\\n    let rProduct = 10 ** 10, lProduct = -rProduct;\\n\\n    while (lProduct < rProduct) {\\n        const midProduct = Math.floor((lProduct + rProduct) / 2);\\n        let rank = 0;\\n        \\n        for (const num1 of nums1) {\\n            if (num1 < 0) {\\n                let l = 0, r = nums2.length;\\n                while (l < r) {\\n                    const mid = (l + r) >> 1;\\n                    nums2[mid] * num1 <= midProduct ? (r = mid) : (l = mid + 1);\\n                }\\n\\n                rank += nums2.length - l;\\n            } else if (num1 > 0) {\\n                let l = -1, r = nums2.length - 1;\\n                while (l < r) {\\n                    const mid = (l + r + 1) >> 1;\\n                    nums2[mid] * num1 <= midProduct ? (l = mid) : (r = mid - 1);\\n                }\\n\\n                rank += l + 1;\\n            } else {\\n                rank += midProduct >= 0 ? nums2.length : 0;\\n            }\\n        }\\n        \\n        rank < k ? lProduct = midProduct + 1 : rProduct = midProduct;\\n    }\\n\\n    return lProduct;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar kthSmallestProduct = function(nums1, nums2, k) {\\n    let rProduct = 10 ** 10, lProduct = -rProduct;\\n    const negativeNums1 = nums1.filter((num) => num < 0);\\n    const positiveNums1 = nums1.filter((num) => num >= 0);\\n    const negativeNums2 = nums2.filter((num) => num < 0);\\n    const positiveNums2 = nums2.filter((num) => num >= 0);\\n    const negativeNums1Reverse = [...negativeNums1].reverse();\\n    const positiveNums1Reverse = [...positiveNums1].reverse();\\n    const negativeNums2Reverse = [...negativeNums2].reverse();\\n    const positiveNums2Reverse = [...positiveNums2].reverse();\\n\\n    const findRank = (list1, list2, product) => {\\n        let rank = 0;\\n\\n        for (let i = list1.length - 1, j = 0; i >= 0; i--) {\\n\\t\\t\\tfor (; j < list2.length && list2[j] * list1[i] <= product; j++);\\n            rank += j;\\n        }\\n        \\n        return rank;\\n    };\\n\\n    while (lProduct < rProduct) {\\n        const midProduct = Math.floor((lProduct + rProduct) / 2);\\n\\n        if (midProduct >= 0) {\\n            var rank = negativeNums1.length * positiveNums2.length +\\n                negativeNums2.length * positiveNums1.length +\\n                findRank(negativeNums1Reverse, negativeNums2Reverse, midProduct) +\\n                findRank(positiveNums1, positiveNums2, midProduct)\\n        } else {\\n            var rank = findRank(positiveNums1Reverse, negativeNums2, midProduct) +\\n                findRank(positiveNums2Reverse, negativeNums1, midProduct);\\n        }\\n\\n        rank < k ? (lProduct = midProduct + 1) : (rProduct = midProduct);\\n    }\\n    \\n    return lProduct;\\n};\\n```\n```\\nvar kthSmallestProduct = function(nums1, nums2, k) {\\n    let rProduct = 10 ** 10, lProduct = -rProduct;\\n\\n    while (lProduct < rProduct) {\\n        const midProduct = Math.floor((lProduct + rProduct) / 2);\\n        let rank = 0;\\n        \\n        for (const num1 of nums1) {\\n            if (num1 < 0) {\\n                let l = 0, r = nums2.length;\\n                while (l < r) {\\n                    const mid = (l + r) >> 1;\\n                    nums2[mid] * num1 <= midProduct ? (r = mid) : (l = mid + 1);\\n                }\\n\\n                rank += nums2.length - l;\\n            } else if (num1 > 0) {\\n                let l = -1, r = nums2.length - 1;\\n                while (l < r) {\\n                    const mid = (l + r + 1) >> 1;\\n                    nums2[mid] * num1 <= midProduct ? (l = mid) : (r = mid - 1);\\n                }\\n\\n                rank += l + 1;\\n            } else {\\n                rank += midProduct >= 0 ? nums2.length : 0;\\n            }\\n        }\\n        \\n        rank < k ? lProduct = midProduct + 1 : rProduct = midProduct;\\n    }\\n\\n    return lProduct;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938330,
                "title": "c-solution",
                "content": "Solution is C# version of [this ](https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/discuss/1524349/Java-Double-Binary-Search-O(log1010-x-MlogN))\\n```\\npublic class Solution \\n{\\n    static long INF = (long) 1e10;\\n    \\n    public long KthSmallestProduct(int[] nums1, int[] nums2, long k) \\n    {\\n        int m = nums1.Length, n = nums2.Length;\\n\\t\\tlong lo = -INF - 1, hi = INF + 1;\\n        \\n\\t\\twhile (lo < hi)\\n\\t\\t{\\n\\t\\t\\tlong mid = lo + ((hi - lo) >> 1), cnt = 0;\\n\\t\\t\\t\\n            foreach (int i in nums1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (0 <= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint l = 0, r = n - 1, p = 0;\\n\\t\\t\\t\\t\\twhile (l <= r)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint c = l + ((r - l) >> 1);\\n\\t\\t\\t\\t\\t\\tlong mul = i * (long)nums2[c];\\n\\t\\t\\t\\t\\t\\tif (mul <= mid)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tp = c + 1;\\n\\t\\t\\t\\t\\t\\t\\tl = c + 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tr = c - 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcnt += p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint l = 0, r = n - 1, p = 0;\\n\\t\\t\\t\\t\\twhile (l <= r)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint c = l + ((r - l) >> 1);\\n\\t\\t\\t\\t\\t\\tlong mul = i * (long)nums2[c];\\n\\t\\t\\t\\t\\t\\tif (mul <= mid)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tp = n - c;\\n\\t\\t\\t\\t\\t\\t\\tr = c - 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tl = c + 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcnt += p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (cnt >= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\thi = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlo = mid + 1L;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lo;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    static long INF = (long) 1e10;\\n    \\n    public long KthSmallestProduct(int[] nums1, int[] nums2, long k) \\n    {\\n        int m = nums1.Length, n = nums2.Length;\\n\\t\\tlong lo = -INF - 1, hi = INF + 1;\\n        \\n\\t\\twhile (lo < hi)\\n\\t\\t{\\n\\t\\t\\tlong mid = lo + ((hi - lo) >> 1), cnt = 0;\\n\\t\\t\\t\\n            foreach (int i in nums1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (0 <= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint l = 0, r = n - 1, p = 0;\\n\\t\\t\\t\\t\\twhile (l <= r)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint c = l + ((r - l) >> 1);\\n\\t\\t\\t\\t\\t\\tlong mul = i * (long)nums2[c];\\n\\t\\t\\t\\t\\t\\tif (mul <= mid)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tp = c + 1;\\n\\t\\t\\t\\t\\t\\t\\tl = c + 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tr = c - 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcnt += p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint l = 0, r = n - 1, p = 0;\\n\\t\\t\\t\\t\\twhile (l <= r)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint c = l + ((r - l) >> 1);\\n\\t\\t\\t\\t\\t\\tlong mul = i * (long)nums2[c];\\n\\t\\t\\t\\t\\t\\tif (mul <= mid)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tp = n - c;\\n\\t\\t\\t\\t\\t\\t\\tr = c - 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tl = c + 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcnt += p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (cnt >= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\thi = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tlo = mid + 1L;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn lo;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590943,
                "title": "java-binary-search-approach",
                "content": "Thanks to [@hdchen](https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/discuss/1524349/Java-Double-Binary-Search-O(log1010-x-MlogN)) took reference from the solution and made a concise version of it.\\n\\n**Approach**\\n* Do Binary Search from negative limit `-1e10` to positive limit `1e10` for the value `val` from the first array\\n* Do Binary search for the length of the second array from `0` to `nums2.length - 1`\\n* Multiply the value each time with the mid value from the second array and see if its less that or greater and count `cnt` accordingly\\n* Eventually the `k` smallest element will be found and the `lo` value will be returned\\n\\n```\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        long lo = (long) -1e10; \\n        long hi = (long) 1e10;\\n        \\n        while (lo < hi) {\\n            long mid = lo + ((hi - lo) >> 1);\\n            long cnt = 0;\\n            \\n            for (int val : nums1) \\n                cnt += (val >= 0) ? binary_search(mid, val, nums2, true) : binary_search(mid, val, nums2, false);\\n            \\n            if (cnt >= k) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    \\n    public long binary_search(long mid, int i, int[] nums2, boolean positive){\\n        int l = 0;\\n        int r = nums2.length - 1;\\n        int res = 0;\\n        \\n        while (l <= r) {\\n            int c = l + ((r - l) >> 1);\\n            long mul = i * (long) nums2[c];\\n            if (mul <= mid) {\\n                if (positive){\\n                    l = c + 1;\\n                    res = c + 1; \\n                }\\n                else{\\n                    r = c - 1;\\n                    res = nums2.length - c;\\n                } \\n            }\\n            else{\\n                if (positive) r = c - 1;                    \\n                else l = c + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        long lo = (long) -1e10; \\n        long hi = (long) 1e10;\\n        \\n        while (lo < hi) {\\n            long mid = lo + ((hi - lo) >> 1);\\n            long cnt = 0;\\n            \\n            for (int val : nums1) \\n                cnt += (val >= 0) ? binary_search(mid, val, nums2, true) : binary_search(mid, val, nums2, false);\\n            \\n            if (cnt >= k) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    \\n    public long binary_search(long mid, int i, int[] nums2, boolean positive){\\n        int l = 0;\\n        int r = nums2.length - 1;\\n        int res = 0;\\n        \\n        while (l <= r) {\\n            int c = l + ((r - l) >> 1);\\n            long mul = i * (long) nums2[c];\\n            if (mul <= mid) {\\n                if (positive){\\n                    l = c + 1;\\n                    res = c + 1; \\n                }\\n                else{\\n                    r = c - 1;\\n                    res = nums2.length - c;\\n                } \\n            }\\n            else{\\n                if (positive) r = c - 1;                    \\n                else l = c + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577805,
                "title": "c-binary-search-clean-and-short-o-m-n-lgv",
                "content": "```c++\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& a, vector<int>& b, long long k) {\\n        int n = a.size(), m = b.size();\\n        int x = lower_bound(begin(a), end(a), 0) - begin(a);\\n        int y = lower_bound(begin(b), end(b), 0) - begin(b);\\n        auto lt = [&](int i, int j) { return 1LL * a[x - 1 - i] * b[y - 1 - j]; };\\n        auto rt = [&](int i, int j) { return 1LL * a[i]         * b[m - 1 - j]; };\\n        auto lb = [&](int i, int j) { return 1LL * a[n - 1 - i] * b[j]; };\\n        auto rb = [&](int i, int j) { return 1LL * a[x + i]     * b[y + j]; };\\n        auto count = [](auto& f, int n, int m, long long v) {\\n            long long c = 0;\\n            for(int i = n - 1, j = 0; j < m && i >= 0; ++j) {\\n                while (i >= 0 && 1LL * f(i, j) > v) --i;\\n                c += i + 1;\\n            }\\n            return c;\\n        };\\n        long long L = -1e10 - 1, R = 1e10;\\n        while (L + 1 < R) {\\n            auto M = (L + R) >> 1;\\n            auto cnt =  count(lt,     x,     y, M) +\\n                        count(rt,     x, m - y, M) +\\n                        count(lb, n - x,     y, M) +\\n                        count(rb, n - x, m - y, M);\\n            if (cnt < k) L = M;\\n            else R = M;\\n        }\\n        return R;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& a, vector<int>& b, long long k) {\\n        int n = a.size(), m = b.size();\\n        int x = lower_bound(begin(a), end(a), 0) - begin(a);\\n        int y = lower_bound(begin(b), end(b), 0) - begin(b);\\n        auto lt = [&](int i, int j) { return 1LL * a[x - 1 - i] * b[y - 1 - j]; };\\n        auto rt = [&](int i, int j) { return 1LL * a[i]         * b[m - 1 - j]; };\\n        auto lb = [&](int i, int j) { return 1LL * a[n - 1 - i] * b[j]; };\\n        auto rb = [&](int i, int j) { return 1LL * a[x + i]     * b[y + j]; };\\n        auto count = [](auto& f, int n, int m, long long v) {\\n            long long c = 0;\\n            for(int i = n - 1, j = 0; j < m && i >= 0; ++j) {\\n                while (i >= 0 && 1LL * f(i, j) > v) --i;\\n                c += i + 1;\\n            }\\n            return c;\\n        };\\n        long long L = -1e10 - 1, R = 1e10;\\n        while (L + 1 < R) {\\n            auto M = (L + R) >> 1;\\n            auto cnt =  count(lt,     x,     y, M) +\\n                        count(rt,     x, m - y, M) +\\n                        count(lb, n - x,     y, M) +\\n                        count(rb, n - x, m - y, M);\\n            if (cnt < k) L = M;\\n            else R = M;\\n        }\\n        return R;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551347,
                "title": "java-binary-search",
                "content": "~~~java\\n\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        if (nums1 == null || nums2 == null) {\\n            return -1;\\n        }\\n        \\n        long left = (long) -1e10;\\n        long right = (long) 1e10;\\n        while (left + 1 < right) {\\n            long mid = left + (right - left) / 2;\\n            long count = countSmallerOrEqual(nums1, nums2, mid);\\n            if (count < k) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return countSmallerOrEqual(nums1, nums2, left) >= k ? left : right;\\n    }\\n    \\n    private long countSmallerOrEqual(int[] nums1, int[] nums2, long target) {\\n        long count = 0;\\n        \\n        for (int n1 : nums1) {\\n            int left = 0, right = nums2.length - 1;\\n            \\n            while (left + 1 < right) {\\n                int mid = left + (right - left) / 2;\\n                long prod = (long)n1 * nums2[mid];\\n                \\n                if (n1 >= 0) {\\n                    if (prod <= target) {\\n                        left = mid;\\n                    } else {\\n                        right = mid - 1;\\n                    }\\n                } else {\\n                    if (prod <= target) {\\n                        right = mid;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n            } \\n            \\n            long currCount = 0;\\n            if (n1 >= 0) {\\n                if ((long) n1 * nums2[right] <= target) {\\n                    currCount = right + 1;\\n                } else if ((long) n1 * nums2[left] <= target) {\\n                    currCount = left + 1;\\n                } else {\\n                    currCount = 0;\\n                }\\n            } else {\\n                if ((long) n1 * nums2[left] <= target) {\\n                    currCount = nums2.length - left;\\n                } else if ((long) n1 * nums2[right] <= target) {\\n                    currCount = nums2.length - right;\\n                } else {\\n                    currCount = 0;\\n                }\\n            }\\n            count += currCount;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        if (nums1 == null || nums2 == null) {\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1527947,
                "title": "c-rust-solution",
                "content": "We execute 4 simple algorithm on 4 sorted sub matrix to process negative rather than 1 complex algorithm.\\n\\nTime: O(n * log(10^10))\\nSpace: O(1)\\n\\nRust\\n\\nThe space complexity of this rust code is not O(1) since I\\'m still a newbee on rust and\\ndon\\'t know how to implement it.\\n\\n```rust\\nimpl Solution {\\n    pub fn kth_smallest_product(nums1: Vec<i32>, nums2: Vec<i32>, k: i64) -> i64 {\\n        let (neg1, pos1): (Vec<i32>, Vec<i32>) = nums1.iter().partition(|&&x| x < 0);\\n        let (neg2, pos2): (Vec<i32>, Vec<i32>) = nums2.iter().partition(|&&x| x < 0);\\n        let rneg1: Vec<i32> = neg1.iter().cloned().rev().collect();\\n        let rneg2: Vec<i32> = neg2.iter().cloned().rev().collect();\\n        let rpos1: Vec<i32> = pos1.iter().cloned().rev().collect();\\n        let rpos2: Vec<i32> = pos2.iter().cloned().rev().collect();\\n        let countle = |mid: i64| {\\n            Solution::countle_in_sorted_matrix(&neg1, &rpos2, mid)\\n                + Solution::countle_in_sorted_matrix(&rneg1, &rneg2, mid)\\n                + Solution::countle_in_sorted_matrix(&rpos1, &neg2, mid)\\n                + Solution::countle_in_sorted_matrix(&pos1, &pos2, mid)\\n        };\\n\\n        let limit = 10_i64.pow(10);\\n        let mut r = (-limit, limit);\\n        while r.0 != r.1 {\\n            let mid = r.0 + (r.1 - r.0) / 2;\\n            if countle(mid) < k {\\n                r.0 = mid + 1;\\n            } else {\\n                r.1 = mid;\\n            }\\n        }\\n        r.0\\n    }\\n\\n    fn countle_in_sorted_matrix(nums1: &[i32], nums2: &[i32], k: i64) -> i64 {\\n        let mut j = nums2.len();\\n        let mut cnt: i64 = 0;\\n        for &v in nums1 {\\n            while j != 0 && (nums2[j - 1] as i64) * (v as i64) > k {\\n                j -= 1;\\n            }\\n            cnt += j as i64;\\n        }\\n\\n        cnt\\n    }\\n}\\n```\\n\\nC++\\n\\nO(1) space\\n\\n```cpp\\nclass Solution {\\n   public:\\n    long long kthSmallestProduct(vector<int>& nums1,\\n                                 vector<int>& nums2,\\n                                 long long k) {\\n        int64_t l = -1e10;\\n        int64_t r = 1e10;\\n        while (l != r) {\\n            const auto mid = l + (r - l) / 2;\\n            if (countle(nums1, nums2, mid) < k) {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    int64_t countle(const vector<int>& nums1,\\n                    const vector<int>& nums2,\\n                    int64_t k) {\\n        const auto pos1 = partition_point(nums1.begin(),\\n                                          nums1.end(),\\n                                          [](const auto& x) { return x < 0; });\\n        const auto pos2 = partition_point(nums2.begin(),\\n                                          nums2.end(),\\n                                          [](const auto& x) { return x < 0; });\\n        const auto first1 = nums1.begin();\\n        const auto last1 = nums1.end();\\n        const auto first2 = nums2.begin();\\n        const auto last2 = nums2.end();\\n        return countle_in_sorted_matrix(pos1, last1, pos2, last2, k) +\\n               countle_in_sorted_matrix(first1,\\n                                        pos1,\\n                                        make_reverse_iterator(last2),\\n                                        make_reverse_iterator(pos2),\\n                                        k) +\\n               countle_in_sorted_matrix(make_reverse_iterator(pos1),\\n                                        make_reverse_iterator(first1),\\n                                        make_reverse_iterator(pos2),\\n                                        make_reverse_iterator(first2),\\n                                        k) +\\n               countle_in_sorted_matrix(make_reverse_iterator(last1),\\n                                        make_reverse_iterator(pos1),\\n                                        first2,\\n                                        pos2,\\n                                        k);\\n    }\\n\\n    template <class It1, class It2>\\n    int64_t countle_in_sorted_matrix(\\n        It1 first1, It1 last1, It2 first2, It2 last2, int64_t k) {\\n        int64_t cnt = 0;\\n        auto j = last2;\\n        for (auto it = first1; it != last1; ++it) {\\n            while (j != first2 && j[-1] * int64_t(*it) > k) {\\n                --j;\\n            }\\n            cnt += distance(first2, j);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn kth_smallest_product(nums1: Vec<i32>, nums2: Vec<i32>, k: i64) -> i64 {\\n        let (neg1, pos1): (Vec<i32>, Vec<i32>) = nums1.iter().partition(|&&x| x < 0);\\n        let (neg2, pos2): (Vec<i32>, Vec<i32>) = nums2.iter().partition(|&&x| x < 0);\\n        let rneg1: Vec<i32> = neg1.iter().cloned().rev().collect();\\n        let rneg2: Vec<i32> = neg2.iter().cloned().rev().collect();\\n        let rpos1: Vec<i32> = pos1.iter().cloned().rev().collect();\\n        let rpos2: Vec<i32> = pos2.iter().cloned().rev().collect();\\n        let countle = |mid: i64| {\\n            Solution::countle_in_sorted_matrix(&neg1, &rpos2, mid)\\n                + Solution::countle_in_sorted_matrix(&rneg1, &rneg2, mid)\\n                + Solution::countle_in_sorted_matrix(&rpos1, &neg2, mid)\\n                + Solution::countle_in_sorted_matrix(&pos1, &pos2, mid)\\n        };\\n\\n        let limit = 10_i64.pow(10);\\n        let mut r = (-limit, limit);\\n        while r.0 != r.1 {\\n            let mid = r.0 + (r.1 - r.0) / 2;\\n            if countle(mid) < k {\\n                r.0 = mid + 1;\\n            } else {\\n                r.1 = mid;\\n            }\\n        }\\n        r.0\\n    }\\n\\n    fn countle_in_sorted_matrix(nums1: &[i32], nums2: &[i32], k: i64) -> i64 {\\n        let mut j = nums2.len();\\n        let mut cnt: i64 = 0;\\n        for &v in nums1 {\\n            while j != 0 && (nums2[j - 1] as i64) * (v as i64) > k {\\n                j -= 1;\\n            }\\n            cnt += j as i64;\\n        }\\n\\n        cnt\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\n   public:\\n    long long kthSmallestProduct(vector<int>& nums1,\\n                                 vector<int>& nums2,\\n                                 long long k) {\\n        int64_t l = -1e10;\\n        int64_t r = 1e10;\\n        while (l != r) {\\n            const auto mid = l + (r - l) / 2;\\n            if (countle(nums1, nums2, mid) < k) {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    int64_t countle(const vector<int>& nums1,\\n                    const vector<int>& nums2,\\n                    int64_t k) {\\n        const auto pos1 = partition_point(nums1.begin(),\\n                                          nums1.end(),\\n                                          [](const auto& x) { return x < 0; });\\n        const auto pos2 = partition_point(nums2.begin(),\\n                                          nums2.end(),\\n                                          [](const auto& x) { return x < 0; });\\n        const auto first1 = nums1.begin();\\n        const auto last1 = nums1.end();\\n        const auto first2 = nums2.begin();\\n        const auto last2 = nums2.end();\\n        return countle_in_sorted_matrix(pos1, last1, pos2, last2, k) +\\n               countle_in_sorted_matrix(first1,\\n                                        pos1,\\n                                        make_reverse_iterator(last2),\\n                                        make_reverse_iterator(pos2),\\n                                        k) +\\n               countle_in_sorted_matrix(make_reverse_iterator(pos1),\\n                                        make_reverse_iterator(first1),\\n                                        make_reverse_iterator(pos2),\\n                                        make_reverse_iterator(first2),\\n                                        k) +\\n               countle_in_sorted_matrix(make_reverse_iterator(last1),\\n                                        make_reverse_iterator(pos1),\\n                                        first2,\\n                                        pos2,\\n                                        k);\\n    }\\n\\n    template <class It1, class It2>\\n    int64_t countle_in_sorted_matrix(\\n        It1 first1, It1 last1, It2 first2, It2 last2, int64_t k) {\\n        int64_t cnt = 0;\\n        auto j = last2;\\n        for (auto it = first1; it != last1; ++it) {\\n            while (j != first2 && j[-1] * int64_t(*it) > k) {\\n                --j;\\n            }\\n            cnt += distance(first2, j);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946642,
                "title": "2040-kth-smallest-product-of-two-sorted-arrays-binary-search-2-pointers",
                "content": "This question involved using binary search on Ans-\\n\\n**key idea** - we keep find out the **number of product\\u2264 our mid value** and comparing it with our k\\nwe keep shortening our upper bound when we have found our ans.\\n\\nchallenges faced-\\n\\n1. **effectively calculating the number of products of array in O(N) time**\\nfor this we maintained a 2-pointer approach , since the array was sorted , we kept our **j pointer** to **last value of second array** and **i pointer** on **first value of second array** , if that value gave the answer less  than our num, all the values before that would give the same ans, so we update the cnt as j+1 and move i pointer ahead. Once j value reaches 0, increasing i pointer would not mean much and thus we exit out the loop.\\n\\n2.**handling negative numbers**\\n\\nour negative number would disturb the above approach and hence we have to handle them separately.\\n\\nWe first check **whether k lies in the negative side and positive side**, and according to that we proceed.\\n\\neg: if k lies in negative than we need only negative numbers to check and we multiply neg1 * pos2 and neg2 * pos1;\\n\\nalso **value of k decide which array we have to reverse**\\n\\n\\u2192if k is in negative side to effectively get negative products count we would have to r**everse positive numbers** so as to fit our above logic\\n\\neg: arr1 = [-2,-1], arr2 = [3,4]\\n\\n-2 * 4 = -8  < -7 but -2 * 3 =-6 > -7\\n\\n\\u2192by same logic when k is in positive side **we reverse negative numbers** to fit our logic\\n\\nI have taken low and high as most minimum and maximum values but you can take them as min and max value of products array\\n```\\nclass Solution {\\npublic:\\n    long long getnum(vector<int>& arr1,vector<int>& arr2,vector<int>& arr3,vector<int>& arr4,long long num){\\n        int i = 0;\\n        int j = arr2.size()-1;\\n        long long  cnt = 0;\\n        while(i<arr1.size() and j>=0 and arr2.size()>0){\\n            if(1l*arr1[i]*arr2[j]<=num){\\n                i++;\\n                cnt+=(j+1);\\n            }\\n            else j--;\\n        }\\n        i=0;j=arr4.size()-1;\\n        while(i<arr3.size() and j>=0 and arr4.size()>0){\\n            if(1l*arr3[i]*arr4[j]<=num){\\n                i++;\\n                cnt+=(j+1);\\n            }\\n            else j--;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        \\n        vector<int> pos1;\\n        vector<int> neg1;\\n        vector<int> pos2;\\n        vector<int> neg2;\\n        for(auto x:nums1){\\n            if(x<0){\\n                neg1.push_back(x);\\n            }\\n            else{\\n                pos1.push_back(x);\\n            }\\n        }\\n        for(auto x:nums2){\\n            if(x<0){\\n                neg2.push_back(x);\\n            }\\n            else{\\n                pos2.push_back(x);\\n            }\\n        }\\n        long long nofneg  = neg1.size() * pos2.size()  + neg2.size()*pos1.size();\\n        bool iskneg = k>nofneg?false:true;\\n        k = !iskneg?k-nofneg:k;\\n        if(!iskneg){\\n            reverse(neg1.begin(),neg1.end());\\n            reverse(neg2.begin(),neg2.end());\\n        }else{\\n            reverse(pos1.begin(),pos1.end());\\n            reverse(pos2.begin(),pos2.end());\\n        }\\n        long long low = -1e10,high = 1e10;\\n        while(low<high){\\n            long long mid = (long long)(low + (high-low)/2); \\n            if(getnum(pos1,iskneg?neg2:pos2,neg1,iskneg?pos2:neg2,mid)>=k){\\n                high = mid;\\n            }else{\\n                low = mid+1;\\n            }\\n            \\n        }\\n        return high;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getnum(vector<int>& arr1,vector<int>& arr2,vector<int>& arr3,vector<int>& arr4,long long num){\\n        int i = 0;\\n        int j = arr2.size()-1;\\n        long long  cnt = 0;\\n        while(i<arr1.size() and j>=0 and arr2.size()>0){\\n            if(1l*arr1[i]*arr2[j]<=num){\\n                i++;\\n                cnt+=(j+1);\\n            }\\n            else j--;\\n        }\\n        i=0;j=arr4.size()-1;\\n        while(i<arr3.size() and j>=0 and arr4.size()>0){\\n            if(1l*arr3[i]*arr4[j]<=num){\\n                i++;\\n                cnt+=(j+1);\\n            }\\n            else j--;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        \\n        vector<int> pos1;\\n        vector<int> neg1;\\n        vector<int> pos2;\\n        vector<int> neg2;\\n        for(auto x:nums1){\\n            if(x<0){\\n                neg1.push_back(x);\\n            }\\n            else{\\n                pos1.push_back(x);\\n            }\\n        }\\n        for(auto x:nums2){\\n            if(x<0){\\n                neg2.push_back(x);\\n            }\\n            else{\\n                pos2.push_back(x);\\n            }\\n        }\\n        long long nofneg  = neg1.size() * pos2.size()  + neg2.size()*pos1.size();\\n        bool iskneg = k>nofneg?false:true;\\n        k = !iskneg?k-nofneg:k;\\n        if(!iskneg){\\n            reverse(neg1.begin(),neg1.end());\\n            reverse(neg2.begin(),neg2.end());\\n        }else{\\n            reverse(pos1.begin(),pos1.end());\\n            reverse(pos2.begin(),pos2.end());\\n        }\\n        long long low = -1e10,high = 1e10;\\n        while(low<high){\\n            long long mid = (long long)(low + (high-low)/2); \\n            if(getnum(pos1,iskneg?neg2:pos2,neg1,iskneg?pos2:neg2,mid)>=k){\\n                high = mid;\\n            }else{\\n                low = mid+1;\\n            }\\n            \\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793270,
                "title": "c-binary-search-with-o-m-n-lg10-10",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <iostream>\\n#include <vector>\\n#include <chrono>\\n#include <limits>\\n#include <algorithm>\\n\\nusing std::vector;\\n\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& left, vector<int>& right, long long k) {\\n      long long min = 0l, max = 0l, mid = 0l;\\n      if (left[0] > 0) {\\n        if (right[0] > 0) {\\n          // \\u7EAF\\u6B63 \\u7EAF\\u6B63\\n          min = static_cast<long long>(left[0]) * static_cast<long long>(right[0]);\\n          max = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[right.size()-1]);\\n        } else if (right[right.size()-1] <= 0) {\\n          // \\u7EAF\\u6B63 \\u7EAF\\u8D1F\\n          min = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[0]);\\n          max = static_cast<long long>(left[0]) * static_cast<long long>(right[right.size()-1]);\\n        } else {\\n          // \\u7EAF\\u6B63 \\u6DF7\\u5408\\n          min = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[0]);\\n          max = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[right.size()-1]);\\n        }\\n      } else if (left[left.size()-1] <= 0) {\\n        if (right[0] > 0) {\\n          // \\u7EAF\\u8D1F \\u7EAF\\u6B63\\n          min = static_cast<long long>(left[0]) * static_cast<long long>(right[right.size()-1]);\\n          max = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[0]);\\n        } else if (right[right.size()-1] <= 0) {\\n          // \\u7EAF\\u8D1F \\u7EAF\\u8D1F\\n          min = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[right.size()-1]);\\n          max = static_cast<long long>(left[0]) * static_cast<long long>(right[0]);\\n        } else {\\n          // \\u7EAF\\u8D1F \\u6DF7\\u5408\\n          min = static_cast<long long>(left[0]) * static_cast<long long>(right[right.size()-1]);\\n          max = static_cast<long long>(left[0]) * static_cast<long long>(right[0]);\\n        }\\n      } else {\\n        if (right[0] > 0) {\\n          // \\u6DF7\\u5408 \\u7EAF\\u6B63\\n          min = static_cast<long long>(left[0]) * static_cast<long long>(right[right.size()-1]);\\n          max = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[right.size()-1]);\\n        } else if (right[right.size()-1] <= 0) {\\n          // \\u6DF7\\u5408 \\u7EAF\\u8D1F\\n          min = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[0]);\\n          max = static_cast<long long>(left[0]) * static_cast<long long>(right[0]);\\n        } else {\\n          // \\u6DF7\\u5408 \\u6DF7\\u5408\\n          min = std::min(left[0] * static_cast<long long>(right[right.size()-1]), static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[0]));\\n          max = std::max(left[0] * static_cast<long long>(right[0]), static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[right.size()-1]));\\n        }\\n      }\\n\\n      auto findLastNegative = [](vector<int>& nums) -> const int {\\n        int i = 0;\\n        for (; i < nums.size(); i++) {\\n          if (nums[i] >= 0) {\\n            return i-1;\\n          }\\n        }\\n        return nums.size()-1;\\n      };\\n      auto findFirstPositive = [](vector<int>& nums) -> const int {\\n        int i = 0;\\n        for (; i < nums.size(); i++) {\\n          if (nums[i] > 0) {\\n            return i;\\n          }\\n        }\\n        return nums.size();\\n      };\\n\\n      int lx = findLastNegative(left);\\n      int ly = findFirstPositive(left);\\n      int rx = findLastNegative(right);\\n      int ry = findFirstPositive(right);\\n\\n      while (true) {\\n        if (max - min <= 1) {\\n          if (find(left, right, min, lx, ly, rx, ry) >= k) {\\n            return min;\\n          } else {\\n            return max;\\n          }\\n        }\\n\\n        mid = (min+max)/2;\\n        if (find(left, right, mid, lx, ly, rx, ry) < k) {\\n          min = mid;\\n        } else {\\n          max = mid;\\n        }\\n      }\\n      return mid;\\n    }\\n\\n    long long find(vector<int>& left, vector<int>& right, long long target, int lx, int ly, int rx, int ry) {\\n      long long k = 0;\\n      if (target >= 0l) {\\n        // -8, -4, -2, -1, 0, 1, 2, 4, 8 -> 3, 5\\n        // -8, -4, -2, -1, 0, 1, 2, 4, 8 -> 3, 5\\n        k += static_cast<long long>(lx+1)*static_cast<long long>((right.size()-ry));      // left \\u7684\\u8D1F\\u6570 * right \\u7684\\u6B63\\u6570\\n        k += static_cast<long long>(left.size()-ly)*static_cast<long long>((rx+1));       // left \\u7684\\u6B63\\u6570 * right \\u7684\\u8D1F\\u6570\\n        k += static_cast<long long>(ly-lx-1)*static_cast<long long>(right.size());        // left \\u7684\\u96F6 * right\\n        k += static_cast<long long>(ry-rx-1)*static_cast<long long>(left.size());         // right \\u7684\\u96F6 * left\\n        k -= static_cast<long long>(ly-lx-1)*static_cast<long long>((ry-rx-1));           // left \\u7684\\u96F6 * right \\u7684\\u96F6\\n\\n        int i = 0, j = rx;\\n        // -8, -4, -2, -1\\n        // -8, -4, -2, -1\\n        for (; i <= lx; i++) {\\n          // j \\u662F\\u4ECE\\u53F3\\u5F80\\u5DE6\\u7B2C\\u4E00\\u4E2A\\u4E0D\\u6EE1\\u8DB3\\u7684\\u8D1F\\u6570\\n          while (j >= 0) {\\n            long long d = static_cast<long long>(left[i]) * static_cast<long long>(right[j]);\\n            if (d <= target) {\\n              j--;\\n            } else {\\n              break;\\n            }\\n          }\\n          k += static_cast<long long>(rx-j);\\n        }\\n\\n        // 1, 2, 4, 8 -> 3,5\\n        // 1, 2, 4, 8 -> 3,5\\n        j = right.size()-1;\\n        for (i = ly; i < left.size(); i++) {\\n          // j \\u662F\\u4ECE\\u53F3\\u5F80\\u5DE6, \\u6700\\u540E\\u4E00\\u4E2A\\u6EE1\\u8DB3\\u7684\\n          while (j >= ry) {\\n            long long d = static_cast<long long>(left[i]) * static_cast<long long>(right[j]);\\n            if (d > target) {\\n              j--;\\n            } else {\\n              break;\\n            }\\n          }\\n          k += static_cast<long long>(j-ry+1);\\n        }\\n      } else {\\n        int i = 0, j = ry;\\n        // -8, -4, -2, -1 -> 3,5\\n        // 1, 2, 4, 8 -> 3,5\\n        for (; i <= lx; i++) {\\n          // j \\u662F\\u4ECE\\u5DE6\\u5F80\\u53F3, \\u7B2C\\u4E00\\u4E2A\\u6EE1\\u8DB3\\u7684\\n          while (j < right.size()) {\\n            long long d = static_cast<long long>(left[i]) * static_cast<long long>(right[j]);\\n            if (d > target) {\\n              j++;\\n            } else {\\n              break;\\n            }\\n          }\\n          k += static_cast<long long>(right.size()-j);\\n        }\\n\\n        // 1, 2, 3, 4\\n        // -8,-4,-2,-1\\n        j = 0;\\n        for(i = ly; i < left.size(); i++) {\\n          // j \\u4ECE\\u5DE6\\u5F80\\u53F3, \\u7B2C\\u4E00\\u4E2A\\u4E0D\\u6EE1\\u8DB3\\u7684\\n          while (j <= rx) {\\n            long long d = static_cast<long long>(left[i]) * static_cast<long long>(right[j]);\\n            if (d <= target) {\\n              j++;\\n            } else {\\n              break;\\n            }\\n          }\\n          k += static_cast<long long>(j);\\n        }\\n      }\\n\\n      return k;\\n    }\\n\\n    int countLess(vector<int>& right, int curr, int target) {\\n      for (; curr >= 0; curr--) {\\n        if (right[curr] <= target) {\\n          return curr;\\n        }\\n      }\\n      return -1;\\n    }\\n\\n    int countGreater(vector<int>& right, int curr, int target) {\\n      for (; curr >= 0; curr--) {\\n        if (right[curr] < target) {\\n          return curr+1;\\n        }\\n      }\\n      return right.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <iostream>\\n#include <vector>\\n#include <chrono>\\n#include <limits>\\n#include <algorithm>\\n\\nusing std::vector;\\n\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& left, vector<int>& right, long long k) {\\n      long long min = 0l, max = 0l, mid = 0l;\\n      if (left[0] > 0) {\\n        if (right[0] > 0) {\\n          // \\u7EAF\\u6B63 \\u7EAF\\u6B63\\n          min = static_cast<long long>(left[0]) * static_cast<long long>(right[0]);\\n          max = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[right.size()-1]);\\n        } else if (right[right.size()-1] <= 0) {\\n          // \\u7EAF\\u6B63 \\u7EAF\\u8D1F\\n          min = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[0]);\\n          max = static_cast<long long>(left[0]) * static_cast<long long>(right[right.size()-1]);\\n        } else {\\n          // \\u7EAF\\u6B63 \\u6DF7\\u5408\\n          min = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[0]);\\n          max = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[right.size()-1]);\\n        }\\n      } else if (left[left.size()-1] <= 0) {\\n        if (right[0] > 0) {\\n          // \\u7EAF\\u8D1F \\u7EAF\\u6B63\\n          min = static_cast<long long>(left[0]) * static_cast<long long>(right[right.size()-1]);\\n          max = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[0]);\\n        } else if (right[right.size()-1] <= 0) {\\n          // \\u7EAF\\u8D1F \\u7EAF\\u8D1F\\n          min = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[right.size()-1]);\\n          max = static_cast<long long>(left[0]) * static_cast<long long>(right[0]);\\n        } else {\\n          // \\u7EAF\\u8D1F \\u6DF7\\u5408\\n          min = static_cast<long long>(left[0]) * static_cast<long long>(right[right.size()-1]);\\n          max = static_cast<long long>(left[0]) * static_cast<long long>(right[0]);\\n        }\\n      } else {\\n        if (right[0] > 0) {\\n          // \\u6DF7\\u5408 \\u7EAF\\u6B63\\n          min = static_cast<long long>(left[0]) * static_cast<long long>(right[right.size()-1]);\\n          max = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[right.size()-1]);\\n        } else if (right[right.size()-1] <= 0) {\\n          // \\u6DF7\\u5408 \\u7EAF\\u8D1F\\n          min = static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[0]);\\n          max = static_cast<long long>(left[0]) * static_cast<long long>(right[0]);\\n        } else {\\n          // \\u6DF7\\u5408 \\u6DF7\\u5408\\n          min = std::min(left[0] * static_cast<long long>(right[right.size()-1]), static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[0]));\\n          max = std::max(left[0] * static_cast<long long>(right[0]), static_cast<long long>(left[left.size()-1]) * static_cast<long long>(right[right.size()-1]));\\n        }\\n      }\\n\\n      auto findLastNegative = [](vector<int>& nums) -> const int {\\n        int i = 0;\\n        for (; i < nums.size(); i++) {\\n          if (nums[i] >= 0) {\\n            return i-1;\\n          }\\n        }\\n        return nums.size()-1;\\n      };\\n      auto findFirstPositive = [](vector<int>& nums) -> const int {\\n        int i = 0;\\n        for (; i < nums.size(); i++) {\\n          if (nums[i] > 0) {\\n            return i;\\n          }\\n        }\\n        return nums.size();\\n      };\\n\\n      int lx = findLastNegative(left);\\n      int ly = findFirstPositive(left);\\n      int rx = findLastNegative(right);\\n      int ry = findFirstPositive(right);\\n\\n      while (true) {\\n        if (max - min <= 1) {\\n          if (find(left, right, min, lx, ly, rx, ry) >= k) {\\n            return min;\\n          } else {\\n            return max;\\n          }\\n        }\\n\\n        mid = (min+max)/2;\\n        if (find(left, right, mid, lx, ly, rx, ry) < k) {\\n          min = mid;\\n        } else {\\n          max = mid;\\n        }\\n      }\\n      return mid;\\n    }\\n\\n    long long find(vector<int>& left, vector<int>& right, long long target, int lx, int ly, int rx, int ry) {\\n      long long k = 0;\\n      if (target >= 0l) {\\n        // -8, -4, -2, -1, 0, 1, 2, 4, 8 -> 3, 5\\n        // -8, -4, -2, -1, 0, 1, 2, 4, 8 -> 3, 5\\n        k += static_cast<long long>(lx+1)*static_cast<long long>((right.size()-ry));      // left \\u7684\\u8D1F\\u6570 * right \\u7684\\u6B63\\u6570\\n        k += static_cast<long long>(left.size()-ly)*static_cast<long long>((rx+1));       // left \\u7684\\u6B63\\u6570 * right \\u7684\\u8D1F\\u6570\\n        k += static_cast<long long>(ly-lx-1)*static_cast<long long>(right.size());        // left \\u7684\\u96F6 * right\\n        k += static_cast<long long>(ry-rx-1)*static_cast<long long>(left.size());         // right \\u7684\\u96F6 * left\\n        k -= static_cast<long long>(ly-lx-1)*static_cast<long long>((ry-rx-1));           // left \\u7684\\u96F6 * right \\u7684\\u96F6\\n\\n        int i = 0, j = rx;\\n        // -8, -4, -2, -1\\n        // -8, -4, -2, -1\\n        for (; i <= lx; i++) {\\n          // j \\u662F\\u4ECE\\u53F3\\u5F80\\u5DE6\\u7B2C\\u4E00\\u4E2A\\u4E0D\\u6EE1\\u8DB3\\u7684\\u8D1F\\u6570\\n          while (j >= 0) {\\n            long long d = static_cast<long long>(left[i]) * static_cast<long long>(right[j]);\\n            if (d <= target) {\\n              j--;\\n            } else {\\n              break;\\n            }\\n          }\\n          k += static_cast<long long>(rx-j);\\n        }\\n\\n        // 1, 2, 4, 8 -> 3,5\\n        // 1, 2, 4, 8 -> 3,5\\n        j = right.size()-1;\\n        for (i = ly; i < left.size(); i++) {\\n          // j \\u662F\\u4ECE\\u53F3\\u5F80\\u5DE6, \\u6700\\u540E\\u4E00\\u4E2A\\u6EE1\\u8DB3\\u7684\\n          while (j >= ry) {\\n            long long d = static_cast<long long>(left[i]) * static_cast<long long>(right[j]);\\n            if (d > target) {\\n              j--;\\n            } else {\\n              break;\\n            }\\n          }\\n          k += static_cast<long long>(j-ry+1);\\n        }\\n      } else {\\n        int i = 0, j = ry;\\n        // -8, -4, -2, -1 -> 3,5\\n        // 1, 2, 4, 8 -> 3,5\\n        for (; i <= lx; i++) {\\n          // j \\u662F\\u4ECE\\u5DE6\\u5F80\\u53F3, \\u7B2C\\u4E00\\u4E2A\\u6EE1\\u8DB3\\u7684\\n          while (j < right.size()) {\\n            long long d = static_cast<long long>(left[i]) * static_cast<long long>(right[j]);\\n            if (d > target) {\\n              j++;\\n            } else {\\n              break;\\n            }\\n          }\\n          k += static_cast<long long>(right.size()-j);\\n        }\\n\\n        // 1, 2, 3, 4\\n        // -8,-4,-2,-1\\n        j = 0;\\n        for(i = ly; i < left.size(); i++) {\\n          // j \\u4ECE\\u5DE6\\u5F80\\u53F3, \\u7B2C\\u4E00\\u4E2A\\u4E0D\\u6EE1\\u8DB3\\u7684\\n          while (j <= rx) {\\n            long long d = static_cast<long long>(left[i]) * static_cast<long long>(right[j]);\\n            if (d <= target) {\\n              j++;\\n            } else {\\n              break;\\n            }\\n          }\\n          k += static_cast<long long>(j);\\n        }\\n      }\\n\\n      return k;\\n    }\\n\\n    int countLess(vector<int>& right, int curr, int target) {\\n      for (; curr >= 0; curr--) {\\n        if (right[curr] <= target) {\\n          return curr;\\n        }\\n      }\\n      return -1;\\n    }\\n\\n    int countGreater(vector<int>& right, int curr, int target) {\\n      for (; curr >= 0; curr--) {\\n        if (right[curr] < target) {\\n          return curr+1;\\n        }\\n      }\\n      return right.size();\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3597303,
                "title": "c-solution",
                "content": "C# solutin based on this explanation https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/solutions/1524856/binary-search-with-detailed-explanation/\\n\\n# Code\\n```\\npublic class Solution {\\n    public long KthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        var a1 = nums1.Where(x => x < 0).ToArray();\\n        a1 = rev(inv(a1));\\n        var a2 = nums1.Where(x => x >= 0).ToArray();\\n        var b1 = nums2.Where(x => x < 0).ToArray();\\n        b1 = rev(inv(b1));\\n        var b2 = nums2.Where(x => x >= 0).ToArray();\\n\\n        var negCount = a1.Length * b2.Length + b1.Length * a2.Length;\\n\\n        var sign = 1;\\n\\n        if (k > negCount)\\n        {\\n            k -= negCount;\\n        }\\n        else\\n        {\\n            k = negCount - k + 1;\\n            var temp = b1;\\n            b1 = b2;\\n            b2 = temp;\\n            sign = -1;\\n        }\\n\\n\\n        var lo = 0L;\\n        var hi = 10000000000L;\\n\\n        while (lo < hi)\\n        {\\n            var mid = (lo + hi) / 2;\\n            var count = CountProductsSmallerOrEqualToNumber(mid, a1, b1)\\n             + CountProductsSmallerOrEqualToNumber(mid, a2, b2);\\n            Console.WriteLine($\"guess: {mid}. count: {count}\");\\n            if (count >= k)\\n            {\\n                hi = mid;\\n            }\\n            else\\n            {\\n                lo = mid + 1;\\n            }\\n        }\\n        return sign * lo;\\n    }\\n\\n    public long CountProductsSmallerOrEqualToNumber(long number, int[] nums1, int[] nums2)\\n    {\\n        var count = 0L;\\n        var j = nums2.Length - 1;\\n        for (int i = 0; i < nums1.Length && j >= 0; i++)\\n        {\\n            while (j >= 0 && (long)nums1[i] * (long)nums2[j] > number)\\n            {\\n                j--;\\n            }\\n            count += j + 1;\\n\\n        }\\n        return count;\\n    }\\n\\n    public int[] inv(int[] nums)\\n    {\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            nums[i] = -nums[i];\\n\\n        }\\n        return nums;\\n\\n    }\\n\\n    public int[] rev(int[] nums)\\n    {\\n        for (int l = 0, r = nums.Length - 1; l < r; l++, r--)\\n        {\\n            nums[l] ^= nums[r];\\n            nums[r] ^= nums[l];\\n            nums[l] ^= nums[r];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long KthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        var a1 = nums1.Where(x => x < 0).ToArray();\\n        a1 = rev(inv(a1));\\n        var a2 = nums1.Where(x => x >= 0).ToArray();\\n        var b1 = nums2.Where(x => x < 0).ToArray();\\n        b1 = rev(inv(b1));\\n        var b2 = nums2.Where(x => x >= 0).ToArray();\\n\\n        var negCount = a1.Length * b2.Length + b1.Length * a2.Length;\\n\\n        var sign = 1;\\n\\n        if (k > negCount)\\n        {\\n            k -= negCount;\\n        }\\n        else\\n        {\\n            k = negCount - k + 1;\\n            var temp = b1;\\n            b1 = b2;\\n            b2 = temp;\\n            sign = -1;\\n        }\\n\\n\\n        var lo = 0L;\\n        var hi = 10000000000L;\\n\\n        while (lo < hi)\\n        {\\n            var mid = (lo + hi) / 2;\\n            var count = CountProductsSmallerOrEqualToNumber(mid, a1, b1)\\n             + CountProductsSmallerOrEqualToNumber(mid, a2, b2);\\n            Console.WriteLine($\"guess: {mid}. count: {count}\");\\n            if (count >= k)\\n            {\\n                hi = mid;\\n            }\\n            else\\n            {\\n                lo = mid + 1;\\n            }\\n        }\\n        return sign * lo;\\n    }\\n\\n    public long CountProductsSmallerOrEqualToNumber(long number, int[] nums1, int[] nums2)\\n    {\\n        var count = 0L;\\n        var j = nums2.Length - 1;\\n        for (int i = 0; i < nums1.Length && j >= 0; i++)\\n        {\\n            while (j >= 0 && (long)nums1[i] * (long)nums2[j] > number)\\n            {\\n                j--;\\n            }\\n            count += j + 1;\\n\\n        }\\n        return count;\\n    }\\n\\n    public int[] inv(int[] nums)\\n    {\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            nums[i] = -nums[i];\\n\\n        }\\n        return nums;\\n\\n    }\\n\\n    public int[] rev(int[] nums)\\n    {\\n        for (int l = 0, r = nums.Length - 1; l < r; l++, r--)\\n        {\\n            nums[l] ^= nums[r];\\n            nums[r] ^= nums[l];\\n            nums[l] ^= nums[r];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511768,
                "title": "one-of-the-best-intitution-for-2-binary-search-used-and-reduse-time-complexity-in-1-sec",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n\\n\\tll countKaroProducts(vector<int>& a, vector<int>& b, long long mid) {\\n\\t\\tll totalNumbersLessThanMid = 0;\\n\\t\\tfor (auto el : a) {\\n\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\tif (el >= 0) {   //positive number check  number >=0\\n\\t\\t\\t\\tll s = 0, e = b.size() - 1;  //0 to n-1\\n\\t\\t\\t\\twhile (s <= e) {\\n\\t\\t\\t\\t\\tll m = (s + e) / 2;\\n\\t\\t\\t\\t\\tif ((ll)((ll)el * (ll)b[m]) <= mid) {\\n\\t\\t\\t\\t\\t\\tcnt = m + 1;  //if number is less then mid then we can say all less no are negetive\\n\\t\\t\\t\\t\\t\\ts = m + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\te = m - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttotalNumbersLessThanMid += cnt;\\n\\t\\t\\t}\\n\\t\\t\\telse {   //negetive number search\\n\\t\\t\\t\\tll s = 0, e = b.size() - 1;\\n\\t\\t\\t\\twhile (s <= e) {\\n\\t\\t\\t\\t\\tll m = (s + e) / 2;\\n\\t\\t\\t\\t\\tif ((ll)((ll)el * (ll)b[m]) <= mid) {\\n\\t\\t\\t\\t\\t\\tcnt = b.size() - m;\\n\\t\\t\\t\\t\\t\\te = m - 1;    //check any elemet left from mid-1 if then include\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\ts = m + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttotalNumbersLessThanMid += cnt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn totalNumbersLessThanMid;\\n\\t}\\n\\n\\tlong long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n\\t\\tll s = -1e10;\\n\\t\\tll e = 1e10;\\n\\t\\tll ans;\\n\\t\\twhile (s <= e) { // log(2*10^10)\\n\\t\\t\\tll mid = ((ll)(s + e)) / 2;\\n\\t\\t\\tif (countKaroProducts(nums1, nums2, mid) >= k) {\\n\\t\\t\\t\\tans = mid;   \\n\\t\\t\\t\\te = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\ts = mid + 1;  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n\\n\\tll countKaroProducts(vector<int>& a, vector<int>& b, long long mid) {\\n\\t\\tll totalNumbersLessThanMid = 0;\\n\\t\\tfor (auto el : a) {\\n\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\tif (el >= 0) {   //positive number check  number >=0\\n\\t\\t\\t\\tll s = 0, e = b.size() - 1;  //0 to n-1\\n\\t\\t\\t\\twhile (s <= e) {\\n\\t\\t\\t\\t\\tll m = (s + e) / 2;\\n\\t\\t\\t\\t\\tif ((ll)((ll)el * (ll)b[m]) <= mid) {\\n\\t\\t\\t\\t\\t\\tcnt = m + 1;  //if number is less then mid then we can say all less no are negetive\\n\\t\\t\\t\\t\\t\\ts = m + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\te = m - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttotalNumbersLessThanMid += cnt;\\n\\t\\t\\t}\\n\\t\\t\\telse {   //negetive number search\\n\\t\\t\\t\\tll s = 0, e = b.size() - 1;\\n\\t\\t\\t\\twhile (s <= e) {\\n\\t\\t\\t\\t\\tll m = (s + e) / 2;\\n\\t\\t\\t\\t\\tif ((ll)((ll)el * (ll)b[m]) <= mid) {\\n\\t\\t\\t\\t\\t\\tcnt = b.size() - m;\\n\\t\\t\\t\\t\\t\\te = m - 1;    //check any elemet left from mid-1 if then include\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\ts = m + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttotalNumbersLessThanMid += cnt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn totalNumbersLessThanMid;\\n\\t}\\n\\n\\tlong long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n\\t\\tll s = -1e10;\\n\\t\\tll e = 1e10;\\n\\t\\tll ans;\\n\\t\\twhile (s <= e) { // log(2*10^10)\\n\\t\\t\\tll mid = ((ll)(s + e)) / 2;\\n\\t\\t\\tif (countKaroProducts(nums1, nums2, mid) >= k) {\\n\\t\\t\\t\\tans = mid;   \\n\\t\\t\\t\\te = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\ts = mid + 1;  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358948,
                "title": "c-binary-search-solution",
                "content": "\\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\n\\n    bool isPossible(vector<int>& a, vector<int>& b,  ll midVal, ll k) {\\n        ll cnt = 0;\\n        for(auto num: a) {\\n            if(num >= 0) { // smallest products will be on left side\\n                \\n                ll l = 0, h = b.size() - 1, res = -1;\\n                while(l <= h) {\\n                    ll mid = (l + h) / 2;\\n\\n                    if((long long) b[mid] * num <= midVal) {\\n                        l = mid + 1;\\n                        res = mid; // go higher because ve * -ve = -ve;\\n                    } else\\n                        h = mid - 1;\\n                }\\n                \\n                cnt += res + 1; // left side to maximum side\\n                \\n            } else { // smallest products will be on right side\\n     \\n                ll l = 0, h = b.size() - 1, res = b.size();\\n                while(l <= h) {\\n                    ll mid = (l + h) / 2;\\n\\n                    if((long long) b[mid] * num <= midVal) {\\n                        h = mid - 1;\\n                        res = mid; // go lower because -ve * +ve = -ve\\n                    } else\\n                        l = mid + 1;\\n                }\\n                \\n                cnt += b.size() - res; // left side to maximum side\\n                \\n            }\\n        }\\n\\n        return cnt >= k;\\n    }\\n\\npublic:\\n    ll kthSmallestProduct(vector<int>& a, vector<int>& b, ll k) {\\n        ll low = -1e10;\\n        ll high = 1e10; \\n        ll res = 0;\\n\\n        while(low <= high) {\\n            ll mid = (low + high) / 2;\\n            if(isPossible(a, b, mid, k)) {\\n                res = mid;\\n                high = mid - 1;\\n            } else\\n                low = mid + 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\n\\n    bool isPossible(vector<int>& a, vector<int>& b,  ll midVal, ll k) {\\n        ll cnt = 0;\\n        for(auto num: a) {\\n            if(num >= 0) { // smallest products will be on left side\\n                \\n                ll l = 0, h = b.size() - 1, res = -1;\\n                while(l <= h) {\\n                    ll mid = (l + h) / 2;\\n\\n                    if((long long) b[mid] * num <= midVal) {\\n                        l = mid + 1;\\n                        res = mid; // go higher because ve * -ve = -ve;\\n                    } else\\n                        h = mid - 1;\\n                }\\n                \\n                cnt += res + 1; // left side to maximum side\\n                \\n            } else { // smallest products will be on right side\\n     \\n                ll l = 0, h = b.size() - 1, res = b.size();\\n                while(l <= h) {\\n                    ll mid = (l + h) / 2;\\n\\n                    if((long long) b[mid] * num <= midVal) {\\n                        h = mid - 1;\\n                        res = mid; // go lower because -ve * +ve = -ve\\n                    } else\\n                        l = mid + 1;\\n                }\\n                \\n                cnt += b.size() - res; // left side to maximum side\\n                \\n            }\\n        }\\n\\n        return cnt >= k;\\n    }\\n\\npublic:\\n    ll kthSmallestProduct(vector<int>& a, vector<int>& b, ll k) {\\n        ll low = -1e10;\\n        ll high = 1e10; \\n        ll res = 0;\\n\\n        while(low <= high) {\\n            ll mid = (low + high) / 2;\\n            if(isPossible(a, b, mid, k)) {\\n                res = mid;\\n                high = mid - 1;\\n            } else\\n                low = mid + 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287387,
                "title": "binary-search-with-visualization-for-different-regions-java-79ms-100",
                "content": "# Intuition\\nIt\\'s basically the same idea as \"\". Just that we should separate the matrix into four regions, as the order in each region is different and we should traverse the matrix from different starting position and in different direction. A general rule to remember is that \"**starting from the max value of a column and walk along ascending direction to the next column**\".\\n\\nA visualization of the four regions are: \\n![5C144E9C-88C2-4B8E-BE1E-DBA5633F0D84.jpeg](https://assets.leetcode.com/users/images/12fce226-b138-4903-bb69-a24e10db9f8c_1678606895.7290757.jpeg)\\n\\n#### Triky Points to Notice\\n1. `k` could exceed the integer limit. So the return type of the count function should be `long`.\\n2. The product could also exceed the integer limit. Cast to `long` before computing the product.\\n\\n# Code\\n```\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        if (nums1.length == 1 && nums2.length == 1)\\n            return nums1[0] * nums2[0];\\n\\n        long[] extremes = {(long) nums1[0] * nums2[0],\\n                (long) nums1[0] * nums2[nums2.length - 1],\\n                (long) nums1[nums1.length - 1] * nums2[0],\\n                (long) nums1[nums1.length - 1] * nums2[nums2.length - 1]};\\n        Arrays.sort(extremes);\\n        int firstNonNegative1 = binarySearch(nums1, 0);\\n        int firstNonNegative2 = binarySearch(nums2, 0);\\n        long low = extremes[0];\\n        long high = extremes[3];\\n        //System.out.println(\"Indices: \" \\n        //        + String.join(\",\", String.valueOf(firstNonNegative1), String.valueOf(firstNonNegative2)));\\n        //System.out.println(\"Boundary: \"\\n        //        + String.join(\",\", String.valueOf(low), String.valueOf(high)));\\n        while(low < high) {\\n            long mid = low + (high - low) / 2;\\n            if (countLessThan(nums1, nums2, firstNonNegative1, firstNonNegative2, mid) < k) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n        m: index of first element >= 0 in nums1.\\n        n: index of first element >= 0 in nums2.\\n     */\\n    private long countLessThan(int[] nums1, int[] nums2, int m, int n, long target) {\\n        long count = 0;\\n        // First Region:\\n        int row = 0;\\n        int col = n - 1;\\n        while(row < m && col >= 0) {\\n            while(row < m && ((long) nums1[row]) * nums2[col] > target) {\\n                row++;\\n            }\\n            count += m - row;\\n            col--;\\n        }\\n\\n        // Second Region:\\n        row = m;\\n        col = 0;\\n        while(row < nums1.length && col < n) {\\n            while(row < nums1.length && ((long) nums1[row]) * nums2[col] > target) {\\n                row++;\\n            }\\n            count += nums1.length - row;\\n            col++;\\n        }\\n\\n        // Third Region:\\n        row = m - 1;\\n        col = nums2.length - 1;\\n        while(row >= 0 && col >= n) {\\n            while(row >= 0 && ((long) nums1[row]) * nums2[col] > target) {\\n                row--;\\n            }\\n            count += row - 0 + 1;\\n            col--;\\n        }\\n\\n        // Fourth Region:\\n        row = nums1.length - 1;\\n        col = n;\\n        while(row >= m && col < nums2.length) {\\n            while(row >= m && ((long) nums1[row]) * nums2[col] > target) {\\n                row--;\\n            }\\n            count += row - m + 1;\\n            col++;\\n        }\\n        return count;\\n    }\\n\\n    // Find the leftmost element that >= than target.\\n    private int binarySearch(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length;\\n        while(left < right) {\\n            int mid = (left + right) / 2;\\n            if (nums[mid] >= target) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        if (nums1.length == 1 && nums2.length == 1)\\n            return nums1[0] * nums2[0];\\n\\n        long[] extremes = {(long) nums1[0] * nums2[0],\\n                (long) nums1[0] * nums2[nums2.length - 1],\\n                (long) nums1[nums1.length - 1] * nums2[0],\\n                (long) nums1[nums1.length - 1] * nums2[nums2.length - 1]};\\n        Arrays.sort(extremes);\\n        int firstNonNegative1 = binarySearch(nums1, 0);\\n        int firstNonNegative2 = binarySearch(nums2, 0);\\n        long low = extremes[0];\\n        long high = extremes[3];\\n        //System.out.println(\"Indices: \" \\n        //        + String.join(\",\", String.valueOf(firstNonNegative1), String.valueOf(firstNonNegative2)));\\n        //System.out.println(\"Boundary: \"\\n        //        + String.join(\",\", String.valueOf(low), String.valueOf(high)));\\n        while(low < high) {\\n            long mid = low + (high - low) / 2;\\n            if (countLessThan(nums1, nums2, firstNonNegative1, firstNonNegative2, mid) < k) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n        m: index of first element >= 0 in nums1.\\n        n: index of first element >= 0 in nums2.\\n     */\\n    private long countLessThan(int[] nums1, int[] nums2, int m, int n, long target) {\\n        long count = 0;\\n        // First Region:\\n        int row = 0;\\n        int col = n - 1;\\n        while(row < m && col >= 0) {\\n            while(row < m && ((long) nums1[row]) * nums2[col] > target) {\\n                row++;\\n            }\\n            count += m - row;\\n            col--;\\n        }\\n\\n        // Second Region:\\n        row = m;\\n        col = 0;\\n        while(row < nums1.length && col < n) {\\n            while(row < nums1.length && ((long) nums1[row]) * nums2[col] > target) {\\n                row++;\\n            }\\n            count += nums1.length - row;\\n            col++;\\n        }\\n\\n        // Third Region:\\n        row = m - 1;\\n        col = nums2.length - 1;\\n        while(row >= 0 && col >= n) {\\n            while(row >= 0 && ((long) nums1[row]) * nums2[col] > target) {\\n                row--;\\n            }\\n            count += row - 0 + 1;\\n            col--;\\n        }\\n\\n        // Fourth Region:\\n        row = nums1.length - 1;\\n        col = n;\\n        while(row >= m && col < nums2.length) {\\n            while(row >= m && ((long) nums1[row]) * nums2[col] > target) {\\n                row--;\\n            }\\n            count += row - m + 1;\\n            col++;\\n        }\\n        return count;\\n    }\\n\\n    // Find the leftmost element that >= than target.\\n    private int binarySearch(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length;\\n        while(left < right) {\\n            int mid = (left + right) / 2;\\n            if (nums[mid] >= target) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835965,
                "title": "c-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long kthSmallestProduct(vector<int>& A, vector<int>& B, long long k) {\\n        ll l = -1e10, r = 1e10;\\n        auto count_le = [&](ll x){\\n            ll total = 0;\\n            for(auto a : A) {\\n                if(a > 0) {\\n                    int l = 0, r = B.size()-1;\\n                    while(l < r) {\\n                        int m = l + (r-l+1)/2;\\n                        if((ll)a*B[m] > x) r = m-1;\\n                        else l = m;\\n                    }\\n                    total += (ll)a*B[l] <= x ? l+1 : 0;\\n                } else {\\n                    int l = 0, r = B.size()-1;\\n                    while(l < r) {\\n                        int m = l + (r-l)/2;\\n                        if((ll)a*B[m] > x) l = m+1;\\n                        else r = m;\\n                    }\\n                    total += (ll)a*B[l] <= x ? B.size() -l : 0;\\n                }\\n            }\\n            return total;\\n        };\\n\\n        while(l < r) {\\n            ll x = l + (r-l)/2;\\n            if(count_le(x) < k) l = x+1;\\n            else r = x;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long kthSmallestProduct(vector<int>& A, vector<int>& B, long long k) {\\n        ll l = -1e10, r = 1e10;\\n        auto count_le = [&](ll x){\\n            ll total = 0;\\n            for(auto a : A) {\\n                if(a > 0) {\\n                    int l = 0, r = B.size()-1;\\n                    while(l < r) {\\n                        int m = l + (r-l+1)/2;\\n                        if((ll)a*B[m] > x) r = m-1;\\n                        else l = m;\\n                    }\\n                    total += (ll)a*B[l] <= x ? l+1 : 0;\\n                } else {\\n                    int l = 0, r = B.size()-1;\\n                    while(l < r) {\\n                        int m = l + (r-l)/2;\\n                        if((ll)a*B[m] > x) l = m+1;\\n                        else r = m;\\n                    }\\n                    total += (ll)a*B[l] <= x ? B.size() -l : 0;\\n                }\\n            }\\n            return total;\\n        };\\n\\n        while(l < r) {\\n            ll x = l + (r-l)/2;\\n            if(count_le(x) < k) l = x+1;\\n            else r = x;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760350,
                "title": "binarysearch-counting-fully-explained-python",
                "content": "there can be |nums1| * |nums2| products, so finding every product and then couting k smallest is too slow.\\n\\nIf you knew what k was, can you count number of products less than k?\\nIf intgers were all positive heres how u would do it in O(n) time\\nMaintatin two pointers (i, j), one points to beggining of arr1 and other to the end of arr2.\\n```\\nIf nums[i]*nums[j] <= k, count += (j + 1),\\n```\\nbecause all elements to the left of j also satisfy the inequality.\\n```\\nif nums[i]*nums[j] > k, j -= 1,\\n```\\nbecause all elements to the right of i will also not work with nums[j]\\n\\nBut elements can also be negative and in this case you just need to handle them separately.\\n\\nNow that you have an efficient way of counting, u still dont know k.\\n**But you can guess k using binary search.**\\n```\\nif countOfProducts(guess) < k, guess is too small\\nif countOfProducts(guess) > k, guess is too large\\n```\\n\\n**Time: O(n * log(maxProduct - minProduct))**\\nSpace: O(n) if you separate negaitve and positive nummbers into different arrays. But you can do it O(1). \\n\\n```\\ndef kthSmallestProduct(self, nums1, nums2, k):\\n    #elements can be negative, so max and min prod need to calculated properly\\n    L = min(nums1[0]*nums2[0], nums1[0]*nums2[-1], nums2[0]*nums1[-1])\\n    R = max(nums1[0]*nums2[0], nums1[-1]*nums2[-1], nums1[-1]*nums2[0], nums1[0]*nums2[-1])\\n\\n    neg1 = [i for i in nums1 if i < 0]; nums1 = nums1[len(neg1): ]\\n    neg2 = [i for i in nums2 if i < 0]; nums2 = nums2[len(neg2): ]\\n    def getCount(k):\\n        #4 combinations to count\\n        #(neg, neg), (neg, pos), (pos, neg), (pos, pos)\\n        count = 0\\n        #(neg, neg)\\n        i = len(neg1) - 1; j = 0\\n        while i >= 0 and j < len(neg2):\\n            if neg1[i]*neg2[j] <= k:\\n                count += (len(neg2) - j)\\n                i -= 1\\n            else:\\n                j += 1\\n        \\n        #(neg, pos)\\n        i = 0; j = 0\\n        while i < len(neg1) and j < len(nums2):\\n            if neg1[i]*nums2[j] <= k:\\n                count += (len(nums2) - j)\\n                i += 1\\n            else:\\n                j += 1\\n        \\n        #(pos, neg)\\n        i = len(nums1) - 1; j = len(neg2) - 1\\n        while i >= 0 and j >= 0:\\n            if nums1[i]*neg2[j] <= k:\\n                count += (j + 1)\\n                i -= 1\\n            else:\\n                j -= 1\\n        \\n        #(pos, pos)\\n        i = 0; j = len(nums2) - 1\\n        while i < len(nums1) and j >= 0:\\n            if nums1[i]*nums2[j] <= k:\\n                count += (j + 1)\\n                i += 1\\n            else:\\n                j -= 1\\n        \\n        return count\\n    \\n    while L < R:\\n        M = (L+R)//2\\n        if getCount(M) < k:\\n            L = M+1\\n        else:\\n            R = M\\n    \\n    return L\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nIf nums[i]*nums[j] <= k, count += (j + 1),\\n```\n```\\nif nums[i]*nums[j] > k, j -= 1,\\n```\n```\\nif countOfProducts(guess) < k, guess is too small\\nif countOfProducts(guess) > k, guess is too large\\n```\n```\\ndef kthSmallestProduct(self, nums1, nums2, k):\\n    #elements can be negative, so max and min prod need to calculated properly\\n    L = min(nums1[0]*nums2[0], nums1[0]*nums2[-1], nums2[0]*nums1[-1])\\n    R = max(nums1[0]*nums2[0], nums1[-1]*nums2[-1], nums1[-1]*nums2[0], nums1[0]*nums2[-1])\\n\\n    neg1 = [i for i in nums1 if i < 0]; nums1 = nums1[len(neg1): ]\\n    neg2 = [i for i in nums2 if i < 0]; nums2 = nums2[len(neg2): ]\\n    def getCount(k):\\n        #4 combinations to count\\n        #(neg, neg), (neg, pos), (pos, neg), (pos, pos)\\n        count = 0\\n        #(neg, neg)\\n        i = len(neg1) - 1; j = 0\\n        while i >= 0 and j < len(neg2):\\n            if neg1[i]*neg2[j] <= k:\\n                count += (len(neg2) - j)\\n                i -= 1\\n            else:\\n                j += 1\\n        \\n        #(neg, pos)\\n        i = 0; j = 0\\n        while i < len(neg1) and j < len(nums2):\\n            if neg1[i]*nums2[j] <= k:\\n                count += (len(nums2) - j)\\n                i += 1\\n            else:\\n                j += 1\\n        \\n        #(pos, neg)\\n        i = len(nums1) - 1; j = len(neg2) - 1\\n        while i >= 0 and j >= 0:\\n            if nums1[i]*neg2[j] <= k:\\n                count += (j + 1)\\n                i -= 1\\n            else:\\n                j -= 1\\n        \\n        #(pos, pos)\\n        i = 0; j = len(nums2) - 1\\n        while i < len(nums1) and j >= 0:\\n            if nums1[i]*nums2[j] <= k:\\n                count += (j + 1)\\n                i += 1\\n            else:\\n                j -= 1\\n        \\n        return count\\n    \\n    while L < R:\\n        M = (L+R)//2\\n        if getCount(M) < k:\\n            L = M+1\\n        else:\\n            R = M\\n    \\n    return L\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2627762,
                "title": "c-o-m-n-log-10-10-time-o-1-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        int n = nums1.size(), m = nums2.size();\\n        ll lo = -(ll)1e10 - 1, hi = (ll)1e10 + 1;\\n        \\n        int ln = -1;\\n        for (int i = 0; i < m; ++i) {\\n            if (nums2[i] < 0) ln = i;\\n        }\\n        \\n        while (hi - lo > 1) {\\n            ll mid = (hi + lo) / 2;\\n            // cnt number of pairs whose product <= mid\\n            // This is not as simple as addition\\n            // Because product of two negative integers becomes positive\\n            \\n            ll cnt = 0;\\n            ll l = 0;\\n            \\n            ll pos = ln + 1, neg = ln;\\n            \\n            // negative in nums1\\n            while (l < n && nums1[l] < 0) {\\n                while (pos < m && (ll)nums1[l] * nums2[pos] > mid) pos++;   \\n                cnt += m - pos;\\n                while (neg >= 0 && (ll)nums1[l] * nums2[neg] <= mid) neg--;\\n                cnt += ln - neg;\\n                ++l;\\n            }\\n            \\n            neg = 0, pos = m - 1;;\\n            \\n            // positive in nums1\\n            while (l < n) {\\n                while (neg <= ln && (ll)nums1[l] * nums2[neg] <= mid) neg++;\\n                cnt += neg;\\n                while (pos > ln && (ll)nums1[l] * nums2[pos] > mid) pos--;\\n                cnt += pos - ln;\\n                ++l;\\n            }\\n            \\n            if (cnt < k) lo = mid;\\n            else hi = mid;\\n        }\\n        \\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        int n = nums1.size(), m = nums2.size();\\n        ll lo = -(ll)1e10 - 1, hi = (ll)1e10 + 1;\\n        \\n        int ln = -1;\\n        for (int i = 0; i < m; ++i) {\\n            if (nums2[i] < 0) ln = i;\\n        }\\n        \\n        while (hi - lo > 1) {\\n            ll mid = (hi + lo) / 2;\\n            // cnt number of pairs whose product <= mid\\n            // This is not as simple as addition\\n            // Because product of two negative integers becomes positive\\n            \\n            ll cnt = 0;\\n            ll l = 0;\\n            \\n            ll pos = ln + 1, neg = ln;\\n            \\n            // negative in nums1\\n            while (l < n && nums1[l] < 0) {\\n                while (pos < m && (ll)nums1[l] * nums2[pos] > mid) pos++;   \\n                cnt += m - pos;\\n                while (neg >= 0 && (ll)nums1[l] * nums2[neg] <= mid) neg--;\\n                cnt += ln - neg;\\n                ++l;\\n            }\\n            \\n            neg = 0, pos = m - 1;;\\n            \\n            // positive in nums1\\n            while (l < n) {\\n                while (neg <= ln && (ll)nums1[l] * nums2[neg] <= mid) neg++;\\n                cnt += neg;\\n                while (pos > ln && (ll)nums1[l] * nums2[pos] > mid) pos--;\\n                cnt += pos - ln;\\n                ++l;\\n            }\\n            \\n            if (cnt < k) lo = mid;\\n            else hi = mid;\\n        }\\n        \\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621550,
                "title": "simple-binary-search-o-nloga-solution-c",
                "content": "Since It\\'s really confusing that you tackle this problem without division into cases, you\\'d be better determine the sign of number at first.\\n\\nAt first, I tried O(NlogNlogA) Soluiton, but it was too slow to finish in TL.\\n\\nHere\\'s my implemention in C++.\\n\\nTime Complexity : O(NlogA)\\nSpace Complexity : O(N)\\n\\n```\\ntypedef long long ll;\\n\\ntemplate<class T = int>int bisect_right(const std::vector<T> & V, T val){if (V.size() == 0){return 0;}auto it = upper_bound(V.begin(), V.end(), val);int index = it - V.begin();return index;}\\n\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& arr1, vector<int>& arr2, long long k){\\n        vector<vector<ll>> nums1(3);\\n        vector<vector<ll>> nums2(3);\\n\\n        const int n1 = arr1.size();\\n        const int n2 = arr2.size();\\n\\n        for (auto & e : arr1){\\n            if (e > 0){\\n                nums1[0].emplace_back(e);\\n            }else if (e == 0){\\n                nums1[1].emplace_back(e);    \\n            }else{\\n                nums1[2].emplace_back(-e);\\n            }\\n        }\\n        reverse(nums1[2].begin(), nums1[2].end());\\n\\n        for (auto & e : arr2){\\n            if (e > 0){\\n                nums2[0].emplace_back(e);\\n            }else if (e == 0){\\n                nums2[1].emplace_back(e);    \\n            }else{\\n                nums2[2].emplace_back(-e);\\n            }\\n        }\\n        reverse(nums2[2].begin(), nums2[2].end());\\n\\n        auto count_not_less_than = [&](ll x){\\n            ll res = 0;\\n            if (x < 0){\\n                res += 1ll * nums1[2].size() * nums2[0].size();\\n                res += 1ll * nums1[0].size() * nums2[2].size();\\n                res -= countNoLessThan(nums1[2], nums2[0], -x - 1);\\n                res -= countNoLessThan(nums1[0], nums2[2], -x - 1);\\n                // for (auto & e : nums1[2]){\\n                //     res -= bisect_right<ll>(nums2[0], (-x - 1) / e);\\n                // }\\n                // for (auto & e : nums1[0]){\\n                //     res -= bisect_right<ll>(nums2[2], (-x - 1) / e);\\n                // }\\n            }else if (x == 0){\\n                res += 1ll * n1 * n2;\\n                res -= 1ll * nums1[0].size() * nums2[0].size();\\n                res -= 1ll * nums1[2].size() * nums2[2].size();\\n            }else if (x > 0){\\n                res += 1ll * n1 * n2;\\n                res -= 1ll * nums1[0].size() * nums2[0].size();\\n                res -= 1ll * nums1[2].size() * nums2[2].size();\\n                res += countNoLessThan(nums1[2], nums2[2], x);\\n                res += countNoLessThan(nums1[0], nums2[0], x);\\n                // for (auto & e : nums1[2]){\\n                //     res += bisect_right<ll>(nums2[2], x / e);\\n                // }\\n                // for (auto & e : nums1[0]){\\n                //     res += bisect_right<ll>(nums2[0], x / e);\\n                // }\\n            }\\n            return res;\\n        };\\n        \\n        ll ng = -1e10 - 1, ok = 1e10 + 1;\\n        while(ok - ng > 1){\\n            ll mid = (ng + ok) / 2;\\n            if (count_not_less_than(mid) < k){\\n                ng = mid;\\n            }else{\\n                ok = mid;\\n            }\\n        }\\n        return ok;\\n    }\\n    long long countNoLessThan(vector<ll>& arr1, vector<ll>& arr2, long long k){\\n        //assume both array are sorted.\\n        const int n1 = arr1.size();\\n        const int n2 = arr2.size();\\n        ll res = 0;\\n        for (int i = n1 - 1, ptr = 0; i >= 0; i--){\\n            while(ptr < n2 && arr2[ptr] <=  k / arr1[i]){\\n                ptr++;\\n            }\\n            res += ptr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long ll;\\n\\ntemplate<class T = int>int bisect_right(const std::vector<T> & V, T val){if (V.size() == 0){return 0;}auto it = upper_bound(V.begin(), V.end(), val);int index = it - V.begin();return index;}\\n\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& arr1, vector<int>& arr2, long long k){\\n        vector<vector<ll>> nums1(3);\\n        vector<vector<ll>> nums2(3);\\n\\n        const int n1 = arr1.size();\\n        const int n2 = arr2.size();\\n\\n        for (auto & e : arr1){\\n            if (e > 0){\\n                nums1[0].emplace_back(e);\\n            }else if (e == 0){\\n                nums1[1].emplace_back(e);    \\n            }else{\\n                nums1[2].emplace_back(-e);\\n            }\\n        }\\n        reverse(nums1[2].begin(), nums1[2].end());\\n\\n        for (auto & e : arr2){\\n            if (e > 0){\\n                nums2[0].emplace_back(e);\\n            }else if (e == 0){\\n                nums2[1].emplace_back(e);    \\n            }else{\\n                nums2[2].emplace_back(-e);\\n            }\\n        }\\n        reverse(nums2[2].begin(), nums2[2].end());\\n\\n        auto count_not_less_than = [&](ll x){\\n            ll res = 0;\\n            if (x < 0){\\n                res += 1ll * nums1[2].size() * nums2[0].size();\\n                res += 1ll * nums1[0].size() * nums2[2].size();\\n                res -= countNoLessThan(nums1[2], nums2[0], -x - 1);\\n                res -= countNoLessThan(nums1[0], nums2[2], -x - 1);\\n                // for (auto & e : nums1[2]){\\n                //     res -= bisect_right<ll>(nums2[0], (-x - 1) / e);\\n                // }\\n                // for (auto & e : nums1[0]){\\n                //     res -= bisect_right<ll>(nums2[2], (-x - 1) / e);\\n                // }\\n            }else if (x == 0){\\n                res += 1ll * n1 * n2;\\n                res -= 1ll * nums1[0].size() * nums2[0].size();\\n                res -= 1ll * nums1[2].size() * nums2[2].size();\\n            }else if (x > 0){\\n                res += 1ll * n1 * n2;\\n                res -= 1ll * nums1[0].size() * nums2[0].size();\\n                res -= 1ll * nums1[2].size() * nums2[2].size();\\n                res += countNoLessThan(nums1[2], nums2[2], x);\\n                res += countNoLessThan(nums1[0], nums2[0], x);\\n                // for (auto & e : nums1[2]){\\n                //     res += bisect_right<ll>(nums2[2], x / e);\\n                // }\\n                // for (auto & e : nums1[0]){\\n                //     res += bisect_right<ll>(nums2[0], x / e);\\n                // }\\n            }\\n            return res;\\n        };\\n        \\n        ll ng = -1e10 - 1, ok = 1e10 + 1;\\n        while(ok - ng > 1){\\n            ll mid = (ng + ok) / 2;\\n            if (count_not_less_than(mid) < k){\\n                ng = mid;\\n            }else{\\n                ok = mid;\\n            }\\n        }\\n        return ok;\\n    }\\n    long long countNoLessThan(vector<ll>& arr1, vector<ll>& arr2, long long k){\\n        //assume both array are sorted.\\n        const int n1 = arr1.size();\\n        const int n2 = arr2.size();\\n        ll res = 0;\\n        for (int i = n1 - 1, ptr = 0; i >= 0; i--){\\n            while(ptr < n2 && arr2[ptr] <=  k / arr1[i]){\\n                ptr++;\\n            }\\n            res += ptr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536641,
                "title": "c",
                "content": "```\\ntypedef long long int ll;\\n\\nclass Solution \\n{\\npublic:\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) \\n    {\\n        ll left = -(ll)(1e10) - 1;\\n        ll right = (ll)(1e10) + 1;\\n        \\n        while(right - left > 1)\\n        {\\n            ll mid = (left + right) / 2;\\n            ll num = 0;\\n            \\n            for(int number : nums1)\\n            {\\n                if(number == 0)\\n                {\\n                    if(mid >= 0)\\n                    {\\n                        num += nums2.size();\\n                    }\\n                }\\n                else if(number > 0)\\n                {\\n                    ll roundedNumber = floor(mid / (double)number); // round down\\n                    auto iter = upper_bound(nums2.begin(), nums2.end(), roundedNumber);\\n                    num += iter - nums2.begin();\\n                }\\n                else\\n                {\\n                    ll roundedNumber = ceil(mid / (double)number); // round up\\n                    auto iter = lower_bound(nums2.begin(), nums2.end(), roundedNumber);\\n                    num += nums2.size() - (iter - nums2.begin());             \\n                }\\n            }\\n            \\n            if(num >= k)\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                left = mid;\\n            }\\n        }\\n        \\n        return right;\\n    }\\n};\\n\\n// The complexity is O(NlogNlogA), where N denotes max(nums1.size(), nums2.size()) and A denotes the size of the range\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\nclass Solution \\n{\\npublic:\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) \\n    {\\n        ll left = -(ll)(1e10) - 1;\\n        ll right = (ll)(1e10) + 1;\\n        \\n        while(right - left > 1)\\n        {\\n            ll mid = (left + right) / 2;\\n            ll num = 0;\\n            \\n            for(int number : nums1)\\n            {\\n                if(number == 0)\\n                {\\n                    if(mid >= 0)\\n                    {\\n                        num += nums2.size();\\n                    }\\n                }\\n                else if(number > 0)\\n                {\\n                    ll roundedNumber = floor(mid / (double)number); // round down\\n                    auto iter = upper_bound(nums2.begin(), nums2.end(), roundedNumber);\\n                    num += iter - nums2.begin();\\n                }\\n                else\\n                {\\n                    ll roundedNumber = ceil(mid / (double)number); // round up\\n                    auto iter = lower_bound(nums2.begin(), nums2.end(), roundedNumber);\\n                    num += nums2.size() - (iter - nums2.begin());             \\n                }\\n            }\\n            \\n            if(num >= k)\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                left = mid;\\n            }\\n        }\\n        \\n        return right;\\n    }\\n};\\n\\n// The complexity is O(NlogNlogA), where N denotes max(nums1.size(), nums2.size()) and A denotes the size of the range\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526725,
                "title": "python-binary-search-two-pointers-explained",
                "content": "1. Discuss 2 cases: k-th smallest is negetive/positive `splitArr`\\n2. In `helper` function, arr1[i+1] * arr2[j] > arr1[i] * arr2[j] and arr1[i] * arr2[j+1] > arr1[i] * arr2[j]. Same for arr3 and arr4. Do binary search in range [smallest_product, largest_product].\\n3. Then for arr1 and arr2 (or arr3 and arr4), we can use two pointers to find how many products is smaller than mid. `countSmaller`\\n```\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        def splitArr(arr):\\n            for i in range(len(arr)):\\n                if arr[i] >= 0:\\n                    return arr[:i], arr[i:]\\n            return arr[:], []\\n        \\n        def countSmaller(target, arr1, arr2) -> int:\\n            i, j = 0, len(arr2)-1\\n            cnt = 0\\n            for i in range(len(arr1)):\\n                while j>=0 and arr1[i]*arr2[j] > target:\\n                    j -= 1\\n                cnt += j + 1\\n            return cnt\\n        \\n        def helper(k, arr1, arr2, arr3, arr4) -> int:\\n            b1 = len(arr1) and len(arr2)\\n            b2 = len(arr3) and len(arr4)\\n            l = min(arr1[0]*arr2[0] if b1 else math.inf, arr3[0]*arr4[0] if b2 else math.inf) \\n            r = max(arr1[-1]*arr2[-1] if b1 else -math.inf, arr3[-1]*arr4[-1] if b2 else -math.inf)\\n            while l <= r:\\n                mid = l+(r-l)//2\\n                rank = countSmaller(mid, arr1, arr2) + countSmaller(mid, arr3, arr4)\\n                if rank < k:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            return l\\n        \\n        \\n        neg1, pos1 = splitArr(nums1)\\n        neg2, pos2 = splitArr(nums2)\\n        N_neg = len(pos1)*len(neg2) + len(pos2)*len(neg1)\\n        if k > N_neg:\\n            return helper(k-N_neg, pos1, pos2, neg1[::-1], neg2[::-1])\\n        else:\\n            return helper(k, neg1, pos2[::-1], neg2, pos1[::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        def splitArr(arr):\\n            for i in range(len(arr)):\\n                if arr[i] >= 0:\\n                    return arr[:i], arr[i:]\\n            return arr[:], []\\n        \\n        def countSmaller(target, arr1, arr2) -> int:\\n            i, j = 0, len(arr2)-1\\n            cnt = 0\\n            for i in range(len(arr1)):\\n                while j>=0 and arr1[i]*arr2[j] > target:\\n                    j -= 1\\n                cnt += j + 1\\n            return cnt\\n        \\n        def helper(k, arr1, arr2, arr3, arr4) -> int:\\n            b1 = len(arr1) and len(arr2)\\n            b2 = len(arr3) and len(arr4)\\n            l = min(arr1[0]*arr2[0] if b1 else math.inf, arr3[0]*arr4[0] if b2 else math.inf) \\n            r = max(arr1[-1]*arr2[-1] if b1 else -math.inf, arr3[-1]*arr4[-1] if b2 else -math.inf)\\n            while l <= r:\\n                mid = l+(r-l)//2\\n                rank = countSmaller(mid, arr1, arr2) + countSmaller(mid, arr3, arr4)\\n                if rank < k:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            return l\\n        \\n        \\n        neg1, pos1 = splitArr(nums1)\\n        neg2, pos2 = splitArr(nums2)\\n        N_neg = len(pos1)*len(neg2) + len(pos2)*len(neg1)\\n        if k > N_neg:\\n            return helper(k-N_neg, pos1, pos2, neg1[::-1], neg2[::-1])\\n        else:\\n            return helper(k, neg1, pos2[::-1], neg2, pos1[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419755,
                "title": "binary-search",
                "content": "class Solution {\\npublic:\\n    long long solve(vector<int >& nums1,vector<int >& nums2,long long product)\\n    {\\n        long long count=0;\\n        for(int a:nums1)\\n        {\\n            if(a>0)\\n            {\\n                int l=0;\\n                int h=nums2.size()-1;\\n                \\n                int temp=-1;\\n                while(l<=h)\\n                {\\n                int mid = l+(h-l)/2;\\n                \\n                if((long long)a*nums2[mid]<=product)\\n                {\\n                    temp = mid;\\n                    l=mid+1;\\n                }\\n                else\\n                {\\n                    h=mid-1;\\n                }\\n                }\\n                count += temp+1;\\n            }\\n            else\\n            {\\n                int l=0;\\n                int h=nums2.size()-1;\\n                int temp=nums2.size();\\n                while(l<=h)\\n                {\\n                    int mid = l+(h-l)/2;\\n                    if((long long)a*nums2[mid]<=product)\\n                    {\\n                        temp = mid;\\n                        h=mid-1;\\n                    }\\n                    else\\n                    {\\n                        l=mid+1;\\n                    }\\n                }\\n                count += nums2.size()-temp;\\n            }\\n        }\\n        return count;\\n    }\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) \\n    {\\n       long long int low = -1e10;\\n       long long int high  = 1e10;\\n        \\n        long long ans;\\n        long long mid;\\n        \\n        while(low<=high)\\n        {\\n            mid = low+(high-low)/2;\\n            if(solve(nums1,nums2,mid)>=k)\\n            {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long solve(vector<int >& nums1,vector<int >& nums2,long long product)\\n    {\\n        long long count=0;\\n        for(int a:nums1)\\n        {\\n            if(a>0)\\n            {\\n                int l=0;\\n                int h=nums2.size()-1;\\n                \\n                int temp=-1;\\n                while(l<=h)\\n                {\\n                int mid = l+(h-l)/2;\\n                \\n                if((long long)a*nums2[mid]<=product)\\n                {\\n                    temp = mid;\\n                    l=mid+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2322108,
                "title": "accepted-c-solution-binary-search-based-approach",
                "content": "```\\n\\t\\tpublic class Solution\\n\\t\\t{\\n\\n\\t\\t\\tprivate long FindNegative(List<long> p1, List<long> p2, List<long> n1, List<long> n2, long k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tp1.Sort();\\n\\t\\t\\t\\tp2.Sort();\\n\\t\\t\\t\\tn1.Sort();\\n\\t\\t\\t\\tn2.Sort();\\n\\n\\t\\t\\t\\tp1.Reverse();\\n\\t\\t\\t\\tp2.Reverse();\\n\\t\\t\\t\\tn1.Reverse();\\n\\t\\t\\t\\tn2.Reverse();\\n\\n\\t\\t\\t\\tlong l = long.MinValue;\\n\\t\\t\\t\\tlong r = -1;\\n\\n\\t\\t\\t\\twhile (r - l > 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar mid = l + (r - l) / 2;\\n\\t\\t\\t\\t\\tif (CalculateNegProdsCount(p1, p2, n1, n2, -mid) >= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tr = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tl = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (CalculateNegProdsCount(p1, p2, n1, n2, -l) < k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn r;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn l;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tprivate long CalculatePosProdsCount(List<long> l1, List<long> l2, long cand)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (l1.Count == 0 || l2.Count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong c = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < l1.Count; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint l = 0;\\n\\t\\t\\t\\t\\tint r = l2.Count - 1;\\n\\n\\t\\t\\t\\t\\twhile (r - l > 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint mid = l + (r - l) / 2;\\n\\t\\t\\t\\t\\t\\tif (l1[i] * l2[mid] > cand)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tr = mid;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tl = mid;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (l1[i] * l2[r] <= cand)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc += (r + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(l1[i] * l2[l] <= cand)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc += (l + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn c;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tprivate long CalculateNegProdsCount(List<long> l1, List<long> l2, long cand)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (l1.Count == 0 || l2.Count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlong c = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < l1.Count; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint l = 0;\\n\\t\\t\\t\\t\\tint r = l2.Count - 1;\\n\\n\\t\\t\\t\\t\\twhile (r - l > 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint mid = l + (r - l) / 2;\\n\\t\\t\\t\\t\\t\\tif (l1[i] * l2[mid] < cand)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tr = mid;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tl = mid;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (l1[i] * l2[r] >= cand)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc += (r + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (l1[i] * l2[l] >= cand)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc += (l + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn c;\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate long CalculateNegProdsCount(List<long> p1, List<long> p2, List<long> n1, List<long> n2, long cand)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong c1 = CalculateNegProdsCount(p1, n2, cand);\\n\\t\\t\\t\\tlong c2 = CalculateNegProdsCount(n1, p2, cand);\\n\\t\\t\\t\\treturn c1 + c2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate long CalculatePosProdsCount(List<long> p1, List<long> p2, List<long> n1, List<long> n2, long cand)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong c1 = CalculatePosProdsCount(p1, p2, cand);\\n\\t\\t\\t\\tlong c2 = CalculatePosProdsCount(n1, n2, cand);\\n\\t\\t\\t\\treturn c1 + c2;\\n\\t\\t\\t}\\n\\t\\t\\tprivate long FindPositive(List<long> p1, List<long> p2, List<long> n1, List<long> n2, long k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tp1.Sort();\\n\\t\\t\\t\\tp2.Sort();\\n\\t\\t\\t\\tn1.Sort();\\n\\t\\t\\t\\tn2.Sort();\\n\\n\\t\\t\\t\\tlong l = 1;\\n\\t\\t\\t\\tlong r = long.MaxValue;\\n\\n\\t\\t\\t\\twhile (r-l > 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar mid = l + (r - l) / 2;\\n\\t\\t\\t\\t\\tif (CalculatePosProdsCount(p1, p2, n1, n2, mid) >= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tr = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tl = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (CalculatePosProdsCount(p1, p2, n1, n2, l) < k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn r;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn l;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic long KthSmallestProduct(int[] nums1, int[] nums2, long k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tList<long> p1 = new List<long>(nums1.Length);\\n\\t\\t\\t\\tList<long> n1 = new List<long>(nums1.Length);\\n\\t\\t\\t\\tList<long> p2 = new List<long>(nums2.Length);\\n\\t\\t\\t\\tList<long> n2 = new List<long>(nums2.Length);\\n\\n\\t\\t\\t\\tlong z1 = 0, z2 = 0;\\n\\n\\t\\t\\t\\tforeach (var num in nums1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (num == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tz1++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (num > 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tp1.Add(num);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (num < 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tn1.Add(-num);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tforeach (var num in nums2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (num == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tz2++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (num > 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tp2.Add(num);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (num < 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tn2.Add(-num);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlong negativePairs = p1.Count * n2.Count + p2.Count * n1.Count;\\n\\t\\t\\t\\tlong zeroPairs = z1 * (p2.Count + n2.Count) + z2 * (p1.Count + n1.Count) + z1 * z2;\\n\\n\\t\\t\\t\\tif (k <= negativePairs)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn FindNegative(p1, p2, n1, n2, k);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tk -= negativePairs;\\n\\n\\t\\t\\t\\tif (k <= zeroPairs)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tk -= zeroPairs;\\n\\t\\t\\t\\treturn FindPositive(p1, p2, n1, n2, k);\\n\\n\\t\\t\\t}\\n\\t\\t}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n\\t\\tpublic class Solution\\n\\t\\t{\\n\\n\\t\\t\\tprivate long FindNegative(List<long> p1, List<long> p2, List<long> n1, List<long> n2, long k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tp1.Sort();\\n\\t\\t\\t\\tp2.Sort();\\n\\t\\t\\t\\tn1.Sort();\\n\\t\\t\\t\\tn2.Sort();\\n\\n\\t\\t\\t\\tp1.Reverse();\\n\\t\\t\\t\\tp2.Reverse();\\n\\t\\t\\t\\tn1.Reverse();\\n\\t\\t\\t\\tn2.Reverse();\\n\\n\\t\\t\\t\\tlong l = long.MinValue;\\n\\t\\t\\t\\tlong r = -1;\\n\\n\\t\\t\\t\\twhile (r - l > 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar mid = l + (r - l) / 2;\\n\\t\\t\\t\\t\\tif (CalculateNegProdsCount(p1, p2, n1, n2, -mid) >= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tr = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tl = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (CalculateNegProdsCount(p1, p2, n1, n2, -l) < k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn r;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn l;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tprivate long CalculatePosProdsCount(List<long> l1, List<long> l2, long cand)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (l1.Count == 0 || l2.Count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong c = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < l1.Count; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint l = 0;\\n\\t\\t\\t\\t\\tint r = l2.Count - 1;\\n\\n\\t\\t\\t\\t\\twhile (r - l > 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint mid = l + (r - l) / 2;\\n\\t\\t\\t\\t\\t\\tif (l1[i] * l2[mid] > cand)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tr = mid;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tl = mid;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (l1[i] * l2[r] <= cand)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc += (r + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(l1[i] * l2[l] <= cand)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc += (l + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn c;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tprivate long CalculateNegProdsCount(List<long> l1, List<long> l2, long cand)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (l1.Count == 0 || l2.Count == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlong c = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < l1.Count; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint l = 0;\\n\\t\\t\\t\\t\\tint r = l2.Count - 1;\\n\\n\\t\\t\\t\\t\\twhile (r - l > 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint mid = l + (r - l) / 2;\\n\\t\\t\\t\\t\\t\\tif (l1[i] * l2[mid] < cand)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tr = mid;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tl = mid;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (l1[i] * l2[r] >= cand)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc += (r + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (l1[i] * l2[l] >= cand)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tc += (l + 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn c;\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate long CalculateNegProdsCount(List<long> p1, List<long> p2, List<long> n1, List<long> n2, long cand)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong c1 = CalculateNegProdsCount(p1, n2, cand);\\n\\t\\t\\t\\tlong c2 = CalculateNegProdsCount(n1, p2, cand);\\n\\t\\t\\t\\treturn c1 + c2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate long CalculatePosProdsCount(List<long> p1, List<long> p2, List<long> n1, List<long> n2, long cand)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong c1 = CalculatePosProdsCount(p1, p2, cand);\\n\\t\\t\\t\\tlong c2 = CalculatePosProdsCount(n1, n2, cand);\\n\\t\\t\\t\\treturn c1 + c2;\\n\\t\\t\\t}\\n\\t\\t\\tprivate long FindPositive(List<long> p1, List<long> p2, List<long> n1, List<long> n2, long k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tp1.Sort();\\n\\t\\t\\t\\tp2.Sort();\\n\\t\\t\\t\\tn1.Sort();\\n\\t\\t\\t\\tn2.Sort();\\n\\n\\t\\t\\t\\tlong l = 1;\\n\\t\\t\\t\\tlong r = long.MaxValue;\\n\\n\\t\\t\\t\\twhile (r-l > 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar mid = l + (r - l) / 2;\\n\\t\\t\\t\\t\\tif (CalculatePosProdsCount(p1, p2, n1, n2, mid) >= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tr = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tl = mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (CalculatePosProdsCount(p1, p2, n1, n2, l) < k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn r;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn l;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic long KthSmallestProduct(int[] nums1, int[] nums2, long k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tList<long> p1 = new List<long>(nums1.Length);\\n\\t\\t\\t\\tList<long> n1 = new List<long>(nums1.Length);\\n\\t\\t\\t\\tList<long> p2 = new List<long>(nums2.Length);\\n\\t\\t\\t\\tList<long> n2 = new List<long>(nums2.Length);\\n\\n\\t\\t\\t\\tlong z1 = 0, z2 = 0;\\n\\n\\t\\t\\t\\tforeach (var num in nums1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (num == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tz1++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (num > 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tp1.Add(num);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (num < 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tn1.Add(-num);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tforeach (var num in nums2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (num == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tz2++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (num > 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tp2.Add(num);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (num < 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tn2.Add(-num);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlong negativePairs = p1.Count * n2.Count + p2.Count * n1.Count;\\n\\t\\t\\t\\tlong zeroPairs = z1 * (p2.Count + n2.Count) + z2 * (p1.Count + n1.Count) + z1 * z2;\\n\\n\\t\\t\\t\\tif (k <= negativePairs)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn FindNegative(p1, p2, n1, n2, k);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tk -= negativePairs;\\n\\n\\t\\t\\t\\tif (k <= zeroPairs)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tk -= zeroPairs;\\n\\t\\t\\t\\treturn FindPositive(p1, p2, n1, n2, k);\\n\\n\\t\\t\\t}\\n\\t\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280542,
                "title": "numpy-solution-least-runtime-solution",
                "content": "```\\nimport numpy as np\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        A = np.sort(nums1)\\n        B = np.sort(nums2)\\n        Aneg, Azero, Apos = A[A < 0], A[A == 0], A[A > 0]\\n\\n        def f(x):\\n            # Count number of a * b <= x, casing on the sign of a\\n            countZero = len(Azero) * len(B) if x >= 0 else 0\\n            countPos = np.searchsorted(B, x // Apos, side=\"right\").sum()\\n            countNeg = len(Aneg) * len(B) - np.searchsorted(B, (-x - 1) // (-Aneg), side=\"right\").sum()\\n            return countNeg + countZero + countPos\\n\\n        lo = -(10 ** 10)\\n        hi = 10 ** 10\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if f(mid) >= k:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return hi\\n    \\n#         A, B = nums1, nums2\\n#         n, m = len(A), len(B)\\n#         A1,A2 = [-a for a in A if a < 0][::-1], [a for a in A if a >= 0]\\n#         B1,B2 = [-a for a in B if a < 0][::-1], [a for a in B if a >= 0]\\n\\n#         neg = len(A1) * len(B2) + len(A2) * len(B1)\\n#         if k > neg:\\n#             k -= neg\\n#             s = 1\\n#         else:\\n#             k = neg - k + 1\\n#             B1, B2 = B2,B1\\n#             s = -1\\n\\n#         def count(A, B, x):\\n#             res = 0\\n#             j = len(B) - 1\\n#             for i in range(len(A)):\\n#                 while j >= 0 and A[i] * B[j] > x:\\n#                     j -= 1\\n#                 res += j + 1\\n#             return res\\n\\n#         left, right = 0, 10**10\\n#         while left < right:\\n#             mid = (left + right) // 2\\n#             if count(A1, B1, mid) + count(A2, B2, mid) >= k:\\n#                 right = mid\\n#             else:\\n#                 left = mid + 1\\n#         return left * s\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        A = np.sort(nums1)\\n        B = np.sort(nums2)\\n        Aneg, Azero, Apos = A[A < 0], A[A == 0], A[A > 0]\\n\\n        def f(x):\\n            # Count number of a * b <= x, casing on the sign of a\\n            countZero = len(Azero) * len(B) if x >= 0 else 0\\n            countPos = np.searchsorted(B, x // Apos, side=\"right\").sum()\\n            countNeg = len(Aneg) * len(B) - np.searchsorted(B, (-x - 1) // (-Aneg), side=\"right\").sum()\\n            return countNeg + countZero + countPos\\n\\n        lo = -(10 ** 10)\\n        hi = 10 ** 10\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if f(mid) >= k:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return hi\\n    \\n#         A, B = nums1, nums2\\n#         n, m = len(A), len(B)\\n#         A1,A2 = [-a for a in A if a < 0][::-1], [a for a in A if a >= 0]\\n#         B1,B2 = [-a for a in B if a < 0][::-1], [a for a in B if a >= 0]\\n\\n#         neg = len(A1) * len(B2) + len(A2) * len(B1)\\n#         if k > neg:\\n#             k -= neg\\n#             s = 1\\n#         else:\\n#             k = neg - k + 1\\n#             B1, B2 = B2,B1\\n#             s = -1\\n\\n#         def count(A, B, x):\\n#             res = 0\\n#             j = len(B) - 1\\n#             for i in range(len(A)):\\n#                 while j >= 0 and A[i] * B[j] > x:\\n#                     j -= 1\\n#                 res += j + 1\\n#             return res\\n\\n#         left, right = 0, 10**10\\n#         while left < right:\\n#             mid = (left + right) // 2\\n#             if count(A1, B1, mid) + count(A2, B2, mid) >= k:\\n#                 right = mid\\n#             else:\\n#                 left = mid + 1\\n#         return left * s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182453,
                "title": "java-solution-binary-search-tc-o-nlogm",
                "content": "```\\n// Tc = O(nlogm)   => dependent on count function\\n\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        long low = (long)-1e10, high = (long)1e10;\\n        \\n        while(low <= high){\\n            long dotProduct = (low+high)/2;\\n            if(countNoOfElements(nums1, nums2, dotProduct) < k) \\n                low = dotProduct+1;\\n            else\\n                high = dotProduct-1;\\n        }\\n        return high;\\n    }\\n    \\n    private long countNoOfElements(int[] nums1, int[] nums2, long dotProduct){  // this function will return the no. of elements(after product) which are less than dotProduct\\n        long count = 0;\\n        for(int element : nums1){\\n            if(element >= 0){     // if positve\\n                int low = 0, high = nums2.length;  // binary search on nums2\\n                while(low < high){\\n                    int mid = (low+high)/2;\\n                    if((long)element * nums2[mid] < dotProduct)\\n                        low = mid+1;\\n                    else\\n                        high = mid;\\n                }\\n               count += low;    // no. of elemets after product with element smaller than dotproduct\\n            }\\n            else{          //if negative  => binary search in some reverse order\\n                int low = 0, high = nums2.length;\\n                while(low < high){\\n                    int mid = (low+high)/2;\\n                    if((long) element * nums2[mid] >= dotProduct)\\n                        low = mid+1;\\n                    else\\n                        high = mid;\\n                }\\n                \\n                count += nums2.length - low;   // in negative element case smaller element will be on right side\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n// Tc = O(nlogm)   => dependent on count function\\n\\nclass Solution {\\n    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {\\n        long low = (long)-1e10, high = (long)1e10;\\n        \\n        while(low <= high){\\n            long dotProduct = (low+high)/2;\\n            if(countNoOfElements(nums1, nums2, dotProduct) < k) \\n                low = dotProduct+1;\\n            else\\n                high = dotProduct-1;\\n        }\\n        return high;\\n    }\\n    \\n    private long countNoOfElements(int[] nums1, int[] nums2, long dotProduct){  // this function will return the no. of elements(after product) which are less than dotProduct\\n        long count = 0;\\n        for(int element : nums1){\\n            if(element >= 0){     // if positve\\n                int low = 0, high = nums2.length;  // binary search on nums2\\n                while(low < high){\\n                    int mid = (low+high)/2;\\n                    if((long)element * nums2[mid] < dotProduct)\\n                        low = mid+1;\\n                    else\\n                        high = mid;\\n                }\\n               count += low;    // no. of elemets after product with element smaller than dotproduct\\n            }\\n            else{          //if negative  => binary search in some reverse order\\n                int low = 0, high = nums2.length;\\n                while(low < high){\\n                    int mid = (low+high)/2;\\n                    if((long) element * nums2[mid] >= dotProduct)\\n                        low = mid+1;\\n                    else\\n                        high = mid;\\n                }\\n                \\n                count += nums2.length - low;   // in negative element case smaller element will be on right side\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065167,
                "title": "test-case-25-112",
                "content": "For test case 25/112, the input is \\n```\\n[-9,6,10]\\n[-7,-1,1,2,3,4,4,6,9,10]\\n15\\n```\\n\\nMy expection is that the result should be 9 as,\\n```\\n// kth number, nums1 index, nums2 index, product\\n0 0 9  -90\\n1 0 8  -81\\n2 2 0  -70\\n3 0 7  -54\\n4 1 0  -42\\n5 0 6  -36\\n6 0 5  -36\\n7 0 4  -27\\n8 0 3  -18\\n9 2 1  -10\\n10 0 2  -9\\n11 1 1  -6\\n13 1 2  6\\n14 0 1  9\\n```\\n\\nI don\\'t really understand why the answer is 10. Anyone can help?",
                "solutionTags": [],
                "code": "```\\n[-9,6,10]\\n[-7,-1,1,2,3,4,4,6,9,10]\\n15\\n```\n```\\n// kth number, nums1 index, nums2 index, product\\n0 0 9  -90\\n1 0 8  -81\\n2 2 0  -70\\n3 0 7  -54\\n4 1 0  -42\\n5 0 6  -36\\n6 0 5  -36\\n7 0 4  -27\\n8 0 3  -18\\n9 2 1  -10\\n10 0 2  -9\\n11 1 1  -6\\n13 1 2  6\\n14 0 1  9\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062969,
                "title": "self-explanatory-intuitive-c-code",
                "content": "```\\nusing ll=long long;\\nclass Solution {\\npublic:\\n    // This returns TRUE, iff the number of elements in the set(A)*set(B) <= \\'val\\' is >= \\'K\\' \\n    bool predicate(ll val, const ll K, vector<int>& A, vector<int>& B){\\n        ll cnt=0;\\n        for(auto a:A){\\n            if(a<0){\\n                cnt += findNumberOfNumbersLessThanEqualToValInNonIncreasingArray(val,\\n                                                                                B,a);\\n            } else if (a==0) {\\n                if (val>=0) cnt+=B.size();\\n            } else if (a>0) {\\n                cnt += findNumberOfNumbersLessThanEqualToValInNonDecreasingArray(val,\\n                                                                                B,a);\\n            }\\n        }\\n        return cnt>=K;\\n    }\\n    \\n    int findNumberOfNumbersLessThanEqualToValInNonIncreasingArray(const ll val,\\n                                                                  vector<int>& B,\\n                                                                 const int a){\\n        // find the smallest index for which B[i]<=val\\n        int n = B.size();\\n        int lo=0,hi=n-1;\\n        // if the smallest numebr is > val, then there is no such element\\n        if((ll)B[hi]*a > val)return 0;\\n        while(lo!=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if((ll)B[mid]*a <= val)hi=mid;\\n            else lo=mid+1;\\n        }\\n        return n-lo;\\n    }\\n    \\n    int findNumberOfNumbersLessThanEqualToValInNonDecreasingArray(const ll val,\\n                                                                  vector<int>& B,\\n                                                                 const int a){\\n        // find the largest index for which B[i]<=val\\n        int n = B.size();\\n        int lo=0,hi=n-1;\\n        // if the smallest value if > val, then there is no such elements present\\n        if((ll)B[lo]*a > val) return 0;\\n        while(lo!=hi){\\n            int mid=lo+(hi-lo+1)/2;\\n            if((ll)B[mid]*a <= val)lo=mid;\\n            else hi=mid-1;\\n        }\\n        return lo+1;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& A, vector<int>& B, long long K) {\\n        // if x=A[i]*B[j], then we need to find the set of \\'x\\'(s) for which number of numbers <= \\'x\\'  will be >= \\'K\\' ans choose smallest in that set(smallest \\'x\\')\\n        \\n        ll lo=-1e10-100;\\n        ll hi=1e10+100;\\n        \\n        while(lo!=hi){\\n            ll mid=lo+(hi-lo)/2;\\n            if(predicate(mid,K,A,B))hi=mid;\\n            else lo= mid+1;\\n        }\\n        \\n        // since k <= A.length * B.length as given in the question, Here no need to check whetehr the answer exists or not\\n        \\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nusing ll=long long;\\nclass Solution {\\npublic:\\n    // This returns TRUE, iff the number of elements in the set(A)*set(B) <= \\'val\\' is >= \\'K\\' \\n    bool predicate(ll val, const ll K, vector<int>& A, vector<int>& B){\\n        ll cnt=0;\\n        for(auto a:A){\\n            if(a<0){\\n                cnt += findNumberOfNumbersLessThanEqualToValInNonIncreasingArray(val,\\n                                                                                B,a);\\n            } else if (a==0) {\\n                if (val>=0) cnt+=B.size();\\n            } else if (a>0) {\\n                cnt += findNumberOfNumbersLessThanEqualToValInNonDecreasingArray(val,\\n                                                                                B,a);\\n            }\\n        }\\n        return cnt>=K;\\n    }\\n    \\n    int findNumberOfNumbersLessThanEqualToValInNonIncreasingArray(const ll val,\\n                                                                  vector<int>& B,\\n                                                                 const int a){\\n        // find the smallest index for which B[i]<=val\\n        int n = B.size();\\n        int lo=0,hi=n-1;\\n        // if the smallest numebr is > val, then there is no such element\\n        if((ll)B[hi]*a > val)return 0;\\n        while(lo!=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if((ll)B[mid]*a <= val)hi=mid;\\n            else lo=mid+1;\\n        }\\n        return n-lo;\\n    }\\n    \\n    int findNumberOfNumbersLessThanEqualToValInNonDecreasingArray(const ll val,\\n                                                                  vector<int>& B,\\n                                                                 const int a){\\n        // find the largest index for which B[i]<=val\\n        int n = B.size();\\n        int lo=0,hi=n-1;\\n        // if the smallest value if > val, then there is no such elements present\\n        if((ll)B[lo]*a > val) return 0;\\n        while(lo!=hi){\\n            int mid=lo+(hi-lo+1)/2;\\n            if((ll)B[mid]*a <= val)lo=mid;\\n            else hi=mid-1;\\n        }\\n        return lo+1;\\n    }\\n    \\n    long long kthSmallestProduct(vector<int>& A, vector<int>& B, long long K) {\\n        // if x=A[i]*B[j], then we need to find the set of \\'x\\'(s) for which number of numbers <= \\'x\\'  will be >= \\'K\\' ans choose smallest in that set(smallest \\'x\\')\\n        \\n        ll lo=-1e10-100;\\n        ll hi=1e10+100;\\n        \\n        while(lo!=hi){\\n            ll mid=lo+(hi-lo)/2;\\n            if(predicate(mid,K,A,B))hi=mid;\\n            else lo= mid+1;\\n        }\\n        \\n        // since k <= A.length * B.length as given in the question, Here no need to check whetehr the answer exists or not\\n        \\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061718,
                "title": "binary-search-n-m-log-10-10-faster-than-98",
                "content": "```\\ntypedef long long ll;\\n#define all(nums) nums.begin(), nums.end()\\n#define reverse(nums1, nums2) reverse(all(nums1)), reverse(all(nums2))\\nclass Solution {\\npublic:\\n    inline ll count(vector<int> &nums1, vector<int> &nums2, ll limit) {\\n        ll result = 0;\\n        for(int i = 0, j = nums2.size()-1; i < nums1.size(); i++, result += (j+1))\\n            while(j >= 0 && (ll)nums1[i]*nums2[j] > limit) j--;\\n        return result;\\n    }\\n    tuple<ll, ll, ll, vector<int>, vector<int>> getStats(vector<int> nums) {\\n        vector<int> pos(upper_bound(all(nums), 0), nums.end()), neg(nums.begin(), lower_bound(all(nums), 0));\\n        return {neg.size(), std::count(all(nums), 0), pos.size(), neg, pos};\\n    }\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        ll n = nums1.size(), m = nums2.size();\\n        auto [neg1, zero1, pos1, nums1Neg, nums1Pos] = getStats(nums1);\\n        auto [neg2, zero2, pos2, nums2Neg, nums2Pos] = getStats(nums2);\\n        ll negCount = pos1*neg2+pos2*neg1, zeroCount = n*zero2+m*zero1-zero1*zero2, left=-1e10-5, right=1e10+5, mid;\\n        if(k > negCount) {\\n            if(k <= negCount+zeroCount) return 0;\\n            reverse(nums1Neg, nums2Neg);\\n            left = 1;\\n            k -= (negCount + zeroCount);\\n        } else {\\n            reverse(nums1Pos, nums2Pos);\\n            right = 0;\\n            swap(nums2Pos, nums2Neg);\\n        }\\n        while(left < right) {\\n            mid = left + (right-left)/2;\\n            if(count(nums1Pos, nums2Pos, mid) + count(nums2Neg, nums1Neg, mid) < k) left = mid+1;\\n            else right = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\n#define all(nums) nums.begin(), nums.end()\\n#define reverse(nums1, nums2) reverse(all(nums1)), reverse(all(nums2))\\nclass Solution {\\npublic:\\n    inline ll count(vector<int> &nums1, vector<int> &nums2, ll limit) {\\n        ll result = 0;\\n        for(int i = 0, j = nums2.size()-1; i < nums1.size(); i++, result += (j+1))\\n            while(j >= 0 && (ll)nums1[i]*nums2[j] > limit) j--;\\n        return result;\\n    }\\n    tuple<ll, ll, ll, vector<int>, vector<int>> getStats(vector<int> nums) {\\n        vector<int> pos(upper_bound(all(nums), 0), nums.end()), neg(nums.begin(), lower_bound(all(nums), 0));\\n        return {neg.size(), std::count(all(nums), 0), pos.size(), neg, pos};\\n    }\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        ll n = nums1.size(), m = nums2.size();\\n        auto [neg1, zero1, pos1, nums1Neg, nums1Pos] = getStats(nums1);\\n        auto [neg2, zero2, pos2, nums2Neg, nums2Pos] = getStats(nums2);\\n        ll negCount = pos1*neg2+pos2*neg1, zeroCount = n*zero2+m*zero1-zero1*zero2, left=-1e10-5, right=1e10+5, mid;\\n        if(k > negCount) {\\n            if(k <= negCount+zeroCount) return 0;\\n            reverse(nums1Neg, nums2Neg);\\n            left = 1;\\n            k -= (negCount + zeroCount);\\n        } else {\\n            reverse(nums1Pos, nums2Pos);\\n            right = 0;\\n            swap(nums2Pos, nums2Neg);\\n        }\\n        while(left < right) {\\n            mid = left + (right-left)/2;\\n            if(count(nums1Pos, nums2Pos, mid) + count(nums2Neg, nums1Neg, mid) < k) left = mid+1;\\n            else right = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056924,
                "title": "binary-search-o-nmlog-nm",
                "content": "class Solution {\\npublic:\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long hi=10000000000;\\n        long long lo=-10000000000;\\n        long long ans1=0;\\n        while(lo<=hi){\\n            long long mid=(hi+lo)/2;\\n            if(countElement(nums1,nums2,mid)>=k){\\n                ans1=mid;\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        return ans1;\\n    }\\n    \\n    long long countElement(vector<int> &arr1,vector<int> &arr2,long long dot_prod){\\n        long long ans=0;\\n        for(int i=0;i<arr1.size();i++){\\n            long long count=0;\\n            long long e1=arr1[i];\\n            long long lo=0;\\n            long long hi=arr2.size()-1;\\n            if(e1>=0){\\n                while(lo<=hi){\\n                    int mid=(lo+hi)/2;\\n                    if((long long)e1*arr2[mid]<=dot_prod){\\n                        count=mid+1;\\n                        lo=mid+1;\\n                    }\\n                    else{\\n                        hi=mid-1;\\n                    }\\n                }\\n                ans=ans+count;\\n            }\\n            else{\\n                while(lo<=hi){\\n                    int mid=(lo+hi)/2;\\n                    if((long long)e1*arr2[mid]<=dot_prod){\\n                        count=arr2.size()-mid;\\n                        hi=mid-1;\\n                    }\\n                    else{\\n                        lo=mid+1;\\n                    }\\n                }\\n                ans=ans+count;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        long long hi=10000000000;\\n        long long lo=-10000000000;\\n        long long ans1=0;\\n        while(lo<=hi){\\n            long long mid=(hi+lo)/2;\\n            if(countElement(nums1,nums2,mid)>=k){\\n                ans1=mid;\\n                hi=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1865409,
                "title": "java-binary-search",
                "content": "Notable issues:\\n1. type cast to long BEFORE min max\\n2. be aware of whether the binary search end is inclusive or not\\n3. be aware the count/index update is happening in which if clause to confirm it is the largest value have k count less than it or smallest\\n\\n```\\n\\n\\nclass Solution {\\n    int m;\\n    int n;\\n    int[] nums1;\\n    int[] nums2;\\n    \\n    public long kthSmallestProduct(int[] n1, int[] n2, long k) {\\n        this.nums1 = n1.length < n2.length? n1: n2;\\n        this.nums2 = n1.length < n2.length? n2: n1;\\n        \\n        m = nums1.length;\\n        n = nums2.length;\\n        // Do binary search on product value range\\n        long l = Math.min(Math.min((long)nums1[m-1]*nums2[n-1], (long)nums1[0]*nums2[0]), Math.min((long)nums1[0]*nums2[n-1], (long)nums2[0]*nums1[m-1]));\\n        long r = Math.max(Math.max((long)nums1[m-1]*nums2[n-1], (long)nums1[0]*nums2[0]), Math.max((long)nums1[0]*nums2[n-1], (long)nums2[0]*nums1[m-1]));\\n        long res = -1;\\n        \\n        while(l <= r) {\\n            long mid = l + (r-l)/2;\\n            long count = countTillMidVal(mid);\\n\\n            if(count < k) {\\n                l = mid+1;\\n            } else {\\n                res = mid;\\n                r = mid-1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private long countTillMidVal(long val) {\\n        long count = 0;\\n        \\n        for(int num: nums1) {\\n            // if num > 0, product order is the same as nums2\\n            // if nums < 0, product order is reverse as nums2\\n            long c = 0;\\n            if(num < 0) {\\n                c = getCountNums2Reverse(val, num);\\n            } else {\\n                c = getCountNums2(val, num);\\n            }\\n            count += c;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private long getCountNums2(long val, long num1){\\n        int l = 0;\\n        int r = n - 1;\\n        long count = 0;\\n        \\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            \\n            if(nums2[mid]*num1 <= val) {\\n                count = mid+1;\\n                l = mid+1;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private long getCountNums2Reverse(long val, long num1) {\\n        int l = 0;\\n        int r = n - 1;\\n        long count = 0;\\n        \\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            \\n            if(nums2[mid]*num1 > val) {\\n                l = mid+1;\\n            } else {\\n                count = n-mid;\\n                r = mid-1;\\n            }\\n        }\\n        \\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\n    int m;\\n    int n;\\n    int[] nums1;\\n    int[] nums2;\\n    \\n    public long kthSmallestProduct(int[] n1, int[] n2, long k) {\\n        this.nums1 = n1.length < n2.length? n1: n2;\\n        this.nums2 = n1.length < n2.length? n2: n1;\\n        \\n        m = nums1.length;\\n        n = nums2.length;\\n        // Do binary search on product value range\\n        long l = Math.min(Math.min((long)nums1[m-1]*nums2[n-1], (long)nums1[0]*nums2[0]), Math.min((long)nums1[0]*nums2[n-1], (long)nums2[0]*nums1[m-1]));\\n        long r = Math.max(Math.max((long)nums1[m-1]*nums2[n-1], (long)nums1[0]*nums2[0]), Math.max((long)nums1[0]*nums2[n-1], (long)nums2[0]*nums1[m-1]));\\n        long res = -1;\\n        \\n        while(l <= r) {\\n            long mid = l + (r-l)/2;\\n            long count = countTillMidVal(mid);\\n\\n            if(count < k) {\\n                l = mid+1;\\n            } else {\\n                res = mid;\\n                r = mid-1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private long countTillMidVal(long val) {\\n        long count = 0;\\n        \\n        for(int num: nums1) {\\n            // if num > 0, product order is the same as nums2\\n            // if nums < 0, product order is reverse as nums2\\n            long c = 0;\\n            if(num < 0) {\\n                c = getCountNums2Reverse(val, num);\\n            } else {\\n                c = getCountNums2(val, num);\\n            }\\n            count += c;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private long getCountNums2(long val, long num1){\\n        int l = 0;\\n        int r = n - 1;\\n        long count = 0;\\n        \\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            \\n            if(nums2[mid]*num1 <= val) {\\n                count = mid+1;\\n                l = mid+1;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private long getCountNums2Reverse(long val, long num1) {\\n        int l = 0;\\n        int r = n - 1;\\n        long count = 0;\\n        \\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            \\n            if(nums2[mid]*num1 > val) {\\n                l = mid+1;\\n            } else {\\n                count = n-mid;\\n                r = mid-1;\\n            }\\n        }\\n        \\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787498,
                "title": "swift-binary-search",
                "content": "Thank you to Ankush093 for their solution in C++ [here](https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/discuss/1753363/Binary-search)\\n\\n```\\nclass Solution {\\n    func kthSmallestProduct(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {\\n        var nums1 = nums1\\n        var nums2 = nums2\\n        \\n        var n = nums1.count\\n        var m = nums2.count\\n        var result = 0\\n        var minIndex = min(nums1[0], nums2[0])\\n        var maxIndex = max(nums1[n - 1], nums2[m - 1])\\n        \\n        var left = min(minIndex, maxIndex*minIndex)\\n        var right = max(maxIndex*maxIndex, minIndex*minIndex)\\n        \\n        while left <= right {\\n            var mid = left + (right - left) / 2\\n            if valid(&nums1,&nums2,n,m,mid,k) {\\n                result = mid\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func getValue1(_ x: Int, _ nums2: inout [Int], _ m: Int, _ val: Int) -> Int {\\n        var left = 0\\n        var right = m - 1\\n        var result = m\\n        \\n        while left <= right {\\n            var mid = left + (right - left) / 2\\n            if x * nums2[mid] <= val {\\n                result = mid\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return m - result\\n    }\\n    \\n    func getValue2(_ x: Int, _ nums2: inout [Int], _ m: Int, _ val: Int) -> Int {\\n        var left = 0\\n        var right = m - 1\\n        var result = 0\\n        \\n        while left <= right {\\n            var mid = left + (right - left) / 2\\n            if x * nums2[mid] <= val {\\n                result = mid + 1\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func valid(_ nums1: inout [Int], _ nums2: inout [Int], _ n : Int, _ m: Int, _ mid: Int, _ k : Int) -> Bool {\\n        var result = 0\\n        for index in 0 ..< n {\\n            if nums1[index] < 0 {\\n                result += getValue1(nums1[index], &nums2, m, mid)\\n            } else {\\n                result += getValue2(nums1[index], &nums2, m, mid)\\n            }\\n        }\\n        return result >= k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    func kthSmallestProduct(_ nums1: [Int], _ nums2: [Int], _ k: Int) -> Int {\\n        var nums1 = nums1\\n        var nums2 = nums2\\n        \\n        var n = nums1.count\\n        var m = nums2.count\\n        var result = 0\\n        var minIndex = min(nums1[0], nums2[0])\\n        var maxIndex = max(nums1[n - 1], nums2[m - 1])\\n        \\n        var left = min(minIndex, maxIndex*minIndex)\\n        var right = max(maxIndex*maxIndex, minIndex*minIndex)\\n        \\n        while left <= right {\\n            var mid = left + (right - left) / 2\\n            if valid(&nums1,&nums2,n,m,mid,k) {\\n                result = mid\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    func getValue1(_ x: Int, _ nums2: inout [Int], _ m: Int, _ val: Int) -> Int {\\n        var left = 0\\n        var right = m - 1\\n        var result = m\\n        \\n        while left <= right {\\n            var mid = left + (right - left) / 2\\n            if x * nums2[mid] <= val {\\n                result = mid\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return m - result\\n    }\\n    \\n    func getValue2(_ x: Int, _ nums2: inout [Int], _ m: Int, _ val: Int) -> Int {\\n        var left = 0\\n        var right = m - 1\\n        var result = 0\\n        \\n        while left <= right {\\n            var mid = left + (right - left) / 2\\n            if x * nums2[mid] <= val {\\n                result = mid + 1\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func valid(_ nums1: inout [Int], _ nums2: inout [Int], _ n : Int, _ m: Int, _ mid: Int, _ k : Int) -> Bool {\\n        var result = 0\\n        for index in 0 ..< n {\\n            if nums1[index] < 0 {\\n                result += getValue1(nums1[index], &nums2, m, mid)\\n            } else {\\n                result += getValue2(nums1[index], &nums2, m, mid)\\n            }\\n        }\\n        return result >= k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753363,
                "title": "binary-search",
                "content": "\\n```\\nclass Solution {\\n    //function for counting valid elements whose product with elements of second vector(nums2) is less than or equal to val when the element of first vector(nums1) is negative\\n    int getvalue1(long long x,vector<int>& nums2,int m,long long val){\\n        int l = 0 ,r = m - 1;\\n        int ans = m;\\n        while( l <= r){\\n            int mid = l + (r-l)/2;\\n            if(x *1LL* nums2[mid] <= val){\\n                ans = mid;\\n                r = mid -1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return m - ans;\\n    }\\n    //function for counting valid elements whose product with elements of second vector(nums2) is less than or equal to val when the element of first vector(nums1) is positive\\n    int getvalue2(long long x,vector<int>& nums2,int m,long long val){\\n        int l = 0 ,r = m - 1;\\n        int ans = 0;\\n        while( l <= r){\\n            int mid = l + (r-l)/2;\\n            if(x *1LL* nums2[mid] <= val){\\n                ans = mid +1;\\n                l = mid +1;\\n            }\\n            else\\n                r = mid - 1;\\n        }\\n        return ans;\\n    }\\n    \\n    bool valid(vector<int>& nums1, vector<int>& nums2,int n ,int m,long long mid,long long  k){\\n        long long  ans = 0;\\n        //counting the valid pairing of each element of first vector(nums1) with the elements of second vector(nums2)\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums1[i] < 0)\\n            ans += getvalue1(nums1[i],nums2,m,mid);\\n            else\\n            ans +=getvalue2(nums1[i],nums2,m,mid);\\n        }\\n        return ans >= k;\\n    }\\npublic:\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        \\n        int n = nums1.size() , m = nums2.size() ;\\n        long long ans = 0;\\n        long long  mini = min(nums1[0],nums2[0]),maxi = max(nums1[n - 1],nums2[m - 1]);\\n        long long l = min(mini*maxi,mini),r=max(mini*mini,maxi*maxi);\\n        while(l <= r){\\n            \\n            long long mid = l + (r - l)/2;\\n           \\n            if(valid(nums1,nums2,n,m,mid,k)){\\n                ans = mid ;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    //function for counting valid elements whose product with elements of second vector(nums2) is less than or equal to val when the element of first vector(nums1) is negative\\n    int getvalue1(long long x,vector<int>& nums2,int m,long long val){\\n        int l = 0 ,r = m - 1;\\n        int ans = m;\\n        while( l <= r){\\n            int mid = l + (r-l)/2;\\n            if(x *1LL* nums2[mid] <= val){\\n                ans = mid;\\n                r = mid -1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return m - ans;\\n    }\\n    //function for counting valid elements whose product with elements of second vector(nums2) is less than or equal to val when the element of first vector(nums1) is positive\\n    int getvalue2(long long x,vector<int>& nums2,int m,long long val){\\n        int l = 0 ,r = m - 1;\\n        int ans = 0;\\n        while( l <= r){\\n            int mid = l + (r-l)/2;\\n            if(x *1LL* nums2[mid] <= val){\\n                ans = mid +1;\\n                l = mid +1;\\n            }\\n            else\\n                r = mid - 1;\\n        }\\n        return ans;\\n    }\\n    \\n    bool valid(vector<int>& nums1, vector<int>& nums2,int n ,int m,long long mid,long long  k){\\n        long long  ans = 0;\\n        //counting the valid pairing of each element of first vector(nums1) with the elements of second vector(nums2)\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums1[i] < 0)\\n            ans += getvalue1(nums1[i],nums2,m,mid);\\n            else\\n            ans +=getvalue2(nums1[i],nums2,m,mid);\\n        }\\n        return ans >= k;\\n    }\\npublic:\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        \\n        int n = nums1.size() , m = nums2.size() ;\\n        long long ans = 0;\\n        long long  mini = min(nums1[0],nums2[0]),maxi = max(nums1[n - 1],nums2[m - 1]);\\n        long long l = min(mini*maxi,mini),r=max(mini*mini,maxi*maxi);\\n        while(l <= r){\\n            \\n            long long mid = l + (r - l)/2;\\n           \\n            if(valid(nums1,nums2,n,m,mid,k)){\\n                ans = mid ;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680599,
                "title": "what-s-wrong-why-a-vector-is-not-taking-long-long-data-type-inside-it",
                "content": "```\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        vector<long long>nums3;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                nums3.push_back(nums1[i]*nums2[j]);\\n            }\\n        }\\n        sort(nums3.begin(),nums3.end());\\n        return nums3[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kthSmallestProduct(vector<int>& nums1, vector<int>& nums2, long long k) {\\n        vector<long long>nums3;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                nums3.push_back(nums1[i]*nums2[j]);\\n            }\\n        }\\n        sort(nums3.begin(),nums3.end());\\n        return nums3[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666425,
                "title": "binary-search",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    long long kthSmallestProduct(vector<int> &nums1, vector<int> &nums2, long long k)\\n    {\\n        // \\u4E58\\u79EF\\u503C\\u4E00\\u5B9A\\u5728 [-10000000000, 10000000000]\\u4E4B\\u95F4.\\n        // \\u503C\\u7684\\u6700\\u5927\\u8303\\u56F4\\u8DE8\\u5EA6(MAX-VLAUE-RANGE) = 20000000000\\n\\n        // \\u7B97\\u6CD5\\u590D\\u6742\\u5EA6\\u8003\\u8651: Log(MAX-VLAUE-RANGE) * |nums1| * log(|nums2|)\\n        // \\u56E0\\u6B64, \\u5C06nums1\\u8BBE\\u5B9A\\u4E3A\\u957F\\u5EA6\\u8F83\\u5C0F\\u7684\\u6570\\u7EC4\\n        if (nums1.size() > nums2.size())\\n        {\\n            nums1.swap(nums2);\\n        }\\n\\n        long long begin = -10000000000ll;\\n        long long end = 10000000000ll;\\n        long long result = -1;\\n        while (begin <= end)\\n        {\\n            auto middle = (begin + end) / 2;\\n\\n            //\\u4E0D\\u5927\\u4E8Emiddle\\u7684\\u4E58\\u79EF\\u5BF9\\u7684\\u4E2A\\u6570\\n            long long count = 0;\\n            for (auto &n1 : nums1)\\n            {\\n                count += getTotalNotGreaterThan(nums2, n1, middle);\\n            }\\n            if (count >= k)\\n            {\\n                result = middle;\\n                end = middle - 1;\\n            }\\n            else\\n            {\\n                begin = middle + 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    //\\u5728nums2\\u4E2D, \\u4E0En1\\u76F8\\u4E58\\uFF0C\\u4F46\\u662F\\u4E58\\u79EF\\u503C\\u4E0D\\u5927\\u4E8Evalue\\u7684\\u5143\\u7D20\\u4E2A\\u6570.\\n    long long getTotalNotGreaterThan(vector<int> &nums2, long long n1, long long value)\\n    {\\n        //\\u53EF\\u4EE5\\u81EA\\u5DF1\\u5199\\u4E00\\u4E2Abinary search, \\u6211\\u8FD9\\u91CC\\u5957\\u7528stl upper_bound/lower_bound\\u65B9\\u6CD5.\\n        if (n1 >= 0)\\n        {\\n            return distance(nums2.begin(), upper_bound(nums2.begin(), nums2.end(), -1, [=](int v1, int v2)\\n                                                       { return value < (long)v2 * n1; }));\\n        }\\n        else\\n        {\\n            n1 *= -1;\\n            return distance(lower_bound(nums2.begin(), nums2.end(), -1, [=](int v1, int v2)\\n                                        { return (long)v1 * n1 < -value; }),\\n                            nums2.end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long kthSmallestProduct(vector<int> &nums1, vector<int> &nums2, long long k)\\n    {\\n        // \\u4E58\\u79EF\\u503C\\u4E00\\u5B9A\\u5728 [-10000000000, 10000000000]\\u4E4B\\u95F4.\\n        // \\u503C\\u7684\\u6700\\u5927\\u8303\\u56F4\\u8DE8\\u5EA6(MAX-VLAUE-RANGE) = 20000000000\\n\\n        // \\u7B97\\u6CD5\\u590D\\u6742\\u5EA6\\u8003\\u8651: Log(MAX-VLAUE-RANGE) * |nums1| * log(|nums2|)\\n        // \\u56E0\\u6B64, \\u5C06nums1\\u8BBE\\u5B9A\\u4E3A\\u957F\\u5EA6\\u8F83\\u5C0F\\u7684\\u6570\\u7EC4\\n        if (nums1.size() > nums2.size())\\n        {\\n            nums1.swap(nums2);\\n        }\\n\\n        long long begin = -10000000000ll;\\n        long long end = 10000000000ll;\\n        long long result = -1;\\n        while (begin <= end)\\n        {\\n            auto middle = (begin + end) / 2;\\n\\n            //\\u4E0D\\u5927\\u4E8Emiddle\\u7684\\u4E58\\u79EF\\u5BF9\\u7684\\u4E2A\\u6570\\n            long long count = 0;\\n            for (auto &n1 : nums1)\\n            {\\n                count += getTotalNotGreaterThan(nums2, n1, middle);\\n            }\\n            if (count >= k)\\n            {\\n                result = middle;\\n                end = middle - 1;\\n            }\\n            else\\n            {\\n                begin = middle + 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    //\\u5728nums2\\u4E2D, \\u4E0En1\\u76F8\\u4E58\\uFF0C\\u4F46\\u662F\\u4E58\\u79EF\\u503C\\u4E0D\\u5927\\u4E8Evalue\\u7684\\u5143\\u7D20\\u4E2A\\u6570.\\n    long long getTotalNotGreaterThan(vector<int> &nums2, long long n1, long long value)\\n    {\\n        //\\u53EF\\u4EE5\\u81EA\\u5DF1\\u5199\\u4E00\\u4E2Abinary search, \\u6211\\u8FD9\\u91CC\\u5957\\u7528stl upper_bound/lower_bound\\u65B9\\u6CD5.\\n        if (n1 >= 0)\\n        {\\n            return distance(nums2.begin(), upper_bound(nums2.begin(), nums2.end(), -1, [=](int v1, int v2)\\n                                                       { return value < (long)v2 * n1; }));\\n        }\\n        else\\n        {\\n            n1 *= -1;\\n            return distance(lower_bound(nums2.begin(), nums2.end(), -1, [=](int v1, int v2)\\n                                        { return (long)v1 * n1 < -value; }),\\n                            nums2.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567080,
                "content": [
                    {
                        "username": "antarestrue",
                        "content": "Seems like everyone is using binary search for this one, but is it possible to use the priority_queue approach in\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/ ?"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was my first idea. It times out, because the time complexity is `O(k*log(n))`, and `k` can be `n²`. If `n` is `5e4`, there are 39 billion operations, while LeetCode allows up to few millions usually."
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "priority_queue<long, vector<long> , greater<long>> pq;\\n        long long int res;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i =0; i<n ; i++){\\n            for(int j =0; j<m ; j++){\\n                long long int var = nums1[i]*nums2[j];\\n                pq.push(var);\\n            }\\n        }\\n        int i =0;\\n        while(i<k && !pq.empty()){\\n            res = pq.top();\\n            i++;\\n            cout<<res<<\" \";\\n            pq.pop();\\n        }\\n        return res;\\n        \\n\\n\\nit is showing integer overflow. "
                    },
                    {
                        "username": "rajghoshbravo614",
                        "content": "It\\'d increase the time complexity."
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Leetcode can have Very Hard section"
                    },
                    {
                        "username": "A-ANNAMALAI_ESWARAN",
                        "content": "Why my program gives 100000 * 100000 = 1410065408???"
                    },
                    {
                        "username": "Finesse",
                        "content": "Try Python if you are\\'t comfortable with low-level programming restrictions"
                    },
                    {
                        "username": "ank1t-choudhary",
                        "content": "overflow, use long long instead of int."
                    },
                    {
                        "username": "iakhtar0271",
                        "content": "use long data type instead of int."
                    }
                ]
            },
            {
                "id": 1815024,
                "content": [
                    {
                        "username": "antarestrue",
                        "content": "Seems like everyone is using binary search for this one, but is it possible to use the priority_queue approach in\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/ ?"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was my first idea. It times out, because the time complexity is `O(k*log(n))`, and `k` can be `n²`. If `n` is `5e4`, there are 39 billion operations, while LeetCode allows up to few millions usually."
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "priority_queue<long, vector<long> , greater<long>> pq;\\n        long long int res;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i =0; i<n ; i++){\\n            for(int j =0; j<m ; j++){\\n                long long int var = nums1[i]*nums2[j];\\n                pq.push(var);\\n            }\\n        }\\n        int i =0;\\n        while(i<k && !pq.empty()){\\n            res = pq.top();\\n            i++;\\n            cout<<res<<\" \";\\n            pq.pop();\\n        }\\n        return res;\\n        \\n\\n\\nit is showing integer overflow. "
                    },
                    {
                        "username": "rajghoshbravo614",
                        "content": "It\\'d increase the time complexity."
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Leetcode can have Very Hard section"
                    },
                    {
                        "username": "A-ANNAMALAI_ESWARAN",
                        "content": "Why my program gives 100000 * 100000 = 1410065408???"
                    },
                    {
                        "username": "Finesse",
                        "content": "Try Python if you are\\'t comfortable with low-level programming restrictions"
                    },
                    {
                        "username": "ank1t-choudhary",
                        "content": "overflow, use long long instead of int."
                    },
                    {
                        "username": "iakhtar0271",
                        "content": "use long data type instead of int."
                    }
                ]
            },
            {
                "id": 1787364,
                "content": [
                    {
                        "username": "antarestrue",
                        "content": "Seems like everyone is using binary search for this one, but is it possible to use the priority_queue approach in\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/ ?"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was my first idea. It times out, because the time complexity is `O(k*log(n))`, and `k` can be `n²`. If `n` is `5e4`, there are 39 billion operations, while LeetCode allows up to few millions usually."
                    },
                    {
                        "username": "ankitnainwal999",
                        "content": "priority_queue<long, vector<long> , greater<long>> pq;\\n        long long int res;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i =0; i<n ; i++){\\n            for(int j =0; j<m ; j++){\\n                long long int var = nums1[i]*nums2[j];\\n                pq.push(var);\\n            }\\n        }\\n        int i =0;\\n        while(i<k && !pq.empty()){\\n            res = pq.top();\\n            i++;\\n            cout<<res<<\" \";\\n            pq.pop();\\n        }\\n        return res;\\n        \\n\\n\\nit is showing integer overflow. "
                    },
                    {
                        "username": "rajghoshbravo614",
                        "content": "It\\'d increase the time complexity."
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "Leetcode can have Very Hard section"
                    },
                    {
                        "username": "A-ANNAMALAI_ESWARAN",
                        "content": "Why my program gives 100000 * 100000 = 1410065408???"
                    },
                    {
                        "username": "Finesse",
                        "content": "Try Python if you are\\'t comfortable with low-level programming restrictions"
                    },
                    {
                        "username": "ank1t-choudhary",
                        "content": "overflow, use long long instead of int."
                    },
                    {
                        "username": "iakhtar0271",
                        "content": "use long data type instead of int."
                    }
                ]
            }
        ]
    }
]