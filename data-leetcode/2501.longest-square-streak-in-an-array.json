[
    {
        "title": "Longest Square Streak in an Array",
        "question_content": "You are given an integer array nums. A subsequence of nums is called a square streak if:\n\n\tThe length of the subsequence is at least 2, and\n\tafter sorting the subsequence, each element (except the first element) is the square of the previous number.\n\nReturn the length of the longest square streak in nums, or return -1 if there is no square streak.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n&nbsp;\nExample 1:\n\nInput: nums = [4,3,6,16,8,2]\nOutput: 3\nExplanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16].\n- 4 = 2 * 2.\n- 16 = 4 * 4.\nTherefore, [4,16,2] is a square streak.\nIt can be shown that every subsequence of length 4 is not a square streak.\n\nExample 2:\n\nInput: nums = [2,3,5,6,7]\nOutput: -1\nExplanation: There is no square streak in nums so return -1.\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 105\n\t2 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 2899678,
                "title": "short-dp-c-java-lis-type",
                "content": "+ # For every number we reach, we just check if its a `perfect square`:\\n   + If its a `Perfect Square`, we pair up with its `Square Root`.\\n   + Else, we keep it in `dp` array with length as `1`, for pairing up its `square number` later.\\n \\n Similar Question : [1218. Longest Arithmetic Subsequence of Given Difference](https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/#:~:text=Input%3A%20arr%20%3D%20%5B1%2C,subsequence%20is%20any%20single%20element.)\\n# C++    \\n\\tint longestSquareStreak(vector<int>& A) {\\n        unordered_map<int, int> dp;\\n        int res = 0;\\n        sort(begin(A), end(A));\\n        for(auto i : A){\\n            int root = sqrt(i);\\n            if(root * root == i)\\n\\t\\t\\t   dp[i] = 1 + dp[root];\\n\\t\\t\\telse \\n\\t\\t\\t   dp[i] = 1;\\n            res = max(res, dp[i]);\\n        }\\n        return res < 2 ? -1 : res;\\n    }\\n# Java\\n    public int longestSquareStreak(int[] A) {\\n        HashMap<Integer, Integer> dp = new HashMap<>();\\n        int res = 0;\\n        Arrays.sort(A);\\n        for(var i : A){\\n            int root = (int)Math.sqrt(i);\\n            if(root * root == i)  \\n\\t\\t\\t   dp.put(i, dp.getOrDefault(root, 0) + 1);\\n            else  \\n\\t\\t\\t   dp.put(i, 1);\\n            res = Math.max(res, dp.get(i));\\n        }\\n        return res < 2 ? -1 : res;\\n    }\\n> Time : O(nlogn)\\n\\n> Space - O(n)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "+ # For every number we reach, we just check if its a `perfect square`:\\n   + If its a `Perfect Square`, we pair up with its `Square Root`.\\n   + Else, we keep it in `dp` array with length as `1`, for pairing up its `square number` later.\\n \\n Similar Question : [1218. Longest Arithmetic Subsequence of Given Difference](https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/#:~:text=Input%3A%20arr%20%3D%20%5B1%2C,subsequence%20is%20any%20single%20element.)\\n# C++    \\n\\tint longestSquareStreak(vector<int>& A) {\\n        unordered_map<int, int> dp;\\n        int res = 0;\\n        sort(begin(A), end(A));\\n        for(auto i : A){\\n            int root = sqrt(i);\\n            if(root * root == i)\\n\\t\\t\\t   dp[i] = 1 + dp[root];\\n\\t\\t\\telse \\n\\t\\t\\t   dp[i] = 1;\\n            res = max(res, dp[i]);\\n        }\\n        return res < 2 ? -1 : res;\\n    }\\n# Java\\n    public int longestSquareStreak(int[] A) {\\n        HashMap<Integer, Integer> dp = new HashMap<>();\\n        int res = 0;\\n        Arrays.sort(A);\\n        for(var i : A){\\n            int root = (int)Math.sqrt(i);\\n            if(root * root == i)  \\n\\t\\t\\t   dp.put(i, dp.getOrDefault(root, 0) + 1);\\n            else  \\n\\t\\t\\t   dp.put(i, 1);\\n            res = Math.max(res, dp.get(i));\\n        }\\n        return res < 2 ? -1 : res;\\n    }\\n> Time : O(nlogn)\\n\\n> Space - O(n)",
                "codeTag": "Unknown"
            },
            {
                "id": 2899431,
                "title": "c-using-set-dp-not-required-very-simple-and-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        unordered_set<int> s;\\n        for(auto n: nums) s.insert(n);\\n        for(auto n: nums) {\\n            \\n            long long t = n;\\n            int c = 0;\\n            while(s.find(t) != s.end()){\\n                c++;\\n                s.erase(t);\\n                t = t*t;\\n            }\\n            ans = max(ans, c);\\n        }\\n        return ans<2?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        unordered_set<int> s;\\n        for(auto n: nums) s.insert(n);\\n        for(auto n: nums) {\\n            \\n            long long t = n;\\n            int c = 0;\\n            while(s.find(t) != s.end()){\\n                c++;\\n                s.erase(t);\\n                t = t*t;\\n            }\\n            ans = max(ans, c);\\n        }\\n        return ans<2?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899425,
                "title": "python-c-extract-square-root-till-death",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Python.**\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        \\n        sqr = Counter(sorted(set(nums)))\\n        \\n        for n in sqr:\\n            while (s:=isqrt(n))**2 == n and s in sqr:\\n                sqr[s] += 1\\n                n = s\\n\\n        return c if (c:=max(sqr.values())) >= 2 else -1\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        auto isqrt = [](int n) { return (int)floor(sqrt(n)); };\\n        \\n        sort(nums.begin(), nums.end());\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        \\n        int s, c = 0;\\n        unordered_map<int,int> sqr;\\n        \\n        for (int n : nums)\\n        {\\n            sqr[n] = 1;\\n            while ((s = isqrt(n)) && s*s == n && sqr.count(s))\\n                sqr[s] += 1, n = s;\\n        }\\n        \\n        for (auto[n,s] : sqr) c = max(c,s);\\n        return c > 1 ? c : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        \\n        sqr = Counter(sorted(set(nums)))\\n        \\n        for n in sqr:\\n            while (s:=isqrt(n))**2 == n and s in sqr:\\n                sqr[s] += 1\\n                n = s\\n\\n        return c if (c:=max(sqr.values())) >= 2 else -1\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        auto isqrt = [](int n) { return (int)floor(sqrt(n)); };\\n        \\n        sort(nums.begin(), nums.end());\\n        nums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        \\n        int s, c = 0;\\n        unordered_map<int,int> sqr;\\n        \\n        for (int n : nums)\\n        {\\n            sqr[n] = 1;\\n            while ((s = isqrt(n)) && s*s == n && sqr.count(s))\\n                sqr[s] += 1, n = s;\\n        }\\n        \\n        for (auto[n,s] : sqr) c = max(c,s);\\n        return c > 1 ? c : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899387,
                "title": "c-hashmap-sorting-easy-approach",
                "content": "# Approach\\nSort nums in decreasing order so that instead of finding square of elements, we can find square root of elements. Then, we store frequency of each element in the hashmap. Then, we find perfect square root of each element (if exists) repeatedly until that element becomes a prime number.\\n\\n# Time Complexity\\nO(N*log(N))\\n\\n# Space Complexity\\nO(N) \\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {  \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        unordered_map<int, int> mp;\\n        for(auto &it:nums)\\n        {\\n            mp[it]++;\\n        }\\n        \\n        int count;\\n        int maxi=1;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            count=1;\\n            int x=nums[i];\\n            while(mp[sqrt(x)]>0)\\n            {\\n                int p=sqrt(x);\\n                //Since sqrt(x) can be a decimal number so we need to check  perfect square condition\\n                if(p*p==x) count++;\\n                else break;\\n                mp[sqrt(x)]--;\\n                x = sqrt(x);\\n            }\\n            maxi = max(maxi, count);\\n        }\\n        return maxi==1?-1:maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {  \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        unordered_map<int, int> mp;\\n        for(auto &it:nums)\\n        {\\n            mp[it]++;\\n        }\\n        \\n        int count;\\n        int maxi=1;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            count=1;\\n            int x=nums[i];\\n            while(mp[sqrt(x)]>0)\\n            {\\n                int p=sqrt(x);\\n                //Since sqrt(x) can be a decimal number so we need to check  perfect square condition\\n                if(p*p==x) count++;\\n                else break;\\n                mp[sqrt(x)]--;\\n                x = sqrt(x);\\n            }\\n            maxi = max(maxi, count);\\n        }\\n        return maxi==1?-1:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899470,
                "title": "hashmap-and-sorting-java",
                "content": "# Intuition \\nusing hashmap to store array elements and sorting it\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Complexity\\n- Time complexity:o(NlogN)\\n<!-- O(N) -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer> m=new HashMap<>();\\n        int res=-1;\\n        for(int x:nums){\\n            int perfect=(int)Math.sqrt(x);\\n            //check perfect int or not as there may be int which will not form perfect square\\n            \\n            if(perfect*perfect==x && m.containsKey(perfect)){\\n                m.put(x,m.get(perfect)+1);\\n                res=Math.max((m.get(perfect)+1),res);   \\n            }\\n            else{\\n                m.put(x,1);\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer> m=new HashMap<>();\\n        int res=-1;\\n        for(int x:nums){\\n            int perfect=(int)Math.sqrt(x);\\n            //check perfect int or not as there may be int which will not form perfect square\\n            \\n            if(perfect*perfect==x && m.containsKey(perfect)){\\n                m.put(x,m.get(perfect)+1);\\n                res=Math.max((m.get(perfect)+1),res);   \\n            }\\n            else{\\n                m.put(x,1);\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899488,
                "title": "c-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        map<long long,long long> mp;\\n        int n = nums.size();\\n        \\n        for(auto it : nums)\\n        {\\n            mp[it]++;\\n        }\\n        \\n        int mx = -1;\\n        bool flag = false;\\n        for(auto it : mp)\\n        {\\n            long long curr = it.first*it.first;\\n            int cnt = 1;\\n            while(mp.count(curr)==1)\\n            {\\n                cout<<curr<<\" \";\\n                flag = true;\\n                cnt++;\\n                curr = curr*curr;\\n            }\\n            \\n            mx = max(cnt,mx);\\n        }\\n        \\n        if(!flag) return -1;\\n        \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        map<long long,long long> mp;\\n        int n = nums.size();\\n        \\n        for(auto it : nums)\\n        {\\n            mp[it]++;\\n        }\\n        \\n        int mx = -1;\\n        bool flag = false;\\n        for(auto it : mp)\\n        {\\n            long long curr = it.first*it.first;\\n            int cnt = 1;\\n            while(mp.count(curr)==1)\\n            {\\n                cout<<curr<<\" \";\\n                flag = true;\\n                cnt++;\\n                curr = curr*curr;\\n            }\\n            \\n            mx = max(cnt,mx);\\n        }\\n        \\n        if(!flag) return -1;\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2899909,
                "title": "set-with-optimizations",
                "content": "Many ways to solve this problem.\\n\\n## Set\\nHere, we insert small values (< 317), and values with an integer square root, into a sorted set.\\n\\nThen, for each small value, we check it\\'s square root sequence.\\n\\n**C++**\\n```cpp\\nint longestSquareStreak(vector<int>& n) {\\n    int res = 0;\\n    set<int> s;\\n    for(int val : n)\\n        if (int sr = sqrt(val); val < 317 || sr * sr == val)\\n            s.insert(val);\\n    for (auto it = begin(s); it != end(s) && *it < 317; ++it) {\\n        int sz = s.size();\\n        for (int i = *it; i < 317 && s.count(i * i); i *= i)\\n            s.erase(i * i);\\n        res = max(res, sz - (int)s.size());\\n    }\\n    return res == 0 ? -1 : res + 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint longestSquareStreak(vector<int>& n) {\\n    int res = 0;\\n    set<int> s;\\n    for(int val : n)\\n        if (int sr = sqrt(val); val < 317 || sr * sr == val)\\n            s.insert(val);\\n    for (auto it = begin(s); it != end(s) && *it < 317; ++it) {\\n        int sz = s.size();\\n        for (int i = *it; i < 317 && s.count(i * i); i *= i)\\n            s.erase(i * i);\\n        res = max(res, sz - (int)s.size());\\n    }\\n    return res == 0 ? -1 : res + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2899570,
                "title": "c-dp-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<int>dp(n, 0);\\n        dp[n - 1] = 1;\\n        int mxLen = 1;\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            long long target = (long long)nums[i] * nums[i];\\n            //======================================================\\n            int low = i + 1, high = n - 1;\\n            int pos = -1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) { pos = mid; break; }\\n                else if (nums[mid] < target) low = mid + 1;\\n                else if (nums[mid] > target) high = mid - 1;\\n            }\\n            //=========================================================\\n            int currLen;\\n            if (pos == -1) currLen = 1;\\n            else currLen = 1 + dp[pos];\\n            dp[i] = currLen;\\n            mxLen = max(dp[i], mxLen);\\n        }\\n        if (mxLen == 1) return -1;\\n        return mxLen;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<int>dp(n, 0);\\n        dp[n - 1] = 1;\\n        int mxLen = 1;\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            long long target = (long long)nums[i] * nums[i];\\n            //======================================================\\n            int low = i + 1, high = n - 1;\\n            int pos = -1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) { pos = mid; break; }\\n                else if (nums[mid] < target) low = mid + 1;\\n                else if (nums[mid] > target) high = mid - 1;\\n            }\\n            //=========================================================\\n            int currLen;\\n            if (pos == -1) currLen = 1;\\n            else currLen = 1 + dp[pos];\\n            dp[i] = currLen;\\n            mxLen = max(dp[i], mxLen);\\n        }\\n        if (mxLen == 1) return -1;\\n        return mxLen;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899507,
                "title": "java-hashmap-o-n-logn",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n*logn)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=nums.length-1; i>=0; i--) \\n            map.put(nums[i], map.getOrDefault(nums[i]*nums[i], 0) +1);\\n        int max = 0;\\n        for(int val : map.values())\\n            max = Math.max(max, val);\\n        return max == 1 ? -1 : max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=nums.length-1; i>=0; i--) \\n            map.put(nums[i], map.getOrDefault(nums[i]*nums[i], 0) +1);\\n        int max = 0;\\n        for(int val : map.values())\\n            max = Math.max(max, val);\\n        return max == 1 ? -1 : max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899398,
                "title": "python-java-sort-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        square = {}\\n        nums.sort(reverse = True)\\n        res = -1\\n        for num in nums:\\n            if num * num in square:\\n                square[num] = square[num * num] + 1\\n                res = max(res, square[num])\\n            else:\\n                square[num] = 1\\n        return res\\n\\n\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Map<Integer, Integer> square = new HashMap<>();\\n        Arrays.sort(nums);\\n        int res = -1;\\n        for (int i = nums.length - 1; i > -1; i --) {\\n            int num = nums[i];\\n            if (square.containsKey(num * num)) {\\n                square.put(num, square.get(num * num) + 1);\\n                res = Math.max(res, square.get(num));\\n            } else {\\n                square.put(num, 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        square = {}\\n        nums.sort(reverse = True)\\n        res = -1\\n        for num in nums:\\n            if num * num in square:\\n                square[num] = square[num * num] + 1\\n                res = max(res, square[num])\\n            else:\\n                square[num] = 1\\n        return res\\n\\n\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Map<Integer, Integer> square = new HashMap<>();\\n        Arrays.sort(nums);\\n        int res = -1;\\n        for (int i = nums.length - 1; i > -1; i --) {\\n            int num = nums[i];\\n            if (square.containsKey(num * num)) {\\n                square.put(num, square.get(num * num) + 1);\\n                res = Math.max(res, square.get(num));\\n            } else {\\n                square.put(num, 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899374,
                "title": "python-simple-sorting-solution",
                "content": "```\\ndef longestSquareStreak(self, nums: List[int]) -> int:\\n\\tnums, used, ans = set(nums), set(), 1\\n\\tfor n in sorted(nums):\\n\\t\\tif n in used:\\n\\t\\t\\tcontinue\\n\\t\\tused.add(n)\\n\\t\\tcur = 1\\n\\t\\twhile(n**2 in nums):\\n\\t\\t\\tused.add(n**2)\\n\\t\\t\\tn *= n \\n\\t\\t\\tcur += 1\\n\\t\\tans = max(cur, ans)\\n\\treturn ans if ans>1 else -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef longestSquareStreak(self, nums: List[int]) -> int:\\n\\tnums, used, ans = set(nums), set(), 1\\n\\tfor n in sorted(nums):\\n\\t\\tif n in used:\\n\\t\\t\\tcontinue\\n\\t\\tused.add(n)\\n\\t\\tcur = 1\\n\\t\\twhile(n**2 in nums):\\n\\t\\t\\tused.add(n**2)\\n\\t\\t\\tn *= n \\n\\t\\t\\tcur += 1\\n\\t\\tans = max(cur, ans)\\n\\treturn ans if ans>1 else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2899365,
                "title": "simple-java-solution-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int max = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i: nums) set.add(i);\\n        for(int i=0;i<nums.length;i++) {\\n            int num = nums[i];\\n            int count = 1;\\n            while(set.contains(num*num)) {\\n                num = num*num;\\n                count++;\\n            }\\n            if(count > 1 && count > max) max = count;\\n        }\\n        return max==0 ? -1 : max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int max = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i: nums) set.add(i);\\n        for(int i=0;i<nums.length;i++) {\\n            int num = nums[i];\\n            int count = 1;\\n            while(set.contains(num*num)) {\\n                num = num*num;\\n                count++;\\n            }\\n            if(count > 1 && count > max) max = count;\\n        }\\n        return max==0 ? -1 : max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899360,
                "title": "c-simple-map-and-sorting",
                "content": "## Approach\\nStore value, and sort the given vector.\\nChecking longest Square Streak one by one and erase the number in map.\\n## Code\\n```\\n#define ll long long\\nint longestSquareStreak(vector<int>& nums) {\\n    unordered_map<ll, int> m;\\n    // build map\\n    for(auto i : nums)\\n        ++m[i];\\n    sort(nums.begin(), nums.end());\\n    ll ans = -1;\\n    for(auto i : nums) {\\n        // break earlier\\n        if(!m.size())\\n            break;\\n        ll len = 0, now = i;\\n        while(m.count(now)) {\\n            m.erase(now);\\n            ++len;\\n            now *= now;\\n        }\\n        // valid ans\\n        if(len > 1)\\n            ans = max(ans, len);\\n    }\\n    return ans;\\n}\\n```\\n**Upvote** if you like this post : )",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long\\nint longestSquareStreak(vector<int>& nums) {\\n    unordered_map<ll, int> m;\\n    // build map\\n    for(auto i : nums)\\n        ++m[i];\\n    sort(nums.begin(), nums.end());\\n    ll ans = -1;\\n    for(auto i : nums) {\\n        // break earlier\\n        if(!m.size())\\n            break;\\n        ll len = 0, now = i;\\n        while(m.count(now)) {\\n            m.erase(now);\\n            ++len;\\n            now *= now;\\n        }\\n        // valid ans\\n        if(len > 1)\\n            ans = max(ans, len);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570854,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer> m=new HashMap<>();\\n        int res=-1;\\n        for(int x:nums){\\n            int perfect=(int)Math.sqrt(x);\\n            //check perfect int or not as there may be int which will not form perfect square\\n            \\n            if(perfect*perfect==x && m.containsKey(perfect)){\\n                m.put(x,m.get(perfect)+1);\\n                res=Math.max((m.get(perfect)+1),res);   \\n            }\\n            else{\\n                m.put(x,1);\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer> m=new HashMap<>();\\n        int res=-1;\\n        for(int x:nums){\\n            int perfect=(int)Math.sqrt(x);\\n            //check perfect int or not as there may be int which will not form perfect square\\n            \\n            if(perfect*perfect==x && m.containsKey(perfect)){\\n                m.put(x,m.get(perfect)+1);\\n                res=Math.max((m.get(perfect)+1),res);   \\n            }\\n            else{\\n                m.put(x,1);\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301598,
                "title": "c-2-dp-solutions-4-lines-recursive-iterative-faster-94",
                "content": "**Intuition**\\n- While traversing from backward, if current items `i`\\'s `square ( i * i )` does not exist store count 0 in `DP[i]`\\n- If  `square ( i * i )` exists in DP, store `DP[i] =  DP[i * i] + 1`\\n- Keep tracking the `max_value` for `DP[i]`\\n- Return `max_value + 1` if `max_value != 0`, otherwise -1\\n\\n**Iterative Approach** ( Accepted  \\u2705 94.32 % )\\n```c++\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums, int res = 0) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<long long, int> dp;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            long long curr = nums[i], next = curr * curr;\\n            dp[curr] = dp.count(next) ? dp[next] + 1: 0;\\n            res = max(res, dp[curr]);\\n        }\\n        return res ? res + 1: -1;\\n    }\\n};\\n```\\n\\n**Previous Attempt: Recursive Approach** ( Gets TLE \\u274C )\\n```c++\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        auto gen_key = [](long long i, long long j) { return to_string(i) + \"-\" + to_string(j); };\\n        unordered_map<string, long long> cache;\\n        \\n        function<long long(long long, long long)> go = \\n            [&](auto idx, auto prev) -> long long {\\n            if (idx == nums.size()) return 0;\\n            \\n            auto key = gen_key(idx, prev);\\n            if (cache.count(key)) return cache[key];\\n            \\n            long long res = go(idx + 1, nums[idx]);\\n            if (prev) res = max(res, go(idx + 1, prev));\\n            if (prev * prev != (long long) nums[idx]) return res;\\n            return cache[key] = max(res, 1 + go(idx + 1, nums[idx]));\\n        };\\n        \\n        auto res =  go(0LL, 0LL);\\n        return res ? res + 1: -1;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums, int res = 0) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<long long, int> dp;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            long long curr = nums[i], next = curr * curr;\\n            dp[curr] = dp.count(next) ? dp[next] + 1: 0;\\n            res = max(res, dp[curr]);\\n        }\\n        return res ? res + 1: -1;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        auto gen_key = [](long long i, long long j) { return to_string(i) + \"-\" + to_string(j); };\\n        unordered_map<string, long long> cache;\\n        \\n        function<long long(long long, long long)> go = \\n            [&](auto idx, auto prev) -> long long {\\n            if (idx == nums.size()) return 0;\\n            \\n            auto key = gen_key(idx, prev);\\n            if (cache.count(key)) return cache[key];\\n            \\n            long long res = go(idx + 1, nums[idx]);\\n            if (prev) res = max(res, go(idx + 1, prev));\\n            if (prev * prev != (long long) nums[idx]) return res;\\n            return cache[key] = max(res, 1 + go(idx + 1, nums[idx]));\\n        };\\n        \\n        auto res =  go(0LL, 0LL);\\n        return res ? res + 1: -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905642,
                "title": "python-3-11-lines-mathematics-w-brief-comments-t-m-97-68",
                "content": "Pretty much the same solution as others, except the set of potential squares has been pruned back to just those numbers `n` such that `n%4 == 0` or `n%4 == 1`.  \\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n\\n        s = set(nums)\\n        nums, ans = sorted(s), 0\\n        s = {n for n in s if n%4 < 2}\\n\\n        for n in nums:\\n            square, tally = n*n, 1\\n\\n            while square in s:\\n                s.remove(square)\\n                tally+= 1\\n                square*= square\\n\\n            ans = max(ans, tally)\\n   \\n        return ans if ans > 1 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n\\n        s = set(nums)\\n        nums, ans = sorted(s), 0\\n        s = {n for n in s if n%4 < 2}\\n\\n        for n in nums:\\n            square, tally = n*n, 1\\n\\n            while square in s:\\n                s.remove(square)\\n                tally+= 1\\n                square*= square\\n\\n            ans = max(ans, tally)\\n   \\n        return ans if ans > 1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900272,
                "title": "why-use-long-long-solving-overflow-using-int-only",
                "content": "Overflow Solution : Since constraint is- 2 <= nums[i] <= 1e5\\nSo finding squares of elements greater than 317 is useless.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n       unordered_map<int, int>mp;\\n       for(auto& it : nums) mp[it] = 1;\\n       sort(begin(nums), end(nums));\\n       int r = -1;\\n       for(int i = 0; i < nums.size(); i++) {\\n           if(nums[i] >= 317) break;\\n           int cur = nums[i] * nums[i];\\n           int cnt = 1;\\n           while(mp[cur]) {\\n               cnt++;\\n               if(cur >= 317) break;\\n               cur = cur *cur;\\n           }\\n           r = max(r, cnt);\\n       }\\n       return r == 1 ? -1 : r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n       unordered_map<int, int>mp;\\n       for(auto& it : nums) mp[it] = 1;\\n       sort(begin(nums), end(nums));\\n       int r = -1;\\n       for(int i = 0; i < nums.size(); i++) {\\n           if(nums[i] >= 317) break;\\n           int cur = nums[i] * nums[i];\\n           int cnt = 1;\\n           while(mp[cur]) {\\n               cnt++;\\n               if(cur >= 317) break;\\n               cur = cur *cur;\\n           }\\n           r = max(r, cnt);\\n       }\\n       return r == 1 ? -1 : r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900114,
                "title": "6-lines-with-hashmap",
                "content": "reversing nums is better because no need to take care of float\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        ans, buf = -1, {}\\n        for n in reversed(sorted(nums)):\\n            buf[n] = buf.get(n*n, 0) + 1\\n            if buf[n] > 1:\\n                ans = max(ans, buf[n])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        ans, buf = -1, {}\\n        for n in reversed(sorted(nums)):\\n            buf[n] = buf.get(n*n, 0) + 1\\n            if buf[n] > 1:\\n                ans = max(ans, buf[n])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899592,
                "title": "map-traversal-simple-solution-c",
                "content": "**Just store the value in map and traverse to find the square**\\n**Upvote if it was helpful**\\n```\\nclass Solution\\n{\\npublic:\\n    int longestSquareStreak(vector<int> &nums)\\n    {\\n        unordered_map<long long, long long> mp;\\n        for (auto &it : nums)\\n            mp[it]++;\\n\\n        int ans = INT_MIN;\\n        for (auto &it : mp)\\n        {\\n            long long to_search = it.first;\\n            int temp = 0;\\n            while (mp.find(to_search) != mp.end())\\n            {\\n                if (mp.find(to_search) != mp.end())\\n                {\\n                    temp++;\\n                    to_search = to_search * to_search;\\n                }\\n            }\\n            ans = max(temp, ans);\\n        }\\n        if (ans == 1 || ans == 0)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Interactive"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int longestSquareStreak(vector<int> &nums)\\n    {\\n        unordered_map<long long, long long> mp;\\n        for (auto &it : nums)\\n            mp[it]++;\\n\\n        int ans = INT_MIN;\\n        for (auto &it : mp)\\n        {\\n            long long to_search = it.first;\\n            int temp = 0;\\n            while (mp.find(to_search) != mp.end())\\n            {\\n                if (mp.find(to_search) != mp.end())\\n                {\\n                    temp++;\\n                    to_search = to_search * to_search;\\n                }\\n            }\\n            ans = max(temp, ans);\\n        }\\n        if (ans == 1 || ans == 0)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899520,
                "title": "c-hashing",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<long long, int> mp;\\n        long long res = -1;\\n        for(auto n : nums) mp[n]++;\\n        \\n        for(auto n : nums) {\\n            if(!mp.size())\\n                break;\\n            if(mp.count(n) != 0) {\\n                long long cnt = 1, cur = (long long)n * (long long)n;\\n                while(mp.size()) {\\n                    if(mp.count(cur)) {\\n                        mp.erase(cur);\\n                        ++cnt;\\n                        cur *= cur;\\n                    }\\n                    else\\n                        break;\\n                }\\n                if(cnt > 1)\\n                    res= max(res, cnt);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<long long, int> mp;\\n        long long res = -1;\\n        for(auto n : nums) mp[n]++;\\n        \\n        for(auto n : nums) {\\n            if(!mp.size())\\n                break;\\n            if(mp.count(n) != 0) {\\n                long long cnt = 1, cur = (long long)n * (long long)n;\\n                while(mp.size()) {\\n                    if(mp.count(cur)) {\\n                        mp.erase(cur);\\n                        ++cnt;\\n                        cur *= cur;\\n                    }\\n                    else\\n                        break;\\n                }\\n                if(cnt > 1)\\n                    res= max(res, cnt);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899377,
                "title": "simple-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n logn) for sorting + O(n) for traversing the loop\\n\\n- Space complexity: O(n) --> For storing elements in the hashmap\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        int p=-1,s=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int m=(int)Math.sqrt(nums[i]);\\n            if(m*m == nums[i] && nm.containsKey(m))\\n            {\\n                nm.put(nums[i],nm.get(m)+1);\\n                if(nm.containsKey(m))\\n                {\\n                    if(nm.get(m)+1>s)\\n                    {\\n                        s=nm.get(m)+1;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                nm.put(nums[i],1);\\n            }\\n        }\\n        return s;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        int p=-1,s=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int m=(int)Math.sqrt(nums[i]);\\n            if(m*m == nums[i] && nm.containsKey(m))\\n            {\\n                nm.put(nums[i],nm.get(m)+1);\\n                if(nm.containsKey(m))\\n                {\\n                    if(nm.get(m)+1>s)\\n                    {\\n                        s=nm.get(m)+1;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                nm.put(nums[i],1);\\n            }\\n        }\\n        return s;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017799,
                "title": "must-see-easy-to-understand-binary-search",
                "content": "do binary serach for every element of the array and find its square; \\ntime complexcity of binary serach is log(n);\\nbinary search for every n elements is n*log(n);\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        \\n         int ans = -1;\\n         sort(nums.begin(),nums.end());\\n         for(int i=0;i<nums.size();i++)\\n         {\\n              long long int num = nums[i];\\n              long long int pwr = num*num;\\n              long long int len = 1;\\n\\n              while(binary_search(nums.begin(),nums.end(),pwr) == true)\\n              {\\n                   len++;\\n                   long long int ele = pwr;\\n                   pwr = ele *  ele;\\n              }\\n             if(len!=1 and len > ans)\\n             ans = len;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        \\n         int ans = -1;\\n         sort(nums.begin(),nums.end());\\n         for(int i=0;i<nums.size();i++)\\n         {\\n              long long int num = nums[i];\\n              long long int pwr = num*num;\\n              long long int len = 1;\\n\\n              while(binary_search(nums.begin(),nums.end(),pwr) == true)\\n              {\\n                   len++;\\n                   long long int ele = pwr;\\n                   pwr = ele *  ele;\\n              }\\n             if(len!=1 and len > ans)\\n             ans = len;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925056,
                "title": "count-streaks",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n * log n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define has(m, x) m.find(x) != m.end()\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int> sqr;\\n        double st;\\n        for(int num: nums) {\\n            st = sqrt(num);\\n            if(ceil(st) == floor(st))\\n                sqr[num] = max(sqr[num], sqr[st] + 1);\\n            else\\n                sqr[num] = (sqr[num] == 0) ? 1 : sqr[num];\\n        }\\n        int streak = -1;\\n        for(auto el: sqr) {\\n            if(el.second > 1)\\n                streak = max(streak, el.second);\\n        }\\n        return streak;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n#define has(m, x) m.find(x) != m.end()\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int> sqr;\\n        double st;\\n        for(int num: nums) {\\n            st = sqrt(num);\\n            if(ceil(st) == floor(st))\\n                sqr[num] = max(sqr[num], sqr[st] + 1);\\n            else\\n                sqr[num] = (sqr[num] == 0) ? 1 : sqr[num];\\n        }\\n        int streak = -1;\\n        for(auto el: sqr) {\\n            if(el.second > 1)\\n                streak = max(streak, el.second);\\n        }\\n        return streak;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901649,
                "title": "java-solution-time-beats-100-space-beats-100",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n \\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Set<Long> set = new HashSet<>();\\n\\n        for(int i: nums) set.add(Long.valueOf(i));\\n\\n        int max = 0;\\n        for(int i: nums) {\\n            int cnt = 1;\\n            long num = i;\\n\\n            while(set.contains(num*num)) {\\n                num = num*num;\\n                cnt++;\\n            }\\n\\n            max = Math.max(max, cnt);\\n        }\\n\\n        return max == 1 ? -1: max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Set<Long> set = new HashSet<>();\\n\\n        for(int i: nums) set.add(Long.valueOf(i));\\n\\n        int max = 0;\\n        for(int i: nums) {\\n            int cnt = 1;\\n            long num = i;\\n\\n            while(set.contains(num*num)) {\\n                num = num*num;\\n                cnt++;\\n            }\\n\\n            max = Math.max(max, cnt);\\n        }\\n\\n        return max == 1 ? -1: max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900746,
                "title": "java-hashset-easy",
                "content": "# Please Upvote :D\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/fdf4f9e3-644e-4c23-b7ec-78cf04322602_1670753050.7683902.png)\\n\\n---\\n\\n``` java []\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int maxLen = 0;\\n\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : nums) {\\n            set.add(n);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            int len = 1;\\n\\n            while (set.contains(n * n)) {\\n                n *= n;\\n                len++;\\n            }\\n\\n            maxLen = Math.max(maxLen, len);\\n        }\\n\\n        return maxLen > 1? maxLen : -1;\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int maxLen = 0;\\n\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : nums) {\\n            set.add(n);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int n = nums[i];\\n            int len = 1;\\n\\n            while (set.contains(n * n)) {\\n                n *= n;\\n                len++;\\n            }\\n\\n            maxLen = Math.max(maxLen, len);\\n        }\\n\\n        return maxLen > 1? maxLen : -1;\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900734,
                "title": "java-simple-dp-1-pass",
                "content": "# Intuition\\nStore the numbers we\\'ve seen in a hash map as the key, and the length of the increasing subsequence as value.\\n\\nAt any value `x` we check if `sqrt(x)` is in the map, if it is, we add map[sqrt(x)] to our current subsequence length, otherwise there is no streak and we set `map[x]` to 1.\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> squareStreak = new HashMap<>();\\n        int best = -1;\\n\\n        for (int x : nums) {\\n            double sqrt = Math.pow(x, 0.5);\\n            if (sqrt % 1 == 0 && squareStreak.containsKey((int) sqrt)) {\\n                squareStreak.put(x, squareStreak.get((int) sqrt) + 1);\\n                best = Math.max(best, squareStreak.get(x));\\n            } else {\\n                squareStreak.put(x, 1);\\n            }\\n        }\\n\\n        return best;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> squareStreak = new HashMap<>();\\n        int best = -1;\\n\\n        for (int x : nums) {\\n            double sqrt = Math.pow(x, 0.5);\\n            if (sqrt % 1 == 0 && squareStreak.containsKey((int) sqrt)) {\\n                squareStreak.put(x, squareStreak.get((int) sqrt) + 1);\\n                best = Math.max(best, squareStreak.get(x));\\n            } else {\\n                squareStreak.put(x, 1);\\n            }\\n        }\\n\\n        return best;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900361,
                "title": "very-easy-o-n-solution-no-need-to-sort",
                "content": "# Intuition\\nFound this question similar to question where we have to find longest-consecutive-sequence\\nhttps://leetcode.com/problems/longest-consecutive-sequence/description/\\n\\n# Approach\\nStore all numbers intially in a map(no need to sort)\\n\\nItterate over the array and try to find all consecutive numbers in array\\n\\nLike for eg. we are standing at 2\\nwe try to find 4, then 16\\n\\nImp-> remember to erase numbers we have founded so that there is no overlap\\nSee solution for more clarity \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_map<long long int,long long int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i])==mp.end())\\n            mp[nums[i]]++;\\n        }\\n        long long int ans=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i])==mp.end())\\n            {\\n                continue;\\n            }\\n            long long int count=mp[nums[i]];\\n            if(nums[i]<(INT_MAX/nums[i]))\\n            {\\n                long long int x=nums[i]*nums[i];\\n                while(mp.find(x)!=mp.end())\\n                {\\n                    count=count+mp[x];\\n                    mp.erase(x);\\n                    if(x>(INT_MAX/x))\\n                    {\\n                        break;\\n                    }\\n                    x=x*x;\\n\\n                }\\n            }\\n            mp[nums[i]]=count;\\n            ans=max(ans,count);\\n        }\\n        if(ans<2)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_map<long long int,long long int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i])==mp.end())\\n            mp[nums[i]]++;\\n        }\\n        long long int ans=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i])==mp.end())\\n            {\\n                continue;\\n            }\\n            long long int count=mp[nums[i]];\\n            if(nums[i]<(INT_MAX/nums[i]))\\n            {\\n                long long int x=nums[i]*nums[i];\\n                while(mp.find(x)!=mp.end())\\n                {\\n                    count=count+mp[x];\\n                    mp.erase(x);\\n                    if(x>(INT_MAX/x))\\n                    {\\n                        break;\\n                    }\\n                    x=x*x;\\n\\n                }\\n            }\\n            mp[nums[i]]=count;\\n            ans=max(ans,count);\\n        }\\n        if(ans<2)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900000,
                "title": "easy-c-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin() , nums.end() , greater<int>());\\n        unordered_map<int , int> mp;\\n\\n        for(auto it: nums){\\n            mp[it] = 1;\\n        }\\n        int count;\\n        int maxi = -1;\\n\\n        for(int i=0 ; i<nums.size()-1 ; i++){\\n            count = 1;\\n            int x = nums[i];\\n\\n            while(mp[sqrt(x)]>0){\\n                int t = sqrt(x);\\n                if(t*t == x)\\n                    count++;\\n                else break;\\n                mp[sqrt(x)]--;\\n                x = sqrt(x);          \\n            }\\n            maxi = max(maxi , count);\\n        }\\n        return maxi==1?-1:maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin() , nums.end() , greater<int>());\\n        unordered_map<int , int> mp;\\n\\n        for(auto it: nums){\\n            mp[it] = 1;\\n        }\\n        int count;\\n        int maxi = -1;\\n\\n        for(int i=0 ; i<nums.size()-1 ; i++){\\n            count = 1;\\n            int x = nums[i];\\n\\n            while(mp[sqrt(x)]>0){\\n                int t = sqrt(x);\\n                if(t*t == x)\\n                    count++;\\n                else break;\\n                mp[sqrt(x)]--;\\n                x = sqrt(x);          \\n            }\\n            maxi = max(maxi , count);\\n        }\\n        return maxi==1?-1:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899876,
                "title": "c-very-easy-approach-using-unordered-set",
                "content": "```\\nint longestSquareStreak(vector<int>& nums) {\\n        long long n=nums.size();\\n        unordered_set<long long>st;\\n        sort(nums.begin(), nums.end());\\n        for(auto x:nums){\\n            st.insert(x);\\n        }\\n        vector<int>vec;\\n        long long ans=0;\\n        if(nums[0]>316){\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>316){\\n                break;\\n            }\\n            long long temp=1;\\n            if(st.find(nums[i]*nums[i])!=st.end()){\\n                long long curr=nums[i]*nums[i];\\n                temp++;\\n                while(true){\\n                    if(st.find(curr*curr)!=st.end()){\\n                        temp++;\\n                        curr=curr*curr;\\n                    }                    \\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n            ans=max(ans, temp);\\n        }\\n        if(ans==1){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n\\t*Sort the input vector and insert all items of the vector into an unordered_set.\\n\\t*Then traverse over all the items in the input vector and for each element check if it\\'s square is present. \\n\\t*keep in mind that if element exceeds 316 then square of it will not be present as 317*317 \\n\\texceeds the constraints of the elements of the input \\n\\t*even though you will be using two loops in this approach the time complexity will be o(nlogn) \\n\\tthat\\'s because of the sorting as search in an unordered_set is an O(1) operation and at max \\n\\tthe traversal will go to 316th element of the vector only.\\n\\t\\n\\tPS: hope this makes sense thank you :)",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nint longestSquareStreak(vector<int>& nums) {\\n        long long n=nums.size();\\n        unordered_set<long long>st;\\n        sort(nums.begin(), nums.end());\\n        for(auto x:nums){\\n            st.insert(x);\\n        }\\n        vector<int>vec;\\n        long long ans=0;\\n        if(nums[0]>316){\\n            return -1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>316){\\n                break;\\n            }\\n            long long temp=1;\\n            if(st.find(nums[i]*nums[i])!=st.end()){\\n                long long curr=nums[i]*nums[i];\\n                temp++;\\n                while(true){\\n                    if(st.find(curr*curr)!=st.end()){\\n                        temp++;\\n                        curr=curr*curr;\\n                    }                    \\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n            ans=max(ans, temp);\\n        }\\n        if(ans==1){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n\\t*Sort the input vector and insert all items of the vector into an unordered_set.\\n\\t*Then traverse over all the items in the input vector and for each element check if it\\'s square is present. \\n\\t*keep in mind that if element exceeds 316 then square of it will not be present as 317*317 \\n\\texceeds the constraints of the elements of the input \\n\\t*even though you will be using two loops in this approach the time complexity will be o(nlogn) \\n\\tthat\\'s because of the sorting as search in an unordered_set is an O(1) operation and at max \\n\\tthe traversal will go to 316th element of the vector only.\\n\\t\\n\\tPS: hope this makes sense thank you :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2899557,
                "title": "c-java-python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/8f409c5e220a4a1a1d7fdfbfcc1dcd24eeead232) for solutions of weekly 323. \\n\\n**Intuition**\\nIt is quite strange that sorting is allowed in this problem. However, since sorting is allowed, all that matters is whether a squared number exists. One solution via DP is to check if a number x is a squared number if so its streak is 1+dp[r] where r is the square root of x. \\n\\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        vector<int> dp(100\\'001); \\n        sort(nums.begin(), nums.end()); \\n        for (auto& x : nums) {\\n            dp[x] = max(1, dp[x]); \\n            int v = sqrt(x); \\n            if (v * v == x) dp[x] = 1 + dp[v]; \\n        }\\n        int ans = *max_element(dp.begin(), dp.end()); \\n        return ans > 1 ? ans : -1; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int[] dp = new int[100_001]; \\n        Arrays.sort(nums); \\n        int ans = 0; \\n        for (int x : nums) {\\n            dp[x] = Math.max(1, dp[x]); \\n            int v = (int) Math.sqrt(x); \\n            if (v*v == x) dp[x] = 1 + dp[v]; \\n            ans = Math.max(ans, dp[x]); \\n        }\\n        return ans > 1 ? ans : -1; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        dp = defaultdict(int)\\n        for x in sorted(nums): \\n            dp[x] = max(dp[x], 1)\\n            v = isqrt(x)\\n            if v**2 == x: dp[x] = 1 + dp[v]\\n        ans = max(dp.values())\\n        return ans if ans > 1 else -1\\n```\\n**Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        vector<int> dp(100\\'001); \\n        sort(nums.begin(), nums.end()); \\n        for (auto& x : nums) {\\n            dp[x] = max(1, dp[x]); \\n            int v = sqrt(x); \\n            if (v * v == x) dp[x] = 1 + dp[v]; \\n        }\\n        int ans = *max_element(dp.begin(), dp.end()); \\n        return ans > 1 ? ans : -1; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int[] dp = new int[100_001]; \\n        Arrays.sort(nums); \\n        int ans = 0; \\n        for (int x : nums) {\\n            dp[x] = Math.max(1, dp[x]); \\n            int v = (int) Math.sqrt(x); \\n            if (v*v == x) dp[x] = 1 + dp[v]; \\n            ans = Math.max(ans, dp[x]); \\n        }\\n        return ans > 1 ? ans : -1; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        dp = defaultdict(int)\\n        for x in sorted(nums): \\n            dp[x] = max(dp[x], 1)\\n            v = isqrt(x)\\n            if v**2 == x: dp[x] = 1 + dp[v]\\n        ans = max(dp.values())\\n        return ans if ans > 1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899483,
                "title": "python-3-simple-using-set",
                "content": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        uniq = set(nums)\\n        res = 0\\n        \\n        for i in nums:\\n            temp = i\\n            t = 0\\n            while temp * temp in uniq:\\n                temp *= temp\\n                t += 1\\n            \\n            res = max(res, t)\\n        \\n        return res + 1 if res else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        uniq = set(nums)\\n        res = 0\\n        \\n        for i in nums:\\n            temp = i\\n            t = 0\\n            while temp * temp in uniq:\\n                temp *= temp\\n                t += 1\\n            \\n            res = max(res, t)\\n        \\n        return res + 1 if res else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899478,
                "title": "using-sqrt-function-and-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<float,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            float temp = sqrt(nums[i]);\\n            if(mp.find(temp)!=mp.end()){\\n                mp[nums[i]] = mp[temp]+1;\\n            }\\n            else{\\n                mp[nums[i]]=1;\\n            }\\n        }\\n        for(auto i:mp){\\n            ans=max(ans,i.second);\\n        }\\n        if(ans==1) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<float,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            float temp = sqrt(nums[i]);\\n            if(mp.find(temp)!=mp.end()){\\n                mp[nums[i]] = mp[temp]+1;\\n            }\\n            else{\\n                mp[nums[i]]=1;\\n            }\\n        }\\n        for(auto i:mp){\\n            ans=max(ans,i.second);\\n        }\\n        if(ans==1) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899391,
                "title": "c-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        set<long long> st(nums.begin(),nums.end());\\n        long long  ans=-1;\\n        for(auto it : nums){\\n            if(st.find((long long)it*it)!=st.end()){\\n                long long  cnt=2,val=(long long)it*it;\\n                while(st.find(val*val)!=st.end()){\\n                    cnt += 1;\\n                    val = val*val;\\n                }\\n                if(ans<cnt) ans = cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        set<long long> st(nums.begin(),nums.end());\\n        long long  ans=-1;\\n        for(auto it : nums){\\n            if(st.find((long long)it*it)!=st.end()){\\n                long long  cnt=2,val=(long long)it*it;\\n                while(st.find(val*val)!=st.end()){\\n                    cnt += 1;\\n                    val = val*val;\\n                }\\n                if(ans<cnt) ans = cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682412,
                "title": "easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_map<long long ,int>mp;// to store the length of subsequence ending at num[i];\\n        sort(nums.begin(),nums.end());\\n        int ans=1;\\n        for(int i=nums.size()-1;i>=0;i--) {  // traverse in reverse order\\n            long long int num=nums[i];\\n            long long square=num*num; // calculate the square of the number\\n            if(mp.find(square)!=mp.end()){  // check if the subsequence ending at the square is there in map . if it is there then just add at susequence ending at nums[i]  that length ending at square +1;\\n                mp[nums[i]] = mp[num]+1;\\n            }\\n            else{\\n                mp[nums[i]] = 1;   // if not present the square the the length will be 1 itself \\n            }\\n            ans=max(ans,mp[nums[i]]); // take max\\n        }\\n        if(ans==1) return -1;  // if ans is still 1 the return -1\\n        return ans; // return the length of max subsequence\\n    }\\n};\\n\\n//  if have any doubt ,plz comment\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_map<long long ,int>mp;// to store the length of subsequence ending at num[i];\\n        sort(nums.begin(),nums.end());\\n        int ans=1;\\n        for(int i=nums.size()-1;i>=0;i--) {  // traverse in reverse order\\n            long long int num=nums[i];\\n            long long square=num*num; // calculate the square of the number\\n            if(mp.find(square)!=mp.end()){  // check if the subsequence ending at the square is there in map . if it is there then just add at susequence ending at nums[i]  that length ending at square +1;\\n                mp[nums[i]] = mp[num]+1;\\n            }\\n            else{\\n                mp[nums[i]] = 1;   // if not present the square the the length will be 1 itself \\n            }\\n            ans=max(ans,mp[nums[i]]); // take max\\n        }\\n        if(ans==1) return -1;  // if ans is still 1 the return -1\\n        return ans; // return the length of max subsequence\\n    }\\n};\\n\\n//  if have any doubt ,plz comment\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662719,
                "title": "o-n-solution-in-c",
                "content": "# Intuition\\nJust look at the constraints. 2 <= nums[i] <= 1e5 in this range maximum answer can possible is of length five-->(2,4,16,256,65536)\\n\\n# Approach\\njust put all the elements in the unordered_set to access them quickly.\\nthen iterate over the nums array and try to find all square numbers from that particular index. but if any nums[i] is greater than 999 then their square will be greater than 1e9 so skip that numbers.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(int i=0; i<nums.size(); i++)\\n            s.insert(nums[i]);\\n\\n        int maxi = 0;\\n        for(int i=0; i<nums.size(); i++){\\n\\n            int ans = 1;\\n            if(nums[i] <= 999){\\n\\n                long long square = nums[i]*nums[i]*1ll;\\n                int t = 5;\\n                while(t--){\\n                    \\n                    if(s.find(square) == s.end())\\n                        break;\\n                    \\n                    ans++;\\n                    if(square > 999)\\n                        break;\\n                    \\n                    square *= square;\\n\\n                }\\n\\n            }\\n\\n            maxi = max(ans,maxi);\\n\\n        }\\n\\n        return maxi < 2 ? -1:maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(int i=0; i<nums.size(); i++)\\n            s.insert(nums[i]);\\n\\n        int maxi = 0;\\n        for(int i=0; i<nums.size(); i++){\\n\\n            int ans = 1;\\n            if(nums[i] <= 999){\\n\\n                long long square = nums[i]*nums[i]*1ll;\\n                int t = 5;\\n                while(t--){\\n                    \\n                    if(s.find(square) == s.end())\\n                        break;\\n                    \\n                    ans++;\\n                    if(square > 999)\\n                        break;\\n                    \\n                    square *= square;\\n\\n                }\\n\\n            }\\n\\n            maxi = max(ans,maxi);\\n\\n        }\\n\\n        return maxi < 2 ? -1:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507232,
                "title": "c-o-n-easy-solution-faster-than-99-8-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse an array to store the presence of numbers. And loop through it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Ceates a boolean array called `A`, where `A[i]` is true if and only if `i` is present in nums. \\n2. Store a global max `maxCnt` and a local max `cnt` for the while loop. \\n3. Note that We only need to iterate from 2 to 316 in the outer loop since $317^2 > 100000$, which means elements after 317 cannot form a sequence starting from it. \\n4. Same for the while loop, we only need to continue the loop when `j` is less than 317.\\n\\n5. Note that `A[j]` can be set to `false` to speed up the performance since we have seen it and there is no need to start at `j` again. i.e. If we find `3,9,81`, it is redundant to start from `9` again.\\n6. If `maxCnt < 2`, we don\\'t find a valid sequence thus return -1; otherwise return `maxCnt`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        vector<bool> A(100001, false); \\n        for (int i : nums) {\\n            A[i] = true;\\n        }\\n\\n        int maxCnt = 0, cnt, j;\\n        for (int i = 2; i < 317; ++i) {  \\n            cnt = 0;\\n            j = i;\\n            while (A[j]) {\\n                ++cnt;\\n                A[j] = false;\\n                if (j < 317) {\\n                    j *= j;\\n                } else {\\n                    break;\\n                }\\n            }\\n            maxCnt = max(maxCnt, cnt);\\n        }\\n        \\n        return maxCnt < 2 ? -1 : maxCnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        vector<bool> A(100001, false); \\n        for (int i : nums) {\\n            A[i] = true;\\n        }\\n\\n        int maxCnt = 0, cnt, j;\\n        for (int i = 2; i < 317; ++i) {  \\n            cnt = 0;\\n            j = i;\\n            while (A[j]) {\\n                ++cnt;\\n                A[j] = false;\\n                if (j < 317) {\\n                    j *= j;\\n                } else {\\n                    break;\\n                }\\n            }\\n            maxCnt = max(maxCnt, cnt);\\n        }\\n        \\n        return maxCnt < 2 ? -1 : maxCnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329000,
                "title": "longest-square-streak-in-an-array-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem can be solved using the sliding window technique, where we maintain a window of distinct elements and move the window forward as we iterate through the array. We can use a hash set to keep track of the distinct elements in the window and update the maximum length of the window as we move forward.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a hash set to keep track of the distinct elements in the window.\\n2. Initialize two pointers `left` and `right` to the start of the array.\\n3. While the right pointer is less than the length of the array:\\n1. If the element at the right pointer is not in the hash set:\\n1. Add the element to the hash set.\\n2. Update the maximum length of the window.\\n3. Move the right pointer forward.\\n2. If the element at the right pointer is in the hash set:\\n1. Remove the element at the left pointer from the hash set.\\n2. Move the left pointer forward.\\n4. Return the maximum length of the window.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity of the algorithm is O(n), where n is the length of the input array. This is\\nbecause we iterate through the array only once and perform constant time operations for\\neach element.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int j = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] != nums[j]) {\\n                j++;\\n                nums[j] = nums[i];\\n            }\\n        }\\n        n = j + 1;\\n        int[] dp = new int[nums[n-1]+1];\\n        Arrays.fill(dp, 0);\\n        int maxNum = nums[n-1];\\n        for (int i = n-1; i >= 0; i--) {\\n            dp[nums[i]] = 1;\\n            long squaredNum = (long) nums[i] * nums[i];\\n            if (squaredNum <= maxNum) {\\n                dp[nums[i]] += dp[(int) squaredNum];\\n            }\\n        }\\n        int ans = Arrays.stream(dp).max().getAsInt();\\n        return ans < 2 ? -1 : ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int j = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] != nums[j]) {\\n                j++;\\n                nums[j] = nums[i];\\n            }\\n        }\\n        n = j + 1;\\n        int[] dp = new int[nums[n-1]+1];\\n        Arrays.fill(dp, 0);\\n        int maxNum = nums[n-1];\\n        for (int i = n-1; i >= 0; i--) {\\n            dp[nums[i]] = 1;\\n            long squaredNum = (long) nums[i] * nums[i];\\n            if (squaredNum <= maxNum) {\\n                dp[nums[i]] += dp[(int) squaredNum];\\n            }\\n        }\\n        int ans = Arrays.stream(dp).max().getAsInt();\\n        return ans < 2 ? -1 : ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167795,
                "title": "simple-and-easy-c-solution-without-sorting-using-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n      set<long long> s;\\n        for(int i=0; i<nums.size(); i++)\\n          s.insert(nums[i]);\\nint n =nums.size();\\n long long ans=-1;\\n for(int i=n-1; i>=0; i--){\\n        long long cnt=1;\\n      long long num=nums[i];\\n        while(s.count(num*num)){\\n            cnt++;\\n          num=num*num;\\n        }\\nans= max(ans,cnt);\\n }\\n\\n if(ans==1)\\n return -1;\\n return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n      set<long long> s;\\n        for(int i=0; i<nums.size(); i++)\\n          s.insert(nums[i]);\\nint n =nums.size();\\n long long ans=-1;\\n for(int i=n-1; i>=0; i--){\\n        long long cnt=1;\\n      long long num=nums[i];\\n        while(s.count(num*num)){\\n            cnt++;\\n          num=num*num;\\n        }\\nans= max(ans,cnt);\\n }\\n\\n if(ans==1)\\n return -1;\\n return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146124,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums)\\n    {\\n     unordered_set<double>st;\\n     for (int i=0;i<nums.size();i++)\\n     {\\n         st.insert(nums[i]);\\n     }\\n     int ans=1;\\n     int cur=1;\\n     for (int i=0;i<nums.size();i++)\\n     { \\n         cur=1;\\n         double val=(double)nums[i];\\n         val=sqrt(val);\\n         while(st.count(val))\\n         {\\n             \\n             cur++;\\n             val=sqrt(val);\\n             cout<<val<<\" \";\\n         }\\n         ans=max(ans,cur);\\n     }\\n     if (ans==1) return -1;\\n     return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums)\\n    {\\n     unordered_set<double>st;\\n     for (int i=0;i<nums.size();i++)\\n     {\\n         st.insert(nums[i]);\\n     }\\n     int ans=1;\\n     int cur=1;\\n     for (int i=0;i<nums.size();i++)\\n     { \\n         cur=1;\\n         double val=(double)nums[i];\\n         val=sqrt(val);\\n         while(st.count(val))\\n         {\\n             \\n             cur++;\\n             val=sqrt(val);\\n             cout<<val<<\" \";\\n         }\\n         ans=max(ans,cur);\\n     }\\n     if (ans==1) return -1;\\n     return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3107994,
                "title": "using-the-union-find-method-very-unique-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n   \\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        map<int,int>m;\\n       int a= *max_element(nums.begin(), nums.end());\\n       DisjointSet ds(a);\\n          set<long long int>s;\\n        for(int i=0;i<nums.size();i++){\\n               s.insert(nums[i]);\\n        }\\n         for(auto it:s){\\n             long long int p=pow(it,2);\\n             if(s.find(p)!=s.end()){\\n                 ds.unionBySize(it,p);\\n             }\\n         }\\n        map<int,int>ans;\\n        int cnt=INT_MIN;\\n        for(auto it:s){\\n           ans[ds.findUPar(it)]++;\\n            if(cnt<ans[ds.findUPar(it)]){\\n                cnt=ans[ds.findUPar(it)];\\n            }\\n        }\\n        if(cnt<=1){\\n            cnt=-1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n## Upvote it if you like it",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n   \\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        map<int,int>m;\\n       int a= *max_element(nums.begin(), nums.end());\\n       DisjointSet ds(a);\\n          set<long long int>s;\\n        for(int i=0;i<nums.size();i++){\\n               s.insert(nums[i]);\\n        }\\n         for(auto it:s){\\n             long long int p=pow(it,2);\\n             if(s.find(p)!=s.end()){\\n                 ds.unionBySize(it,p);\\n             }\\n         }\\n        map<int,int>ans;\\n        int cnt=INT_MIN;\\n        for(auto it:s){\\n           ans[ds.findUPar(it)]++;\\n            if(cnt<ans[ds.findUPar(it)]){\\n                cnt=ans[ds.findUPar(it)];\\n            }\\n        }\\n        if(cnt<=1){\\n            cnt=-1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106903,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        Arrays.sort(nums);\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            int val = nums[i];\\n            map.put(val, map.getOrDefault(val * val, 0) + 1);\\n        }\\n        int len = -1;\\n        for(int val : map.values()){\\n            if(val > 1)\\n            len = Math.max(len, val);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        Arrays.sort(nums);\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            int val = nums[i];\\n            map.put(val, map.getOrDefault(val * val, 0) + 1);\\n        }\\n        int len = -1;\\n        for(int val : map.values()){\\n            if(val > 1)\\n            len = Math.max(len, val);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982261,
                "title": "sort",
                "content": "```\\nint longestSquareStreak(vector<int>& nn) \\n{\\n\\tsort(begin(nn), end(nn));\\n\\tunordered_map<int, int> m;\\n\\tint out{};\\n\\tfor(const auto & n : nn)\\n\\t\\tif(int t = sqrt(n); t*t==n)\\n\\t\\t\\tout = max(out, m[n]=m[t]+1);\\n\\t\\telse\\n\\t\\t\\tm[n] = 1;\\n\\treturn out>1 ? out : -1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint longestSquareStreak(vector<int>& nn) \\n{\\n\\tsort(begin(nn), end(nn));\\n\\tunordered_map<int, int> m;\\n\\tint out{};\\n\\tfor(const auto & n : nn)\\n\\t\\tif(int t = sqrt(n); t*t==n)\\n\\t\\t\\tout = max(out, m[n]=m[t]+1);\\n\\t\\telse\\n\\t\\t\\tm[n] = 1;\\n\\treturn out>1 ? out : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2967072,
                "title": "easy-approach-using-hashset-and-sorting",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPut all the elements into a hashset, so that we can easily find out whether it\\'s square is there or not in O(1) time complexity.\\nNow sort the array, and traverse over it and check whether it\\'s square is present in the set or not, if present then keep on checking how much square streak is present and update the value in maxi variable and eventually return it.\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// #define ll long long\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<long long> sett;\\n        for(auto it : nums){\\n            sett.insert(it);\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        int maxi = 0, cnt = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(sett.find((long long)nums[i] * nums[i]) == sett.end()) continue;\\n\\n            int cnt = 1;\\n            int val = nums[i];\\n            while(1){\\n                long long sq = (long long)val * val;\\n                if(sett.find(sq) != sett.end()){\\n                    cnt++;\\n                    val = sq;\\n                }\\n                else{\\n                    maxi = max(maxi, cnt);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(maxi <= 1) return -1;\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// #define ll long long\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<long long> sett;\\n        for(auto it : nums){\\n            sett.insert(it);\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        int maxi = 0, cnt = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(sett.find((long long)nums[i] * nums[i]) == sett.end()) continue;\\n\\n            int cnt = 1;\\n            int val = nums[i];\\n            while(1){\\n                long long sq = (long long)val * val;\\n                if(sett.find(sq) != sett.end()){\\n                    cnt++;\\n                    val = sq;\\n                }\\n                else{\\n                    maxi = max(maxi, cnt);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if(maxi <= 1) return -1;\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936196,
                "title": "python3-solution-dp-clean-concise",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, A):\\n        A.sort()\\n        n = len(A)\\n        dp = [1] * n\\n        r = n - 1\\n        for i in range(n - 1, -1, -1):\\n            while A[i] * A[i] < A[r]: r -= 1\\n            if A[i] * A[i] == A[r]: dp[i] = dp[r] + 1\\n        ans = max(dp)\\n        return ans if ans > 1 else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, A):\\n        A.sort()\\n        n = len(A)\\n        dp = [1] * n\\n        r = n - 1\\n        for i in range(n - 1, -1, -1):\\n            while A[i] * A[i] < A[r]: r -= 1\\n            if A[i] * A[i] == A[r]: dp[i] = dp[r] + 1\\n        ans = max(dp)\\n        return ans if ans > 1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928309,
                "title": "c-easy-hashmap-and-iterative-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int ans=0;\\n        map<long long int,long long int> mp;int count=0;map<long long int,long long int>::iterator it;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(it=mp.begin();it!=mp.end();it++){\\n            int count=0;\\n            long long int x=it->first;\\n            if(x<=1e+5){\\n            if(mp.find(x*x)!=mp.end()){\\n                count++;\\n                long long int temp=x*x;\\n                while(mp.find(temp)!=mp.end()){\\n                    count++;\\n                    temp*=temp;\\n                }\\n            }}\\n                ans=max(count,ans);\\n        }\\n        if(ans==0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int ans=0;\\n        map<long long int,long long int> mp;int count=0;map<long long int,long long int>::iterator it;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(it=mp.begin();it!=mp.end();it++){\\n            int count=0;\\n            long long int x=it->first;\\n            if(x<=1e+5){\\n            if(mp.find(x*x)!=mp.end()){\\n                count++;\\n                long long int temp=x*x;\\n                while(mp.find(temp)!=mp.end()){\\n                    count++;\\n                    temp*=temp;\\n                }\\n            }}\\n                ans=max(count,ans);\\n        }\\n        if(ans==0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916014,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Use a map `m` to store the \"best ending here\" (similar to Kadane\\'s algorithm) by performing a linear scan of each value `x` of the sorted input array `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun longestSquareStreak(A: IntArray): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        for (x in A)\\n            m[x] = 1\\n        for (x in A.sorted()) {\\n            var y = Math.sqrt(x.toDouble()).toInt()\\n            if (y * y == x)\\n                m[x] = 1 + (m[y] ?: 0)\\n        }\\n        return if (1 < m.values.max()!!) m.values.max()!! else -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet longestSquareStreak = (A, m = new Map()) => {\\n    for (let x of A)\\n        m.set(x, 1);\\n    for (let x of A.sort((a, b) => a - b)) {\\n        let y = Number(Math.sqrt(x));\\n        if (y * y == x)\\n            m.set(x, 1 + (m.get(y) || 0));\\n    }\\n    return 1 < Math.max(...m.values()) ? Math.max(...m.values()) : -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def longestSquareStreak(self, A: List[int]) -> int:\\n        m = {x: 1 for x in A}\\n        for x in sorted(A):\\n            m[x] = 1 + (m[sqrt(x)] if sqrt(x) in m else 0)\\n        return max(m.values()) if 1 < max(m.values()) else -1\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn longest_square_streak(mut A: Vec<i32>) -> i32 {\\n        A.sort();\\n        let mut m = HashMap::new();\\n        for x in &mut A {\\n            *m.entry(x.clone()).or_insert(0) = 1;\\n            let y = (x.clone() as f32).sqrt() as i32;\\n            if &y * &y == *x {\\n                *m.entry(*x).or_insert(0) += *m.entry(y).or_insert(0);\\n            }\\n        }\\n        let best = m.values().max().unwrap();\\n        if &1 < best { *best } else { -1 }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int longestSquareStreak(VI& A, Map m = {}) {\\n        sort(A.begin(), A.end());\\n        for (auto x: A) {\\n            m[x] = 1;\\n            int y = sqrt(x);\\n            if (y * y == x)\\n                m[x] += (m.find(y) != m.end() ? m[y] : 0);\\n        }\\n        auto best = max_element(m.begin(), m.end(), [](auto& a, auto& b) { return a.second < b.second; })->second;\\n        return 1 < best ? best : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun longestSquareStreak(A: IntArray): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        for (x in A)\\n            m[x] = 1\\n        for (x in A.sorted()) {\\n            var y = Math.sqrt(x.toDouble()).toInt()\\n            if (y * y == x)\\n                m[x] = 1 + (m[y] ?: 0)\\n        }\\n        return if (1 < m.values.max()!!) m.values.max()!! else -1\\n    }\\n}\\n```\n```\\nlet longestSquareStreak = (A, m = new Map()) => {\\n    for (let x of A)\\n        m.set(x, 1);\\n    for (let x of A.sort((a, b) => a - b)) {\\n        let y = Number(Math.sqrt(x));\\n        if (y * y == x)\\n            m.set(x, 1 + (m.get(y) || 0));\\n    }\\n    return 1 < Math.max(...m.values()) ? Math.max(...m.values()) : -1;\\n};\\n```\n```\\nclass Solution:\\n    def longestSquareStreak(self, A: List[int]) -> int:\\n        m = {x: 1 for x in A}\\n        for x in sorted(A):\\n            m[x] = 1 + (m[sqrt(x)] if sqrt(x) in m else 0)\\n        return max(m.values()) if 1 < max(m.values()) else -1\\n```\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn longest_square_streak(mut A: Vec<i32>) -> i32 {\\n        A.sort();\\n        let mut m = HashMap::new();\\n        for x in &mut A {\\n            *m.entry(x.clone()).or_insert(0) = 1;\\n            let y = (x.clone() as f32).sqrt() as i32;\\n            if &y * &y == *x {\\n                *m.entry(*x).or_insert(0) += *m.entry(y).or_insert(0);\\n            }\\n        }\\n        let best = m.values().max().unwrap();\\n        if &1 < best { *best } else { -1 }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    int longestSquareStreak(VI& A, Map m = {}) {\\n        sort(A.begin(), A.end());\\n        for (auto x: A) {\\n            m[x] = 1;\\n            int y = sqrt(x);\\n            if (y * y == x)\\n                m[x] += (m.find(y) != m.end() ? m[y] : 0);\\n        }\\n        auto best = max_element(m.begin(), m.end(), [](auto& a, auto& b) { return a.second < b.second; })->second;\\n        return 1 < best ? best : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908545,
                "title": "my-hashset-approach",
                "content": "\\n# Approach\\nKeep increasing the streak till there exists the square of current number.\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int ovrlMax = -1;\\n\\n        Set<Long> set = new HashSet();\\n        for(int num : nums){\\n            set.add((long)num);\\n        }\\n\\n        for(int i=0; i<nums.length; i++){\\n            int streak = 1;\\n            long num = nums[i];\\n            while(set.contains(num*num)){\\n                streak++;\\n                num = num*num;\\n                ovrlMax = Math.max(ovrlMax, streak);\\n            }\\n        }\\n        return ovrlMax;\\n    }\\n}\\n```\\n\\nX==X==X==X==X==X==X==X==X==X==X==X==X==X==X==X==X==X==X==X==X\\n\\n**Update:** Thanks to @[doggo28](https://leetcode.com/doggo28/) and @[sgallivan](https://leetcode.com/sgallivan/) for the correction. The code is not O(n). By the way, I have put an if condition which reduced the Runtime from 70ms to 50ms and made the code almost 91% faster in both space and runtime.\\nAlthough I\\'m sure this also not making best-runtime to O(n) because elements can be unsorted, somewhat as [256, 16, 4, 8, 9, 2]\\n\\nThe change in code is in the for-loop only:\\n```\\n        for(int i=0; i<nums.length; i++){\\n            int streak = 1;\\n            long num =  nums[i];\\n            while(set.contains(num*num)){\\n                streak++;\\n                num = num*num;\\n                ovrlMax = Math.max(ovrlMax, streak);\\n            }\\n\\n//no need to check if you\\'ve already achieved the maximum streak as nums.length\\n// for cases like [2,4,16,256,...]\\n\\n            if(ovrlMax == nums.length){\\n                return ovrlMax;\\n            }\\n        }\\n```\\n![image.png](https://assets.leetcode.com/users/images/0e024691-20fd-480c-bffb-b7e82b0c9cf5_1671017012.1464403.png)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int ovrlMax = -1;\\n\\n        Set<Long> set = new HashSet();\\n        for(int num : nums){\\n            set.add((long)num);\\n        }\\n\\n        for(int i=0; i<nums.length; i++){\\n            int streak = 1;\\n            long num = nums[i];\\n            while(set.contains(num*num)){\\n                streak++;\\n                num = num*num;\\n                ovrlMax = Math.max(ovrlMax, streak);\\n            }\\n        }\\n        return ovrlMax;\\n    }\\n}\\n```\n```\\n        for(int i=0; i<nums.length; i++){\\n            int streak = 1;\\n            long num =  nums[i];\\n            while(set.contains(num*num)){\\n                streak++;\\n                num = num*num;\\n                ovrlMax = Math.max(ovrlMax, streak);\\n            }\\n\\n//no need to check if you\\'ve already achieved the maximum streak as nums.length\\n// for cases like [2,4,16,256,...]\\n\\n            if(ovrlMax == nums.length){\\n                return ovrlMax;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903476,
                "title": "using-dp-and-binary-search-nlogn",
                "content": "# Intuition\\nOn seeing the question first , we will see the subsequence does not matters much because we have to sort it and tell the result. We only need to find the longest square stream in the array.\\n\\n# Approach\\nIf the number is a Perfect Square, we pair up with its Square Root.\\nElse, we will move to the next element.\\nInitially I have intilialised the dp array with 1.\\nI have used extra space , and counted the squares present from the ith index . Suppose I am at ith index then i will search for the value i.e.nums[i], from index i-1 upto 0, using binary search .  If I found any index between i-1 to 0 , lets call the index as j, such that nums[j]*nums[j]==nums[i], then I will return that index j.I have sorted the array beforehand so I can use Binary search here.I will return the index j and store dp[i]=max(dp[i],1+dp[j]). The maximum value present at any index will be the answer. If we counter only 1\\'s then there is no stream of size 2 present , so we will return -1.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int helper(int h,int l,int target,vector<int>&nums)\\n {\\n     while(l<=h)\\n     {\\n         int mid=l+(h-l)/2;\\n         \\n         if((long)nums[mid]*nums[mid]==target)\\n         return mid;\\n         else if((long)nums[mid]*nums[mid]<target)\\n         l=mid+1;\\n         else\\n         h=mid-1;\\n     }\\n     return -1;\\n }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        int ans=-1;\\n        for(int i=1;i<n;i++)\\n        {\\n            int a=nums[i];\\n           int temp= helper(i-1,0,a,nums);\\n            if(temp!=-1)\\n            dp[i]=1+dp[temp];\\n             ans=max(ans,dp[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<dp[i]<<\" \";\\n        }\\n       if(ans==1)\\n           return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int helper(int h,int l,int target,vector<int>&nums)\\n {\\n     while(l<=h)\\n     {\\n         int mid=l+(h-l)/2;\\n         \\n         if((long)nums[mid]*nums[mid]==target)\\n         return mid;\\n         else if((long)nums[mid]*nums[mid]<target)\\n         l=mid+1;\\n         else\\n         h=mid-1;\\n     }\\n     return -1;\\n }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        int ans=-1;\\n        for(int i=1;i<n;i++)\\n        {\\n            int a=nums[i];\\n           int temp= helper(i-1,0,a,nums);\\n            if(temp!=-1)\\n            dp[i]=1+dp[temp];\\n             ans=max(ans,dp[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<dp[i]<<\" \";\\n        }\\n       if(ans==1)\\n           return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2903113,
                "title": "java-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        int val=nums[nums.length-1];\\n        Set<Integer> s=new HashSet<>();\\n        for(int i:nums)s.add(i);\\n        int max=0;\\n        boolean b=false;\\n        for(int i:s)\\n        {\\n            int v=i*i;\\n            int c=0;\\n            while(true)\\n            {\\n                if(v<=val&&s.contains(v)){\\n                    b=true;\\n                    c++;\\n                    v=v*v;\\n                }else{\\n                    break;\\n                }\\n            }\\n            max=Math.max(max,c);\\n            \\n        }\\n        return b==true?max+1:-1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        int val=nums[nums.length-1];\\n        Set<Integer> s=new HashSet<>();\\n        for(int i:nums)s.add(i);\\n        int max=0;\\n        boolean b=false;\\n        for(int i:s)\\n        {\\n            int v=i*i;\\n            int c=0;\\n            while(true)\\n            {\\n                if(v<=val&&s.contains(v)){\\n                    b=true;\\n                    c++;\\n                    v=v*v;\\n                }else{\\n                    break;\\n                }\\n            }\\n            max=Math.max(max,c);\\n            \\n        }\\n        return b==true?max+1:-1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901659,
                "title": "python-js-dont-use-expensive-sqrt-function",
                "content": "# Python\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        seen = {}\\n        ans = -1\\n\\n        for n in nums:\\n            if n*n in seen:\\n                seen[n] = seen[n*n]+1\\n                ans = max(ans, seen[n])\\n            else:\\n                seen[n] = 1\\n\\n        return ans\\n```\\n# JavaScript\\n```\\nconst longestSquareStreak = nums => {\\n    nums.sort((a,b) => b-a)\\n    const seen = new Map()\\n    let ans = -1\\n\\n    for (let n of nums) {\\n        if (seen.has(n*n)) {\\n            seen.set(n, seen.get(n*n) + 1)\\n            ans = Math.max(ans, seen.get(n))\\n        } else {\\n            seen.set(n, 1)\\n        }\\n    }\\n\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        seen = {}\\n        ans = -1\\n\\n        for n in nums:\\n            if n*n in seen:\\n                seen[n] = seen[n*n]+1\\n                ans = max(ans, seen[n])\\n            else:\\n                seen[n] = 1\\n\\n        return ans\\n```\n```\\nconst longestSquareStreak = nums => {\\n    nums.sort((a,b) => b-a)\\n    const seen = new Map()\\n    let ans = -1\\n\\n    for (let n of nums) {\\n        if (seen.has(n*n)) {\\n            seen.set(n, seen.get(n*n) + 1)\\n            ans = Math.max(ans, seen.get(n))\\n        } else {\\n            seen.set(n, 1)\\n        }\\n    }\\n\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901567,
                "title": "c-simple-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        \\n        unordered_set<int>st(nums.begin(),nums.end());\\n        int mx=-1;\\n        int ans=-1;\\n        for(auto &it:nums)mx = max(mx,it);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int ct=0;\\n            int x = nums[i];\\n            for(long long j=x;j<=mx;j=j*j)\\n            {\\n                if(st.find(j)!=st.end())\\n                {\\n                    ct++;\\n                }\\n                else\\n                break;\\n            }\\n            if(ct>1)\\n            ans = max(ans,ct);\\n        }\\n        if(ans==-1)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        \\n        unordered_set<int>st(nums.begin(),nums.end());\\n        int mx=-1;\\n        int ans=-1;\\n        for(auto &it:nums)mx = max(mx,it);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int ct=0;\\n            int x = nums[i];\\n            for(long long j=x;j<=mx;j=j*j)\\n            {\\n                if(st.find(j)!=st.end())\\n                {\\n                    ct++;\\n                }\\n                else\\n                break;\\n            }\\n            if(ct>1)\\n            ans = max(ans,ct);\\n        }\\n        if(ans==-1)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900952,
                "title": "simple-hashmap-use-with-detailed-explanation",
                "content": "# Intuition\\n\\nsince we want to keep track of many problems at a single moment, hashmap is usually my approach.\\n\\n# Approach\\nHope this helps\\nWe will start storing every perfect square no. along with the counter of how many previous no. in the sequence were used to get to this square no.\\n\\nlets suppose the list is [4,3,6,16,8,2]\\nAfter sorting it will be [2,3,4,6,8,16]\\n\\nthe iterations for the i loop will be as following\\n\\nHashmap will look like\\n2--> 1\\n3-->1\\nnow for i=4 we can see that val = 2,(val = sqrt(i)) since val(2) is a key of hashmap we will use the counter of val to store in 4 like-\\n2--> 1\\n3-->1\\n4-->2\\n6-->1\\n8-->1\\n16-->3\\n\\nsince max counter for any value is (3) our answer is 3.\\n\\n# Complexity\\n- Time complexity:\\nthe time Complexity is O(nLogn) due to Sorting and O(n) for the looping\\n\\n- Space complexity:\\nO(n) using HashMap\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer> mp = new HashMap<>();\\n        int ans = 0;\\n        for(int i:nums){\\n            int val = (int)Math.sqrt(i);\\n\\n            if(val*val == i && mp.containsKey(val)){\\n                mp.put(i,mp.get(val)+1);\\n                ans = Math.max(ans,mp.get(i));\\n            }\\n            else mp.put(i,1);\\n        }\\n        return ans<2?-1:ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer> mp = new HashMap<>();\\n        int ans = 0;\\n        for(int i:nums){\\n            int val = (int)Math.sqrt(i);\\n\\n            if(val*val == i && mp.containsKey(val)){\\n                mp.put(i,mp.get(val)+1);\\n                ans = Math.max(ans,mp.get(i));\\n            }\\n            else mp.put(i,1);\\n        }\\n        return ans<2?-1:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900801,
                "title": "python-o-n-solution-without-sort",
                "content": "# Intuition\\nSince each subsequence has a smallest number, just count from the smallest to the biggest.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        s = set(nums)\\n        res = -1\\n        for item in s:\\n            if sqrt(item) in s: continue\\n            else: \\n                curr = 1\\n                while item*item in s:\\n                    item*=item\\n                    curr+=1\\n                res = max(curr, res)\\n        return -1 if res <= 1 else res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        s = set(nums)\\n        res = -1\\n        for item in s:\\n            if sqrt(item) in s: continue\\n            else: \\n                curr = 1\\n                while item*item in s:\\n                    item*=item\\n                    curr+=1\\n                res = max(curr, res)\\n        return -1 if res <= 1 else res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900784,
                "title": "js-sort-and-set",
                "content": "# Code\\n### #1\\n```\\nconst longestSquareStreak = function(nums) {\\n    nums.sort((a, b) => a-b)\\n    const set = new Set(nums)\\n    let max = -1\\n    let visited = new Set()\\n    for (let i = 0; i < nums.length; i++) {\\n        let num = nums[i]\\n        if (visited.has(num)) continue;\\n        let count = 0\\n        visited.add(num)\\n        while (set.has(num*num)) {\\n            visited.add(num*num)\\n            num = num*num\\n            count++\\n        }\\n        if (count > 0) {\\n            max = Math.max(max, count+1)\\n        }\\n    }\\n    return max\\n};\\n```\\n### #2\\n```\\nconst longestSquareStreak = function(nums) {\\n    const set = new Set(nums)\\n    let max = -1\\n    for (let num of nums) {\\n        let count = 0\\n        while (set.has(num)) {\\n            num = num*num\\n            count++\\n        }\\n        if (count > 1) {\\n            max = Math.max(max, count)\\n        }\\n    }\\n    \\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst longestSquareStreak = function(nums) {\\n    nums.sort((a, b) => a-b)\\n    const set = new Set(nums)\\n    let max = -1\\n    let visited = new Set()\\n    for (let i = 0; i < nums.length; i++) {\\n        let num = nums[i]\\n        if (visited.has(num)) continue;\\n        let count = 0\\n        visited.add(num)\\n        while (set.has(num*num)) {\\n            visited.add(num*num)\\n            num = num*num\\n            count++\\n        }\\n        if (count > 0) {\\n            max = Math.max(max, count+1)\\n        }\\n    }\\n    return max\\n};\\n```\n```\\nconst longestSquareStreak = function(nums) {\\n    const set = new Set(nums)\\n    let max = -1\\n    for (let num of nums) {\\n        let count = 0\\n        while (set.has(num)) {\\n            num = num*num\\n            count++\\n        }\\n        if (count > 1) {\\n            max = Math.max(max, count)\\n        }\\n    }\\n    \\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900749,
                "title": "java-using-binary-search",
                "content": "# Approach\\nSort the array and use binary search to find the square streak. Maintain a count of how long each streak is and return the max count. \\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        int maxCount = 0;\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            int x = nums[i], count = 1;\\n            while (true) {\\n                if (Arrays.binarySearch(nums, x*x) >= 0) {\\n                    x *= x;\\n                    count += 1;\\n                } else break;\\n            }\\n            if (count > maxCount) \\n                maxCount = count;\\n        }\\n        \\n        return maxCount > 1 ? maxCount : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        int maxCount = 0;\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            int x = nums[i], count = 1;\\n            while (true) {\\n                if (Arrays.binarySearch(nums, x*x) >= 0) {\\n                    x *= x;\\n                    count += 1;\\n                } else break;\\n            }\\n            if (count > maxCount) \\n                maxCount = count;\\n        }\\n        \\n        return maxCount > 1 ? maxCount : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900748,
                "title": "javascript-solution-using-two-sets-150-ms",
                "content": "316 - is maximum possible square per description\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSquareStreak = function(nums) {\\n    const squares = new Set();\\n    for (let i = 2; i < 317; ++i) {\\n        squares.add(i * i);\\n    } \\n\\n    nums = nums.filter(o => o < 317 || squares.has(o));\\n    nums.sort((a, b) => a - b);\\n    const set = new Set(nums);\\n    let result = -1;\\n    let count = 0, current;\\n\\n    for (const num of nums) {\\n        current = num;\\n        count = 1;\\n\\n        while (set.has(current * current)) {\\n            current *= current;\\n            ++count;\\n        }\\n\\n        if (count > result) result = count;\\n    }\\n\\n    return result === 1 ? -1 : result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSquareStreak = function(nums) {\\n    const squares = new Set();\\n    for (let i = 2; i < 317; ++i) {\\n        squares.add(i * i);\\n    } \\n\\n    nums = nums.filter(o => o < 317 || squares.has(o));\\n    nums.sort((a, b) => a - b);\\n    const set = new Set(nums);\\n    let result = -1;\\n    let count = 0, current;\\n\\n    for (const num of nums) {\\n        current = num;\\n        count = 1;\\n\\n        while (set.has(current * current)) {\\n            current *= current;\\n            ++count;\\n        }\\n\\n        if (count > result) result = count;\\n    }\\n\\n    return result === 1 ? -1 : result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900558,
                "title": "easy-and-short-using-hashing",
                "content": "# Approach\\nHash Table base approach. Store the previous value of square in hash table and move further. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n=10e5+4;\\n        vector<int> hash(n,0);\\n        for(int i=0;i<nums.size();i++)\\n            hash[nums[i]]=1;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=sqrt(i);\\n            if(hash[i]>0 && hash[temp]!=0 && temp*temp == i)\\n            {\\n                hash[i]+=hash[temp];\\n                count=max(count,hash[i]);\\n            }\\n        }\\n        if(count <= 1)\\n            return -1;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n=10e5+4;\\n        vector<int> hash(n,0);\\n        for(int i=0;i<nums.size();i++)\\n            hash[nums[i]]=1;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=sqrt(i);\\n            if(hash[i]>0 && hash[temp]!=0 && temp*temp == i)\\n            {\\n                hash[i]+=hash[temp];\\n                count=max(count,hash[i]);\\n            }\\n        }\\n        if(count <= 1)\\n            return -1;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900075,
                "title": "sort-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<long long> s(nums.begin(), nums.end());\\n        sort(nums.begin(), nums.end());\\n        \\n        long long ans = 0;\\n        for(int i : nums) {\\n            long long n = i, cnt = 1;\\n            while(s.find(n * n) != s.end()) {\\n                cnt++;\\n                n *= n;\\n                s.erase(n);\\n            }\\n            ans = max(ans, cnt);\\n        }\\n        return ans == 1 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<long long> s(nums.begin(), nums.end());\\n        sort(nums.begin(), nums.end());\\n        \\n        long long ans = 0;\\n        for(int i : nums) {\\n            long long n = i, cnt = 1;\\n            while(s.find(n * n) != s.end()) {\\n                cnt++;\\n                n *= n;\\n                s.erase(n);\\n            }\\n            ans = max(ans, cnt);\\n        }\\n        return ans == 1 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900024,
                "title": "c-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        set<long long> mySet;\\n        for(auto num : nums) {\\n            mySet.insert(num);\\n        }\\n        int maxCount=0;\\n        for(auto i=mySet.begin();i!=mySet.end();i=mySet.begin()){\\n            int count=1;\\n            long long ft=*i;\\n            if(ft>320) break;\\n            while(mySet.count(ft*ft)==1){\\n                count++;\\n                mySet.erase(ft);\\n                ft=ft*ft;\\n            }\\n            mySet.erase(ft);\\n            maxCount=max(count,maxCount);\\n        }\\n        if(maxCount==1 || maxCount==0) return -1;\\n        return maxCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        set<long long> mySet;\\n        for(auto num : nums) {\\n            mySet.insert(num);\\n        }\\n        int maxCount=0;\\n        for(auto i=mySet.begin();i!=mySet.end();i=mySet.begin()){\\n            int count=1;\\n            long long ft=*i;\\n            if(ft>320) break;\\n            while(mySet.count(ft*ft)==1){\\n                count++;\\n                mySet.erase(ft);\\n                ft=ft*ft;\\n            }\\n            mySet.erase(ft);\\n            maxCount=max(count,maxCount);\\n        }\\n        if(maxCount==1 || maxCount==0) return -1;\\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899995,
                "title": "using-set-simple-solution-c",
                "content": "```\\n int n=nums.size();\\n        set<long long>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        \\n        long long maxi=-1;\\n  \\n        for(auto it:nums){\\n        long long res=0;\\n            long long val=(long long)it* (long long)it;\\n          \\n            \\n                long long val1=val;\\n                while(st.find(val1)!=st.end()){\\n                    res++;\\n                  \\n                    val1=val1*val1;\\n                    \\n                }\\n            \\n            maxi=max(maxi,res);\\n        }\\n        if(maxi==0){\\n            return -1;\\n        }\\n        return maxi+1;",
                "solutionTags": [],
                "code": "```\\n int n=nums.size();\\n        set<long long>st;\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        \\n        long long maxi=-1;\\n  \\n        for(auto it:nums){\\n        long long res=0;\\n            long long val=(long long)it* (long long)it;\\n          \\n            \\n                long long val1=val;\\n                while(st.find(val1)!=st.end()){\\n                    res++;\\n                  \\n                    val1=val1*val1;\\n                    \\n                }\\n            \\n            maxi=max(maxi,res);\\n        }\\n        if(maxi==0){\\n            return -1;\\n        }\\n        return maxi+1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2899988,
                "title": "c-accepted-simple-bruteforce-approach",
                "content": "# Intuition\\nGo with the simplest solution\\n\\n# Approach\\nBrute Force | Mathematical approach\\n\\n# Complexity\\n- Time complexity:\\nnlog(n)\\n\\n- Space complexity:\\nconstand\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    // find if next square is present in the vector or not\\n    bool isPresent(vector<int>&arr, int key){\\n        int s = 0;\\n        int e = arr.size()-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            if(arr[mid]==key) {\\n                // set found value to 0 to avoid repetitions\\n                arr[mid] = 0;\\n                return true;\\n            }\\n            else if(key<arr[mid]) e = mid-1;\\n            else s = mid + 1;\\n        }\\n        return false;\\n    }\\n    \\n    // find max subsequence length from a given element\\n    int maxx(vector<int>&arr, int i){\\n        long long int prev = arr[i];\\n        if(arr[i]==0) return 0;\\n        int ans = 1;\\n        long long int next = prev*prev;\\n        while(isPresent(arr, next) && next<100000){\\n            ans++;\\n            prev = next;\\n            next = prev*prev;\\n        }\\n        return ans;\\n    }\\n    \\n    int longestSquareStreak(vector<int> &nums)\\n    {\\n        // sort to limit time complexity while finding the square in the vector\\n        sort(nums.begin(), nums.end());\\n        int ans = -1;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int a = maxx(nums, i);\\n            if (a > ans)\\n                ans = a;\\n        }\\n        if (ans < 2)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // find if next square is present in the vector or not\\n    bool isPresent(vector<int>&arr, int key){\\n        int s = 0;\\n        int e = arr.size()-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            if(arr[mid]==key) {\\n                // set found value to 0 to avoid repetitions\\n                arr[mid] = 0;\\n                return true;\\n            }\\n            else if(key<arr[mid]) e = mid-1;\\n            else s = mid + 1;\\n        }\\n        return false;\\n    }\\n    \\n    // find max subsequence length from a given element\\n    int maxx(vector<int>&arr, int i){\\n        long long int prev = arr[i];\\n        if(arr[i]==0) return 0;\\n        int ans = 1;\\n        long long int next = prev*prev;\\n        while(isPresent(arr, next) && next<100000){\\n            ans++;\\n            prev = next;\\n            next = prev*prev;\\n        }\\n        return ans;\\n    }\\n    \\n    int longestSquareStreak(vector<int> &nums)\\n    {\\n        // sort to limit time complexity while finding the square in the vector\\n        sort(nums.begin(), nums.end());\\n        int ans = -1;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int a = maxx(nums, i);\\n            if (a > ans)\\n                ans = a;\\n        }\\n        if (ans < 2)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899829,
                "title": "easy-c-solution-using-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<long long int ,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=1;\\n        }\\n        int count =-1;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(nums[i]==nums[i+1]) continue;\\n            int  k=nums[i];\\n            long long int f=(long long )nums[i]*(long long)nums[i];\\n            //check if square exist\\n            if(mp.find(f)!= mp.end()){\\n                mp[k]+=mp[f];\\n                count=max(count,mp[k]);\\n            }\\n        }\\n        return (count==1 ? -1 : count);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<long long int ,int> mp;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=1;\\n        }\\n        int count =-1;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(nums[i]==nums[i+1]) continue;\\n            int  k=nums[i];\\n            long long int f=(long long )nums[i]*(long long)nums[i];\\n            //check if square exist\\n            if(mp.find(f)!= mp.end()){\\n                mp[k]+=mp[f];\\n                count=max(count,mp[k]);\\n            }\\n        }\\n        return (count==1 ? -1 : count);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899789,
                "title": "java-two-approaches-using-lis-using-hashset",
                "content": "**Approach 1 - Using LIS [It will give TLE at Test case 66/87]**\\n```\\nclass Solution {\\n\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        int dp[] = new int[nums.length];\\n        int maxLen = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int max = 0;\\n            for (int j = i - 1; j >= 0; j--) {\\n                if (nums[j] < nums[i] && nums[j] * nums[j] == nums[i]) {\\n                    max = Math.max(max, dp[j]);\\n                }\\n            }\\n            dp[i] = max + 1;\\n            maxLen = Math.max(maxLen, dp[i]);\\n        }\\n        return maxLen >= 2 ? maxLen : -1;\\n    }\\n}\\n\\nTime Complexity - O((N^2)Logn)\\nSpace Complexity - O(N)\\n```\\n\\n**Approach 2 - Using HashSet**\\n```\\nclass Solution {\\n\\n    public int longestSquareStreak(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int max = 0;\\n        for (int val : nums) {\\n            hs.add(val);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int val = nums[i];\\n            int len = 1;\\n            while (hs.contains(val * val)) {\\n                len++;\\n                val *= val;\\n            }\\n\\n            max = Math.max(max, len);\\n        }\\n        return max >= 2 ? max : -1;\\n    }\\n}\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(N)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        int dp[] = new int[nums.length];\\n        int maxLen = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int max = 0;\\n            for (int j = i - 1; j >= 0; j--) {\\n                if (nums[j] < nums[i] && nums[j] * nums[j] == nums[i]) {\\n                    max = Math.max(max, dp[j]);\\n                }\\n            }\\n            dp[i] = max + 1;\\n            maxLen = Math.max(maxLen, dp[i]);\\n        }\\n        return maxLen >= 2 ? maxLen : -1;\\n    }\\n}\\n\\nTime Complexity - O((N^2)Logn)\\nSpace Complexity - O(N)\\n```\n```\\nclass Solution {\\n\\n    public int longestSquareStreak(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int max = 0;\\n        for (int val : nums) {\\n            hs.add(val);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            int val = nums[i];\\n            int len = 1;\\n            while (hs.contains(val * val)) {\\n                len++;\\n                val *= val;\\n            }\\n\\n            max = Math.max(max, len);\\n        }\\n        return max >= 2 ? max : -1;\\n    }\\n}\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899752,
                "title": "simple-java-solution-beats-100-o-nlogn-time-and-o-n-space",
                "content": "# Intuition\\nIt is similar to Longest Increasing Subsequence and we store the max square subsequence ending at that element.While performing this we maintain a max variable which stores our ans\\n\\n# Approach\\nStep 1-> Sort the array. As we can sort the subsequence to check if it is square subsequence orn not.\\nStep2->We use a HashMap to Store ele vs Max square subsequence begining from this element.\\nStep3-> We are runing the loop from end of array which helps us check if square of current no exits or not\\nIf square exists we add 1 to length of subsequence begining from square and if not we store 1 against this element\\nWhile doing this we maintain a variable max to store max length of square subsequence.\\nIf max has value 1 all subsequence have only 1 value and thus no square subsequence and we return -1\\nelse we return max.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int max=-1;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            int ele=nums[i];\\n            if(hm.containsKey(ele*ele))\\n            {\\n                hm.put(ele,hm.get(ele*ele)+1);\\n            }\\n            else\\n            {\\n                hm.put(ele,1);\\n            }\\n            max=Math.max(max,hm.get(ele));\\n        }\\n        if(max==1)\\n        {\\n            return -1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int max=-1;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            int ele=nums[i];\\n            if(hm.containsKey(ele*ele))\\n            {\\n                hm.put(ele,hm.get(ele*ele)+1);\\n            }\\n            else\\n            {\\n                hm.put(ele,1);\\n            }\\n            max=Math.max(max,hm.get(ele));\\n        }\\n        if(max==1)\\n        {\\n            return -1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899662,
                "title": "c-hashmap-easy-64-time-7-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& v) {\\n      int n = v.size(), idx = 0;\\n      map<int, int> mp;\\n      for(auto &i: v) mp[i]++;\\n      vector<pair<int, int>> ans(n);\\n      double maxele = *max_element(v.begin(), v.end());\\n      maxele = sqrt(maxele);\\n      for(auto &p: mp){\\n        ans[idx].first = p.first;\\n        ans[idx].second = 1;\\n        long long t = p.first;\\n        while(t <= maxele and mp.find(t * t) != mp.end()){\\n          t = t * t;\\n          ans[idx].second++;\\n        }\\n        idx++;\\n      }\\n      int res = INT_MIN;\\n      for(auto &p: ans){\\n        res = max(res, p.second);\\n      }\\n      return res == 1 ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& v) {\\n      int n = v.size(), idx = 0;\\n      map<int, int> mp;\\n      for(auto &i: v) mp[i]++;\\n      vector<pair<int, int>> ans(n);\\n      double maxele = *max_element(v.begin(), v.end());\\n      maxele = sqrt(maxele);\\n      for(auto &p: mp){\\n        ans[idx].first = p.first;\\n        ans[idx].second = 1;\\n        long long t = p.first;\\n        while(t <= maxele and mp.find(t * t) != mp.end()){\\n          t = t * t;\\n          ans[idx].second++;\\n        }\\n        idx++;\\n      }\\n      int res = INT_MIN;\\n      for(auto &p: ans){\\n        res = max(res, p.second);\\n      }\\n      return res == 1 ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899518,
                "title": "java-solution-sorting-hashtable-clean-code",
                "content": "```java\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        \\n        int max=0;\\n        for(int x:nums)\\n        {\\n            if(x>max)\\n                max=x;\\n        }\\n        int[] a = new int[max+1];\\n        \\n        for(int x:nums)\\n        {\\n            a[x]=1;\\n        }\\n        \\n        int maxlen=-1;\\n        for(int j=0;j<a.length;j++)\\n        {\\n            int len=0;\\n            int i=j;\\n            while(i>=0 && i<a.length && a[i]==1)\\n            {\\n                a[i]=0;\\n                i=i*i;\\n                len++;\\n            }\\n            if(len>=2)\\n            maxlen= Math.max(maxlen,len);\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        \\n        int max=0;\\n        for(int x:nums)\\n        {\\n            if(x>max)\\n                max=x;\\n        }\\n        int[] a = new int[max+1];\\n        \\n        for(int x:nums)\\n        {\\n            a[x]=1;\\n        }\\n        \\n        int maxlen=-1;\\n        for(int j=0;j<a.length;j++)\\n        {\\n            int len=0;\\n            int i=j;\\n            while(i>=0 && i<a.length && a[i]==1)\\n            {\\n                a[i]=0;\\n                i=i*i;\\n                len++;\\n            }\\n            if(len>=2)\\n            maxlen= Math.max(maxlen,len);\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899516,
                "title": "using-set-accepted-c",
                "content": "# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        set<int> s;\\n        for(auto x: nums) s.insert(x);\\n        for(int i=n-1;i>0;i--) {\\n            double cur = nums[i];\\n            double sqr = sqrt(cur);\\n            int count = 1;\\n            while((int) sqr == sqr && s.count(sqr) > 0) {\\n                count++;\\n                cur = sqr;\\n                sqr = sqrt(cur);\\n            }\\n            if(count!=1) ans = max(ans, count);\\n        }\\n        if(ans == 0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        set<int> s;\\n        for(auto x: nums) s.insert(x);\\n        for(int i=n-1;i>0;i--) {\\n            double cur = nums[i];\\n            double sqr = sqrt(cur);\\n            int count = 1;\\n            while((int) sqr == sqr && s.count(sqr) > 0) {\\n                count++;\\n                cur = sqr;\\n                sqr = sqrt(cur);\\n            }\\n            if(count!=1) ans = max(ans, count);\\n        }\\n        if(ans == 0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899497,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int sq=sqrt(nums[i]);\\n            if(sq*sq!=nums[i])\\n            {\\n                mp[nums[i]]=1;\\n                continue;\\n            }\\n            if(mp.count(sq))\\n            {\\n                mp[nums[i]]=mp[sq]+1;\\n            }\\n            else mp[nums[i]]=1;\\n            \\n        }\\n        int ans=-1e9;\\n        for(auto it:mp)\\n        {\\n            ans=max(ans,it.second);\\n        }\\n        return ans==1?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int sq=sqrt(nums[i]);\\n            if(sq*sq!=nums[i])\\n            {\\n                mp[nums[i]]=1;\\n                continue;\\n            }\\n            if(mp.count(sq))\\n            {\\n                mp[nums[i]]=mp[sq]+1;\\n            }\\n            else mp[nums[i]]=1;\\n            \\n        }\\n        int ans=-1e9;\\n        for(auto it:mp)\\n        {\\n            ans=max(ans,it.second);\\n        }\\n        return ans==1?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899472,
                "title": "java-simple-hashset",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        HashSet<Long> hs = new HashSet<>();\\n        for(int n : nums) {\\n            hs.add((long)n);\\n        }\\n        \\n        int ans = 0;\\n        for(long i=2; i*i<=100000; i++) {\\n            long tmp = i;\\n            int cnt = 0;\\n            \\n            while(hs.contains(tmp) && tmp <= 100000) {\\n                cnt++;\\n                tmp = tmp*tmp;\\n            }\\n            \\n            if(cnt >= 2) {\\n                ans = Math.max(ans, cnt);\\n            }\\n        }\\n        \\n        if(ans==0) return -1;\\n        else return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        HashSet<Long> hs = new HashSet<>();\\n        for(int n : nums) {\\n            hs.add((long)n);\\n        }\\n        \\n        int ans = 0;\\n        for(long i=2; i*i<=100000; i++) {\\n            long tmp = i;\\n            int cnt = 0;\\n            \\n            while(hs.contains(tmp) && tmp <= 100000) {\\n                cnt++;\\n                tmp = tmp*tmp;\\n            }\\n            \\n            if(cnt >= 2) {\\n                ans = Math.max(ans, cnt);\\n            }\\n        }\\n        \\n        if(ans==0) return -1;\\n        else return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899457,
                "title": "python-optimal-o-n-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort()\\n        d = {}\\n        ans = 0\\n        for i, n in enumerate(nums):\\n            sqrt = n ** 0.5\\n            if sqrt in d and sqrt.is_integer():\\n                d[n] = d[sqrt] + 1\\n                ans = max(ans, d[n])\\n            else:\\n                d[n] = 1\\n        \\n        return ans if ans > 0 else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort()\\n        d = {}\\n        ans = 0\\n        for i, n in enumerate(nums):\\n            sqrt = n ** 0.5\\n            if sqrt in d and sqrt.is_integer():\\n                d[n] = d[sqrt] + 1\\n                ans = max(ans, d[n])\\n            else:\\n                d[n] = 1\\n        \\n        return ans if ans > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899408,
                "title": "simple-java-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int count = 1;\\n            int curr = nums[i];\\n            while(true){\\n                curr *= curr;\\n                if(set.contains(curr)){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans = Math.max(ans, count);\\n        }\\n        if(ans < 2)return -1;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            int count = 1;\\n            int curr = nums[i];\\n            while(true){\\n                curr *= curr;\\n                if(set.contains(curr)){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans = Math.max(ans, count);\\n        }\\n        if(ans < 2)return -1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899389,
                "title": "sort-in-descending-and-dp-on-longest-sequence",
                "content": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n        l = {}\\n        for el in nums:\\n            if el * el in l:\\n                l[el] = l[el * el] + 1\\n            else:\\n                l[el] = 1\\n        res = max(l.values())\\n        if res < 2:\\n            return -1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse = True)\\n        l = {}\\n        for el in nums:\\n            if el * el in l:\\n                l[el] = l[el * el] + 1\\n            else:\\n                l[el] = 1\\n        res = max(l.values())\\n        if res < 2:\\n            return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095870,
                "title": "2-elegant-solutions-second-one-will-blow-you",
                "content": "# 1. HashMap + DP Table\\n- Time complexity: $$O(n*log(n))$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int> vis;\\n        vector<int> dp(n,1);\\n\\n        for(int i=0; i<n; i++)\\n        {\\n          int sqRoot = sqrt(nums[i]);\\n          if(vis.count(sqRoot) && 1LL*sqRoot*sqRoot == nums[i])\\n          {  //if current number\\'s square root is present\\n              dp[i] = max(dp[i],1 + dp[vis[sqRoot]]); //the, update value in dp\\n              maxi = max(maxi,dp[i]); //take maximum\\n          }\\n        vis[nums[i]] = i;\\n        }\\n    return (maxi == 1) ? -1 : maxi;\\n    }\\n};\\n```\\n.\\n# 2. Only HashMap - Just traverse from the back\\n- Time complexity: $$O(n*log(n))$$ \\n\\n- Space complexity: $$O(n)$$ \\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<long long,int> dp; //all value are 0 by default\\n        for(int i=n-1; i>=0; i--) //traverse from the back\\n        {\\n          dp[nums[i]] = 1 + dp[1LL * nums[i] * nums[i]]; //keep on updating values from the back\\n          maxi = max(maxi,dp[nums[i]]); //and take maximum\\n        }\\n    return (maxi == 1) ? -1 : maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int> vis;\\n        vector<int> dp(n,1);\\n\\n        for(int i=0; i<n; i++)\\n        {\\n          int sqRoot = sqrt(nums[i]);\\n          if(vis.count(sqRoot) && 1LL*sqRoot*sqRoot == nums[i])\\n          {  //if current number\\'s square root is present\\n              dp[i] = max(dp[i],1 + dp[vis[sqRoot]]); //the, update value in dp\\n              maxi = max(maxi,dp[i]); //take maximum\\n          }\\n        vis[nums[i]] = i;\\n        }\\n    return (maxi == 1) ? -1 : maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n = nums.size(), maxi = 1;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<long long,int> dp; //all value are 0 by default\\n        for(int i=n-1; i>=0; i--) //traverse from the back\\n        {\\n          dp[nums[i]] = 1 + dp[1LL * nums[i] * nums[i]]; //keep on updating values from the back\\n          maxi = max(maxi,dp[nums[i]]); //and take maximum\\n        }\\n    return (maxi == 1) ? -1 : maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068746,
                "title": "optimize-solution-using-hashset-98-beats-also-beginner-friendly-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:***O(NlogN)***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Set<Long> set = new HashSet<>();\\n        for(int num : nums) set.add((long)num);\\n\\n        Arrays.sort(nums);\\n        int res = -1;\\n\\n        for(int num : nums){\\n            long temp = (long)num;\\n            int cnt=1;\\n            while(set.contains(temp*temp)){\\n                cnt++;\\n                temp = temp*temp;\\n                res = Math.max(res, cnt);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Set<Long> set = new HashSet<>();\\n        for(int num : nums) set.add((long)num);\\n\\n        Arrays.sort(nums);\\n        int res = -1;\\n\\n        for(int num : nums){\\n            long temp = (long)num;\\n            int cnt=1;\\n            while(set.contains(temp*temp)){\\n                cnt++;\\n                temp = temp*temp;\\n                res = Math.max(res, cnt);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066070,
                "title": "c-o-n-solution-using-disjoint-set-union-union-find-beats-99-73",
                "content": "# Intuition\\nEach chain of squares can be thought of as a disjoint set, where each set contains the numbers in the chain. By choosing the smallest node as the representative node, you can find the size of each set in linear time by squaring the number until it\\'s not found in the set.\\n\\n# Approach\\nFor each number, we put it in the hash map and check if the root or square is present. If so, we set the root as the parent of the number, and the number as the parent of the square. In this way, we guarantee that if a number is it\\'s own parent, it is the smallest number in the disjoint set.\\n\\nWe then do another linear operation to find every number that is a representative node (it\\'s parent is itself). That number is guaranteed to be the smallest number, so we can find the size of the set by squaring until it\\'s not found in the hashmap. Any number that has a parent other than itself is guaranteed to be part of a larger chain, so it is skipped.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - When building the disjoint sets, we iterate through each number and perform a constant number of operations (check the root and square).\\n\\n    When checking the size of each disjoint set, each number will be checked at most once for any worst case. For example, n disjoint sets of size 1 will not enter the while loop. Similarly, 1 disjoint set of size n will enter the while loop once and find all n numbers.\\n\\n- Space complexity:\\nO(n) - We use a hash map to track the parent nodes.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Largest possible root, given the constraints.\\n    const int MAXNUM = 317;\\n\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        auto uf = vector<int>(1e5+1);\\n\\n        for (const auto num : nums)\\n        {\\n            // Default representative node for each number in the set is itself.\\n            uf[num] = num;\\n\\n            // Any number > 316 is guaranteed to not have any squares.\\n            if (num >= MAXNUM)\\n                continue;\\n\\n            // Prepare root and square.\\n            auto root = sqrt(num);\\n            auto square = num * num;\\n\\n            // Map each number to it\\'s smaller root.\\n            if (root * root == num && uf[root] != 0)\\n                uf[num] = root;\\n\\n            if (uf[square] != 0)\\n                uf[square] = num;\\n        }\\n\\n        auto res = -1;\\n        for (auto i = 2; i < MAXNUM; ++i)\\n        {\\n            // For each representative node (parent is itself), we check the size of the disjoint set.\\n            if (uf[i] == i)\\n            {\\n                auto num = i;\\n                auto count = 2; \\n                auto square = num * num;\\n\\n                while (uf[square] != 0)\\n                {\\n                    res = max(res, count);\\n                    num = square;\\n                    square = num < MAXNUM ? num * num : 0;\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Largest possible root, given the constraints.\\n    const int MAXNUM = 317;\\n\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        auto uf = vector<int>(1e5+1);\\n\\n        for (const auto num : nums)\\n        {\\n            // Default representative node for each number in the set is itself.\\n            uf[num] = num;\\n\\n            // Any number > 316 is guaranteed to not have any squares.\\n            if (num >= MAXNUM)\\n                continue;\\n\\n            // Prepare root and square.\\n            auto root = sqrt(num);\\n            auto square = num * num;\\n\\n            // Map each number to it\\'s smaller root.\\n            if (root * root == num && uf[root] != 0)\\n                uf[num] = root;\\n\\n            if (uf[square] != 0)\\n                uf[square] = num;\\n        }\\n\\n        auto res = -1;\\n        for (auto i = 2; i < MAXNUM; ++i)\\n        {\\n            // For each representative node (parent is itself), we check the size of the disjoint set.\\n            if (uf[i] == i)\\n            {\\n                auto num = i;\\n                auto count = 2; \\n                auto square = num * num;\\n\\n                while (uf[square] != 0)\\n                {\\n                    res = max(res, count);\\n                    num = square;\\n                    square = num < MAXNUM ? num * num : 0;\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059308,
                "title": "swift-solution-beats-100-percent",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func longestSquareStreak(_ nums: [Int]) -> Int {\\n            var sorted = nums.sorted()\\n            var count = 0\\n            var maxSequenceCount = 0\\n            \\n\\n            while count < sorted.count {\\n                var first = sorted[count]\\n                var square = first*first\\n                var sequenceCount = 0\\n                var innerCount = 0\\n                \\n                \\n                while self.binarySearchAlgo(arr: sorted, key: square) != nil {\\n                    square = square*square\\n                    if sequenceCount == 0 {\\n                        sequenceCount = sequenceCount + 1\\n                    }\\n                    sequenceCount = sequenceCount + 1\\n                    if sequenceCount > maxSequenceCount {\\n                        maxSequenceCount = sequenceCount\\n                    }\\n                }\\n                \\n                count = count + 1\\n            }\\n        if maxSequenceCount == 0 {\\n            return -1\\n        }\\n        return maxSequenceCount\\n        }\\n        func binarySearchAlgo(arr: [Int], key: Int) -> Int? {\\n\\n       var LBound = 0\\n       var UBound = arr.count - 1\\n        \\n       while LBound <= UBound {\\n          let middle = (LBound + UBound) / 2\\n          if arr[middle] == key {\\n            \\n             // Found the key element\\n             return middle\\n          } else if arr[middle] < key {\\n            \\n             // Searching in the upper half\\n             LBound = middle + 1\\n          } else {\\n            \\n             // Searching in the lower half\\n             UBound = middle - 1\\n          }\\n       }\\n        \\n       // Key element is not found\\n       return nil\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestSquareStreak(_ nums: [Int]) -> Int {\\n            var sorted = nums.sorted()\\n            var count = 0\\n            var maxSequenceCount = 0\\n            \\n\\n            while count < sorted.count {\\n                var first = sorted[count]\\n                var square = first*first\\n                var sequenceCount = 0\\n                var innerCount = 0\\n                \\n                \\n                while self.binarySearchAlgo(arr: sorted, key: square) != nil {\\n                    square = square*square\\n                    if sequenceCount == 0 {\\n                        sequenceCount = sequenceCount + 1\\n                    }\\n                    sequenceCount = sequenceCount + 1\\n                    if sequenceCount > maxSequenceCount {\\n                        maxSequenceCount = sequenceCount\\n                    }\\n                }\\n                \\n                count = count + 1\\n            }\\n        if maxSequenceCount == 0 {\\n            return -1\\n        }\\n        return maxSequenceCount\\n        }\\n        func binarySearchAlgo(arr: [Int], key: Int) -> Int? {\\n\\n       var LBound = 0\\n       var UBound = arr.count - 1\\n        \\n       while LBound <= UBound {\\n          let middle = (LBound + UBound) / 2\\n          if arr[middle] == key {\\n            \\n             // Found the key element\\n             return middle\\n          } else if arr[middle] < key {\\n            \\n             // Searching in the upper half\\n             LBound = middle + 1\\n          } else {\\n            \\n             // Searching in the lower half\\n             UBound = middle - 1\\n          }\\n       }\\n        \\n       // Key element is not found\\n       return nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044674,
                "title": "java-3ms-100-count-and-dp",
                "content": "\\n# Approach\\n1. Map the present numbers in an int[100001]. If a number is present, set it to 1.\\n2. Loop with i from Math.sqrt(100000) to 2 and if present[i] > 0 && present[i * i] > 0(so both numbers are present), then set present[i] += present[i * i]\\n3. Each time, set a global longestSeq = Math.max(present[i], longestSeq)\\n4. Return global longestSeq.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(100001)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int[] presentNums = getPresentNums(nums);\\n        int longestSeq = 0;\\n        for (int i = (int)Math.sqrt(100000); i >= 2; i--) {\\n            if (presentNums[i] > 0 && presentNums[i*i] > 0) {\\n                presentNums[i] += presentNums[i*i];\\n                longestSeq = Math.max(longestSeq, presentNums[i]);\\n            }\\n        }\\n        return longestSeq <= 1 ? -1 : longestSeq;\\n    }\\n\\n    private int[] getPresentNums(int[] nums) {\\n        int[] presentNums = new int[100001];\\n        for (int num : nums) {\\n            presentNums[num] = 1;\\n        }\\n        return presentNums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int[] presentNums = getPresentNums(nums);\\n        int longestSeq = 0;\\n        for (int i = (int)Math.sqrt(100000); i >= 2; i--) {\\n            if (presentNums[i] > 0 && presentNums[i*i] > 0) {\\n                presentNums[i] += presentNums[i*i];\\n                longestSeq = Math.max(longestSeq, presentNums[i]);\\n            }\\n        }\\n        return longestSeq <= 1 ? -1 : longestSeq;\\n    }\\n\\n    private int[] getPresentNums(int[] nums) {\\n        int[] presentNums = new int[100001];\\n        for (int num : nums) {\\n            presentNums[num] = 1;\\n        }\\n        return presentNums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018343,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, sort the array nums then select each element and then looks its square term in the nums array. Here we use lowerbound to reduce time complexity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int mod =pow(2,15);\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n =nums.size();\\n        int maxans =0;\\n        for(int i=0;i<n;i++){\\n            int ind =i;\\n            int currcount =1;\\n            while(ind<n&&nums[ind]<=mod){\\n                int p;\\n                auto p1 = lower_bound(nums.begin(),nums.end(),nums[ind]*nums[ind]);\\n                if(p1==nums.end()) break;\\n                else p = p1-nums.begin();\\n                 if(nums[p]==nums[ind]*nums[ind]){\\n                     currcount++;\\n                     ind =p;\\n                 }\\n                 else break;\\n            }\\n            maxans=max(maxans,currcount);\\n        }\\n        if(maxans==1){\\n            return -1;\\n        }\\n        else return maxans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int mod =pow(2,15);\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n =nums.size();\\n        int maxans =0;\\n        for(int i=0;i<n;i++){\\n            int ind =i;\\n            int currcount =1;\\n            while(ind<n&&nums[ind]<=mod){\\n                int p;\\n                auto p1 = lower_bound(nums.begin(),nums.end(),nums[ind]*nums[ind]);\\n                if(p1==nums.end()) break;\\n                else p = p1-nums.begin();\\n                 if(nums[p]==nums[ind]*nums[ind]){\\n                     currcount++;\\n                     ind =p;\\n                 }\\n                 else break;\\n            }\\n            maxans=max(maxans,currcount);\\n        }\\n        if(maxans==1){\\n            return -1;\\n        }\\n        else return maxans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984155,
                "title": "longest-square-streak-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int count1 = -1;\\n        HashSet<Long> hs = new HashSet<Long>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            hs.add((long)nums[i]);\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            long count=1;\\n            long x=nums[i];\\n            while(hs.contains(x*x))\\n            {\\n                count++;\\n                x=x*x;\\n            }\\n            if(count!=1)\\n            count1=(int)Math.max(count1,count);\\n        }\\n        if(count1==-1)\\n        return -1;\\n        return count1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int count1 = -1;\\n        HashSet<Long> hs = new HashSet<Long>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            hs.add((long)nums[i]);\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            long count=1;\\n            long x=nums[i];\\n            while(hs.contains(x*x))\\n            {\\n                count++;\\n                x=x*x;\\n            }\\n            if(count!=1)\\n            count1=(int)Math.max(count1,count);\\n        }\\n        if(count1==-1)\\n        return -1;\\n        return count1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975231,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int max =0;\\n        Set<Long> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            set.add(Long.valueOf(nums[i]));\\n        }\\n        for(int i : nums){\\n            long a = i;\\n            int count =1;\\n            while(set.contains(a*a)){\\n                a = a*a;\\n                count++;\\n            }\\n            max = max > count?max:count;//Math.max(max, count);\\n        }\\n        return max==1?-1:max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int max =0;\\n        Set<Long> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            set.add(Long.valueOf(nums[i]));\\n        }\\n        for(int i : nums){\\n            long a = i;\\n            int count =1;\\n            while(set.contains(a*a)){\\n                a = a*a;\\n                count++;\\n            }\\n            max = max > count?max:count;//Math.max(max, count);\\n        }\\n        return max==1?-1:max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952153,
                "title": "sort-and-binary-search-solution-in-c",
                "content": "\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\nprivate:\\n    bool binarySearch(ll target, vector<int>& arr){\\n        int l = 0;\\n        int r = arr.size();\\n        while (l<r){\\n            int mid = l+(r-l)/2;\\n            if (arr[mid]>=target){\\n                r = mid;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        if (l<arr.size()){return arr[l]==target;}\\n        else{return false;}\\n    }\\n    int getMaxLen(ll i, vector<int>& nums){\\n        int l = 0;\\n        while (binarySearch(i, nums)){\\n            i*=i;\\n            l++;\\n        }\\n        if (l>=2){return l;}\\n        else{return -1;}\\n    }\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        std::sort(nums.begin(), nums.end());\\n        int upperLimit = (int)std::sqrt(nums.back())+1;\\n        int maxLen = -1;\\n        for (int i=2; i<upperLimit; i++){\\n            maxLen = std::max(maxLen, getMaxLen((ll)i, nums));\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\nprivate:\\n    bool binarySearch(ll target, vector<int>& arr){\\n        int l = 0;\\n        int r = arr.size();\\n        while (l<r){\\n            int mid = l+(r-l)/2;\\n            if (arr[mid]>=target){\\n                r = mid;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        if (l<arr.size()){return arr[l]==target;}\\n        else{return false;}\\n    }\\n    int getMaxLen(ll i, vector<int>& nums){\\n        int l = 0;\\n        while (binarySearch(i, nums)){\\n            i*=i;\\n            l++;\\n        }\\n        if (l>=2){return l;}\\n        else{return -1;}\\n    }\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        std::sort(nums.begin(), nums.end());\\n        int upperLimit = (int)std::sqrt(nums.back())+1;\\n        int maxLen = -1;\\n        for (int i=2; i<upperLimit; i++){\\n            maxLen = std::max(maxLen, getMaxLen((ll)i, nums));\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946752,
                "title": "simple-python-99-51-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        mx=-1\\n        arr=set(nums)\\n        for i in arr:\\n            count=0\\n            while True:\\n                if i*i in arr:\\n                    if count==0:\\n                        count+=1\\n                    count+=1\\n                    i=i*i\\n                else:\\n                    break\\n            if count>0 and  count>mx: \\n                mx=count\\n        return mx\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        mx=-1\\n        arr=set(nums)\\n        for i in arr:\\n            count=0\\n            while True:\\n                if i*i in arr:\\n                    if count==0:\\n                        count+=1\\n                    count+=1\\n                    i=i*i\\n                else:\\n                    break\\n            if count>0 and  count>mx: \\n                mx=count\\n        return mx\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928760,
                "title": "simple-solution-using-maps-only-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n=nums.size();\\n        unordered_map<int, int>dp;\\n        for(int i=0;i<n;i++){\\n            dp[nums[i]]=1;\\n        }\\n        int maxlen=-1;\\n        for(int i=0;i<n;i++){\\n            float num=sqrt(nums[i]);\\n            int num1=sqrt(nums[i]);\\n            if(num1==num) //to check for perfect square\\n            if(dp[num1]>=1){\\n                dp[nums[i]]=1+dp[num1];\\n                maxlen=max(maxlen, dp[nums[i]]);\\n            }\\n        }\\n        return maxlen;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n=nums.size();\\n        unordered_map<int, int>dp;\\n        for(int i=0;i<n;i++){\\n            dp[nums[i]]=1;\\n        }\\n        int maxlen=-1;\\n        for(int i=0;i<n;i++){\\n            float num=sqrt(nums[i]);\\n            int num1=sqrt(nums[i]);\\n            if(num1==num) //to check for perfect square\\n            if(dp[num1]>=1){\\n                dp[nums[i]]=1+dp[num1];\\n                maxlen=max(maxlen, dp[nums[i]]);\\n            }\\n        }\\n        return maxlen;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913285,
                "title": "dp-with-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSorting and then using binary search to find if the solution exists for all the indexes\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*log(N))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        # Reducing the search space by sorting\\n        nums.sort()\\n        \\n        dp = [1]*len(nums)\\n\\n        for i in range(len(nums)):\\n            lo = 0\\n            hi = i\\n            flag = False\\n            while lo < hi:\\n                mid = (lo + hi) >> 1\\n                if nums[mid]**2 == nums[i]:\\n                    flag = True\\n                if nums[mid]**2 < nums[i]:\\n                    lo = mid + 1\\n                else:\\n                    hi = mid     \\n            if flag:\\n                dp[i] += dp[lo]\\n        \\n        ans = max(dp)\\n\\n        if ans <= 1:\\n            return -1\\n        else:\\n            return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        # Reducing the search space by sorting\\n        nums.sort()\\n        \\n        dp = [1]*len(nums)\\n\\n        for i in range(len(nums)):\\n            lo = 0\\n            hi = i\\n            flag = False\\n            while lo < hi:\\n                mid = (lo + hi) >> 1\\n                if nums[mid]**2 == nums[i]:\\n                    flag = True\\n                if nums[mid]**2 < nums[i]:\\n                    lo = mid + 1\\n                else:\\n                    hi = mid     \\n            if flag:\\n                dp[i] += dp[lo]\\n        \\n        ans = max(dp)\\n\\n        if ans <= 1:\\n            return -1\\n        else:\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855121,
                "title": "binary-search-based-algorithm-python-faster-than-99",
                "content": "# Intuition\\nThe longest requested streak should be a list of sorted square numbers, plus an integer appended to the start of the streak, which is the square root of the first element of the streak. Therefore, we can first find long streaks in the set of square numbers, and then get the results.\\n\\n# Approach\\nFirst, we sort the original number list `nums`, and find the list of square numbers `sq_nums` in `nums`.\\n\\nSecond, we start with the first element of the square number list, denoted as `streak_head`, to find long streaks in the set of square numbers. For each long streak, once we find the next element of the streak, we can pop that element because it cannot belong to another long streak. We will always use Binary Search `bisect_left` since the number list is sorted at the very beginning.\\n\\nAt last, we add 1 to the length of this streak if the square root of the head of this streak belongs to `nums`, and then record the largest streak length.\\n\\n# Complexity\\n- Time complexity: $O(NlogN)$\\nList sort is $O(NlogN)$, and binary search based on a sorted list is $O(logN)$. After each binary search, we would either pop an element or stop further searching. Therefore, the total time complexity is $O(NlogN)$.\\n\\n- Space complexity: $O(N)$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        import math\\n        nums = list(set(nums))\\n        nums.sort()\\n        sq_nums = []\\n        for num in nums:\\n            if self.isSquareNumber(num):\\n                sq_nums.append(num)\\n\\n        max_streak = -1\\n        while sq_nums:\\n            streak_head = sq_nums.pop(0)\\n            prev_num = streak_head\\n            tmp_streak = 1\\n            j = self.index(sq_nums, prev_num**2)\\n            while j != -1:\\n                prev_num = sq_nums.pop(j)\\n                tmp_streak += 1\\n                j = self.index(sq_nums, prev_num**2, lo=j)\\n            if self.index(nums, int(math.sqrt(streak_head))) != -1:\\n                tmp_streak += 1\\n            if tmp_streak > max_streak:\\n                max_streak = tmp_streak\\n        \\n        if max_streak < 2:\\n            return -1\\n        else:\\n            return max_streak\\n            \\n    def isSquareNumber(self, num: int) -> bool:\\n        import math\\n        return math.sqrt(num) == int(math.sqrt(num))\\n\\n    def index(self, a, x, lo=0):\\n        from bisect import bisect_left\\n        \\'Locate the leftmost value exactly equal to x\\'\\n        i = bisect_left(a, x, lo=lo)\\n        if i != len(a) and a[i] == x:\\n            return i\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        import math\\n        nums = list(set(nums))\\n        nums.sort()\\n        sq_nums = []\\n        for num in nums:\\n            if self.isSquareNumber(num):\\n                sq_nums.append(num)\\n\\n        max_streak = -1\\n        while sq_nums:\\n            streak_head = sq_nums.pop(0)\\n            prev_num = streak_head\\n            tmp_streak = 1\\n            j = self.index(sq_nums, prev_num**2)\\n            while j != -1:\\n                prev_num = sq_nums.pop(j)\\n                tmp_streak += 1\\n                j = self.index(sq_nums, prev_num**2, lo=j)\\n            if self.index(nums, int(math.sqrt(streak_head))) != -1:\\n                tmp_streak += 1\\n            if tmp_streak > max_streak:\\n                max_streak = tmp_streak\\n        \\n        if max_streak < 2:\\n            return -1\\n        else:\\n            return max_streak\\n            \\n    def isSquareNumber(self, num: int) -> bool:\\n        import math\\n        return math.sqrt(num) == int(math.sqrt(num))\\n\\n    def index(self, a, x, lo=0):\\n        from bisect import bisect_left\\n        \\'Locate the leftmost value exactly equal to x\\'\\n        i = bisect_left(a, x, lo=lo)\\n        if i != len(a) and a[i] == x:\\n            return i\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826756,
                "title": "c-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n        unordered_set<int> us;\\n        unordered_map<int, int> um;\\n        for(int x: nums)\\n        {\\n            if(us.count(x)==0)\\n            {\\n                int y = sqrt(x);\\n                if(y*y==x)\\n                {\\n                    if(us.count(y)==1)\\n                    {\\n                        um[x]=um[y]+1;\\n                        um.erase(y);\\n                        us.insert(x);\\n                    }\\n                    else\\n                    {\\n                        us.insert(x);\\n                        um[x]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    us.insert(x);\\n                    um[x]=1;\\n                }\\n            }\\n        }\\n        int ans = 1;\\n        for(auto itr: um)\\n        {\\n            ans=max(ans, itr.second);\\n        }\\n        if(ans==1){return -1;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n        unordered_set<int> us;\\n        unordered_map<int, int> um;\\n        for(int x: nums)\\n        {\\n            if(us.count(x)==0)\\n            {\\n                int y = sqrt(x);\\n                if(y*y==x)\\n                {\\n                    if(us.count(y)==1)\\n                    {\\n                        um[x]=um[y]+1;\\n                        um.erase(y);\\n                        us.insert(x);\\n                    }\\n                    else\\n                    {\\n                        us.insert(x);\\n                        um[x]=1;\\n                    }\\n                }\\n                else\\n                {\\n                    us.insert(x);\\n                    um[x]=1;\\n                }\\n            }\\n        }\\n        int ans = 1;\\n        for(auto itr: um)\\n        {\\n            ans=max(ans, itr.second);\\n        }\\n        if(ans==1){return -1;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775278,
                "title": "easy-c-code-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <vector>\\n#include <set>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& v) {\\n        set<int> s(v.begin(), v.end());\\n        int res = 0;\\n        while (!s.empty()) {\\n            long long current = *s.begin();\\n            int streak = 0;\\n            int l=*s.rbegin();\\n            while (s.count(current) and current<=l) {\\n                streak++;\\n                s.erase(current);\\n                current = current * current;\\n            }\\n            res = max(res, streak);\\n        }\\n        if(res==1) return -1;\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <set>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& v) {\\n        set<int> s(v.begin(), v.end());\\n        int res = 0;\\n        while (!s.empty()) {\\n            long long current = *s.begin();\\n            int streak = 0;\\n            int l=*s.rbegin();\\n            while (s.count(current) and current<=l) {\\n                streak++;\\n                s.erase(current);\\n                current = current * current;\\n            }\\n            res = max(res, streak);\\n        }\\n        if(res==1) return -1;\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3775277,
                "title": "easy-c-code-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <vector>\\n#include <set>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& v) {\\n        set<int> s(v.begin(), v.end());\\n        int res = 0;\\n        while (!s.empty()) {\\n            long long current = *s.begin();\\n            int streak = 0;\\n            int l=*s.rbegin();\\n            while (s.count(current) and current<=l) {\\n                streak++;\\n                s.erase(current);\\n                current = current * current;\\n            }\\n            res = max(res, streak);\\n        }\\n        if(res==1) return -1;\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <set>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& v) {\\n        set<int> s(v.begin(), v.end());\\n        int res = 0;\\n        while (!s.empty()) {\\n            long long current = *s.begin();\\n            int streak = 0;\\n            int l=*s.rbegin();\\n            while (s.count(current) and current<=l) {\\n                streak++;\\n                s.erase(current);\\n                current = current * current;\\n            }\\n            res = max(res, streak);\\n        }\\n        if(res==1) return -1;\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3700355,
                "title": "unordered-set-approach-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<int> st;\\n        \\n        for(auto &num:nums) st.insert(num);\\n        int lss = -1;\\n        for(auto &num:nums) {\\n            if(st.find(sqrt(num)) == st.end()) {\\n                int css = 1;\\n                int a = num;\\n                st.erase(a);\\n                while(st.find((long long) a * a) != st.end()) {\\n                    css++;\\n                    st.erase(a * a);\\n                    a = a * a;\\n                }\\n                if(css >= 2) lss = max(lss, css);\\n            }\\n        }\\n        return lss;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<int> st;\\n        \\n        for(auto &num:nums) st.insert(num);\\n        int lss = -1;\\n        for(auto &num:nums) {\\n            if(st.find(sqrt(num)) == st.end()) {\\n                int css = 1;\\n                int a = num;\\n                st.erase(a);\\n                while(st.find((long long) a * a) != st.end()) {\\n                    css++;\\n                    st.erase(a * a);\\n                    a = a * a;\\n                }\\n                if(css >= 2) lss = max(lss, css);\\n            }\\n        }\\n        return lss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680099,
                "title": "c-solution",
                "content": "# Intuition\\nSince we have to sort the streak, thus we can sort the entire array. After sorting, if any element presents in the streak, then square root of that element will be present before that.\\n\\n# Approach\\nUsing an unordrered map, if a perfect square integer found then we store that in map by 1 increament to that squre root value in map. \\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ (Please correct if it is wrong)\\n\\n- Space complexity:\\n$$O(nlogn)$$ (Please correct if it is wrong)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n=nums.size(),mx=1;\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int> m;\\n        for(int i=0;i<n;i++){\\n            \\n            double sq=sqrt(nums[i]);\\n            if(floor(sq)==sq) {\\n                m[nums[i]]=1+m[sq]; \\n                mx=max(mx,m[nums[i]]); \\n            }\\n            else{\\n                m[nums[i]]=1;\\n            }\\n            \\n        }\\n            \\n        if(mx==1) return -1;\\n        return mx;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n=nums.size(),mx=1;\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int> m;\\n        for(int i=0;i<n;i++){\\n            \\n            double sq=sqrt(nums[i]);\\n            if(floor(sq)==sq) {\\n                m[nums[i]]=1+m[sq]; \\n                mx=max(mx,m[nums[i]]); \\n            }\\n            else{\\n                m[nums[i]]=1;\\n            }\\n            \\n        }\\n            \\n        if(mx==1) return -1;\\n        return mx;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653278,
                "title": "easy-to-understand-python-trick-is-to-see-if-a-number-is-processed-already",
                "content": "- Ssort the nums \\n- For each num,  see if this is already processed. If it is processed, sequence from here cannot be bigger than already present seqeuence\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        processed = set()\\n        nums.sort()\\n        numset = set(nums)\\n        ans = 0\\n        for num in nums:\\n            if num not in processed:\\n                base = num\\n                l = 0\\n                while base in numset:\\n                    l += 1\\n                    base = base*base\\n                ans = max(ans, l)\\n        if ans < 2:\\n            return -1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        processed = set()\\n        nums.sort()\\n        numset = set(nums)\\n        ans = 0\\n        for num in nums:\\n            if num not in processed:\\n                base = num\\n                l = 0\\n                while base in numset:\\n                    l += 1\\n                    base = base*base\\n                ans = max(ans, l)\\n        if ans < 2:\\n            return -1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647583,
                "title": "using-dfs-standard-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    void dfs(vector<long long> adj[] , int node , vector<bool>& visited, int &ans) {\\n\\n        if(visited[node]) return;\\n\\n        visited[node] = true;\\n\\n        for(auto it: adj[node]) {\\n            if(!visited[it]) {\\n                ans++;\\n                dfs(adj, it, visited, ans);\\n            }\\n        }\\n\\n    }\\n\\n\\n    int longestSquareStreak(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<long long>s;\\n        int maxi = 0;\\n        for(int i = 0; i < n; i++) {\\n            s.insert(nums[i]);\\n            maxi = max(maxi, nums[i]);\\n        }\\n\\n        vector<long long>adj[maxi + 1];\\n        for(long long i = 2;  i < (maxi + 1); i++) {\\n            long long val = i*i;\\n            if(s.find(val) != s.end() && s.find(i) != s.end()) {\\n                adj[i].push_back(val);\\n            }\\n        }\\n\\n\\n        int fans = 0;\\n        vector<bool>visited(maxi + 1 , false);\\n\\n        for(int i = 0; i < n; i++) {\\n            if(!visited[nums[i]]) {\\n                int ans = 0;\\n                dfs(adj, nums[i], visited , ans);\\n                fans = max(fans, ans);\\n            }\\n        }\\n\\n        if(fans == 0) return -1;\\n\\n\\n        return fans + 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    void dfs(vector<long long> adj[] , int node , vector<bool>& visited, int &ans) {\\n\\n        if(visited[node]) return;\\n\\n        visited[node] = true;\\n\\n        for(auto it: adj[node]) {\\n            if(!visited[it]) {\\n                ans++;\\n                dfs(adj, it, visited, ans);\\n            }\\n        }\\n\\n    }\\n\\n\\n    int longestSquareStreak(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<long long>s;\\n        int maxi = 0;\\n        for(int i = 0; i < n; i++) {\\n            s.insert(nums[i]);\\n            maxi = max(maxi, nums[i]);\\n        }\\n\\n        vector<long long>adj[maxi + 1];\\n        for(long long i = 2;  i < (maxi + 1); i++) {\\n            long long val = i*i;\\n            if(s.find(val) != s.end() && s.find(i) != s.end()) {\\n                adj[i].push_back(val);\\n            }\\n        }\\n\\n\\n        int fans = 0;\\n        vector<bool>visited(maxi + 1 , false);\\n\\n        for(int i = 0; i < n; i++) {\\n            if(!visited[nums[i]]) {\\n                int ans = 0;\\n                dfs(adj, nums[i], visited , ans);\\n                fans = max(fans, ans);\\n            }\\n        }\\n\\n        if(fans == 0) return -1;\\n\\n\\n        return fans + 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638030,
                "title": "easiest-approach-bruteforce-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=-1;\\n        unordered_map<long long,int> vis;\\n        unordered_map<int,bool> idx;\\n        for(int i=0;i<nums.size();i++){\\n            vis[nums[i]]=i+1;\\n        }\\n        // cout<<\"h\";\\n        for(int i=0;i<nums.size();i++){\\n            if(idx[i]){\\n                continue;\\n            }\\n            int k=0;\\n            long long p=nums[i];\\n            while(vis[p]){\\n                idx[vis[p]-1]=true;\\n                k++;\\n                // cout<<p<<endl;\\n                p=p*p;\\n                \\n            }\\n            cnt=max(cnt,k);\\n        }\\n        if(cnt==1){\\n            return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=-1;\\n        unordered_map<long long,int> vis;\\n        unordered_map<int,bool> idx;\\n        for(int i=0;i<nums.size();i++){\\n            vis[nums[i]]=i+1;\\n        }\\n        // cout<<\"h\";\\n        for(int i=0;i<nums.size();i++){\\n            if(idx[i]){\\n                continue;\\n            }\\n            int k=0;\\n            long long p=nums[i];\\n            while(vis[p]){\\n                idx[vis[p]-1]=true;\\n                k++;\\n                // cout<<p<<endl;\\n                p=p*p;\\n                \\n            }\\n            cnt=max(cnt,k);\\n        }\\n        if(cnt==1){\\n            return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3620526,
                "title": "java-easy-solution-no-dp-no-sorting-o-n",
                "content": "The idea behind is simple: \\n- put all nums in the array in a hashset\\n- iterating through the array, checking that we have sqare roots and squares of the element in the set. \\n- if we do have the needed square or a square root, we increase counter, and then remove the element from the hashset to avoid processing it multiple times\\n\\nTC: O(N) | Space: O(N)\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] arr) {\\n        var set = new HashSet<Integer>();\\n        for (var num:arr) set.add(num);\\n        \\n        int max=0;\\n        for (int i=0;i<arr.length;i++){\\n            int cnt=0, val = arr[i], low=val, high=val*val;\\n            while (set.contains(low)){\\n                set.remove(low);\\n                var sqrt = (int)Math.sqrt(low);\\n                low= sqrt*sqrt==low?sqrt:-1;\\n                cnt++;\\n                max=Math.max(max,cnt);\\n            }\\n            while (set.contains(high)){\\n                set.remove(high);\\n                high=high*high;\\n                cnt++;\\n                max=Math.max(max,cnt);\\n            }\\n        }\\n        return max<2?-1:max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] arr) {\\n        var set = new HashSet<Integer>();\\n        for (var num:arr) set.add(num);\\n        \\n        int max=0;\\n        for (int i=0;i<arr.length;i++){\\n            int cnt=0, val = arr[i], low=val, high=val*val;\\n            while (set.contains(low)){\\n                set.remove(low);\\n                var sqrt = (int)Math.sqrt(low);\\n                low= sqrt*sqrt==low?sqrt:-1;\\n                cnt++;\\n                max=Math.max(max,cnt);\\n            }\\n            while (set.contains(high)){\\n                set.remove(high);\\n                high=high*high;\\n                cnt++;\\n                max=Math.max(max,cnt);\\n            }\\n        }\\n        return max<2?-1:max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593251,
                "title": "using-hash-map",
                "content": "\\n\\n# Approach\\n  similar to question 128 Longest Consecutive Sequence\\n\\n\\n# Complexity\\n- Time complexity:o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int ans=-1;\\n        unordered_map<int,int>m;\\n        for(auto e:nums)\\n          m[e]++;\\n          for(auto e:nums)\\n          {\\n              int n=sqrt(e);\\n              int x=0;\\n              if((e%n!=0 && m.count(n)>0) || m.count(n)==0)\\n              {\\n                 long long  y=e;\\n                  while(m.count(y)>0 && y<=INT_MAX)\\n                  {\\n                      x++;\\n                      y=y*y;\\n                  }\\n              }\\n              if(x>=2)\\n              ans=max(ans,x);\\n          }\\n          return(ans);\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int ans=-1;\\n        unordered_map<int,int>m;\\n        for(auto e:nums)\\n          m[e]++;\\n          for(auto e:nums)\\n          {\\n              int n=sqrt(e);\\n              int x=0;\\n              if((e%n!=0 && m.count(n)>0) || m.count(n)==0)\\n              {\\n                 long long  y=e;\\n                  while(m.count(y)>0 && y<=INT_MAX)\\n                  {\\n                      x++;\\n                      y=y*y;\\n                  }\\n              }\\n              if(x>=2)\\n              ans=max(ans,x);\\n          }\\n          return(ans);\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586745,
                "title": "2-liner-hashset-c",
                "content": "**If you exclude the variable declarations, function return and indentation of the for loop for readability, it becomes a 2-liner** \\uD83D\\uDE1C\\n\\n---\\n### Time Complexity and Space Complexity: O(n)\\n---\\n- ##### But why? If you consider the smallest possible number and the greatest possible number given in the constraints, the maximum streak can be 2, 4, 16, 256, and 65536\\n- ##### So, the inner for loop won\\'t run more than 5 times, resulting in a time complexity of O(5 * n) = O(n)\\n\\n```C++\\nint longestSquareStreak(vector<int>& nums) {\\n    unordered_set<long long> uniqueNums(nums.begin(), nums.end());       \\n    int ans = 0;\\n\\n    for(long long currNum : uniqueNums)\\n        for(int streak = 0;\\n            uniqueNums.count(currNum);\\n            streak++, currNum = currNum * currNum, ans = max(ans, streak));\\n\\n    return ans > 1 ? ans : -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```C++\\nint longestSquareStreak(vector<int>& nums) {\\n    unordered_set<long long> uniqueNums(nums.begin(), nums.end());       \\n    int ans = 0;\\n\\n    for(long long currNum : uniqueNums)\\n        for(int streak = 0;\\n            uniqueNums.count(currNum);\\n            streak++, currNum = currNum * currNum, ans = max(ans, streak));\\n\\n    return ans > 1 ? ans : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3580958,
                "title": "easy-and-understandable-code-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mn = 1e9;\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int> vis(n,0);\\n        map<int,int> mp;\\n        int mx = sqrt(nums[n-1]) + 1;\\n        for(int i=0; i<n; i++){\\n            mp[nums[i]] = i;\\n        }\\n        int ans = -1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(vis[i]==0){\\n                long long temp = 1LL*nums[i];\\n                int cnt = 0;\\n                while(mp.find(temp)!=mp.end()){\\n                    cnt++;\\n                    vis[mp[temp]] = 1;\\n                    if(temp <= mx){\\n                        temp *= temp;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                if(cnt>=2){\\n                    ans = max(ans,cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mn = 1e9;\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int> vis(n,0);\\n        map<int,int> mp;\\n        int mx = sqrt(nums[n-1]) + 1;\\n        for(int i=0; i<n; i++){\\n            mp[nums[i]] = i;\\n        }\\n        int ans = -1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(vis[i]==0){\\n                long long temp = 1LL*nums[i];\\n                int cnt = 0;\\n                while(mp.find(temp)!=mp.end()){\\n                    cnt++;\\n                    vis[mp[temp]] = 1;\\n                    if(temp <= mx){\\n                        temp *= temp;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                if(cnt>=2){\\n                    ans = max(ans,cnt);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555771,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake a hashmap and store the value at current index with the maximum length of square subarray that can be achieved at that index.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer> m=new HashMap<>();\\n        int res=-1;\\n        for(int x:nums){\\n            int perfect=(int)Math.sqrt(x);\\n            //check perfect int or not as there may be int which will not form perfect square\\n            \\n            if(perfect*perfect==x && m.containsKey(perfect)){\\n                m.put(x,m.get(perfect)+1);\\n                res=Math.max((m.get(perfect)+1),res);   \\n            }\\n            else{\\n                m.put(x,1);\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer> m=new HashMap<>();\\n        int res=-1;\\n        for(int x:nums){\\n            int perfect=(int)Math.sqrt(x);\\n            //check perfect int or not as there may be int which will not form perfect square\\n            \\n            if(perfect*perfect==x && m.containsKey(perfect)){\\n                m.put(x,m.get(perfect)+1);\\n                res=Math.max((m.get(perfect)+1),res);   \\n            }\\n            else{\\n                m.put(x,1);\\n            }\\n        }  \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553003,
                "title": "simple-solution-based-on-criteria",
                "content": "# Intuition\\nSince `317 * 317 = 100489` is greater than 100000 which is in the criteria we only check for numbers less then 317 to see if their square is inside the numbers. It is important to store the numbers inside a set so we have a lookup time of O(1). \\n\\nTime complexity: Constant\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        set_nums = set(nums)\\n        max_streak = 1\\n        # if nums[i] > 317 then nums[i] * nums[i] would be greater than\\n        # 100000\\n        for i in range(2, 317):\\n            n = i\\n            cur_streak = 0\\n            while n < 100000:\\n                if n in set_nums:\\n                    cur_streak += 1\\n                else:\\n                    break\\n                n = n * n\\n                max_streak = max(max_streak, cur_streak)\\n        return max_streak if max_streak > 1 else -1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        set_nums = set(nums)\\n        max_streak = 1\\n        # if nums[i] > 317 then nums[i] * nums[i] would be greater than\\n        # 100000\\n        for i in range(2, 317):\\n            n = i\\n            cur_streak = 0\\n            while n < 100000:\\n                if n in set_nums:\\n                    cur_streak += 1\\n                else:\\n                    break\\n                n = n * n\\n                max_streak = max(max_streak, cur_streak)\\n        return max_streak if max_streak > 1 else -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523260,
                "title": "python-hashmap-easy-to-understand",
                "content": "# Intuition & Approach\\nFirst intuition that comes up is this is similar to longest increasing subsequnce but that approach gives a TLE because the best case TC from that would be  O(N**2). So a different approach would be to use a hashmap and traversing each possible subsequence of squares,\\nHere we just need to keep all the element in the hashmap no matter if they are duplicate or not their contribution in the  subsequnce would be counted only once. Then going through all the elements, if they are unvisited and then checking out if there is another element which is a square that is present in the array. The Worst case TC is when none of the elements have a square in that case we have O(N).\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfrom functools import cache\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        dic={}\\n        visited = set([])\\n        for i in range(len(nums)):\\n            dic[nums[i]]=1\\n        maxi = -1\\n        for i in range(len(nums)):\\n            if(nums[i] in visited):\\n                continue\\n            else:\\n                visited.add(nums[i])\\n                flag = True\\n                count = 1\\n                temp = nums[i]\\n                while(flag):\\n                    temp = temp**2\\n                    if(temp in dic):\\n                        visited.add(temp)\\n                        count+=1\\n                        continue\\n                    else:\\n                        flag = False\\n                maxi = max(maxi, count)\\n        if(maxi>=2):\\n            return maxi\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        dic={}\\n        visited = set([])\\n        for i in range(len(nums)):\\n            dic[nums[i]]=1\\n        maxi = -1\\n        for i in range(len(nums)):\\n            if(nums[i] in visited):\\n                continue\\n            else:\\n                visited.add(nums[i])\\n                flag = True\\n                count = 1\\n                temp = nums[i]\\n                while(flag):\\n                    temp = temp**2\\n                    if(temp in dic):\\n                        visited.add(temp)\\n                        count+=1\\n                        continue\\n                    else:\\n                        flag = False\\n                maxi = max(maxi, count)\\n        if(maxi>=2):\\n            return maxi\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516930,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            int count=1;\\n            long long target=pow(nums[i],2);\\n            int p=i+1;\\n            int q=nums.size()-1; \\n            while(p<=q){\\n                int mid=(p+q)/2;\\n                if(nums[mid]==target){\\n                    target=pow(nums[mid],2);\\n                    count++;\\n                    p=mid+1 ;\\n                    q=nums.size()-1;\\n                }\\n                else if(nums[mid]>target){\\n                    q=mid-1;\\n                }\\n                else{\\n                    p=mid+1;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n       if(*max_element(ans.begin(),ans.end())==1){\\n           return -1;\\n       }\\n       return *max_element(ans.begin(),ans.end());\\n    }\\n};\\n```\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            int count=1;\\n            long long target=pow(nums[i],2);\\n            int p=i+1;\\n            int q=nums.size()-1; \\n            while(p<=q){\\n                int mid=(p+q)/2;\\n                if(nums[mid]==target){\\n                    target=pow(nums[mid],2);\\n                    count++;\\n                    p=mid+1 ;\\n                    q=nums.size()-1;\\n                }\\n                else if(nums[mid]>target){\\n                    q=mid-1;\\n                }\\n                else{\\n                    p=mid+1;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n       if(*max_element(ans.begin(),ans.end())==1){\\n           return -1;\\n       }\\n       return *max_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495509,
                "title": "python-counter-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitialize a counter to have value 1 for each number, then at each number add a 1 to the counter of all values in nums that are the square roots of the num (and the square root of that, until you cannot go deeper)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums_set = set(nums)\\n        my_counter = Counter(nums_set)\\n        for num in nums_set:\\n            while sqrt(num) in nums_set:\\n                my_counter[sqrt(num)] += 1\\n                num = sqrt(num)\\n        return max(my_counter.values()) if max(my_counter.values()) > 1 else -1\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums_set = set(nums)\\n        my_counter = Counter(nums_set)\\n        for num in nums_set:\\n            while sqrt(num) in nums_set:\\n                my_counter[sqrt(num)] += 1\\n                num = sqrt(num)\\n        return max(my_counter.values()) if max(my_counter.values()) > 1 else -1\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489638,
                "title": "c-sort-and-hash-num-to-index",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int,int> num2idx;\\n        for(int i = 0; i < nums.size(); ++i)\\n            num2idx[nums[i]] = i;\\n        \\n        int streak = -1;\\n        for(int i = 0, maxsqrt = sqrt(100\\'000); i < nums.size() && nums[i] <= maxsqrt; ++i) {\\n            if(int n = nums[i]; n) {\\n                int curstreak = 1;\\n                while( n <= maxsqrt && (n = n*n, num2idx.count(n)) ) {\\n                    nums[num2idx[n]] = 0;\\n                    ++curstreak;\\n                }\\n                if(curstreak > 1)\\n                    streak = max(streak, curstreak);\\n            }\\n        }\\n        return streak;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int,int> num2idx;\\n        for(int i = 0; i < nums.size(); ++i)\\n            num2idx[nums[i]] = i;\\n        \\n        int streak = -1;\\n        for(int i = 0, maxsqrt = sqrt(100\\'000); i < nums.size() && nums[i] <= maxsqrt; ++i) {\\n            if(int n = nums[i]; n) {\\n                int curstreak = 1;\\n                while( n <= maxsqrt && (n = n*n, num2idx.count(n)) ) {\\n                    nums[num2idx[n]] = 0;\\n                    ++curstreak;\\n                }\\n                if(curstreak > 1)\\n                    streak = max(streak, curstreak);\\n            }\\n        }\\n        return streak;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487637,
                "title": "c-solution-a-variation-to-lis-problem",
                "content": "class Solution {\\npublic:\\n    \\n    bool isinteger(double num)\\n    {\\n        if(ceil(num)==floor(num))\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int longestSquareStreak(vector<int>& nums) {\\n        int n= nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        unordered_map<int,int> lis;\\n        \\n        for(int i=0;i<n;i++)\\n            lis[nums[i]]=1;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int x= nums[i];\\n            double y= sqrt(nums[i]);\\n            \\n            if(isinteger(y) && lis.count(y))\\n                lis[x]= lis[y]+1;\\n        }\\n        \\n        int maxi= INT_MIN;\\n        \\n        for(auto el: lis)\\n            maxi= max(maxi,el.second);\\n        \\n        if(maxi==1)\\n            return -1;\\n        \\n        return maxi;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool isinteger(double num)\\n    {\\n        if(ceil(num)==floor(num))\\n            return true;\\n        \\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3439132,
                "title": "longest-square-streak-in-an-array",
                "content": "------------------- Easy C++ Solution -----------------\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        unordered_map<int, int> dp;\\n        int result = 0;\\n        for (const auto& x : nums) {\\n            const int sqrt_x = static_cast<int>(sqrt(x));\\n            if (sqrt_x * sqrt_x == x) {\\n                dp[x] = dp[sqrt_x] + 1;\\n            } else {\\n                dp[x] = 1;\\n            }\\n            result = max(result, dp[x]);\\n        }\\n        return result != 1 ? result : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        unordered_map<int, int> dp;\\n        int result = 0;\\n        for (const auto& x : nums) {\\n            const int sqrt_x = static_cast<int>(sqrt(x));\\n            if (sqrt_x * sqrt_x == x) {\\n                dp[x] = dp[sqrt_x] + 1;\\n            } else {\\n                dp[x] = 1;\\n            }\\n            result = max(result, dp[x]);\\n        }\\n        return result != 1 ? result : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433894,
                "title": "easy-understandable-code-with-understandable-comments-o-nlogn-no-dp-binary-search",
                "content": "## Intuition\\nMy first intuition was sorting because the sequence does not matter here. (Even though they have written subsequence but anyway they are sorting it afterwards.)\\n# Approach\\nMy approach is sort the array then take each element from smallest to largest and find its square in the array till last element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int maxLen = -1;  // For storing the answer\\n        int i=0;  pointer for each iteration\\n        while(i<n){\\n            int ans = 1;   // For storing length for each iteration\\n\\n            // starting from current index, find length till end of array\\n            for(int j=i; j<n; ){\\n                // finding index of square of current element\\n                int ind = lower_bound(nums.begin(), nums.end(), (long long)nums[j]*nums[j])-nums.begin();\\n\\n                // updating ans and j\\n                if(ind<n && nums[ind] == nums[j]*nums[j]){\\n                    ans++;\\n                    j = ind;\\n                }\\n\\n                // if ind go outside of array or square does not exist\\n                else break;\\n            }\\n\\n            // updating maxLen\\n            maxLen = max(maxLen, ans);\\n            i++;\\n        }\\n        if(maxLen == 1) return -1;\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int maxLen = -1;  // For storing the answer\\n        int i=0;  pointer for each iteration\\n        while(i<n){\\n            int ans = 1;   // For storing length for each iteration\\n\\n            // starting from current index, find length till end of array\\n            for(int j=i; j<n; ){\\n                // finding index of square of current element\\n                int ind = lower_bound(nums.begin(), nums.end(), (long long)nums[j]*nums[j])-nums.begin();\\n\\n                // updating ans and j\\n                if(ind<n && nums[ind] == nums[j]*nums[j]){\\n                    ans++;\\n                    j = ind;\\n                }\\n\\n                // if ind go outside of array or square does not exist\\n                else break;\\n            }\\n\\n            // updating maxLen\\n            maxLen = max(maxLen, ans);\\n            i++;\\n        }\\n        if(maxLen == 1) return -1;\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433301,
                "title": "easy-hashmap-and-dp-solution",
                "content": "# Intuition\\nThe problem asks to find the length of the longest subsequence in the given array that is a square streak. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. Therefore, we need to find all the subsequences that are square streaks and return the length of the longest one.\\n\\n# Approach\\nWe can start by sorting the array in non-decreasing order. Then, for each number in the array, we can check if there exists a subsequence starting from this number that is a square streak. To do this, we can check all the numbers that are the square of the previous number in the sorted array. If such a number exists, we can add it to the subsequence and continue the process until we cannot find any more numbers that are the square of the previous number. We can then update the length of the longest subsequence found so far and continue with the next number in the array.\\n\\nTo optimize this approach, we can use dynamic programming to store the length of the longest square streak ending at each number in the array. We can then use this information to find the length of the longest square streak starting at each number in the array. We can also use a hash map to store the frequency of each number in the array, which will help us to avoid duplicate calculations.\\n\\n# Complexity\\n- Time complexity:\\nO(n log n), where n is the length of the input array. This is because we need to sort the array in non-decreasing order, which takes O(n log n) time. We then need to iterate over each number in the array, and for each number, we need to check all the numbers that are the square of the previous number, which takes O(log n) time. Therefore, the overall time complexity is O(n log n * log n) = O(n log^2 n).\\n\\n- Space complexity: \\n O(n), where n is the length of the input array. This is because we need to store the length of the longest square streak ending at each number in the array, which takes O(n) space. We also need to store the frequency of each number in the array, which takes O(n) space. Therefore, the overall space complexity is O(n + n) = O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInt(double num) {\\n        return floor(num) == ceil(num);\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_map<int,int> mp;//this is dp\\n        sort(nums.begin(),nums.end());\\n        // 2 3 4 6 8 16\\n        // 1 1 2 1 2 3\\n\\n        // 2 3 5 6 7\\n        // 1 1 1 1 1\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=1;\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++){\\n            int x=nums[i];\\n            int curans=1;\\n            double y=sqrt(x);\\n            if(isInt(y) && mp.find(y)!=mp.end()){\\n                mp[x]=mp[y]+1;\\n                curans=mp[x];\\n            }\\n\\n            ans=max(ans,curans);\\n        }\\n        return ans>=2?ans:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInt(double num) {\\n        return floor(num) == ceil(num);\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_map<int,int> mp;//this is dp\\n        sort(nums.begin(),nums.end());\\n        // 2 3 4 6 8 16\\n        // 1 1 2 1 2 3\\n\\n        // 2 3 5 6 7\\n        // 1 1 1 1 1\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]=1;\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++){\\n            int x=nums[i];\\n            int curans=1;\\n            double y=sqrt(x);\\n            if(isInt(y) && mp.find(y)!=mp.end()){\\n                mp[x]=mp[y]+1;\\n                curans=mp[x];\\n            }\\n\\n            ans=max(ans,curans);\\n        }\\n        return ans>=2?ans:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426650,
                "title": "java-simple-hashmap",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] arr) {\\n        HashMap<Integer,Boolean> map = new HashMap<>();\\n        for(int i:arr){\\n            map.put(i,true);\\n        }\\n        int res = 0;\\n        Arrays.sort(arr);\\n        for(int i = 0;i<arr.length;i++){\\n            int cnt = 1;\\n            int a = arr[i];\\n            if(map.get(a)){\\n                map.put(a,false);\\n                while(map.containsKey(a*a) && map.get(a*a) == true){\\n                    cnt++;\\n                    a = a*a;\\n                    map.put(a,false);\\n                }\\n                res = Math.max(res,cnt);\\n            }\\n        }\\n        return res == 1 ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] arr) {\\n        HashMap<Integer,Boolean> map = new HashMap<>();\\n        for(int i:arr){\\n            map.put(i,true);\\n        }\\n        int res = 0;\\n        Arrays.sort(arr);\\n        for(int i = 0;i<arr.length;i++){\\n            int cnt = 1;\\n            int a = arr[i];\\n            if(map.get(a)){\\n                map.put(a,false);\\n                while(map.containsKey(a*a) && map.get(a*a) == true){\\n                    cnt++;\\n                    a = a*a;\\n                    map.put(a,false);\\n                }\\n                res = Math.max(res,cnt);\\n            }\\n        }\\n        return res == 1 ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410713,
                "title": "c-sort-and-dp",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n\\n        int n = nums.size();\\n        int dp[100001] = {0};\\n        dp[nums[0]] = 1;\\n\\n        int ans = 1;\\n        for (int i = 1; i < n; ++i)\\n        {\\n            dp[nums[i]] = 1;\\n            int prev = sqrt(nums[i]);\\n            if (prev * prev != nums[i])\\n            {\\n                continue;\\n            }\\n\\n            if (dp[prev])\\n            {\\n                dp[nums[i]] = dp[prev] + 1;\\n            }\\n\\n            ans = max(ans, dp[nums[i]]);\\n        }\\n\\n        return ans == 1 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n        sort(nums.begin(), nums.end());\\n\\n        int n = nums.size();\\n        int dp[100001] = {0};\\n        dp[nums[0]] = 1;\\n\\n        int ans = 1;\\n        for (int i = 1; i < n; ++i)\\n        {\\n            dp[nums[i]] = 1;\\n            int prev = sqrt(nums[i]);\\n            if (prev * prev != nums[i])\\n            {\\n                continue;\\n            }\\n\\n            if (dp[prev])\\n            {\\n                dp[nums[i]] = dp[prev] + 1;\\n            }\\n\\n            ans = max(ans, dp[nums[i]]);\\n        }\\n\\n        return ans == 1 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398885,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int max=0;\\n        HashMap<Integer,Integer> h=new HashMap<Integer,Integer>();\\n        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(!h.containsKey(nums[i]))\\n            {\\n                h.put(nums[i],1);\\n                pq.add(nums[i]);\\n            }\\n        }\\n        while(pq.size()>0)\\n        {\\n            int x=pq.poll();\\n            if(h.containsKey(x))\\n            {\\n                h.remove(x);\\n                int p=1;\\n                while(true)\\n                {\\n                    if(x>1000)     //nums[i]<=100000\\n                    {\\n                        break;\\n                    }\\n                    x=x*x;\\n                    if(h.containsKey(x))\\n                    {\\n                        p++;\\n                        h.remove(x);\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(p>1)\\n                {\\n                    if(max<p)\\n                    {\\n                        max=p;\\n                    }\\n                }\\n            }\\n\\n        }\\n        if(max==0)\\n        {\\n            return -1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        int max=0;\\n        HashMap<Integer,Integer> h=new HashMap<Integer,Integer>();\\n        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(!h.containsKey(nums[i]))\\n            {\\n                h.put(nums[i],1);\\n                pq.add(nums[i]);\\n            }\\n        }\\n        while(pq.size()>0)\\n        {\\n            int x=pq.poll();\\n            if(h.containsKey(x))\\n            {\\n                h.remove(x);\\n                int p=1;\\n                while(true)\\n                {\\n                    if(x>1000)     //nums[i]<=100000\\n                    {\\n                        break;\\n                    }\\n                    x=x*x;\\n                    if(h.containsKey(x))\\n                    {\\n                        p++;\\n                        h.remove(x);\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(p>1)\\n                {\\n                    if(max<p)\\n                    {\\n                        max=p;\\n                    }\\n                }\\n            }\\n\\n        }\\n        if(max==0)\\n        {\\n            return -1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394305,
                "title": "kotlin-short-no-sorting",
                "content": "```\\n\\tfun longestSquareStreak(nums: IntArray): Int {\\n        val cache = mutableMapOf<Int, Int>()\\n        val occs = nums.toSet()\\n        \\n        var longest = 0\\n        for (num in nums) {\\n            longest = maxOf(longest, compute(num, occs, cache))\\n        }\\n        \\n        return if (longest > 1) longest else -1\\n    }\\n    \\n    private fun compute(num: Int, occs: Set<Int>, cache: MutableMap<Int, Int>): Int = when {\\n        !occs.contains(num) -> 0\\n        cache.containsKey(num) -> cache.getValue(num)\\n        num > 46340 -> 1\\n        else -> (1 + compute(num * num, occs, cache)).apply { cache[num] = this }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tfun longestSquareStreak(nums: IntArray): Int {\\n        val cache = mutableMapOf<Int, Int>()\\n        val occs = nums.toSet()\\n        \\n        var longest = 0\\n        for (num in nums) {\\n            longest = maxOf(longest, compute(num, occs, cache))\\n        }\\n        \\n        return if (longest > 1) longest else -1\\n    }\\n    \\n    private fun compute(num: Int, occs: Set<Int>, cache: MutableMap<Int, Int>): Int = when {\\n        !occs.contains(num) -> 0\\n        cache.containsKey(num) -> cache.getValue(num)\\n        num > 46340 -> 1\\n        else -> (1 + compute(num * num, occs, cache)).apply { cache[num] = this }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3394158,
                "title": "hashset-implementation-o-n-similar-to-finding-the-longest-consecutive-subsequence-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<double> set;\\n        for(int i = 0; i<nums.size(); i++){\\n            set.insert(nums[i]);\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(set.count((long)nums[i]*nums[i])>0){\\n                continue;\\n            }else{\\n                int temp = 0;\\n                double val = nums[i];\\n                while(set.count(val)>0){\\n                    temp++;\\n                    val = sqrt(val);\\n                }\\n                count = max(count, temp);\\n            }\\n        }\\n        if(count<2){\\n            return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<double> set;\\n        for(int i = 0; i<nums.size(); i++){\\n            set.insert(nums[i]);\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(set.count((long)nums[i]*nums[i])>0){\\n                continue;\\n            }else{\\n                int temp = 0;\\n                double val = nums[i];\\n                while(set.count(val)>0){\\n                    temp++;\\n                    val = sqrt(val);\\n                }\\n                count = max(count, temp);\\n            }\\n        }\\n        if(count<2){\\n            return -1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394038,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def longestSquareStreak(nums: Array[Int]): Int = {\\n        val res = nums.sorted.reverse.foldLeft(Map[Int, Int]())((acc, cur)=>{\\n            acc + (cur -> (acc.getOrElse(cur * cur, 0)  + 1))\\n        }).values.max\\n        if(res == 1) -1 else res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def longestSquareStreak(nums: Array[Int]): Int = {\\n        val res = nums.sorted.reverse.foldLeft(Map[Int, Int]())((acc, cur)=>{\\n            acc + (cur -> (acc.getOrElse(cur * cur, 0)  + 1))\\n        }).values.max\\n        if(res == 1) -1 else res\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3375427,
                "title": "easy-to-understand-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        sort(nums.begin(), nums.end());\\n        for(auto it: nums) {\\n            if(m.count(it)) continue;\\n            m[it] = 1;\\n            int root = sqrt(it);\\n            if(root*root == it) {\\n                m[it] = m[root] + 1;\\n                m.erase(root);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto it: m) ans = max(ans, it.second);\\n        return ans == 1 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        sort(nums.begin(), nums.end());\\n        for(auto it: nums) {\\n            if(m.count(it)) continue;\\n            m[it] = 1;\\n            int root = sqrt(it);\\n            if(root*root == it) {\\n                m[it] = m[root] + 1;\\n                m.erase(root);\\n            }\\n        }\\n        int ans = 0;\\n        for(auto it: m) ans = max(ans, it.second);\\n        return ans == 1 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372603,
                "title": "c-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<long long, int> mp;\\n        int l = -1;\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            long long n = nums[i];\\n            long long n2 = n * n;\\n            int streak = 0;\\n            if(mp.find(n2) != mp.end()){\\n                streak = mp[n2];\\n            }\\n            mp[n] = streak + 1;\\n            if(streak + 1 >= 2) l = max(streak + 1, l);\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<long long, int> mp;\\n        int l = -1;\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            long long n = nums[i];\\n            long long n2 = n * n;\\n            int streak = 0;\\n            if(mp.find(n2) != mp.end()){\\n                streak = mp[n2];\\n            }\\n            mp[n] = streak + 1;\\n            if(streak + 1 >= 2) l = max(streak + 1, l);\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361244,
                "title": "java-using-set",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : nums) set.add(n);\\n        int streak = -1;\\n        for (int n : nums) {\\n            int temp = n, count = 1;\\n            while (set.contains((int)Math.min(Integer.MAX_VALUE, 1L * temp * temp))) {\\n                temp *= temp;\\n                count++;\\n            }\\n            if (count > 1 && streak < count) {\\n                streak = count;\\n            }\\n        }\\n        return streak;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : nums) set.add(n);\\n        int streak = -1;\\n        for (int n : nums) {\\n            int temp = n, count = 1;\\n            while (set.contains((int)Math.min(Integer.MAX_VALUE, 1L * temp * temp))) {\\n                temp *= temp;\\n                count++;\\n            }\\n            if (count > 1 && streak < count) {\\n                streak = count;\\n            }\\n        }\\n        return streak;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354815,
                "title": "c-sorting-binary-search-faster-easy-to-understand",
                "content": "* ***Using Sorting && Binary Search***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // find the index of square using binary search\\n    \\n    int find(vector<int>& nums, vector<bool>& vis, int idx, long long target)\\n    {\\n        int n = nums.size();\\n        \\n        int low = idx;\\n        \\n        int high = n - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            \\n            if(vis[mid])\\n            {\\n                if(target >= nums[mid])\\n                {\\n                    low = mid + 1;\\n                }\\n                else\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n            else if(vis[mid] == false)\\n            {\\n                if(nums[mid] == target)\\n                {\\n                    return mid;\\n                }\\n                else if(target > nums[mid])\\n                {\\n                    low = mid + 1;\\n                }\\n                else\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int longestSquareStreak(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the nums\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // declare an visited array\\n        \\n        vector<bool> vis(n, false);\\n        \\n        int maxi = -1;\\n        \\n        // traverse over the nums and find maxi\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(vis[i] == false)\\n            {\\n                long long curr = (long long) nums[i] * (long long) nums[i];\\n                \\n                int idx = i + 1;\\n                \\n                int count = 1;\\n                \\n                while(1)\\n                {\\n                    idx = find(nums, vis, idx, curr);\\n                    \\n                    if(idx == -1)\\n                    {\\n                        break;\\n                    }\\n                    \\n                    // update curr\\n                    \\n                    curr = (long long) nums[idx] * (long long) nums[idx];\\n                    \\n                    count++;\\n                    \\n                    // mark idx as visited\\n                    \\n                    vis[idx] = true;\\n                }\\n                \\n                // update maxi\\n                \\n                if(count >= 2)\\n                {\\n                    maxi = max(maxi, count);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // find the index of square using binary search\\n    \\n    int find(vector<int>& nums, vector<bool>& vis, int idx, long long target)\\n    {\\n        int n = nums.size();\\n        \\n        int low = idx;\\n        \\n        int high = n - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            \\n            if(vis[mid])\\n            {\\n                if(target >= nums[mid])\\n                {\\n                    low = mid + 1;\\n                }\\n                else\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n            else if(vis[mid] == false)\\n            {\\n                if(nums[mid] == target)\\n                {\\n                    return mid;\\n                }\\n                else if(target > nums[mid])\\n                {\\n                    low = mid + 1;\\n                }\\n                else\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int longestSquareStreak(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the nums\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // declare an visited array\\n        \\n        vector<bool> vis(n, false);\\n        \\n        int maxi = -1;\\n        \\n        // traverse over the nums and find maxi\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(vis[i] == false)\\n            {\\n                long long curr = (long long) nums[i] * (long long) nums[i];\\n                \\n                int idx = i + 1;\\n                \\n                int count = 1;\\n                \\n                while(1)\\n                {\\n                    idx = find(nums, vis, idx, curr);\\n                    \\n                    if(idx == -1)\\n                    {\\n                        break;\\n                    }\\n                    \\n                    // update curr\\n                    \\n                    curr = (long long) nums[idx] * (long long) nums[idx];\\n                    \\n                    count++;\\n                    \\n                    // mark idx as visited\\n                    \\n                    vis[idx] = true;\\n                }\\n                \\n                // update maxi\\n                \\n                if(count >= 2)\\n                {\\n                    maxi = max(maxi, count);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333488,
                "title": "no-sort-o-n-time-and-space",
                "content": "# Intuition\\n\\n# Approach\\n- Create a set of the array\\n- For each number in the set, we can keep doulbing and square-rooting the number and check if set contains this number, while removing this number from the set as well to make sure we only check each number once\\n\\n# Complexity\\n- Time complexity: O(n) for creating set and going through each number in the array once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for creating set\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestSquareStreak(int[] nums) {\\n        HashSet<int> set = nums.ToHashSet();\\n\\n        int max = -1;\\n        foreach (int n in set)\\n        {\\n            int count = 1;\\n            long num = (long) n * n;\\n            while (num <= int.MaxValue && set.Contains((int) num))\\n            {\\n                set.Remove((int) num);\\n                count++;\\n                num *= num;\\n            }\\n\\n            double sqrt = Math.Sqrt(n);\\n            bool isSquare = sqrt % 1 == 0;\\n            while (isSquare && set.Contains((int) sqrt))\\n            {\\n                set.Remove((int) sqrt);\\n                count++;\\n                sqrt = Math.Sqrt(sqrt);\\n                isSquare = sqrt % 1 == 0;\\n            }\\n\\n            if (count > 1)\\n                max = Math.Max(max, count);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestSquareStreak(int[] nums) {\\n        HashSet<int> set = nums.ToHashSet();\\n\\n        int max = -1;\\n        foreach (int n in set)\\n        {\\n            int count = 1;\\n            long num = (long) n * n;\\n            while (num <= int.MaxValue && set.Contains((int) num))\\n            {\\n                set.Remove((int) num);\\n                count++;\\n                num *= num;\\n            }\\n\\n            double sqrt = Math.Sqrt(n);\\n            bool isSquare = sqrt % 1 == 0;\\n            while (isSquare && set.Contains((int) sqrt))\\n            {\\n                set.Remove((int) sqrt);\\n                count++;\\n                sqrt = Math.Sqrt(sqrt);\\n                isSquare = sqrt % 1 == 0;\\n            }\\n\\n            if (count > 1)\\n                max = Math.Max(max, count);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330571,
                "title": "python-sort-and-check-from-first-number",
                "content": "We can sort the array first and find the next square number in the array and mark it visited. We skip all the visited number and reset the counter for length tracking.\\n\\nOnce we visited all the numbers in the array, we can find the longest square streak.\\n\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        num_dict = set(nums)\\n        num_set_sorted = list(num_dict)\\n        seen = set()\\n        \\n        idx, ans = 0, -1\\n        while idx < len(num_set_sorted):\\n            if num_set_sorted[idx] not in seen:\\n                t_len = 1\\n                start = num_set_sorted[idx]\\n                seen.add(num_set_sorted[idx])\\n                nxt_num = start * start\\n                while nxt_num in num_dict:\\n                    t_len += 1\\n                    seen.add(nxt_num)\\n                    nxt_num = nxt_num * nxt_num\\n                if t_len >= 2 and t_len > ans:\\n                    ans = t_len\\n            idx += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        num_dict = set(nums)\\n        num_set_sorted = list(num_dict)\\n        seen = set()\\n        \\n        idx, ans = 0, -1\\n        while idx < len(num_set_sorted):\\n            if num_set_sorted[idx] not in seen:\\n                t_len = 1\\n                start = num_set_sorted[idx]\\n                seen.add(num_set_sorted[idx])\\n                nxt_num = start * start\\n                while nxt_num in num_dict:\\n                    t_len += 1\\n                    seen.add(nxt_num)\\n                    nxt_num = nxt_num * nxt_num\\n                if t_len >= 2 and t_len > ans:\\n                    ans = t_len\\n            idx += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304031,
                "title": "2501-longest-square-streak-in-an-array",
                "content": "# Complexity\\n- Time complexity: N logN\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <unordered_map>\\nclass Solution {\\npublic:\\n    int bin_search(vector<int>& nums, int l, int r, int num)\\n    {\\n        int mid;\\n        while(l <= r)\\n        {\\n            mid = (l + r) >> 1;\\n\\n            if(nums[mid] == num)\\n                return mid;\\n            else if(nums[mid] < num)\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        return -1;\\n    }\\n\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_map<int, int> visited;\\n\\n        std::sort(nums.begin(), nums.end());\\n        nums.erase( unique( nums.begin(), nums.end() ), nums.end() );\\n        int mac = -1;\\n        int current = -1;\\n        int sq;\\n        int index;\\n\\n        for(int i = 0; i < nums.size(); i++){\\n            if (visited.find(i) != visited.end()) continue;\\n\\n            if(nums[i] < 32000) sq= nums[i] * nums[i];\\n\\n            else visited.insert({i,i});\\n\\n            index = 0;\\n\\n            do{\\n\\n                index = bin_search(nums, i + 1 + current, nums.size() - 1, sq);\\n\\n                if(index!=-1){\\n                    visited.insert({index,index});\\n                    current++;\\n                    if (sq >= 32000) {\\n                        mac = mac > current ? mac : current;\\n                        current = -1;\\n                        break;}\\n                    sq = sq * sq;}\\n\\n            } while((index != -1 and index < nums.size()));\\n\\n            mac = mac > current ? mac : current;\\n            current = -1;}\\n\\n\\n        mac = mac > current ? mac : current;\\n        return mac != -1 ? mac + 2 : mac;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\n#include <unordered_map>\\nclass Solution {\\npublic:\\n    int bin_search(vector<int>& nums, int l, int r, int num)\\n    {\\n        int mid;\\n        while(l <= r)\\n        {\\n            mid = (l + r) >> 1;\\n\\n            if(nums[mid] == num)\\n                return mid;\\n            else if(nums[mid] < num)\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        return -1;\\n    }\\n\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_map<int, int> visited;\\n\\n        std::sort(nums.begin(), nums.end());\\n        nums.erase( unique( nums.begin(), nums.end() ), nums.end() );\\n        int mac = -1;\\n        int current = -1;\\n        int sq;\\n        int index;\\n\\n        for(int i = 0; i < nums.size(); i++){\\n            if (visited.find(i) != visited.end()) continue;\\n\\n            if(nums[i] < 32000) sq= nums[i] * nums[i];\\n\\n            else visited.insert({i,i});\\n\\n            index = 0;\\n\\n            do{\\n\\n                index = bin_search(nums, i + 1 + current, nums.size() - 1, sq);\\n\\n                if(index!=-1){\\n                    visited.insert({index,index});\\n                    current++;\\n                    if (sq >= 32000) {\\n                        mac = mac > current ? mac : current;\\n                        current = -1;\\n                        break;}\\n                    sq = sq * sq;}\\n\\n            } while((index != -1 and index < nums.size()));\\n\\n            mac = mac > current ? mac : current;\\n            current = -1;}\\n\\n\\n        mac = mac > current ? mac : current;\\n        return mac != -1 ? mac + 2 : mac;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3283910,
                "title": "best-solution-in-c-binarysearch",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=1;\\n            long long sqr=(long long)nums[i]*nums[i];\\n            while(binary_search(nums.begin(),nums.end(),sqr))\\n            {\\n                count++;\\n                sqr*=sqr;\\n                ans=max(ans,count);\\n            }\\n        }\\n        return ans>1?ans:-1; //If answer equal or less than 1 return -1 else count\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=1;\\n            long long sqr=(long long)nums[i]*nums[i];\\n            while(binary_search(nums.begin(),nums.end(),sqr))\\n            {\\n                count++;\\n                sqr*=sqr;\\n                ans=max(ans,count);\\n            }\\n        }\\n        return ans>1?ans:-1; //If answer equal or less than 1 return -1 else count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278067,
                "title": "python-dfs",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n- Space complexity:\\nO(n)\\n\\nIf you like it please upvote!\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        def dfs(v: int) -> int:\\n            if v not in s:\\n                return 0\\n            s.remove(v)\\n            sqr = v ** 2\\n            if sqr in s:\\n                return 1 + dfs(sqr)\\n            else:\\n                return 1\\n        # dedup\\n        s = set(nums)\\n        nums = sorted(s)\\n        i, r, n = 0, 1, len(nums)\\n        while n - i > r:\\n            r = max(r, dfs(nums[i]))\\n            i += 1\\n        return -1 if r == 1 else r\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        def dfs(v: int) -> int:\\n            if v not in s:\\n                return 0\\n            s.remove(v)\\n            sqr = v ** 2\\n            if sqr in s:\\n                return 1 + dfs(sqr)\\n            else:\\n                return 1\\n        # dedup\\n        s = set(nums)\\n        nums = sorted(s)\\n        i, r, n = 0, 1, len(nums)\\n        while n - i > r:\\n            r = max(r, dfs(nums[i]))\\n            i += 1\\n        return -1 if r == 1 else r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259410,
                "title": "easy-c-solution-top-2-by-runtime-top-10-by-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf some number in array is a member of a streak, its square root is also presented in the array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, extract the maximal number in order to know how much memory we have to allocate.\\n\\nSecondly, initialize and fill boolean array. Each its element shows if that index exists in the input array.\\n\\nThirdly, calculate the streak length for each number. If the fractional part of the root is not zero the the number is not full square and its streak cannot have smaller members. Try to extract square root until it is interger and presented in array and update result if necessary.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(maximal)$$\\n# Code\\n```\\nclass Solution {\\n   \\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n         int lim = 0;\\n         for (auto num : nums)\\n         {\\n             lim = max(lim, num);\\n         }\\n\\n         std::vector<bool> exists(lim + 1);\\n         for (auto num : nums)\\n         {\\n             exists[num] = true;\\n         }\\n\\n         int res = 0;\\n     \\n        for (auto num : nums)\\n        {\\n            int cur = 0;\\n            while (exists[num])\\n            {\\n                ++cur;\\n                float root = sqrt(num);\\n                int intpart = int(root);\\n                if (root - intpart != 0.0f)\\n                    break;\\n                num = intpart;\\n            }\\n\\n            res = max(cur, res);\\n        }\\n\\n        return (res == 1) ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    int longestSquareStreak(vector<int>& nums) \\n    {\\n         int lim = 0;\\n         for (auto num : nums)\\n         {\\n             lim = max(lim, num);\\n         }\\n\\n         std::vector<bool> exists(lim + 1);\\n         for (auto num : nums)\\n         {\\n             exists[num] = true;\\n         }\\n\\n         int res = 0;\\n     \\n        for (auto num : nums)\\n        {\\n            int cur = 0;\\n            while (exists[num])\\n            {\\n                ++cur;\\n                float root = sqrt(num);\\n                int intpart = int(root);\\n                if (root - intpart != 0.0f)\\n                    break;\\n                num = intpart;\\n            }\\n\\n            res = max(cur, res);\\n        }\\n\\n        return (res == 1) ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255798,
                "title": "c-solution-with-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long longestSquareStreak(vector<int>& nums) {\\n        long long n=nums.size();\\n        long long l=0;\\n        long long maxlen=0;\\n        long long sq=0;\\n        sort(nums.begin(),nums.end());\\n        for(long long i=0;i<nums.size();i++){\\n            if(nums[i]>pow(10,2.5)) continue;\\n            sq=nums[i]*nums[i];\\n            l=0;\\n            while(sq<=nums[n-1]){\\n                if(binary_search(nums.begin()+i+1+l,nums.end(),sq)) l++;\\n                else break;\\n                sq=sq*sq;\\n            }\\n            maxlen=max(maxlen,l);\\n        }\\n        if(maxlen<1) return -1;\\n        return maxlen+1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long longestSquareStreak(vector<int>& nums) {\\n        long long n=nums.size();\\n        long long l=0;\\n        long long maxlen=0;\\n        long long sq=0;\\n        sort(nums.begin(),nums.end());\\n        for(long long i=0;i<nums.size();i++){\\n            if(nums[i]>pow(10,2.5)) continue;\\n            sq=nums[i]*nums[i];\\n            l=0;\\n            while(sq<=nums[n-1]){\\n                if(binary_search(nums.begin()+i+1+l,nums.end(),sq)) l++;\\n                else break;\\n                sq=sq*sq;\\n            }\\n            maxlen=max(maxlen,l);\\n        }\\n        if(maxlen<1) return -1;\\n        return maxlen+1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232134,
                "title": "c-union-find-disjoint-set-100-time-90ms-90-space-85-3mb",
                "content": "This looks really like a problem where we will have to group/cluster elements and see which group is bigger.\\n\\nAnd if that does not scream \"Union Find!\" to you, I don\\'t know what it does \\uD83E\\uDD14.\\n\\nWe will start declaring a few external constants:\\n* `maxRange` represent the upper limit of our specs, plus `1` to make it fit in `0`- based indexed array avoiding annoying `+ 1` operations all the time;\\n* `sqrLmt` is going to be the limit for squaring values we will use later, set to the square root of `maxRange`.\\n\\nIn our `UF` class we will have three instance variables and two methods:\\n* `parent` will store the value of each node\\'s parent, initially all set to `0`, which means the nodes does not exist (we can do it, since we will never get a node with a value `< 2`);\\n* `rank` will store the value of the node\\'s cluster size, being set initially to `1` for each new found node;\\n* `maxRank` will store the size of the largest cluster we will find, initially set to be `-1` - the value we will `return` when no cluster of at least two elements is found;\\n* `find` will work like a classic UF lookup, flattening the lookup time as it goes (that was it gives us the slightly above linear time, see below for the complexity part); for each `node` we will `return`:\\n    * `node` if `parent[node]` is already the same value - ie: `node` is the head of a cluster;\\n    * the new value of `parent[node]`, computed calling recursively `find` on the previous value;\\n* `merge` will try unite the clusters of the two provided nodes `node1` and `node2` (with `node1` guaranteed to be `< node2`). More in detail, it will:\\n    * update `node1` to be its own parent by calling `find` on it;\\n    * update `node2` to be its own parent by calling `find` on it;\\n    * if either value is not present in our data structure yet (ie: either call to find the parent gave us a `0`) or if they are already in the same cluster (ie: they have already the same head of cluster, `node1 == node2`), we will `return` out of the function;\\n    * increase the rank of `node1` (we know it has to be the smaller) to include also the rank of `node2`;\\n    * update `maxRank` to be the maximum between its current value and the increased value of `rank[node1]`;\\n    * set the parent of `node2` to be `node1`.\\n\\nIn our main function, we will declare a few support variables:\\n* `sqrtN` will store the floored square root of each number we test;\\n* `uf` will be our `UF` instance.\\n\\nNow, time to parse `nums` and for each value `n` in it, we will:\\n* `continue`, if we already worked on this specific value (ie: `parent[n] != 0`);\\n* set the parent of `n` to be itself;\\n* set the rank of `n` to be `1` (ie: initially the element is in a cluster containing only itself);\\n* compute `sqrtN` as the floored square root of `n`;\\n* if `n` was a perfect square (ie: `sqrtN * sqrtN == n`), we will try to merge `sqrtN` and `n`;\\n* if `n` squared does not exceed our upper limit (ie: `n <= sqrLmt`), we will try to merge `n` and its square (`n * n`).\\n\\nFinally, we will just `return` `uf.maxRank` :)\\n\\n# Complexity\\n- Time complexity: $$O(n\\u03B1(n))$$ (with `\\u03B1(n)` being [the inverse Ackermann function](https://en.wikipedia.org/wiki/Ackermann_function#Inverse))\\n- Space complexity: $$O(1)$$ (we always use the upper limit of the range)\\n\\n# Code\\n```cpp\\nconstexpr int maxRange = 500001, sqrLmt = 707;\\n\\nstruct UF {\\n    int parent[maxRange] = {}, rank[maxRange], maxRank = -1;\\n    int find(int node) {\\n        return parent[node] == node ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int node1, int node2) {\\n        // checking if they exist and looking for the root node of their clusters\\n        node1 = find(parent[node1]), node2 = find(parent[node2]);\\n        // exiting if either does not exist or if already merged\\n        if (!node1 || !node2 || node1 == node2) return;\\n        // actual union\\n        maxRank = max(maxRank, rank[node1] += rank[node2]);\\n        parent[node2] = node1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int> &nums) {\\n        // support variables\\n        int sqrtN;\\n        UF uf = UF();\\n        // parsing nums\\n        for (int n : nums) {\\n            // moving out if we already encountered n\\n            if (uf.parent[n]) continue;\\n            // setting every node to be its own parent with rank 1\\n            uf.parent[n] = n, uf.rank[n] = 1;\\n            // trying to merge n with its square root, if it exists\\n            sqrtN = sqrt(n);\\n            if (sqrtN * sqrtN == n) uf.merge(sqrtN, n);\\n            // trying to merge n with its square root, if in range\\n            if (n <= sqrLmt) uf.merge(n, n * n);\\n        }\\n        return uf.maxRank;\\n    }\\n};\\n```\\n\\nCan we do better?\\n\\nYep, if we pay the cost of a linear pass in the `UF` constructor to find the maximum extension of the range and size `parent` and `rank` accordingly.\\n\\nI thought that this dynamic allocation would have slowed us down a lot, but apparently there are very few test cases going for bigger ranges and I moved my best time down a few dozens seconds (ie: speed improved about 30%) \\uD83C\\uDF89!\\n\\n# Complexity\\n- Time complexity: $$O(n\\u03B1(n))$$ (with `\\u03B1(n)` being [the inverse Ackermann function](https://en.wikipedia.org/wiki/Ackermann_function#Inverse))\\n- Space complexity: $$O(maxN)$$\\n\\n```cpp\\nstruct UF {\\n    int *parent, *rank, maxRank = -1,  maxRange = INT_MIN, sqrLmt;\\n    UF(vector<int> &nums) {\\n        // finding the highest value we will have to deal with and its square\\n        maxRange = *max_element(begin(nums), end(nums)) + 1;\\n        sqrLmt = sqrt(maxRange - 1);\\n        // sizing parent and rank accordingly and initialising parent\\n        parent = new int[maxRange], rank = new int[maxRange];\\n        // preparing parent\\n        fill(parent, parent + maxRange, 0);\\n    }\\n    int find(int node) {\\n        return parent[node] == node ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int node1, int node2) {\\n        // checking if they exist and looking for the root node of their clusters\\n        node1 = find(parent[node1]), node2 = find(parent[node2]);\\n        // exiting if either does not exist or if already merged\\n        if (!node1 || !node2 || node1 == node2) return;\\n        // actual union\\n        maxRank = max(maxRank, rank[node1] += rank[node2]);\\n        parent[node2] = node1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int> &nums) {\\n        // support variables\\n        UF uf = UF(nums);\\n        int sqrtN, sqrLmt = uf.sqrLmt;\\n        // parsing nums\\n        for (int n : nums) {\\n            // moving out if we already encountered n\\n            if (uf.parent[n]) continue;\\n            // setting every node to be its own parent with rank 1\\n            uf.parent[n] = n, uf.rank[n] = 1;\\n            // trying to merge n with its square root, if it exists\\n            sqrtN = sqrt(n);\\n            if (sqrtN * sqrtN == n) uf.merge(sqrtN, n);\\n            // trying to merge n with its square root, if in range\\n            if (n <= sqrLmt) uf.merge(n, n * n);\\n        }\\n        return uf.maxRank;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image.png](https://assets.leetcode.com/users/images/22d3d0e4-7d12-4c40-b13f-5cda9ed22ec2_1677403041.0496309.png)\\n",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```cpp\\nconstexpr int maxRange = 500001, sqrLmt = 707;\\n\\nstruct UF {\\n    int parent[maxRange] = {}, rank[maxRange], maxRank = -1;\\n    int find(int node) {\\n        return parent[node] == node ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int node1, int node2) {\\n        // checking if they exist and looking for the root node of their clusters\\n        node1 = find(parent[node1]), node2 = find(parent[node2]);\\n        // exiting if either does not exist or if already merged\\n        if (!node1 || !node2 || node1 == node2) return;\\n        // actual union\\n        maxRank = max(maxRank, rank[node1] += rank[node2]);\\n        parent[node2] = node1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int> &nums) {\\n        // support variables\\n        int sqrtN;\\n        UF uf = UF();\\n        // parsing nums\\n        for (int n : nums) {\\n            // moving out if we already encountered n\\n            if (uf.parent[n]) continue;\\n            // setting every node to be its own parent with rank 1\\n            uf.parent[n] = n, uf.rank[n] = 1;\\n            // trying to merge n with its square root, if it exists\\n            sqrtN = sqrt(n);\\n            if (sqrtN * sqrtN == n) uf.merge(sqrtN, n);\\n            // trying to merge n with its square root, if in range\\n            if (n <= sqrLmt) uf.merge(n, n * n);\\n        }\\n        return uf.maxRank;\\n    }\\n};\\n```\n```cpp\\nstruct UF {\\n    int *parent, *rank, maxRank = -1,  maxRange = INT_MIN, sqrLmt;\\n    UF(vector<int> &nums) {\\n        // finding the highest value we will have to deal with and its square\\n        maxRange = *max_element(begin(nums), end(nums)) + 1;\\n        sqrLmt = sqrt(maxRange - 1);\\n        // sizing parent and rank accordingly and initialising parent\\n        parent = new int[maxRange], rank = new int[maxRange];\\n        // preparing parent\\n        fill(parent, parent + maxRange, 0);\\n    }\\n    int find(int node) {\\n        return parent[node] == node ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int node1, int node2) {\\n        // checking if they exist and looking for the root node of their clusters\\n        node1 = find(parent[node1]), node2 = find(parent[node2]);\\n        // exiting if either does not exist or if already merged\\n        if (!node1 || !node2 || node1 == node2) return;\\n        // actual union\\n        maxRank = max(maxRank, rank[node1] += rank[node2]);\\n        parent[node2] = node1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int> &nums) {\\n        // support variables\\n        UF uf = UF(nums);\\n        int sqrtN, sqrLmt = uf.sqrLmt;\\n        // parsing nums\\n        for (int n : nums) {\\n            // moving out if we already encountered n\\n            if (uf.parent[n]) continue;\\n            // setting every node to be its own parent with rank 1\\n            uf.parent[n] = n, uf.rank[n] = 1;\\n            // trying to merge n with its square root, if it exists\\n            sqrtN = sqrt(n);\\n            if (sqrtN * sqrtN == n) uf.merge(sqrtN, n);\\n            // trying to merge n with its square root, if in range\\n            if (n <= sqrLmt) uf.merge(n, n * n);\\n        }\\n        return uf.maxRank;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229161,
                "title": "longest-square-streak-in-an-array-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<double> st;\\n        for(auto x:nums)\\n        {\\n            st.insert(x);\\n        }\\n        int ans = 1;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            int curr = 1;\\n            double val = (double)nums[i];\\n            val = sqrt(val);\\n            while(st.count(val))\\n            {\\n                curr++;\\n                val = sqrt(val);\\n            }\\n            ans = max(ans,curr);\\n            \\n\\n        }\\n        return ans==1?-1:ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        unordered_set<double> st;\\n        for(auto x:nums)\\n        {\\n            st.insert(x);\\n        }\\n        int ans = 1;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            int curr = 1;\\n            double val = (double)nums[i];\\n            val = sqrt(val);\\n            while(st.count(val))\\n            {\\n                curr++;\\n                val = sqrt(val);\\n            }\\n            ans = max(ans,curr);\\n            \\n\\n        }\\n        return ans==1?-1:ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223743,
                "title": "c-set-and-iterate-from-smallest-number-up",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        set<long> s(nums.begin(), nums.end());\\n        int ans = -1;\\n        auto it = s.begin();\\n        while (it != s.end()){\\n            long cur = (*it) * (*it);\\n            int total = 1;\\n            while (cur < INT_MAX && s.find(cur) != s.end()){\\n                s.erase(cur);\\n                cur *= cur;\\n                ++total;\\n            }\\n            if (total > 1) ans = max(ans, total);\\n            ++it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        set<long> s(nums.begin(), nums.end());\\n        int ans = -1;\\n        auto it = s.begin();\\n        while (it != s.end()){\\n            long cur = (*it) * (*it);\\n            int total = 1;\\n            while (cur < INT_MAX && s.find(cur) != s.end()){\\n                s.erase(cur);\\n                cur *= cur;\\n                ++total;\\n            }\\n            if (total > 1) ans = max(ans, total);\\n            ++it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210970,
                "title": "c-simple-binary-search-no-dp-lower-bound",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNothing to think much. Just do as the question says. First sort the array then find the required subsequence.\\n\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            long long curr = nums[i];\\n            long long cnt = 1;\\n            while(true){\\n                int temp = lower_bound(nums.begin(), nums.end(), curr*curr)-nums.begin();\\n                if(temp<nums.size() && nums[temp] == curr*curr){\\n                    cnt++;\\n                    curr = curr*curr;\\n                }\\n                else    break;\\n            }\\n            ans = max(ans, cnt);\\n        }\\n\\n        if(ans == 1)\\n            return -1;\\n        else    return ans;\\n    }\\n};\\n```\\n\\n## If I was able to help you, Please upvote this post. It realy motivates me to post such posts",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        long long ans = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            long long curr = nums[i];\\n            long long cnt = 1;\\n            while(true){\\n                int temp = lower_bound(nums.begin(), nums.end(), curr*curr)-nums.begin();\\n                if(temp<nums.size() && nums[temp] == curr*curr){\\n                    cnt++;\\n                    curr = curr*curr;\\n                }\\n                else    break;\\n            }\\n            ans = max(ans, cnt);\\n        }\\n\\n        if(ans == 1)\\n            return -1;\\n        else    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207496,
                "title": "typescript-js-beats-100-136ms",
                "content": "\\nBeats 100% with ~130ms, can definitely be improved.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction longestSquareStreak(nums: number[]): number {\\n    let set = new Set(nums);\\n    let longeststreak = -1;\\n    set.forEach((e) => {\\n        let currnum = e * e;\\n        let newstreak = -1;\\n        while (true) {\\n            if (set.has(currnum)) {\\n                newstreak = newstreak === -1 ? 2 : newstreak + 1;\\n                currnum = currnum * currnum;\\n            } else {\\n                break;\\n            }\\n        }\\n        longeststreak = Math.max(longeststreak, newstreak)\\n    })\\n    return longeststreak;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction longestSquareStreak(nums: number[]): number {\\n    let set = new Set(nums);\\n    let longeststreak = -1;\\n    set.forEach((e) => {\\n        let currnum = e * e;\\n        let newstreak = -1;\\n        while (true) {\\n            if (set.has(currnum)) {\\n                newstreak = newstreak === -1 ? 2 : newstreak + 1;\\n                currnum = currnum * currnum;\\n            } else {\\n                break;\\n            }\\n        }\\n        longeststreak = Math.max(longeststreak, newstreak)\\n    })\\n    return longeststreak;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3193617,
                "title": "python-hashset-faster-than-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums=set(nums) #convert to set\\n        ans, temp=0,0 #default counts\\n        for i in nums: #iterate over nums\\n            while i * i in nums: #keep adding 1 to temporary count until square of i is present in set\\n                temp+=1 #update temp count\\n                i=i*i #update square\\n            ans=max(ans,temp) #take maximum of temp counts\\n            temp=0\\n        if ans==0: #if there is no subsequence of length >=2, return -1\\n            return -1 \\n        return ans+1 #ans = length of subsequence + 1(prev number included)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums=set(nums) #convert to set\\n        ans, temp=0,0 #default counts\\n        for i in nums: #iterate over nums\\n            while i * i in nums: #keep adding 1 to temporary count until square of i is present in set\\n                temp+=1 #update temp count\\n                i=i*i #update square\\n            ans=max(ans,temp) #take maximum of temp counts\\n            temp=0\\n        if ans==0: #if there is no subsequence of length >=2, return -1\\n            return -1 \\n        return ans+1 #ans = length of subsequence + 1(prev number included)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180253,
                "title": "python-dp-top-down-solution",
                "content": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums = sorted(nums,reverse = True)\\n        memo = dict()\\n        res = 1\\n        for num in nums:\\n            if num in memo: continue\\n            memo[num] = 1\\n            square = int(num*num)\\n            \\n            if square in memo:\\n                memo[num] = max(memo[num],memo[square] + 1)\\n                res = max(res,memo[num])\\n        \\n        if res == 1: res = -1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums = sorted(nums,reverse = True)\\n        memo = dict()\\n        res = 1\\n        for num in nums:\\n            if num in memo: continue\\n            memo[num] = 1\\n            square = int(num*num)\\n            \\n            if square in memo:\\n                memo[num] = max(memo[num],memo[square] + 1)\\n                res = max(res,memo[num])\\n        \\n        if res == 1: res = -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177740,
                "title": "elixir-use-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec longest_square_streak(nums :: [integer]) :: integer\\n  def longest_square_streak(nums) do\\n    longest_square_streak(Enum.sort(nums), Enum.reduce(nums, %{}, fn x, acc -> Map.update(acc, x, 0, &(&1 + 1)) end), 1)\\n  end\\n\\n  @spec longest_square_streak(nums :: [integer], map :: {integer, integer}, ans :: integer) :: integer\\n  def longest_square_streak([], _, ans) when ans == 1 do\\n    -1\\n  end\\n\\n  def longest_square_streak([], _, ans) do\\n    ans\\n  end\\n\\n  def longest_square_streak([head | tail], map, ans) do\\n    sqrt = trunc(:math.sqrt(head))\\n    if sqrt*sqrt == head do\\n      new_map = Map.put(map, head, Map.get(map, sqrt, 0) + 1)\\n      if Map.get(new_map, head) > ans do\\n        longest_square_streak(tail, new_map, Map.get(new_map, head))\\n      else\\n        longest_square_streak(tail, new_map, ans)\\n      end\\n    else\\n      new_map = Map.put(map, head, 1)\\n      longest_square_streak(tail, new_map, ans)\\n    end\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec longest_square_streak(nums :: [integer]) :: integer\\n  def longest_square_streak(nums) do\\n    longest_square_streak(Enum.sort(nums), Enum.reduce(nums, %{}, fn x, acc -> Map.update(acc, x, 0, &(&1 + 1)) end), 1)\\n  end\\n\\n  @spec longest_square_streak(nums :: [integer], map :: {integer, integer}, ans :: integer) :: integer\\n  def longest_square_streak([], _, ans) when ans == 1 do\\n    -1\\n  end\\n\\n  def longest_square_streak([], _, ans) do\\n    ans\\n  end\\n\\n  def longest_square_streak([head | tail], map, ans) do\\n    sqrt = trunc(:math.sqrt(head))\\n    if sqrt*sqrt == head do\\n      new_map = Map.put(map, head, Map.get(map, sqrt, 0) + 1)\\n      if Map.get(new_map, head) > ans do\\n        longest_square_streak(tail, new_map, Map.get(new_map, head))\\n      else\\n        longest_square_streak(tail, new_map, ans)\\n      end\\n    else\\n      new_map = Map.put(map, head, 1)\\n      longest_square_streak(tail, new_map, ans)\\n    end\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3157200,
                "title": "python-no-sorting-no-dp-only-set-o-m",
                "content": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums=set(nums)\\n        ans=-1\\n        for i in nums:\\n            if sqrt(i) not in nums:\\n                j=i*i\\n                curr=0\\n                while j in nums:\\n                    j=j*j\\n                    curr+=1\\n                if curr:\\n                    ans=max(ans,curr+1)\\n        return ans\\n```\\nTC: O(m), m= number of unique elements in nums \\n=>Searching in set is O(1) on average. Correct me if i am wrong !",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums=set(nums)\\n        ans=-1\\n        for i in nums:\\n            if sqrt(i) not in nums:\\n                j=i*i\\n                curr=0\\n                while j in nums:\\n                    j=j*j\\n                    curr+=1\\n                if curr:\\n                    ans=max(ans,curr+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156129,
                "title": "easy-solution-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        \\n        map<long long,long long>mp; int ans=0;\\n          for(auto e:nums)\\n          {\\n              mp[e]++;\\n          }\\n        for(auto e:mp)\\n        {\\n            long long  curr=e.first*e.first;\\n            \\n            int cnt=1;\\n            while(mp.find(curr)!=mp.end())\\n            {\\n                cnt++;\\n                curr=curr*curr;\\n            }\\n            ans=max(ans,cnt);\\n      \\n        }\\n  \\n            return ans>=2?ans:-1;\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        \\n        map<long long,long long>mp; int ans=0;\\n          for(auto e:nums)\\n          {\\n              mp[e]++;\\n          }\\n        for(auto e:mp)\\n        {\\n            long long  curr=e.first*e.first;\\n            \\n            int cnt=1;\\n            while(mp.find(curr)!=mp.end())\\n            {\\n                cnt++;\\n                curr=curr*curr;\\n            }\\n            ans=max(ans,cnt);\\n      \\n        }\\n  \\n            return ans>=2?ans:-1;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151479,
                "title": "beats-98-of-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSquareStreak = function(nums) {\\n    let set=new Set(nums) //to keep track of nums element\\n    let res=-1;\\n    for(let i=0;i<nums.length;i++){\\n        let square=nums[i]**2;\\n        let k=0; //to keep track of subsequece length;\\n        while(set.has(square)){\\n            k++;\\n            square=square**2;\\n        }\\n        if(k>0){\\n            k++;\\n            res=Math.max(res,k);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSquareStreak = function(nums) {\\n    let set=new Set(nums) //to keep track of nums element\\n    let res=-1;\\n    for(let i=0;i<nums.length;i++){\\n        let square=nums[i]**2;\\n        let k=0; //to keep track of subsequece length;\\n        while(set.has(square)){\\n            k++;\\n            square=square**2;\\n        }\\n        if(k>0){\\n            k++;\\n            res=Math.max(res,k);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3147708,
                "title": "c-golang-map",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        map<int, int> Map;\\n        for(int num: nums) {\\n            Map[num] = 1;\\n        }\\n        int ans = 1;\\n        for(auto &[num, _]: Map) {\\n            int sqrtNum = sqrt(num);\\n            if(sqrtNum * sqrtNum == num)\\n                Map[num] = Map[sqrtNum] + 1;\\n            ans = max(ans, Map[num]);\\n        }\\n        return ans == 1? -1: ans;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        map<int, int> Map;\\n        int ans = 1;\\n        for(int num: nums) {\\n            int sqrtNum = sqrt(num);\\n            if(sqrtNum * sqrtNum == num) {\\n                Map[num] = Map[sqrtNum] + 1;\\n                ans = max(ans, Map[num]);\\n            } else {\\n                Map[num] = 1;\\n            }\\n        }\\n        return ans == 1? -1: ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc longestSquareStreak(nums []int) int {\\n    sort.Ints(nums)\\n    var ans int = 1\\n    Map := make(map[int]int)\\n    for _, num := range nums {\\n        sqrtNum := int(math.Sqrt(float64(num)))\\n        if sqrtNum * sqrtNum == num {\\n            Map[num] = Map[sqrtNum] + 1\\n            if Map[num] > ans {\\n                ans = Map[num]\\n            }\\n        } else {\\n            Map[num] = 1\\n        }\\n    }\\n    if ans == 1 {return -1}\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        map<int, int> Map;\\n        for(int num: nums) {\\n            Map[num] = 1;\\n        }\\n        int ans = 1;\\n        for(auto &[num, _]: Map) {\\n            int sqrtNum = sqrt(num);\\n            if(sqrtNum * sqrtNum == num)\\n                Map[num] = Map[sqrtNum] + 1;\\n            ans = max(ans, Map[num]);\\n        }\\n        return ans == 1? -1: ans;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        map<int, int> Map;\\n        int ans = 1;\\n        for(int num: nums) {\\n            int sqrtNum = sqrt(num);\\n            if(sqrtNum * sqrtNum == num) {\\n                Map[num] = Map[sqrtNum] + 1;\\n                ans = max(ans, Map[num]);\\n            } else {\\n                Map[num] = 1;\\n            }\\n        }\\n        return ans == 1? -1: ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc longestSquareStreak(nums []int) int {\\n    sort.Ints(nums)\\n    var ans int = 1\\n    Map := make(map[int]int)\\n    for _, num := range nums {\\n        sqrtNum := int(math.Sqrt(float64(num)))\\n        if sqrtNum * sqrtNum == num {\\n            Map[num] = Map[sqrtNum] + 1\\n            if Map[num] > ans {\\n                ans = Map[num]\\n            }\\n        } else {\\n            Map[num] = 1\\n        }\\n    }\\n    if ans == 1 {return -1}\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146266,
                "title": "beats-90-of-soluting-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSquareStreak = function(nums) {\\n    let set=new Set(nums);\\n    let res=-1;\\n    for(let i=0;i<nums.length;i++){\\n        let square=nums[i]*nums[i];\\n        let k=0;\\n        while(set.has(square)){\\n            k++;\\n            square=square**2;\\n        }\\n        if(k>0){\\n            k++;\\n            res=Math.max(res,k);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSquareStreak = function(nums) {\\n    let set=new Set(nums);\\n    let res=-1;\\n    for(let i=0;i<nums.length;i++){\\n        let square=nums[i]*nums[i];\\n        let k=0;\\n        while(set.has(square)){\\n            k++;\\n            square=square**2;\\n        }\\n        if(k>0){\\n            k++;\\n            res=Math.max(res,k);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143315,
                "title": "c-dp-hashmap-solution-faster-than-60",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        // dp\\n        int result = -1;\\n        std::sort(nums.begin(),nums.end());\\n        std::vector<int>dp(nums.size(),1);\\n        std::unordered_map<float,int>pos_map;\\n        for(size_t i=0;i<nums.size();i++){\\n            float sqrt_num = std::sqrt(nums[i]);\\n            if(pos_map.find(sqrt_num)!=pos_map.end()){\\n                int pos = pos_map[sqrt_num];\\n                dp[i] = dp[pos] + 1;\\n            }\\n            if(dp[i]>1)\\n                result = std::max(result,dp[i]);\\n            pos_map[nums[i]] = i;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        // dp\\n        int result = -1;\\n        std::sort(nums.begin(),nums.end());\\n        std::vector<int>dp(nums.size(),1);\\n        std::unordered_map<float,int>pos_map;\\n        for(size_t i=0;i<nums.size();i++){\\n            float sqrt_num = std::sqrt(nums[i]);\\n            if(pos_map.find(sqrt_num)!=pos_map.end()){\\n                int pos = pos_map[sqrt_num];\\n                dp[i] = dp[pos] + 1;\\n            }\\n            if(dp[i]>1)\\n                result = std::max(result,dp[i]);\\n            pos_map[nums[i]] = i;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139681,
                "title": "java-beats-100-using-boolean-short-and-fast-easy-to-understand-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n100%\\n\\n- Space complexity:\\n100%\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        boolean[] map = new boolean[100001];\\n        int max = -1;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            map[nums[i]] = true;\\n        }\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            int count = 1, num = nums[i];\\n            while(num < 317 && map[num*num]){\\n                count++;\\n                num*=num;\\n            }\\n            if(count > 1 && count > max) max = count;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSquareStreak(int[] nums) {\\n        boolean[] map = new boolean[100001];\\n        int max = -1;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            map[nums[i]] = true;\\n        }\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            int count = 1, num = nums[i];\\n            while(num < 317 && map[num*num]){\\n                count++;\\n                num*=num;\\n            }\\n            if(count > 1 && count > max) max = count;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138451,
                "title": "longest-square-streak",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        res = -1\\n\\n        num_set, seen = set(nums), set()\\n        for n in num_set:\\n            # skip if n has been seen\\n            if n in seen:\\n                continue\\n            # try to expand the streak towards both directions\\n            cur_streak, l, r = set(), n, n\\n            while l in num_set:\\n                seen.add(l)\\n                cur_streak.add(l)\\n                l = sqrt(l)\\n            while r in num_set:\\n                seen.add(r)\\n                cur_streak.add(r)\\n                r = pow(r, 2)\\n            if len(cur_streak) > 1:\\n                res = max(res, len(cur_streak))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        res = -1\\n\\n        num_set, seen = set(nums), set()\\n        for n in num_set:\\n            # skip if n has been seen\\n            if n in seen:\\n                continue\\n            # try to expand the streak towards both directions\\n            cur_streak, l, r = set(), n, n\\n            while l in num_set:\\n                seen.add(l)\\n                cur_streak.add(l)\\n                l = sqrt(l)\\n            while r in num_set:\\n                seen.add(r)\\n                cur_streak.add(r)\\n                r = pow(r, 2)\\n            if len(cur_streak) > 1:\\n                res = max(res, len(cur_streak))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137411,
                "title": "dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef fun(a,dc,memo):\\n    if(a in memo):\\n        return memo[a]\\n    x=1\\n    if(dc[a**2]==1):\\n        x+=fun(a**2,dc,memo)\\n    memo[a]=x\\n    return x\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        dc=defaultdict(lambda:0)\\n        for a in nums:\\n            dc[a]=1\\n        vis=defaultdict(lambda:0)\\n        ans=1\\n        for a in nums:\\n            ans=max(ans,fun(a,dc,{}))\\n        if(ans==1):\\n            return -1\\n        return ans\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fun(a,dc,memo):\\n    if(a in memo):\\n        return memo[a]\\n    x=1\\n    if(dc[a**2]==1):\\n        x+=fun(a**2,dc,memo)\\n    memo[a]=x\\n    return x\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        dc=defaultdict(lambda:0)\\n        for a in nums:\\n            dc[a]=1\\n        vis=defaultdict(lambda:0)\\n        ans=1\\n        for a in nums:\\n            ans=max(ans,fun(a,dc,{}))\\n        if(ans==1):\\n            return -1\\n        return ans\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133437,
                "title": "php-fast-and-easy",
                "content": "\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function longestSquareStreak($nums) {\\n        $nums = array_unique($nums);\\n        sort($nums);\\n        $response = [];\\n        $longestStreak = -1;\\n        $elements = array_fill_keys($nums, true);\\n        for($i=0; $i<count($nums); $i++){\\n            // if(!in_array(pow($nums[$i], 2), $nums)) {\\n            //     continue;\\n            // }\\n            $next = $nums[$i];\\n            $currentStreak = 1;\\n            // while(in_array($power = pow($next, 2), $nums)) {\\n            $prev = pow($nums[$i], 2);\\n            while (isset($elements[$prev])) {\\n                $currentStreak++;\\n                $longestStreak = max($longestStreak, $currentStreak);\\n                // $nums = array_filter($nums, function ($x) use ($prev) { return $x > $prev; });\\n                // $next = $power;\\n                $prev = pow($prev, 2);\\n            }\\n        }\\n        return $longestStreak;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "class Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function longestSquareStreak($nums) {\\n        $nums = array_unique($nums);\\n        sort($nums);\\n        $response = [];\\n        $longestStreak = -1;\\n        $elements = array_fill_keys($nums, true);\\n        for($i=0; $i<count($nums); $i++){\\n            // if(!in_array(pow($nums[$i], 2), $nums)) {\\n            //     continue;\\n            // }",
                "codeTag": "Java"
            },
            {
                "id": 3126998,
                "title": "simple-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        int ans=0;\\n        map<ll,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[nums[i]]=i;\\n        }\\n        for(auto k:m)\\n        {\\n          ll i=k.second;\\n          ll a=nums[i];\\n          if(m.find(a*a)!= m.end())\\n          {\\n              int index=m[a*a];\\n              dp[i]+=1;\\n              dp[index]+=dp[i];\\n          }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=max(ans,dp[i]);\\n        }\\n        if(ans==0)\\n        {\\n            return -1;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        int ans=0;\\n        map<ll,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[nums[i]]=i;\\n        }\\n        for(auto k:m)\\n        {\\n          ll i=k.second;\\n          ll a=nums[i];\\n          if(m.find(a*a)!= m.end())\\n          {\\n              int index=m[a*a];\\n              dp[i]+=1;\\n              dp[index]+=dp[i];\\n          }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=max(ans,dp[i]);\\n        }\\n        if(ans==0)\\n        {\\n            return -1;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126997,
                "title": "simple-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        int ans=0;\\n        map<ll,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[nums[i]]=i;\\n        }\\n        for(auto k:m)\\n        {\\n          ll i=k.second;\\n          ll a=nums[i];\\n          if(m.find(a*a)!= m.end())\\n          {\\n              int index=m[a*a];\\n              dp[i]+=1;\\n              dp[index]+=dp[i];\\n          }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=max(ans,dp[i]);\\n        }\\n        if(ans==0)\\n        {\\n            return -1;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        int ans=0;\\n        map<ll,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[nums[i]]=i;\\n        }\\n        for(auto k:m)\\n        {\\n          ll i=k.second;\\n          ll a=nums[i];\\n          if(m.find(a*a)!= m.end())\\n          {\\n              int index=m[a*a];\\n              dp[i]+=1;\\n              dp[index]+=dp[i];\\n          }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=max(ans,dp[i]);\\n        }\\n        if(ans==0)\\n        {\\n            return -1;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117402,
                "title": "swift-solution-using-hashmap",
                "content": "# Approach\\n1. Use a map to store the frequency of each number.\\n2. Iterate through the array and for each number, we try to find the longest streak of square numbers starting from that number.\\n3. For each number, we keep multiplying it by itself until we reach a number that is not in the map. The number of multiplications is the length of the streak.\\n4. We keep track of the maximum streak length and return it at the end.\\n\\n# Complexity\\n> Time complexity: O(nlogn) where n is the length of the array. We iterate through the array and for each number, we keep multiplying it by itself until we reach a number that is not in the map. The number of multiplications is the length of the streak. Since we are multiplying by itself, the number of multiplications is logn. So the total time complexity is O(nlogn).\\n> Space complexity: O(n) where n is the length of the array. We use a map to store the frequency of each number. \\n\\n# Code\\n```\\nclass Solution {\\n    func longestSquareStreak(_ nums: [Int]) -> Int {\\n        var n = nums.count, maxLen = 0\\n        var map = [Int: Int]()\\n        for i in 0..<n {\\n            map[nums[i], default: 0] += 1\\n        }\\n        for i in 0..<n {\\n            var prev = nums[i]\\n            var count = 1\\n            while map[prev*prev] != nil {\\n                prev = prev*prev\\n                count += 1\\n            }\\n            maxLen = max(maxLen, count)\\n        }\\n        return maxLen==1 ? -1 : maxLen\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestSquareStreak(_ nums: [Int]) -> Int {\\n        var n = nums.count, maxLen = 0\\n        var map = [Int: Int]()\\n        for i in 0..<n {\\n            map[nums[i], default: 0] += 1\\n        }\\n        for i in 0..<n {\\n            var prev = nums[i]\\n            var count = 1\\n            while map[prev*prev] != nil {\\n                prev = prev*prev\\n                count += 1\\n            }\\n            maxLen = max(maxLen, count)\\n        }\\n        return maxLen==1 ? -1 : maxLen\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117224,
                "title": "c-hashmap-clean-and-short-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        map<float,float> p;\\n        for(auto i : nums)\\n        p[i]=1;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(p[nums[i]]==5)\\n            continue;\\n            float x=(float)sqrtf(nums[i]);\\n            if(p[x]>0)\\n               p[nums[i]]=1+p[sqrtf(nums[i])];\\n        }\\n        int a=0;\\n        for(auto i : p)\\n        {if(a<i.second)\\n        a=i.second;}\\n\\n        if(a<2)\\n        return -1;\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        map<float,float> p;\\n        for(auto i : nums)\\n        p[i]=1;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(p[nums[i]]==5)\\n            continue;\\n            float x=(float)sqrtf(nums[i]);\\n            if(p[x]>0)\\n               p[nums[i]]=1+p[sqrtf(nums[i])];\\n        }\\n        int a=0;\\n        for(auto i : p)\\n        {if(a<i.second)\\n        a=i.second;}\\n\\n        if(a<2)\\n        return -1;\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099074,
                "title": "clever-idea-to-save-memory-to-o-1",
                "content": "*The idea is simple just keep finding the square of current element till you can in sorted manner*\\n*And if the index is already visited don\\'t go to that. Reason explained below-*\\n```\\nif for example there exist 2,4,8 and 16 in any array and the array is sorted,\\nSo 2 will be encountered first then 4 then 8 and so on.\\nNow there is no menaing of choosing a subarray starting with 4 or 8 or 16 \\nbecause it will be smaller anyway.\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/XjKruKhX/shared\" frameBorder=\"0\" width=\"800\" height=\"450\"></iframe>",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif for example there exist 2,4,8 and 16 in any array and the array is sorted,\\nSo 2 will be encountered first then 4 then 8 and so on.\\nNow there is no menaing of choosing a subarray starting with 4 or 8 or 16 \\nbecause it will be smaller anyway.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3098643,
                "title": "c-solution-99-faster-o-n-time-complexity",
                "content": "# Approach\\n1. create a frequency array for nums\\n2. iterate over array nums\\n3. check if the frequency of square root of current value is greater then or equal to 1\\n4. if condition is true then call the find function for sqrt(curr) \\n5. else goto step2\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(max size)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int num, int*freq){\\n        int curr = sqrt(num);\\n        if(curr*curr==num and freq[curr]>0){\\n            return 1+find(curr,freq);\\n        }\\n        return 1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        int freq[100001]={0};\\n        for(auto i:nums)\\n            freq[i]++;\\n        int ans =-1,curr;\\n        for(auto i:nums){\\n            curr = sqrt(i);\\n            if(curr*curr==i and freq[curr]>0)\\n                ans = max(ans,1+find(curr,freq));\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int num, int*freq){\\n        int curr = sqrt(num);\\n        if(curr*curr==num and freq[curr]>0){\\n            return 1+find(curr,freq);\\n        }\\n        return 1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        int freq[100001]={0};\\n        for(auto i:nums)\\n            freq[i]++;\\n        int ans =-1,curr;\\n        for(auto i:nums){\\n            curr = sqrt(i);\\n            if(curr*curr==i and freq[curr]>0)\\n                ans = max(ans,1+find(curr,freq));\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093703,
                "title": "simple-js-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSquareStreak = function(nums) {\\n    let map = new Set(nums) \\n    let ans = -1\\n    for (let i = 0; i < nums.length; i++) {\\n        let s = nums[i] * nums[i]\\n        let k = 0\\n        while (map.has(s)) {\\n            k += 1\\n            s = s*s;\\n        }\\n        if(k>0){\\n            k += 1\\n            ans = Math.max(ans,k)\\n        }\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestSquareStreak = function(nums) {\\n    let map = new Set(nums) \\n    let ans = -1\\n    for (let i = 0; i < nums.length; i++) {\\n        let s = nums[i] * nums[i]\\n        let k = 0\\n        while (map.has(s)) {\\n            k += 1\\n            s = s*s;\\n        }\\n        if(k>0){\\n            k += 1\\n            ans = Math.max(ans,k)\\n        }\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3093494,
                "title": "python-o-n-set-solution",
                "content": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        res = -1\\n\\n        num_set, seen = set(nums), set()\\n        for n in num_set:\\n            # skip if n has been seen\\n            if n in seen:\\n                continue\\n            # try to expand the streak towards both directions\\n            cur_streak, l, r = set(), n, n\\n            while l in num_set:\\n                seen.add(l)\\n                cur_streak.add(l)\\n                l = sqrt(l)\\n            while r in num_set:\\n                seen.add(r)\\n                cur_streak.add(r)\\n                r = pow(r, 2)\\n            if len(cur_streak) > 1:\\n                res = max(res, len(cur_streak))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        res = -1\\n\\n        num_set, seen = set(nums), set()\\n        for n in num_set:\\n            # skip if n has been seen\\n            if n in seen:\\n                continue\\n            # try to expand the streak towards both directions\\n            cur_streak, l, r = set(), n, n\\n            while l in num_set:\\n                seen.add(l)\\n                cur_streak.add(l)\\n                l = sqrt(l)\\n            while r in num_set:\\n                seen.add(r)\\n                cur_streak.add(r)\\n                r = pow(r, 2)\\n            if len(cur_streak) > 1:\\n                res = max(res, len(cur_streak))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1718095,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1789520,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1716059,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 2000121,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1835142,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1831487,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1831482,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1722799,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1715965,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1714936,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1718095,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1789520,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1716059,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 2000121,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1835142,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1831487,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1831482,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1722799,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1715965,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            },
            {
                "id": 1714936,
                "content": [
                    {
                        "username": "ramm007",
                        "content": "I wrote a basic explanation to Solve this problem \ni.e basically create a HashSet and add all the values in to the set so that all the duplicates will be gone \nafter that iterate through the array and see if set contains (square of value) if contains increment the count by one and change the valve to (square of value) and check it again if the set contains it or not after each iteration check the max of count for previous and current iterations and Finally return the max of count;  \n for each iteration\nint num = arr[i];\nint count=1;\nwhile(set.contains(num*num)){\n                num=num*num;\n                count++;\n            }"
                    },
                    {
                        "username": "heg816",
                        "content": "Hints 2 and 3 are erroneously the same"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Share a weird but simple test case  `[18532,92682]`.\nIf you failed on this, it is probably because your int type variable OVERFLOW!!!\nWell, you'll just need to change all your variable type into long/Long and that will help you crack all the cases.\n\nSharing my Java code with the type casting trick:\n ```\nclass Solution {\n    public int longestSquareStreak(int[] nums) {\n        Set<Long> set = new HashSet<>();\n        for(int num : nums) set.add(num*1l);\n        int max = -1;\n        for(int num : nums) {\n            int len = 1;\n            while(set.contains(num*1l*num*1l)) {\n                len++;\n                num=num*num;\n                max = Math.max(max, len);\n            }\n        }\n        return max;\n    }\n}\n```"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You only have this problem if you go looking for the square of each number, instead, I went to  look for the root. Same procedure the other way around and you don\\'t have overflow."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "can someone help me. I am getting wa on Test case 87 dont know why\\n        unordered_set<long long> st(nums.begin(),nums.end());\\n        int mxlen=1;\\n        for( auto i: st){\\n            if(st.find(sqrt(i))==st.end()){\\n                long long x = pow(i,2);\\n                int len=1;\\n                while(st.find(x)!=st.end()){\\n                    mxlen=max(mxlen,++len);\\n                    x=pow(x,2);\\n                }\\n            }\\n        }\\n        return mxlen>=2?mxlen:-1;\\n    }\\n"
                    },
                    {
                        "username": "stacktrace28",
                        "content": " Hey, can anyone suggest to me how can I approach the problem if both negative and positive numbers are present in nums;"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "negative numbers won\\'t have squares so it\\'ll basically convert to the same question. "
                    },
                    {
                        "username": "sarthak_045",
                        "content": "test case 87 is so weird\\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "``` \\nclass Solution {\\npublic:\\n\\n    int bs(vector<int>& nums,int target){\\n        int start=0,end=nums.size()-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]<target){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n    int longestSquareStreak(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            if(s.size()==0){\\n                s.insert(nums[i]);\\n            }\\n               \\n               else{\\n                    if((int)sqrt(nums[i])*(int)sqrt(nums[i])==nums[i] && s.find(sqrt(nums[i]))!=s.end()){\\n                     int index=bs(nums,sqrt(nums[i]));\\n                    //  cout<<nums[i]<<\" \"<<index<<endl;\\n                     if(index!=-1){\\n                        dp[i]=dp[index]+1;\\n                     }\\n                   \\n                }\\n                s.insert(nums[i]);\\n               }\\n              \\n                \\n              \\n            \\n        }\\n\\n        int ans=-1;\\n     \\n       \\n\\n\\n        for(auto x:dp){\\n           if(x>1){\\n               ans=x;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nwhy my code giving wrong ans on test case 87/92"
                    },
                    {
                        "username": "ISHU999",
                        "content": "Getting TLE issue with this solution of O(N), what could be the challenge? Is it because of some inbuilt function I am using? \\n\\n```\\nimport math\\nclass Solution:\\n    def longestSquareStreak(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        covered = []\\n        hash_map = {}\\n        for x in nums:\\n            if x not in covered:\\n                covered.append(x)\\n                sqruare_root = sqrt(x)\\n                if sqruare_root * sqruare_root == x:\\n                    value = 1\\n                    if sqruare_root in nums:\\n                        if sqruare_root * sqruare_root in hash_map.keys():\\n                            value = hash_map[sqruare_root * sqruare_root]\\n                        else:\\n                            value = 1\\n                        hash_map[sqruare_root] = value + 1\\n                        if value > 4:\\n                            return value\\n        print(hash_map)\\n        if len(hash_map) > 0:\\n            count = max(hash_map.values())\\n        else:\\n            count = -1\\n        return count\\n```"
                    },
                    {
                        "username": "iDanyel",
                        "content": "covered is a list, so you don't have O(1) access time, try to use a set. Also, you firstly sort the elements, so it's not a O(n) solution."
                    },
                    {
                        "username": "snow_101010",
                        "content": "Can somebody help me with this, I don't know why my code is failing.\n\n\n\nint longestSquareStreak(vector<int>& nums) {\n        int n = nums.size();\n        \n        unordered_map<int, int> map;\n        \n        for(int i=0;i<n;++i) map[nums[i]] = 1;\n        \n        int ans = -1;\n        \n        for(auto it = map.begin();it != map.end();++it){\n            long long int temp = it->first;\n            int count = 0;\n            \n            int s = sqrt(temp);\n            \n            if(map.find(s) == map.end()){\n                while(map.find(temp) != map.end()){\n                    count++;\n                    if(temp*temp > INT_MAX) break;\n                    temp = temp*temp;\n                }\n                \n                if(count >= 2) {\n                    ans = max(ans, count); \n                }\n            }\n        }\n        \n        return ans;\n    }"
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng) can you please tell me if there\\'s something wrong with the logic that I\\'m using? "
                    },
                    {
                        "username": "snow_101010",
                        "content": "[@zjingfeng](/zjingfeng)  Firstly thanks for your reply, after I type casted it, it is still giving a wrong answer in one of the cases instead of integer overflow.\\n"
                    },
                    {
                        "username": "zjingfeng",
                        "content": "[18532,92682] try this, and take a look at my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    },
                    {
                        "username": "user3591Bz",
                        "content": " I wrote a pretty basic binary search solution. Could someone explain why this fails on testcase 87. Passes 86/87 of the rest.\n```class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int m = 1, n = nums.size();\n        int arr[n]; for(int i=0; i<n; i++) arr[i] = 1;\n        arr[0] = 1;\n        for(int i=0; i<n; i++)\n        {\n            int l = lower_bound(nums.begin(), nums.end(), (long long)nums[i]*nums[i]) - nums.begin();\n            if(l<n && (long long)nums[l] == (long long)nums[i]*nums[i])\n            {\n                arr[l] = arr[i] + 1;\n            }\n            m = max(m, arr[i]);\n        }\n        if(m==1) m = -1;\n        return m;\n    }\n}; ```\n"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "[@user3591Bz](/user3591Bz) same here written binary search but getting  WA on TC 87\nmy output =2\nexpected output=3"
                    },
                    {
                        "username": "user3591Bz",
                        "content": "[@zjingfeng](/zjingfeng) Hm, no [18532,92682] passes on my code and I changed every int to longlong but 87th is still failing :("
                    },
                    {
                        "username": "zjingfeng",
                        "content": "Try this [18532, 92682] and you\\'ll find out, here is my answer https://leetcode.com/problems/longest-square-streak-in-an-array/discussion/comments/1716059"
                    }
                ]
            }
        ]
    }
]