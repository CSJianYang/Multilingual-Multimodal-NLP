[
    {
        "title": "Set Matrix Zeroes",
        "question_content": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.\n&nbsp;\nExample 1:\n\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n\nExample 2:\n\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n&nbsp;\nConstraints:\n\n\tm == matrix.length\n\tn == matrix[0].length\n\t1 <= m, n <= 200\n\t-231 <= matrix[i][j] <= 231 - 1\n\n&nbsp;\nFollow up:\n\n\tA straightforward solution using O(mn) space is probably a bad idea.\n\tA simple improvement uses O(m + n) space, but still not the best solution.\n\tCould you devise a constant space solution?",
        "solutions": [
            {
                "id": 26014,
                "title": "any-shorter-o-1-space-solution",
                "content": "My idea is simple: store states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable \"col0\" for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way.\\n\\n    void setZeroes(vector<vector<int> > &matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n    \\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) col0 = 0;\\n            for (int j = 1; j < cols; j++)\\n                if (matrix[i][j] == 0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n    \\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "My idea is simple: store states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable \"col0\" for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way.\\n\\n    void setZeroes(vector<vector<int> > &matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n    \\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) col0 = 0;\\n            for (int j = 1; j < cols; j++)\\n                if (matrix[i][j] == 0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n    \\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26008,
                "title": "my-ac-java-o-1-solution-easy-to-read",
                "content": "    public class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean fr = false,fc = false;\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                if(matrix[i][j] == 0) {\\n                    if(i == 0) fr = true;\\n                    if(j == 0) fc = true;\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 1; i < matrix.length; i++) {\\n            for(int j = 1; j < matrix[0].length; j++) {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(fr) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                matrix[0][j] = 0;\\n            }\\n        }\\n        if(fc) {\\n            for(int i = 0; i < matrix.length; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean fr = false,fc = false;\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                if(matrix[i][j] == 0) {\\n                    if(i == 0) fr = true;\\n                    if(j == 0) fc = true;\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3172908,
                "title": "best-c-4-solution-hash-table-matrix-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Four approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Matrix with Extra space.  TC : O((N*M)*(N+M)),  SC : O(N*M).\\n2. Solved using Matrix with Constant space.  TC : O((N*M)*(N+M)),  SC : O(1).\\n3. Solved using Array + Hash Table (Unordered set).  TC : O(N*M),  SC : O(N+M).\\n4. Solved using Matrix with Constant space.  Optimized Approaches.  TC : O(N*M),  SC : O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M) for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(N*M), visited matrix space.\\n\\n    Solved using Matrix with Extra space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> visited = matrix;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        visited[i][k] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        visited[k][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = visited[i][j];\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M)for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        if(matrix[i][k] != 0){\\n                            matrix[i][k] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        if(matrix[k][j] != 0){\\n                            matrix[k][j] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == -9999){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(N+M), Here Unordered set(setRows and setColumn) creates the space complexity. O(N) for\\n    storing the row indexs and O(M) for storing the column indexs.\\n\\n    Solved using Matrix + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        unordered_set<int> setRows; \\n        unordered_set<int> setColumns; \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    setRows.insert(i);\\n                    setColumns.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(setRows.count(i) > 0 || setColumns.count(j) > 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        bool flag1 = false, flag2 = false;\\n        for(int i=0; i<n; i++){\\n            if(matrix[i][0] == 0){\\n                flag1 = true;\\n            }\\n        }\\n        for(int j=0; j<m; j++){\\n            if(matrix[0][j] == 0){\\n                flag2 = true;\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(flag1 == true){\\n            for(int i=0; i<n; i++){\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        if(flag2 == true){\\n            for(int j=0; j<m; j++){\\n                matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n};\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M) for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(N*M), visited matrix space.\\n\\n    Solved using Matrix with Extra space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> visited = matrix;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        visited[i][k] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        visited[k][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = visited[i][j];\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M)for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        if(matrix[i][k] != 0){\\n                            matrix[i][k] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        if(matrix[k][j] != 0){\\n                            matrix[k][j] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == -9999){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(N+M), Here Unordered set(setRows and setColumn) creates the space complexity. O(N) for\\n    storing the row indexs and O(M) for storing the column indexs.\\n\\n    Solved using Matrix + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        unordered_set<int> setRows; \\n        unordered_set<int> setColumns; \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    setRows.insert(i);\\n                    setColumns.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(setRows.count(i) > 0 || setColumns.count(j) > 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        bool flag1 = false, flag2 = false;\\n        for(int i=0; i<n; i++){\\n            if(matrix[i][0] == 0){\\n                flag1 = true;\\n            }\\n        }\\n        for(int j=0; j<m; j++){\\n            if(matrix[0][j] == 0){\\n                flag2 = true;\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(flag1 == true){\\n            for(int i=0; i<n; i++){\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        if(flag2 == true){\\n            for(int j=0; j<m; j++){\\n                matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525398,
                "title": "all-approaches-from-brute-force-to-optimal-with-easy-explanation",
                "content": "**Method 1:** (Brute force)\\n-using another matrix (let\\'s say it matrix2)\\n1. we can copy all the elements of given matrix to matrix2\\n2. while traversing given matrix whenever we encounter 0, we will make the entire row and column of the matrix2 to 0\\n3. finally we can again copy all the elements of matrix2 to given matrix\\n-**Time:** $$O((mn)*(m+n))$$, **Space:** $$O(mn)$$\\n\\n![image](https://assets.leetcode.com/users/images/edb17693-61dd-424b-88e7-f37b79c602f1_1662224098.764936.png)\\n\\n\\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m= matrix.length, n= matrix[0].length;\\n        int matrix2[][]= new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix2[i][j]=matrix[i][j];\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    for(int k=0;k<n;k++)\\n                        matrix2[i][k]=0;\\n\\n                    for(int k=0;k<m;k++)\\n                        matrix2[k][j]=0;\\n                }\\n            }\\n        }\\n    \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix[i][j]=matrix2[i][j];\\n        }\\n    }\\n```\\n\\n\\n**Method 2:** (Better)\\n1. we can use two separate arrays one for rows (rowsArray) and one for columns (colsArray) and initialize them to 1\\n2. while traversing the given matrix whenever we encounter 0 at (i,j), we will set rowsArray[i]=0 and colsArray[j]=0\\n3. After completion of step 2, again iterate through the matrix and for any (i,j), if rowsArray[i] or colsArray[j] is 0 then update matrix[i][j] to 0.\\n-**Time:** $$O(mn)$$, **Space:** $$O(m+n)$$\\n\\n![image](https://assets.leetcode.com/users/images/985c05ee-ba5b-43ec-a7c2-41983d8bdae1_1662224319.5420349.png)\\n\\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        int rowsArray[]= new int[m];\\n        int colsArray[]= new int[n];\\n        \\n        Arrays.fill(rowsArray,1);\\n        Arrays.fill(colsArray,1);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    rowsArray[i]=0;\\n                    colsArray[j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(rowsArray[i]==0 || colsArray[j]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n    }\\n```\\n\\n**Method 3:** (Optimal)\\n-we can use the 0th row and 0th column of the given matrix itself instead of using two separate arrays\\n1. first we will traverse the 0th row and 0th column of the given matrix and if we encounter any 0 then we will set the isRow0/isCol0 variable to true which indicates that the 0th row/0th column of the given matrix will become 0\\n2. next we will traverse the remaining matrix except 0th row and 0th column and if we encounter any 0, we will make the corresponding row no. and column no. equal to 0 in the 0th column and 0th row respectively\\n3. Now we will update the values of the matrix except first row and first column to 0 if matrix[i][0]=0 or matrix[0][j]=0 for any (i,j).\\n4. finally we will traverse the 0th row and 0th column and if we find any 0, we will make the whole row and whole column equal to 0\\n-**Time:** $$O(mn)$$, **Space:** $$O(1)$$\\n\\n![image](https://assets.leetcode.com/users/images/75193089-d14a-4cf9-aacf-5f97cc935f02_1662224420.9994516.png)\\n\\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        boolean isRow0=false, isCol0=false;\\n        \\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0)\\n                isRow0=true;\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0)\\n                isCol0=true;\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[0][j]==0 || matrix[i][0]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n        if(isRow0){\\n            for(int j=0;j<n;j++)\\n                matrix[0][j]=0;\\n        }\\n        \\n        if(isCol0){\\n            for(int i=0;i<m;i++)\\n                matrix[i][0]=0;\\n        }\\n    }\\n```\\n\\nDon\\'t forget to upvote if you find it helpful! \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m= matrix.length, n= matrix[0].length;\\n        int matrix2[][]= new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix2[i][j]=matrix[i][j];\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    for(int k=0;k<n;k++)\\n                        matrix2[i][k]=0;\\n\\n                    for(int k=0;k<m;k++)\\n                        matrix2[k][j]=0;\\n                }\\n            }\\n        }\\n    \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix[i][j]=matrix2[i][j];\\n        }\\n    }\\n```\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        int rowsArray[]= new int[m];\\n        int colsArray[]= new int[n];\\n        \\n        Arrays.fill(rowsArray,1);\\n        Arrays.fill(colsArray,1);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    rowsArray[i]=0;\\n                    colsArray[j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(rowsArray[i]==0 || colsArray[j]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n    }\\n```\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        boolean isRow0=false, isCol0=false;\\n        \\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0)\\n                isRow0=true;\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0)\\n                isCol0=true;\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[0][j]==0 || matrix[i][0]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n        if(isRow0){\\n            for(int j=0;j<n;j++)\\n                matrix[0][j]=0;\\n        }\\n        \\n        if(isCol0){\\n            for(int i=0;i<m;i++)\\n                matrix[i][0]=0;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3472518,
                "title": "full-explanation-super-easy-constant-space",
                "content": "# Intuition\\nIn this approach, we can just improve the space complexity. So, instead of using two extra matrices row and col, we will use the 1st row and 1st column of the given matrix to keep a track of the cells that need to be marked with 0. But here comes a problem. If we try to use the 1st row and 1st column to serve the purpose, the cell matrix[0][0] is taken twice. To solve this problem we will take an extra variable col0 initialized with 1. Now the entire 1st row of the matrix will serve the purpose of the row array. And the 1st column from (0,1) to (0,m-1) with the col0 variable will serve the purpose of the col array\\n\\n![image.png](https://assets.leetcode.com/users/images/5e4c94b5-ea1e-4ca5-a166-9a014d49e001_1682924194.5173662.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe steps are as follows:\\n\\nFirst, we will traverse the matrix and mark the proper cells of 1st row and 1st column with 0 accordingly. The marking will be like this: if cell(i, j) contains 0, we will mark the i-th row i.e. matrix[i][0] with 0 and we will mark j-th column i.e. matrix[0][j] with 0.\\nIf i is 0, we will mark matrix[0][0] with 0 but if j is 0, we will mark the col0 variable with 0 instead of marking matrix[0][0] again.\\n\\nAfter step 1 is completed, we will modify the cells from (1,1) to (n-1, m-1) using the values from the 1st row, 1st column, and col0 variable.\\n\\nWe will not modify the 1st row and 1st column of the matrix here as the modification of the rest of the matrix(i.e. From (1,1) to (n-1, m-1)) is dependent on that row and column.\\n\\nFinally, we will change the 1st row and column using the values from matrix[0][0] and col0 variable. Here also we will change the row first and then the column.\\n\\nIf matrix[0][0] = 0, we will change all the elements from the cell (0,1) to (0, m-1), to 0.\\nIf col0 = 0, we will change all the elements from the cell (0,0) to (n-1, 0), to 0. Note that the above approach is provided by Striver on youtube.\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/e3a4d44d-7ade-4acb-8e2e-6cdc257505f3_1682924171.8253722.png)\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\npublic void setZeroes(int[][] matrix) {\\n    boolean fr = false,fc = false;\\n    for(int i = 0; i < matrix.length; i++) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            if(matrix[i][j] == 0) {\\n                if(i == 0) fr = true;\\n                if(j == 0) fc = true;\\n                matrix[0][j] = 0;\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n    for(int i = 1; i < matrix.length; i++) {\\n        for(int j = 1; j < matrix[0].length; j++) {\\n            if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                matrix[i][j] = 0;\\n        }}\\n    }\\n    if(fr) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if(fc) {\\n        for(int i = 0; i < matrix.length; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n}}  \\n\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/43fc6382-7684-43ad-91e9-cea1908663b6_1682924250.7315671.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\npublic void setZeroes(int[][] matrix) {\\n    boolean fr = false,fc = false;\\n    for(int i = 0; i < matrix.length; i++) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            if(matrix[i][j] == 0) {\\n                if(i == 0) fr = true;\\n                if(j == 0) fc = true;\\n                matrix[0][j] = 0;\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n    for(int i = 1; i < matrix.length; i++) {\\n        for(int j = 1; j < matrix[0].length; j++) {\\n            if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                matrix[i][j] = 0;\\n        }}\\n    }\\n    if(fr) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if(fc) {\\n        for(int i = 0; i < matrix.length; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n}}  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657430,
                "title": "python-solution-w-approach-explanation-readable-with-space-progression-from-o-m-n-o-1",
                "content": "Note: m = number of rows, n = number of cols\\n\\n**Brute force using O(m*n) space:** The initial approach is to start with creating another matrix to store the result. From doing that, you\\'ll notice that we want a way to know when each row and col should be changed to zero. We don\\'t want to prematurely change the values in the matrix to zero because as we go through it, we might change a row to 0 because of the new value. \\n\\n**More optimized using O(m + n) space:** To do better, we want O(m + n). How do we go about that? Well, we really just need a way to track if any row or any col has a zero, because then that means the entire row or col has to be zero. Ok, well, then we can use an array to track the zeroes for the row and zeros for the col. Whenever we see a zero, just set that row or col to be True.\\n\\nSpace: O(m + n) for the zeroes_row and zeroes_col array \\n``` Python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        # input validation\\n        if not matrix:\\n            return []\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n         zeroes_row = [False] * m\\n         zeroes_col = [False] * n\\n         for row in range(m):\\n             for col in range(n):\\n                 if matrix[row][col] == 0:\\n                     zeroes_row[row] = True\\n                     zeroes_col[col] = True\\n\\n         for row in range(m):\\n             for col in range(n):\\n                 if zeroes_row[row] or zeroes_col[col]:\\n                     matrix[row][col] = 0\\n```\\n\\n**Most optimized using O(1) space:** But, we can do even better, O(1) - initial ask of the problem. What if instead of having a separate array to track the zeroes, we simply use the first row or col to track them and then go back to update the first row and col with zeroes after we\\'re done replacing it? The approach to get constant space is to use first row and first col of the matrix as a tracker. \\n* At each row or col, if you see a zero, then mark the first row or first col as zero with the current row and col. \\n* Then iterate through the array again to see where the first row and col were marked as zero and then set that row/col as 0. \\n* After doing that, you\\'ll need to traverse through the first row and/or first col if there were any zeroes there to begin with and set everything to be equal to 0 in the first row and/or first col. \\n\\nTime complexity for all three progression is O(m * n).\\n\\n\\n\\n**Space:** O(1) for modification in place and using the first row and first col to keep track of zeros instead of zeroes_row and zeroes_col\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\t\\t\\n        first_row_has_zero = False\\n        first_col_has_zero = False\\n        \\n        # iterate through matrix to mark the zero row and cols\\n        for row in range(m):\\n            for col in range(n):\\n                if matrix[row][col] == 0:\\n                    if row == 0:\\n                        first_row_has_zero = True\\n                    if col == 0:\\n                        first_col_has_zero = True\\n                    matrix[row][0] = matrix[0][col] = 0\\n    \\n        # iterate through matrix to update the cell to be zero if it\\'s in a zero row or col\\n        for row in range(1, m):\\n            for col in range(1, n):\\n                matrix[row][col] = 0 if matrix[0][col] == 0 or matrix[row][0] == 0 else matrix[row][col]\\n        \\n        # update the first row and col if they\\'re zero\\n        if first_row_has_zero:\\n            for col in range(n):\\n                matrix[0][col] = 0\\n        \\n        if first_col_has_zero:\\n            for row in range(m):\\n                matrix[row][0] = 0\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` Python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        # input validation\\n        if not matrix:\\n            return []\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n         zeroes_row = [False] * m\\n         zeroes_col = [False] * n\\n         for row in range(m):\\n             for col in range(n):\\n                 if matrix[row][col] == 0:\\n                     zeroes_row[row] = True\\n                     zeroes_col[col] = True\\n\\n         for row in range(m):\\n             for col in range(n):\\n                 if zeroes_row[row] or zeroes_col[col]:\\n                     matrix[row][col] = 0\\n```\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\t\\t\\n        first_row_has_zero = False\\n        first_col_has_zero = False\\n        \\n        # iterate through matrix to mark the zero row and cols\\n        for row in range(m):\\n            for col in range(n):\\n                if matrix[row][col] == 0:\\n                    if row == 0:\\n                        first_row_has_zero = True\\n                    if col == 0:\\n                        first_col_has_zero = True\\n                    matrix[row][0] = matrix[0][col] = 0\\n    \\n        # iterate through matrix to update the cell to be zero if it\\'s in a zero row or col\\n        for row in range(1, m):\\n            for col in range(1, n):\\n                matrix[row][col] = 0 if matrix[0][col] == 0 or matrix[row][0] == 0 else matrix[row][col]\\n        \\n        # update the first row and col if they\\'re zero\\n        if first_row_has_zero:\\n            for col in range(n):\\n                matrix[0][col] = 0\\n        \\n        if first_col_has_zero:\\n            for row in range(m):\\n                matrix[row][0] = 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 26113,
                "title": "21-lines-concise-and-easy-understand-c-solution-o-1-space-three-steps",
                "content": "    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            bool row = false, col = false;\\n            for(int i = 0; i < matrix.size(); i++){\\n                for(int j = 0; j < matrix[0].size(); j++){\\n                    if(matrix[i][j] == 0) {\\n                        if(i == 0) row = true;\\n                        if(j == 0) col = true;\\n                        matrix[0][j] = matrix[i][0] = 0;\\n                    }\\n                }\\n            }\\n            for(int i = 1; i < matrix.size(); i++){\\n                for(int j = 1; j < matrix[0].size(); j++){\\n                    if(matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;\\n                }\\n            }\\n            if(col){\\n                for(int i = 0; i < matrix.size(); i++) matrix[i][0] = 0;\\n            }\\n            if(row){\\n                for(int j = 0; j < matrix[0].size(); j++) matrix[0][j] = 0;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            bool row = false, col = false;\\n            for(int i = 0; i < matrix.size(); i++){\\n                for(int j = 0; j < matrix[0].size(); j++){\\n                    if(matrix[i][j] == 0) {\\n                        if(i == 0) row = true;\\n                        if(j == 0) col = true;\\n                        matrix[0][j] = matrix[i][0] = 0;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1400849,
                "title": "set-matrix-zeroes-2-approach-w-explanation-c-python-java",
                "content": "**OBSERVATION:**\\nThe time complexity of this problem remains `O(M*N)`, the only improvement we can do is of the space complexity. So we will have 2 approaches here\\n\\n# **APPROACH I:**\\n*Additional Memory Approach-*\\nIf any cell of the matrix has a zero we can record its row and column number. All the cells of this recorded row and column can be marked zero in the next iteration.\\n\\n**Algorithm**\\n* We iterate over the original array and look for zero entries.\\n* If we find that an entry at `[i, j]` is `0`, then we need to record somewhere the row `i` and column `j`.\\n* So, we use two sets, one for the rows and one for the columns.\\n```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\\n*  We iterate over the array once again, and check each cell.\\n\\t*  If the row **Or** column is marked, we set the value of the cell as 0.\\n\\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(M+N)**\\n\\n# **APPROACH II**\\nWe handle cases seperately. \\n* Check the first row and column for pre-existing `0`. \\n\\t* If found we mark that row or column as true\\n* Now we work upon the remaining matrix.\\n\\t* First we look for the cell that has `0` in it.\\n\\t* Then proceed with the working i.e. marking the cell as 0. \\n*  Now work upon the checked first row and column and update their values.\\n\\t*  Note: Updating before hand gives WA\\n \\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(1)**",
                "solutionTags": [],
                "code": "```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276330,
                "title": "c-simple-99-faster-o-1-space-upvote",
                "content": "```\\n    void setZeroes(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        bool firstRow = false;  // do we need to set first row zero\\n        bool firstCol = false;  // do we need to ser first col zero\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n\\t\\t\\t\\t\\tif(a[i][j] == 0){   // store rows and cols state in first row and col\\n                    if(i==0) firstRow = true;\\n                    if(j==0) firstCol = true;\\n                    a[i][0] = 0;\\n                    a[0][j] = 0;\\n                }\\n            }\\n        }\\n        // cout<<firstRow<<\" \"<<firstCol<<endl;\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(a[i][0] == 0 || a[0][j] == 0){\\n                    a[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(firstRow){\\n            for(int i=0;i<m;i++) a[0][i] = 0;\\n        }\\n        \\n        if(firstCol){\\n            for(int i=0;i<n;i++) a[i][0] = 0;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    void setZeroes(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        bool firstRow = false;  // do we need to set first row zero\\n        bool firstCol = false;  // do we need to ser first col zero\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n\\t\\t\\t\\t\\tif(a[i][j] == 0){   // store rows and cols state in first row and col\\n                    if(i==0) firstRow = true;\\n                    if(j==0) firstCol = true;\\n                    a[i][0] = 0;\\n                    a[0][j] = 0;\\n                }\\n            }\\n        }\\n        // cout<<firstRow<<\" \"<<firstCol<<endl;\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(a[i][0] == 0 || a[0][j] == 0){\\n                    a[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(firstRow){\\n            for(int i=0;i<m;i++) a[0][i] = 0;\\n        }\\n        \\n        if(firstCol){\\n            for(int i=0;i<n;i++) a[i][0] = 0;\\n        }\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 717535,
                "title": "cpp-c-99-23-google-amazon",
                "content": "Approach-First of all create two vectors rowmarker and columnmarker to store the positions of column and row where the element is zero. \\nIf element in either row marker or columnmarker is 0.Then make the element in the whole matrix 0. \\n```\\n void setZeroes(vector<vector<int>>& matrix) {     \\n        int rowsize=matrix.size(); \\n        int columnsize=matrix[0].size(); \\n        vector<int>rowmarker(rowsize,1);\\n        vector<int>columnmarker(columnsize,1); \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    rowmarker[i]=0; \\n                    columnmarker[j]=0;\\n                }\\n            }\\n        } \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(rowmarker[i]==0 or columnmarker[j]==0)\\n                    matrix[i][j]=0;\\n             }\\n        }\\n        \\n    }\\n\\t```\\n\\t Please Upvote if you like my solution.Jai Hind.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n void setZeroes(vector<vector<int>>& matrix) {     \\n        int rowsize=matrix.size(); \\n        int columnsize=matrix[0].size(); \\n        vector<int>rowmarker(rowsize,1);\\n        vector<int>columnmarker(columnsize,1); \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    rowmarker[i]=0; \\n                    columnmarker[j]=0;\\n                }\\n            }\\n        } \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(rowmarker[i]==0 or columnmarker[j]==0)\\n                    matrix[i][j]=0;\\n             }\\n        }\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 26038,
                "title": "my-c-o-1-yoooooo",
                "content": "I find the last row which has 0, and use it to store the 0-collumns.\\nThen go row by row set them to 0.\\nThen go column by column set them to 0.\\nFinally set the last row which has 0. It's long but hey it's O(1) \\n\\n\\n    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int> > &matrix) {\\n            \\n            int H = matrix.size();\\n            int W = matrix[0].size();\\n            \\n            // find the last 0 row\\n            int last_0_row = -1;\\n            for (int y = H - 1; y >= 0 && last_0_row == -1; y--)\\n                for (int x = 0; x < W; x++)\\n                    if (matrix[y][x] == 0)\\n                    {\\n                        last_0_row = y;\\n                        break;\\n                    }\\n            if (last_0_row == -1)\\n                return;\\n            \\n            // go row by row\\n            for (int y = 0; y < last_0_row; y++)\\n            {\\n                bool this_is_a_0_row = false;\\n                \\n                for (int x = 0; x < W; x++)\\n                {\\n                    if (matrix[y][x] == 0)\\n                    {\\n                        this_is_a_0_row = true;\\n                        matrix[last_0_row][x] = 0;\\n                    }\\n                }\\n                \\n                if (this_is_a_0_row)\\n                for (int x = 0; x < W; x++)\\n                {\\n                    matrix[y][x] = 0;\\n                }\\n            }\\n            \\n            // set collums to 0\\n            for (int y = 0; y < H; y++)\\n            for (int x = 0; x < W; x++)\\n            {\\n                if (matrix[last_0_row][x] == 0)\\n                    matrix[y][x] = 0;\\n            }\\n            \\n            // set the last 0 row \\n            for (int x = 0; x < W; x++)\\n            {\\n                matrix[last_0_row][x] = 0;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int> > &matrix) {\\n            \\n            int H = matrix.size();\\n            int W = matrix[0].size();\\n            \\n            // find the last 0 row\\n            int last_0_row = -1;\\n            for (int y = H - 1; y >= 0 && last_0_row == -1; y--)\\n                for (int x = 0; x < W; x++)\\n                    if (matrix[y][x] == 0)\\n                    {\\n                        last_0_row = y;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 26026,
                "title": "o-1-space-solution-in-python",
                "content": "    class Solution:\\n    # @param {integer[][]} matrix\\n    # @return {void} Do not return anything, modify matrix in-place instead.\\n    def setZeroes(self, matrix):\\n        m = len(matrix)\\n        if m == 0:\\n            return\\n        n = len(matrix[0])\\n        \\n        row_zero = False\\n        for i in range(m):\\n            if matrix[i][0] == 0:\\n                row_zero = True\\n        col_zero = False\\n        for j in range(n):\\n            if matrix[0][j] == 0:\\n                col_zero = True\\n                \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = 0\\n                    matrix[0][j] = 0\\n        \\n        for i in range(1, m):\\n            if matrix[i][0] == 0:\\n                for j in range(1, n):\\n                    matrix[i][j] = 0\\n                    \\n        for j in range(1, n):\\n            if matrix[0][j] == 0:\\n                for i in range(1, m):\\n                    matrix[i][j] = 0\\n        \\n        if col_zero:\\n            for j in range(n):\\n                matrix[0][j] = 0\\n        if row_zero:\\n            for i in range(m):\\n                matrix[i][0] = 0",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {integer[][]}",
                "codeTag": "Java"
            },
            {
                "id": 1400861,
                "title": "python-o-mn-o-1-time-space-solution-explained",
                "content": "The idea is to use first row and first column as indicator, if we need to set the whole corresponding column or row to zeros. We also keep `r1 and `c1` variables: do we need to update first column and/or first row in the end. So, we have the following steps:\\n\\n1. Create `r1` and `c1`.\\n2. Iterate through our matrix and if we see that for if element `M[i][j]` is equal to `0`, we put both elements `M[i][0]` and `M[0][j]` to `0`.\\n3. Now, we updated all elements in first row and column, so we iterate our matrix once again: and if we see that one of elements `M[i][0]` or `M[0][j]` equal to `0`, we make `M[i][j] equal to `0`.\\n4. Finally, we need to update first row and column, so we make them `0`, if we have indicator `r1` for row and `c1` for column.\\n\\n#### Complexity\\nTime complexity is `O(mn)`, space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def setZeroes(self, M):\\n        m, n = len(M[0]), len(M)\\n        r1 = any(M[0][j] == 0 for j in range(m))\\n        c1 = any(M[i][0] == 0 for i in range(n))\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][j] == 0: M[i][0] = M[0][j] = 0\\n                \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][0] * M[0][j] == 0: M[i][j] = 0\\n                \\n        if r1:\\n            for i in range(m): M[0][i] = 0\\n                \\n        if c1:\\n            for j in range(n): M[j][0] = 0\\n```\\n\\t\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def setZeroes(self, M):\\n        m, n = len(M[0]), len(M)\\n        r1 = any(M[0][j] == 0 for j in range(m))\\n        c1 = any(M[i][0] == 0 for i in range(n))\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][j] == 0: M[i][0] = M[0][j] = 0\\n                \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][0] * M[0][j] == 0: M[i][j] = 0\\n                \\n        if r1:\\n            for i in range(m): M[0][i] = 0\\n                \\n        if c1:\\n            for j in range(n): M[j][0] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469077,
                "title": "python-from-o-m-n-space-to-o-1-space-with-picture-clean-concise",
                "content": "**Solution 1: Additional Memory Space**\\n- Let `zeroRow[r] = True` denote all the cells in row `r` must have value 0.\\n- Let `zeroCol[c] = True` denote all the cells in column `c` must have value 0.\\n```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        zeroRow = [False] * m\\n        zeroCol = [False] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == 0:\\n                    zeroRow[r] = zeroCol[c] = True\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if zeroRow[r] or zeroCol[c]:\\n                    matrix[r][c] = 0\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns.\\n- Space: `O(M + N)`\\n\\n---\\n**Solution 2: In-space Solution**\\n- We re-use the first row as the meaning of `zeroCol`. It means `matrix[r][0] = 0` is the same meaning with `zeroRow[r] = True`. \\n- We re-use the first column as the meaning of `zeroRow`. It means `matrix[0][c] = 0` is the same meaning with `zeroCol[c] = True`.\\n- While processing to set `matrix[r][0] = 0` or `matrix[0][c] = 0`, we iterate cells with `r` in `[1...m-1]`, `c` in `[1..n-1]`. \\n\\t- We skip cells in the first row `r = 0` and cells in the first column `c = 0`. \\n\\t- Otherwise, we will get WRONG ANSWER, can check following example:\\n\\t![image](https://assets.leetcode.com/users/images/dc1a5e2f-615e-409c-bdb5-a153fe66c955_1631898869.821589.png)\\n- Before, we need to use 2 additional flag:\\n\\t- `zeroFirstRow`: To check if all elements in the first row should be set into zero\\n\\t- `zeroFirstCol`: To check if all elements in the first column should be set into zero.\\n```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        zeroFirstRow = any(matrix[0][c] == 0 for c in range(n))\\n        zeroFirstCol = any(matrix[r][0] == 0 for r in range(m))\\n        \\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][c] == 0: matrix[0][c] = matrix[r][0] = 0\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][0] == 0 or matrix[0][c] == 0: matrix[r][c] = 0\\n                    \\n        if zeroFirstRow:\\n            for c in range(n): matrix[0][c] = 0\\n        \\n        if zeroFirstCol:\\n            for r in range(m): matrix[r][0] = 0\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns.\\n- Space: `O(1)`\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        zeroRow = [False] * m\\n        zeroCol = [False] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == 0:\\n                    zeroRow[r] = zeroCol[c] = True\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if zeroRow[r] or zeroCol[c]:\\n                    matrix[r][c] = 0\\n```\n```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        zeroFirstRow = any(matrix[0][c] == 0 for c in range(n))\\n        zeroFirstCol = any(matrix[r][0] == 0 for r in range(m))\\n        \\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][c] == 0: matrix[0][c] = matrix[r][0] = 0\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][0] == 0 or matrix[0][c] == 0: matrix[r][c] = 0\\n                    \\n        if zeroFirstRow:\\n            for c in range(n): matrix[0][c] = 0\\n        \\n        if zeroFirstCol:\\n            for r in range(m): matrix[r][0] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26115,
                "title": "java-python-o-1-space-11-lines-solution",
                "content": "**Java**\\n\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length, k = 0;\\n        // First row has zero?\\n        while (k < n && matrix[0][k] != 0) ++k;\\n        // Use first row/column as marker, scan the matrix\\n        for (int i = 1; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (matrix[i][j] == 0)\\n                    matrix[0][j] = matrix[i][0] = 0;\\n        // Set the zeros\\n        for (int i = 1; i < m; ++i)\\n            for (int j = n - 1; j >= 0; --j)\\n                if (matrix[0][j] == 0 || matrix[i][0] == 0)\\n                    matrix[i][j] = 0;\\n        // Set the zeros for the first row\\n        if (k < n) Arrays.fill(matrix[0], 0);\\n    }\\n\\n**Python**\\n\\n    def setZeroes(self, matrix):\\n        # First row has zero?\\n        m, n, firstRowHasZero = len(matrix), len(matrix[0]), not all(matrix[0])\\n        # Use first row/column as marker, scan the matrix\\n        for i in xrange(1, m):\\n            for j in xrange(n):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = matrix[i][0] = 0\\n        # Set the zeros\\n        for i in xrange(1, m):\\n            for j in xrange(n - 1, -1, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n        # Set the zeros for the first row\\n        if firstRowHasZero:\\n            matrix[0] = [0] * n",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "**Java**\\n\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length, k = 0;\\n        // First row has zero?\\n        while (k < n && matrix[0][k] != 0) ++k;\\n        // Use first row/column as marker, scan the matrix\\n        for (int i = 1; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (matrix[i][j] == 0)\\n                    matrix[0][j] = matrix[i][0] = 0;\\n        // Set the zeros\\n        for (int i = 1; i < m; ++i)\\n            for (int j = n - 1; j >= 0; --j)\\n                if (matrix[0][j] == 0 || matrix[i][0] == 0)\\n                    matrix[i][j] = 0;\\n        // Set the zeros for the first row\\n        if (k < n) Arrays.fill(matrix[0], 0);\\n    }\\n\\n**Python**\\n\\n    def setZeroes(self, matrix):\\n        # First row has zero?\\n        m, n, firstRowHasZero = len(matrix), len(matrix[0]), not all(matrix[0])\\n        # Use first row/column as marker, scan the matrix\\n        for i in xrange(1, m):\\n            for j in xrange(n):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = matrix[i][0] = 0\\n        # Set the zeros\\n        for i in xrange(1, m):\\n            for j in xrange(n - 1, -1, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n        # Set the zeros for the first row\\n        if firstRowHasZero:\\n            matrix[0] = [0] * n",
                "codeTag": "Python3"
            },
            {
                "id": 26037,
                "title": "o-1-java-straightforward-idea",
                "content": "Use the first column and the first row as marker:\\n1. first scan through the whole matrix, and if one row i has zero, label matrix[i][0] = 0, if column j has zero, then label matrix[0][j] = 0.\\nif we find the first row has zero, then mark a boolean row = true, if the first column has zeros, mark a boolean col = true;\\n\\n2. By the markers on the first row and first col, set the other columns and rows to zeros. (first row and first column already contain zeros)\\n\\n3. According to booleans row and col, decide whether to set first row and column to zeros.\\n\\n        public class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;\\n            int m = matrix.length, n = matrix[0].length;\\n            boolean row = false, col = false;\\n            for (int i = 0; i < m; i++)\\n                for (int j = 0; j < n; j++){\\n                    if (matrix[i][j] == 0) {\\n                        matrix[0][j] = 0;\\n                        matrix[i][0] = 0;\\n                        if (i == 0) row = true;\\n                        if (j == 0) col = true;\\n                    }\\n                }\\n            for (int i = 1; i < m; i++){\\n                if (matrix[i][0] == 0){\\n                    for (int j = 1; j < n;j++)\\n                        matrix[i][j] = 0;\\n                }\\n            }\\n            for (int j = 1; j < n; j++){\\n                if (matrix[0][j] == 0){\\n                    for (int i = 1; i < m; i++)\\n                        matrix[i][j] = 0;\\n                }\\n            }\\n            if (row){\\n                for (int j = 0; j < n; j++)\\n                    matrix[0][j] = 0;\\n            }\\n            if (col){\\n                for(int i = 0; i < m; i++)\\n                    matrix[i][0] = 0;\\n            }\\n        }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;\\n            int m = matrix.length, n = matrix[0].length;\\n            boolean row = false, col = false;\\n            for (int i = 0; i < m; i++)\\n                for (int j = 0; j < n; j++){\\n                    if (matrix[i][j] == 0) {\\n                        matrix[0][j] = 0;\\n                        matrix[i][0] = 0;\\n                        if (i == 0) row = true;\\n                        if (j == 0) col = true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 26020,
                "title": "my-java-solution-easy-to-understand",
                "content": "    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(row[i]==1||col[j]==1){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(row[i]==1||col[j]==1){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26087,
                "title": "java-easy-to-understand-o-1-space-solution-with-2-passes",
                "content": "    public class Solution {\\n    \\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null || matrix.length==0){\\n            return;\\n        }\\n        \\n        boolean setFirstRowToZeroes = false;\\n        boolean setFirstColumnToZeroes = false;\\n        \\n        //check if first column needs to be set to zero\\n        for(int row=0;row<matrix.length;row++){\\n            if(matrix[row][0] == 0){\\n                setFirstColumnToZeroes=true;\\n                break;\\n            }\\n        }\\n        \\n        //check if first row needs to be set to zero\\n        for(int col=0;col<matrix[0].length;col++){\\n            if(matrix[0][col] == 0){\\n                setFirstRowToZeroes=true;\\n                break;\\n            }\\n        }\\n        \\n        //mark columns and rows to be set to zero\\n        for(int row=1;row<matrix.length;row++){\\n            for(int col=1;col<matrix[0].length;col++){\\n                if(matrix[row][col]==0){\\n                    matrix[row][0]=0;\\n                    matrix[0][col]=0;\\n                }\\n            }\\n        }\\n        \\n        // make rows zero\\n        for(int row=1;row<matrix.length;row++){\\n            if(matrix[row][0]==0){\\n                for(int col=1;col<matrix[0].length;col++){\\n                    matrix[row][col]=0;\\n                }\\n            }\\n        }\\n        \\n        // make columns zero\\n        for(int col=1;col<matrix[0].length;col++){\\n            if(matrix[0][col]==0){\\n                for(int row=1;row<matrix.length;row++){\\n                    matrix[row][col]=0;\\n                }\\n            }\\n        }\\n        \\n        // zero out first row (if needed)\\n        if(setFirstRowToZeroes){\\n            for(int col=0;col<matrix[0].length;col++){\\n                matrix[0][col]=0;\\n            }\\n        }\\n        \\n        // zero out first column (if needed)\\n        if(setFirstColumnToZeroes){\\n            for(int row=0;row<matrix.length;row++){\\n                matrix[row][0]=0;\\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null || matrix.length==0){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 26166,
                "title": "my-java-o-1-solution-easy-to-understand",
                "content": "    public class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if(matrix==null){\\n                return;\\n            }\\n            \\n            int m = matrix.length;\\n            int n = matrix[0].length;\\n            \\n            boolean rowHasZero = false;\\n            boolean colHasZero = false;\\n            \\n            for(int i=0; i<n; i++){\\n                if(matrix[0][i]==0){\\n                    rowHasZero = true;\\n                    break;\\n                }\\n            }\\n            \\n            for(int i=0; i<m; i++){\\n                if(matrix[i][0]==0){\\n                    colHasZero = true;\\n                    break;\\n                }\\n            }\\n            \\n            for(int i=1; i<m; i++){\\n                for(int j=1; j<n; j++){\\n                    if(matrix[i][j]==0){\\n                        matrix[i][0] = 0;\\n                        matrix[0][j] = 0;\\n                    }\\n                }\\n            }\\n            \\n    \\n            \\n            for(int j=1;j<n; j++){\\n                if(matrix[0][j]==0){\\n                    nullifyCol(matrix, j, m, n);\\n                }\\n            }\\n            \\n            for(int i=1; i<m; i++){\\n                if(matrix[i][0]==0){\\n                    nullifyRow(matrix, i, m, n);\\n                }\\n            }\\n            \\n            if(rowHasZero){\\n                nullifyRow(matrix, 0, m, n);\\n            }\\n            if(colHasZero){\\n                nullifyCol(matrix, 0, m, n);\\n            }\\n            \\n        }\\n        \\n        public void nullifyRow(int[][] matrix, int i, int m, int n){\\n            for(int col=0; col<n; col++){\\n                matrix[i][col] = 0;\\n            }\\n        }\\n        \\n        public void nullifyCol(int[][] matrix, int j, int m, int n){\\n            for(int row=0; row<m; row++){\\n                matrix[row][j] = 0;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if(matrix==null){\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 588969,
                "title": "python-solution-using-set-beats-100",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        row = set()\\n        column = set()\\n        \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    row.add(i)\\n                    column.add(j)          \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j] = 0\\n        for i in column:\\n            for j in range(len(matrix)):\\n                matrix[j][i] = 0 \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        row = set()\\n        column = set()\\n        \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    row.add(i)\\n                    column.add(j)          \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j] = 0\\n        for i in column:\\n            for j in range(len(matrix)):\\n                matrix[j][i] = 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515437,
                "title": "java-tc-o-r-c-sc-o-1-optimized-in-place-solution",
                "content": "```java\\n/**\\n * Optimized In-Place solution\\n *\\n * We can use the first cell of every row and column as a flag. This flag will\\n * determine whether a row or a column has to be set to zero.\\n *\\n * Time Complexity: O(2 * R * C)\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return;\\n        }\\n\\n        boolean isFirstColZero = false;\\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                isFirstColZero = true;\\n            }\\n            for (int j = 1; j < cols; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--) {\\n                if (matrix[i][0] == 0 | matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n            if (isFirstColZero) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Optimized In-Place solution\\n *\\n * We can use the first cell of every row and column as a flag. This flag will\\n * determine whether a row or a column has to be set to zero.\\n *\\n * Time Complexity: O(2 * R * C)\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return;\\n        }\\n\\n        boolean isFirstColZero = false;\\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                isFirstColZero = true;\\n            }\\n            for (int j = 1; j < cols; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--) {\\n                if (matrix[i][0] == 0 | matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n            if (isFirstColZero) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383492,
                "title": "simple-c-solution-using-extra-space",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<pair<int,int>> cor;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   cor.push_back({i,j});\\n                }\\n            }\\n        }\\n        for(int i=0;i<cor.size();i++)\\n        {\\n            int x=cor[i].first;\\n            int y=cor[i].second;\\n            int row=0;\\n            int col=0;\\n            while(row<m)\\n            {\\n                matrix[row][y]=0;\\n                row++;\\n            }\\n            while(col<n)\\n            {\\n                matrix[x][col]=0;\\n                col++;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<pair<int,int>> cor;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   cor.push_back({i,j});\\n                }\\n            }\\n        }\\n        for(int i=0;i<cor.size();i++)\\n        {\\n            int x=cor[i].first;\\n            int y=cor[i].second;\\n            int row=0;\\n            int col=0;\\n            while(row<m)\\n            {\\n                matrix[row][y]=0;\\n                row++;\\n            }\\n            while(col<n)\\n            {\\n                matrix[x][col]=0;\\n                col++;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280740,
                "title": "3-sweet-and-simple-approach-brute-force-optimal-pro-optimal",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& v) {\\n        int x,y;\\n        \\n        /*-------------BRUTE FORCE APPROACH-----------------*/\\n/*        \\n        \\n      int m=v.size();\\n        int n=v[0].size();\\n        int temp[m][n];\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                temp[i][j]=1;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                {\\n                for(int k=0;k<m;k++)\\n                    temp[k][j]=0;\\n                    \\n                    for(int k=0;k<n;k++)\\n                        temp[i][k]=0;\\n                }\\n               \\n            }\\n            \\n            \\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               if(temp[i][j]==0)\\n                   v[i][j]=temp[i][j];\\n                else\\n                    v[i][j]=v[i][j];\\n            }\\n        }\\n        T.C =O(M*N*(M+N))    S.C=O(MN)\\n    */    \\n        \\n        /*-----------OPTIMAL APPROACH MAKE DUMMY ROW AND COLUMN---------*/\\n     \\n        \\n      /*  \\n        int m=v.size();\\n        int n=v[0].size();\\n        int row[m];\\n        int col[n];\\n        \\n        for(int i=0;i<m;i++)\\n            row[i]=false;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n            col[i]=false;\\n        \\n         for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                {\\n                    row[i]=true;\\n                    col[j]=true;\\n                }\\n            }\\n         }\\n        \\n         for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if( row[i]==true  ||  col[j]==true)\\n                {\\n                    v[i][j]=0;\\n                }\\n            }\\n         }\\n        \\n     time complexity   = O(N*M)\\n\\nSpace Complexity: O(M + N), for storing hash tables.\\n\\n*/\\n        \\n        /*--------------------- PRO -OPTIMAL APPROACH-----------------------*/\\n          int col0 = 1, rows = v.size(), cols = v[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (v[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (v[i][j] == 0)\\n                v[i][0] = v[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (v[i][0] == 0 || v[0][j] == 0)\\n                v[i][j] = 0;\\n        if (col0 == 0) v[i][0] = 0;\\n        \\n    }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& v) {\\n        int x,y;\\n        \\n        /*-------------BRUTE FORCE APPROACH-----------------*/\\n/*        \\n        \\n      int m=v.size();\\n        int n=v[0].size();\\n        int temp[m][n];\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                temp[i][j]=1;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                {\\n                for(int k=0;k<m;k++)\\n                    temp[k][j]=0;\\n                    \\n                    for(int k=0;k<n;k++)\\n                        temp[i][k]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2170667,
                "title": "c-easy-solution-optimized",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = true;\\n        // int rows = sizeof(matrix)/sizeof(matrix[0]);\\n        int rows = matrix.size();\\n        // int cols = sizeof(matrix[0]/sizeof(matrix[0][0]));\\n        int cols = matrix[0].size();\\n        \\n        \\n        // iterate from forward\\n        for(int i = 0; i < rows; i++)\\n        {\\n            if(matrix[i][0]==0) col0 = false;\\n            for(int j = 1; j < cols; j++)\\n                if(matrix[i][j]==0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        // iterate from backward\\n        for(int i = rows-1; i >= 0; i--){\\n            for(int j = cols-1; j >= 1; j--)\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if(col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```\\n**Please upvote if you find the solution useful, means a lot.**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = true;\\n        // int rows = sizeof(matrix)/sizeof(matrix[0]);\\n        int rows = matrix.size();\\n        // int cols = sizeof(matrix[0]/sizeof(matrix[0][0]));\\n        int cols = matrix[0].size();\\n        \\n        \\n        // iterate from forward\\n        for(int i = 0; i < rows; i++)\\n        {\\n            if(matrix[i][0]==0) col0 = false;\\n            for(int j = 1; j < cols; j++)\\n                if(matrix[i][j]==0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        // iterate from backward\\n        for(int i = rows-1; i >= 0; i--){\\n            for(int j = cols-1; j >= 1; j--)\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if(col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495421,
                "title": "javascript-fast-and-simple",
                "content": "```\\nvar setZeroes = function(matrix) {\\n\\n    var track = []\\n    \\n    // find zeros\\n    for(var i = 0; i < matrix.length; i++){\\n      for(var j = 0; j < matrix[0].length; j++){\\n        if(matrix[i][j] === 0) track.push([i, j])                \\n      }\\n    }\\n\\n    for(var i = 0; i < track.length; i++){\\n      var [x, y] = track[i]\\n      \\n      // update row\\n      for(var j = 0; j < matrix[0].length; j++){\\n        matrix[x][j] = 0\\n      }\\n      \\n      // udpate column\\n      for(var j = 0; j < matrix.length; j++){\\n        matrix[j][y] = 0\\n      }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n\\n    var track = []\\n    \\n    // find zeros\\n    for(var i = 0; i < matrix.length; i++){\\n      for(var j = 0; j < matrix[0].length; j++){\\n        if(matrix[i][j] === 0) track.push([i, j])                \\n      }\\n    }\\n\\n    for(var i = 0; i < track.length; i++){\\n      var [x, y] = track[i]\\n      \\n      // update row\\n      for(var j = 0; j < matrix[0].length; j++){\\n        matrix[x][j] = 0\\n      }\\n      \\n      // udpate column\\n      for(var j = 0; j < matrix.length; j++){\\n        matrix[j][y] = 0\\n      }\\n\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519959,
                "title": "c-java-python-javascript-using-matrix-and-array-with-full-explanation",
                "content": "# Intuition:\\nWe need to modify the matrix in-place, so we can\\'t use an auxiliary matrix or hash table. We can instead use the first row and first column of the original matrix as a replacement for the auxiliary array. This way, we can save the extra space required for the auxiliary arrays and also set the values in the first row and column to zero if any element in the corresponding row or column is zero.\\n\\n# Approach:\\n1. First, the code initializes two dummy vectors, `dummyRow` and `dummyCol`, with initial values of -1. These vectors will be used to mark the rows and columns that need to be set to zero.\\n2. The code then iterates through each element of the matrix and checks if it is zero. If an element is zero, it updates the corresponding indices in `dummyRow` and `dummyCol` to 0.\\n3. After marking the rows and columns, the code iterates through the matrix again. For each element, it checks if the corresponding row index or column index in `dummyRow` or `dummyCol` is zero. If either of them is zero, it sets the current element to zero.\\n4. Finally, the matrix will have rows and columns set to zero based on the values in `dummyRow` and `dummyCol`.\\n\\n# Complexity:\\n- Time complexity: O(mn), where m and n are the number of rows and columns in the matrix, respectively. We have to traverse the matrix twice.\\n- Space complexity: O(m+n), where m and n are the number of rows and columns in the matrix, respectively. We are using two auxiliary vectors of size m and n to keep track of the rows and columns that contain zero elements.\\n\\n---\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        vector <int> dummyRow(row,-1);\\n        vector<int> dummyCol(col,-1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n         for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```java\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[] dummyRow = new int[row];\\n        int[] dummyCol = new int[col];\\n        Arrays.fill(dummyRow, -1);\\n        Arrays.fill(dummyCol, -1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```py\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        row = len(matrix)\\n        col = len(matrix[0])\\n        dummyRow = [-1] * row\\n        dummyCol = [-1] * col\\n        for i in range(row):\\n            for j in range(col):\\n                if matrix[i][j] == 0:\\n                    dummyRow[i] = 0\\n                    dummyCol[j] = 0\\n        for i in range(row):\\n            for j in range(col):\\n                if dummyRow[i] == 0 or dummyCol[j] == 0:\\n                    matrix[i][j] = 0\\n\\n```\\n---\\n# JavaScript\\n```js\\nvar setZeroes = function(matrix) {\\n    const row = matrix.length;\\n    const col = matrix[0].length;\\n    const dummyRow = new Array(row).fill(-1);\\n    const dummyCol = new Array(col).fill(-1);\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(matrix[i][j]==0){\\n                dummyRow[i] = 0;\\n                dummyCol[j] = 0;\\n            }\\n        }\\n    }\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        vector <int> dummyRow(row,-1);\\n        vector<int> dummyCol(col,-1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n         for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[] dummyRow = new int[row];\\n        int[] dummyCol = new int[col];\\n        Arrays.fill(dummyRow, -1);\\n        Arrays.fill(dummyCol, -1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n```\n```py\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        row = len(matrix)\\n        col = len(matrix[0])\\n        dummyRow = [-1] * row\\n        dummyCol = [-1] * col\\n        for i in range(row):\\n            for j in range(col):\\n                if matrix[i][j] == 0:\\n                    dummyRow[i] = 0\\n                    dummyCol[j] = 0\\n        for i in range(row):\\n            for j in range(col):\\n                if dummyRow[i] == 0 or dummyCol[j] == 0:\\n                    matrix[i][j] = 0\\n\\n```\n```js\\nvar setZeroes = function(matrix) {\\n    const row = matrix.length;\\n    const col = matrix[0].length;\\n    const dummyRow = new Array(row).fill(-1);\\n    const dummyCol = new Array(col).fill(-1);\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(matrix[i][j]==0){\\n                dummyRow[i] = 0;\\n                dummyCol[j] = 0;\\n            }\\n        }\\n    }\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26151,
                "title": "constant-space-java-solution",
                "content": " a b b \\n\\n   b c c\\n\\n   b c c\\n\\nStep1: Determine row1 and col1. Need to go through the first col and first row. Use two vars to store that information.\\nStep2: Use \"c\" to determine \"b\". Need to go through the entire matrix. Once \"c\" is zero, set its corresponding two \"b\"s to zero.\\nStep3: Use \"b\" to set \"c\". If \"b\" is zero, its corresponding row or col are set to all zero.\\nStep4: Use previous row1 and col1 information to set col1 and row1.\\n\\n    public class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstColZero = false, firstRowZero = false;\\n            for(int i = 0;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    firstColZero = true;\\n            for(int j = 0;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    firstRowZero = true;\\n            for(int i = 1;i < matrix.length;i++)\\n                for(int j = 1;j < matrix[0].length;j++)\\n                    if(matrix[i][j] == 0)\\n                        matrix[i][0] = matrix[0][j] = 0;\\n            for(int i = 1;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    for(int j = 0;j < matrix[0].length;j++)\\n                        matrix[i][j] = 0;\\n            for(int j = 1;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    for(int i = 0;i < matrix.length;i++)\\n                        matrix[i][j] = 0;\\n            if(firstColZero)\\n                for(int i = 0;i < matrix.length;i++)\\n                    matrix[i][0] = 0;\\n            if(firstRowZero)\\n                for(int j = 0;j < matrix[0].length;j++)\\n                    matrix[0][j] = 0;\\n                    \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstColZero = false, firstRowZero = false;\\n            for(int i = 0;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    firstColZero = true;\\n            for(int j = 0;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    firstRowZero = true;\\n            for(int i = 1;i < matrix.length;i++)\\n                for(int j = 1;j < matrix[0].length;j++)\\n                    if(matrix[i][j] == 0)\\n                        matrix[i][0] = matrix[0][j] = 0;\\n            for(int i = 1;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    for(int j = 0;j < matrix[0].length;j++)\\n                        matrix[i][j] = 0;\\n            for(int j = 1;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    for(int i = 0;i < matrix.length;i++)\\n                        matrix[i][j] = 0;\\n            if(firstColZero)\\n                for(int i = 0;i < matrix.length;i++)\\n                    matrix[i][0] = 0;\\n            if(firstRowZero)\\n                for(int j = 0;j < matrix[0].length;j++)\\n                    matrix[0][j] = 0;\\n                    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1477825,
                "title": "javascript-three-solutions-one-is-suggested-transcribed-to-js-100",
                "content": "![image](https://assets.leetcode.com/users/images/45384296-f1fe-4288-9759-058e94dde2c9_1632272059.2179272.png)\\n\\n\\nDoing the Blind 75 and posting all solutions.\\n\\nHere is the \\'Suggested Solution\\' transcribed to JS.  Cool solution if you Have to keep constant space.  A little convoluted otherwise imo.\\n```\\nvar setZeroes = function(matrix) {\\n  let isCol = false, r = matrix.length, c = matrix[0].length;\\n  for (let i = 0; i < r; i++) {\\n    if (!matrix[i][0]) isCol = true;\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][j]) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      };\\n    }\\n  }\\n  for (let i = 1; i < r; i++) {\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0;\\n    }\\n  }\\n  if (!matrix[0][0]) {\\n    for (let j = 0; j < c; j++) matrix[0][j] = 0;\\n  }\\n  if (isCol) {\\n    for (let i = 0; i < r; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n};\\n```\\n\\nHere is a version where we use Sets to track 0\\'s.  A little extra space, but not a ton.  Won\\'t work if interviewer challenges you to constant space though.\\n```\\nvar setZeroes = function(matrix) {\\n  const rowSet = new Set(), colSet = new Set()\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!matrix[i][j]) {\\n        rowSet.add(i);\\n        colSet.add(j);\\n      };\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (rowSet.has(i) || colSet.has(j)) matrix[i][j] = 0\\n    }\\n  }\\n};\\n```\\n\\nHere is a version where we just deep copy the array and go to town.  This is the easiest imo and gets solid time complexity (Maybe slight redoing of the recursive calls if 0\\'s overwrite cells more than once.).  It Is the worst on space complexity though.  Just depends what they\\'re looking for and if Constant Space is make or break.\\n```\\nvar setZeroes = function(matrix) {\\n  const copy = JSON.parse(JSON.stringify(matrix));\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!copy[i][j]) traverse(i, j);\\n    }\\n  }\\n  \\n  function traverse(row, col, dir = \\'all\\') {\\n    matrix[row][col] = 0;\\n    if (row - 1 >= 0 && (dir === \\'all\\' || dir === \\'up\\')) traverse(row - 1, col, \\'up\\');\\n    if (row + 1 <= matrix.length - 1 && (dir === \\'all\\' || dir === \\'down\\')) traverse(row + 1, col, \\'down\\');\\n    if (col - 1 >= 0 && (dir === \\'all\\' || dir === \\'left\\')) traverse(row, col - 1, \\'left\\');\\n    if (col + 1 <= matrix[row].length - 1 && (dir === \\'all\\' || dir === \\'right\\')) traverse(row, col + 1, \\'right\\');\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n  let isCol = false, r = matrix.length, c = matrix[0].length;\\n  for (let i = 0; i < r; i++) {\\n    if (!matrix[i][0]) isCol = true;\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][j]) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      };\\n    }\\n  }\\n  for (let i = 1; i < r; i++) {\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0;\\n    }\\n  }\\n  if (!matrix[0][0]) {\\n    for (let j = 0; j < c; j++) matrix[0][j] = 0;\\n  }\\n  if (isCol) {\\n    for (let i = 0; i < r; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n};\\n```\n```\\nvar setZeroes = function(matrix) {\\n  const rowSet = new Set(), colSet = new Set()\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!matrix[i][j]) {\\n        rowSet.add(i);\\n        colSet.add(j);\\n      };\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (rowSet.has(i) || colSet.has(j)) matrix[i][j] = 0\\n    }\\n  }\\n};\\n```\n```\\nvar setZeroes = function(matrix) {\\n  const copy = JSON.parse(JSON.stringify(matrix));\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!copy[i][j]) traverse(i, j);\\n    }\\n  }\\n  \\n  function traverse(row, col, dir = \\'all\\') {\\n    matrix[row][col] = 0;\\n    if (row - 1 >= 0 && (dir === \\'all\\' || dir === \\'up\\')) traverse(row - 1, col, \\'up\\');\\n    if (row + 1 <= matrix.length - 1 && (dir === \\'all\\' || dir === \\'down\\')) traverse(row + 1, col, \\'down\\');\\n    if (col - 1 >= 0 && (dir === \\'all\\' || dir === \\'left\\')) traverse(row, col - 1, \\'left\\');\\n    if (col + 1 <= matrix[row].length - 1 && (dir === \\'all\\' || dir === \\'right\\')) traverse(row, col + 1, \\'right\\');\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26047,
                "title": "quiet-simple-answer-u2018hacking-u2019-with-javascript",
                "content": "var setZeroes = function(matrix) {\\n\\n    var r = matrix.length;\\n    var l = matrix[0].length;\\n    for (var i = 0; i < r; i++) {\\n        for (var j = 0; j < l; j++) {\\n            if (matrix[i][j] === 0 && 1 / matrix[i][j] === Infinity) {\\n                for (var x = 0; x < r; x++) {\\n                    matrix[x][j] = matrix[x][j] && -0;\\n                }\\n                for (var y = 0; y < l; y++) {\\n                    matrix[i][y] = matrix[i][y] && -0;\\n                }\\n            }\\n        }\\n    }\\n\\n};",
                "solutionTags": [],
                "code": "var setZeroes = function(matrix) {\\n\\n    var r = matrix.length;\\n    var l = matrix[0].length;\\n    for (var i = 0; i < r; i++) {\\n        for (var j = 0; j < l; j++) {\\n            if (matrix[i][j] === 0 && 1 / matrix[i][j] === Infinity) {\\n                for (var x = 0; x < r; x++) {\\n                    matrix[x][j] = matrix[x][j] && -0;\\n                }\\n                for (var y = 0; y < l; y++) {\\n                    matrix[i][y] = matrix[i][y] && -0;\\n                }\\n            }\\n        }\\n    }\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1918838,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func setZeroes(_ matrix: inout [[Int]]) {\\n        let row = matrix.count\\n        let col = matrix[0].count\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] == 0 {\\n                    setMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] != 0 {\\n                    resetMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n    }\\n\\n    \\n    func setMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        for i in 0..<matrix.count { \\n            let val = matrix[i][col]\\n            matrix[i][col] = val == 0 ? 0 : Int.max\\n        }\\n        \\n        for j in 0..<matrix[0].count {\\n            let val = matrix[row][j]\\n            matrix[row][j] = val == 0 ? 0 : Int.max\\n        }\\n    }\\n    \\n    \\n    func resetMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        let val = matrix[row][col]\\n        if val == Int.max { matrix[row][col] = 0 }\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func setZeroes(_ matrix: inout [[Int]]) {\\n        let row = matrix.count\\n        let col = matrix[0].count\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] == 0 {\\n                    setMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] != 0 {\\n                    resetMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n    }\\n\\n    \\n    func setMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        for i in 0..<matrix.count { \\n            let val = matrix[i][col]\\n            matrix[i][col] = val == 0 ? 0 : Int.max\\n        }\\n        \\n        for j in 0..<matrix[0].count {\\n            let val = matrix[row][j]\\n            matrix[row][j] = val == 0 ? 0 : Int.max\\n        }\\n    }\\n    \\n    \\n    func resetMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        let val = matrix[row][col]\\n        if val == Int.max { matrix[row][col] = 0 }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26176,
                "title": "is-there-a-better-constant-space-solution",
                "content": "My solution is kind of hackish - accpeted. So, I want to know if there is a better constant space solution?\\n\\nI traverse the matrix and if I find a zero, I replace all the elements, except the 0 elements, of the corresponding row and column with -1. Finally I make all the -1 to 0.\\n\\nThis algorithm would fail if the matrix has -1s. \\n\\n        void setZeroes(vector<vector<int> > &matrix) {\\n        \\n        int i,j,k,m,n;\\n        \\n        m = matrix.size();\\n        n = matrix[0].size();\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==0)\\n                {\\n                    for(k=0;k<n;k++)\\n                        if(matrix[i][k]!=0)\\n                            matrix[i][k] = -1;\\n                    for(k=0;k<m;k++)\\n                        if(matrix[k][j]!=0)\\n                            matrix[k][j] = -1;\\n                }\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==-1)\\n                   matrix[i][j]=0; \\n    }",
                "solutionTags": [],
                "code": "My solution is kind of hackish - accpeted. So, I want to know if there is a better constant space solution?\\n\\nI traverse the matrix and if I find a zero, I replace all the elements, except the 0 elements, of the corresponding row and column with -1. Finally I make all the -1 to 0.\\n\\nThis algorithm would fail if the matrix has -1s. \\n\\n        void setZeroes(vector<vector<int> > &matrix) {\\n        \\n        int i,j,k,m,n;\\n        \\n        m = matrix.size();\\n        n = matrix[0].size();\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==0)\\n                {\\n                    for(k=0;k<n;k++)\\n                        if(matrix[i][k]!=0)\\n                            matrix[i][k] = -1;\\n                    for(k=0;k<m;k++)\\n                        if(matrix[k][j]!=0)\\n                            matrix[k][j] = -1;\\n                }\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==-1)\\n                   matrix[i][j]=0; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3513736,
                "title": "python3-o-1-with-reverse-traversal",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        firstRowVal, R, C = 1, len(matrix), len(matrix[0])\\n\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0 # mark column\\n                    if i != 0:       \\n                        matrix[i][0] = 0\\n                    else:\\n                        firstRowVal = 0\\n        \\n        for i in reversed(range(R)):\\n            for j in reversed(range(C)):\\n                if i == 0:\\n                    matrix[i][j] *= firstRowVal\\n                elif matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        firstRowVal, R, C = 1, len(matrix), len(matrix[0])\\n\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0 # mark column\\n                    if i != 0:       \\n                        matrix[i][0] = 0\\n                    else:\\n                        firstRowVal = 0\\n        \\n        for i in reversed(range(R)):\\n            for j in reversed(range(C)):\\n                if i == 0:\\n                    matrix[i][j] *= firstRowVal\\n                elif matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367506,
                "title": "easy-c-o-1-faang-optimal-approach",
                "content": "# **Solution 1:**\\n \\n# **Approach: Using brute force**\\n\\nAssuming all the elements in the matrix are non-negative. Traverse through the matrix and if you find an element with value 0, then change all the elements in its row and column to -1, except when an element is 0. The reason for not changing other elements to 0, but -1, is because that might affect other columns and rows. Now traverse through the matrix again and if an element is -1 change it to 0, which will be the answer.\\n\\n```\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout << \"The Final Matrix is \" << endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\\n# Time Complexity:O((N*M)*(N + M)). O(N*M) for traversing through each element and (N+M)for traversing to row and column of elements having value 0.\\n\\n# Space Complexity:O(1)\\n# **Solution 2: Better approach**\\n\\n**Intuition:** Instead of traversing through each row and column, we can use dummy arrays to check if the particular row or column has an element 0 or not, which will improve the time complexity.\\n\\n**Approach:** Take two dummy array one of size of row and other of size of column.Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout<<\"The Final Matrix is \"<<endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\\n# **Time Complexity: O(N*M + N*M)**\\n\\n# **Space Complexity: O(N)**\\n# **Solution 3: Optimizing the better approach.**\\n\\n**Intuition:** Instead of taking two dummy arrays we can use the first row and column of the matrix for the same work. This will help to reduce the space complexity of the problem. While traversing for the second time the first row and column will be computed first, which will affect the values of further elements that\\u2019s why we traversing in the reverse direction.\\n\\n**Approach:** Instead of taking two separate dummy array,take first row and column of the matrix as the array for checking whether the particular column or row has the value 0 or not.Since matrix[0][0] are overlapping.Therefore take separate variable col0(say) to check if the 0th column has 0 or not and use matrix[0][0] to check if the 0th row has 0 or not.Now traverse from last element to the first element and check if matrix[i][0]==0 || matrix[0][j]==0 and if true set matrix[i][j]=0,else continue.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix){\\n        int col0=1, rows=matrix.size(), columns=matrix[0].size();\\n        for(int i=0 ; i<rows ; i++){\\n            if(matrix[i][0]==0) col0=0;\\n            for(int j=1 ; j<columns ; j++){\\n                if(matrix[i][j]==0)\\n                    matrix[i][0]=matrix[0][j]=0;\\n            }\\n        }\\n        for(int i=rows-1 ; i>=0 ; i--){\\n            for(int j=columns-1 ; j>=1 ; j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(col0==0)\\n                matrix[i][0]=0;\\n        }\\n    }\\n};\\n\\n// Total TC: O(2(m*n)) SC: O(1)\\n```\\n# **Time Complexity: O(2*(N*M)), as we are traversing two times in a matrix.**\\n\\n# **Space Complexity: O(1).**\\n\\nI found This video really useful. \\n[https://www.youtube.com/watch?v=M65xBewcqcI&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=10](http://)\\n\\n# **Please UPVOTE if it helped you !   \\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout << \"The Final Matrix is \" << endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout<<\"The Final Matrix is \"<<endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix){\\n        int col0=1, rows=matrix.size(), columns=matrix[0].size();\\n        for(int i=0 ; i<rows ; i++){\\n            if(matrix[i][0]==0) col0=0;\\n            for(int j=1 ; j<columns ; j++){\\n                if(matrix[i][j]==0)\\n                    matrix[i][0]=matrix[0][j]=0;\\n            }\\n        }\\n        for(int i=rows-1 ; i>=0 ; i--){\\n            for(int j=columns-1 ; j>=1 ; j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(col0==0)\\n                matrix[i][0]=0;\\n        }\\n    }\\n};\\n\\n// Total TC: O(2(m*n)) SC: O(1)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 715132,
                "title": "java-best-explained-o-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //if we do normal approach whole matrix becomes 0\\n        // Basic explanation:\\n        // we are using the first row and column as a memory to keep track of all the 0\\'s in the entire matrix.\\n        \\n        if(matrix==null || matrix.length==0 || matrix[0].length==0){\\n            return;\\n        }\\n        \\n        \\n        //first we have to check is there any need to make first row and first column\\n        //so that at last we make tham 0\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        boolean first_row=false;\\n        boolean first_col=false;\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0){\\n                first_col=true;\\n                break;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0){\\n                first_row=true;\\n                break;\\n            }\\n        }\\n        //now find 0 inside matrix (except first row and col)\\n        //make 0 at the corresponding pos of first row and first col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //Now it\\'s time to make them 0 based to first row and col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        //At last convert first row 0 if first_row is true\\n        if(first_row){\\n            for(int j=0;j<n;j++){\\n                matrix[0][j]=0;\\n            }\\n        }\\n        //same for first col\\n        if(first_col){\\n            for(int i=0;i<m;i++){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //if we do normal approach whole matrix becomes 0\\n        // Basic explanation:\\n        // we are using the first row and column as a memory to keep track of all the 0\\'s in the entire matrix.\\n        \\n        if(matrix==null || matrix.length==0 || matrix[0].length==0){\\n            return;\\n        }\\n        \\n        \\n        //first we have to check is there any need to make first row and first column\\n        //so that at last we make tham 0\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        boolean first_row=false;\\n        boolean first_col=false;\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0){\\n                first_col=true;\\n                break;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0){\\n                first_row=true;\\n                break;\\n            }\\n        }\\n        //now find 0 inside matrix (except first row and col)\\n        //make 0 at the corresponding pos of first row and first col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //Now it\\'s time to make them 0 based to first row and col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        //At last convert first row 0 if first_row is true\\n        if(first_row){\\n            for(int j=0;j<n;j++){\\n                matrix[0][j]=0;\\n            }\\n        }\\n        //same for first col\\n        if(first_col){\\n            for(int i=0;i<m;i++){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961783,
                "title": "c-3-approaches-easy-to-understand",
                "content": "It is a frequently asked problem in interviews and a really good example of how to reduce time and space complexity for matrices using certain observations.\\n\\n**1st approach: Brute Force**\\n\\nSo, this approach would cross everyone\\'s mind and goes as following-\\nFirst we\\'ll check for cells with zero and then create a new matrix and traverse the given matrix and reflect all the changes in the new matrix itself.\\n\\n**Code-**\\n\\n```\\nvector<vector<int>> v( matrix.size(), vector<int>(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){\\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t       for(int k=0; k<matrix.size(); k++){\\n\\t\\t\\t       v[k][j]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int k=0; k<matrix[0].size(); k++){\\n\\t\\t\\t       v[i][k]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv[i][j]=matrix[i][j];\\n\\t\\t}\\n    }\\n```\\n\\n*Time complexity= O((rowsize * columsize) *  (rowsize+columnsize))\\nSpace Complexity= O(rowsize  columnsize)*\\n\\n**2nd approach: Using Hash Table**\\n\\nNow, we can get rid of the third loop by simply using two hash tables. The intuition to use two hash tables comes from observing the problem and what it requires, and that is we just want to keep track of 0 of any matrix cell and want to change the whole column or whole row accordingly, thus the idea of using hashing generates.\\n\\nIn this approach, we\\'ll use two hash tables-\\n\\n1)For tracking which row will contain 0\\'s\\n2)For tracking which column will contain 0\\'s\\n\\nand will update the row or column index in the matrix to 0. Then we\\'ll iterate through the whole matrix again and check the values in the hash table, so when we\\'ll encounter a 0 in either of the hash tables we\\'ll update 0 in the matrix.\\n\\n**Code-**\\n\\n```\\nvector<int> rows(matrix.size()), cols(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t      rows[i] = cols[j] = 0;       //updating hash tables\\n\\t\\t\\t }\\n\\t   }\\n}\\n//Now updating the matrix in 2nd traversal\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(rows[i] == 0 || cols[j] == 0){\\n\\t\\t      matrix[i][j] = 0;       \\n\\t\\t\\t }\\n\\t   }\\n}\\n\\n```\\n\\n*Time complexity= O(rowsize * columnsize)\\nSpace Complexity= O(rowsize + columnsize)*\\n\\n**3rd approach: Using In-place Hashing**\\n\\nNow this can be done by an amazing observation and using the 2nd approch but with O(1) space complexity, that is we know that we are required to update 0 in place of a particular column or row whenever a zero is encountered, that means ultimately the first/last column and row are going to reflect changes accordingly and can act as suitable hash tables. Voila! You got that right, in this question we can use the first/last column and row as hash tables and thus reduced space complexity.\\n\\nBut!! There is one problem that is if we use the first or last column and row, the first/last cell will result in clashing as it is common to both the dummy hash tables. So, can we resolve this issue? Well, yes this issue can be resolved.\\n\\nHow?\\nWe can reserve the first/last cell for dummy row hash table and whether to reflect changes in the column hash table we can use a separate variable. And this way, we can avoid any sort of clashing.\\n\\n**Code-**\\n\\n```\\nint n=matrix.size(), m=matrix[0].size(), col=1; //the col variable is defined so as to avoid the clash on the first cell of the matrix as it is commom to both dummy in-place hash tables \\n        for(int i=0;i<n;i++){\\n            if(matrix[i][0]==0)col=0; //it will only be set to zero when a 0 is encountered corresponding to a column\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //The first matrix traversal was to create the hash tables and the second one below is to update the values in the matrix according to the hash table\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=1;j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n            }\\n            if(col==0)matrix[i][0]=0; //clash avoided as column that particular column will only be updated when col is 0 otherwise values will remain intact \\n        }\\n        //the reason we were able to use in-place hashing in this question was because ultimately 0 in a cell will make that particular row or column 0. Hence we could use the first row and column as dummy hash tables and also didn\\'t have to store the values elsewhere\\n```\\n\\n*Time complexity= O(rowsize * columnsize)\\nSpace Complexity= O(1)*\\n\\nIf this helped you, please consider upvoting! \\nHappy coding!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> v( matrix.size(), vector<int>(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){\\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t       for(int k=0; k<matrix.size(); k++){\\n\\t\\t\\t       v[k][j]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int k=0; k<matrix[0].size(); k++){\\n\\t\\t\\t       v[i][k]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv[i][j]=matrix[i][j];\\n\\t\\t}\\n    }\\n```\n```\\nvector<int> rows(matrix.size()), cols(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t      rows[i] = cols[j] = 0;       //updating hash tables\\n\\t\\t\\t }\\n\\t   }\\n}\\n//Now updating the matrix in 2nd traversal\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(rows[i] == 0 || cols[j] == 0){\\n\\t\\t      matrix[i][j] = 0;       \\n\\t\\t\\t }\\n\\t   }\\n}\\n\\n```\n```\\nint n=matrix.size(), m=matrix[0].size(), col=1; //the col variable is defined so as to avoid the clash on the first cell of the matrix as it is commom to both dummy in-place hash tables \\n        for(int i=0;i<n;i++){\\n            if(matrix[i][0]==0)col=0; //it will only be set to zero when a 0 is encountered corresponding to a column\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //The first matrix traversal was to create the hash tables and the second one below is to update the values in the matrix according to the hash table\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=1;j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n            }\\n            if(col==0)matrix[i][0]=0; //clash avoided as column that particular column will only be updated when col is 0 otherwise values will remain intact \\n        }\\n        //the reason we were able to use in-place hashing in this question was because ultimately 0 in a cell will make that particular row or column 0. Hence we could use the first row and column as dummy hash tables and also didn\\'t have to store the values elsewhere\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009282,
                "title": "with-explanation-0-1-space-0-m-n-space",
                "content": "```\\n\\n//O(m+n) space, O(m+n) time\\n//keep two sets, one for row indexes than should be marked 0, and one for col indexes that should be marked 0\\n//loop through matrix once, populating the sets\\n//loop through a second time, setting items to 0, if their indexes are in either set\\n\\nconst setZeroes = (matrix) => {\\n    let rowsZero = new Set()\\n    let colsZero = new Set()\\n    for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n                rowsZero.add(i)\\n                colsZero.add(j)\\n            }\\n        }\\n    }\\n  for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (rowsZero.has(i) || colsZero.has(j)){\\n                matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\n//O(1) space, O(m+n) time\\n//we do the same as above, except we use the matrix itself to keep track of which rows and cols should be 0, instead of using sets\\n//we go through matrix and if we find a 0, we mark all items in row and all items in col\\n//we can\\'t simply set all items in row and col to zero, because we don\\'t want to change rows and columns with newly formed zeroes...just original zeroes\\n//if our \\'mark\\' function changed all items in selected row and col to be zero, it would mess up future iterations\\n//so we mark them as something else...null...and then we loop through the matrix a second time, making null items 0\\nconst setZeroes = (matrix) =>{\\n      for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n              mark(matrix,i,j)\\n            }\\n        }\\n    }\\n       for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === null){\\n              matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\nconst mark = (matrix, row, col)=>{\\n    for (let j = 0; j < matrix[0].length; j++){\\n        //preserve original 0, mark items that should zero as null\\n        if (matrix[row][j] !== 0){\\n           matrix[row][j] = null         \\n        }\\n    }\\n    for (let i = 0; i < matrix.length; i++){\\n        //preserve original 0, mark items that should be zero as null\\n        if (matrix[i][col] !== 0){\\n            matrix[i][col] = null\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n//O(m+n) space, O(m+n) time\\n//keep two sets, one for row indexes than should be marked 0, and one for col indexes that should be marked 0\\n//loop through matrix once, populating the sets\\n//loop through a second time, setting items to 0, if their indexes are in either set\\n\\nconst setZeroes = (matrix) => {\\n    let rowsZero = new Set()\\n    let colsZero = new Set()\\n    for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n                rowsZero.add(i)\\n                colsZero.add(j)\\n            }\\n        }\\n    }\\n  for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (rowsZero.has(i) || colsZero.has(j)){\\n                matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\n//O(1) space, O(m+n) time\\n//we do the same as above, except we use the matrix itself to keep track of which rows and cols should be 0, instead of using sets\\n//we go through matrix and if we find a 0, we mark all items in row and all items in col\\n//we can\\'t simply set all items in row and col to zero, because we don\\'t want to change rows and columns with newly formed zeroes...just original zeroes\\n//if our \\'mark\\' function changed all items in selected row and col to be zero, it would mess up future iterations\\n//so we mark them as something else...null...and then we loop through the matrix a second time, making null items 0\\nconst setZeroes = (matrix) =>{\\n      for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n              mark(matrix,i,j)\\n            }\\n        }\\n    }\\n       for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === null){\\n              matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\nconst mark = (matrix, row, col)=>{\\n    for (let j = 0; j < matrix[0].length; j++){\\n        //preserve original 0, mark items that should zero as null\\n        if (matrix[row][j] !== 0){\\n           matrix[row][j] = null         \\n        }\\n    }\\n    for (let i = 0; i < matrix.length; i++){\\n        //preserve original 0, mark items that should be zero as null\\n        if (matrix[i][col] !== 0){\\n            matrix[i][col] = null\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3689227,
                "title": "java-striver-easy-understanding",
                "content": "```\\n# 1. Brute force Approach\\nComplexity\\nTime complexity:O((NM)(N + M)) + O(N*M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(1)\\n\\n# Code\\n\\nclass Solution {\\n    \\n    // making rows negative excluding 0\\'s\\n    public static void makeRow(int matrix[][],int n,int m,int i){\\n        for(int j=0;j<n;j++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n            \\n        }\\n    }\\n    \\n      // making cols negative excluding 0\\'s\\n    public static void makeCol(int matrix[][],int n,int m,int j){\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n        }\\n    }\\n    \\n    // main function\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix[0].length;\\n        int m = matrix.length;\\n       \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    makeRow(matrix,n,m,i);\\n                    makeCol(matrix,n,m,j);\\n                }\\n            }\\n        }\\n        \\n        // itterate through the matrix and mark 0\\'s where negative is present \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]== -1){\\n                    matrix[i][j]=0;\\n                }\\n                \\n            }\\n        }\\n    }\\n}\\n```\\n\\n```\\n#2. Better Approach\\nComplexity\\nTime complexity:O(2*(N*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(N) + O(M)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int row [] = new int[m];\\n        int col[] = new int[n];\\n\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                   \\n                   row [i] = 1;\\n                   col [j] = 1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(row[i]==1 ||col[j]==1){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\n```\\n\\n#3. Optimal Approach\\nComplexity\\nTime complexity:O(2*(N*M))\\nSpace complexity:O(1)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){  \\n                    matrix[i][0] = 0;\\n                if(j != 0){\\n                    matrix[0][j] = 0;\\n                }else col0 = 0;\\n                }\\n            }\\n        }\\n\\t\\t\\n        for(int i = 1;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[i][0]==0 ||matrix[0][j]==0){\\n                    matrix[i][j] = 0;\\n                }\\n                } \\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            if(matrix[0][0]==0){\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        for(int i = 0;i<m;i++){\\n            if(col0 == 0){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n# 1. Brute force Approach\\nComplexity\\nTime complexity:O((NM)(N + M)) + O(N*M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(1)\\n\\n# Code\\n\\nclass Solution {\\n    \\n    // making rows negative excluding 0\\'s\\n    public static void makeRow(int matrix[][],int n,int m,int i){\\n        for(int j=0;j<n;j++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n            \\n        }\\n    }\\n    \\n      // making cols negative excluding 0\\'s\\n    public static void makeCol(int matrix[][],int n,int m,int j){\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n        }\\n    }\\n    \\n    // main function\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix[0].length;\\n        int m = matrix.length;\\n       \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    makeRow(matrix,n,m,i);\\n                    makeCol(matrix,n,m,j);\\n                }\\n            }\\n        }\\n        \\n        // itterate through the matrix and mark 0\\'s where negative is present \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]== -1){\\n                    matrix[i][j]=0;\\n                }\\n                \\n            }\\n        }\\n    }\\n}\\n```\n```\\n#2. Better Approach\\nComplexity\\nTime complexity:O(2*(N*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(N) + O(M)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int row [] = new int[m];\\n        int col[] = new int[n];\\n\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                   \\n                   row [i] = 1;\\n                   col [j] = 1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(row[i]==1 ||col[j]==1){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\n```\\n\\n#3. Optimal Approach\\nComplexity\\nTime complexity:O(2*(N*M))\\nSpace complexity:O(1)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){  \\n                    matrix[i][0] = 0;\\n                if(j != 0){\\n                    matrix[0][j] = 0;\\n                }else col0 = 0;\\n                }\\n            }\\n        }\\n\\t\\t\\n        for(int i = 1;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[i][0]==0 ||matrix[0][j]==0){\\n                    matrix[i][j] = 0;\\n                }\\n                } \\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            if(matrix[0][0]==0){\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        for(int i = 0;i<m;i++){\\n            if(col0 == 0){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316512,
                "title": "java-solution-for-beginners",
                "content": "*** Please upvote if helpful!**\\n```\\npublic void setZeroes(int[][] matrix) {\\n        int[] row = new int[matrix.length];\\n        int[] col = new int[matrix[0].length];\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    row[i] = -1;\\n                    col[j] = -1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (row[i] == -1 || col[j] == -1) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void setZeroes(int[][] matrix) {\\n        int[] row = new int[matrix.length];\\n        int[] col = new int[matrix[0].length];\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    row[i] = -1;\\n                    col[j] = -1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (row[i] == -1 || col[j] == -1) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 512927,
                "title": "python-o-1-aux-space-sol-by-bit-masking-72-with-explanation",
                "content": "Python O(1) aux space sol by bit masking\\n\\nLet *m*, *n* denote as the dimension of matrix height and width.\\n\\n---\\n\\n**Hint**:\\nWhat we need to know is **index of row** and **index column** for **zero element**.\\n\\nUsually, first idea pop into our head is to to store those indices in a set, which is up to O( m + n )\\n\\nActually, we can be more memory-space saving by using bit masking, reduce aux space cost to O(1).\\n\\n---\\n\\n**Algorithm**:\\n\\nStep_#1.\\n\\nScan each element in matrix.\\n**Setup bit masking for zero element**, store them in integer.\\n\\nFor example, if masking row is row_#**0**, row_#**1**, and row_**#3**, then\\n**row_mask** = (1<<**0**) + (1<<**1**) + (1<<**3**) = 2^**0** + 2^**1** + 2^**3**\\n= 0b **1011**\\n\\nSimilarly, masking column is setup in the same way.\\n\\n---\\n\\nStep_#2.\\n\\nIterate each position in matrix,\\n**Clean specified position to 0** by **row mask** and **column mask**.\\n\\n---\\n\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        h, w = len( matrix), len( matrix[0])\\n        \\n        row_mask, col_mask = 0, 0\\n        \\n        ## Step_#1\\n        #\\n        # Setup masking for zero element\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if matrix[y][x] == 0:\\n                    \\n                    row_mask |= (1<<y)\\n                    col_mask |= (1<<x)\\n        \\n        \\n        ## Step_#2\\n        #\\n        # Clear by row mask and column mask\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if row_mask & (1<<y) or col_mask & (1<<x):\\n                    matrix[y][x] = 0\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #1252 Cells with Odd Values in a Matrix](https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/)",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        h, w = len( matrix), len( matrix[0])\\n        \\n        row_mask, col_mask = 0, 0\\n        \\n        ## Step_#1\\n        #\\n        # Setup masking for zero element\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if matrix[y][x] == 0:\\n                    \\n                    row_mask |= (1<<y)\\n                    col_mask |= (1<<x)\\n        \\n        \\n        ## Step_#2\\n        #\\n        # Clear by row mask and column mask\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if row_mask & (1<<y) or col_mask & (1<<x):\\n                    matrix[y][x] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597295,
                "title": "3-approaches-from-brute-to-optimal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo traverse through thw whole matrix and if a zero is found then set whole row and column to 0\\n# Approach 1:\\n<!-- Describe your approach to solving the problem. -->\\nTraversing the matrix and if 0 is found then setting it to a negative number cause setting it to zero can hamper values of other row and columns where initially 0 was not present after setting with negative number traversing again through matrix and setting to zero wherever negative number is found. This approach works only if no negative numbers are present in the matrix.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*M)*O(N+M)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setRowColumn(vector<vector<int>>& matrix,int m,int n,int r,int c)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(matrix[r][i]!=0)\\n                matrix[r][i]=-1;\\n        }\\n        for(int j=0;j<m;j++)\\n        {\\tif(matrix[j][c]!=0)\\n                matrix[j][c]=-1;\\n        }\\n    }\\n    void setZeroes(vector<vector<int>> &matrix)\\n    {\\n        // Write your code here.\\n        int m=matrix.size(), n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    setRowColumn(matrix,m,n,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]<0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```\\n\\n# Approach 2:\\n<!-- Describe your approach to solving the problem. -->\\nUsing dummy arrays to keep track of zeroes. Setting that particular row to 0 in dummy row as well as dummy column arrays wherever zero is found in the cell. Again traversing through the matrix and replacing current value by 0 if current cell dummy row index or dummy column index is set to 0.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*M + N*M)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)+O(M)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size(),n=matrix[0].size();\\n\\tvector<int> rows(m,1),cols(n,1);\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\trows[i]=0;\\n\\t\\t\\t\\tcols[j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(rows[i]==0 || cols[j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n  }\\n};\\n```\\n# Approach 3:\\n<!-- Describe your approach to solving the problem. -->\\nUsing dummy arrays increases space complexity to O(N) so trying to reduce space complexity.\\nWe use the 1st row and 1st column of given array as dummy array but matrix[0][0] coincides so to resolve this we use dummy column from 1 to n and dummy row from 0 to m. so for keeping track of whether dummy row contains any 0 we use a variable col and set it to 0 if a 0 is found in dummy row.\\nWe again traverse the array apart from dummy row and dummy column i.e from i-> 1 to m and j-> 1 to n to find if matrix cell contains any zero if it does then we check whether dummy column or row is set if it is set then we set the matrix cell to zero.\\nNow we again need to perform similar operation for dummy row as well as dummy column. dummy row depends on matrix [0][0] whereas as dummy column depends on cols variable so we set it accordingly.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*M + N*M)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n    bool cols=1;\\n\\tint m=matrix.size(),n=matrix[0].size();\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][0]=0;\\n\\t\\t\\t\\tif(j!=0)\\n\\t\\t\\t\\t\\tmatrix[0][j]=0;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcols=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=1;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=1;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]!=0)\\n\\t\\t\\t{\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) \\n\\t\\t\\t\\t{\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\tif(matrix[0][0]==0)\\n\\t{\\n\\t\\tfor (int i = 0; i < n; i++) \\n\\t\\t{\\n\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n    }\\n\\tif(cols==0)\\n\\t{\\n\\t\\tfor (int j = 0; j < m; j++) \\n\\t\\t{\\n\\t\\t\\tmatrix[j][0] = 0;\\n\\t\\t}\\n    }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setRowColumn(vector<vector<int>>& matrix,int m,int n,int r,int c)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(matrix[r][i]!=0)\\n                matrix[r][i]=-1;\\n        }\\n        for(int j=0;j<m;j++)\\n        {\\tif(matrix[j][c]!=0)\\n                matrix[j][c]=-1;\\n        }\\n    }\\n    void setZeroes(vector<vector<int>> &matrix)\\n    {\\n        // Write your code here.\\n        int m=matrix.size(), n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    setRowColumn(matrix,m,n,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]<0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size(),n=matrix[0].size();\\n\\tvector<int> rows(m,1),cols(n,1);\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\trows[i]=0;\\n\\t\\t\\t\\tcols[j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(rows[i]==0 || cols[j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n    bool cols=1;\\n\\tint m=matrix.size(),n=matrix[0].size();\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][0]=0;\\n\\t\\t\\t\\tif(j!=0)\\n\\t\\t\\t\\t\\tmatrix[0][j]=0;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcols=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=1;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=1;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]!=0)\\n\\t\\t\\t{\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) \\n\\t\\t\\t\\t{\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\tif(matrix[0][0]==0)\\n\\t{\\n\\t\\tfor (int i = 0; i < n; i++) \\n\\t\\t{\\n\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n    }\\n\\tif(cols==0)\\n\\t{\\n\\t\\tfor (int j = 0; j < m; j++) \\n\\t\\t{\\n\\t\\t\\tmatrix[j][0] = 0;\\n\\t\\t}\\n    }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243163,
                "title": "python-easy-solution",
                "content": "I have initialize the coordinate list for row and col. If we found zero we append its row and col coordinates to respective list....Easy??\\n\\nFor the next steps I\\'m simply adding zero to (0-R, 1-R, 2-R, ...upto no. of rows) indexes. Similarly for the column I\\'m adding zero to (C-0, C-1, C-2, ...upto no of columns) indexes. Easy..!!\\n\\nEasy and Helpful ?? **Make sure to Upvote** \\n\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        row, col = [], []\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c] == 0:\\n                    row.append(r)\\n                    col.append(c)\\n        \\n        for r in row:\\n            for i in range(len(matrix[0])):\\n                matrix[r][i] = 0\\n        \\n        for c in col:\\n            for i in range(len(matrix)):\\n                matrix[i][c] = 0\\n```\\n\\n![image](https://assets.leetcode.com/users/images/bcd31b28-9137-4b52-ba0c-3019cb6db3dd_1657052349.8345335.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        row, col = [], []\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c] == 0:\\n                    row.append(r)\\n                    col.append(c)\\n        \\n        for r in row:\\n            for i in range(len(matrix[0])):\\n                matrix[r][i] = 0\\n        \\n        for c in col:\\n            for i in range(len(matrix)):\\n                matrix[i][c] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944059,
                "title": "two-different-approaches",
                "content": "# without Space ---->O(1)\\n# Time complexity ------>O(N^3)\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    for row in range(n):\\n                        if matrix[i][row]!=0:\\n                            matrix[i][row]=-2**32\\n                    for col in range(m):\\n                        if matrix[col][j]!=0:\\n                            matrix[col][j]=-2**32\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==(-2**32):\\n                    matrix[i][j]=0\\n```\\n# with space Complexity:O(2*k) \\n# Time Complexity--->O(N^2)\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        arr=[]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    arr.append([i,j])\\n                \\n        for k,l in arr:\\n            for row in range(n):\\n                matrix[k][row]=0\\n            for col in range(m):\\n                matrix[col][l]=0\\n  ```\\n  # please upvote me it would encourage me alot\\n\\n\\n            \\n\\n\\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    for row in range(n):\\n                        if matrix[i][row]!=0:\\n                            matrix[i][row]=-2**32\\n                    for col in range(m):\\n                        if matrix[col][j]!=0:\\n                            matrix[col][j]=-2**32\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==(-2**32):\\n                    matrix[i][j]=0\\n```\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        arr=[]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    arr.append([i,j])\\n                \\n        for k,l in arr:\\n            for row in range(n):\\n                matrix[k][row]=0\\n            for col in range(m):\\n                matrix[col][l]=0\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3155961,
                "title": "simplest-c-solution-using-set-and-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        set<int>r,c;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n\\n            }\\n        }\\n    for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(r.count(i) || c.count(j))\\n                matrix[i][j]=0;\\n                }\\n            \\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\nDo upvote if it helped\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        set<int>r,c;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n\\n            }\\n        }\\n    for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(r.count(i) || c.count(j))\\n                matrix[i][j]=0;\\n                }\\n            \\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\nDo upvote if it helped\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802535,
                "title": "striver-s-solution-upvote-if-you-like",
                "content": "# Intuition\\nusing striver approach\\n\\n# Approach\\nstore states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable \"colm\" for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way.\\n\\n# Complexity\\nO(m*n)\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1,rows=matrix.size(),col=matrix[0].size();\\n        for(int i=0;i<rows;i++)\\n        {\\n        if(matrix[i][0]==0) colm=0;\\n          for(int j=1;j<col;j++)\\n         {\\n            if(matrix[i][j]==0)\\n                matrix[i][0]=matrix[0][j]=0;\\n            \\n         }\\n        }\\n        for(int i=rows-1;i>=0;i--)\\n        {\\n            for(int j=col-1;j>=1;j--)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n                \\n                \\n            }\\n            if(colm==0) matrix[i][0]=0;\\n            \\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1,rows=matrix.size(),col=matrix[0].size();\\n        for(int i=0;i<rows;i++)\\n        {\\n        if(matrix[i][0]==0) colm=0;\\n          for(int j=1;j<col;j++)\\n         {\\n            if(matrix[i][j]==0)\\n                matrix[i][0]=matrix[0][j]=0;\\n            \\n         }\\n        }\\n        for(int i=rows-1;i>=0;i--)\\n        {\\n            for(int j=col-1;j>=1;j--)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n                \\n                \\n            }\\n            if(colm==0) matrix[i][0]=0;\\n            \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628269,
                "title": "set-matrix-zeroes-c-easy-and-clear-cut-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    //Just keep it very simple \\n    //if any row or col containing zeros that means we have to set that row or col to zero.\\n    void setZeroes(vector<vector<int>>& matrix){\\n        bool isrow = false, iscol = false;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j] == 0){\\n                    if(i == 0) isrow = true;\\n                    if(j == 0) iscol = true;\\n                    //for further memorization we set the first element of that col and row to zero.\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<matrix.size();i++){\\n            for(int j=1;j<matrix[0].size();j++){\\n                if(matrix[i][0] == 0 or matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(iscol) for(int i=0;i<matrix.size();i++) matrix[i][0] = 0;\\n        if(isrow) for(int j=0;j<matrix[0].size();j++) matrix[0][j] = 0;\\n    }\\n};\\n```\\n**Guys Don\\'t forget to upvote me.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Just keep it very simple \\n    //if any row or col containing zeros that means we have to set that row or col to zero.\\n    void setZeroes(vector<vector<int>>& matrix){\\n        bool isrow = false, iscol = false;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j] == 0){\\n                    if(i == 0) isrow = true;\\n                    if(j == 0) iscol = true;\\n                    //for further memorization we set the first element of that col and row to zero.\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<matrix.size();i++){\\n            for(int j=1;j<matrix[0].size();j++){\\n                if(matrix[i][0] == 0 or matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(iscol) for(int i=0;i<matrix.size();i++) matrix[i][0] = 0;\\n        if(isrow) for(int j=0;j<matrix[0].size();j++) matrix[0][j] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968645,
                "title": "o-1-space-easily-explained-faster-than-100",
                "content": "**Code :**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) \\n{\\n        int m = matrix.size(), n = matrix[0].size();\\n        bool isRowZero = false, isColZero = false;\\n        \\n\\t\\t// Check the first Column, zero is present or not...\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                isColZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check the First Row, zero is present or not\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                isRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check all elements except first row & first Column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// process all elements except first row & first column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        \\n\\t\\t// process first column\\n        if(isColZero)\\n        {\\n            for(int i = 0; i < m; i++)\\n                matrix[i][0] = 0;\\n        }\\n        \\n\\t\\t// process first row\\n        if(isRowZero)\\n        {\\n            for(int i = 0; i < n; i++)\\n                matrix[0][i] = 0;\\n        }\\n}\\n```\\n\\n**Time Complexity : O(m + n)**\\n**Space Complexity : O(1)**\\n\\n**If you find it useful please upvote.\\nIf you have any question feel free to ask in comment section.**\\n",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvoid setZeroes(vector<vector<int>>& matrix) \\n{\\n        int m = matrix.size(), n = matrix[0].size();\\n        bool isRowZero = false, isColZero = false;\\n        \\n\\t\\t// Check the first Column, zero is present or not...\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                isColZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check the First Row, zero is present or not\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                isRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check all elements except first row & first Column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// process all elements except first row & first column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        \\n\\t\\t// process first column\\n        if(isColZero)\\n        {\\n            for(int i = 0; i < m; i++)\\n                matrix[i][0] = 0;\\n        }\\n        \\n\\t\\t// process first row\\n        if(isRowZero)\\n        {\\n            for(int i = 0; i < n; i++)\\n                matrix[0][i] = 0;\\n        }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1443892,
                "title": "m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& A) {\\n        const int m = A.size(), n = A[0].size();\\n        vector<int> row(m, 1), col(n,1);\\n        for(int i =0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(A[i][j] == 0){\\n                    col[j] = 0;\\n                    row[i] = 0;\\n                }\\n        \\n        for(int i =0; i < m; i++)                        \\n            for(int j = 0; j < n; j++) \\n                if(row[i] == 0 || col[j] == 0) \\n                    A[i][j] = 0;            \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& A) {\\n        const int m = A.size(), n = A[0].size();\\n        vector<int> row(m, 1), col(n,1);\\n        for(int i =0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(A[i][j] == 0){\\n                    col[j] = 0;\\n                    row[i] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1400851,
                "title": "2-approach-w-explanation-o-m-n-o-1-c-python-java",
                "content": "**OBSERVATION:**\\nThe time complexity of this problem remains `O(M*N)`, the only improvement we can do is of the space complexity. So we will have 2 approaches here\\n\\n# **APPROACH I:**\\n*Additional Memory Approach-*\\nIf any cell of the matrix has a zero we can record its row and column number. All the cells of this recorded row and column can be marked zero in the next iteration.\\n\\n**Algorithm**\\n* We iterate over the original array and look for zero entries.\\n* If we find that an entry at `[i, j]` is `0`, then we need to record somewhere the row `i` and column `j`.\\n* So, we use two sets, one for the rows and one for the columns.\\n```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\\n*  We iterate over the array once again, and check each cell.\\n\\t*  If the row **Or** column is marked, we set the value of the cell as 0.\\n\\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(M+N)**\\n\\n# **APPROACH II**\\nWe handle cases seperately. \\n* Check the first row and column for pre-existing `0`. \\n\\t* If found we mark that row or column as true\\n* Now we work upon the remaining matrix.\\n\\t* First we look for the cell that has `0` in it.\\n\\t* Then proceed with the working i.e. marking the cell as 0. \\n*  Now work upon the checked first row and column and update their values.\\n\\t*  Note: Updating before hand gives WA\\n \\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(1)**",
                "solutionTags": [],
                "code": "```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383088,
                "title": "three-solutions-in-python-3-o-1-o-m-n-and-o-mn-space",
                "content": "_O(1) space:_\\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N = len(m), len(m[0])\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j]: continue\\n    \\t\\tfor k in range(N):\\n    \\t\\t\\tif m[i][k] != 0: m[i][k] = \\' \\'\\n    \\t\\tfor k in range(M):\\n    \\t\\t\\tif m[k][j] != 0: m[k][j] = \\' \\'\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j] == \\' \\': m[i][j] = 0\\n\\t\\t\\t\\n\\t\\t\\t\\n```\\n_O(M+N) space:_\\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N, = len(m), len(m[0])\\n    \\tR, C = [i for i,j in enumerate(m) if 0 in j], [i for i,j in enumerate(zip(*m)) if 0 in j]\\n    \\tfor i,j in itertools.product(R,range(N)): m[i][j] = 0\\n    \\tfor i,j in itertools.product(C,range(M)): m[j][i] = 0\\n\\n\\n```\\n_O(MN) space:_\\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N, n = len(m), len(m[0]), [list(i) for i in m]\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif n[i][j]: continue\\n    \\t\\tfor k in range(N): m[i][k] = 0\\n    \\t\\tfor k in range(M): m[k][j] = 0\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N = len(m), len(m[0])\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j]: continue\\n    \\t\\tfor k in range(N):\\n    \\t\\t\\tif m[i][k] != 0: m[i][k] = \\' \\'\\n    \\t\\tfor k in range(M):\\n    \\t\\t\\tif m[k][j] != 0: m[k][j] = \\' \\'\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j] == \\' \\': m[i][j] = 0\\n\\t\\t\\t\\n\\t\\t\\t\\n```\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N, = len(m), len(m[0])\\n    \\tR, C = [i for i,j in enumerate(m) if 0 in j], [i for i,j in enumerate(zip(*m)) if 0 in j]\\n    \\tfor i,j in itertools.product(R,range(N)): m[i][j] = 0\\n    \\tfor i,j in itertools.product(C,range(M)): m[j][i] = 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208830,
                "title": "javascript-o-n-m-time-o-1-space-first-row-col-flags",
                "content": "```javascript\\n/**\\n * Time: O(n * m)\\n * Space: O(1)\\n * n - number of rows in matrix\\n * m - number of cols in matrix\\n */\\n\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nfunction setZeroes(matrix) {\\n  let firstColHasZero = false;\\n  let firstRowHasZero = false;\\n\\n  // Check if first col has zero\\n  for (let i = 0; i < matrix.length; i++) {\\n    if (matrix[i][0] === 0) {\\n      firstColHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Check if first row has zero\\n  for (let j = 0; j < matrix[0].length; j++) {\\n    if (matrix[0][j] === 0) {\\n      firstRowHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Use first row and col as flags, set matrix[i][0] and matrix[0][j] to 0 if matrix[i][j] is 0\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out cells based on flags in first row and col\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][0] === 0 || matrix[0][j] === 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out first col\\n  if (firstColHasZero) {\\n    for (let i = 0; i < matrix.length; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n\\n  // Zero out first row\\n  if (firstRowHasZero) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      matrix[0][j] = 0;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Time: O(n * m)\\n * Space: O(1)\\n * n - number of rows in matrix\\n * m - number of cols in matrix\\n */\\n\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nfunction setZeroes(matrix) {\\n  let firstColHasZero = false;\\n  let firstRowHasZero = false;\\n\\n  // Check if first col has zero\\n  for (let i = 0; i < matrix.length; i++) {\\n    if (matrix[i][0] === 0) {\\n      firstColHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Check if first row has zero\\n  for (let j = 0; j < matrix[0].length; j++) {\\n    if (matrix[0][j] === 0) {\\n      firstRowHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Use first row and col as flags, set matrix[i][0] and matrix[0][j] to 0 if matrix[i][j] is 0\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out cells based on flags in first row and col\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][0] === 0 || matrix[0][j] === 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out first col\\n  if (firstColHasZero) {\\n    for (let i = 0; i < matrix.length; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n\\n  // Zero out first row\\n  if (firstRowHasZero) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      matrix[0][j] = 0;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26039,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Set Matrix Zeroes** https://leetcode.com/problems/set-matrix-zeroes/\\n\\n**Algorithm**\\n1. Encode the state of each row in matrix[i,0].\\n2. Encode the state of each col in matrix[0,j].\\n3. During steps 1 and 2, maintain two boolean variables to keep status of row 0 and column 0. Why do we need these variables? Imagine we have matrix[3,4] = 0. We will mark matrix[3,0] and matrix[0,4] as 0. This does not mean we should strike row 0 as zero since no element in row 0 were zero. Hence the two variables.\\n4. While filling, first fill all sections of the matrix except zero row and zero col. Fill zero row and col only if zero_row or zero_col are marked true.\\n\\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n = len(matrix),len(matrix[0])\\n        zero_row, zero_col = False, False\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n                    zero_row = True if i == 0 else zero_row\\n                    zero_col = True if j == 0 else zero_col\\n\\n        for j in range(1,n):\\n            if matrix[0][j] == 0:\\n                for i in range(1, m):\\n                    matrix[i][j] = 0\\n        \\n        for i in range(1,m):\\n            if matrix[i][0] == 0:\\n                for j in range(1, n):\\n                    matrix[i][j] = 0\\n        \\n        if zero_row:\\n            for j in range(n):\\n                matrix[0][j] = 0\\n                \\n        if zero_col:\\n            for i in range(m):\\n                matrix[i][0] = 0\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n = len(matrix),len(matrix[0])\\n        zero_row, zero_col = False, False\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n                    zero_row = True if i == 0 else zero_row\\n                    zero_col = True if j == 0 else zero_col\\n\\n        for j in range(1,n):\\n            if matrix[0][j] == 0:\\n                for i in range(1, m):\\n                    matrix[i][j] = 0\\n        \\n        for i in range(1,m):\\n            if matrix[i][0] == 0:\\n                for j in range(1, n):\\n                    matrix[i][j] = 0\\n        \\n        if zero_row:\\n            for j in range(n):\\n                matrix[0][j] = 0\\n                \\n        if zero_col:\\n            for i in range(m):\\n                matrix[i][0] = 0\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400855,
                "title": "c-easy-clean-solution-o-1-implementation",
                "content": "**Solution:**\\n\\nApproach\\n1. First check if there is any `0` in the first row or column and set the respective flag(`row, col`) to `1`.\\n2. Now, iterate from `row 2` and `column 2` and check if there is any zero present; fill the first row index `ar[0][j] = 0` and first column index `ar[i][0] = 0`.\\n3. Our first row and first column determine which rows and columns should be fully set to `0`.\\n4. Now, check if flag `row == 1`, means our first row itself should be made `0`.\\n5. Finally, check if flag `col == 1`, means our first column itself should be made `0`.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& ar) {\\n        int n = ar.size();\\n        int m = ar[0].size();\\n        int row = 0, col = 0;\\n        for(int i = 0; i < m; i++){\\n            if(ar[0][i] == 0){\\n                row = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(ar[i][0] == 0){\\n                col = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                if(ar[i][j] == 0){\\n                    ar[i][0] = 0;\\n                    ar[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 1; i < n; i++){\\n            if(ar[i][0] == 0)\\n                for(int j = 0; j < m; j++)\\n                    ar[i][j] = 0;\\n        }\\n        for(int i = 1; i < m; i++){\\n            if(ar[0][i] == 0)\\n                for(int j = 0; j < n; j++)\\n                    ar[j][i] = 0;\\n        }\\n        if(row == 1){\\n            for(int i = 0; i < m; i++)\\n                ar[0][i] = 0;\\n        }\\n        if(col == 1){\\n            for(int i = 0; i < n; i++)\\n                ar[i][0] = 0;\\n        }\\n    }\\n};\\n```\\n**Feel free to share your ideas or any improvements as well.**\\n",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& ar) {\\n        int n = ar.size();\\n        int m = ar[0].size();\\n        int row = 0, col = 0;\\n        for(int i = 0; i < m; i++){\\n            if(ar[0][i] == 0){\\n                row = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(ar[i][0] == 0){\\n                col = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                if(ar[i][j] == 0){\\n                    ar[i][0] = 0;\\n                    ar[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 1; i < n; i++){\\n            if(ar[i][0] == 0)\\n                for(int j = 0; j < m; j++)\\n                    ar[i][j] = 0;\\n        }\\n        for(int i = 1; i < m; i++){\\n            if(ar[0][i] == 0)\\n                for(int j = 0; j < n; j++)\\n                    ar[j][i] = 0;\\n        }\\n        if(row == 1){\\n            for(int i = 0; i < m; i++)\\n                ar[0][i] = 0;\\n        }\\n        if(col == 1){\\n            for(int i = 0; i < n; i++)\\n                ar[i][0] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370007,
                "title": "o-n-space-solution-to-o-1-space-solution-in-c-diagram-included",
                "content": "**We can have a simple trivial solution by maintaining 2 arrays(1 for rows and 1 for columns)**\\n\\nWe traverse the Matrix and if we find a 0 we mark the row and column arrays as 1(in those index), then after traversing the whole array we again traverse the whole array to set the matrix as 0.\\n\\nTry dry running with this example\\n<img src=\"https://assets.leetcode.com/users/images/624d7294-3ebd-4ec4-8987-f8050e3d8ce6_1627550828.8580964.png\" alt=\"drawing\" width=\"500\"/>\\n\\nCode : \\n```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\tint row[n],col[m]; //This is the matrix where we maintain if 0th row or 3rd column has to be set to 0\\n\\tmemset(row,0,sizeof(row));\\n\\tmemset(col,0,sizeof(col));\\n\\n\\t//if row[index] is set a 1 means we have to set the entire row\\n\\tfor(int i = 0;i<n;i++)\\n\\t{   \\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) row[i] = 1,col[j] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t//after find which rows and columns have to be set to 0\\n\\t//We just traverse the matrix again and set them as 0;\\n\\tfor(int i = 0;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t\\tif(row[i] == 1 || col[j] == 1)\\n\\t\\t\\t\\tmat[i][j] = 0;\\n\\t}\\n```\\n\\n**Optimal solution  (Read the above solution first)**\\n\\nTo Optimize this we use the top row and first column as marked in the diagram, We use top row to store if a column has to be set to 0 and first column to store if we have to set a row to 0\\n\\nTry dry running with this example\\n<img src=\"https://assets.leetcode.com/users/images/cc4db96e-07b1-43f6-bfcc-623f94acb9c6_1627552363.9453866.png\" alt=\"drawing\" width=\"500\"/>\\n\\nCode:\\n```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\n\\t//Rzero is used to check if the top row has to be set to 0\\n\\tint Rzero = 0,Czero = 0;\\n\\n\\t//Rzero is set to 1 if we have a 0 in the top row\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(mat[i][0] == 0) Rzero = 1;\\n\\n\\t//Same logic is applied for the first column\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(mat[0][i] == 0) Czero = 1;\\n\\n\\t//same the previous solution we store we have to set a row or column to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) mat[i][0]=mat[0][j]=0;\\n\\t\\t}\\n\\t}\\n\\n\\t//we then actually then set them to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 1;j<m;j++)\\n\\t\\t\\tif(mat[i][0] == 0 || mat[0][j] == 0) mat[i][j] = 0;\\n\\t}\\n\\n\\t//top row and first col are set to 0 \\n\\t//if there was a 0 in them\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(Rzero) mat[i][0] = 0;\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(Czero) mat[0][i] = 0;\\n```\\n\\nIf you have any doubts hit me in the comments below.\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\tint row[n],col[m]; //This is the matrix where we maintain if 0th row or 3rd column has to be set to 0\\n\\tmemset(row,0,sizeof(row));\\n\\tmemset(col,0,sizeof(col));\\n\\n\\t//if row[index] is set a 1 means we have to set the entire row\\n\\tfor(int i = 0;i<n;i++)\\n\\t{   \\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) row[i] = 1,col[j] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t//after find which rows and columns have to be set to 0\\n\\t//We just traverse the matrix again and set them as 0;\\n\\tfor(int i = 0;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t\\tif(row[i] == 1 || col[j] == 1)\\n\\t\\t\\t\\tmat[i][j] = 0;\\n\\t}\\n```\n```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\n\\t//Rzero is used to check if the top row has to be set to 0\\n\\tint Rzero = 0,Czero = 0;\\n\\n\\t//Rzero is set to 1 if we have a 0 in the top row\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(mat[i][0] == 0) Rzero = 1;\\n\\n\\t//Same logic is applied for the first column\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(mat[0][i] == 0) Czero = 1;\\n\\n\\t//same the previous solution we store we have to set a row or column to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) mat[i][0]=mat[0][j]=0;\\n\\t\\t}\\n\\t}\\n\\n\\t//we then actually then set them to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 1;j<m;j++)\\n\\t\\t\\tif(mat[i][0] == 0 || mat[0][j] == 0) mat[i][j] = 0;\\n\\t}\\n\\n\\t//top row and first col are set to 0 \\n\\t//if there was a 0 in them\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(Rzero) mat[i][0] = 0;\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(Czero) mat[0][i] = 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124948,
                "title": "c-clean-o-1-space-sol-detailed-explanation",
                "content": "```\\n/*\\n    \\n    https://leetcode.com/problems/set-matrix-zeroes/solution/\\n    \\n    Idea is to use 1st row and 1st col to save the 0 reset status\\n    for the rows and cols. Now since position [0][0] will overlap\\n    between the row and col status vector, we use 2 separate variables \\n    just to save whether 1st row/col needs a reset or not.\\n    \\n    TC: O(MN)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // saves the reset status of row and col resp.\\n        int first_row = matrix[0][0], first_col = matrix[0][0];\\n        // check the first col and row, if either needs a reset to 0\\n        // col check\\n        for(int i = 0; first_col && i < matrix.size(); i++)\\n            if(!matrix[i][0]) \\n                first_col = 0; \\n            \\n        // row check\\n        for(int i = 0; first_row && i < matrix[0].size(); i++)\\n            if(!matrix[0][i]) \\n                first_row = 0; \\n        \\n        // We will use the first row to save all the col status, first \\n        // col to save all the row status\\n        // If some col/row needs a reset, the info will be saved there\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(!matrix[i][j]) \\n                    matrix[0][j] = matrix[i][0] = 0;\\n            }\\n        \\n        // set the 0 values\\n        for(int i = 1; i < matrix.size(); i++)\\n            for(int j = 1; j < matrix[0].size(); j++)\\n                if(!matrix[0][j] || !matrix[i][0])\\n                    matrix[i][j] = 0;\\n        // check if the first row and col needs a reset\\n        if(!first_col) \\n            for(int i = 0; i < matrix.size(); i++)\\n                matrix[i][0] = 0;  \\n        if(!first_row)\\n            for(int i = 0; i < matrix[0].size(); i++)\\n                matrix[0][i] = 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    \\n    https://leetcode.com/problems/set-matrix-zeroes/solution/\\n    \\n    Idea is to use 1st row and 1st col to save the 0 reset status\\n    for the rows and cols. Now since position [0][0] will overlap\\n    between the row and col status vector, we use 2 separate variables \\n    just to save whether 1st row/col needs a reset or not.\\n    \\n    TC: O(MN)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // saves the reset status of row and col resp.\\n        int first_row = matrix[0][0], first_col = matrix[0][0];\\n        // check the first col and row, if either needs a reset to 0\\n        // col check\\n        for(int i = 0; first_col && i < matrix.size(); i++)\\n            if(!matrix[i][0]) \\n                first_col = 0; \\n            \\n        // row check\\n        for(int i = 0; first_row && i < matrix[0].size(); i++)\\n            if(!matrix[0][i]) \\n                first_row = 0; \\n        \\n        // We will use the first row to save all the col status, first \\n        // col to save all the row status\\n        // If some col/row needs a reset, the info will be saved there\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(!matrix[i][j]) \\n                    matrix[0][j] = matrix[i][0] = 0;\\n            }\\n        \\n        // set the 0 values\\n        for(int i = 1; i < matrix.size(); i++)\\n            for(int j = 1; j < matrix[0].size(); j++)\\n                if(!matrix[0][j] || !matrix[i][0])\\n                    matrix[i][j] = 0;\\n        // check if the first row and col needs a reset\\n        if(!first_col) \\n            for(int i = 0; i < matrix.size(); i++)\\n                matrix[i][0] = 0;  \\n        if(!first_row)\\n            for(int i = 0; i < matrix[0].size(); i++)\\n                matrix[0][i] = 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26040,
                "title": "very-short-python-solution-with-o-1-space-complexity-13-lines-of-code",
                "content": "Idea is as follow:\\nIts only necessary to find out which row and column contains 0. After this step, change all elements in certain row and column to 0. If no 0 exists, do nothing.\\n\\n```\\n# Two sets that record which row and column has 0\\nrowSet = set()\\ncolSet = set()\\n# Iterate each element. \\n# If it is 0, record row and column number\\nfor r in range(len(matrix)):\\n    for c in range(len(matrix[0])):\\n        if matrix[r][c] == 0:\\n            rowSet.add(r)\\n            colSet.add(c)\\n# Change all rows containing 0 to 0\\nfor r in rowSet:\\n    for c in range(len(matrix[0])):\\n        matrix[r][c] = 0\\n# Change all columns containing 0 to 0\\nfor c in colSet:\\n    for r in range(len(matrix)):\\n        matrix[r][c] = 0\\n```",
                "solutionTags": [],
                "code": "```\\n# Two sets that record which row and column has 0\\nrowSet = set()\\ncolSet = set()\\n# Iterate each element. \\n# If it is 0, record row and column number\\nfor r in range(len(matrix)):\\n    for c in range(len(matrix[0])):\\n        if matrix[r][c] == 0:\\n            rowSet.add(r)\\n            colSet.add(c)\\n# Change all rows containing 0 to 0\\nfor r in rowSet:\\n    for c in range(len(matrix[0])):\\n        matrix[r][c] = 0\\n# Change all columns containing 0 to 0\\nfor c in colSet:\\n    for r in range(len(matrix)):\\n        matrix[r][c] = 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26181,
                "title": "java-constant-space-solution-hint-use-space-inside-the-matrix",
                "content": "An easy way to solve this problem is to use extra O(m + n) space, storing the zero row and column indices. \\n\\nWe can improve it by not using the extra O(m + n) space, instead, we can use the space inside that input matrix (inspired by **Shangrila**'s solution, which use the first row and column for storage).\\n\\nIn this solution, at the beginning, I find the first zero element, and use that row and column as the temp place for storing the other zero element indices. After we get all the zero indices, then set the corresponding row and columns to zero. Please see the code below.\\n\\n    public void setZeroes(int[][] matrix) {\\n        int rowTemp = -1;   // select a row to store the column indices for the zero element\\n        int colTemp = -1;   // select a column to store the row indices for the zero element\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    // find the first zero element\\n                    if (rowTemp == -1) {\\n                        rowTemp = i;\\n                        colTemp = j;\\n                    }\\n                    // update indice in the row and column temp\\n                    else {\\n                        matrix[rowTemp][j] = 0;\\n                        matrix[i][colTemp] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        // no zero in the matrix\\n        if (rowTemp == -1)\\n            return;\\n        // set rows to zero\\n        for (int i = 0; i < matrix.length; i++) {\\n            if (i == rowTemp)   // skip the temp row\\n                continue;\\n            if (matrix[i][colTemp] == 0) {\\n                for (int j = 0; j < matrix[0].length; j++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set columns to zero\\n        for (int j = 0; j < matrix[0].length; j++) {\\n            if (matrix[rowTemp][j] == 0) {\\n                for (int i = 0; i < matrix.length; i++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set the final temp row to zero\\n        for (int j = 0; j < matrix[0].length; j++)\\n            matrix[rowTemp][j] = 0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "An easy way to solve this problem is to use extra O(m + n) space, storing the zero row and column indices. \\n\\nWe can improve it by not using the extra O(m + n) space, instead, we can use the space inside that input matrix (inspired by **Shangrila**'s solution, which use the first row and column for storage).\\n\\nIn this solution, at the beginning, I find the first zero element, and use that row and column as the temp place for storing the other zero element indices. After we get all the zero indices, then set the corresponding row and columns to zero. Please see the code below.\\n\\n    public void setZeroes(int[][] matrix) {\\n        int rowTemp = -1;   // select a row to store the column indices for the zero element\\n        int colTemp = -1;   // select a column to store the row indices for the zero element\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    // find the first zero element\\n                    if (rowTemp == -1) {\\n                        rowTemp = i;\\n                        colTemp = j;\\n                    }\\n                    // update indice in the row and column temp\\n                    else {\\n                        matrix[rowTemp][j] = 0;\\n                        matrix[i][colTemp] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        // no zero in the matrix\\n        if (rowTemp == -1)\\n            return;\\n        // set rows to zero\\n        for (int i = 0; i < matrix.length; i++) {\\n            if (i == rowTemp)   // skip the temp row\\n                continue;\\n            if (matrix[i][colTemp] == 0) {\\n                for (int j = 0; j < matrix[0].length; j++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set columns to zero\\n        for (int j = 0; j < matrix[0].length; j++) {\\n            if (matrix[rowTemp][j] == 0) {\\n                for (int i = 0; i < matrix.length; i++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set the final temp row to zero\\n        for (int j = 0; j < matrix[0].length; j++)\\n            matrix[rowTemp][j] = 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3807640,
                "title": "c-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this approach,I have initialsed 2 unordered maps(one for rows and one for columns) for keeping the record weather a row or column contains a zero in it or not.For it I just traversed through the 2D array and once I get a zero, updated the value of that row and column to 1 in map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversed through the array, if arr[i][j] == 0 then I just set map[i] = 1 and map2[j] = 1.\\nIn second iteration, if any one i and j in matrix is found to be 1, I\\'m updating the value in the original array as 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor this code we\\'re just interating the array twice hence the complexity is : O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe\\'re using two maps which are of length N and M.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_map<int,int>ump;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    ump[i]=1;\\n                    mp[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(ump[i] || mp[j]){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n\\n        \\n        \\n    }\\n};\\n```\\nYour valuable suggestions and even minor optimizations in the code will be warmly welcomed and greatly appreciated.\\n\\nPlease upvote if you like the solution. :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_map<int,int>ump;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    ump[i]=1;\\n                    mp[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(ump[i] || mp[j]){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596062,
                "title": "shortest-solution-using-hashset-o-m-n-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Here whenever we find the 0 element in the matrix we add its row and column to the  relative set.\\n- Since its a set data structure , no two same row or column will be added.\\n- Then we iterate through each row and column in the set and fill the matrix with 0\\'s.\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n        for(int r : row){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[r][i] = 0;\\n            }\\n        }\\n        for(int c : col){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][c] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n        for(int r : row){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[r][i] = 0;\\n            }\\n        }\\n        for(int c : col){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][c] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276573,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O ( m*n )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O( Math.max( n , m ))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int row[] = new int[n];\\n        int col[] = new int[m];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if( arr[i][j] ==0 )\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if( row[i]==1 )\\n            {\\n                for (int j = 0; j < m; j++) {\\n                    arr[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if( col[j]==1 )\\n            {\\n                for (int i = 0; i < n; i++) {\\n                    arr[i][j] = 0 ;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int row[] = new int[n];\\n        int col[] = new int[m];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if( arr[i][j] ==0 )\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if( row[i]==1 )\\n            {\\n                for (int j = 0; j < m; j++) {\\n                    arr[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if( col[j]==1 )\\n            {\\n                for (int i = 0; i < n; i++) {\\n                    arr[i][j] = 0 ;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840148,
                "title": "c-easy-fast-and-short-9-lines-solution",
                "content": "This solution is very short, simple.\\nThe process is divided into three parts.\\n\\n1. Traverse the matrix and finds 0. If it finds 0, it insert row and column in set `rows`, `cols`.\\n2. Iterate through the row(`rows`) and fill in zeros.\\n3. Iterate through the column(`cols`), fill in zeros.\\n\\n```\\n// origin - https://github.com/o-oppang/lets-solve-algorithm\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows, cols;\\n        for( auto i = 0; i < matrix.size(); ++i ) // row\\n            for( auto j = 0; j < matrix[0].size(); ++j ) // col\\n                if( matrix[i][j] == 0 )  { rows.insert(i); cols.insert(j); }\\n        \\n        for( auto row : rows ) // fill rows to zero\\n            std::fill(matrix[row].begin(), matrix[row].end(), 0);\\n        \\n        for( auto col : cols ) // fill cols to zero\\n            for( auto row = 0; row < matrix.size(); ++row )\\n                std::fill(matrix[row].begin() + col, matrix[row].begin() + col + 1, 0);\\n    }\\n};\\n// Runtime: 24 ms, faster than 94.25% of C++ online submissions for Set Matrix Zeroes.\\n// Memory Usage: 13.3 MB, less than 49.73% of C++ online submissions for Set Matrix Zeroes.\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// origin - https://github.com/o-oppang/lets-solve-algorithm\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows, cols;\\n        for( auto i = 0; i < matrix.size(); ++i ) // row\\n            for( auto j = 0; j < matrix[0].size(); ++j ) // col\\n                if( matrix[i][j] == 0 )  { rows.insert(i); cols.insert(j); }\\n        \\n        for( auto row : rows ) // fill rows to zero\\n            std::fill(matrix[row].begin(), matrix[row].end(), 0);\\n        \\n        for( auto col : cols ) // fill cols to zero\\n            for( auto row = 0; row < matrix.size(); ++row )\\n                std::fill(matrix[row].begin() + col, matrix[row].begin() + col + 1, 0);\\n    }\\n};\\n// Runtime: 24 ms, faster than 94.25% of C++ online submissions for Set Matrix Zeroes.\\n// Memory Usage: 13.3 MB, less than 49.73% of C++ online submissions for Set Matrix Zeroes.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522715,
                "title": "java-o-1-space-with-explanation",
                "content": "Thinking Processing: \\n1. First, Let\\'s come out O(m+n) Space solution, which is very directly. We need two arrays to store rows and columns status. It looks like a head of a line to check its line\\'s status. When we loop each point, we just need to update its two headers\\' status. If current point\\'s value is 0, we set its headers to true. After finishing all points\\' loop, we loop the matrix again to update the matrix by checking this two arrays\\' info. When we reach a point, we check its x-coordinate and y-coordinate\\'s arrays status, if true, set current point value to 0. \\nHere I draw a picture to show the idea.\\n![image](https://assets.leetcode.com/users/haimei2/image_1582846410.png)\\nHere are the code: \\n```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean[] rows = new boolean[m];\\n        boolean[] cols = new boolean[n];\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]&&cols[j]) continue;\\n                if (matrix[i][j]==0) {\\n                    rows[i] = true;\\n                    cols[j] = true;\\n                }\\n            }\\n        }\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]||cols[j]) matrix[i][j] = 0;\\n            }\\n        }\\n    }\\n```\\n2. In order to reduce space, we can apply rows[] and cols[]\\'s role to matrix\\'s first row and first column. When we loop the matrix, we update matrix[i][0] and matrix[0][j] status, like rows and cols array. And then when we need to update the whole matrix, we can udpate point(i,j) value according to matrix[i][0] and matrix[0][j], here i and j are starting from 1!!! So how about the first row and first column point\\'s update? We just need additional two variables to help: two boolean varaibles: firstrow and firstcol. \\n![image](https://assets.leetcode.com/users/haimei2/image_1582847354.png)\\n\\nTest Cases:\\n1. []\\n2. [1]\\n3. [[1,1,1],\\n  [1,0,1],\\n  [1,1,1]]  // without firstrow and firstcol help\\n4. [[0,1,2,0],\\n      [3,4,5,2],\\n      [1,3,1,5]] // with firstrow and firstcol help\\n\\t  \\nTime Complexity is O(m\\\\*n)\\n\\nSpace Complexity is O(1)\\n\\n```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean firstrow = false;\\n        boolean firstcol = false;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                    if (i==0) firstrow = true;\\n                    if (j==0) firstcol = true;\\n                }\\n            }\\n        }\\n        for (int i=1; i<m; i++) {\\n            for (int j=1; j<n; j++) {\\n                if (matrix[i][0]==0||matrix[0][j]==0) \\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        if (firstrow) {\\n            for (int j=0; j<n; j++) matrix[0][j] = 0;\\n        }\\n        if (firstcol) {\\n            for (int i=0; i<m; i++) matrix[i][0] = 0;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean[] rows = new boolean[m];\\n        boolean[] cols = new boolean[n];\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]&&cols[j]) continue;\\n                if (matrix[i][j]==0) {\\n                    rows[i] = true;\\n                    cols[j] = true;\\n                }\\n            }\\n        }\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]||cols[j]) matrix[i][j] = 0;\\n            }\\n        }\\n    }\\n```\n```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean firstrow = false;\\n        boolean firstcol = false;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                    if (i==0) firstrow = true;\\n                    if (j==0) firstcol = true;\\n                }\\n            }\\n        }\\n        for (int i=1; i<m; i++) {\\n            for (int j=1; j<n; j++) {\\n                if (matrix[i][0]==0||matrix[0][j]==0) \\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        if (firstrow) {\\n            for (int j=0; j<n; j++) matrix[0][j] = 0;\\n        }\\n        if (firstcol) {\\n            for (int i=0; i<m; i++) matrix[i][0] = 0;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490917,
                "title": "java-easy-and-short-solution-with-explanation",
                "content": "We plan to use the firstRow and firstCol of the matrix to store the state of entire row and matrix. \\n\\n**BUT**\\n\\nDoing this, we might loose the state of the firstRow and firstCol. So we use two variables isFirstRowZero and isFirstColZero to store the state of irstRow and firstCol and later use it to restore them to their correct state. \\n\\nBelow is the solution is with comments for better understanding :)\\n```\\npublic void setZeroes(int[][] matrix) {\\n        \\n\\t// The below two vars store the state of first row and first col\\n\\tboolean isFirstRowZero = false , isFirstColZero = false;\\n\\n\\tfor(int i=0; i<matrix.length; i++) \\n\\t\\tfor(int j=0; j<matrix[0].length; j++) \\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tif(i == 0) isFirstRowZero = true;       // Store state of firstRow\\n\\t\\t\\t\\tif(j == 0) isFirstColZero = true;       // Store state of firstCol\\n\\t\\t\\t\\tmatrix[0][j] = 0;                       // Store state of other row in firstRow\\n\\t\\t\\t\\tmatrix[i][0] = 0;                       // Store state of other col in firstCol\\n\\t\\t\\t}\\n\\n\\tfor(int i=1; i<matrix.length; i++) \\n\\t\\tfor(int j=1; j<matrix[0].length; j++)\\n\\t\\t\\tif(matrix[i][0] == 0 || matrix[0][j] == 0)  // If the first cell of row or col is zero \\n\\t\\t\\t\\tmatrix[i][j] = 0;                       // Mark the current cell as 0\\n\\n\\tif(isFirstRowZero)                                  // if entire firstRow is to be zero\\n\\t\\tfor(int i=0; i<matrix[0].length; i++)\\n\\t\\t\\tmatrix[0][i] = 0;                           // make them all zero\\n\\n\\tif(isFirstColZero)                                  // if entire firstCol is to be zero\\n\\t\\tfor(int i=0; i<matrix.length; i++)\\n\\t\\t\\tmatrix[i][0] = 0;                           // make them all zero\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void setZeroes(int[][] matrix) {\\n        \\n\\t// The below two vars store the state of first row and first col\\n\\tboolean isFirstRowZero = false , isFirstColZero = false;\\n\\n\\tfor(int i=0; i<matrix.length; i++) \\n\\t\\tfor(int j=0; j<matrix[0].length; j++) \\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tif(i == 0) isFirstRowZero = true;       // Store state of firstRow\\n\\t\\t\\t\\tif(j == 0) isFirstColZero = true;       // Store state of firstCol\\n\\t\\t\\t\\tmatrix[0][j] = 0;                       // Store state of other row in firstRow\\n\\t\\t\\t\\tmatrix[i][0] = 0;                       // Store state of other col in firstCol\\n\\t\\t\\t}\\n\\n\\tfor(int i=1; i<matrix.length; i++) \\n\\t\\tfor(int j=1; j<matrix[0].length; j++)\\n\\t\\t\\tif(matrix[i][0] == 0 || matrix[0][j] == 0)  // If the first cell of row or col is zero \\n\\t\\t\\t\\tmatrix[i][j] = 0;                       // Mark the current cell as 0\\n\\n\\tif(isFirstRowZero)                                  // if entire firstRow is to be zero\\n\\t\\tfor(int i=0; i<matrix[0].length; i++)\\n\\t\\t\\tmatrix[0][i] = 0;                           // make them all zero\\n\\n\\tif(isFirstColZero)                                  // if entire firstCol is to be zero\\n\\t\\tfor(int i=0; i<matrix.length; i++)\\n\\t\\t\\tmatrix[i][0] = 0;                           // make them all zero\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390800,
                "title": "javascript-solution-memory-usage-beats-90",
                "content": "```\\nvar setZeroes = function(matrix) {\\n  let xs = new Set();\\n  let ys = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j]) {\\n        continue;\\n      } else {\\n        xs.add(i);\\n        ys.add(j);\\n      }\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (xs.has(i) || ys.has(j)) {\\n        matrix[i][j] = 0;\\n      } else {\\n        continue;\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n  let xs = new Set();\\n  let ys = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j]) {\\n        continue;\\n      } else {\\n        xs.add(i);\\n        ys.add(j);\\n      }\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (xs.has(i) || ys.has(j)) {\\n        matrix[i][j] = 0;\\n      } else {\\n        continue;\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213817,
                "title": "my-4-line-code-for-python",
                "content": "```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        points = [[i,j] for i in range(len(matrix)) for j in range(len(matrix[i])) if matrix[i][j] == 0]\\n        for i, a in enumerate(points):\\n            matrix[a[0]] = [0 for k in range(len(matrix[0]))]\\n            for k in range(len(matrix)): matrix[k][a[1]] = 0        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        points = [[i,j] for i in range(len(matrix)) for j in range(len(matrix[i])) if matrix[i][j] == 0]\\n        for i, a in enumerate(points):\\n            matrix[a[0]] = [0 for k in range(len(matrix[0]))]\\n            for k in range(len(matrix)): matrix[k][a[1]] = 0        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554878,
                "title": "best-o-1-space-solution",
                "content": "# Approach \\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void makeRowZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int j = 0; j < col; j++)\\n            matrix[row][j] = 0;    \\n    }  \\n    void makeColZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int i = 0; i < row; i++)\\n            matrix[i][col] = 0;    \\n    }    \\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        int col0 = 1;\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    if (j != 0)\\n                        matrix[0][j] = 0;\\n                    else\\n                        col0 = 0;      \\n                }\\n            }\\n        }\\n        for (int j = 1; j < c; j++) {\\n            if (matrix[0][j] == 0) \\n                makeColZero(matrix, r, j);\\n        }\\n        for (int i = 0; i < r; i++) {\\n            if (matrix[i][0] == 0) \\n                makeRowZero(matrix, i, c);\\n        }\\n        if (col0 == 0)\\n            makeColZero(matrix, r, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void makeRowZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int j = 0; j < col; j++)\\n            matrix[row][j] = 0;    \\n    }  \\n    void makeColZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int i = 0; i < row; i++)\\n            matrix[i][col] = 0;    \\n    }    \\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        int col0 = 1;\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    if (j != 0)\\n                        matrix[0][j] = 0;\\n                    else\\n                        col0 = 0;      \\n                }\\n            }\\n        }\\n        for (int j = 1; j < c; j++) {\\n            if (matrix[0][j] == 0) \\n                makeColZero(matrix, r, j);\\n        }\\n        for (int i = 0; i < r; i++) {\\n            if (matrix[i][0] == 0) \\n                makeRowZero(matrix, i, c);\\n        }\\n        if (col0 == 0)\\n            makeColZero(matrix, r, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365254,
                "title": "using-same-matrix-o-m-n-easy-to-understand-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'ll use 0th column and 0th row to set all other rows and column to zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.First we\\'ll traverse thorugh first row and first column of the matrix(0th row and 0th column).\\nWhenever we find 0 in this row we\\'ll set isrow0 to true.\\nSimilarly, whenever we find 0 in this column we\\'ll set iscol0 to true.\\nThis will be used later.\\n2.Now we\\'ll go through the entire matrix(Except the 0th row and 0th column).\\nWhenever 0 is encountered we\\'ll set that row\\'s first column\\'s element to 0.\\nSimilarly, we\\'ll set that column\\'s first row\\'s element to 0.\\n3.After that, we go through the matrix one more time and for any row or column where the first element is zero, we set all of the other elements in that row or column to zero as well.\\n4.lastly, we\\'ll set the entire 0th row and 0th column to zero if isrow0 and iscol0 is true respectively.\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length,n=matrix[0].length;\\n        boolean isrow0=false,iscol0=false;\\n        int i,j;\\n        for(i=0;i<m;i++)\\n        {\\n          if(matrix[i][0]==0)\\n          {\\n            isrow0=true;\\n          }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n          if(matrix[0][i]==0)\\n          {\\n            iscol0=true;\\n          }\\n        }\\n        for(i=1;i<m;i++)\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][j]==0)\\n            {\\n              matrix[0][j]=0;//0th row of column j\\n              matrix[i][0]=0;//0th column of row i\\n            }\\n          }\\n        }\\n        for(i=1;i<m;i++)//traversing again\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][0]==0 || matrix[0][j]==0)\\n            {\\n              matrix[i][j]=0;\\n            }\\n          }\\n        }\\n        if(isrow0)\\n        {\\n          for(i=0;i<m;i++)\\n          {\\n            matrix[i][0]=0;\\n          }\\n        }\\n        if(iscol0)\\n        {\\n          for(j=0;j<n;j++)\\n          {\\n            matrix[0][j]=0;\\n          }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length,n=matrix[0].length;\\n        boolean isrow0=false,iscol0=false;\\n        int i,j;\\n        for(i=0;i<m;i++)\\n        {\\n          if(matrix[i][0]==0)\\n          {\\n            isrow0=true;\\n          }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n          if(matrix[0][i]==0)\\n          {\\n            iscol0=true;\\n          }\\n        }\\n        for(i=1;i<m;i++)\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][j]==0)\\n            {\\n              matrix[0][j]=0;//0th row of column j\\n              matrix[i][0]=0;//0th column of row i\\n            }\\n          }\\n        }\\n        for(i=1;i<m;i++)//traversing again\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][0]==0 || matrix[0][j]==0)\\n            {\\n              matrix[i][j]=0;\\n            }\\n          }\\n        }\\n        if(isrow0)\\n        {\\n          for(i=0;i<m;i++)\\n          {\\n            matrix[i][0]=0;\\n          }\\n        }\\n        if(iscol0)\\n        {\\n          for(j=0;j<n;j++)\\n          {\\n            matrix[0][j]=0;\\n          }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289339,
                "title": "short-easy-very-clearly-explained-step-by-step-python",
                "content": "# SOLUTION\\n\\n```\\nclass Solution:\\n  def setZeroes(self, matrix):\\n    zero_rows, zero_cols = set(), set()\\n    for i in range(len(matrix)):\\n        for j in range(len(matrix[0])):\\n            if matrix[i][j] == 0:\\n                zero_rows.add(i)\\n                zero_cols.add(j)\\n    for i in zero_rows:\\n        matrix[i] = [0] * len(matrix[0])\\n    for j in zero_cols:\\n        for i in range(len(matrix)):\\n            matrix[i][j] = 0\\n\\n\\n```\\n# STEP-BY-STEP EXPLANATION\\n    zero_rows, zero_cols = set(), set()\\nTwo empty sets, zero_rows and zero_cols, are created to store the indices of the rows and columns with a zero value.\\n\\n    for i in range(len(matrix)):\\n        for j in range(len(matrix[0])):\\n            if matrix[i][j] == 0:\\n                zero_rows.add(i)\\n                zero_cols.add(j)\\n\\nLoops through the entire matrix and checks each element to see if it is zero. If it is, the index of the row and column are added to their respective sets, zero_rows and zero_cols.\\n\\n    for i in zero_rows:\\n        matrix[i] = [0] * len(matrix[0])\\n\\nNext loop goes through each index in zero_rows and sets the entire row to zero by creating a new list of zeros with the same length as the row and assigning it to the row.\\n\\n    for j in zero_cols:\\n        for i in range(len(matrix)):\\n            matrix[i][j] = 0\\n\\nLast loop goes through each index in zero_cols and sets the entire column to zero by looping through each row and setting the value at that column index to zero.\\n\\nThat\\'s it!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def setZeroes(self, matrix):\\n    zero_rows, zero_cols = set(), set()\\n    for i in range(len(matrix)):\\n        for j in range(len(matrix[0])):\\n            if matrix[i][j] == 0:\\n                zero_rows.add(i)\\n                zero_cols.add(j)\\n    for i in zero_rows:\\n        matrix[i] = [0] * len(matrix[0])\\n    for j in zero_cols:\\n        for i in range(len(matrix)):\\n            matrix[i][j] = 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970925,
                "title": "c-easy-to-understand-using-two-vectors",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n        \\n        int r = arr.size();\\n        int c = arr[0].size();\\n\\n        vector<int> xr,yc;\\n\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j =0;j<c;j++)\\n            {\\n                if(arr[i][j] == 0)\\n                {\\n                    xr.push_back(i);\\n                    yc.push_back(j);\\n                }\\n            }\\n        }\\n\\n        for(auto row : xr)\\n        {\\n            for(int col = 0;col<c;col++)\\n            arr[row][col] = 0;\\n        }\\n\\n        for(auto col : yc)\\n        {\\n            for(int row = 0;row<r;row++)\\n            arr[row][col] = 0;\\n        }\\n        \\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n        \\n        int r = arr.size();\\n        int c = arr[0].size();\\n\\n        vector<int> xr,yc;\\n\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j =0;j<c;j++)\\n            {\\n                if(arr[i][j] == 0)\\n                {\\n                    xr.push_back(i);\\n                    yc.push_back(j);\\n                }\\n            }\\n        }\\n\\n        for(auto row : xr)\\n        {\\n            for(int col = 0;col<c;col++)\\n            arr[row][col] = 0;\\n        }\\n\\n        for(auto col : yc)\\n        {\\n            for(int row = 0;row<r;row++)\\n            arr[row][col] = 0;\\n        }\\n        \\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933016,
                "title": "java-brute-better-optimised-3-approaches-added-explanation-for-3rd",
                "content": "### **1. Naive Approach**\\n\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        boolean[][] arr = new boolean[m][n];\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0)\\n                    arr[row][col] = true;\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(arr[row][col] == true){\\n                    helperRow(matrix, row, n);\\n                    helperCol(matrix, col, m);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void helperRow(int[][] matrix, int row, int n){\\n        for(int col = 0; col < n; ++col)\\n            matrix[row][col] = 0;\\n    }\\n    \\n    public void helperCol(int[][] matrix, int col, int m){\\n        for(int row = 0; row < m; ++row)\\n            matrix[row][col] = 0;\\n    }\\n}\\n```\\n\\n**TC = O(N^3) in worst case if matrix is of order N x N.**\\n**SC = O(N^2) in worst case if matrix is of order N x N.**\\n**Runtime 3ms, faster than 25%.**\\n\\n### **2. Better Approach**\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        Set<Integer> rows = new HashSet<>();\\n        Set<Integer> cols = new HashSet<>();\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0){\\n                    rows.add(row);\\n                    cols.add(col);\\n                }\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(rows.contains(row) || cols.contains(col))\\n                    matrix[row][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```\\n**TC = O(M x N), since all set operations used above take O(1) time.**\\n**SC = O(M + N).**\\n**Runtime 4ms, faster than 18%.**\\n\\n### **3. Optimised approach**\\n\\nHere we will consider the dummy row array and dummy column array (as used in approach 2) as row 0 and column 0 of the matrix, for checking whether the particular column or row has the value 0 or not.\\nSince matrix[0][0] are overlapping, therefore take separate variable col0(say) to check if the 0th column has 0 or not and use matrix[0][0] to check if the 0th row has 0 or not.\\nNow traverse from last element to the first element and check if matrix[i][0]==0 || matrix[0][j]==0 and if true set matrix[i][j]=0, else continue.\\n\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n        \\n        for(int row = 0; row < m; ++row){\\n            if(matrix[row][0] == 0)\\n                col0 = 0;\\n            \\n            for(int col = 1; col < n; ++col)\\n                if(matrix[row][col] == 0)\\n                    matrix[row][0] = matrix[0][col] = 0;\\n        }\\n        \\n        for(int row = m - 1; row >= 0; --row){\\n            for(int col = n - 1; col >= 1; --col)\\n                if(matrix[row][0] == 0 || matrix[0][col] == 0)\\n                    matrix[row][col] = 0;\\n            \\n            if(col0 == 0)\\n                matrix[row][0] = 0;\\n        }\\n    }\\n}\\n```\\n\\n**TC = O(M x N).**\\n**SC = O(1).**\\n**Runtime 1ms, faster than 89%.**\\n\\n**Plz upvote if you find it helpful.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        boolean[][] arr = new boolean[m][n];\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0)\\n                    arr[row][col] = true;\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(arr[row][col] == true){\\n                    helperRow(matrix, row, n);\\n                    helperCol(matrix, col, m);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void helperRow(int[][] matrix, int row, int n){\\n        for(int col = 0; col < n; ++col)\\n            matrix[row][col] = 0;\\n    }\\n    \\n    public void helperCol(int[][] matrix, int col, int m){\\n        for(int row = 0; row < m; ++row)\\n            matrix[row][col] = 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        Set<Integer> rows = new HashSet<>();\\n        Set<Integer> cols = new HashSet<>();\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0){\\n                    rows.add(row);\\n                    cols.add(col);\\n                }\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(rows.contains(row) || cols.contains(col))\\n                    matrix[row][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n        \\n        for(int row = 0; row < m; ++row){\\n            if(matrix[row][0] == 0)\\n                col0 = 0;\\n            \\n            for(int col = 1; col < n; ++col)\\n                if(matrix[row][col] == 0)\\n                    matrix[row][0] = matrix[0][col] = 0;\\n        }\\n        \\n        for(int row = m - 1; row >= 0; --row){\\n            for(int col = n - 1; col >= 1; --col)\\n                if(matrix[row][0] == 0 || matrix[0][col] == 0)\\n                    matrix[row][col] = 0;\\n            \\n            if(col0 == 0)\\n                matrix[row][0] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790756,
                "title": "c-solution-using-set-easy-fast-simple-91-38-12ms-13-4-mb",
                "content": "![image](https://assets.leetcode.com/users/images/ce857028-f902-4df8-b7c2-f9a4c5b72bde_1645509329.445337.png)\\n\\nSteps involved\\n1. Iterate once to store all rows and columns containing a `0` in two separate sets.\\n2. Iterate through set `rows` to make all elements with given row, making all elements 0\\n3. Iterare through set `cols` to make all element with given column, making all elements 0\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows;\\n        set<int> cols;\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size();j++)\\n                if(matrix[i][j] == 0) {\\n                    rows.insert(i);\\n                    cols.insert(j);\\n                }\\n\\n        for(auto x: rows) \\n            for(int j = 0; j < matrix[0].size();j++) \\n                    matrix[x][j] = 0;\\n\\n        for(auto x: cols) \\n            for(int i = 0; i < matrix.size(); i++) \\n                matrix[i][x] = 0;\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows;\\n        set<int> cols;\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size();j++)\\n                if(matrix[i][j] == 0) {\\n                    rows.insert(i);\\n                    cols.insert(j);\\n                }\\n\\n        for(auto x: rows) \\n            for(int j = 0; j < matrix[0].size();j++) \\n                    matrix[x][j] = 0;\\n\\n        for(auto x: cols) \\n            for(int i = 0; i < matrix.size(); i++) \\n                matrix[i][x] = 0;\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205739,
                "title": "java-array-1ms-beats-93-t-c-o-m-n-s-c-o-1",
                "content": "\\n    // O(m*n) O(1)\\n\\tpublic void setZeroes(int[][] matrix) {\\n\\n\\t\\tint m = matrix.length, n = matrix[0].length;\\n\\t\\tboolean row = false, col = false;\\n\\n        for (int i = 0; i < m; i++) {\\n\\t\\t\\tif (matrix[i][0] == 0) {\\n\\t\\t\\t\\tcol = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (matrix[0][i] == 0) {\\n\\t\\t\\t\\trow = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t\\t\\t\\tmatrix[0][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < m; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][0] == 0 || matrix[0][j] == 0)\\n\\t\\t\\t\\t\\tmatrix[i][j] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (row == true) {\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n\\n\\t\\tif (col == true) {\\n\\t\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(m*n) O(1)\\n\\tpublic void setZeroes(int[][] matrix) {\\n\\n\\t\\tint m = matrix.length, n = matrix[0].length;\\n\\t\\tboolean row = false, col = false;\\n\\n        for (int i = 0; i < m; i++) {\\n\\t\\t\\tif (matrix[i][0] == 0) {\\n\\t\\t\\t\\tcol = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (matrix[0][i] == 0) {\\n\\t\\t\\t\\trow = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t\\t\\t\\tmatrix[0][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < m; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][0] == 0 || matrix[0][j] == 0)\\n\\t\\t\\t\\t\\tmatrix[i][j] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (row == true) {\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n\\n\\t\\tif (col == true) {\\n\\t\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t}\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 917943,
                "title": "my-very-simple-python-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        def changeRC(r,c):\\n            \\n            for col in range(len(matrix[0])):\\n                matrix[r][col]=\\'X\\' if matrix[r][col]!=0 else 0\\n            for row in range(len(matrix)):\\n                matrix[row][c]=\\'X\\' if matrix[row][c]!=0 else 0\\n\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==0:\\n                    changeRC(r,c)\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==\\'X\\':\\n                    matrix[r][c]=0\\n                    \\n        #return matrix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        def changeRC(r,c):\\n            \\n            for col in range(len(matrix[0])):\\n                matrix[r][col]=\\'X\\' if matrix[r][col]!=0 else 0\\n            for row in range(len(matrix)):\\n                matrix[row][c]=\\'X\\' if matrix[row][c]!=0 else 0\\n\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==0:\\n                    changeRC(r,c)\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==\\'X\\':\\n                    matrix[r][c]=0\\n                    \\n        #return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691293,
                "title": "javascript-human-readable-solution",
                "content": "```javascript\\nvar setZeroes = function(matrix) {\\n    const zeroRow = new Set();\\n    const zeroCol = new Set();\\n    \\n    for(let i = 0; i < matrix.length; i++) {\\n        \\n        for(let j = 0; j < matrix[0].length; j++) {\\n            \\n            if(matrix[i][j] === 0) {\\n                zeroRow.add(i);\\n                zeroCol.add(j);\\n            }\\n        }\\n    }\\n    \\n    for(let r of zeroRow) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            matrix[r][j] = 0;\\n        }\\n    }\\n    \\n    for(let c of zeroCol) {\\n        for(let i = 0; i < matrix.length; i++) {\\n            matrix[i][c] = 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar setZeroes = function(matrix) {\\n    const zeroRow = new Set();\\n    const zeroCol = new Set();\\n    \\n    for(let i = 0; i < matrix.length; i++) {\\n        \\n        for(let j = 0; j < matrix[0].length; j++) {\\n            \\n            if(matrix[i][j] === 0) {\\n                zeroRow.add(i);\\n                zeroCol.add(j);\\n            }\\n        }\\n    }\\n    \\n    for(let r of zeroRow) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            matrix[r][j] = 0;\\n        }\\n    }\\n    \\n    for(let c of zeroCol) {\\n        for(let i = 0; i < matrix.length; i++) {\\n            matrix[i][c] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26056,
                "title": "java-2-solutions-space-o-1-and-o-m-n-with-explaination",
                "content": "space O(1), time O(mn)\\nUse the top row and the left column to record which rows and columns need to be set 0. topZero and leftZero to record whether we need to set  the top row and the left column to zero before finished.\\n```\\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        boolean topZero=false, leftZero=false;\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    if(i==0) topZero = true;\\n                    if(j==0) leftZero = true;\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<M; i++){\\n            if(matrix[i][0]==0){\\n                for(int q=1; q<N; q++) matrix[i][q] = 0;\\n            }\\n        }\\n        for(int j=1; j<N; j++){\\n            if(matrix[0][j]==0){\\n                for(int p=1; p<M; p++)  matrix[p][j] = 0;\\n            }\\n        }\\n        if(topZero){\\n            for(int q=0; q<N; q++) matrix[0][q] = 0;\\n        }\\n        if(leftZero){\\n            for(int p=0; p<M; p++) matrix[p][0] = 0;\\n        }\\n    }\\n```\\nspace O(m+n), time O(mn)\\n```    \\n    public void setZeroes_Set(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        Set<Integer> rowSet = new HashSet<>();\\n        Set<Integer> colSet = new HashSet<>();\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    rowSet.add(i);\\n                    colSet.add(j);\\n                }\\n            }\\n        }\\n        for(int row : rowSet)\\n            for(int j=0; j<N; j++)\\n                matrix[row][j] = 0;\\n        for(int col : colSet)\\n            for(int i=0; i<M; i++)\\n                matrix[i][col] = 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        boolean topZero=false, leftZero=false;\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    if(i==0) topZero = true;\\n                    if(j==0) leftZero = true;\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<M; i++){\\n            if(matrix[i][0]==0){\\n                for(int q=1; q<N; q++) matrix[i][q] = 0;\\n            }\\n        }\\n        for(int j=1; j<N; j++){\\n            if(matrix[0][j]==0){\\n                for(int p=1; p<M; p++)  matrix[p][j] = 0;\\n            }\\n        }\\n        if(topZero){\\n            for(int q=0; q<N; q++) matrix[0][q] = 0;\\n        }\\n        if(leftZero){\\n            for(int p=0; p<M; p++) matrix[p][0] = 0;\\n        }\\n    }\\n```\n```    \\n    public void setZeroes_Set(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        Set<Integer> rowSet = new HashSet<>();\\n        Set<Integer> colSet = new HashSet<>();\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    rowSet.add(i);\\n                    colSet.add(j);\\n                }\\n            }\\n        }\\n        for(int row : rowSet)\\n            for(int j=0; j<N; j++)\\n                matrix[row][j] = 0;\\n        for(int col : colSet)\\n            for(int i=0; i<M; i++)\\n                matrix[i][col] = 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26070,
                "title": "simple-in-place-solution-yet-still-best-submission-in-c",
                "content": "    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) \\n        {\\n            if(matrix.empty()) return ;\\n            int rowSize = matrix.size(), colSize = matrix[0].size();\\n            bool firstRow = false, firstCol = false;\\n            for(int c = 0; c < colSize; ++c) if(matrix[0][c] == 0) firstRow = true;\\n            for(int r = 0; r < rowSize; ++r) if(matrix[r][0] == 0) firstCol = true;\\n            for(int r = 1; r < rowSize; ++r)\\n                for(int c = 1; c < colSize; ++c)\\n                    if(matrix[r][c] == 0) matrix[0][c] = matrix[r][0] = 0;\\n            for(int c = 1; c < colSize; ++c) \\n                if(matrix[0][c] == 0)\\n                    for(int r = 1; r < rowSize; ++r)\\n                        matrix[r][c] = 0;\\n            for(int r = 1; r < rowSize; ++r) \\n                if(matrix[r][0] == 0)\\n                    for(int c = 1; c < colSize; ++c)\\n                        matrix[r][c] = 0;\\n            if(firstRow) for(int c = 0; c < colSize; ++c) matrix[0][c] = 0;\\n            if(firstCol) for(int r = 0; r < rowSize; ++r) matrix[r][0] = 0;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) \\n        {\\n            if(matrix.empty()) return ;\\n            int rowSize = matrix.size(), colSize = matrix[0].size();\\n            bool firstRow = false, firstCol = false;\\n            for(int c = 0; c < colSize; ++c) if(matrix[0][c] == 0) firstRow = true;\\n            for(int r = 0; r < rowSize; ++r) if(matrix[r][0] == 0) firstCol = true;\\n            for(int r = 1; r < rowSize; ++r)\\n                for(int c = 1; c < colSize; ++c)\\n                    if(matrix[r][c] == 0) matrix[0][c] = matrix[r][0] = 0;\\n            for(int c = 1; c < colSize; ++c) \\n                if(matrix[0][c] == 0)\\n                    for(int r = 1; r < rowSize; ++r)\\n                        matrix[r][c] = 0;\\n            for(int r = 1; r < rowSize; ++r) \\n                if(matrix[r][0] == 0)\\n                    for(int c = 1; c < colSize; ++c)\\n                        matrix[r][c] = 0;\\n            if(firstRow) for(int c = 0; c < colSize; ++c) matrix[0][c] = 0;\\n            if(firstCol) for(int r = 0; r < rowSize; ++r) matrix[r][0] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 26111,
                "title": "python-easy-inplace-solution",
                "content": "Make first row and first column to mark which row and column should be zero before filling them out, then fill the matrix from right to left, and make the first row zero in the last if first row has any zero.\\n\\n    def setZeroes(self, matrix):\\n        firstRowHasZero = not all(matrix[0])\\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0\\n                    matrix[i][0] = 0\\n        \\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])-1,-1,-1):\\n                if matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n        \\n        if firstRowHasZero:\\n            matrix[0] = [0]*len(matrix[0])",
                "solutionTags": [
                    "Python"
                ],
                "code": "Make first row and first column to mark which row and column should be zero before filling them out, then fill the matrix from right to left, and make the first row zero in the last if first row has any zero.\\n\\n    def setZeroes(self, matrix):\\n        firstRowHasZero = not all(matrix[0])\\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0\\n                    matrix[i][0] = 0\\n        \\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])-1,-1,-1):\\n                if matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n        \\n        if firstRowHasZero:\\n            matrix[0] = [0]*len(matrix[0])",
                "codeTag": "Python3"
            },
            {
                "id": 3881749,
                "title": "easy-to-understand-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<pair<int,int>> temp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    temp.push_back(make_pair(i,j));\\n                }\\n            }\\n        }\\n        for(int i=0; i<temp.size();i++){\\n            int row=temp[i].first;\\n            int col=temp[i].second;\\n            for(int j=0;j<matrix.size();j++){\\n                for(int k=0;k<matrix[j].size();k++){\\n                    if(j==row)\\n                    matrix[j][k]=0;\\n                    if(k==col)\\n                    matrix[j][k]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<pair<int,int>> temp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    temp.push_back(make_pair(i,j));\\n                }\\n            }\\n        }\\n        for(int i=0; i<temp.size();i++){\\n            int row=temp[i].first;\\n            int col=temp[i].second;\\n            for(int j=0;j<matrix.size();j++){\\n                for(int k=0;k<matrix[j].size();k++){\\n                    if(j==row)\\n                    matrix[j][k]=0;\\n                    if(k==col)\\n                    matrix[j][k]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742996,
                "title": "simple-solution-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // we will keep the rows and col of 0 value \\n        set<int>r;\\n        set<int>c;\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n\\n        //now comes the part of making rows and col = 0\\n        //for rows\\n        for(auto i:r){\\n            for(int j=0;j<cols;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n\\n        // for cols\\n        for(auto j:c){\\n            for(int i=0;i<rows;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```\\n![leetcode.jpeg](https://assets.leetcode.com/users/images/b3c5af72-8a7d-4763-a72c-8a2242a871cd_1688997851.1284735.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // we will keep the rows and col of 0 value \\n        set<int>r;\\n        set<int>c;\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n\\n        //now comes the part of making rows and col = 0\\n        //for rows\\n        for(auto i:r){\\n            for(int j=0;j<cols;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n\\n        // for cols\\n        for(auto j:c){\\n            for(int i=0;i<rows;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713783,
                "title": "python-easy-solution-with-clear-explanation-with-example",
                "content": "# Intuition\\nHere, our intuition is to make every row and column zero if there is a zero present in that row. To accomplish this, we need to follow these steps:\\n\\n# Approach\\n\\nStep 1: Append the indices to a list where there is a zero.\\nFor example, given the list [[0,1,2,0],[3,4,5,2],[1,3,1,5]], the list of indices would be [0, 3].\\n\\nThis list is created because:\\ni) If there is a zero in a nested list, we make the entire list zero.\\nii) If a zero is not present in a row, but it is present in another row in the same column, we make that column zero for every nested list.\\n\\nTo perform this, we use two separate for loops:\\n- The first loop is used to get the indices of the zeros in the nested list and store them in `zero_cols`.\\n- The second loop is used to update the values to zero based on the conditions mentioned above.\\n\\n![WhatsApp Image 2023-07-05 at 9.36.31 AM.jpeg](https://assets.leetcode.com/users/images/7a38df5b-365f-4c72-b52f-ff7a570791c5_1688530121.9454794.jpeg)\\n\\n# **Kindly do a upvote if you find it usefull and a comment if found any mistake\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83E\\uDEC2**\\n\\n# Code\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        l_c = []\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if matrix[i][j] == 0:\\n                    l_c.append(j)\\n\\n        for i in range(len(matrix)):\\n            if 0 in matrix[i]:\\n                for ii in range(len(matrix[i])):\\n                    matrix[i][ii] = 0\\n            else:\\n                for _ in l_c:\\n                    matrix[i][_] = 0\\n        return matrix\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        l_c = []\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if matrix[i][j] == 0:\\n                    l_c.append(j)\\n\\n        for i in range(len(matrix)):\\n            if 0 in matrix[i]:\\n                for ii in range(len(matrix[i])):\\n                    matrix[i][ii] = 0\\n            else:\\n                for _ in l_c:\\n                    matrix[i][_] = 0\\n        return matrix\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663211,
                "title": "c-beats-91-30-runtime-beats-99-23-memory-2-methods-brute-force-optimal-solution",
                "content": "# Code\\n```\\n// OPTIMAL SOLUTION\\n/*\\nTC : O(n*m)\\nSC : O(1)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool firstRowZero = false;\\n        bool firstColZero = false;\\n        \\n        // Check if the first row and first column need to be set to zero\\n        for (int j = 0; j < m; j++) { // TC: O(m)\\n            if (matrix[0][j] == 0) {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) { // TC: O(n)\\n            if (matrix[i][0] == 0) {\\n                firstColZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // Mark the corresponding entry in the first row and first column as zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the elements in rows and columns (excluding the first row and first column) to zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the first row to zero if necessary\\n        if (firstRowZero) { // TC: O(m)\\n            for (int j = 0; j < m; j++) {\\n                matrix[0][j] = 0;\\n            }\\n        }\\n        \\n        // Set the first column to zero if necessary\\n        if (firstColZero) { // TC: O(n)\\n            for (int i = 0; i < n; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n\\n\\n# Code\\n```\\n// BRUTE FORCE\\n/*\\nTC : O(n*m)\\nSC : O(n + m)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        vector<int> row(n, 0); // SC: O(n)\\n        vector<int> col(m, 0); // SC: O(m)\\n\\n        // mark the row and col corresponding to element 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(matrix[i][j] == 0) {\\n                    row[i] = 1;\\n                    col[j] = 1;\\n                }\\n            }\\n        }\\n\\n        // set all row and col as 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(row[i] || col[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// OPTIMAL SOLUTION\\n/*\\nTC : O(n*m)\\nSC : O(1)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool firstRowZero = false;\\n        bool firstColZero = false;\\n        \\n        // Check if the first row and first column need to be set to zero\\n        for (int j = 0; j < m; j++) { // TC: O(m)\\n            if (matrix[0][j] == 0) {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) { // TC: O(n)\\n            if (matrix[i][0] == 0) {\\n                firstColZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // Mark the corresponding entry in the first row and first column as zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the elements in rows and columns (excluding the first row and first column) to zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the first row to zero if necessary\\n        if (firstRowZero) { // TC: O(m)\\n            for (int j = 0; j < m; j++) {\\n                matrix[0][j] = 0;\\n            }\\n        }\\n        \\n        // Set the first column to zero if necessary\\n        if (firstColZero) { // TC: O(n)\\n            for (int i = 0; i < n; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\n```\\n// BRUTE FORCE\\n/*\\nTC : O(n*m)\\nSC : O(n + m)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        vector<int> row(n, 0); // SC: O(n)\\n        vector<int> col(m, 0); // SC: O(m)\\n\\n        // mark the row and col corresponding to element 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(matrix[i][j] == 0) {\\n                    row[i] = 1;\\n                    col[j] = 1;\\n                }\\n            }\\n        }\\n\\n        // set all row and col as 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(row[i] || col[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610821,
                "title": "java-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Step 1\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 3 | 4 | 5 | 2 |\\n| 1 | 3 | 1 | 5 |\\n\\nrow = false\\ncol = true\\n\\n## Step 2\\n\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 3 | 4 | 5 | 2 |\\n| 1 | 3 | 1 | 5 |\\n\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 3 | 4 | 5 | 2 |\\n| 1 | 3 | 1 | 5 |\\n\\nrow = true\\ncol = true\\n\\n## Step 3 and so on\\n\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 0 | 4 | 5 | 2 |\\n| 0 | 3 | 1 | 5 |\\n\\n| 0 | 0 | 0 | 0 |\\n|---|---|---|---|\\n| 0 | 4 | 5 | 2 |\\n| 0 | 3 | 1 | 5 |\\n\\n| 0 | 0 | 0 | 0 |\\n|---|---|---|---|\\n| 0 | 4 | 5 | 2 |\\n| 0 | 3 | 1 | 5 |\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        boolean row = false;\\n        boolean col = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                col = true;\\n                break;\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                row = true;\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[0][j] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[i][0] = 0;\\n                    matrix[i][0] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j = 1; j < m; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                for (int i = 1; i < n; i++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        if (col) {\\n            cleanZeroCol(matrix, n);\\n        }\\n\\n        if (row) {\\n            cleanZeroRow(matrix, m);\\n        }\\n    }\\n\\n    private void cleanZeroCol(int[][] matrix, int n) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n    private void cleanZeroRow(int[][] matrix, int m) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        boolean row = false;\\n        boolean col = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                col = true;\\n                break;\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                row = true;\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[0][j] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[i][0] = 0;\\n                    matrix[i][0] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j = 1; j < m; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                for (int i = 1; i < n; i++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        if (col) {\\n            cleanZeroCol(matrix, n);\\n        }\\n\\n        if (row) {\\n            cleanZeroRow(matrix, m);\\n        }\\n    }\\n\\n    private void cleanZeroCol(int[][] matrix, int n) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n    private void cleanZeroRow(int[][] matrix, int m) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554849,
                "title": "most-optimal-solution-using-in-place-or-constant-space-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  void setZeroes(vector<vector<int>> &matrix)\\n  {\\n    int n = matrix.size();\\n    int m = matrix[0].size();\\n    int col0 = 1;\\n    for (int i = 0; i < n; i++)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        if (matrix[i][j] == 0)\\n        {\\n\\n          matrix[i][0] = 0;\\n\\n          if (j != 0)\\n            matrix[0][j] = 0;\\n          else\\n            col0 = 0;\\n        }\\n      }\\n    }\\n\\n    for (int i = 1; i < n; i++)\\n    {\\n      for (int j = 1; j < m; j++)\\n      {\\n        if (matrix[i][j] != 0)\\n        {\\n\\n          if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n          {\\n            matrix[i][j] = 0;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (matrix[0][0] == 0)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        matrix[0][j] = 0;\\n      }\\n    }\\n    if (col0 == 0)\\n    {\\n      for (int i = 0; i < n; i++)\\n      {\\n        matrix[i][0] = 0;\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  void setZeroes(vector<vector<int>> &matrix)\\n  {\\n    int n = matrix.size();\\n    int m = matrix[0].size();\\n    int col0 = 1;\\n    for (int i = 0; i < n; i++)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        if (matrix[i][j] == 0)\\n        {\\n\\n          matrix[i][0] = 0;\\n\\n          if (j != 0)\\n            matrix[0][j] = 0;\\n          else\\n            col0 = 0;\\n        }\\n      }\\n    }\\n\\n    for (int i = 1; i < n; i++)\\n    {\\n      for (int j = 1; j < m; j++)\\n      {\\n        if (matrix[i][j] != 0)\\n        {\\n\\n          if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n          {\\n            matrix[i][j] = 0;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (matrix[0][0] == 0)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        matrix[0][j] = 0;\\n      }\\n    }\\n    if (col0 == 0)\\n    {\\n      for (int i = 0; i < n; i++)\\n      {\\n        matrix[i][0] = 0;\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306062,
                "title": "optimize-solution-in-constant-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean isRow0Zero = false, isCol0Zero =false;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        // check if first column need to set zero\\n        for(int i =0; i< m; i++) {\\n            if(matrix[i][0] == 0) {\\n                isCol0Zero = true;\\n                break;\\n            }\\n        }\\n\\n      // check if first row need to set zero\\n        for(int i =0; i< n; i++) {\\n            if(matrix[0][i] == 0) {\\n                isRow0Zero = true;\\n                break;\\n            }\\n        }\\n\\n\\n       for(int i=1; i<m; i++) {\\n           for(int j=1;j<n;j++) {\\n               if(matrix[i][j] == 0) {\\n                   matrix[i][0] = 0;\\n                   matrix[0][j] = 0;\\n               }\\n           }\\n       }\\n\\n\\n        for(int i=1; i<m; i++) {\\n            for(int j=1;j<n;j++) {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                  matrix[i][j] = 0;\\n                }\\n           }\\n        }\\n\\n        if(isRow0Zero) {\\n            for(int i=0;i <n; i++) \\n                 matrix[0][i] = 0;\\n        }\\n\\n        if(isCol0Zero) {\\n            for(int i=0;i <m; i++) \\n                 matrix[i][0] = 0;\\n        }\\n    \\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean isRow0Zero = false, isCol0Zero =false;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        // check if first column need to set zero\\n        for(int i =0; i< m; i++) {\\n            if(matrix[i][0] == 0) {\\n                isCol0Zero = true;\\n                break;\\n            }\\n        }\\n\\n      // check if first row need to set zero\\n        for(int i =0; i< n; i++) {\\n            if(matrix[0][i] == 0) {\\n                isRow0Zero = true;\\n                break;\\n            }\\n        }\\n\\n\\n       for(int i=1; i<m; i++) {\\n           for(int j=1;j<n;j++) {\\n               if(matrix[i][j] == 0) {\\n                   matrix[i][0] = 0;\\n                   matrix[0][j] = 0;\\n               }\\n           }\\n       }\\n\\n\\n        for(int i=1; i<m; i++) {\\n            for(int j=1;j<n;j++) {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                  matrix[i][j] = 0;\\n                }\\n           }\\n        }\\n\\n        if(isRow0Zero) {\\n            for(int i=0;i <n; i++) \\n                 matrix[0][i] = 0;\\n        }\\n\\n        if(isCol0Zero) {\\n            for(int i=0;i <m; i++) \\n                 matrix[i][0] = 0;\\n        }\\n    \\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217274,
                "title": "python-easy-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, mat: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n=len(mat),len(mat[0])\\n        r=c=0\\n#Storing the index of 0th element in first row and column\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j]==0:\\n                    if i==0:\\n                        r=1\\n                    if j==0:\\n                        c=1   \\n                    mat[i][0]=mat[0][j]=0\\n        \\n#If first row or column is marked with 0 the then marking all the elements in that row or column as 0\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                if mat[i][0]==0 or mat[0][j]==0:\\n                    mat[i][j]=0\\n#If first row or column as 0 then making all elements in first row or column as 0\\n        if r==1:\\n            for j in range(n):\\n                mat[0][j]=0\\n        if c==1:\\n            for i in range(m):\\n                mat[i][0]=0\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, mat: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n=len(mat),len(mat[0])\\n        r=c=0\\n#Storing the index of 0th element in first row and column\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j]==0:\\n                    if i==0:\\n                        r=1\\n                    if j==0:\\n                        c=1   \\n                    mat[i][0]=mat[0][j]=0\\n        \\n#If first row or column is marked with 0 the then marking all the elements in that row or column as 0\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                if mat[i][0]==0 or mat[0][j]==0:\\n                    mat[i][j]=0\\n#If first row or column as 0 then making all elements in first row or column as 0\\n        if r==1:\\n            for j in range(n):\\n                mat[0][j]=0\\n        if c==1:\\n            for i in range(m):\\n                mat[i][0]=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182406,
                "title": "store-indices",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int> r,c;\\n        int i,j,m = matrix.size(),n = matrix[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(!matrix[i][j]){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n        for(auto &i: r){\\n            for(j = 0; j < n; j++){\\n                matrix[i][j] = 0;\\n            }\\n        }for(auto &i: c){\\n            for(j = 0; j < m; j++){\\n                matrix[j][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int> r,c;\\n        int i,j,m = matrix.size(),n = matrix[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(!matrix[i][j]){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n        for(auto &i: r){\\n            for(j = 0; j < n; j++){\\n                matrix[i][j] = 0;\\n            }\\n        }for(auto &i: c){\\n            for(j = 0; j < m; j++){\\n                matrix[j][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164326,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size();\\n        int c=1;\\n        for(int i=0;i<row;i++){\\n             if(mat[i][0]==0)\\n             c=0;\\n            for(int j=1;j<col;j++){\\n                if(mat[i][j]==0){\\n                    mat[0][j]=0;\\n                    mat[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1;j>0;j--)\\n            if(mat[i][0]==0||mat[0][j]==0)\\n            mat[i][j]=0;\\n            if(c==0)\\n            mat[i][0]=0;\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        zeroRowIndexes = set()\\n        zeroColIndexes = set()\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    zeroRowIndexes.add(i)\\n                    zeroColIndexes.add(j)\\n        for i in range(m):\\n            for j in range(n):\\n                if i in zeroRowIndexes or j in zeroColIndexes:\\n                    matrix[i][j] = 0\\n```\\n\\n```Java []\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n        \\n        for(int i = 0; i < rows; i++){\\n            if(matrix[i][0] == 0) col0 = 0;\\n            for(int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        \\n        for(int i = rows - 1; i >= 0; i--){\\n            for(int j = cols - 1; j >= 1; j --)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size();\\n        int c=1;\\n        for(int i=0;i<row;i++){\\n             if(mat[i][0]==0)\\n             c=0;\\n            for(int j=1;j<col;j++){\\n                if(mat[i][j]==0){\\n                    mat[0][j]=0;\\n                    mat[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1;j>0;j--)\\n            if(mat[i][0]==0||mat[0][j]==0)\\n            mat[i][j]=0;\\n            if(c==0)\\n            mat[i][0]=0;\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        zeroRowIndexes = set()\\n        zeroColIndexes = set()\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    zeroRowIndexes.add(i)\\n                    zeroColIndexes.add(j)\\n        for i in range(m):\\n            for j in range(n):\\n                if i in zeroRowIndexes or j in zeroColIndexes:\\n                    matrix[i][j] = 0\\n```\n```Java []\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n        \\n        for(int i = 0; i < rows; i++){\\n            if(matrix[i][0] == 0) col0 = 0;\\n            for(int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        \\n        for(int i = rows - 1; i >= 0; i--){\\n            for(int j = cols - 1; j >= 1; j --)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091387,
                "title": "1000-views-best-solution-concise-precise-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n       vector<pair<int,int>> mp;\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<cols;j++)\\n                if(matrix[i][j]==0) mp.push_back(make_pair(i,j));\\n\\n        for(auto i:mp){\\n            int j=0;\\n            while(j<cols){\\n                matrix[i.first][j]=0;\\n                j++;\\n            }\\n            j=0;\\n              while(j<rows){\\n                matrix[j][i.second]=0;\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n       vector<pair<int,int>> mp;\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<cols;j++)\\n                if(matrix[i][j]==0) mp.push_back(make_pair(i,j));\\n\\n        for(auto i:mp){\\n            int j=0;\\n            while(j<cols){\\n                matrix[i.first][j]=0;\\n                j++;\\n            }\\n            j=0;\\n              while(j<rows){\\n                matrix[j][i.second]=0;\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986079,
                "title": "simple-python-solution-easy",
                "content": "# Approach\\n* Create 2 sets to track which column and row needs to be updated\\n* Update original matrix using the sets\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m+n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        col = set()\\n        row = set()\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]==0:\\n                    col.add(j)\\n                    row.add(i)\\n        \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j]=0\\n        for i in range(len(matrix)):\\n            for j in col:\\n                matrix[i][j]=0\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        col = set()\\n        row = set()\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]==0:\\n                    col.add(j)\\n                    row.add(i)\\n        \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j]=0\\n        for i in range(len(matrix)):\\n            for j in col:\\n                matrix[i][j]=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939166,
                "title": "beginner-s-solutions",
                "content": "# Intuition\\nSo, you might think that this question must have some optimized solution but believe me the brute force is the only approach which will give you minimum time complexity ..\\n\\n# Approach\\nWe will declare two vectors if you don\\'t know about vectors you can declare two arrays too. First of all we will traverse entire matrix (using two for loops) and then find which row and column has a 0. We will note that in our arrays/vectors which were keeping track of 0\\'s.\\nThen we will again use two for loops to assign the 0\\'s to respective index with help of our two arrays/vectors which were keeping track of 0\\'s. And yup this is it ..\\n\\n# Complexity\\n- Time complexity:\\nO(2 x n x m) \\nWhere n is number of rows and m is number of columns and we traversed the entire matrix twice hence 2 in multiplication.\\n\\n- Space complexity:\\nO(n+m)\\nWhere n is number of rows and m is number of columns as we declared two arrays/vectors of this size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> row(n,0);\\n        vector<int> col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]>0){\\n                    matrix[i][j]=0;\\n                }\\n                if(col[j]>0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> row(n,0);\\n        vector<int> col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]>0){\\n                    matrix[i][j]=0;\\n                }\\n                if(col[j]>0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804366,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row;\\n        vector<int> col;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row.push_back(i);\\n                    col.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<row.size();i++){\\n            for(int j=0;j<n;j++){\\n                matrix[row[i]][j]=0;\\n            }\\n        }\\n        for(int i=0;i<col.size();i++){\\n            for(int j=0;j<m;j++){\\n                matrix[j][col[i]]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row;\\n        vector<int> col;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row.push_back(i);\\n                    col.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<row.size();i++){\\n            for(int j=0;j<n;j++){\\n                matrix[row[i]][j]=0;\\n            }\\n        }\\n        for(int i=0;i<col.size();i++){\\n            for(int j=0;j<m;j++){\\n                matrix[j][col[i]]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596094,
                "title": "python-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        col = True\\n        \\n        for i in range(n):\\n            if matrix[i][0] == 0:\\n                col = False\\n            for j in range(1, m):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0  \\n\\t\\t\\t\\t\\t\\n        for i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        col = True\\n        \\n        for i in range(n):\\n            if matrix[i][0] == 0:\\n                col = False\\n            for j in range(1, m):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0  \\n\\t\\t\\t\\t\\t\\n        for i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320399,
                "title": "all-the-approach-for-this-question",
                "content": "![image](https://assets.leetcode.com/users/images/b97eba51-d299-4817-86b2-fef17ba46fe8_1658557435.2364733.png)\\n",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/b97eba51-d299-4817-86b2-fef17ba46fe8_1658557435.2364733.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2310610,
                "title": "c-brutforce-to-optimal",
                "content": "Approach: Using brute force\\n\\nAssuming all the elements in the matrix are non-negative. Traverse through the matrix and if you find an element with value 0, then change all the elements in its row and column to -1, except when an element is 0. The reason for not changing other elements to 0, but -1, is because that might affect other columns and rows. Now traverse through the matrix again and if an element is -1 change it to 0, which will be the answer.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\\n\\nBetter approach\\n\\nIntuition: Instead of traversing through each row and column, we can use dummy arrays to check if the particular row or column has an element 0 or not, which will improve the time complexity.\\n\\nApproach:Take two dummy array one of size of row and other of size of column.Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\n```\\n\\nOptimizing the better approach.\\n\\nIntuition: Instead of taking two dummy arrays we can use the first row and column of the matrix for the same work. This will help to reduce the space complexity of the problem. While traversing for the second time the first row and column will be computed first, which will affect the values of further elements that\\u2019s why we traversing in the reverse direction.\\n\\nApproach:Instead of taking two separate dummy array,take first row and column of the matrix as the array for checking whether the particular column or row has the value 0 or not.Since matrix[0][0] are overlapping.Therefore take separate variable col0(say) to check if the 0th column has 0 or not and use matrix[0][0] to check if the 0th row has 0 or not.Now traverse from last element to the first element and check if matrix[i][0]==0 || matrix[0][j]==0 and if true set matrix[i][j]=0,else continue.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    //checking if 0 is present in the 0th column or not\\n    if (matrix[i][0] == 0) col0 = 0;\\n    for (int j = 1; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n  //traversing in the reverse direction and\\n  //checking if the row or col has 0 or not\\n  //and setting values of matrix accordingly.\\n  for (int i = rows - 1; i >= 0; i--) {\\n    for (int j = cols - 1; j >= 1; j--) {\\n      if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n    if (col0 == 0) {\\n      matrix[i][0] = 0;\\n    }\\n\\n  }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\n```\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    //checking if 0 is present in the 0th column or not\\n    if (matrix[i][0] == 0) col0 = 0;\\n    for (int j = 1; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n  //traversing in the reverse direction and\\n  //checking if the row or col has 0 or not\\n  //and setting values of matrix accordingly.\\n  for (int i = rows - 1; i >= 0; i--) {\\n    for (int j = cols - 1; j >= 1; j--) {\\n      if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n    if (col0 == 0) {\\n      matrix[i][0] = 0;\\n    }\\n\\n  }\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281086,
                "title": "c-solution-2-approaches-with-explanation",
                "content": "**Approach 1 (using extra space)**\\n\\nThis Approach will use two boolean 1 dimensional matrices, named rowZero and colZero.\\n- rowZero[i] and colZero[j] will indicate if matrix[i][j] == 0. That is, for each column and row we are storing if it contains a 0 or not in the first traversal. If it contains a 0, mark it as true.\\n- In the second traversal, for each matrix[i][j], if rowZero[i] is true OR colZero[j] is true, then we place a 0 at matrix[i][j]. \\n- Else keep matrix[i][j] as it is.\\n- Time Complexity: 2 * O(M*N)\\n- Space Complexity: O(M) + O(N)\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        vector<bool> rowZero(rowSize);\\n        vector<bool> colZero(colSize);\\n        \\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(matrix[i][j] == 0) {\\n                    rowZero[i] = true;\\n                    colZero[j] = true;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(rowZero[i] == true || colZero[j] == true) matrix[i][j] = 0;\\n            }\\n        }        \\n    }\\n```\\n**Approach 2 (O(1) SPACE)**\\nWe will use two bool variables rowZero and colZero to store whether first row or col has a 0 or not. Then we use first row and first col itself to store whether the remaining rows/cols has zero or not. That is, instead of creating two separate arrays like in first approach, we will instead use the first row and first column of the given matrix itself. This will reduce space complexity to constant space **O(1)**. \\n**Time Complexity will remain O(M*N)**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        \\n        bool rowZero = false, colZero = false;\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        \\n        // check for first col\\n        for(int i=0;i<rowSize;i++){\\n            if(matrix[i][0] == 0){\\n                colZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // check for first row \\n        for(int j=0;j<colSize;j++){\\n            if(matrix[0][j] == 0){\\n                rowZero = true;\\n                break;\\n            }\\n        }\\n        // mark 0 in first row/col where the remaining part of matrix has zero or not.\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        // setting the matrix as 0 wherever required except the first row or col\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[0][j] == 0|| matrix[i][0] == 0) matrix[i][j] = 0;\\n            }\\n        }\\n        \\n        if(rowZero){\\n            for(int j=0;j<colSize;j++) matrix[0][j] = 0;\\n        }\\n        if(colZero){\\n            for(int i=0;i<rowSize;i++) matrix[i][0] = 0;\\n        }\\n               \\n    }\\n```\\n\\nPLEASE UPVOTE\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        vector<bool> rowZero(rowSize);\\n        vector<bool> colZero(colSize);\\n        \\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(matrix[i][j] == 0) {\\n                    rowZero[i] = true;\\n                    colZero[j] = true;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(rowZero[i] == true || colZero[j] == true) matrix[i][j] = 0;\\n            }\\n        }        \\n    }\\n```\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        \\n        bool rowZero = false, colZero = false;\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        \\n        // check for first col\\n        for(int i=0;i<rowSize;i++){\\n            if(matrix[i][0] == 0){\\n                colZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // check for first row \\n        for(int j=0;j<colSize;j++){\\n            if(matrix[0][j] == 0){\\n                rowZero = true;\\n                break;\\n            }\\n        }\\n        // mark 0 in first row/col where the remaining part of matrix has zero or not.\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        // setting the matrix as 0 wherever required except the first row or col\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[0][j] == 0|| matrix[i][0] == 0) matrix[i][j] = 0;\\n            }\\n        }\\n        \\n        if(rowZero){\\n            for(int j=0;j<colSize;j++) matrix[0][j] = 0;\\n        }\\n        if(colZero){\\n            for(int i=0;i<rowSize;i++) matrix[i][0] = 0;\\n        }\\n               \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2224337,
                "title": "c-solution-easy",
                "content": "Hope this helps : )\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<vector<int>> temp = matrix;\\n        for(int i = 0; i<matrix.size();i++){\\n            for(int j = 0;j<matrix[0].size();j++){\\n                if(temp[i][j] == 0){\\n                    for(int row = 0;row<matrix[0].size();row++){\\n                        matrix[i][row] = 0;\\n                    }\\n                    for(int col = 0;col<matrix.size();col++){\\n                        matrix[col][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\nMake sure to upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<vector<int>> temp = matrix;\\n        for(int i = 0; i<matrix.size();i++){\\n            for(int j = 0;j<matrix[0].size();j++){\\n                if(temp[i][j] == 0){\\n                    for(int row = 0;row<matrix[0].size();row++){\\n                        matrix[i][row] = 0;\\n                    }\\n                    for(int col = 0;col<matrix.size();col++){\\n                        matrix[col][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191071,
                "title": "java-solution-using-hashset",
                "content": "**Algorithm**\\n* Make two hashset which will store row index and col index of 0s.\\n* First iterate through row hashset, and make all the elements of that particular row as 0.\\n* Similarly, repeat the process with col hashset for col rows.\\n\\nTime Complexity: O(mn)\\n\\n**Code**\\n```\\npublic void setZeroes(int[][] matrix) {\\n        HashSet<Integer> row = new HashSet<>();\\n        HashSet<Integer> col = new HashSet<>();\\n        for(int i=0; i<matrix[0].length; i++){\\n            for(int j=0; j<matrix.length; j++){\\n                if(matrix[j][i] == 0) {\\n                    col.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0) {\\n                    row.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for (int ele : row) {\\n            for(int j=0; j<matrix[0].length; j++){\\n                matrix[ele][j] = 0;\\n            }\\n        }\\n        for (int ele : col) {\\n            for(int j=0; j<matrix.length; j++){\\n                matrix[j][ele] = 0;\\n            }\\n        }\\n    }\\n```\\n**Please upvote if you appreciate the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void setZeroes(int[][] matrix) {\\n        HashSet<Integer> row = new HashSet<>();\\n        HashSet<Integer> col = new HashSet<>();\\n        for(int i=0; i<matrix[0].length; i++){\\n            for(int j=0; j<matrix.length; j++){\\n                if(matrix[j][i] == 0) {\\n                    col.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0) {\\n                    row.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for (int ele : row) {\\n            for(int j=0; j<matrix[0].length; j++){\\n                matrix[ele][j] = 0;\\n            }\\n        }\\n        for (int ele : col) {\\n            for(int j=0; j<matrix.length; j++){\\n                matrix[j][ele] = 0;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2189679,
                "title": "c-10ms-using-unordered-sets",
                "content": "void setZeroes(vector<vector<int>>& matrix) {\\n    unordered_set<int> rows, cols;\\n        \\n    for(int i = 0; i < matrix.size(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            if(!matrix[i][j]){\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n        }\\n    }\\n        \\n    for(auto i = rows.begin(); i != rows.end(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            matrix[*i][j] = 0;\\n        }\\n    }\\n        \\n    for(auto i = cols.begin(); i != cols.end(); i++){\\n        for(int j = 0; j < matrix.size(); j++){\\n            matrix[j][*i] = 0;\\n        }\\n    }\\n}\\t\\n\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "void setZeroes(vector<vector<int>>& matrix) {\\n    unordered_set<int> rows, cols;\\n        \\n    for(int i = 0; i < matrix.size(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            if(!matrix[i][j]){\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n        }\\n    }\\n        \\n    for(auto i = rows.begin(); i != rows.end(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            matrix[*i][j] = 0;\\n        }\\n    }\\n        \\n    for(auto i = cols.begin(); i != cols.end(); i++){\\n        for(int j = 0; j < matrix.size(); j++){\\n            matrix[j][*i] = 0;\\n        }\\n    }\\n}\\t\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2076696,
                "title": "o-m-n-solution-in-cpp-o-1-space-complexity",
                "content": "Here, instead of using an extra space, we use the first column and first row of corresponding matrix to mark our zeros. Once that is done we will just go through the first row and first column and mark all the elements in their respective columns and row as zero...\\nThis would have a corner case of first row or first column or first element being zero. For that we will use three flags to mark them and adust our matrix after the previous operation is done with...\\n\\n**Pls Upvote this thread if you found the explanation helpful**\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix[0].size(), n=matrix.size();\\n        bool row=false, col=false, first=!(matrix[0][0]);\\n        \\n        //Checking if first row contains any zeros\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                row=true;\\n                break;\\n            }\\n        }\\n        \\n        //Checking if first column contains any zeros\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                col=true;\\n                break;\\n            }\\n        }\\n        \\n        /**Going through the rest of matrix to find 0s,\\n        If 0 exist, we update its first row and first column*/\\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++) {\\n                if(matrix[i][j]==0) {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        //Converting a particular column to 0 if the first row correspoding is 0\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                for(int j=1;j<n;j++) matrix[j][i]=0;\\n            }\\n        }\\n        \\n        //Converting a particular row to 0 if the first column corresponding is 0\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                for(int j=1;j<m;j++) matrix[i][j]=0;\\n            }\\n        }\\n        \\n        //Converting a row or column zero if corresponding flag is zero\\n        if(row || first) for(int i=0;i<m;i++) matrix[0][i]=0;\\n        if(col || first) for(int i=0;i<n;i++) matrix[i][0]=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix[0].size(), n=matrix.size();\\n        bool row=false, col=false, first=!(matrix[0][0]);\\n        \\n        //Checking if first row contains any zeros\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                row=true;\\n                break;\\n            }\\n        }\\n        \\n        //Checking if first column contains any zeros\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                col=true;\\n                break;\\n            }\\n        }\\n        \\n        /**Going through the rest of matrix to find 0s,\\n        If 0 exist, we update its first row and first column*/\\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++) {\\n                if(matrix[i][j]==0) {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        //Converting a particular column to 0 if the first row correspoding is 0\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                for(int j=1;j<n;j++) matrix[j][i]=0;\\n            }\\n        }\\n        \\n        //Converting a particular row to 0 if the first column corresponding is 0\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                for(int j=1;j<m;j++) matrix[i][j]=0;\\n            }\\n        }\\n        \\n        //Converting a row or column zero if corresponding flag is zero\\n        if(row || first) for(int i=0;i<m;i++) matrix[0][i]=0;\\n        if(col || first) for(int i=0;i<n;i++) matrix[i][0]=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031661,
                "title": "3-approaches",
                "content": "1st approach:\\nConsidering non-negative numbers in the matrix, we are changing non-zero elements in rows and columns containg 0 to -1. In next step cahnging those -1 to 0.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    //make row elements 0\\n                    for(int k=0;k<cols;k++)\\n                        if(a[i][k]!=0)\\n                            a[i][k]=-1;\\n                    //make col elements 0\\n                    for(int l=0;l<rows;l++)\\n                        if(a[l][j]!=0)\\n                            a[l][j]=-1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==-1)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n2nd approach:\\nWe are creating 2 dummy arrays where we store whhich row and column contains 0. In next step we chang all elems to 0 according to dummy arrays.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        vector<int> dummyRow(rows,-1), dummyCol(cols,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    dummyRow[i]=0;\\n                    dummyCol[j]=0;\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummyRow[i]==0 || dummyCol[j] ==0)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n3rd approach:\\nInstead of creating dummy arrays we consider 0th row and column as the same. But here matrix[0][0]\\ngets overlapped by both row and column. So for 0th column we consider a varaible col . If any elem of 0th column has 0 then we change col\\'s value. Next we traverse from the last of array.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int col=1;\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            if(a[i][0]==0)\\n                col=0;\\n            for( int j=1;j<cols;j++){\\n                \\n                if(a[i][j]==0){\\n                    a[0][j]=0;\\n                    a[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=rows-1;i>=0;i--){\\n            for(int j=cols-1;j>=1;j--){\\n                if(a[0][j] == 0 || a[i][0]==0)\\n                    a[i][j]=0; \\n            }\\n            if(col==0)\\n                a[i][0]=0;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    //make row elements 0\\n                    for(int k=0;k<cols;k++)\\n                        if(a[i][k]!=0)\\n                            a[i][k]=-1;\\n                    //make col elements 0\\n                    for(int l=0;l<rows;l++)\\n                        if(a[l][j]!=0)\\n                            a[l][j]=-1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==-1)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        vector<int> dummyRow(rows,-1), dummyCol(cols,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    dummyRow[i]=0;\\n                    dummyCol[j]=0;\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummyRow[i]==0 || dummyCol[j] ==0)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int col=1;\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            if(a[i][0]==0)\\n                col=0;\\n            for( int j=1;j<cols;j++){\\n                \\n                if(a[i][j]==0){\\n                    a[0][j]=0;\\n                    a[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=rows-1;i>=0;i--){\\n            for(int j=cols-1;j>=1;j--){\\n                if(a[0][j] == 0 || a[i][0]==0)\\n                    a[i][j]=0; \\n            }\\n            if(col==0)\\n                a[i][0]=0;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005761,
                "title": "go-clear-solution",
                "content": "```\\nfunc setZeroes(matrix [][]int)  {\\n    m, n := len(matrix), len(matrix[0])\\n    zeroColumn, zeroRow := false, false\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            if matrix[r][c] == 0 {\\n                if c == 0 { zeroColumn = true } else { matrix [0][c] = 0 }\\n                if r == 0 { zeroRow = true } else { matrix [r][0] = 0 }\\n            }\\n        }\\n    }\\n    for r := 1; r < m; r++ {\\n        for c := 1; c < n; c++ {\\n            if matrix[0][c] == 0 || matrix[r][0] == 0 {\\n                matrix[r][c] = 0\\n            }\\n        }\\n    }\\n    if zeroColumn { for r := 0; r < m; r++ { matrix[r][0] = 0 } }\\n    if zeroRow { for c := 0; c < n; c++ { matrix[0][c] = 0 } }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc setZeroes(matrix [][]int)  {\\n    m, n := len(matrix), len(matrix[0])\\n    zeroColumn, zeroRow := false, false\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            if matrix[r][c] == 0 {\\n                if c == 0 { zeroColumn = true } else { matrix [0][c] = 0 }\\n                if r == 0 { zeroRow = true } else { matrix [r][0] = 0 }\\n            }\\n        }\\n    }\\n    for r := 1; r < m; r++ {\\n        for c := 1; c < n; c++ {\\n            if matrix[0][c] == 0 || matrix[r][0] == 0 {\\n                matrix[r][c] = 0\\n            }\\n        }\\n    }\\n    if zeroColumn { for r := 0; r < m; r++ { matrix[r][0] = 0 } }\\n    if zeroRow { for c := 0; c < n; c++ { matrix[0][c] = 0 } }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737433,
                "title": "java-solution-using-two-sets",
                "content": "``` \\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> rows=new HashSet<>();\\n        Set<Integer> cols=new HashSet<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    rows.add(i);\\n                    cols.add(j);\\n                }\\n            }\\n        }\\n        for(int i : rows){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        for(int j: cols){\\n            for(int i=0;i<matrix.length;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n\\nTime Comp:- O(rows*cols)\\nSpace :- O(rows+cols)",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> rows=new HashSet<>();\\n        Set<Integer> cols=new HashSet<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    rows.add(i);\\n                    cols.add(j);\\n                }\\n            }\\n        }\\n        for(int i : rows){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        for(int j: cols){\\n            for(int i=0;i<matrix.length;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683206,
                "title": "python-easy-and-concise-solution-with-hashmap-python",
                "content": "* Store 0 valued indexes in hashmap\\n* Traverse the matrix and update according to hashmap\\n\\n# PYTHON\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        n, m = len(matrix), len(matrix[0])\\n        rows, cols = {}, {}\\n        for i in range(n):\\n            for j in range(m):\\n                if matrix[i][j] == 0:\\n                    rows[i] = 1\\n                    cols[j] = 1\\n        for i in range(n):\\n            for j in range(m):\\n                if i in rows:\\n                    matrix[i][j] = 0\\n                if j in cols:\\n                    matrix[i][j] = 0\\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        n, m = len(matrix), len(matrix[0])\\n        rows, cols = {}, {}\\n        for i in range(n):\\n            for j in range(m):\\n                if matrix[i][j] == 0:\\n                    rows[i] = 1\\n                    cols[j] = 1\\n        for i in range(n):\\n            for j in range(m):\\n                if i in rows:\\n                    matrix[i][j] = 0\\n                if j in cols:\\n                    matrix[i][j] = 0\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558946,
                "title": "c-three-levels-of-solution",
                "content": "**1. O(mn) space** \\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<vector<int>>res(m, vector<int>(n, -1));\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) res[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) res[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(res[i][j] == 0) matrix[i][j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n```\\n**2. O(m+n) space**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<pair<int,int>>index;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tindex.push_back({i,j});\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\tvector<pair<int,int>>::iterator it;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tit = find (index.begin(), index.end(), make_pair(i, j));\\n\\t\\t\\tif(it != index.end()) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) matrix[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) matrix[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n}\\n```\\n**3. O(1) space**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tbool zeroCol = false;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tif(matrix[i][0] == 0) {\\n\\t\\t\\tzeroCol = true;\\n\\t\\t}\\n\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tmatrix[0][j] = 0;\\n\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 1; i < m; i++) {\\n\\t\\tfor(int j = 1; j < n; j++) {\\n\\t\\t\\tif(!matrix[i][0] || !matrix[0][j])\\n\\t\\t\\t\\tmatrix[i][j] = 0;\\n\\t\\t}\\n\\t} \\n\\tif(matrix[0][0] == 0) {\\n\\t\\tfor(int j = 0; j < n; j++) matrix[0][j] = 0;\\n\\t}\\n\\tif(zeroCol) {\\n\\t\\tfor(int i = 0; i < m; i++) matrix[i][0] = 0;\\n\\t}\\n}\\n\\t",
                "solutionTags": [],
                "code": "```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<vector<int>>res(m, vector<int>(n, -1));\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) res[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) res[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(res[i][j] == 0) matrix[i][j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<pair<int,int>>index;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tindex.push_back({i,j});\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\tvector<pair<int,int>>::iterator it;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tit = find (index.begin(), index.end(), make_pair(i, j));\\n\\t\\t\\tif(it != index.end()) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) matrix[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) matrix[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402036,
                "title": "java-easy-solution-o-1-space",
                "content": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n      for(int i=0;i<rows;i++){\\n        if(matrix[i][0]==0) \\n            col0=0;\\n        for(int j=1;j<cols;j++){\\n          if(matrix[i][j]==0)\\n            matrix[i][0]=matrix[0][j]=0;\\n        }\\n      }\\n      \\n      for(int i=rows-1;i>=0;i--){\\n        for(int j = cols-1;j>=1;j--)\\n          if(matrix[0][j]==0 || matrix[i][0]==0)\\n            matrix[i][j]=0;\\n        \\n        if(col0==0) matrix[i][0]=0;\\n\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n      for(int i=0;i<rows;i++){\\n        if(matrix[i][0]==0) \\n            col0=0;\\n        for(int j=1;j<cols;j++){\\n          if(matrix[i][j]==0)\\n            matrix[i][0]=matrix[0][j]=0;\\n        }\\n      }\\n      \\n      for(int i=rows-1;i>=0;i--){\\n        for(int j = cols-1;j>=1;j--)\\n          if(matrix[0][j]==0 || matrix[i][0]==0)\\n            matrix[i][j]=0;\\n        \\n        if(col0==0) matrix[i][0]=0;\\n\\n      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823987,
                "title": "wrong-test-case",
                "content": "The problem statement has a constraint:\\n\\n```-10^9 <= matrix[i][j] <= 10^9```\\n\\nyet one of the test cases that my code failed to process looks like this:\\n\\n```[[-4,-2147483648,6,-7,0],[-8,6,-8,-6,0],[2147483647,2,-9,-6,-10]]```\\n\\nI know how to solve the problem without that constraint, but the problem statement shouldn\\'t have included it in the first place. How do we fix the problem statement?",
                "solutionTags": [],
                "code": "```-10^9 <= matrix[i][j] <= 10^9```\n```[[-4,-2147483648,6,-7,0],[-8,6,-8,-6,0],[2147483647,2,-9,-6,-10]]```",
                "codeTag": "Unknown"
            },
            {
                "id": 744750,
                "title": "3-different-solutions-in-c",
                "content": "Solution 1 using queue\\n\\nIn worst case,\\nTime Complexity : O(nm*(n+m))\\nSpace Complexity : O(n*m)\\n\\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n                if(A[i][j] == 0)\\n                    q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            int f = q.front().first;\\n            int s = q.front().second;\\n            q.pop();\\n            \\n            for(int i=0; i<n; i++)\\n                A[i][s] = 0;\\n            \\n            for(int j=0; j<m; j++)\\n                A[f][j] = 0;\\n        }\\n    }\\n```\\n\\nSolution 2 with O(1) space:\\n\\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    for(int x=0; x<n; x++)\\n                        if(A[x][j] != 0)\\n                            A[x][j] = -1000000;\\n\\n                    for(int y=0; y<m; y++)\\n                        if(A[i][y] != 0)\\n                            A[i][y] = -1000000;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == -1000000)\\n                    A[i][j] = 0;\\n            }\\n        }\\n        \\n    }\\n```\\n\\nSolution 3 with O(1) space :\\n\\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        bool col = false;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(A[i][0] == 0)\\n                col = true;\\n            for(int j=1; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1; i<n; i++)\\n            for(int j=1; j<m; j++)\\n                if(A[i][0] == 0 || A[0][j] == 0)\\n                    A[i][j] = 0;\\n        \\n        //first row\\n        if(A[0][0] == 0)\\n            for(int j=1; j<m; j++)\\n                A[0][j] = 0;\\n        \\n        //first column\\n        if(col)\\n            for(int i=0; i<n; i++)\\n                A[i][0] = 0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n                if(A[i][j] == 0)\\n                    q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            int f = q.front().first;\\n            int s = q.front().second;\\n            q.pop();\\n            \\n            for(int i=0; i<n; i++)\\n                A[i][s] = 0;\\n            \\n            for(int j=0; j<m; j++)\\n                A[f][j] = 0;\\n        }\\n    }\\n```\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    for(int x=0; x<n; x++)\\n                        if(A[x][j] != 0)\\n                            A[x][j] = -1000000;\\n\\n                    for(int y=0; y<m; y++)\\n                        if(A[i][y] != 0)\\n                            A[i][y] = -1000000;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == -1000000)\\n                    A[i][j] = 0;\\n            }\\n        }\\n        \\n    }\\n```\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        bool col = false;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(A[i][0] == 0)\\n                col = true;\\n            for(int j=1; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1; i<n; i++)\\n            for(int j=1; j<m; j++)\\n                if(A[i][0] == 0 || A[0][j] == 0)\\n                    A[i][j] = 0;\\n        \\n        //first row\\n        if(A[0][0] == 0)\\n            for(int j=1; j<m; j++)\\n                A[0][j] = 0;\\n        \\n        //first column\\n        if(col)\\n            for(int i=0; i<n; i++)\\n                A[i][0] = 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656346,
                "title": "javascript-short-o-1-space-solution",
                "content": "```\\nvar setZeroes = function(matrix) {\\n    let col0 = 1, row = matrix.length, col = matrix[0].length;\\n    \\n    for(let i = 0; i < row; i++) {\\n        if(matrix[i][0] === 0) col0 = 0;\\n        for(let j = 1; j < col; j++) {\\n            if(matrix[i][j] === 0) {\\n                matrix[i][0] =  matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n    \\n    for(let i = row-1; i >= 0; i--) {\\n        for(let j = col-1; j > 0; j--) {\\n            if(matrix[i][0] === 0 || matrix[0][j] === 0) matrix[i][j] = 0;\\n        }\\n        if(col0 === 0) matrix[i][0] = 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n    let col0 = 1, row = matrix.length, col = matrix[0].length;\\n    \\n    for(let i = 0; i < row; i++) {\\n        if(matrix[i][0] === 0) col0 = 0;\\n        for(let j = 1; j < col; j++) {\\n            if(matrix[i][j] === 0) {\\n                matrix[i][0] =  matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n    \\n    for(let i = row-1; i >= 0; i--) {\\n        for(let j = col-1; j > 0; j--) {\\n            if(matrix[i][0] === 0 || matrix[0][j] === 0) matrix[i][j] = 0;\\n        }\\n        if(col0 === 0) matrix[i][0] = 0;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358555,
                "title": "java-solution-o-1-space-beats-100-in-time-with-explanation",
                "content": "We can reduce the space to O(1) by using the first row as a replacement for the row array and the first column as a replacement for the column array.This works as follows:\\n\\n1. Check if the first row and first column have any zeroes, and set variables rowHasZero and columnHasZero.(We\\'ll nullify the first row and first column later, if necessary.)\\n\\n2. Iterate through the rest of matrix, setting A[i][0] and A[0][j] to zero whenever there\\'s a zero in A[i][j].\\n\\n3. Iterate through rest of matrix, nullifying row i if there\\'s a zero in A[i][0].\\n\\n4. Iterate through rest of matrix, nullifying column j if there\\'s a zero in A[0][j].\\n\\n5. Nullify the first row and first column, if necessary(based on values from step 1).\\n\\nThe explanation is taken from the book \"Cracking The Coding Interview\" by Gayle Laakmann Mcdowell.\\n\\n```\\nclass Solution \\n{\\n    public void nullifyRow(int[][] A, int r)\\n    {\\n        int col = A[r].length;\\n        for(int i = 0; i < col; i++)\\n            A[r][i] = 0;\\n    }\\n    public void nullifyCol(int[][] A, int c)\\n    {\\n        int row = A.length;\\n        for(int i = 0; i < row; i++)\\n            A[i][c] = 0;\\n    }\\n    public void setZeroes(int[][] A) \\n    {\\n        if(A == null)\\n            return;\\n        \\n        boolean rowHasZero = false;\\n        boolean colHasZero = false;\\n        \\n        int row = A.length;\\n        int col = A[0].length;\\n        \\n        for(int i = 0; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n            {\\n                colHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int j = 0; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n            {\\n                rowHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            for(int j = 1; j < col; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n                nullifyRow(A, i);\\n        }\\n        \\n        for(int j = 1; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n                nullifyCol(A, j);\\n        }\\n        \\n        if(colHasZero)\\n        {\\n            nullifyCol(A, 0);\\n        }\\n        \\n        if(rowHasZero)\\n        {\\n            nullifyRow(A, 0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public void nullifyRow(int[][] A, int r)\\n    {\\n        int col = A[r].length;\\n        for(int i = 0; i < col; i++)\\n            A[r][i] = 0;\\n    }\\n    public void nullifyCol(int[][] A, int c)\\n    {\\n        int row = A.length;\\n        for(int i = 0; i < row; i++)\\n            A[i][c] = 0;\\n    }\\n    public void setZeroes(int[][] A) \\n    {\\n        if(A == null)\\n            return;\\n        \\n        boolean rowHasZero = false;\\n        boolean colHasZero = false;\\n        \\n        int row = A.length;\\n        int col = A[0].length;\\n        \\n        for(int i = 0; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n            {\\n                colHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int j = 0; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n            {\\n                rowHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            for(int j = 1; j < col; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n                nullifyRow(A, i);\\n        }\\n        \\n        for(int j = 1; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n                nullifyCol(A, j);\\n        }\\n        \\n        if(colHasZero)\\n        {\\n            nullifyCol(A, 0);\\n        }\\n        \\n        if(rowHasZero)\\n        {\\n            nullifyRow(A, 0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181671,
                "title": "simple-java-solution",
                "content": "```\\n    public void setZeroes(int[][] matrix) {\\n        boolean[] zeroRows = new boolean[matrix.length];\\n        boolean[] zeroColumns= new boolean[matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    zeroRows[i] = true;\\n                    zeroColumns[j] = true;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (zeroRows[i] || zeroColumns[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public void setZeroes(int[][] matrix) {\\n        boolean[] zeroRows = new boolean[matrix.length];\\n        boolean[] zeroColumns= new boolean[matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    zeroRows[i] = true;\\n                    zeroColumns[j] = true;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (zeroRows[i] || zeroColumns[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26141,
                "title": "my-c-solution-use-o-1-space-and-84ms",
                "content": "    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            int m = matrix.size();\\n            int n = matrix[0].size();\\n            \\n            if(m==0 || n==0) return;\\n            int row = -1, col = -1;\\n            for(int i=0; i<m; i++){\\n                if(row != -1) break;\\n                for(int j=0; j<n; j++){\\n                    if(matrix[i][j] == 0){\\n                        row = i;\\n                        col = j;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(row == -1) return;\\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    if(matrix[i][j] == 0){\\n                        matrix[i][col] = 0;\\n                        matrix[row][j] = 0;\\n                    }\\n                }\\n            }\\n            for(int i=0; i<m; i++){\\n                if(i == row) continue;\\n                if(matrix[i][col] == 0){\\n                    for(int j=0; j<n; j++) matrix[i][j] = 0;\\n                }\\n            }\\n            for(int j=0; j<n; j++){\\n                if(j == col) continue;\\n                if(matrix[row][j] == 0){\\n                    for(int i=0; i<m; i++) matrix[i][j] = 0;\\n                }\\n            }\\n            for(int i=0; i<m; i++) matrix[i][col] = 0;\\n            for(int j=0; j<n; j++) matrix[row][j] = 0;\\n        }\\n    };`enter code here`",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            int m = matrix.size();\\n            int n = matrix[0].size();\\n            \\n            if(m==0 || n==0) return;\\n            int row = -1, col = -1;\\n            for(int i=0; i<m; i++){\\n                if(row != -1) break;\\n                for(int j=0; j<n; j++){\\n                    if(matrix[i][j] == 0){\\n                        row = i;\\n                        col = j;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3958297,
                "title": "easy-c-solution-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n     int m=matrix.size();\\n     int n=matrix[0].size();\\n     bool isRow=false;\\n     bool isCol=false;\\n     for(int i=0;i<m;i++)\\n     {\\n         if(matrix[i][0]==0)\\n         isCol=true;\\n     }\\n     for(int j=0;j<n;j++)\\n     {\\n         if(matrix[0][j]==0)\\n         isRow=true;\\n     } \\n     for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][j]==0)\\n            {\\n                matrix[0][j]=0;\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n    for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][0]==0||matrix[0][j]==0)\\n            {\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }  \\n    if(isRow)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            matrix[0][i]=0;\\n        }\\n    }\\n    if(isCol)\\n    {\\n        for(int i=0;i<m;i++)\\n        {\\n            matrix[i][0]=0;\\n        }\\n    }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n     int m=matrix.size();\\n     int n=matrix[0].size();\\n     bool isRow=false;\\n     bool isCol=false;\\n     for(int i=0;i<m;i++)\\n     {\\n         if(matrix[i][0]==0)\\n         isCol=true;\\n     }\\n     for(int j=0;j<n;j++)\\n     {\\n         if(matrix[0][j]==0)\\n         isRow=true;\\n     } \\n     for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][j]==0)\\n            {\\n                matrix[0][j]=0;\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n    for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][0]==0||matrix[0][j]==0)\\n            {\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }  \\n    if(isRow)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            matrix[0][i]=0;\\n        }\\n    }\\n    if(isCol)\\n    {\\n        for(int i=0;i<m;i++)\\n        {\\n            matrix[i][0]=0;\\n        }\\n    }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697836,
                "title": "easy-cpp-solution-with-stepwise-detailed-explanation",
                "content": "# Intuition\\n To form a vector storing the index of 0 element\\'s row and column.\\n\\n# Approach\\n1. The function `setZeroes` takes a 2D vector `matrix` as input and does not return any value.\\n\\n2. It initializes two empty vectors `x` and `y`. These vectors will store the row and column indices of the cells that contain zeros in the matrix.\\n\\n3. It uses nested loops to iterate through each element of the matrix. If an element is equal to 0, it means we need to set the entire row and column containing that element to zero.\\n\\n4. If an element is found to be zero, its row index (`i`) is appended to the vector `x`, and its column index (`j`) is appended to the vector `y`.\\n\\n5. After iterating through the entire matrix, we have two vectors `x` and `y` that contain the row and column indices of the cells with zeros.\\n\\n6. The next step is to set the rows to zero. It iterates over the vector `x` and takes each index value. For each index, it sets all the elements of that row to zero by iterating through the columns (`m`).\\n\\n7. After setting the rows to zero, it moves on to setting the columns to zero. It iterates over the vector `y` and takes each index value. For each index, it sets all the elements of that column to zero by iterating through the rows (`n`).\\n\\n8. Once both the row and column modifications are completed, the function exits.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int>x,y;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    x.push_back(i);\\n                    y.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<x.size();i++)\\n        {\\n            int index=x[i];\\n            for(int j=0;j<m;j++)\\n            {\\n                matrix[index][j]=0;\\n            }\\n        }\\n         for(int i=0;i<y.size();i++)\\n        {\\n            int index=y[i];\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[j][index]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n# Please upvote for better reach!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int>x,y;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    x.push_back(i);\\n                    y.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<x.size();i++)\\n        {\\n            int index=x[i];\\n            for(int j=0;j<m;j++)\\n            {\\n                matrix[index][j]=0;\\n            }\\n        }\\n         for(int i=0;i<y.size();i++)\\n        {\\n            int index=y[i];\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[j][index]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692413,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->https://takeuforward.org/data-structure/set-matrix-zero/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(2(N*M))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++ ){\\n            if(matrix[i][0]==0)colm=0;\\n\\n            for(int j=1;j<col;j++ ){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n        }\\n        }\\n\\n        for(int i=row-1;i>=0;i--){\\n\\n            for(int j=col-1;j>=1;j--){\\n                if( matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(colm==0)matrix[i][0]=0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++ ){\\n            if(matrix[i][0]==0)colm=0;\\n\\n            for(int j=1;j<col;j++ ){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n        }\\n        }\\n\\n        for(int i=row-1;i>=0;i--){\\n\\n            for(int j=col-1;j>=1;j--){\\n                if( matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(colm==0)matrix[i][0]=0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648965,
                "title": "java-11-liner-solution-0ms-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n      int m = matrix.length, n = matrix[0].length, k = 0;\\n      // First row has zeroes ?\\n      while(k < n && matrix[0][k] != 0)  ++ k;\\n      // Use first row/column as marker, scan the matrix\\n      for(int i = 1; i < m; i ++) \\n        for(int j = 0; j < n; j ++)\\n         if(matrix[i][j] == 0)\\n          matrix[0][j] = matrix[i][0] = 0;\\n      // Set the zeros\\n      for(int i = 1; i < m; i ++)\\n        for(int j = n - 1; j >=0; j --)\\n         if(matrix[0][j] == 0 || matrix[i][0] == 0)\\n          matrix[i][j] = 0;\\n      // Set the zeros for the first row\\n      if(k < n) Arrays.fill(matrix[0], 0);\\n    }\\n}\\n```\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n      int m = matrix.length, n = matrix[0].length, k = 0;\\n      // First row has zeroes ?\\n      while(k < n && matrix[0][k] != 0)  ++ k;\\n      // Use first row/column as marker, scan the matrix\\n      for(int i = 1; i < m; i ++) \\n        for(int j = 0; j < n; j ++)\\n         if(matrix[i][j] == 0)\\n          matrix[0][j] = matrix[i][0] = 0;\\n      // Set the zeros\\n      for(int i = 1; i < m; i ++)\\n        for(int j = n - 1; j >=0; j --)\\n         if(matrix[0][j] == 0 || matrix[i][0] == 0)\\n          matrix[i][j] = 0;\\n      // Set the zeros for the first row\\n      if(k < n) Arrays.fill(matrix[0], 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632582,
                "title": "striver-approach-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n\\n        vector<int>row(n,0);\\n        vector<int>col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]==1|col[j]==1)\\n                {\\n                   matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n\\n        vector<int>row(n,0);\\n        vector<int>col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]==1|col[j]==1)\\n                {\\n                   matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612506,
                "title": "easiest-approach-brute-better-optimal-o-n-2-no-extra-space-fully-explained-beats-100",
                "content": "# BRUTE FORCE METHOD\\n## Approach:\\nThe steps are the following:\\n1. First, we will use two loops(nested loops) to traverse all the cells of the matrix.\\n2. If any cell (i,j) contains the value 0, we will mark all cells in row i and column j with -1 except those which contain 0.\\n3. We will perform step 2 for every cell containing 0.\\n4. Finally, we will mark all the cells containing -1 with 0.\\n5. Thus the given matrix will be modified according to the question.\\n\\n**Note:** *Here, we are assuming that the matrix does not contain any negative numbers. But if it contains negatives, we need to find some other ways to mark the cells instead of marking them with -1.*\\n\\n## Intuition:\\n\\nThis approach is very straightforward and we are just following the process stated in the question. But the following two questions need to be clarified to understand the algorithm further.\\n\\n## Complexity Analysis\\n**Time Complexity:** O((N\\\\*M)\\\\*(N + M)) + O(N\\\\*M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** Firstly, we are traversing the matrix to find the cells with the value 0. It takes O(N\\\\*M). Now, whenever we find any such cell we mark that row and column with -1. This process takes O(N+M). So, combining this the whole process, finding and marking, takes O((N\\\\*M)\\\\*(N + M)).\\nAnother O(N*M) is taken to mark all the cells with -1 as 0 finally.\\n\\n**Space Complexity:** O(1) as we are not using any extra space.\\n\\n# BETTER METHOD\\n## Approach (Using two extra arrays):\\n\\nThe steps are as follows:\\n\\n1. First, we will declare two arrays: a row array of size N and a col array of size M and both are initialized with 0.\\n2. Then, we will use two loops(nested loops) to traverse all the cells of the matrix.\\n3. If any cell (i,j) contains the value 0, we will mark ith index of row array i.e. row[i] and jth index of col array col[j] as 1. It signifies that all the elements in the ith row and jth column will be 0 in the final matrix.\\n4. We will perform step 3 for every cell containing 0.\\n5. Finally, we will again traverse the entire matrix and we will put 0 into all the cells (i, j) for which either row[i] or col[j] is marked as 1.\\n6. Thus we will get our final matrix.\\n\\n## Intuition:\\n\\nIn the previous approach, we were marking the cells with -1 while traversing the matrix. But in this approach, we are not marking the entire row and column instead, we are marking the ith index of **row** array i.e. row[i], and jth index of **col** array i.e. col[j] with 1. These marked indices of the two arrays, row and col will tell us for which rows and columns we need to change the values to 0. For any cell (i, j), if the row[i] or col[j] is marked with 1, we will change the value of cell(i, j) to 0.\\n\\nHere we are marking the cells after traversal whereas in the previous case, we were marking the cells while traversal. That is how the time complexity reduces in this case.\\n\\n## Complexity Analysis\\n**Time Complexity:** O(2\\\\*(N\\\\*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** We are traversing the entire matrix 2 times and each traversal is taking O(N*M) time complexity.\\n\\n**Space Complexity:** O(N) + O(M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** O(N) is for using the row array and O(M) is for using the col array.\\n\\n# OPTIMAL METHOD\\n## Intuition:\\nIn the previous approach, the time complexity is minimal as the traversal of a matrix takes at least O(N\\\\*M)(*where N = row and M = column*). In this approach, we can just improve the space complexity. So, instead of using two extra matrices row and col, we will use the 1st row and 1st column of the given matrix to keep a track of the cells that need to be marked with 0. But here comes a problem. If we try to use the 1st row and 1st column to serve the purpose, the cell matrix[0][0] is taken twice. To solve this problem we will take an extra variable col0 initialized with 1. Now the entire 1st row of the matrix will serve the purpose of the **row array**. And the 1st column from (0,1) to (0,m-1) with the col0 variable will serve the purpose of the **col array**.\\n\\nIf any cell in the 0th row contains 0, we will mark matrix[0][0] as 0 and if any cell in the 0th column contains 0, we will mark the col0 variable as 0.\\n\\nThus we can optimize the space complexity.\\n\\n## Approach: \\n\\nThe steps are as follows:\\n\\n1. First, we will traverse the matrix and mark the proper cells of 1st row and 1st column with 0 accordingly. The marking will be like this: if cell(i, j) contains 0, we will mark the i-th row i.e. matrix[i][0] with 0 and we will mark j-th column i.e. matrix[0][j] with 0.\\nIf i is 0, we will mark matrix[0][0] with 0 but if j is 0, we will mark the col0 variable with 0 instead of marking matrix[0][0] again.\\n2. After step 1 is completed, we will modify the cells from (1,1) to (n-1, m-1) using the values from the 1st row, 1st column, and col0 variable.\\n*We will not modify the 1st row and 1st column of the matrix here as the modification of the rest of the matrix(i.e. From (1,1) to (n-1, m-1)) is dependent on that row and column.*\\n3. Finally, we will change the 1st row and column using the values from matrix[0][0] and col0 variable. Here also we will change the row first and then the column.\\nIf matrix[0][0] = 0, we will change all the elements from the cell (0,1) to (0, m-1), to 0.\\nIf col0 = 0, we will change all the elements from the cell (0,0) to (n-1, 0), to 0.\\n\\n## Complexity Analysis\\n**Time Complexity:** O(2\\\\*(N\\\\*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** In this approach, we are also traversing the entire matrix 2 times and each traversal is taking O(N\\\\*M) time complexity.\\n\\n**Space Complexity:** O(1) as we are not using any extra space.\\n\\n# CODE\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        std::ios::sync_with_stdio(0); std::cin.tie(0);\\n        int n=matrix.size(), m=matrix[0].size(), col0=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0] = 0;\\n                    if(j!=0) matrix[0][j] = 0;\\n                    else col0 = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[0][j] == 0 || matrix[i][0] == 0) matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(matrix[0][0]==0){\\n            for(int j=0;j<m;j++) matrix[0][j] = 0;\\n        }\\n        if(col0 == 0){\\n            for(int i=0;i<n;i++) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/82c15abe-fec8-4e99-bbc1-e59479c122ab_1690651460.5963545.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        std::ios::sync_with_stdio(0); std::cin.tie(0);\\n        int n=matrix.size(), m=matrix[0].size(), col0=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0] = 0;\\n                    if(j!=0) matrix[0][j] = 0;\\n                    else col0 = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[0][j] == 0 || matrix[i][0] == 0) matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(matrix[0][0]==0){\\n            for(int j=0;j<m;j++) matrix[0][j] = 0;\\n        }\\n        if(col0 == 0){\\n            for(int i=0;i<n;i++) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497187,
                "title": "easy-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        keep track of rows and columns when ever we encounter 0\\n\\n        and then using stored info we will set all rows and col to 0\\n\\n        if set contains i and j we will set all the element to 0\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //keep track of rows and columns when ever we encounter 0\\n\\n        //and then using stored info we will set all rows and col to 0\\n\\n        HashSet<Integer> row= new HashSet<>();\\n        HashSet<Integer> col= new HashSet<>();\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n\\n        // if set contains i and j we will set all the element to 0\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++)\\n                if(row.contains(i) || col.contains(j)) matrix[i][j]=0;\\n        }\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //keep track of rows and columns when ever we encounter 0\\n\\n        //and then using stored info we will set all rows and col to 0\\n\\n        HashSet<Integer> row= new HashSet<>();\\n        HashSet<Integer> col= new HashSet<>();\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n\\n        // if set contains i and j we will set all the element to 0\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++)\\n                if(row.contains(i) || col.contains(j)) matrix[i][j]=0;\\n        }\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476709,
                "title": "c-better-approach-t-c-o-n-m-striver",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing extra row and col with initializes with 0\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate through every element in matrix and if 0 found then mark extra row and col equals to 1.\\nNow iterate through matrix and if row and col contains 1 then update matrix[i][j] to 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<int> row(r,0);\\n        vector<int> col(c,0);\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(row[i] || col[j])\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<int> row(r,0);\\n        vector<int> col(c,0);\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(row[i] || col[j])\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463953,
                "title": "java-solution-for-set-matrix-zeros-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution aims to set all the elements in a row or column of an input matrix to zero if any element in that row or column is zero. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is to first check if the first row and the first column have any zeros, as they will be used later to mark the remaining rows and columns that need to be set to zero. The algorithm then iterates over the input matrix, starting from the second row and the second column. For each element, if it is zero, it sets the corresponding elements in the first row and first column to zero. After marking the rows and columns that need to be set to zero, the algorithm then iterates over the input matrix again and sets the elements in marked rows and columns to zero. Finally, the algorithm checks if the first row and the first column need to be set to zero and sets them accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn), where m is the number of rows and n is the number of columns in the input matrix, as the algorithm needs to iterate over all elements in the matrix twice. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(1), as the algorithm uses only a constant amount of extra space to store the boolean variables used to track the presence of zeros in the first row and the first column.\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean firstRowZero = false;\\n        boolean firstColumnZero = false;\\n        //set first row and column zero or not\\n        for(int i=0; i<matrix.length; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                firstColumnZero = true;\\n                break;\\n            }\\n        }\\n        for(int i=0; i<matrix[0].length; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        //mark zeros on first row and column\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        //use mark to set elements\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        //set first column and row\\n        if(firstColumnZero)\\n        {\\n            for(int i=0; i<matrix.length; i++)\\n                matrix[i][0] = 0;\\n        }\\n        if(firstRowZero)\\n        {\\n            for(int i=0; i<matrix[0].length; i++)\\n                matrix[0][i] = 0;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean firstRowZero = false;\\n        boolean firstColumnZero = false;\\n        //set first row and column zero or not\\n        for(int i=0; i<matrix.length; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                firstColumnZero = true;\\n                break;\\n            }\\n        }\\n        for(int i=0; i<matrix[0].length; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        //mark zeros on first row and column\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        //use mark to set elements\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        //set first column and row\\n        if(firstColumnZero)\\n        {\\n            for(int i=0; i<matrix.length; i++)\\n                matrix[i][0] = 0;\\n        }\\n        if(firstRowZero)\\n        {\\n            for(int i=0; i<matrix[0].length; i++)\\n                matrix[0][i] = 0;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456258,
                "title": "optimal-solution-o-1-space-comp-c-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst row and First column is going to be marked to reduce Space complexity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int col0=1; // To ignore collision of the row and column,\\n                    // we can use this variable to indicate the first coloumn\\n        for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[i][j] == 0) {\\n                // mark i-th row:\\n                matrix[i][0] = 0;\\n\\n                // mark j-th column:\\n                if (j != 0)\\n                    matrix[0][j] = 0;\\n                else\\n                    col0 = 0;\\n            }\\n        }\\n    }\\n\\n    // Step 2: Mark with 0 from (1,1) to (n-1, m-1):\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[i][j] != 0) {\\n                // check for col & row:\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\n    //step 3: Finally mark the 1st col & then 1st row:\\n    if (matrix[0][0] == 0) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if (col0 == 0) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n\\n    }\\n};\\n```\\n# Upvote if it was helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int col0=1; // To ignore collision of the row and column,\\n                    // we can use this variable to indicate the first coloumn\\n        for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[i][j] == 0) {\\n                // mark i-th row:\\n                matrix[i][0] = 0;\\n\\n                // mark j-th column:\\n                if (j != 0)\\n                    matrix[0][j] = 0;\\n                else\\n                    col0 = 0;\\n            }\\n        }\\n    }\\n\\n    // Step 2: Mark with 0 from (1,1) to (n-1, m-1):\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[i][j] != 0) {\\n                // check for col & row:\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\n    //step 3: Finally mark the 1st col & then 1st row:\\n    if (matrix[0][0] == 0) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if (col0 == 0) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314911,
                "title": "1ms-optimised-java-solution-using-arrays",
                "content": "# Intuition\\n Instead of traversing through each row and column, we can use dummy arrays to check if the particular row or column has an element 0 or not, which will improve the time complexity.\\n\\n# Approach\\n   Take two dummy arrays one of size of the row and the other of size of column. Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n\\n# Complexity\\n- Time complexity:\\nO(N*M + N*M)\\n\\n- Space complexity:\\n O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int rows=matrix.length;\\n        int cols=matrix[0].length;\\n        int []dummy1=new int[rows];\\n        int []dummy2=new int[cols];\\n        Arrays.fill(dummy1,-1);\\n        Arrays.fill(dummy2,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0)\\n                    {dummy1[i]=0;\\n                   dummy2[j]=0;\\n            }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummy1[i]==0 || dummy2[j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int rows=matrix.length;\\n        int cols=matrix[0].length;\\n        int []dummy1=new int[rows];\\n        int []dummy2=new int[cols];\\n        Arrays.fill(dummy1,-1);\\n        Arrays.fill(dummy2,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0)\\n                    {dummy1[i]=0;\\n                   dummy2[j]=0;\\n            }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummy1[i]==0 || dummy2[j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181635,
                "title": "73-set-matrix-zeroes-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We use the first row and first column to store information about the rest of the matrix.\\n- If matrix[i][j] is 0, set matrix[i][0] and matrix[0][j] to 0.\\n- Use a variable called col0 to store information about the first column.\\n- Use the information stored in the first row and first column to set the rest of the matrix to 0s.\\n- We need to traverse the matrix in reverse order, so that we do not overwrite information that we need to use later.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # Use the first row and first column to store information about the rest of the matrix\\n        # If matrix[i][j] is 0, set matrix[i][0] and matrix[0][j] to 0\\n        # Use a variable called col0 to store information about the first column\\n        m, n = len(matrix), len(matrix[0])\\n        col0 = 1\\n        for i in range(m):\\n            if matrix[i][0] == 0:\\n                col0 = 0\\n            for j in range(1, n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n        # Use the information stored in the first row and first column to set the rest of the matrix to 0s\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, 0, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col0 == 0:\\n                matrix[i][0] = 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # Use the first row and first column to store information about the rest of the matrix\\n        # If matrix[i][j] is 0, set matrix[i][0] and matrix[0][j] to 0\\n        # Use a variable called col0 to store information about the first column\\n        m, n = len(matrix), len(matrix[0])\\n        col0 = 1\\n        for i in range(m):\\n            if matrix[i][0] == 0:\\n                col0 = 0\\n            for j in range(1, n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n        # Use the information stored in the first row and first column to set the rest of the matrix to 0s\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, 0, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col0 == 0:\\n                matrix[i][0] = 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902011,
                "title": "set-matrix-zeroes",
                "content": "class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int i,j;\\nint m=matrix.length;\\n //m indicates row\\nint n=matrix[0].length;\\n //n indicates column \\nint[][] arr=new int[m][n];\\n        for (i=0;i<m;i++)\\n            {\\n            for(j=0;j<n;j++){\\n  /* two loops required one for row traversal one for column traversal  */ \\n  arr[i][j]=matrix[i][j];\\n                }\\n            }\\n        for(i=0;i<m;i++)\\n            {\\n  for (j=0;j<n;j++)\\n      {\\n   if(arr[i][j]==0)\\n     func(i,j,matrix); \\n      } \\n    }\\n}\\npublic void func(int a,int b,int[][] matrix)\\n {                   for(int k=0;k<matrix\\n[0].length;k++)\\n     {\\n    matrix[a][k]=0; \\n    }\\nfor(int l=0;l<matrix. length;l++)\\n    {\\n    matrix[l][b]=0;\\n}\\n  }\\n   }                   \\n",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int i,j;\\nint m=matrix.length;\\n //m indicates row\\nint n=matrix[0].length;\\n //n indicates column \\nint[][] arr=new int[m][n];\\n        for (i=0;i<m;i++)\\n            {\\n            for(j=0;j<n;j++){\\n  /* two loops required one for row traversal one for column traversal  */ \\n  arr[i][j]=matrix[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2821742,
                "title": "my-o-mn-java-code-beats-100-submissions",
                "content": "# Intuition\\nThought of storing that zero in something then change all rows and column to zero accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public void makeRowZero(int[][] matrix, int row) {\\n        for (int i = 0; i < matrix[row].length; i++) {\\n            matrix[row][i] = 0;\\n        }\\n    }\\n\\n    public void makeColumnZero(int[][] matrix, int col) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            matrix[i][col] = 0;\\n        }\\n    }\\n\\n    public void setZeroes(int[][] matrix) {\\n        boolean[][] isZero = new boolean[matrix.length][matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    isZero[i][j] = true;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (isZero[i][j]) {\\n                    makeRowZero(matrix, i);\\n                    makeColumnZero(matrix, j);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n     public void makeRowZero(int[][] matrix, int row) {\\n        for (int i = 0; i < matrix[row].length; i++) {\\n            matrix[row][i] = 0;\\n        }\\n    }\\n\\n    public void makeColumnZero(int[][] matrix, int col) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            matrix[i][col] = 0;\\n        }\\n    }\\n\\n    public void setZeroes(int[][] matrix) {\\n        boolean[][] isZero = new boolean[matrix.length][matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    isZero[i][j] = true;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (isZero[i][j]) {\\n                    makeRowZero(matrix, i);\\n                    makeColumnZero(matrix, j);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818142,
                "title": "easy-java-solution-hashset",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> setRow = new HashSet<>();\\n        Set<Integer> setCol = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    setRow.add(i);\\n                    setCol.add(j);\\n                }\\n            }\\n        }\\n        for(int row : setRow){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[row][i] = 0;\\n            }\\n        }\\n        for(int col: setCol){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> setRow = new HashSet<>();\\n        Set<Integer> setCol = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    setRow.add(i);\\n                    setCol.add(j);\\n                }\\n            }\\n        }\\n        for(int row : setRow){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[row][i] = 0;\\n            }\\n        }\\n        for(int col: setCol){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807583,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tqueue<pair<int, int>>q;\\n\\t\\t\\t//vector<vector<int>>v(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\t\\t\\tfor(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<matrix[0].size(); j++){\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0){\\n\\t\\t\\t\\t\\t\\t//v[i][j]=1;\\n\\t\\t\\t\\t\\t\\tq.push({i, j});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint x=q.front().first, y=q.front().second;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tint x1=x, x2=x, x3=x, x4=x, y1=y, y2=y, y3=y, y4=y;\\n\\t\\t\\t\\t//cout<<x<<\" \"<<y<<endl;\\n\\t\\t\\t\\tif(x1>0){\\n\\t\\t\\t\\t\\twhile(x1>0){\\n\\t\\t\\t\\t\\t\\t//v[x1-1][y1]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x1-1][y1]=0;\\n\\t\\t\\t\\t\\t\\tx1--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(x2<matrix.size()-1){\\n\\t\\t\\t\\t\\twhile(x2<matrix.size()-1){\\n\\t\\t\\t\\t\\t\\t//v[x2+1][y]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x2+1][y2]=0;\\n\\t\\t\\t\\t\\t\\tx2++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(y3>0){\\n\\t\\t\\t\\t\\twhile(y3>0){\\n\\t\\t\\t\\t\\t\\t//v[x3][y3-1]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x3][y3-1]=0;\\n\\t\\t\\t\\t\\t\\ty3--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(y4<matrix[0].size()-1){\\n\\t\\t\\t\\t\\twhile(y4<matrix[0].size()-1){\\n\\t\\t\\t\\t\\t\\t//v[x4][y4+1]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x4][y4+1]=0;\\n\\t\\t\\t\\t\\t\\ty4++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tqueue<pair<int, int>>q;\\n\\t\\t\\t//vector<vector<int>>v(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\t\\t\\tfor(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<matrix[0].size(); j++){\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0){\\n\\t\\t\\t\\t\\t\\t//v[i][j]=1;\\n\\t\\t\\t\\t\\t\\tq.push({i, j}",
                "codeTag": "Java"
            },
            {
                "id": 2689157,
                "title": "1-ms-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstRowZero = false;\\n            boolean firstColumnZero = false;\\n            for(int i=0; i<matrix.length; i++){\\n                if(matrix[i][0] == 0){\\n                    firstColumnZero = true;\\n                    break;\\n                }\\n            }\\n            for(int i=0; i<matrix[0].length; i++){\\n                if(matrix[0][i] == 0){\\n                    firstRowZero = true;\\n                    break;\\n                }\\n\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][j] == 0){\\n                        matrix[i][0] = 0;\\n                        matrix[0][j] = 0;\\n                    }\\n                }\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                        matrix[i][j] = 0;\\n                    }\\n                }\\n            }\\n            if(firstColumnZero){\\n                for(int i=0; i<matrix.length; i++)\\n                    matrix[i][0] = 0;\\n            }\\n            if(firstRowZero){\\n                for(int i=0; i<matrix[0].length; i++)\\n                    matrix[0][i] = 0;\\n            }\\n        }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstRowZero = false;\\n            boolean firstColumnZero = false;\\n            for(int i=0; i<matrix.length; i++){\\n                if(matrix[i][0] == 0){\\n                    firstColumnZero = true;\\n                    break;\\n                }\\n            }\\n            for(int i=0; i<matrix[0].length; i++){\\n                if(matrix[0][i] == 0){\\n                    firstRowZero = true;\\n                    break;\\n                }\\n\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][j] == 0){\\n                        matrix[i][0] = 0;\\n                        matrix[0][j] = 0;\\n                    }\\n                }\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                        matrix[i][j] = 0;\\n                    }\\n                }\\n            }\\n            if(firstColumnZero){\\n                for(int i=0; i<matrix.length; i++)\\n                    matrix[i][0] = 0;\\n            }\\n            if(firstRowZero){\\n                for(int i=0; i<matrix[0].length; i++)\\n                    matrix[0][i] = 0;\\n            }\\n        }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653405,
                "title": "java-solution-easy",
                "content": "```\\n\\t\\tArrayList<Integer>l1=new ArrayList<>();\\n        ArrayList<Integer>l2=new ArrayList<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    l1.add(i);\\n                    l2.add(j);\\n                }\\n            }\\n        }\\n        \\n        for(int i:l1){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n        for(int i:l2){\\n            for(int j=0;j<matrix.length;j++){\\n                matrix[j][i]=0;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tArrayList<Integer>l1=new ArrayList<>();\\n        ArrayList<Integer>l2=new ArrayList<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    l1.add(i);\\n                    l2.add(j);\\n                }\\n            }\\n        }\\n        \\n        for(int i:l1){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n        for(int i:l2){\\n            for(int j=0;j<matrix.length;j++){\\n                matrix[j][i]=0;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2562319,
                "title": "java-solution-brute-force",
                "content": "it is the brute force which is easy to understand \\n\\n\\t\\tclass Solution {\\n\\t\\t  public void setZeroes(int[][] matrix) {\\n\\t\\t\\tint R = matrix.length;\\n\\t\\t\\tint C = matrix[0].length;\\n\\t\\t\\tSet<Integer> rows = new HashSet<Integer>();\\n\\t\\t\\tSet<Integer> cols = new HashSet<Integer>();\\n\\n\\t\\t\\t// Essentially, we mark the rows and columns that are to be made zero\\n\\t\\t\\tfor (int i = 0; i < R; i++) {\\n\\t\\t\\t  for (int j = 0; j < C; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t  rows.add(i);\\n\\t\\t\\t\\t  cols.add(j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Iterate over the array once again and using the rows and cols sets, update the elements.\\n\\t\\t\\tfor (int i = 0; i < R; i++) {\\n\\t\\t\\t  for (int j = 0; j < C; j++) {\\n\\t\\t\\t\\tif (rows.contains(i) || cols.contains(j)) {\\n\\t\\t\\t\\t  matrix[i][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\t\\t\\nif its relevant solution then plz upvote it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t  public void setZeroes(int[][] matrix) {\\n\\t\\t\\tint R = matrix.length;\\n\\t\\t\\tint C = matrix[0].length;\\n\\t\\t\\tSet<Integer> rows = new HashSet<Integer>();\\n\\t\\t\\tSet<Integer> cols = new HashSet<Integer>();\\n\\n\\t\\t\\t// Essentially, we mark the rows and columns that are to be made zero\\n\\t\\t\\tfor (int i = 0; i < R; i++) {\\n\\t\\t\\t  for (int j = 0; j < C; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t  rows.add(i);\\n\\t\\t\\t\\t  cols.add(j);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2437385,
                "title": "o-m-n-m-n-and-o-1-space-solution-using-randomization-approach",
                "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n           \\n      int k;\\n        bool ok=true;\\n        while(ok){\\n            \\n            ok=false;\\n            long long int p=(1LL<<32);\\n            \\n            k=(rand()%p)-(1<<31);\\n            \\n              for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==k){\\n                     \\n                     ok=true;\\n                     break;\\n                      \\n                 }\\n                \\n            }\\n                  \\n          }\\n            \\n        }\\n        \\n             for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==0){\\n                     \\n                     for(int jj=0;jj<arr[0].size();jj++){\\n                          if(arr[i][jj]){\\n                               arr[i][jj]=k; \\n                          }\\n                       \\n                     }\\n                     \\n                     for(int ii=0;ii<arr.size();ii++){\\n                              if(arr[ii][j]){\\n                               arr[ii][j]=k; \\n                          }\\n                     }\\n                      \\n                 }\\n                \\n            }\\n                  \\n          }\\n        \\n        \\n          for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==k){\\n                     \\n                    arr[i][j]=0;\\n                      \\n                 }\\n                \\n            }\\n                  \\n          }\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n           \\n      int k;\\n        bool ok=true;\\n        while(ok){\\n            \\n            ok=false;\\n            long long int p=(1LL<<32);\\n            \\n            k=(rand()%p)-(1<<31);\\n            \\n              for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==k){\\n                     \\n                     ok=true;\\n                     break;\\n                      \\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2399205,
                "title": "c-easy-explantion-set-matrix-zero",
                "content": "\\t// Traverse the matrix \\n\\t// Take two vector to mark the rows and column in which the entry is 0\\n\\t// finally mark matrix[i][j] is 0 if either of the row[i] or column[i] is 0  \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tint n=matrix.size();\\n\\t\\t\\tint m=matrix[0].size();\\n\\t\\t\\tvector<int>row(n,-1);\\n\\t\\t\\tvector<int>col(m,-1);\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\trow[i]=0; // marking that row in which element is zero\\n\\t\\t\\t\\t\\t\\tcol[j]=0; // marking that col in which element is x=zero\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(row[i]==0||col[j]==0)\\n\\t\\t\\t\\t\\t\\tmatrix[i][j]=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tint n=matrix.size();\\n\\t\\t\\tint m=matrix[0].size();\\n\\t\\t\\tvector<int>row(n,-1);\\n\\t\\t\\tvector<int>col(m,-1);\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\trow[i]=0; // marking that row in which element is zero\\n\\t\\t\\t\\t\\t\\tcol[j]=0; // marking that col in which element is x=zero\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2315182,
                "title": "c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rowZero;\\n        set<int> colZero;\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    rowZero.insert(i);\\n                    colZero.insert(j);\\n                }\\n            }\\n        }\\n        for(int rowIndex: rowZero){\\n            makeRowZero(matrix, rowIndex);\\n        }\\n        for(int colIndex: colZero){\\n           makeColZero(matrix, colIndex); \\n        }\\n        return;\\n        \\n    }\\n    private: void makeRowZero(vector<vector<int>>& matrix, int rindex){\\n        for(int i=0;i<matrix[0].size();i++){\\n          matrix[rindex][i]= 0;  \\n        }\\n    }\\n    private: void makeColZero(vector<vector<int>>& matrix, int cindex){\\n        for(int j=0;j<matrix.size();j++){\\n            matrix[j][cindex]=0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rowZero;\\n        set<int> colZero;\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    rowZero.insert(i);\\n                    colZero.insert(j);\\n                }\\n            }\\n        }\\n        for(int rowIndex: rowZero){\\n            makeRowZero(matrix, rowIndex);\\n        }\\n        for(int colIndex: colZero){\\n           makeColZero(matrix, colIndex); \\n        }\\n        return;\\n        \\n    }\\n    private: void makeRowZero(vector<vector<int>>& matrix, int rindex){\\n        for(int i=0;i<matrix[0].size();i++){\\n          matrix[rindex][i]= 0;  \\n        }\\n    }\\n    private: void makeColZero(vector<vector<int>>& matrix, int cindex){\\n        for(int j=0;j<matrix.size();j++){\\n            matrix[j][cindex]=0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250531,
                "title": "python-o-m-n-and-o-1-space-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n            \\n        n,m=len(matrix),len(matrix[0])\\n        col,row=False,False\\n        \\n    #check if first row and col has zero \\n    \\n        for i in range(n):\\n            if matrix[i][0]==0:col=True\\n        for i in range(m):\\n            if matrix[0][i]==0:row=True\\n                \\n    #if position has zero set first col and first row zero for that \\n    \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                if matrix[i][j]==0:\\n                    matrix[0][j]=matrix[i][0]=0\\n                    \\n    #for every zero in first col set zero for every postion on that row\\n    \\n        for i in range(1,n):\\n            if matrix[i][0]==0:\\n                for j in range(1,m):\\n                    matrix[i][j]=0\\n                \\n    #for every zero in first row set zero for every postion on that col\\n    \\n        for j in range(1,m):\\n            if matrix[0][j]==0:\\n                for i in range(1,n):\\n                     matrix[i][j]=0\\n                        \\n    # if any of the check is true change all postions to zero\\n\\n        if col:\\n            for i in range(n):\\n                matrix[i][0]=0\\n\\n        if row:\\n            for j in range(m):\\n                matrix[0][j]=0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n            \\n        n,m=len(matrix),len(matrix[0])\\n        col,row=False,False\\n        \\n    #check if first row and col has zero \\n    \\n        for i in range(n):\\n            if matrix[i][0]==0:col=True\\n        for i in range(m):\\n            if matrix[0][i]==0:row=True\\n                \\n    #if position has zero set first col and first row zero for that \\n    \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                if matrix[i][j]==0:\\n                    matrix[0][j]=matrix[i][0]=0\\n                    \\n    #for every zero in first col set zero for every postion on that row\\n    \\n        for i in range(1,n):\\n            if matrix[i][0]==0:\\n                for j in range(1,m):\\n                    matrix[i][j]=0\\n                \\n    #for every zero in first row set zero for every postion on that col\\n    \\n        for j in range(1,m):\\n            if matrix[0][j]==0:\\n                for i in range(1,n):\\n                     matrix[i][j]=0\\n                        \\n    # if any of the check is true change all postions to zero\\n\\n        if col:\\n            for i in range(n):\\n                matrix[i][0]=0\\n\\n        if row:\\n            for j in range(m):\\n                matrix[0][j]=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197878,
                "title": "striversdesheet-set-matrix-zero-brute-better-optimal",
                "content": "**Brute Force**\\nT.C = O(n * m) * O(n * m) + O(n*m)\\nS.C = O(1)\\n```\\n#define INF 1e9\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            if(matrix[i][j]==0){\\n                for(int k=0;k<cols;k++){\\n                   if(matrix[i][k]!=0){\\n                       matrix[i][k]=INF;\\n                   }\\n                }\\n            }\\n             if(matrix[i][j]==0){\\n                for(int k=0;k<rows;k++){\\n                   if(matrix[k][j]!=0){\\n                       matrix[k][j]=INF;\\n                   }\\n                }\\n            }\\n           \\n        }\\n    }\\n        for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            \\n            if(matrix[i][j]==INF){\\n                matrix[i][j]=0;\\n            }\\n            \\n        }}\\n        \\n\\n    }\\n};\\n```\\n\\n**BETTER**\\nT.C = O(n * m) + 2 * O(n * m)\\nS.C =O(n) + O(m)\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> u;\\n        vector<int> v;\\n        int rowsize=matrix.size();\\n        int colsize=matrix[0].size();\\n        for(int i=0;i<rowsize;i++){\\n            for(int j=0;j<colsize;j++){\\n                if(matrix[i][j]==0){\\n                    u.push_back(i);\\n                    v.push_back(j);\\n                }\\n            }\\n        }\\n        for(int m=0;m<u.size();m++){\\n            for(int p=0;p<colsize;p++){\\n            matrix[u[m]][p]=0;\\n        }\\n        }\\n        for(int n=0;n<v.size();n++){\\n          for(int q=0;q<rowsize;q++){\\n            matrix[q][v[n]]=0;\\n        }\\n        }\\n        \\n    }\\n};\\n```\\n\\n**OPTIMAL**\\nT.C = O(n * m) + O(n * m)\\nS.C =O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                matrix[i][j] = 0;\\n        if (col0 == 0) matrix[i][0] = 0;\\n    }\\n    }\\n};\\n\\n```\\nDo Upvote if this is helpful.\\nIf you have any query,DM me on this instagram id (usually active there) - \"__asif18  (https://www.instagram.com/__asif18/?hl=en)\"\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\n#define INF 1e9\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            if(matrix[i][j]==0){\\n                for(int k=0;k<cols;k++){\\n                   if(matrix[i][k]!=0){\\n                       matrix[i][k]=INF;\\n                   }\\n                }\\n            }\\n             if(matrix[i][j]==0){\\n                for(int k=0;k<rows;k++){\\n                   if(matrix[k][j]!=0){\\n                       matrix[k][j]=INF;\\n                   }\\n                }\\n            }\\n           \\n        }\\n    }\\n        for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            \\n            if(matrix[i][j]==INF){\\n                matrix[i][j]=0;\\n            }\\n            \\n        }}\\n        \\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> u;\\n        vector<int> v;\\n        int rowsize=matrix.size();\\n        int colsize=matrix[0].size();\\n        for(int i=0;i<rowsize;i++){\\n            for(int j=0;j<colsize;j++){\\n                if(matrix[i][j]==0){\\n                    u.push_back(i);\\n                    v.push_back(j);\\n                }\\n            }\\n        }\\n        for(int m=0;m<u.size();m++){\\n            for(int p=0;p<colsize;p++){\\n            matrix[u[m]][p]=0;\\n        }\\n        }\\n        for(int n=0;n<v.size();n++){\\n          for(int q=0;q<rowsize;q++){\\n            matrix[q][v[n]]=0;\\n        }\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                matrix[i][j] = 0;\\n        if (col0 == 0) matrix[i][0] = 0;\\n    }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195609,
                "title": "100-optimal-solution-explained",
                "content": "Easy to understand, detailed solution with step by step explanation with all approaches Brute-Better-Optimal and code in multiple languages:\\n\\nhttps://codewithkartik.com/2022/05/16/set-matrix-zeroes-leetcode-73-solution\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you find the solution useful, means a lot.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2108834,
                "title": "c-solution-faster-than-100-with-o-1-space-complexity",
                "content": "**Please up vote if you like the solution**\\n#### **Brute Force**\\nAssuming all the elements in the matrix are non-negative. Traverse through the matrix and if you find an element with value 0, then change all the elements in its row and column to -1, except when an element is 0. The reason for not changing other elements to 0, but -1, is because that might affect other columns and rows. Now traverse through the matrix again and if an element is -1 change it to 0, which will be the answer.\\n\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\\nTime Complexity : O ((N * M) * (N + M))\\nSpace Complexity:O (1)\\n.\\n.\\n.\\n\\n#### **Better Approach**\\nTake two dummy array one of size of row and other of size of column.Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\\n\\nTime Complexity: O(N * M + N * M)\\nSpace Complexity: O(N)\\nP.S : Credit for code of brute force and bette approach goes to take you forward now you can see my optimal solution.\\n.\\n.\\n.\\n#### **Optimal Solution**\\nInstead of taking two separate dummy array,take first row and column of the matrix as the array for checking whether the particular column or row has the value 0 or not.\\n\\n```\\nclass Solution {\\npublic:\\n    // use first col and first row as extra array \\n    void setZeroes(vector<vector<int>>& m) {\\n        // make 2 variable for row and collumns\\n        int a = m.size(), b = m[0].size();\\n        // 2 variables to store if we need to mark first row and first column as zero also at the end\\n        int f1 = 1, f2 = 1;\\n        for(int i = 0; i < a; i++)\\n        {\\n            for(int j = 0; j < b; j++)\\n            {\\n                if(m[i][j] == 0)\\n                {\\n                    // if index=0 and it is in first row and first column than f1=0 and f2=0\\n                    if(i == 0) f1 = 0;\\n                    if(j == 0) f2 = 0;\\n                    // if m[i][j]=0 than mark ith index of first col 0 and jth index of first row 0\\n                    if(i != 0 and j != 0)\\n                    {\\n                        m[0][j] = 0;\\n                        m[i][0] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 1; i < a; i++)\\n        {\\n            // check in the first column if any elemnt mark as zero and if yes than mark that full row zero\\n            if(m[i][0] == 0)\\n            {\\n                for(int j = 1; j < b; j++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        for(int j = 1; j < b; j++)\\n        {\\n            // check in the first row if any elemnt mark as zero and if yes than mark that full column zero\\n            if(m[0][j] == 0)\\n            {\\n                for(int i = 1; i < a; i++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check if first row need to be mark as fully by zeros\\n        if(f1 == 0)\\n        {\\n            for(int j = 0; j < b; j++)\\n                {\\n                    m[0][j] = 0;\\n                }\\n        }\\n        // check if first colmn need to be mark as fully by zeros\\n        if(f2 == 0)\\n        {\\n            for(int j = 0; j < a; j++)\\n                {\\n                    m[j][0] = 0;\\n                }\\n        }\\n    }\\n};\\n```\\nTime Complexity: O(N * M )\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    // use first col and first row as extra array \\n    void setZeroes(vector<vector<int>>& m) {\\n        // make 2 variable for row and collumns\\n        int a = m.size(), b = m[0].size();\\n        // 2 variables to store if we need to mark first row and first column as zero also at the end\\n        int f1 = 1, f2 = 1;\\n        for(int i = 0; i < a; i++)\\n        {\\n            for(int j = 0; j < b; j++)\\n            {\\n                if(m[i][j] == 0)\\n                {\\n                    // if index=0 and it is in first row and first column than f1=0 and f2=0\\n                    if(i == 0) f1 = 0;\\n                    if(j == 0) f2 = 0;\\n                    // if m[i][j]=0 than mark ith index of first col 0 and jth index of first row 0\\n                    if(i != 0 and j != 0)\\n                    {\\n                        m[0][j] = 0;\\n                        m[i][0] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 1; i < a; i++)\\n        {\\n            // check in the first column if any elemnt mark as zero and if yes than mark that full row zero\\n            if(m[i][0] == 0)\\n            {\\n                for(int j = 1; j < b; j++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        for(int j = 1; j < b; j++)\\n        {\\n            // check in the first row if any elemnt mark as zero and if yes than mark that full column zero\\n            if(m[0][j] == 0)\\n            {\\n                for(int i = 1; i < a; i++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check if first row need to be mark as fully by zeros\\n        if(f1 == 0)\\n        {\\n            for(int j = 0; j < b; j++)\\n                {\\n                    m[0][j] = 0;\\n                }\\n        }\\n        // check if first colmn need to be mark as fully by zeros\\n        if(f2 == 0)\\n        {\\n            for(int j = 0; j < a; j++)\\n                {\\n                    m[j][0] = 0;\\n                }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103145,
                "title": "simple-python-solution",
                "content": "\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        a,b=len(matrix),len(matrix[0])\\n        first_col,first_row=False,False\\n        for i in range(a):\\n            if matrix[i][0]==0:\\n                first_col=True\\n        for j in range(b):\\n            if matrix[0][j]==0:\\n                first_row=True\\n        for i in range(1,a):\\n            for j in range(1,b):\\n                if matrix[i][j]==0:\\n                    matrix[i][0]=0\\n                    matrix[0][j]=0\\n        for i in range(1,a):\\n            if matrix[i][0]==0:\\n                for j in range(1,b):\\n                    matrix[i][j]=0\\n        for i in range(1,b):\\n            if matrix[0][i]==0:\\n                for j in range(1,a):\\n                    matrix[j][i]=0\\n        if first_col:\\n            for i in range(a):\\n                matrix[i][0]=0\\n        if first_row:\\n            for i in range(b):\\n                matrix[0][i]=0\\n        return matrix\\n                \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        a,b=len(matrix),len(matrix[0])\\n        first_col,first_row=False,False\\n        for i in range(a):\\n            if matrix[i][0]==0:\\n                first_col=True\\n        for j in range(b):\\n            if matrix[0][j]==0:\\n                first_row=True\\n        for i in range(1,a):\\n            for j in range(1,b):\\n                if matrix[i][j]==0:\\n                    matrix[i][0]=0\\n                    matrix[0][j]=0\\n        for i in range(1,a):\\n            if matrix[i][0]==0:\\n                for j in range(1,b):\\n                    matrix[i][j]=0\\n        for i in range(1,b):\\n            if matrix[0][i]==0:\\n                for j in range(1,a):\\n                    matrix[j][i]=0\\n        if first_col:\\n            for i in range(a):\\n                matrix[i][0]=0\\n        if first_row:\\n            for i in range(b):\\n                matrix[0][i]=0\\n        return matrix\\n                \\n        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1967511,
                "title": "c-optimized-solution-o-n-x-m-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                matrix[i][j] = 0;\\n        if (col0 == 0) matrix[i][0] = 0;\\n    }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1921825,
                "title": "o-n-2-solution-for-absolute-beginners",
                "content": "Here\\'s my solution, which is not the optimal but it will help you build the foundation of the problem statement. \\n\\nSo, in this solution I keep two Sets [rol and col ] this sets stores - **while traversing the entire matrix have I ever encountered a 0 in either the row or the col**. \\nIf yes, then store the index in the SET.\\n\\nNow, iterate again through the matrix and check if either the row or col has ever encountered a 0 in the past: \\n\\t- if yes\\n\\t\\t- Set the [i][j] to 0\\n\\n\\nPretty straight forward right. \\n\\nGetting this result from LC\\n\\nRuntime: 91 ms, faster than 77.97% of JavaScript online submissions for Set Matrix Zeroes.\\nMemory Usage: 44.4 MB, less than 90.74% of JavaScript online submissions for Set Matrix Zeroes.\\n\\nHere\\'s the code.\\n\\n```\\nvar setZeroes = function (matrix) {\\n  const row = new Set();\\n  const col = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        row.add(i);\\n        col.add(j);\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (row.has(i) || col.has(j)) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  return matrix;\\n};\\n```\\n\\nHope you can optimize this on your own and do upvote it helped.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar setZeroes = function (matrix) {\\n  const row = new Set();\\n  const col = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        row.add(i);\\n        col.add(j);\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (row.has(i) || col.has(j)) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1893250,
                "title": "an-easy-approach-to-solve-set-matrix-zeroes-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int x=1;\\n        int y=1;\\n        \\n        for(int i=0; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                x=0;\\n        }\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                y=0;\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            for(int j=1; j<col; j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                for(int j=0; j<col; j++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        for(int j=1; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                for(int i=0; i<row; i++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        if(x==0)\\n        {\\n            for(int i=0; i<row; i++)\\n                matrix[i][0]=0;\\n        }\\n        \\n        if(y==0)\\n        {\\n            for(int j=0; j<col; j++)\\n                matrix[0][j]=0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int x=1;\\n        int y=1;\\n        \\n        for(int i=0; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                x=0;\\n        }\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                y=0;\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            for(int j=1; j<col; j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                for(int j=0; j<col; j++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        for(int j=1; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                for(int i=0; i<row; i++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        if(x==0)\\n        {\\n            for(int i=0; i<row; i++)\\n                matrix[i][0]=0;\\n        }\\n        \\n        if(y==0)\\n        {\\n            for(int j=0; j<col; j++)\\n                matrix[0][j]=0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860587,
                "title": "c-solution-by-using-o-n-space-to-record-indexes",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<pair<int,int>> v;\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(nums[i][j]==0){\\n                    v.push_back({i,j});\\n                    \\n                }\\n            }\\n        }\\n        for(auto it: v){\\n            int a=it.first;\\n            int b=it.second;\\n            for(int i=0;i<n;++i){\\n                nums[i][b]=0;\\n            }\\n            for(int i=0;i<m;++i){\\n                nums[a][i]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<pair<int,int>> v;\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(nums[i][j]==0){\\n                    v.push_back({i,j});\\n                    \\n                }\\n            }\\n        }\\n        for(auto it: v){\\n            int a=it.first;\\n            int b=it.second;\\n            for(int i=0;i<n;++i){\\n                nums[i][b]=0;\\n            }\\n            for(int i=0;i<m;++i){\\n                nums[a][i]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765705,
                "title": "set-matrix-to-zero-striver-s-sde-sheet-problem-no-1-brute-force",
                "content": "Python Solution \\nThis is a brute force based solution very helpful for beginners to understand\\nBasic Approach : \\n* **First**, checking the positions of zero and saving it in a new list\\n* **Second**, Just multiplying with 0 to update the values\\n\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        l=[]\\n        k=len(matrix)\\n        d=len(matrix[0])\\n        #LOOP FOR CHECKING THE POSITIONS OF ZERO\\n        for i in range(k):\\n            for j in range(d):\\n                if (matrix[i][j]==0):\\n                    l.append([i,j])\\n                    \\n        #LOOP FOR UPDATING THE MATRIX \\n        for h in range(len(l)):\\n            for p in range(d):\\n                matrix[l[h][0]][p]=matrix[l[h][0]][p] * 0 \\n            for g in range(k):\\n                matrix[g][l[h][1]]=matrix[g][l[h][1]]* 0 \\n        return matrix\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        l=[]\\n        k=len(matrix)\\n        d=len(matrix[0])\\n        #LOOP FOR CHECKING THE POSITIONS OF ZERO\\n        for i in range(k):\\n            for j in range(d):\\n                if (matrix[i][j]==0):\\n                    l.append([i,j])\\n                    \\n        #LOOP FOR UPDATING THE MATRIX \\n        for h in range(len(l)):\\n            for p in range(d):\\n                matrix[l[h][0]][p]=matrix[l[h][0]][p] * 0 \\n            for g in range(k):\\n                matrix[g][l[h][1]]=matrix[g][l[h][1]]* 0 \\n        return matrix\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727833,
                "title": "c-8ms-o-1-space-o-mn-time",
                "content": "# Gist of the solution\\n* Check if the 1st row and col contain any 0 or not if it does mark them zero.\\n* Iterate from 2nd row and col and mark all the top row/col element 0 if that row/col contains 0.\\n* now iterate over 1st col/row and mark all the elements in that row/col zero accordingly.\\n* now in the 1st step you stored the bool values of if the zero is present or not so according to that make the 1st row/col zero.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool row = false, col = false;\\n        \\n        for(int i=0; i<n; i++)\\n            if(matrix[i][0] == 0)\\n                col = true;\\n        \\n        for(int j=0; j<m; j++)\\n            if(matrix[0][j] == 0)\\n                row = true;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=1; j<m; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                //make the row zero\\n                for(int j=1;j<m;j++)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                for(int j=1; j<n; j++)\\n                {\\n                    matrix[j][i] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(col)\\n        {\\n            for(int i=0; i<n; i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0; i<m; i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool row = false, col = false;\\n        \\n        for(int i=0; i<n; i++)\\n            if(matrix[i][0] == 0)\\n                col = true;\\n        \\n        for(int j=0; j<m; j++)\\n            if(matrix[0][j] == 0)\\n                row = true;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=1; j<m; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                //make the row zero\\n                for(int j=1;j<m;j++)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                for(int j=1; j<n; j++)\\n                {\\n                    matrix[j][i] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(col)\\n        {\\n            for(int i=0; i<n; i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0; i<m; i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699059,
                "title": "easy-to-understand-in-c-matrix",
                "content": "class Solution {\\npublic:\\n\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<bool> row(m,false);\\n        vector<bool> col(n,false);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=true;\\n                    col[j]=true;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(row[i] || col[j]){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<bool> row(m,false);\\n        vector<bool> col(n,false);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=true;\\n                    col[j]=true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1668009,
                "title": "brute-better-optimal-java-with-comments-0ms-faster-than-100-striver",
                "content": "1.BRUTE FORCE APPROACH\\nLINEARLY TRAVERSING CHECKING IF THERE IS A ZERO IF YES THEN MARKING WHOLE ROW AND COL ZERO\\n```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n            int n = arr.length;\\n            int m = arr[0].length;\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == 0) {\\n                              //FOR MARKING WHOLE ROW 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < m; a++) {\\n                                    if (arr[i][a] != 0) {\\n                                          arr[i][a] = Integer.MIN_VALUE;\\n                                    }\\n\\n                              }\\n                              //FOR MARKING WHOLE COLUMN 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < n; a++) {\\n                                    if (arr[a][j] != 0) {\\n                                          arr[a][j] = Integer.MIN_VALUE;\\n                                    }\\n                              }\\n                        }\\n                  }\\n            }\\n            //THEN AT LAST MARKING ZERO AT PLACES OF Integer.MIN_VALUE\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == Integer.MIN_VALUE) {\\n                              arr[i][j] = 0;\\n                        }\\n                  }\\n            }\\n      }\\n}\\n```\\n2.BETTER APPROACH\\nBY TAKING TWO DUMMY ARRAYS.\\n```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          //making two dummy array\\n          int row[] = new int[n];\\n          int col[] = new int[m];\\n          for(int i=0;i<n;i++)\\n          {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                     row[i]=-1;\\n                     col[j]=-1;\\n                  }\\n              }   \\n          }\\n          //upto this point we filled our dummy array with zero.\\n          //i.e. 2 1D dummay array bnae then traverse kra given array ko ,, then as soon as we encounter 0 then we will mark 0 at i index of dummay array row and mark 0 at jth index of dummay array col->> after traversing the whole array we will know if there is a zero in given row or col or not.\\n      \\n          //again traverse through given array and with help of 1D dummy arrays check for the particular index that if in any one of row or col arrays there is a zero marked if yes then mark that particular index zero in the given array and so on.\\n           for(int i=0;i<n;i++)\\n           {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(row[i]==-1 || col[j]==-1)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n           }\\n      }\\n  }\\n  ```\\n 3.OPTIMAL APPROACH \\nTHIS APPROACH IS SAME AS BETTER APPROACH BUT INSTEAD OF TAKING TWO DUMMY ARRAYS WE USE FIRST ROW AND COL OF GIVEN MATRIX FOR CALCULATING ANSWER.\\n```\\n  class Solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          \\n          int colo=1;\\n          //THIS VARIABLE IS FOR ENSURING THAT WE WILL NOT MARK A WHOLE ROW OR COL ZERO BCZ OF PRESENCE OF A ZERO IN DUMMY PART OF ARRAY AS IT WILL RUIN OUR ANSWER SO WE ARE ASSUMING THAT WE HAVE CHECKED FOR FIRST ROW AND COL AND THEN STARTED TRAVERSING FROM  INDEX (1,1).\\n          for(int i=0;i<n;i++)\\n          {\\n              if(arr[i][0]==0)\\n              {\\n                  colo=0;\\n              }\\n              for(int j=1;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                      //IF FOUND ZERO THEN MARKING 0 IN THE UPPERMOST AND LEFTMOST PART ZERO i.e. MARKING 0 IN DUMMY ARRAY WHICH IS PRESENT IN OUR GIVEN ARRAY.\\n                      arr[i][0]=arr[0][j]=0; \\n                  }\\n              }   \\n          }\\n\\n          //STARTING FROM BACK AS WE WOULD NOT THEN WE WILL UPDATE OUR DUMMY ARRAY FIRST WHICH WHICH RUIN OUR ANSWER\\n          //EVERYTHING ELSE IS SAME LIKE BETTER APPROACH.\\n          //ONLY COLO IS THERE WHICH ENSURES THAT WE WILL NOT MARK OUR A WHOLE ROW ZERO BCZ OF PRESENCE OF A ZERO IN OUR DUMMY ARRAY.\\n          for(int i=n-1;i>=0;i--)\\n          {\\n            //TRAVESING FROM BACK\\n              for(int j=m-1;j>=1;j--)\\n              {\\n                  if(arr[i][0]==0 || arr[0][j]==0)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n              //IF WE FOUNF ZERO IN OU FIRST COL THEN WE WILL WHOLE COL ZERO.\\n              if(colo==0)\\n              {\\n                  arr[i][0]=0;\\n              }\\n          }\\n      }\\n  }\\n  ```\\n  Give it a upvote if you like it :)",
                "solutionTags": [],
                "code": "```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n            int n = arr.length;\\n            int m = arr[0].length;\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == 0) {\\n                              //FOR MARKING WHOLE ROW 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < m; a++) {\\n                                    if (arr[i][a] != 0) {\\n                                          arr[i][a] = Integer.MIN_VALUE;\\n                                    }\\n\\n                              }\\n                              //FOR MARKING WHOLE COLUMN 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < n; a++) {\\n                                    if (arr[a][j] != 0) {\\n                                          arr[a][j] = Integer.MIN_VALUE;\\n                                    }\\n                              }\\n                        }\\n                  }\\n            }\\n            //THEN AT LAST MARKING ZERO AT PLACES OF Integer.MIN_VALUE\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == Integer.MIN_VALUE) {\\n                              arr[i][j] = 0;\\n                        }\\n                  }\\n            }\\n      }\\n}\\n```\n```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          //making two dummy array\\n          int row[] = new int[n];\\n          int col[] = new int[m];\\n          for(int i=0;i<n;i++)\\n          {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                     row[i]=-1;\\n                     col[j]=-1;\\n                  }\\n              }   \\n          }\\n          //upto this point we filled our dummy array with zero.\\n          //i.e. 2 1D dummay array bnae then traverse kra given array ko ,, then as soon as we encounter 0 then we will mark 0 at i index of dummay array row and mark 0 at jth index of dummay array col->> after traversing the whole array we will know if there is a zero in given row or col or not.\\n      \\n          //again traverse through given array and with help of 1D dummy arrays check for the particular index that if in any one of row or col arrays there is a zero marked if yes then mark that particular index zero in the given array and so on.\\n           for(int i=0;i<n;i++)\\n           {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(row[i]==-1 || col[j]==-1)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n           }\\n      }\\n  }\\n  ```\n```\\n  class Solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          \\n          int colo=1;\\n          //THIS VARIABLE IS FOR ENSURING THAT WE WILL NOT MARK A WHOLE ROW OR COL ZERO BCZ OF PRESENCE OF A ZERO IN DUMMY PART OF ARRAY AS IT WILL RUIN OUR ANSWER SO WE ARE ASSUMING THAT WE HAVE CHECKED FOR FIRST ROW AND COL AND THEN STARTED TRAVERSING FROM  INDEX (1,1).\\n          for(int i=0;i<n;i++)\\n          {\\n              if(arr[i][0]==0)\\n              {\\n                  colo=0;\\n              }\\n              for(int j=1;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                      //IF FOUND ZERO THEN MARKING 0 IN THE UPPERMOST AND LEFTMOST PART ZERO i.e. MARKING 0 IN DUMMY ARRAY WHICH IS PRESENT IN OUR GIVEN ARRAY.\\n                      arr[i][0]=arr[0][j]=0; \\n                  }\\n              }   \\n          }\\n\\n          //STARTING FROM BACK AS WE WOULD NOT THEN WE WILL UPDATE OUR DUMMY ARRAY FIRST WHICH WHICH RUIN OUR ANSWER\\n          //EVERYTHING ELSE IS SAME LIKE BETTER APPROACH.\\n          //ONLY COLO IS THERE WHICH ENSURES THAT WE WILL NOT MARK OUR A WHOLE ROW ZERO BCZ OF PRESENCE OF A ZERO IN OUR DUMMY ARRAY.\\n          for(int i=n-1;i>=0;i--)\\n          {\\n            //TRAVESING FROM BACK\\n              for(int j=m-1;j>=1;j--)\\n              {\\n                  if(arr[i][0]==0 || arr[0][j]==0)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n              //IF WE FOUNF ZERO IN OU FIRST COL THEN WE WILL WHOLE COL ZERO.\\n              if(colo==0)\\n              {\\n                  arr[i][0]=0;\\n              }\\n          }\\n      }\\n  }\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1607797,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        \\n        boolean ispresent = false;\\n        for(int i=0; i<matrix.length; i++){\\n            if (matrix[i][0] == 0) ispresent = true;\\n            for(int j=1; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        for(int i=matrix.length-1; i>=0; i--){\\n            for(int j = matrix[0].length-1; j>=1; j--){\\n                if(matrix[0][j] == 0 || matrix[i][0] == 0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if (ispresent) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        \\n        boolean ispresent = false;\\n        for(int i=0; i<matrix.length; i++){\\n            if (matrix[i][0] == 0) ispresent = true;\\n            for(int j=1; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        for(int i=matrix.length-1; i>=0; i--){\\n            for(int j = matrix[0].length-1; j>=1; j--){\\n                if(matrix[0][j] == 0 || matrix[i][0] == 0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if (ispresent) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603669,
                "title": "easy-cpp-solution-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row (matrix.size(), -1) ; \\n        vector<int> col (matrix[0].size(), -1); \\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0; j< matrix[0].size(); j ++){\\n                if(matrix[i][j] == 0){\\n                    row[i] = 0; \\n                    col[j] = 0; \\n                }\\n            }\\n        }\\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0 ; j < matrix[0].size(); j ++){\\n                if(row[i]  ==0 || col[j] ==0){\\n                      matrix[i][j] = 0 ; \\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row (matrix.size(), -1) ; \\n        vector<int> col (matrix[0].size(), -1); \\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0; j< matrix[0].size(); j ++){\\n                if(matrix[i][j] == 0){\\n                    row[i] = 0; \\n                    col[j] = 0; \\n                }\\n            }\\n        }\\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0 ; j < matrix[0].size(); j ++){\\n                if(row[i]  ==0 || col[j] ==0){\\n                      matrix[i][j] = 0 ; \\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585200,
                "title": "c-2-approaches-clean-self-explanatory-with-comments",
                "content": "Here I have discussed 2 Different approaches. The first one uses sets instead of maps and the Second one uses Constant Space.\\n___\\n**Approach 1: Two pass algo Using Set\\nTime: O(n^2logn), Space: O(max(n, m))**\\n**Runtime: 16ms\\nMemory: 13.5MB**\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return;\\n        int cols = matrix[0].size();\\n        set<int> row; // to keep track of row index with 0\\n        set<int> col; // to keep track of column index with 0\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row.insert(i); // insert row and column index to be set to zero in the respective sets\\n                    col.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(row.count(i) || col.count(j)) // if the current index is present in row or column, set it to zero\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }  \\n    }\\n};\\n```\\n____\\n**Approach 2: Constant space**\\n**Runtime: 4ms\\nMemory: 13.1MB**\\nLogic: Use the first column and first row, as an indicator.\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return ;\\n        int cols = matrix[0].size();\\n        bool FirstRow = false;\\n        bool FirstCol = false;\\n\\n        for(int i=0 ; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                if(matrix[i][j]==0) // set indicators of first row and col to 0\\n                {\\n                    if(i==0) FirstRow = true;\\n                    if(j==0) FirstCol = true;\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<rows; i++)\\n        {\\n            for(int j=1; j<cols; j++)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0) // if indicator was set to 0, set matrix[i][j] to 0\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(FirstRow) // if first row had a zero, reset the first col to 0\\n        {\\n            for(int i=0 ;i<cols;i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if(FirstCol) // if first column had a zero, reset the first row to 0\\n        {\\n            for(int i=0;i<rows;i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n____\\nPlease comment down if you find any mistakes/ improvements \\u270C.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return;\\n        int cols = matrix[0].size();\\n        set<int> row; // to keep track of row index with 0\\n        set<int> col; // to keep track of column index with 0\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row.insert(i); // insert row and column index to be set to zero in the respective sets\\n                    col.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(row.count(i) || col.count(j)) // if the current index is present in row or column, set it to zero\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return ;\\n        int cols = matrix[0].size();\\n        bool FirstRow = false;\\n        bool FirstCol = false;\\n\\n        for(int i=0 ; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                if(matrix[i][j]==0) // set indicators of first row and col to 0\\n                {\\n                    if(i==0) FirstRow = true;\\n                    if(j==0) FirstCol = true;\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<rows; i++)\\n        {\\n            for(int j=1; j<cols; j++)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0) // if indicator was set to 0, set matrix[i][j] to 0\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(FirstRow) // if first row had a zero, reset the first col to 0\\n        {\\n            for(int i=0 ;i<cols;i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if(FirstCol) // if first column had a zero, reset the first row to 0\\n        {\\n            for(int i=0;i<rows;i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538988,
                "title": "c-approach-with-0-n-and0-1-space-complexity",
                "content": "O(N) space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        unordered_map<int,int>row;\\n        unordered_map<int,int>col;\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(row.count(i)==1||col.count(j)==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\nO(1) space complexity\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        \\n        bool row=false;\\n        bool col=false;\\n       for(int i=0;i<matrix.size();i++)\\n        {\\n            if(matrix[i][0]==0)\\n            {\\n               col=true;\\n            \\n            }\\n         }   \\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[0][j]==0)\\n                {\\n                   \\n                    row=true;\\n                }\\n            }\\n        \\n        \\n        for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][j]==0) \\n               {\\n                   matrix[0][j]=0;\\n                   matrix[i][0]=0;\\n                  \\n                 \\n                   \\n               }\\n            }\\n        }\\n         for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][0]==0||matrix[0][j]==0)\\n               {\\n                  matrix[i][j]=0;\\n                 \\n               }\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0;i<matrix[0].size();i++)\\n            {\\n                matrix[0][i]=0;\\n            }\\n        }\\n        if(col)\\n        {\\n         for(int i=0;i<matrix.size();i++)\\n            {\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        unordered_map<int,int>row;\\n        unordered_map<int,int>col;\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(row.count(i)==1||col.count(j)==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        \\n        bool row=false;\\n        bool col=false;\\n       for(int i=0;i<matrix.size();i++)\\n        {\\n            if(matrix[i][0]==0)\\n            {\\n               col=true;\\n            \\n            }\\n         }   \\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[0][j]==0)\\n                {\\n                   \\n                    row=true;\\n                }\\n            }\\n        \\n        \\n        for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][j]==0) \\n               {\\n                   matrix[0][j]=0;\\n                   matrix[i][0]=0;\\n                  \\n                 \\n                   \\n               }\\n            }\\n        }\\n         for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][0]==0||matrix[0][j]==0)\\n               {\\n                  matrix[i][j]=0;\\n                 \\n               }\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0;i<matrix[0].size();i++)\\n            {\\n                matrix[0][i]=0;\\n            }\\n        }\\n        if(col)\\n        {\\n         for(int i=0;i<matrix.size();i++)\\n            {\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443826,
                "title": "python-o-1-space-two-pass-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        first_row = 0\\n        first_col = 0\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for row_i in range(m):\\n            for col_j in range(n):\\n                if matrix[row_i][col_j] == 0:\\n                    if row_i == 0:\\n                        first_row = 1\\n                    if col_j == 0:\\n                        first_col = 1\\n                    if row_i != 0 and col_j != 0:\\n                        # mark col_j has a zero\\n                        matrix[0][col_j] = 0\\n                        # mark row_i has a zero\\n                        matrix[row_i][0] = 0\\n        \\n        # set zero to rows         \\n        for row_i in range(1, m):\\n            if matrix[row_i][0] == 0:\\n                for col_j in range(n):\\n                    matrix[row_i][col_j] = 0\\n                    \\n        # set zero to columns         \\n        for col_j in range(1, n):\\n            if matrix[0][col_j] == 0:\\n                for row_i in range(m):\\n                    matrix[row_i][col_j] = 0\\n\\n        # set zero to first row\\n        if first_row == 1:\\n            for col_j in range(n):\\n                matrix[0][col_j] = 0\\n                \\n        # set zero to first column\\n        if first_col == 1:\\n            for row_i in range(m):\\n                matrix[row_i][0] = 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        first_row = 0\\n        first_col = 0\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for row_i in range(m):\\n            for col_j in range(n):\\n                if matrix[row_i][col_j] == 0:\\n                    if row_i == 0:\\n                        first_row = 1\\n                    if col_j == 0:\\n                        first_col = 1\\n                    if row_i != 0 and col_j != 0:\\n                        # mark col_j has a zero\\n                        matrix[0][col_j] = 0\\n                        # mark row_i has a zero\\n                        matrix[row_i][0] = 0\\n        \\n        # set zero to rows         \\n        for row_i in range(1, m):\\n            if matrix[row_i][0] == 0:\\n                for col_j in range(n):\\n                    matrix[row_i][col_j] = 0\\n                    \\n        # set zero to columns         \\n        for col_j in range(1, n):\\n            if matrix[0][col_j] == 0:\\n                for row_i in range(m):\\n                    matrix[row_i][col_j] = 0\\n\\n        # set zero to first row\\n        if first_row == 1:\\n            for col_j in range(n):\\n                matrix[0][col_j] = 0\\n                \\n        # set zero to first column\\n        if first_col == 1:\\n            for row_i in range(m):\\n                matrix[row_i][0] = 0\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568894,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1568426,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1717997,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1567435,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1910323,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1896295,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 2072155,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1957833,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1723363,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1880578,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1568894,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1568426,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1717997,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1567435,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1910323,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1896295,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 2072155,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1957833,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1723363,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1880578,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1722130,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 1751220,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2070767,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2049456,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2048904,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2045278,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2035724,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2022710,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2016559,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2006780,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 1977879,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1973443,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1970018,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1968123,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1968121,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1959245,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1941395,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1931791,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1930988,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1878406,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1832037,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1832036,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1830790,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1754123,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1753767,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1746384,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1743408,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1724739,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1710064,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1710042,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Search Tree Iterator",
        "question_content": "<p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\" target=\"_blank\">in-order traversal</a></strong> of a binary search tree (BST):</p>\n\n<ul>\n\t<li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li>\n\t<li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li>\n</ul>\n\n<p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p>\n\n<p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style=\"width: 189px; height: 178px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n<strong>Output</strong>\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n<strong>Explanation</strong>\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls will be made to <code>hasNext</code>, and <code>next</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Could you implement <code>next()</code> and <code>hasNext()</code> to run in average <code>O(1)</code> time and use&nbsp;<code>O(h)</code> memory, where <code>h</code> is the height of the tree?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 52525,
                "title": "my-solutions-in-3-languages-with-stack",
                "content": "I use Stack to store directed left children from root.\\nWhen next() be called, I just pop one element and process its right child as new root.\\nThe code is pretty straightforward.\\n\\nSo this can satisfy O(h) memory, hasNext() in O(1) time,\\nBut next() is O(h) time.\\n\\nI can't find a solution that can satisfy both next() in O(1) time, space in O(h).\\n\\nJava:\\n\\n    public class BSTIterator {\\n        private Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        public BSTIterator(TreeNode root) {\\n            pushAll(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            TreeNode tmpNode = stack.pop();\\n            pushAll(tmpNode.right);\\n            return tmpNode.val;\\n        }\\n        \\n        private void pushAll(TreeNode node) {\\n            for (; node != null; stack.push(node), node = node.left);\\n        }\\n    }\\n\\nC++:\\n\\n\\n    class BSTIterator {\\n        stack<TreeNode *> myStack;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            pushAll(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !myStack.empty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode *tmpNode = myStack.top();\\n            myStack.pop();\\n            pushAll(tmpNode->right);\\n            return tmpNode->val;\\n        }\\n    \\n    private:\\n        void pushAll(TreeNode *node) {\\n            for (; node != NULL; myStack.push(node), node = node->left);\\n        }\\n    };\\n\\n\\nPython:\\n\\n    class BSTIterator:\\n        # @param root, a binary search tree's root node\\n        def __init__(self, root):\\n            self.stack = list()\\n            self.pushAll(root)\\n    \\n        # @return a boolean, whether we have a next smallest number\\n        def hasNext(self):\\n            return self.stack\\n    \\n        # @return an integer, the next smallest number\\n        def next(self):\\n            tmpNode = self.stack.pop()\\n            self.pushAll(tmpNode.right)\\n            return tmpNode.val\\n            \\n        def pushAll(self, node):\\n            while node is not None:\\n                self.stack.append(node)\\n                node = node.left",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "I use Stack to store directed left children from root.\\nWhen next() be called, I just pop one element and process its right child as new root.\\nThe code is pretty straightforward.\\n\\nSo this can satisfy O(h) memory, hasNext() in O(1) time,\\nBut next() is O(h) time.\\n\\nI can't find a solution that can satisfy both next() in O(1) time, space in O(h).\\n\\nJava:\\n\\n    public class BSTIterator {\\n        private Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        public BSTIterator(TreeNode root) {\\n            pushAll(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            TreeNode tmpNode = stack.pop();\\n            pushAll(tmpNode.right);\\n            return tmpNode.val;\\n        }\\n        \\n        private void pushAll(TreeNode node) {\\n            for (; node != null; stack.push(node), node = node.left);\\n        }\\n    }\\n\\nC++:\\n\\n\\n    class BSTIterator {\\n        stack<TreeNode *> myStack;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            pushAll(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !myStack.empty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode *tmpNode = myStack.top();\\n            myStack.pop();\\n            pushAll(tmpNode->right);\\n            return tmpNode->val;\\n        }\\n    \\n    private:\\n        void pushAll(TreeNode *node) {\\n            for (; node != NULL; myStack.push(node), node = node->left);\\n        }\\n    };\\n\\n\\nPython:\\n\\n    class BSTIterator:\\n        # @param root, a binary search tree's root node\\n        def __init__(self, root):\\n            self.stack = list()\\n            self.pushAll(root)\\n    \\n        # @return a boolean, whether we have a next smallest number\\n        def hasNext(self):\\n            return self.stack\\n    \\n        # @return an integer, the next smallest number\\n        def next(self):\\n            tmpNode = self.stack.pop()\\n            self.pushAll(tmpNode.right)\\n            return tmpNode.val\\n            \\n        def pushAll(self, node):\\n            while node is not None:\\n                self.stack.append(node)\\n                node = node.left",
                "codeTag": "Java"
            },
            {
                "id": 52526,
                "title": "ideal-solution-using-stack-java",
                "content": "My idea comes from this: My first thought was to use inorder traversal to put every node into an array, and then make an index pointer for the next() and hasNext(). That meets the O(1) run time but not the O(h) memory. O(h) is really much more less than O(n) when the tree is huge.\\n\\nThis means I cannot use a lot of memory, which suggests that I need to make use of the tree structure itself. And also, one thing to notice is the \"average O(1) run time\". It's weird to say average O(1), because there's nothing below O(1) in run time, which suggests in most cases, I solve it in O(1), while in some cases, I need to solve it in O(n) or O(h). These two limitations are big hints.\\n\\nBefore I come up with this solution, I really draw a lot binary trees and try inorder traversal on them. We all know that, once you get to a TreeNode, in order to get the smallest, you need to go all the way down its left branch. So our first step is to point to pointer to the left most TreeNode. The problem is how to do back trace. Since the TreeNode doesn't have father pointer, we cannot get a TreeNode's father node in O(1) without store it beforehand. Back to the first step, when we are traversal to the left most TreeNode, we store each TreeNode we met ( They are all father nodes for back trace). \\n\\nAfter that, I try an example, for next(), I directly return where the pointer pointing at, which should be the left most TreeNode I previously found. What to do next? After returning the smallest TreeNode, I need to point the pointer to the next smallest TreeNode. When the current TreeNode has a right branch (It cannot have left branch, remember we traversal to the left most), we need to jump to its right child first and then traversal to its right child's left most TreeNode. When the current TreeNode doesn't have a right branch, it means there cannot be a node with value smaller than itself father node, point the pointer at its father node.\\n\\nThe overall thinking leads to the structure Stack, which fits my requirement so well.\\n\\n    /**\\n     * Definition for binary tree\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    \\n    public class BSTIterator {\\n        \\n        private Stack<TreeNode> stack;\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<>();\\n            TreeNode cur = root;\\n            while(cur != null){\\n                stack.push(cur);\\n                if(cur.left != null)\\n                    cur = cur.left;\\n                else\\n                    break;\\n            }\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            TreeNode node = stack.pop();\\n            TreeNode cur = node;\\n            // traversal right branch\\n            if(cur.right != null){\\n                cur = cur.right;\\n                while(cur != null){\\n                    stack.push(cur);\\n                    if(cur.left != null)\\n                        cur = cur.left;\\n                    else\\n                        break;\\n                }\\n            }\\n            return node.val;\\n        }\\n    }\\n    \\n    /**\\n     * Your BSTIterator will be called like this:\\n     * BSTIterator i = new BSTIterator(root);\\n     * while (i.hasNext()) v[f()] = i.next();\\n     */",
                "solutionTags": [
                    "Java"
                ],
                "code": "My idea comes from this: My first thought was to use inorder traversal to put every node into an array, and then make an index pointer for the next() and hasNext(). That meets the O(1) run time but not the O(h) memory. O(h) is really much more less than O(n) when the tree is huge.\\n\\nThis means I cannot use a lot of memory, which suggests that I need to make use of the tree structure itself. And also, one thing to notice is the \"average O(1) run time\". It's weird to say average O(1), because there's nothing below O(1) in run time, which suggests in most cases, I solve it in O(1), while in some cases, I need to solve it in O(n) or O(h). These two limitations are big hints.\\n\\nBefore I come up with this solution, I really draw a lot binary trees and try inorder traversal on them. We all know that, once you get to a TreeNode, in order to get the smallest, you need to go all the way down its left branch. So our first step is to point to pointer to the left most TreeNode. The problem is how to do back trace. Since the TreeNode doesn't have father pointer, we cannot get a TreeNode's father node in O(1) without store it beforehand. Back to the first step, when we are traversal to the left most TreeNode, we store each TreeNode we met ( They are all father nodes for back trace). \\n\\nAfter that, I try an example, for next(), I directly return where the pointer pointing at, which should be the left most TreeNode I previously found. What to do next? After returning the smallest TreeNode, I need to point the pointer to the next smallest TreeNode. When the current TreeNode has a right branch (It cannot have left branch, remember we traversal to the left most), we need to jump to its right child first and then traversal to its right child's left most TreeNode. When the current TreeNode doesn't have a right branch, it means there cannot be a node with value smaller than itself father node, point the pointer at its father node.\\n\\nThe overall thinking leads to the structure Stack, which fits my requirement so well.\\n\\n    /**\\n     * Definition for binary tree\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    \\n    public class BSTIterator {\\n        \\n        private Stack<TreeNode> stack;\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<>();\\n            TreeNode cur = root;\\n            while(cur != null){\\n                stack.push(cur);\\n                if(cur.left != null)\\n                    cur = cur.left;\\n                else\\n                    break;\\n            }\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            TreeNode node = stack.pop();\\n            TreeNode cur = node;\\n            // traversal right branch\\n            if(cur.right != null){\\n                cur = cur.right;\\n                while(cur != null){\\n                    stack.push(cur);\\n                    if(cur.left != null)\\n                        cur = cur.left;\\n                    else\\n                        break;\\n                }\\n            }\\n            return node.val;\\n        }\\n    }\\n    \\n    /**\\n     * Your BSTIterator will be called like this:\\n     * BSTIterator i = new BSTIterator(root);\\n     * while (i.hasNext()) v[f()] = i.next();\\n     */",
                "codeTag": "Java"
            },
            {
                "id": 52647,
                "title": "nice-comparison-and-short-solution",
                "content": "Compare this typical iterative inorder traversal\\n\\n    1.    TreeNode visit = root;\\n          Stack<TreeNode> stack = new Stack();\\n    2.    while (visit != null || !stack.empty()) {\\n    3.        while (visit != null) {\\n                  stack.push(visit);\\n                  visit = visit.left;\\n              }\\n              TreeNode next = stack.pop();\\n              visit = next.right;\\n              doSomethingWith(next.val);\\n          }\\n\\nwith what we're supposed to support here:\\n\\n    1.    BSTIterator i = new BSTIterator(root);\\n    2.    while (i.hasNext())\\n    3.        doSomethingWith(i.next());\\n\\nYou can see they already have the exact same structure:\\n\\n1. Some **initialization**.\\n2. A while-loop with **a condition that tells whether there is more**.\\n3. The loop body **gets the next value** and does something with it.\\n\\nSo simply put the three parts of that iterative solution into our three iterator methods:\\n\\n    public class BSTIterator {\\n    \\n        private TreeNode visit;\\n        private Stack<TreeNode> stack;\\n        \\n        public BSTIterator(TreeNode root) {\\n            visit = root;\\n            stack = new Stack();\\n        }\\n    \\n        public boolean hasNext() {\\n            return visit != null || !stack.empty();\\n        }\\n    \\n        public int next() {\\n            while (visit != null) {\\n                stack.push(visit);\\n                visit = visit.left;\\n            }\\n            TreeNode next = stack.pop();\\n            visit = next.right;\\n            return next.val;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Compare this typical iterative inorder traversal\\n\\n    1.    TreeNode visit = root;\\n          Stack<TreeNode> stack = new Stack();\\n    2.    while (visit != null || !stack.empty()) {\\n    3.        while (visit != null) {\\n                  stack.push(visit);\\n                  visit = visit.left;\\n              }\\n              TreeNode next = stack.pop();\\n              visit = next.right;\\n              doSomethingWith(next.val);\\n          }\\n\\nwith what we're supposed to support here:\\n\\n    1.    BSTIterator i = new BSTIterator(root);\\n    2.    while (i.hasNext())\\n    3.        doSomethingWith(i.next());\\n\\nYou can see they already have the exact same structure:\\n\\n1. Some **initialization**.\\n2. A while-loop with **a condition that tells whether there is more**.\\n3. The loop body **gets the next value** and does something with it.\\n\\nSo simply put the three parts of that iterative solution into our three iterator methods:\\n\\n    public class BSTIterator {\\n    \\n        private TreeNode visit;\\n        private Stack<TreeNode> stack;\\n        \\n        public BSTIterator(TreeNode root) {\\n            visit = root;\\n            stack = new Stack();\\n        }\\n    \\n        public boolean hasNext() {\\n            return visit != null || !stack.empty();\\n        }\\n    \\n        public int next() {\\n            while (visit != null) {\\n                stack.push(visit);\\n                visit = visit.left;\\n            }\\n            TreeNode next = stack.pop();\\n            visit = next.right;\\n            return next.val;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1430547,
                "title": "c-simple-solution-using-stack-o-h-time-complexity-with-diagrammatic-explanation",
                "content": "We could have easily done this question by using inorder traversal and storing it in a vector after that iterating every index of vector for next() value and if the index is equal to vector size then hasnext() becomes false else it would be true.\\n\\nBut in question, it is given that we have to do it in **0(h) memory, where h is the height of the tree.** So now we will make use of the stack and instead of inorder traversal, we would use partial inorder traversal so that at any instant of time the stack contains elements equal to the height of the tree.\\n\\n**Step 1:** We will push the left part of the tree into a stack which is 7 and then 3 is inserted. Now is **next()** is called 3 is stored as the top and then poped now we will push the right of 3 but it does not contain any so we just return the top->val i.e. 3.\\n\\n**Step 2:** We will now **pop()** 7 from the stack and see if it has the right children yes it has so we push 15 and then 9 into the stack. Observe here you\\'ll see at a time stack contains elements equal to the height of the tree. \\n\\n**Step 3:** Now 9 is poped and 9 does contain any right child so we move on 15. If **hasnext()** is called it would return true as traversal is still left and the stack is also not empty.\\n\\n**Step 4:** Now 15 is poped and checked if it has the right child yes it has i.e. 20 so 20 is pushed inside the stack.\\n\\n**Step 5:** Lastly 20 is poped and returned and after that is **hasnext()** is called it will return false as there are no more elements or children inside the stack.\\n\\n![image](https://assets.leetcode.com/users/images/57090108-e111-4449-b518-a3f2951be06a_1630145672.8967223.png)\\n\\n\\n\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> s;\\n    BSTIterator(TreeNode* root) {\\n        partialInorder(root);\\n    }\\n    \\n    void partialInorder(TreeNode* root){\\n        while(root != NULL){\\n            s.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode* top = s.top();\\n        s.pop();\\n        partialInorder(top->right);\\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```\\n\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> s;\\n    BSTIterator(TreeNode* root) {\\n        partialInorder(root);\\n    }\\n    \\n    void partialInorder(TreeNode* root){\\n        while(root != NULL){\\n            s.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode* top = s.top();\\n        s.pop();\\n        partialInorder(top->right);\\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52642,
                "title": "two-python-solutions-stack-and-generator",
                "content": "stack solution: \\n\\n\\n    def __init__(self, root):\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        return len(self.stack) > 0\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        node = self.stack.pop()\\n        x = node.right\\n        while x:\\n            self.stack.append(x)\\n            x = x.left\\n        return node.val\\n\\ngenerator solution:\\n    \\n    def __init__(self, root):\\n        self.last = root\\n        while self.last and self.last.right:\\n            self.last = self.last.right\\n        self.current = None\\n        self.g = self.iterate(root)\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        return self.current is not self.last\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        return next(self.g)\\n        \\n    def iterate(self, node):\\n        if node is None:\\n            return\\n        for x in self.iterate(node.left):\\n            yield x\\n        self.current = node\\n        yield node.val\\n        for x in self.iterate(node.right):\\n            yield x",
                "solutionTags": [
                    "Python"
                ],
                "code": "stack solution: \\n\\n\\n    def __init__(self, root):\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        return len(self.stack) > 0\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        node = self.stack.pop()\\n        x = node.right\\n        while x:\\n            self.stack.append(x)\\n            x = x.left\\n        return node.val\\n\\ngenerator solution:\\n    \\n    def __init__(self, root):\\n        self.last = root\\n        while self.last and self.last.right:\\n            self.last = self.last.right\\n        self.current = None\\n        self.g = self.iterate(root)\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        return self.current is not self.last\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        return next(self.g)\\n        \\n    def iterate(self, node):\\n        if node is None:\\n            return\\n        for x in self.iterate(node.left):\\n            yield x\\n        self.current = node\\n        yield node.val\\n        for x in self.iterate(node.right):\\n            yield x",
                "codeTag": "Python3"
            },
            {
                "id": 52519,
                "title": "my-solution-in-c-in-average-o-1-time-and-uses-o-h-memory",
                "content": "    class BSTIterator {\\n    private:\\n        stack<TreeNode*> st;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            find_left(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            if (st.empty())\\n                return false;\\n            return true;\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* top = st.top();\\n            st.pop();\\n            if (top->right != NULL)\\n                find_left(top->right);\\n                \\n            return top->val;\\n        }\\n        \\n        /** put all the left child() of root */\\n        void find_left(TreeNode* root)\\n        {\\n            TreeNode* p = root;\\n            while (p != NULL)\\n            {\\n                st.push(p);\\n                p = p->left;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class BSTIterator {\\n    private:\\n        stack<TreeNode*> st;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            find_left(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            if (st.empty())\\n                return false;\\n            return true;\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* top = st.top();\\n            st.pop();\\n            if (top->right != NULL)\\n                find_left(top->right);\\n                \\n            return top->val;\\n        }\\n        \\n        /** put all the left child() of root */\\n        void find_left(TreeNode* root)\\n        {\\n            TreeNode* p = root;\\n            while (p != NULL)\\n            {\\n                st.push(p);\\n                p = p->left;\\n            }\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 1965120,
                "title": "easy-iterative-using-stack-space-o-h-instead-of-o-n",
                "content": "If you like, pls **Upvote** :)\\n\\n## Approach:\\n\\t1. Brute force way - You can do in-order traversal and put each element into an ArrayList (additional space). \\n\\t\\tThen use that to check hasNext() or next() element. However, that approach will use extra space of O(n).\\n\\t2. This approach:\\n\\t\\ta) Here we will use our own Stack (basically do in-order traversal Iteratively, instead of recursively). \\n\\t\\t   Reason, being we have more control here and no need to use extra space of O(n) for ArrayList to store all elements first. \\n\\t\\tb) We get space of O(h) only instead of O(n). [h: is height of tree]\\t\\n\\n## Code:\\n\\n\\t// 15 ms, faster than 82.33% \\n\\tclass BSTIterator {\\n\\t\\tStack<TreeNode> stack;\\n\\t\\tpublic BSTIterator(TreeNode root) {\\n\\t\\t\\tstack = new Stack<>();\\n\\t\\t\\tTreeNode node = root;\\n\\t\\t\\tupdateStack(node);                                      // update stack\\n\\t\\t}\\n\\t\\tpublic int next() {\\n\\t\\t\\tTreeNode toRemove = stack.pop();\\n\\t\\t\\tupdateStack(toRemove.right);                             // before return node, first update stack further        \\n\\t\\t\\treturn toRemove.val;\\n\\t\\t}\\n\\t\\tpublic boolean hasNext() {\\n\\t\\t\\treturn !stack.isEmpty();    \\n\\t\\t}\\n\\t\\t// -------------------\\n\\t\\tpublic void updateStack(TreeNode node){\\n\\t\\t\\twhile(node != null){\\n\\t\\t\\t\\tstack.add(node);\\n\\t\\t\\t\\tnode = node.left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked the explanation/dry run, pls **Upvote** :)",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "If you like, pls **Upvote** :)\\n\\n## Approach:\\n\\t1. Brute force way - You can do in-order traversal and put each element into an ArrayList (additional space). \\n\\t\\tThen use that to check hasNext() or next() element. However, that approach will use extra space of O(n).\\n\\t2. This approach:\\n\\t\\ta) Here we will use our own Stack (basically do in-order traversal Iteratively, instead of recursively). \\n\\t\\t   Reason, being we have more control here and no need to use extra space of O(n) for ArrayList to store all elements first. \\n\\t\\tb) We get space of O(h) only instead of O(n). [h: is height of tree]\\t\\n\\n## Code:\\n\\n\\t// 15 ms, faster than 82.33% \\n\\tclass BSTIterator {\\n\\t\\tStack<TreeNode> stack;\\n\\t\\tpublic BSTIterator(TreeNode root) {\\n\\t\\t\\tstack = new Stack<>();\\n\\t\\t\\tTreeNode node = root;\\n\\t\\t\\tupdateStack(node);                                      // update stack\\n\\t\\t}\\n\\t\\tpublic int next() {\\n\\t\\t\\tTreeNode toRemove = stack.pop();\\n\\t\\t\\tupdateStack(toRemove.right);                             // before return node, first update stack further        \\n\\t\\t\\treturn toRemove.val;\\n\\t\\t}\\n\\t\\tpublic boolean hasNext() {\\n\\t\\t\\treturn !stack.isEmpty();    \\n\\t\\t}\\n\\t\\t// -------------------\\n\\t\\tpublic void updateStack(TreeNode node){\\n\\t\\t\\twhile(node != null){\\n\\t\\t\\t\\tstack.add(node);\\n\\t\\t\\t\\tnode = node.left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked the explanation/dry run, pls **Upvote** :)",
                "codeTag": "Java"
            },
            {
                "id": 965584,
                "title": "python-stack-clean-concise-time-o-1-space-o-h",
                "content": "**Idea**\\n- We use stack to store elements, the top of element is the next smallest element. The size of stack is up to height of the BST.\\n- This problem is good base to solve following questions in `O(H)` in Space Complexity.\\n\\t- **[653. Two Sum IV - Input is a BST](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/discuss/1420711)**.\\n\\t- **[230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/discuss/642294)**.\\n```python\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        self.st = []\\n        self.pushLeft(root)\\n        \\n    def pushLeft(self, root):\\n        while root != None:\\n            self.st.append(root)\\n            root = root.left\\n\\n    def next(self):\\n        node = self.st.pop()\\n        self.pushLeft(node.right)\\n        return node.val\\n\\n    def hasNext(self):\\n        return len(self.st) > 0\\n```\\nComplexity:\\n- Time: `O(1)`\\n- Space: `O(H)`, where `H` is the height of the BST.",
                "solutionTags": [],
                "code": "```python\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        self.st = []\\n        self.pushLeft(root)\\n        \\n    def pushLeft(self, root):\\n        while root != None:\\n            self.st.append(root)\\n            root = root.left\\n\\n    def next(self):\\n        node = self.st.pop()\\n        self.pushLeft(node.right)\\n        return node.val\\n\\n    def hasNext(self):\\n        return len(self.st) > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52584,
                "title": "my-java-accepted-solution",
                "content": "the idea is same as using stack to do Binary Tree Inorder Traversal    \\n\\n    public class BSTIterator {\\n        \\n            Stack<TreeNode> stack =  null ;            \\n            TreeNode current = null ;\\n        \\t\\n            public BSTIterator(TreeNode root) {\\n            \\t  current = root;\\t     \\n            \\t  stack = new Stack<> ();\\n        \\t}\\n        \\n        \\t/** @return whether we have a next smallest number */\\n        \\tpublic boolean hasNext() {\\t\\t  \\n        \\t      return !stack.isEmpty() || current != null;  \\n        \\t}\\n        \\n        \\t    /** @return the next smallest number */\\n        \\tpublic int next() {\\n        \\t\\twhile (current != null) {\\n        \\t\\t\\tstack.push(current);\\n        \\t\\t\\tcurrent = current.left ;\\n        \\t\\t}\\t\\t\\n        \\t\\tTreeNode t = stack.pop() ;\\t\\t\\n        \\t\\tcurrent = t.right ;\\t\\t\\n        \\t\\treturn t.val ;\\n        \\t}\\n        }",
                "solutionTags": [],
                "code": "the idea is same as using stack to do Binary Tree Inorder Traversal    \\n\\n    public class BSTIterator {\\n        \\n            Stack<TreeNode> stack =  null ;            \\n            TreeNode current = null ;\\n        \\t\\n            public BSTIterator(TreeNode root) {\\n            \\t  current = root;\\t     \\n            \\t  stack = new Stack<> ();\\n        \\t}\\n        \\n        \\t/** @return whether we have a next smallest number */\\n        \\tpublic boolean hasNext() {\\t\\t  \\n        \\t      return !stack.isEmpty() || current != null;  \\n        \\t}\\n        \\n        \\t    /** @return the next smallest number */\\n        \\tpublic int next() {\\n        \\t\\twhile (current != null) {\\n        \\t\\t\\tstack.push(current);\\n        \\t\\t\\tcurrent = current.left ;\\n        \\t\\t}\\t\\t\\n        \\t\\tTreeNode t = stack.pop() ;\\t\\t\\n        \\t\\tcurrent = t.right ;\\t\\t\\n        \\t\\treturn t.val ;\\n        \\t}\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52705,
                "title": "morris-traverse-solution",
                "content": "Traverse a BST from the smallest to the largest, then i solve this question simply use the inorder traversal.\\nTo implement a iterator means we should traverse the tree step by step, so just split the inorder traversal.\\n\\n    class BSTIterator {\\n    public:\\n    BSTIterator(TreeNode *root) {\\n        p = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return p != NULL;\\n    }\\n\\n    /** @return the next smallest number */\\n    int next() {\\n        TreeNode *tmp;\\n        int ret;\\n        while(p) {\\n            if (p->left == NULL) {  \\n                ret = p->val;\\n                p = p->right;\\n                break;\\n            }  \\n            else {  \\n                tmp = p->left;  \\n                while (tmp->right != NULL && tmp->right != p)  \\n                    tmp = tmp->right;  \\n                if (tmp->right == NULL) {  \\n                    tmp->right = p;  \\n                    p = p->left;  \\n                }  \\n                else {\\n                    ret = p->val;\\n                    tmp->right = NULL;  \\n                    p = p->right;\\n                    break;\\n                }  \\n            }  \\n        }\\n        \\n        return ret;\\n    }\\n    \\n    TreeNode *p;\\n    };",
                "solutionTags": [],
                "code": "Traverse a BST from the smallest to the largest, then i solve this question simply use the inorder traversal.\\nTo implement a iterator means we should traverse the tree step by step, so just split the inorder traversal.\\n\\n    class BSTIterator {\\n    public:\\n    BSTIterator(TreeNode *root) {\\n        p = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return p != NULL;\\n    }\\n\\n    /** @return the next smallest number */\\n    int next() {\\n        TreeNode *tmp;\\n        int ret;\\n        while(p) {\\n            if (p->left == NULL) {  \\n                ret = p->val;\\n                p = p->right;\\n                break;\\n            }  \\n            else {  \\n                tmp = p->left;  \\n                while (tmp->right != NULL && tmp->right != p)  \\n                    tmp = tmp->right;  \\n                if (tmp->right == NULL) {  \\n                    tmp->right = p;  \\n                    p = p->left;  \\n                }  \\n                else {\\n                    ret = p->val;\\n                    tmp->right = NULL;  \\n                    p = p->right;\\n                    break;\\n                }  \\n            }  \\n        }\\n        \\n        return ret;\\n    }\\n    \\n    TreeNode *p;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 1965329,
                "title": "may-be-you-understand",
                "content": "![image](https://assets.leetcode.com/users/images/6e21daf9-a01f-4c72-be97-8d4d2f21080f_1650423956.0233808.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/3aaf9068-6762-403c-b888-786bed02c41d_1650423967.7870433.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a6943ed3-34a2-499a-8330-e665ff0822f4_1650423988.6830766.jpeg)\\n\\n```\\nclass BSTIterator {\\n    Stack<TreeNode> st;\\n    public BSTIterator(TreeNode root) {\\n        st = new Stack<>();\\n        addAllLeft(root);\\n    }\\n    public void addAllLeft(TreeNode root){\\n        while(root != null){\\n            st.push(root);\\n            root = root.left;\\n        }\\n    }\\n    public int next() {\\n        TreeNode topValue = st.pop();\\n        addAllLeft(topValue.right);\\n        return topValue.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return st.size() != 0;\\n    }\\n}\\n```\\n\\n<hr>\\n<hr>\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(logN)\\n\\n<hr>\\n<hr>",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator {\\n    Stack<TreeNode> st;\\n    public BSTIterator(TreeNode root) {\\n        st = new Stack<>();\\n        addAllLeft(root);\\n    }\\n    public void addAllLeft(TreeNode root){\\n        while(root != null){\\n            st.push(root);\\n            root = root.left;\\n        }\\n    }\\n    public int next() {\\n        TreeNode topValue = st.pop();\\n        addAllLeft(topValue.right);\\n        return topValue.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return st.size() != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965170,
                "title": "c-solution-using-inorder-tc-o-h-instead-of-o-n",
                "content": "```\\nclass BSTIterator {\\npublic:\\n     stack<TreeNode*> st;\\n    BSTIterator(TreeNode *root) {\\n        Lefttree(root);\\n    }\\n    \\n    bool hasNext() {\\n    return st.empty() ? false : true;\\n    }\\n    \\n    int next() {\\n        TreeNode* top = st.top();\\n        st.pop();\\n        if (top->right != NULL)\\n            Lefttree(top->right);  \\n     return top->val;\\n    }\\n    \\n    void Lefttree(TreeNode* root)\\n    {\\n        TreeNode* p = root;\\n        while (p)\\n        {\\n            st.push(p);\\n            p = p->left;\\n        }\\n    }\\n};\\n```\\n**If you like the solution pls upvote**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n     stack<TreeNode*> st;\\n    BSTIterator(TreeNode *root) {\\n        Lefttree(root);\\n    }\\n    \\n    bool hasNext() {\\n    return st.empty() ? false : true;\\n    }\\n    \\n    int next() {\\n        TreeNode* top = st.top();\\n        st.pop();\\n        if (top->right != NULL)\\n            Lefttree(top->right);  \\n     return top->val;\\n    }\\n    \\n    void Lefttree(TreeNode* root)\\n    {\\n        TreeNode* p = root;\\n        while (p)\\n        {\\n            st.push(p);\\n            p = p->left;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965156,
                "title": "python-tc-o-1-sc-o-h-generator-solution",
                "content": "### Explanation\\n\\nOne way to only use O(h) space is to utilise a generator for our inorder traversal. We can implement it as such:\\n\\n```python\\ndef inorder(node: Optional[TreeNode]) -> Generator[int, None, None]:\\n    \"\"\"\\n    Generator function that takes the root node of a binary tree\\n    and iterates through the nodes of the tree via inorder traversal.\\n    @param node - The root node of the binary tree.\\n    \"\"\"\\n    if node:\\n        yield from inorder(node.left)\\n        yield node.val\\n        yield from inorder(node.right)\\n```\\n\\nSince a generator does not store the entire inorder traversal in memory, the only space used is effectively the implicit stack used when making recursive calls to the function, which has a maximum recursion depth of `h` (where `h` is the maximum height of the tree).\\n\\nHowever, using a generator object alone will not allow us to know whether some nodes in the inorder traversal remain to be traversed (i.e., the `hasNext()` function), since generator objects do not have this functionality. We can overcome this by pre-emptively obtaining and storing the next value in the inorder traversal. Then, `hasNext()` will check whether the next value is valid, whereas `next()` will return the stored value before the *next next* value is obtained.\\n\\n---\\n\\n### Solution\\n\\n```python\\nclass BSTIterator:\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.iter = self._inorder(root)\\n        self.nxt = next(self.iter, None)\\n    \\n    def _inorder(self, node: Optional[TreeNode]) -> Generator[int, None, None]:\\n        if node:\\n            yield from self._inorder(node.left)\\n            yield node.val\\n            yield from self._inorder(node.right)\\n\\n    def next(self) -> int:\\n        res, self.nxt = self.nxt, next(self.iter, None)\\n        return res\\n\\n    def hasNext(self) -> bool:\\n        return self.nxt is not None\\n```\\n\\n**TC: O(1)**, since the generator object handles everything for us.\\nEDIT: Amortised O(1), see [this comment](https://leetcode.com/problems/binary-search-tree-iterator/discuss/1965156/Python-TC-O(1)-SC-O(h)-Generator-Solution/1358785) for a simple explanation.\\n**SC: O(h)**, due to the implicit recursive call stack used by the generator function.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef inorder(node: Optional[TreeNode]) -> Generator[int, None, None]:\\n    \"\"\"\\n    Generator function that takes the root node of a binary tree\\n    and iterates through the nodes of the tree via inorder traversal.\\n    @param node - The root node of the binary tree.\\n    \"\"\"\\n    if node:\\n        yield from inorder(node.left)\\n        yield node.val\\n        yield from inorder(node.right)\\n```\n```python\\nclass BSTIterator:\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.iter = self._inorder(root)\\n        self.nxt = next(self.iter, None)\\n    \\n    def _inorder(self, node: Optional[TreeNode]) -> Generator[int, None, None]:\\n        if node:\\n            yield from self._inorder(node.left)\\n            yield node.val\\n            yield from self._inorder(node.right)\\n\\n    def next(self) -> int:\\n        res, self.nxt = self.nxt, next(self.iter, None)\\n        return res\\n\\n    def hasNext(self) -> bool:\\n        return self.nxt is not None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52694,
                "title": "javascript-solution",
                "content": "    function BSTIterator(root) {\\n      var stack = [];\\n      return {hasNext, next};\\n    \\n      function hasNext() {\\n        return root || stack.length;\\n      }\\n    \\n      function next() {\\n        while (root) {\\n          stack.push(root);\\n          root = root.left;\\n        }\\n        root = stack.pop();\\n        var result = root.val;\\n        root = root.right;\\n        return result;\\n      }\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function BSTIterator(root) {\\n      var stack = [];\\n      return {hasNext, next};\\n    \\n      function hasNext() {\\n        return root || stack.length;\\n      }\\n    \\n      function next() {\\n        while (root) {\\n          stack.push(root);\\n          root = root.left;\\n        }\\n        root = stack.pop();\\n        var result = root.val;\\n        root = root.right;\\n        return result;\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52592,
                "title": "my-solution-with-less-than-10-lines-of-code",
                "content": "\\n\\n public class BSTIterator {\\n\\n\\n    private Stack<TreeNode> stack = new Stack<TreeNode>();\\n\\n    public BSTIterator(TreeNode root) {\\n        pushAllNodes(root);\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode minNode = stack.pop();\\n        pushAllNodes(minNode.right);\\n        return minNode.val;\\n    }\\n\\n    private void pushAllNodes(TreeNode node) {\\n        while(node != null)\\n        {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * BSTIterator i = new BSTIterator(root);\\n * while (i.hasNext()) v[f()] = i.next();\\n */",
                "solutionTags": [],
                "code": "\\n\\n public class BSTIterator {\\n\\n\\n    private Stack<TreeNode> stack = new Stack<TreeNode>();\\n\\n    public BSTIterator(TreeNode root) {\\n        pushAllNodes(root);\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode minNode = stack.pop();\\n        pushAllNodes(minNode.right);\\n        return minNode.val;\\n    }\\n\\n    private void pushAllNodes(TreeNode node) {\\n        while(node != null)\\n        {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * BSTIterator i = new BSTIterator(root);\\n * while (i.hasNext()) v[f()] = i.next();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 966244,
                "title": "c-simplest-clean-solution-faster-than-99",
                "content": "```\\nclass BSTIterator {\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        inOrder(root);\\n    }\\n    \\n    int next() {\\n        curr++;\\n        return nodes[curr-1];\\n    }\\n    \\n    bool hasNext() {\\n        return curr != nodes.size();\\n    }\\n    \\nprivate:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        nodes.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n    \\n    vector<int> nodes;\\n    int curr = 0;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        inOrder(root);\\n    }\\n    \\n    int next() {\\n        curr++;\\n        return nodes[curr-1];\\n    }\\n    \\n    bool hasNext() {\\n        return curr != nodes.size();\\n    }\\n    \\nprivate:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        nodes.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n    \\n    vector<int> nodes;\\n    int curr = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52621,
                "title": "very-concise-solution-by-using-stack-in-java",
                "content": "    public class BSTIterator {\\n        Stack<TreeNode> stack;\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<TreeNode>();\\n            setNext(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            if(stack.isEmpty()) return -1;\\n            TreeNode node = stack.pop();\\n            int val = node.val;\\n            setNext(node.right);\\n            return val;\\n        }\\n        \\n        private void setNext(TreeNode root){\\n           while(root != null){\\n               stack.push(root);\\n               root = root.left;\\n           }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class BSTIterator {\\n        Stack<TreeNode> stack;\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<TreeNode>();\\n            setNext(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            if(stack.isEmpty()) return -1;\\n            TreeNode node = stack.pop();\\n            int val = node.val;\\n            setNext(node.right);\\n            return val;\\n        }\\n        \\n        private void setNext(TreeNode root){\\n           while(root != null){\\n               stack.push(root);\\n               root = root.left;\\n           }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 52675,
                "title": "my-python-solution",
                "content": "    class BSTIterator:\\n    # @param root, a binary search tree's root node\\n    def __init__(self, root):\\n        self.q=[]\\n        self.allLeftIntoStack(root)\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        if not self.q:return False\\n        return True\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        cur = self.q.pop()\\n        self.allLeftIntoStack(cur.right)\\n        return cur.val\\n\\n    def allLeftIntoStack(self,root):\\n        while root:\\n            self.q.append(root)\\n            root=root.left",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class BSTIterator:\\n    # @param root, a binary search tree's root node\\n    def __init__(self, root):\\n        self.q=[]\\n        self.allLeftIntoStack(root)\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        if not self.q:return False\\n        return True\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        cur = self.q.pop()\\n        self.allLeftIntoStack(cur.right)\\n        return cur.val\\n\\n    def allLeftIntoStack(self,root):\\n        while root:\\n            self.q.append(root)\\n            root=root.left",
                "codeTag": "Java"
            },
            {
                "id": 344078,
                "title": "all-iterators-in-order-pre-order-and-post-order-stack-based-pre-cache",
                "content": "If you go with Pre-Cached there are following things\\n1. Its lightening fast, as we don\\'t need to touch the actual tree again\\n2. Its fail safe iterator, means andy modification in actual tree won\\'t affect this [ use in concurent system]\\n3. It consume lot of memory as we need to cache whole tree (O(n))\\n4. next() and hashNext() is constant time. \\n\\n\\nIn-Order\\n\\n\\n```\\n\\nclass BSTIteratorInorder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            stack = new Stack<>();\\n            if (root != null)\\n                init(root);\\n        }\\n\\n        private void init(TreeNode root) {\\n\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            if (hasNext()) {\\n\\n                TreeNode current = stack.pop();\\n\\n                process(current.right);\\n\\n                return current.val;\\n            }\\n\\n            return 0;\\n        }\\n\\n        private void process(TreeNode root) {\\n            init(root);\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\nclass BSTIteratorInorderPreCache {\\n\\n    class BSTIterator {\\n\\n        private LinkedList<TreeNode> inorder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            inorder = new LinkedList<>();\\n\\n            inorder(root);\\n\\n        }\\n\\n        private void inorder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n            inorder(root.left);\\n            inorder.add(root);\\n            inorder(root.right);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = inorder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !inorder.isEmpty();\\n        }\\n    }\\n}\\n```\\n\\n\\nPre-Order\\n\\n```\\nclass BSTIteratorPreOrder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<>();\\n\\n            if (root != null)\\n                init(root);\\n\\n\\n        }\\n\\n        private void init(TreeNode root) {\\n            stack.push(root);\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode node = stack.pop();\\n\\n            if (node.right != null)\\n                init(node.right);\\n\\n            if (node.left != null)\\n                init(node.left);\\n\\n            return node.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\n\\nclass BSTIteratorPreOrderPreCache {\\n\\n    class BSTIterator {\\n\\n\\n        private LinkedList<TreeNode> preorder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            preorder = new LinkedList<>();\\n\\n            preorder(root);\\n\\n        }\\n\\n        private void preorder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n            preorder.add(root);\\n            preorder(root.left);\\n            preorder(root.right);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = preorder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !preorder.isEmpty();\\n        }\\n    }\\n}\\n\\n```\\n\\nAnd Post-Order\\n\\n```\\nclass BSTIteratorPostOrder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            stack = new Stack<>();\\n            init(root);\\n\\n        }\\n\\n        /**\\n         * find the first leaf in a tree rooted at cur and store intermediate nodes\\n         */\\n        private void init(TreeNode root) {\\n            while (root != null) {\\n\\n                stack.push(root);\\n\\n                if (root.left != null)\\n                    root = root.left;\\n                else\\n                    root = root.right;\\n            }\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n\\n            TreeNode node = stack.pop();\\n\\n            if (!stack.isEmpty()) {\\n                if (node == stack.peek().left) {\\n                    init(stack.peek().right);  // find next leaf in right sub-tree\\n                }\\n\\n\\n            }\\n            return node.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\n\\nclass BSTIteratorPostOrderPreCached {\\n\\n    class BSTIterator {\\n        private LinkedList<TreeNode> postOrder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            postOrder = new LinkedList<>();\\n            postOrder(root);\\n\\n        }\\n\\n        private void postOrder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n\\n            postOrder(root.left);\\n            postOrder(root.right);\\n            postOrder.add(root);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = postOrder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !postOrder.isEmpty();\\n        }\\n    }\\n\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass BSTIteratorInorder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            stack = new Stack<>();\\n            if (root != null)\\n                init(root);\\n        }\\n\\n        private void init(TreeNode root) {\\n\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            if (hasNext()) {\\n\\n                TreeNode current = stack.pop();\\n\\n                process(current.right);\\n\\n                return current.val;\\n            }\\n\\n            return 0;\\n        }\\n\\n        private void process(TreeNode root) {\\n            init(root);\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\nclass BSTIteratorInorderPreCache {\\n\\n    class BSTIterator {\\n\\n        private LinkedList<TreeNode> inorder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            inorder = new LinkedList<>();\\n\\n            inorder(root);\\n\\n        }\\n\\n        private void inorder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n            inorder(root.left);\\n            inorder.add(root);\\n            inorder(root.right);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = inorder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !inorder.isEmpty();\\n        }\\n    }\\n}\\n```\n```\\nclass BSTIteratorPreOrder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<>();\\n\\n            if (root != null)\\n                init(root);\\n\\n\\n        }\\n\\n        private void init(TreeNode root) {\\n            stack.push(root);\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode node = stack.pop();\\n\\n            if (node.right != null)\\n                init(node.right);\\n\\n            if (node.left != null)\\n                init(node.left);\\n\\n            return node.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\n\\nclass BSTIteratorPreOrderPreCache {\\n\\n    class BSTIterator {\\n\\n\\n        private LinkedList<TreeNode> preorder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            preorder = new LinkedList<>();\\n\\n            preorder(root);\\n\\n        }\\n\\n        private void preorder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n            preorder.add(root);\\n            preorder(root.left);\\n            preorder(root.right);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = preorder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !preorder.isEmpty();\\n        }\\n    }\\n}\\n\\n```\n```\\nclass BSTIteratorPostOrder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            stack = new Stack<>();\\n            init(root);\\n\\n        }\\n\\n        /**\\n         * find the first leaf in a tree rooted at cur and store intermediate nodes\\n         */\\n        private void init(TreeNode root) {\\n            while (root != null) {\\n\\n                stack.push(root);\\n\\n                if (root.left != null)\\n                    root = root.left;\\n                else\\n                    root = root.right;\\n            }\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n\\n            TreeNode node = stack.pop();\\n\\n            if (!stack.isEmpty()) {\\n                if (node == stack.peek().left) {\\n                    init(stack.peek().right);  // find next leaf in right sub-tree\\n                }\\n\\n\\n            }\\n            return node.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\n\\nclass BSTIteratorPostOrderPreCached {\\n\\n    class BSTIterator {\\n        private LinkedList<TreeNode> postOrder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            postOrder = new LinkedList<>();\\n            postOrder(root);\\n\\n        }\\n\\n        private void postOrder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n\\n            postOrder(root.left);\\n            postOrder(root.right);\\n            postOrder.add(root);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = postOrder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !postOrder.isEmpty();\\n        }\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189561,
                "title": "clean-and-fast-java-solution",
                "content": "Each time we keep pushing the left children into the stack until we reach a null node. Then the top node will always have the mininun value. It\\'s kind of like the in-order traveral, except that we keep the \"root\" nodes in the stack for future use (such as adding the right children to the stack).\\n\\nTime complexity:\\nsuppose the binary search tree has height h (if it\\'s a balanced bst, h is O(logn))\\nconstructor: O(h) worst case \\nhasNext(): O(1)\\nnext(): O(h) worst case\\nadd(): O(h) worst case\\n```\\npublic class BSTIterator {\\n    Stack<TreeNode> stack;\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<TreeNode>(); // initialize the stack\\n        add(root); //add the current node and all its left child to the stack\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        add(node.right);\\n        return node.val;\\n    }\\n    \\n    /** @add the current node and all its left child to the stack*/\\n    private void add(TreeNode node) {\\n        while (node != null) {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class BSTIterator {\\n    Stack<TreeNode> stack;\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<TreeNode>(); // initialize the stack\\n        add(root); //add the current node and all its left child to the stack\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        add(node.right);\\n        return node.val;\\n    }\\n    \\n    /** @add the current node and all its left child to the stack*/\\n    private void add(TreeNode node) {\\n        while (node != null) {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965553,
                "title": "c-using-simple-array",
                "content": "**Declare an array ```nums``` and intialise position with  ```pos = -1```.**\\n**By using ```inorder()``` traversal push all elements in array ```nums```.\\nAs mentioned in the problem, ```next()``` is valid, so no need to check for bounding conditions. Just increment the position value and return ```nums[pos]```.\\nEither ```{ pos++; return nums[pos]; }``` or ```{ return nums[++pos]; }```.\\nFor ```hasNext()``` check whether next position is less than the size of the array nums using ```pos+1 < nums.size()```.**\\n```\\nclass BSTIterator {\\npublic:\\n    vector<int> nums;\\n    int pos = -1;\\n    \\n    void inorder(TreeNode* root) {\\n        if(root) {\\n            inorder(root -> left);\\n            nums.push_back(root -> val);\\n            inorder(root -> right);\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n\\t\\t// Increments the pos and returns the nums value at pos\\n        return nums[++pos];\\n    }\\n    \\n    bool hasNext() {\\n\\t\\t// Checking for the bounding condition\\n        return pos+1 < nums.size();\\n    }\\n};\\n```\\n********\\n**Upvote if you like.\\nThank you.**",
                "solutionTags": [],
                "code": "```nums```\n```pos = -1```\n```inorder()```\n```nums```\n```next()```\n```nums[pos]```\n```{ pos++; return nums[pos]; }```\n```{ return nums[++pos]; }```\n```hasNext()```\n```pos+1 < nums.size()```\n```\\nclass BSTIterator {\\npublic:\\n    vector<int> nums;\\n    int pos = -1;\\n    \\n    void inorder(TreeNode* root) {\\n        if(root) {\\n            inorder(root -> left);\\n            nums.push_back(root -> val);\\n            inorder(root -> right);\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n\\t\\t// Increments the pos and returns the nums value at pos\\n        return nums[++pos];\\n    }\\n    \\n    bool hasNext() {\\n\\t\\t// Checking for the bounding condition\\n        return pos+1 < nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162326,
                "title": "python-solution",
                "content": "In order traversal:\\n```\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.trav = root\\n        self.stack = []\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.trav or self.stack\\n        \\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while self.trav:\\n            self.stack.append(self.trav)\\n            self.trav = self.trav.left\\n        u = self.stack.pop()\\n        self.trav = u.right\\n        return u.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.trav = root\\n        self.stack = []\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.trav or self.stack\\n        \\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while self.trav:\\n            self.stack.append(self.trav)\\n            self.trav = self.trav.left\\n        u = self.stack.pop()\\n        self.trav = u.right\\n        return u.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52701,
                "title": "my-java-solution-with-o-1-space-and-o-1-amortized-time-using-morris-tree-traversal",
                "content": "First of all, even with most optimized space and time complexity, I have to say this may be not the best solution, since it changes the tree structure a little bit during constructor period.\\n\\n#Construct Period\\nThe idea is use in-order Morris Tree Traversal (check out [1][2] if you are not familiar with it, otherwise the bellow explanation to you is nonsense) to construct a threaded binary tree in construct function. (This is O(n) time, but we don't care much about it.) Then set a pointer (we call it \"curr\") to the smallest TreeNode, which is easy to do, just find the left-most child from root.\\n\\n#hasNext()\\nFor hasNext() function, simple return \"curr != null\", which is by definition of threaded binary tree.\\n\\n#next()\\nFor next() function, it is a little bit tricky. We call the right child of \"curr\" as \"next\". If \"next\" is not a normal right child of \"curr\", which means the right child relationship is constructed during the threaded binary tree construction period, then the next TreeNode we should iterate is indeed \"next\". However, if \"next\" is a normal right child of \"curr\", then the next TreeNode we should iterate is actually the left-most child of \"next\". \\n\\nSo the problem reduces to how to make clear the situation. Well, it is no hard. If \"next\" is null, then we've done, simply set \"curr\" to null. If \"next\" has no left child, or \"next\"'s left child is strictly larger than \"curr\", that means it is a normal right child of \"curr\", so we should set \"curr\" to left-most child of \"next\". Otherwise, we set \"curr\" to \"next\", and break the right child relationship between \"curr\" and \"next\", to recover the original tree structure. \\n\\n#Complexity analysis\\nThe space complexity is straightforwardly O(1). The time complexity needs some more explanation. Since the only part that is not O(1) is when we search the left-most child of \"next\". However, for all the children along this left path (say, there are N children), we do once search left-most and (N-1) times simply go to right child. So the amortized time complexity is still O(1).\\n\\n#Code:\\n\\n    public class BSTIterator {\\n    \\n    \\tprivate TreeNode curr;\\n        public BSTIterator(TreeNode root) {\\n    \\t\\tTreeNode prev;\\n    \\t\\t//Do a morris in-order traversal, to construct a threaded binary tree\\n    \\t\\tcurr = root;\\n    \\t\\twhile(curr != null){\\n    \\t\\t\\tif(curr.left == null){\\n    \\t\\t\\t\\tcurr = curr.right;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tprev = curr.left;\\n    \\t\\t\\t\\twhile(prev.right != null && prev.right != curr)\\n    \\t\\t\\t\\t\\tprev = prev.right;\\n    \\n    \\t\\t\\t\\tif(prev.right == null){\\n    \\t\\t\\t\\t\\tprev.right = curr;\\n    \\t\\t\\t\\t\\tcurr = curr.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\tcurr = curr.right;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\t//get the left-most child of root, i.e. the smallest TreeNode\\n    \\t\\tcurr = root;\\n    \\t\\twhile(curr != null && curr.left != null)\\n    \\t\\t\\tcurr = curr.left;\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n    \\t\\treturn curr != null;\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n    \\n    \\t\\t//copy the value we need to return\\n    \\t\\tint result = curr.val;\\n    \\n    \\t\\tTreeNode next = curr.right;\\n    \\t\\tif(next == null)\\n    \\t\\t\\tcurr = next;\\n    \\t\\t//the right child relationship is a normal one, find left-most\\n    \\t\\t//child of \"next\"\\n    \\t\\telse if(next.left == null || next.left.val > curr.val){\\n    \\t\\t\\tcurr = next;\\n    \\t\\t\\twhile(curr.left != null)\\n    \\t\\t\\t\\tcurr = curr.left;\\n    \\t\\t}\\n    \\t\\t//the right child relationship is made when we\\n    \\t\\t//construct the threaded binary tree\\n    \\t\\telse{\\n    \\t\\t\\tcurr.right = null;//we recover the original tree structure\\n    \\t\\t\\tcurr = next;\\n    \\t\\t}\\n    \\n    \\t\\treturn result;\\n        }\\n    }\\n\\n#Reference\\n\\nFor those who are not familiar with Morris Tree Traversal, these two paragraphs are good references.\\n\\n[1]https://en.wikipedia.org/wiki/Threaded_binary_tree\\n\\n[2]http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/",
                "solutionTags": [
                    "Java"
                ],
                "code": "First of all, even with most optimized space and time complexity, I have to say this may be not the best solution, since it changes the tree structure a little bit during constructor period.\\n\\n#Construct Period\\nThe idea is use in-order Morris Tree Traversal (check out [1][2] if you are not familiar with it, otherwise the bellow explanation to you is nonsense) to construct a threaded binary tree in construct function. (This is O(n) time, but we don't care much about it.) Then set a pointer (we call it \"curr\") to the smallest TreeNode, which is easy to do, just find the left-most child from root.\\n\\n#hasNext()\\nFor hasNext() function, simple return \"curr != null\", which is by definition of threaded binary tree.\\n\\n#next()\\nFor next() function, it is a little bit tricky. We call the right child of \"curr\" as \"next\". If \"next\" is not a normal right child of \"curr\", which means the right child relationship is constructed during the threaded binary tree construction period, then the next TreeNode we should iterate is indeed \"next\". However, if \"next\" is a normal right child of \"curr\", then the next TreeNode we should iterate is actually the left-most child of \"next\". \\n\\nSo the problem reduces to how to make clear the situation. Well, it is no hard. If \"next\" is null, then we've done, simply set \"curr\" to null. If \"next\" has no left child, or \"next\"'s left child is strictly larger than \"curr\", that means it is a normal right child of \"curr\", so we should set \"curr\" to left-most child of \"next\". Otherwise, we set \"curr\" to \"next\", and break the right child relationship between \"curr\" and \"next\", to recover the original tree structure. \\n\\n#Complexity analysis\\nThe space complexity is straightforwardly O(1). The time complexity needs some more explanation. Since the only part that is not O(1) is when we search the left-most child of \"next\". However, for all the children along this left path (say, there are N children), we do once search left-most and (N-1) times simply go to right child. So the amortized time complexity is still O(1).\\n\\n#Code:\\n\\n    public class BSTIterator {\\n    \\n    \\tprivate TreeNode curr;\\n        public BSTIterator(TreeNode root) {\\n    \\t\\tTreeNode prev;\\n    \\t\\t//Do a morris in-order traversal, to construct a threaded binary tree\\n    \\t\\tcurr = root;\\n    \\t\\twhile(curr != null){\\n    \\t\\t\\tif(curr.left == null){\\n    \\t\\t\\t\\tcurr = curr.right;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tprev = curr.left;\\n    \\t\\t\\t\\twhile(prev.right != null && prev.right != curr)\\n    \\t\\t\\t\\t\\tprev = prev.right;\\n    \\n    \\t\\t\\t\\tif(prev.right == null){\\n    \\t\\t\\t\\t\\tprev.right = curr;\\n    \\t\\t\\t\\t\\tcurr = curr.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\tcurr = curr.right;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\t//get the left-most child of root, i.e. the smallest TreeNode\\n    \\t\\tcurr = root;\\n    \\t\\twhile(curr != null && curr.left != null)\\n    \\t\\t\\tcurr = curr.left;\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n    \\t\\treturn curr != null;\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n    \\n    \\t\\t//copy the value we need to return\\n    \\t\\tint result = curr.val;\\n    \\n    \\t\\tTreeNode next = curr.right;\\n    \\t\\tif(next == null)\\n    \\t\\t\\tcurr = next;\\n    \\t\\t//the right child relationship is a normal one, find left-most\\n    \\t\\t//child of \"next\"\\n    \\t\\telse if(next.left == null || next.left.val > curr.val){\\n    \\t\\t\\tcurr = next;\\n    \\t\\t\\twhile(curr.left != null)\\n    \\t\\t\\t\\tcurr = curr.left;\\n    \\t\\t}\\n    \\t\\t//the right child relationship is made when we\\n    \\t\\t//construct the threaded binary tree\\n    \\t\\telse{\\n    \\t\\t\\tcurr.right = null;//we recover the original tree structure\\n    \\t\\t\\tcurr = next;\\n    \\t\\t}\\n    \\n    \\t\\treturn result;\\n        }\\n    }\\n\\n#Reference\\n\\nFor those who are not familiar with Morris Tree Traversal, these two paragraphs are good references.\\n\\n[1]https://en.wikipedia.org/wiki/Threaded_binary_tree\\n\\n[2]http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/",
                "codeTag": "Java"
            },
            {
                "id": 965790,
                "title": "c-caching-solution-explained-100-time-96-space",
                "content": "Okay, I opted NOT to go with unnecessary logic and try first of all the simplest approach (compare to the other one I had in mind, to go on with a stack of nodes) - caching all the node values in the constructor and then just referring to that - it worked surprisingly well :)\\n\\nTo do so, I declare 3 class variables:\\n* `curr` is a pointer to which value we will \"pop\" next;\\n* `pos` will keep track of what position in `store` we will push into next and, at the end of the caching part, it will also tell us how big is our store (so basically acting as a measure of its length);\\n* `store`, you guessed it, will store the values of each single node parsed.\\n\\nIn our constructor we are going to call our helper `dfs` that will just:\\n* check if `root` is `NULL`, in which case we return;\\n* call itself on `root->left`;\\n* add `root->val` to `store` in position `pos`;\\n* increment `pos` by `1`;\\n* call itself on `root->right`.\\n\\nThe following methods are somehow trivial:\\n* `next` will just return `store[curr]` and increment it;\\n* `hasNext` will just return if `curr < pos`, meaning we can still pop at least a value.\\n\\nThe code:\\n\\n```cpp\\nclass BSTIterator {\\npublic:\\n    int curr = 0, pos = 0, store[10001];\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        dfs(root->left);\\n        store[pos++] = root->val;\\n        dfs(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        dfs(root);\\n    }\\n    \\n    int next() {\\n        return store[curr++];\\n    }\\n    \\n    bool hasNext() {\\n        return curr < pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass BSTIterator {\\npublic:\\n    int curr = 0, pos = 0, store[10001];\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        dfs(root->left);\\n        store[pos++] = root->val;\\n        dfs(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        dfs(root);\\n    }\\n    \\n    int next() {\\n        return store[curr++];\\n    }\\n    \\n    bool hasNext() {\\n        return curr < pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965565,
                "title": "python-stack-solution-follow-up-explained",
                "content": "In this question we are asked to perform Iterator, using inorder traversal, so let us just use inorder traversal, using stack: we will keep two global variables:\\n1. `self.stack`: our explicit stack, where we keep our visited nodes.\\n2. `self.curr`: current node we want to return during our traversal.\\n\\nNext, what we do is perform usual iterative inorder traversal: we go als left as possible until we can and add nodes to stack. Then we remove node from stack and go to right children if it is possible. Also we save our `out` node, because we need to return it as output of `next` function. Finally, howe we can understand if we have next Node or not? If stack is not empty, we have it, also if current node is not `None`, we also have it, in other cases we are done.\\n\\n**Complexity**: amortized time complexity of `next` function is `O(1)`: we spend `O(n)` time to visit all `n` nodes. Note, that amortized time means, that we spend `O(1)` in average, it is exactly what we need in follow-up. Also space complexity for this solution is `O(h)`: our stack will never be longer than height of our tree.\\n\\n```\\nclass BSTIterator:\\n    def __init__(self, root):\\n        self.stack = []\\n        self.curr = root\\n        \\n    def next(self):\\n        while self.curr:\\n            self.stack.append(self.curr)\\n            self.curr = self.curr.left\\n        self.curr = self.stack.pop()\\n        out = self.curr.val\\n        self.curr = self.curr.right\\n        return out\\n\\n    def hasNext(self):\\n        return self.stack or self.curr\\n```\\n\\nNote also, that there is Morris Traversal with `O(1)` time in average and `O(1)` space.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n    def __init__(self, root):\\n        self.stack = []\\n        self.curr = root\\n        \\n    def next(self):\\n        while self.curr:\\n            self.stack.append(self.curr)\\n            self.curr = self.curr.left\\n        self.curr = self.stack.pop()\\n        out = self.curr.val\\n        self.curr = self.curr.right\\n        return out\\n\\n    def hasNext(self):\\n        return self.stack or self.curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52713,
                "title": "python-concise-solution-o-lgn-space-and-o-1-time",
                "content": "```\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        self.stack = []\\n        self.root = root\\n        \\n    def next(self):\\n        while self.root:\\n            self.stack.append(self.root)\\n            self.root = self.root.left\\n        node = self.stack.pop()\\n        res = node.val\\n        self.root = node.right\\n        return res\\n\\n    def hasNext(self):\\n        return len(self.stack) > 0 or self.root != None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        self.stack = []\\n        self.root = root\\n        \\n    def next(self):\\n        while self.root:\\n            self.stack.append(self.root)\\n            self.root = self.root.left\\n        node = self.stack.pop()\\n        res = node.val\\n        self.root = node.right\\n        return res\\n\\n    def hasNext(self):\\n        return len(self.stack) > 0 or self.root != None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568327,
                "title": "javascript-depth-first-search-in-order-traversing",
                "content": "The Idea:\\n1. use **Depth First Search** **In Order** traversing \\n```\\n       10\\n   5        13\\n          11  16\\n```\\ndepthFirstSearchInOrderTraversing(): [5, 10, 11, 13, 16]\\n2. **reverse** result of traversing to have sorting from high to low value\\n[5, 10, 11, 13, 16] will become [16, 13, 11, 10, 5]\\n3. use **Array pop()** to be able perform **O(1)** for **next** and **Array lenght** to be able perform **O(1)** for **hasNext** methods\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n */\\nvar BSTIterator = function(root) {\\n    if(!root){\\n        this.data = [];\\n        return;\\n    }\\n    \\n    let visited = [];\\n    \\n    function traverse(node){\\n        if(node.left) traverse(node.left);\\n        visited.push(node.val);\\n        if(node.right) traverse(node.right);\\n    }\\n    traverse(root);\\n    \\n    this.data = visited.reverse();\\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    return this.data.pop();\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.data.length > 0 ;\\n};\\n\\n/** \\n * Your BSTIterator object will be instantiated and called as such:\\n * var obj = new BSTIterator(root)\\n * var param_1 = obj.next()\\n * var param_2 = obj.hasNext()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n       10\\n   5        13\\n          11  16\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n */\\nvar BSTIterator = function(root) {\\n    if(!root){\\n        this.data = [];\\n        return;\\n    }\\n    \\n    let visited = [];\\n    \\n    function traverse(node){\\n        if(node.left) traverse(node.left);\\n        visited.push(node.val);\\n        if(node.right) traverse(node.right);\\n    }\\n    traverse(root);\\n    \\n    this.data = visited.reverse();\\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    return this.data.pop();\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.data.length > 0 ;\\n};\\n\\n/** \\n * Your BSTIterator object will be instantiated and called as such:\\n * var obj = new BSTIterator(root)\\n * var param_1 = obj.next()\\n * var param_2 = obj.hasNext()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52703,
                "title": "c-using-stack",
                "content": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class BSTIterator {\\n    private:\\n        TreeNode *current = NULL; \\n        stack<TreeNode*> s;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n             // initialize the current pointer\\n            current = root;\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            while(current){\\n                s.push(current);\\n                current = current->left;\\n            }\\n            if(s.empty()){\\n                return false;\\n            }\\n            return true;\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* node = s.top();\\n            s.pop();\\n            current = node->right;\\n            return node->val;\\n        }\\n    };\\n    \\n    /**\\n     * Your BSTIterator will be called like this:\\n     * BSTIterator i = BSTIterator(root);\\n     * while (i.hasNext()) cout << i.next();\\n     */\\n\\nThe basic idea behind this solution is that we have to implement inorder iteratively but it will gets split into two functions i.e. hasNext and next.\\nhasNext() will push all the left elements and check and return accordingly if elements are in the stack.\\nnext() will just pop() the top element from the stack and update the current pointer to right .\\nFor this we are taking a stack and a current pointer.\\nBut maybe I may be wrong in hasNext as the requirement of question is O(1) for hasNext() as well.\\n\\nOpen for comments.",
                "solutionTags": [],
                "code": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class BSTIterator {\\n    private:\\n        TreeNode *current = NULL; \\n        stack<TreeNode*> s;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n             // initialize the current pointer\\n            current = root;\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            while(current){\\n                s.push(current);\\n                current = current->left;\\n            }\\n            if(s.empty()){\\n                return false;\\n            }\\n            return true;\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* node = s.top();\\n            s.pop();\\n            current = node->right;\\n            return node->val;\\n        }\\n    };\\n    \\n    /**\\n     * Your BSTIterator will be called like this:\\n     * BSTIterator i = BSTIterator(root);\\n     * while (i.hasNext()) cout << i.next();\\n     */\\n\\nThe basic idea behind this solution is that we have to implement inorder iteratively but it will gets split into two functions i.e. hasNext and next.\\nhasNext() will push all the left elements and check and return accordingly if elements are in the stack.\\nnext() will just pop() the top element from the stack and update the current pointer to right .\\nFor this we are taking a stack and a current pointer.\\nBut maybe I may be wrong in hasNext as the requirement of question is O(1) for hasNext() as well.\\n\\nOpen for comments.",
                "codeTag": "C++"
            },
            {
                "id": 52718,
                "title": "my-simple-solution-here",
                "content": "    public class BSTIterator {\\n    Stack<TreeNode> stack=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n       while(root!=null){\\n\\t            stack.push(root);\\n\\t            root=root.left;\\n\\t        }\\n\\t    }\\n\\n\\t    /** @return whether we have a next smallest number */\\n\\t    public boolean hasNext() {\\n\\t        if(!stack.isEmpty())\\n\\t            return true;\\n\\t        else\\n\\t        \\t return false;\\n\\t    }\\n\\n\\t    /** @return the next smallest number */\\n\\t    public int next() {\\n\\t        int res=0;\\n\\t        if(!stack.isEmpty()){\\n\\t            TreeNode cur=stack.pop();\\n\\t            res=cur.val;\\n\\t            cur=cur.right;\\n\\t            while(cur!=null){\\n\\t                stack.push(cur);\\n\\t                cur=cur.left;\\n\\t            }\\n\\t        }\\n\\t        return res;\\n\\t    }\\n\\n}",
                "solutionTags": [],
                "code": "    public class BSTIterator {\\n    Stack<TreeNode> stack=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n       while(root!=null){\\n\\t            stack.push(root);\\n\\t            root=root.left;\\n\\t        }\\n\\t    }\\n\\n\\t    /** @return whether we have a next smallest number */\\n\\t    public boolean hasNext() {\\n\\t        if(!stack.isEmpty())\\n\\t            return true;\\n\\t        else\\n\\t        \\t return false;\\n\\t    }\\n\\n\\t    /** @return the next smallest number */\\n\\t    public int next() {\\n\\t        int res=0;\\n\\t        if(!stack.isEmpty()){\\n\\t            TreeNode cur=stack.pop();\\n\\t            res=cur.val;\\n\\t            cur=cur.right;\\n\\t            while(cur!=null){\\n\\t                stack.push(cur);\\n\\t                cur=cur.left;\\n\\t            }\\n\\t        }\\n\\t        return res;\\n\\t    }\\n\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3457559,
                "title": "easy-begginer-friendly-sol-c-stack-implementation",
                "content": "# Intuition\\nThe key idea is to use a stack to keep track of the nodes in the tree that still need to be processed.\\n# Approach\\n- The idea is to maintain a stack that stores the nodes of the BST in the order in which they would be visited during an in-order traversal of the tree.\\n- The push method pushes all the left nodes of the input root onto the stack, simulating an in-order traversal starting from root.\\n- The next method pops the top element from the stack and then simulates an in-order traversal starting from the right child of the popped element. \\n- The right child is pushed onto the stack, followed by all its left children (if any). This ensures that the next element returned by the iterator is the next element in the in-order traversal.\\n- The hasNext method simply checks if the stack is empty or not. If the stack is empty, it means that there are no more elements in the in-order traversal of the BST and there is no next element present.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    void push(TreeNode* root)\\n    {\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        push(root);\\n    }\\n\\n    int next() {\\n        auto temp=st.top();\\n        st.pop();\\n        push(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    void push(TreeNode* root)\\n    {\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        push(root);\\n    }\\n\\n    int next() {\\n        auto temp=st.top();\\n        st.pop();\\n        push(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276281,
                "title": "best-o-1-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    int i = 0;\\n    vector <int> nodes;\\n\\n    BSTIterator(TreeNode* root) {\\n        traversal(root, nodes);\\n    }\\n    \\n    int next() {\\n        return nodes[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return (i != nodes.size());\\n    }\\n    \\nprivate:\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        traversal(root->left, nodes);\\n        nodes.push_back(root->val);\\n        traversal(root->right, nodes);    \\n    }    \\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```\\n\\n# Approach 2\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    stack <TreeNode* > nodes;\\n\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* nextNode = nodes.top();\\n        nodes.pop();\\n        pushAll(nextNode->right);\\n        return nextNode->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !nodes.empty();\\n    }\\n    \\nprivate:\\n    void pushAll(TreeNode* root) {\\n        while (root != NULL) {\\n            nodes.push(root);\\n            root = root->left;\\n        }   \\n    }     \\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    int i = 0;\\n    vector <int> nodes;\\n\\n    BSTIterator(TreeNode* root) {\\n        traversal(root, nodes);\\n    }\\n    \\n    int next() {\\n        return nodes[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return (i != nodes.size());\\n    }\\n    \\nprivate:\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        traversal(root->left, nodes);\\n        nodes.push_back(root->val);\\n        traversal(root->right, nodes);    \\n    }    \\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    stack <TreeNode* > nodes;\\n\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* nextNode = nodes.top();\\n        nodes.pop();\\n        pushAll(nextNode->right);\\n        return nextNode->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !nodes.empty();\\n    }\\n    \\nprivate:\\n    void pushAll(TreeNode* root) {\\n        while (root != NULL) {\\n            nodes.push(root);\\n            root = root->left;\\n        }   \\n    }     \\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52751,
                "title": "java-a-solution-of-15-lines",
                "content": "The idea for the solution is composed of the following points.\\n\\n 1. The solution uses a stack to keep track at most the next `\"h\"` (height of tree)\\n    elements for `\"next()\"` calls. \\n 2. The top of the stack is the current\\n    minimum element. \\n 3. At every `\"next()\"` call, we need to refresh the\\n    stack by populating the stack with all the left nodes up to the\\n    leaf, starting from the right node of the current minimum node.\\n\\nThe complexity of the `\"hasNext()\"` is O(1). While the `\"next()\"` needs to refresh the stack, which in the best case (leaf) takes constant time, and in the worst case, it would take up to `\"h\"` steps. The overall cost of `\"next()\"` is then amortized over the number of nodes. I don't have the precise proof, but it seems to be O(1) on average.\\n\\nHere is the code. One trick is that I extract the refreshing into a function which can be used in the constructor as well, so that the code is more concise. \\n\\n\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    \\n    private void refreshStack(TreeNode iter){\\n         while(iter != null){\\n         \\tstack.push(iter);\\n         \\titer = iter.left;\\n         }\\n    }\\n    \\t\\n    public BSTIterator(TreeNode root) {\\n       this.refreshStack(root);\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !(stack.isEmpty());\\n    }\\n    \\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        if(node != null){\\n        \\tthis.refreshStack(node.right);\\n        \\treturn node.val;\\n        }\\n        \\n        return -1; // should throw exception here.\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "The idea for the solution is composed of the following points.\\n\\n 1. The solution uses a stack to keep track at most the next `\"h\"` (height of tree)\\n    elements for `\"next()\"` calls. \\n 2. The top of the stack is the current\\n    minimum element. \\n 3. At every `\"next()\"` call, we need to refresh the\\n    stack by populating the stack with all the left nodes up to the\\n    leaf, starting from the right node of the current minimum node.\\n\\nThe complexity of the `\"hasNext()\"` is O(1). While the `\"next()\"` needs to refresh the stack, which in the best case (leaf) takes constant time, and in the worst case, it would take up to `\"h\"` steps. The overall cost of `\"next()\"` is then amortized over the number of nodes. I don't have the precise proof, but it seems to be O(1) on average.\\n\\nHere is the code. One trick is that I extract the refreshing into a function which can be used in the constructor as well, so that the code is more concise. \\n\\n\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    \\n    private void refreshStack(TreeNode iter){\\n         while(iter != null){\\n         \\tstack.push(iter);\\n         \\titer = iter.left;\\n         }\\n    }\\n    \\t\\n    public BSTIterator(TreeNode root) {\\n       this.refreshStack(root);\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !(stack.isEmpty());\\n    }\\n    \\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        if(node != null){\\n        \\tthis.refreshStack(node.right);\\n        \\treturn node.val;\\n        }\\n        \\n        return -1; // should throw exception here.\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3212805,
                "title": "173-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main idea behind this solution is to implement an iterator that returns the nodes in the in-order traversal of the binary search tree. We can use a stack to keep track of the nodes we need to visit.\\n\\n- In the constructor of the BSTIterator class, we initialize the stack with the leftmost path of the root node. We do this by adding all the left children of the root to the stack.\\n- hasNext() method returns true if the stack is not empty, which means that there are more nodes to be visited.\\n- next() method pops the top node from the stack, and if the popped node has a right child, we add all its left children to the stack.\\n\\n# Complexity\\n- Time complexity:\\nThe constructor will take O(h) time where h is the height of the tree. The hasNext() and next() method will take O(1) time.\\n\\n- Space complexity:\\nThe space required by the stack is O(h).\\n\\n# Code\\n```\\nclass BSTIterator:\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n    \\n    def next(self) -> int:\\n        node = self.stack.pop()\\n        if node.right:\\n            current = node.right\\n            while current:\\n                self.stack.append(current)\\n                current = current.left\\n        return node.val\\n    \\n    def hasNext(self) -> bool:\\n        return len(self.stack) > 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Design",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator:\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n    \\n    def next(self) -> int:\\n        node = self.stack.pop()\\n        if node.right:\\n            current = node.right\\n            while current:\\n                self.stack.append(current)\\n                current = current.left\\n        return node.val\\n    \\n    def hasNext(self) -> bool:\\n        return len(self.stack) > 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966160,
                "title": "o-1-space-3-solutions-python",
                "content": "## Solution 1: Precalculate inorder traversal\\n\\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._traversal = []\\n\\t\\t# find the whole traversal\\n        self._inorder(root)\\n\\t\\t# pointer to the node which we should return\\n        self._current = 0\\n\\n    def _inorder(self, node: Optional[TreeNode]) -> None:\\n\\t\\t\\n        if node is None:\\n            return\\n\\n        self._inorder(node.left)\\n        self._traversal.append(node)\\n        self._inorder(node.right)\\n            \\n    def next(self) -> int:\\n        \\n\\t\\t# get the node\\n        node = self._traversal[self._current]\\n\\t\\t# move the pointer\\n        self._current += 1\\n\\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \\n\\t\\t# we have nodes until we reach the end\\n        return self._current < len(self._traversal) \\n```\\n\\n### Solution 2: Using stack\\n\\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._stack = []\\n\\t\\t# initial population of the stack\\n\\t\\t# it\\'ll add all the nodes on the path \\n\\t\\t# to the most left node (the smallest)\\n        self._update_stack(root)\\n            \\n    def _update_stack(self, node: Optional[TreeNode]) -> None:\\n        # add the next nodes to the stack\\n        while node:\\n            self._stack.append(node)\\n            node = node.left\\n\\n    def next(self) -> int:\\n        # on top of the stack we have the node \\n\\t\\t# which we need to return\\n        node = self._stack.pop()\\n        # this node doesn\\'t have the left subtree\\n\\t\\t# or we already visited all the nodes in the left subtree\\n\\t\\t# so the next node should be in the right subtree\\n        self._update_stack(node.right)\\n            \\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \\n        return bool(self._stack)\\n```\\n\\n### Solution 3: Morris Traversal ( O(1) Space)\\n\\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._current = root\\n            \\n    def next(self) -> Optional[int]:\\n        \\n        val = None\\n        while self._current:\\n\\t\\t\\t# if left tree exists\\n            if self._current.left:\\n\\t\\t\\t\\t# find inorder predecessor (the most right node the in left subtree)\\n                predecessor = self._current.left\\n                while predecessor.right and predecessor.right != self._current:\\n                    predecessor = predecessor.right\\n\\t\\t\\t\\t# if we find this predecessor in the first time\\n\\t\\t\\t\\t# it means that we haven\\'t visited the left subtree of self._current yet,\\n\\t\\t\\t\\t# so set a link from predecessor to self._current to know that\\n\\t\\t\\t\\t# we already visited the left subtree when we\\'ll find it in the second time\\n                if predecessor.right is None:\\n                    predecessor.right = self._current\\n                    self._current = self._current.left\\n\\t\\t\\t\\t# we already visited the left subtree\\n                else:\\n\\t\\t\\t\\t\\t# take the value of the node\\n                    val = self._current.val\\n\\t\\t\\t\\t\\t# go to the right subtree\\n                    predecessor.right = None\\n                    self._current = self._current.right\\n                    break\\n\\t\\t\\t# there is no left subtree,\\n\\t\\t\\t# take the value of the node and go to the right subtree\\n            else:\\n                val = self._current.val\\n                self._current = self._current.right \\n                break\\n            \\n        return val \\n\\n    def hasNext(self) -> bool:\\n        \\n        return self._current is not None \\n```\\n\\n### Bonus: Implement Python Iterator Protocol\\n\\n```\\nclass TreeNode(Iterable):\\n\\n    def __init__(\\n        self, \\n        val: int = 0, \\n        left: Optional[\"TreeNode\"] = None, \\n        right: Optional[\"TreeNode\"] = None\\n    ):\\n\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n    def __iter__(self) -> Iterator:\\n\\n        return BSTIterator(self)\\n\\n    def __str__(self) -> str:\\n        return str(self.val)\\n\\n\\nclass BSTIterator(Iterator):\\n\\n    def __init__(self, root: Optional[TreeNode] = None) -> None:\\n        self._current = root\\n            \\n    def next(self) -> Optional[int]:\\n        \\n        val = None\\n        while self._current:\\n            if self._current.left:\\n                predecessor = self._current.left\\n                while predecessor.right and predecessor.right != self._current:\\n                    predecessor = predecessor.right\\n\\n                if predecessor.right is None:\\n                    predecessor.right = self._current\\n                    self._current = self._current.left\\n                else:\\n                    val = self._current.val\\n                    predecessor.right = None\\n                    self._current = self._current.right\\n                    break\\n            else:\\n                val = self._current.val\\n                self._current = self._current.right \\n                break\\n            \\n        return val \\n\\n    def hasNext(self) -> bool:\\n        \\n        return self._current is not None \\n\\n    def __next__(self) -> int:\\n\\n        val = self.next()\\n        if val is None:\\n            raise StopIteration\\n\\n        return val\\n\\nroot = TreeNode(\\n    val=7,\\n    left=TreeNode(val=3),\\n    right=TreeNode(\\n        val=15,\\n        left=TreeNode(val=9),\\n        right=TreeNode(val=20),\\n    )\\n)\\n\\nfor node in root:\\n    print(node)\\n```\\n\\nP.S. Feel free to upvote if you liked it",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._traversal = []\\n\\t\\t# find the whole traversal\\n        self._inorder(root)\\n\\t\\t# pointer to the node which we should return\\n        self._current = 0\\n\\n    def _inorder(self, node: Optional[TreeNode]) -> None:\\n\\t\\t\\n        if node is None:\\n            return\\n\\n        self._inorder(node.left)\\n        self._traversal.append(node)\\n        self._inorder(node.right)\\n            \\n    def next(self) -> int:\\n        \\n\\t\\t# get the node\\n        node = self._traversal[self._current]\\n\\t\\t# move the pointer\\n        self._current += 1\\n\\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \\n\\t\\t# we have nodes until we reach the end\\n        return self._current < len(self._traversal) \\n```\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._stack = []\\n\\t\\t# initial population of the stack\\n\\t\\t# it\\'ll add all the nodes on the path \\n\\t\\t# to the most left node (the smallest)\\n        self._update_stack(root)\\n            \\n    def _update_stack(self, node: Optional[TreeNode]) -> None:\\n        # add the next nodes to the stack\\n        while node:\\n            self._stack.append(node)\\n            node = node.left\\n\\n    def next(self) -> int:\\n        # on top of the stack we have the node \\n\\t\\t# which we need to return\\n        node = self._stack.pop()\\n        # this node doesn\\'t have the left subtree\\n\\t\\t# or we already visited all the nodes in the left subtree\\n\\t\\t# so the next node should be in the right subtree\\n        self._update_stack(node.right)\\n            \\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \\n        return bool(self._stack)\\n```\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._current = root\\n            \\n    def next(self) -> Optional[int]:\\n        \\n        val = None\\n        while self._current:\\n\\t\\t\\t# if left tree exists\\n            if self._current.left:\\n\\t\\t\\t\\t# find inorder predecessor (the most right node the in left subtree)\\n                predecessor = self._current.left\\n                while predecessor.right and predecessor.right != self._current:\\n                    predecessor = predecessor.right\\n\\t\\t\\t\\t# if we find this predecessor in the first time\\n\\t\\t\\t\\t# it means that we haven\\'t visited the left subtree of self._current yet,\\n\\t\\t\\t\\t# so set a link from predecessor to self._current to know that\\n\\t\\t\\t\\t# we already visited the left subtree when we\\'ll find it in the second time\\n                if predecessor.right is None:\\n                    predecessor.right = self._current\\n                    self._current = self._current.left\\n\\t\\t\\t\\t# we already visited the left subtree\\n                else:\\n\\t\\t\\t\\t\\t# take the value of the node\\n                    val = self._current.val\\n\\t\\t\\t\\t\\t# go to the right subtree\\n                    predecessor.right = None\\n                    self._current = self._current.right\\n                    break\\n\\t\\t\\t# there is no left subtree,\\n\\t\\t\\t# take the value of the node and go to the right subtree\\n            else:\\n                val = self._current.val\\n                self._current = self._current.right \\n                break\\n            \\n        return val \\n\\n    def hasNext(self) -> bool:\\n        \\n        return self._current is not None \\n```\n```\\nclass TreeNode(Iterable):\\n\\n    def __init__(\\n        self, \\n        val: int = 0, \\n        left: Optional[\"TreeNode\"] = None, \\n        right: Optional[\"TreeNode\"] = None\\n    ):\\n\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n    def __iter__(self) -> Iterator:\\n\\n        return BSTIterator(self)\\n\\n    def __str__(self) -> str:\\n        return str(self.val)\\n\\n\\nclass BSTIterator(Iterator):\\n\\n    def __init__(self, root: Optional[TreeNode] = None) -> None:\\n        self._current = root\\n            \\n    def next(self) -> Optional[int]:\\n        \\n        val = None\\n        while self._current:\\n            if self._current.left:\\n                predecessor = self._current.left\\n                while predecessor.right and predecessor.right != self._current:\\n                    predecessor = predecessor.right\\n\\n                if predecessor.right is None:\\n                    predecessor.right = self._current\\n                    self._current = self._current.left\\n                else:\\n                    val = self._current.val\\n                    predecessor.right = None\\n                    self._current = self._current.right\\n                    break\\n            else:\\n                val = self._current.val\\n                self._current = self._current.right \\n                break\\n            \\n        return val \\n\\n    def hasNext(self) -> bool:\\n        \\n        return self._current is not None \\n\\n    def __next__(self) -> int:\\n\\n        val = self.next()\\n        if val is None:\\n            raise StopIteration\\n\\n        return val\\n\\nroot = TreeNode(\\n    val=7,\\n    left=TreeNode(val=3),\\n    right=TreeNode(\\n        val=15,\\n        left=TreeNode(val=9),\\n        right=TreeNode(val=20),\\n    )\\n)\\n\\nfor node in root:\\n    print(node)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965188,
                "title": "python-6-line-simple-solution-beginner-friendly",
                "content": "The idea is get the sorted tree nodes, and then the problem turns to check the next smallest int number & check if there are any remaining numbers\\n\\n**Please upvote me if you think this is useful :) Much Appreciated!**\\n\\n```\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        # get the in order tree node values\\n        def inorder(root):\\n            if not root:    return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        self.treenodes = inorder(root)\\n        \\n        \\n    def next(self):\\n        # pop out the current smallest int\\n        return self.treenodes.pop(0)\\n        \\n\\n    def hasNext(self):\\n        # check if there are remaining int\\n        return len(self.treenodes) != 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        # get the in order tree node values\\n        def inorder(root):\\n            if not root:    return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        self.treenodes = inorder(root)\\n        \\n        \\n    def next(self):\\n        # pop out the current smallest int\\n        return self.treenodes.pop(0)\\n        \\n\\n    def hasNext(self):\\n        # check if there are remaining int\\n        return len(self.treenodes) != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965154,
                "title": "o-1-space-query-convert-to-linked-list-no-stack-c",
                "content": "We can easily solve the problem in O(1) space by converting the tree to a linked list by inoreder traversal \\nand then just easily answer the queries by saving the head of the linked list.\\n\\n```\\nclass BSTIterator {\\n    \\n    TreeNode* head ;\\n    \\n    void convert(TreeNode* root , TreeNode* &prev , TreeNode* &next)\\n    {\\n        if(root == NULL) return ;\\n        convert(root->left , prev , next) ;\\n        \\n        if(next == NULL){\\n            next = root ;\\n        }\\n        \\n        if(prev!= NULL)\\n        {\\n            prev->right = root ;\\n        }\\n            root->left = NULL ;\\n            prev = root ;\\n        \\n        convert(root->right, prev , next) ;\\n    }\\n    \\npublic:\\n    BSTIterator(TreeNode* root) {\\n        head = NULL ;\\n        head = new TreeNode(0) ;\\n        \\n        TreeNode* prev = NULL ;\\n        TreeNode* &next = head->right ;\\n        convert(root , prev , next) ;\\n\\n    }\\n    \\n    int next() {\\n        head = head->right ;\\n        return head->val ;\\n    }\\n    \\n    bool hasNext() {\\n        return head->right != NULL ; \\n     }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Tree"
                ],
                "code": "We can easily solve the problem in O(1) space by converting the tree to a linked list by inoreder traversal \\nand then just easily answer the queries by saving the head of the linked list.\\n\\n```\\nclass BSTIterator {\\n    \\n    TreeNode* head ;\\n    \\n    void convert(TreeNode* root , TreeNode* &prev , TreeNode* &next)\\n    {\\n        if(root == NULL) return ;\\n        convert(root->left , prev , next) ;\\n        \\n        if(next == NULL){\\n            next = root ;\\n        }\\n        \\n        if(prev!= NULL)\\n        {\\n            prev->right = root ;\\n        }\\n            root->left = NULL ;\\n            prev = root ;\\n        \\n        convert(root->right, prev , next) ;\\n    }\\n    \\npublic:\\n    BSTIterator(TreeNode* root) {\\n        head = NULL ;\\n        head = new TreeNode(0) ;\\n        \\n        TreeNode* prev = NULL ;\\n        TreeNode* &next = head->right ;\\n        convert(root , prev , next) ;\\n\\n    }\\n    \\n    int next() {\\n        head = head->right ;\\n        return head->val ;\\n    }\\n    \\n    bool hasNext() {\\n        return head->right != NULL ; \\n     }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 498353,
                "title": "100-00-fast-in-run-time-and-compared-with-other-approaches-iterative-recursive",
                "content": "satisfactory read: Agree? \\n\\n----------------\\n**Note:**\\n**(a).** next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.\\n**(b).** You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.\\n\\nUsually, an iterator simply goes over each of the elements of the container one by one. For the BST, we want the iterator to return elements in an ascending order.\\n\\n If such an iterator is defined, then the traversal logic can be abstracted out and we can simply make use of the iterator to process the elements in a certain order.\\n** E.G.: **\\n```\\n\\t new_iterator = BSTIterator(root);\\n\\t while (new_iterator.hasNext())\\n\\t    process(new_iterator.next());\\n```\\n\\n----------------------\\nRuntime: 28 ms, faster than **100.00%** of C++ online submissions for Binary Search Tree Iterator.\\nMemory Usage: 24.2 MB, less than **95.65%** of C++ online submissions for Binary Search Tree Iterator.\\n```\\nstatic const auto magic = []() {\\n  std::ios::sync_with_stdio(false);\\n  std::cin.tie(nullptr);\\n  std::cout.tie(nullptr);\\n  return nullptr;\\n}();\\n\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\n    TreeNode* visit;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        visit = root;\\n    }\\n    int next() {\\n        while(visit){\\n            st.push(visit);\\n            visit = visit->left;\\n        }\\n        TreeNode* next = st.top(); st.pop();\\n        visit = next->right;\\n        return next->val;\\n    }\\n    bool hasNext() {\\n        return visit || !st.empty();\\n    }\\n    void pushLeft(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n\\n```\\n\\n------------------------\\n# **controlled recursion**\\nRuntime: 52 ms, faster than 89.84% of C++ online submissions for Binary Search Tree Iterator.\\nMemory Usage: 24.2 MB, less than 89.13% of C++ online submissions for Binary Search Tree Iterator.\\n**average O(1) time and uses O(h) memory**\\nThe average time complexity of next() function is O(1) indeed. As the next function can be called n times at most, and the number of right nodes in **pushLeft(root->right) function is maximal n** in a tree which has n nodes, so the **amortized time complexity is O(1)**.\\n\\n![](https://leetcode.com/articles/Figures/173/approach_2-1.png)\\n\\n# **And then**\\n\\n![](https://leetcode.com/articles/Figures/173/approach_2-2.png)\\n\\n**Time complexity** : The time complexity for this approach is very interesting to analyze. Let\\'s look at the complexities for both the functions in the class:\\n\\nhasNext is the easier of the lot since all we do in this is to return true if there are any elements left in the stack. Otherwise, we return false. So clearly, this is an **O(1)** operation every time. Let\\'s look at the more complicated function now to see if we satisfy all the requirements in the problem statement\\nnext involves two major operations. One is where we pop an element from the stack which becomes the next smallest element to return. This is a **O(1)** operation. However, we then make a call to our helper function pushLeft which iterates over a bunch of nodes. This is clearly a linear time operation i.e. **O(N)** in the worst case. This is true.\\n\\nHowever, the important thing to note here is that we only make such a call for nodes which have a right child. Otherwise, we simply return. Also, even if we end up calling the helper function, it won\\'t always process N nodes. They will be much lesser. Only **if we have a skewed tree** would there be N nodes for the root. But that is the only node for which we would call the helper function.\\nThus,** the amortized (average) time complexity** for this function would still be **O(1)** which is what the question asks for. We don\\'t need to have a solution which gives constant time operations for every call. We need that complexity on average and that is what we get.\\n\\n**Space complexity**: The space complexity is **O(h)** which is occupied by our** custom stack** for simulating the inorder traversal. Again, we satisfy the space requirements as well as specified in the problem statement. \\n\\n```\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        pushLeft(root);\\n    }\\n    int next() {\\n        TreeNode* next = st.top(); st.pop();\\n        if(next->right) pushLeft(next->right);\\n        return next->val;\\n    }\\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    void pushLeft(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n```\\n\\n**Flattening the BST**\\n**Algorithm:**\\n**1.** Initialize an empty vector that will contain the nodes of the binary search tree in the sorted order.\\n**2.** We traverse the binary search tree in the inorder fashion and for each node that we process, we add it to our vector nodes. Note that before processing a node, its left subtree has to be processed (or recursed upon) and after processing a node, its right subtree has to be recursed upon.\\n**(3).** Once we have all the nodes in an vector, we simply need a pointer or an index in that array to implement the two functions next and hasNext. Whenever there\\'s a call to hasNext, we simply check if the index has reached the end of the vector or not. For the call to next function, we simply return the element pointed by the index. Also, after a the next function call is made, we have to move the index one step forward to simulate the progress of our iterator.\\n\\n-------------------\\n# **Flattening the BST**\\nRuntime: 64 ms\\nMemory Usage: 25.4 MB\\n**Time complexity:** **O(N)** is the time taken by the **constructor** for the iterator. The problem statement only asks us to analyze the complexity of the two functions, however, when implementing a class, it\\'s important to also note the time it takes to initialize a new object of the class and in this case it would be linear in terms of the number of nodes in the BST. In addition to the space occupied by the new array we initialized, the recursion stack for the inorder traversal also occupies space but that is limited to **O(h)** where h is the height of the tree.\\nnext() would take **O(1)**\\nhasNext() would take **O(1)**\\n**Space complexity :** **O(N)** since we create a new array to contain all the nodes of the BST. This doesn\\'t comply with the requirement specified in the problem statement that the maximum space complexity of either of the functions should be **O(h)** where h is the height of the tree and for a well balanced BST, the height is usually **logN**, So, we get great time complexities but we had to compromise on the space. Note that the new vector is used for both the function calls and hence the **space complexity for both the calls is O(N)**. \\n\\n```\\nclass BSTIterator {\\nprivate: \\n    vector<int> list;\\n    int loc;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        loc = 0;\\n        dfs(root);\\n    }\\n    void dfs(TreeNode* root){\\n        if(!root) return;\\n        dfs(root->left);\\n        list.push_back(root->val);\\n        dfs(root->right);\\n    }\\n    int next() {\\n        return list[loc++];\\n    }\\n    bool hasNext() {\\n        if(loc<list.size()) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\t new_iterator = BSTIterator(root);\\n\\t while (new_iterator.hasNext())\\n\\t    process(new_iterator.next());\\n```\n```\\nstatic const auto magic = []() {\\n  std::ios::sync_with_stdio(false);\\n  std::cin.tie(nullptr);\\n  std::cout.tie(nullptr);\\n  return nullptr;\\n}();\\n\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\n    TreeNode* visit;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        visit = root;\\n    }\\n    int next() {\\n        while(visit){\\n            st.push(visit);\\n            visit = visit->left;\\n        }\\n        TreeNode* next = st.top(); st.pop();\\n        visit = next->right;\\n        return next->val;\\n    }\\n    bool hasNext() {\\n        return visit || !st.empty();\\n    }\\n    void pushLeft(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n\\n```\n```\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        pushLeft(root);\\n    }\\n    int next() {\\n        TreeNode* next = st.top(); st.pop();\\n        if(next->right) pushLeft(next->right);\\n        return next->val;\\n    }\\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    void pushLeft(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n```\n```\\nclass BSTIterator {\\nprivate: \\n    vector<int> list;\\n    int loc;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        loc = 0;\\n        dfs(root);\\n    }\\n    void dfs(TreeNode* root){\\n        if(!root) return;\\n        dfs(root->left);\\n        list.push_back(root->val);\\n        dfs(root->right);\\n    }\\n    int next() {\\n        return list[loc++];\\n    }\\n    bool hasNext() {\\n        if(loc<list.size()) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 52653,
                "title": "java-concise-solution",
                "content": "        \\n    private Stack<TreeNode> stack;\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<>();\\n        pushLeft(root);\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    private void pushLeft(TreeNode node) {\\n        while (node != null) {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        pushLeft(node.right);\\n        return node.val;\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "        \\n    private Stack<TreeNode> stack;\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<>();\\n        pushLeft(root);\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    private void pushLeft(TreeNode node) {\\n        while (node != null) {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        pushLeft(node.right);\\n        return node.val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2130075,
                "title": "simple-cpp-code-using-morris-traversal-no-extra-space-top-90-fast-and-90-memory-use",
                "content": "Simply use Morris traversal and don\\'t make the Thread NULL again Let the right pointer point to next node.\\nStart from node with least value, so go to the very left.\\n\\n**next() Function Explanation**\\nTo change pointer to next move pointer to right and then left until node->left != null (just as traversing for next smallest element in normal BST)\\nbut we have chance that this right can be a thread we created so By checking weather the new pointer points to value lesser than current value then we just go right\\n```\\nint next() {\\n        if(node!=NULL){\\n            int cur = node->val;\\n            TreeNode* pre = node;\\n            if(node->right == NULL){\\n                node = NULL;\\n                return cur;\\n            }\\n            node = node->right;\\n            while(node->left!=NULL)node = node->left;\\n            \\n            if(node->val <= cur){\\n                node = pre->right;\\n            }\\n            return cur;\\n        }\\n        return -1;\\n    }\\n```\\n**Final Code**\\n```\\nclass BSTIterator {\\npublic:\\n    TreeNode* node;\\n    BSTIterator(TreeNode* root) {\\n        node = root;\\n        while(node != NULL){\\n            if(node->left == NULL){\\n                node = node->right;\\n            }else{\\n                TreeNode* temp = node->left;\\n                while(temp->right!=NULL && temp->right != node){\\n                    temp = temp->right;\\n                }\\n                if(temp->right == NULL)temp->right = node, node = node->left;\\n                else if(temp->right == node)node = node->right;\\n            }\\n        }\\n        node = root;\\n        while(node->left!=NULL)node = node->left;\\n    }\\n    \\n    int next() {\\n        if(node!=NULL){\\n            int cur = node->val;\\n            TreeNode* pre = node;\\n            if(node->right == NULL){\\n                node = NULL;\\n                return cur;\\n            }\\n            node = node->right;\\n            while(node->left!=NULL)node = node->left;\\n            \\n            if(node->val <= cur){\\n                node = pre->right;\\n            }\\n            return cur;\\n        }\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(node!=NULL)return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nint next() {\\n        if(node!=NULL){\\n            int cur = node->val;\\n            TreeNode* pre = node;\\n            if(node->right == NULL){\\n                node = NULL;\\n                return cur;\\n            }\\n            node = node->right;\\n            while(node->left!=NULL)node = node->left;\\n            \\n            if(node->val <= cur){\\n                node = pre->right;\\n            }\\n            return cur;\\n        }\\n        return -1;\\n    }\\n```\n```\\nclass BSTIterator {\\npublic:\\n    TreeNode* node;\\n    BSTIterator(TreeNode* root) {\\n        node = root;\\n        while(node != NULL){\\n            if(node->left == NULL){\\n                node = node->right;\\n            }else{\\n                TreeNode* temp = node->left;\\n                while(temp->right!=NULL && temp->right != node){\\n                    temp = temp->right;\\n                }\\n                if(temp->right == NULL)temp->right = node, node = node->left;\\n                else if(temp->right == node)node = node->right;\\n            }\\n        }\\n        node = root;\\n        while(node->left!=NULL)node = node->left;\\n    }\\n    \\n    int next() {\\n        if(node!=NULL){\\n            int cur = node->val;\\n            TreeNode* pre = node;\\n            if(node->right == NULL){\\n                node = NULL;\\n                return cur;\\n            }\\n            node = node->right;\\n            while(node->left!=NULL)node = node->left;\\n            \\n            if(node->val <= cur){\\n                node = pre->right;\\n            }\\n            return cur;\\n        }\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(node!=NULL)return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775226,
                "title": "javascript-clean-stack-solution",
                "content": "```javascript\\nclass BSTIterator {\\n    constructor(root) {\\n        this.root = root;\\n        this.stack = [];\\n    }\\n    \\n    next() {\\n        while(this.root) {\\n            this.stack.push(this.root);\\n            this.root = this.root.left;\\n        }\\n        const res = this.stack.pop();\\n        this.root = res.right;\\n        return res.val;\\n    }\\n    \\n    hasNext() {\\n        return this.root || this.stack.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass BSTIterator {\\n    constructor(root) {\\n        this.root = root;\\n        this.stack = [];\\n    }\\n    \\n    next() {\\n        while(this.root) {\\n            this.stack.push(this.root);\\n            this.root = this.root.left;\\n        }\\n        const res = this.stack.pop();\\n        this.root = res.right;\\n        return res.val;\\n    }\\n    \\n    hasNext() {\\n        return this.root || this.stack.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241072,
                "title": "keep-prompting-runtime-error-on-json-decoding",
                "content": "From yesterday (on Feb. 20th) till now when I tried to run my code using the given test code, the platform keeps prompting that there is a Runtime Error on json decoding. I tried to submit directly but still received an error message:\\n\\n```\\nLine 56: json.decoder.JSONDecodeError: Expecting value: line 1 column 12 (char 11)\\n```\\n\\nThe same (local) error jumped out even when I tried to run the AC code posted in the discuss area. Could anyone kindly help me figure this out? Great thanks\\n\\n(I tried python3, python and Java, all failed)",
                "solutionTags": [],
                "code": "```\\nLine 56: json.decoder.JSONDecodeError: Expecting value: line 1 column 12 (char 11)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52591,
                "title": "c-binary-tree-template-solves-many-bst-problems-dfs",
                "content": "There is a template for solving many BST problems here is the basic idea starting with standard In Order Traversal.  Pay attention to the \"VISIT NODE\" block, depending on the problem you will plug in your custom logic into this part of the template.\\n\\n```\\n    public IList<int> InorderTraversal(TreeNode root) \\n    {\\n        IList<int> list = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode node = root;\\n        while (node != null || stack.Count > 0)\\n        {\\n            if (node != null)\\n            {\\n                stack.Push(node);\\n                node = node.left;\\n            }\\n            else\\n            {\\n                node = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                list.Add(node.val);\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                node = node.right;\\n            }\\n        }\\n        \\n        return list;\\n    }\\n```\\n\\nHere we can adapt this to the BST iterator problem where \"VISIT NODE\" means this is the next value and break here.\\n\\n```\\npublic class BSTIterator {\\n\\n    private TreeNode curr;\\n    private Stack<TreeNode> stack;\\n    \\n    public BSTIterator(TreeNode root) \\n    {\\n        this.curr = root;\\n        this.stack = new Stack<TreeNode>();\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() \\n    {\\n        return this.curr != null || this.stack.Count > 0;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int Next() \\n    {\\n        int val = 0;\\n        while (this.curr != null || this.stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                this.stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                this.curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                val = curr.val;   \\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                this.curr = curr.right;\\n                break;\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```\\n\\nHere we adaptt it to find the Kth smallest value\\n\\n```\\n    public int KthSmallest(TreeNode root, int k) \\n    {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode curr = root;\\n        \\n        while (curr != null || stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                if (--k == 0) return curr.val;\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                curr = curr.right;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```\\n\\nValidate Binary Search Tree\\n```\\n    public bool IsValidBST(TreeNode root) \\n    {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        \\n        while (curr != null || stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                if (prev != null && prev.val >= curr.val) return false;\\n                prev = curr;\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                curr = curr.right;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<int> InorderTraversal(TreeNode root) \\n    {\\n        IList<int> list = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode node = root;\\n        while (node != null || stack.Count > 0)\\n        {\\n            if (node != null)\\n            {\\n                stack.Push(node);\\n                node = node.left;\\n            }\\n            else\\n            {\\n                node = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                list.Add(node.val);\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                node = node.right;\\n            }\\n        }\\n        \\n        return list;\\n    }\\n```\n```\\npublic class BSTIterator {\\n\\n    private TreeNode curr;\\n    private Stack<TreeNode> stack;\\n    \\n    public BSTIterator(TreeNode root) \\n    {\\n        this.curr = root;\\n        this.stack = new Stack<TreeNode>();\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() \\n    {\\n        return this.curr != null || this.stack.Count > 0;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int Next() \\n    {\\n        int val = 0;\\n        while (this.curr != null || this.stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                this.stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                this.curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                val = curr.val;   \\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                this.curr = curr.right;\\n                break;\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```\n```\\n    public int KthSmallest(TreeNode root, int k) \\n    {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode curr = root;\\n        \\n        while (curr != null || stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                if (--k == 0) return curr.val;\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                curr = curr.right;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```\n```\\n    public bool IsValidBST(TreeNode root) \\n    {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        \\n        while (curr != null || stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                if (prev != null && prev.val >= curr.val) return false;\\n                prev = curr;\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                curr = curr.right;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52716,
                "title": "using-stack-with-explanations",
                "content": "    class BSTIterator {\\n       public:\\n        BSTIterator(TreeNode *root) {\\n            pushAllToTheLeftMost(root);\\n        }\\n    \\n        bool hasNext() {\\n            return !nodes.empty();\\n        }\\n    \\n        /**\\n         * Precondition: the top of the stack is current smallest node (t)\\n         *               whose value will be returned\\n         * \\n         * Postcondition: the top of the stack is the next smallest node.\\n         * \\n         * if the t has right node, the next smallest node will be the left \\n         * most of the right node; otherwise, the next smallest node is t's parent node, \\n         * which has already been pushed on the stack just before the t. \\n         * */\\n        int next() {\\n            TreeNode *t = nodes.top();\\n            nodes.pop();\\n            pushAllToTheLeftMost(t->right);\\n            return t->val;\\n        }\\n        \\n    private:\\n        /** push all the nodes from c to its left most node to the stack */\\n        void pushAllToTheLeftMost(TreeNode *c) {\\n            while (c) {\\n                nodes.push(c);\\n                c = c->left;\\n            }\\n        }\\n        stack<TreeNode*> nodes;\\n    };",
                "solutionTags": [],
                "code": "    class BSTIterator {\\n       public:\\n        BSTIterator(TreeNode *root) {\\n            pushAllToTheLeftMost(root);\\n        }\\n    \\n        bool hasNext() {\\n            return !nodes.empty();\\n        }\\n    \\n        /**\\n         * Precondition: the top of the stack is current smallest node (t)\\n         *               whose value will be returned\\n         * \\n         * Postcondition: the top of the stack is the next smallest node.\\n         * \\n         * if the t has right node, the next smallest node will be the left \\n         * most of the right node; otherwise, the next smallest node is t's parent node, \\n         * which has already been pushed on the stack just before the t. \\n         * */\\n        int next() {\\n            TreeNode *t = nodes.top();\\n            nodes.pop();\\n            pushAllToTheLeftMost(t->right);\\n            return t->val;\\n        }\\n        \\n    private:\\n        /** push all the nodes from c to its left most node to the stack */\\n        void pushAllToTheLeftMost(TreeNode *c) {\\n            while (c) {\\n                nodes.push(c);\\n                c = c->left;\\n            }\\n        }\\n        stack<TreeNode*> nodes;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3574933,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\nThe code implements an iterator for a binary search tree (BST). The iterator is used to traverse the BST in ascending order, providing the next smallest element in each iteration.\\n\\n# Approach\\n- The BSTIterator class uses a stack to keep track of the nodes during traversal.\\n- In the constructor BSTIterator(TreeNode* root), the pushAll function is called to push all the left subtree nodes onto the stack. This ensures that the leftmost node becomes the top of the stack, representing the smallest element in the BST.\\n- The next function returns the value of the top node in the stack (which is the next smallest element) and removes it from the stack. Then, the pushAll function is called on the right child of the popped node to push all the left subtree nodes of the right child onto the stack.\\n- The hasNext function simply checks if the stack is empty or not. If the stack is not empty, it means there are more elements in the BST, and it returns true; otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:\\n## o(1)\\n\\n- Space complexity:\\n O(h)\\n\\n# Code\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;  // Stack to store tree nodes\\n\\n    // Function to push all left subtree nodes onto the stack\\n    void pushAll(TreeNode* node) {\\n        while (node) {\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n\\n    // Constructor that initializes the iterator\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);  // Push all left subtree nodes onto the stack\\n    }\\n\\n    // Function to return the next smallest element in the BST\\n    int next() {\\n        auto temp = st.top();  // Get the top node from the stack\\n        st.pop();  // Pop the node from the stack\\n        pushAll(temp->right);  // Push all left subtree nodes of the right child onto the stack\\n        return temp->val;  // Return the value of the popped node\\n    }\\n\\n    // Function to check if there are any more elements in the BST\\n    bool hasNext() {\\n        return !st.empty();  // Return true if the stack is not empty, indicating there are more elements\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;  // Stack to store tree nodes\\n\\n    // Function to push all left subtree nodes onto the stack\\n    void pushAll(TreeNode* node) {\\n        while (node) {\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n\\n    // Constructor that initializes the iterator\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);  // Push all left subtree nodes onto the stack\\n    }\\n\\n    // Function to return the next smallest element in the BST\\n    int next() {\\n        auto temp = st.top();  // Get the top node from the stack\\n        st.pop();  // Pop the node from the stack\\n        pushAll(temp->right);  // Push all left subtree nodes of the right child onto the stack\\n        return temp->val;  // Return the value of the popped node\\n    }\\n\\n    // Function to check if there are any more elements in the BST\\n    bool hasNext() {\\n        return !st.empty();  // Return true if the stack is not empty, indicating there are more elements\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579552,
                "title": "python-generator-solution-using-python-generator-with-yield",
                "content": "We have already some excellent solutions in this discussion but I wanted to share a Python solution using generator with yield for fun. next is O(1) and hasNext is O(1).\\n\\n```\\ndef inorder_generator(node):\\n    if node:\\n        yield from inorder_generator(node.left)\\n        yield node\\n        yield from inorder_generator(node.right)\\n\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.iterator = iter(inorder_generator(root))\\n        self._next = None\\n\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        if self._next:\\n            next_node = self._next\\n            self._next = None\\n            return next_node.val\\n\\n        next_node = next(self.iterator, None)\\n        if next_node:\\n            return next_node.val\\n        else:\\n            return None\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        if self._next:\\n            return True\\n        \\n        try:\\n            self._next = next(self.iterator)\\n        except StopIteration:\\n            return False\\n        \\n        return True\\n```\\n\\nBTW, the idea hasNext on Python was from https://stackoverflow.com/questions/1966591/hasnext-in-python-iterators/1967037#1967037 \\n\\nAlex Martelli is one of the best Python guru and I always appreciate his contribution to Python.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef inorder_generator(node):\\n    if node:\\n        yield from inorder_generator(node.left)\\n        yield node\\n        yield from inorder_generator(node.right)\\n\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.iterator = iter(inorder_generator(root))\\n        self._next = None\\n\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        if self._next:\\n            next_node = self._next\\n            self._next = None\\n            return next_node.val\\n\\n        next_node = next(self.iterator, None)\\n        if next_node:\\n            return next_node.val\\n        else:\\n            return None\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        if self._next:\\n            return True\\n        \\n        try:\\n            self._next = next(self.iterator)\\n        except StopIteration:\\n            return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340878,
                "title": "python-stack-solution",
                "content": "The solution of this problem is similar to the iterative solution of \\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/332283/Python-recursive-and-iterative-solutions).\\n```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```\\n\\n```\\nclass BSTIterator:\\n    def __init__(self, root):\\n        self.stack = []\\n        self.curr = root\\n        \\n    def next(self):\\n        while self.curr or self.stack:\\n            if self.curr:\\n                self.stack.append(self.curr)\\n                self.curr = self.curr.left\\n            else:\\n                result = self.stack.pop()\\n                self.curr = result.right\\n                return result.val\\n        \\n    def hasNext(self):\\n        return self.curr or self.stack\\n```",
                "solutionTags": [],
                "code": "```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```\n```\\nclass BSTIterator:\\n    def __init__(self, root):\\n        self.stack = []\\n        self.curr = root\\n        \\n    def next(self):\\n        while self.curr or self.stack:\\n            if self.curr:\\n                self.stack.append(self.curr)\\n                self.curr = self.curr.left\\n            else:\\n                result = self.stack.pop()\\n                self.curr = result.right\\n                return result.val\\n        \\n    def hasNext(self):\\n        return self.curr or self.stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202370,
                "title": "javascript",
                "content": "```\\n/**\\n * Definition for binary tree\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * @constructor\\n * @param {TreeNode} root - root of the binary search tree\\n */\\nvar BSTIterator = function(root) {\\n    this.array = []\\n    dfs(root, this.array)\\n    \\n    function dfs(root, array) {\\n        if(!root) {\\n            return\\n        }\\n        dfs(root.left, array)\\n        array.push(root.val)\\n        dfs(root.right, array)\\n    }\\n};\\n\\n\\n/**\\n * @this BSTIterator\\n * @returns {boolean} - whether we have a next smallest number\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.array.length > 0\\n};\\n\\n/**\\n * @this BSTIterator\\n * @returns {number} - the next smallest number\\n */\\nBSTIterator.prototype.next = function() {\\n    if(this.hasNext()){\\n        return this.array.shift()\\n    }\\n};\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * var i = new BSTIterator(root), a = [];\\n * while (i.hasNext()) a.push(i.next());\\n*/\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for binary tree\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * @constructor\\n * @param {TreeNode} root - root of the binary search tree\\n */\\nvar BSTIterator = function(root) {\\n    this.array = []\\n    dfs(root, this.array)\\n    \\n    function dfs(root, array) {\\n        if(!root) {\\n            return\\n        }\\n        dfs(root.left, array)\\n        array.push(root.val)\\n        dfs(root.right, array)\\n    }\\n};\\n\\n\\n/**\\n * @this BSTIterator\\n * @returns {boolean} - whether we have a next smallest number\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.array.length > 0\\n};\\n\\n/**\\n * @this BSTIterator\\n * @returns {number} - the next smallest number\\n */\\nBSTIterator.prototype.next = function() {\\n    if(this.hasNext()){\\n        return this.array.shift()\\n    }\\n};\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * var i = new BSTIterator(root), a = [];\\n * while (i.hasNext()) a.push(i.next());\\n*/\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52690,
                "title": "python-tiny-o-1-time-o-h-space-solution-amortized",
                "content": "    # Definition for a  binary tree node\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class BSTIterator(object):\\n        def __init__(self, root):\\n            self._branch = []\\n            self._findLeftmost(root)\\n        \\n        def _findLeftmost(self, node):\\n            branch = self._branch\\n            while node is not None:\\n                branch.append(node)\\n                node = node.left\\n    \\n        def hasNext(self):\\n            return bool(self._branch)\\n    \\n        def next(self):\\n            node = self._branch.pop()\\n            self._findLeftmost(node.right)\\n            return node.val",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for a  binary tree node\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class BSTIterator(object):\\n        def __init__(self, root):\\n            self._branch = []\\n            self._findLeftmost(root)\\n        \\n        def _findLeftmost(self, node):\\n            branch = self._branch\\n            while node is not None:\\n                branch.append(node)\\n                node = node.left\\n    \\n        def hasNext(self):\\n            return bool(self._branch)\\n    \\n        def next(self):\\n            node = self._branch.pop()\\n            self._findLeftmost(node.right)\\n            return node.val",
                "codeTag": "Java"
            },
            {
                "id": 52708,
                "title": "elegant-java-solution-using-a-stack",
                "content": "    public class BSTIterator {\\n    private Stack<TreeNode> stack = null; \\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<>();\\n        \\n        TreeNode curr = root;\\n        while(curr!=null){\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        \\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        \\n        if(hasNext()){\\n            int ret = stack.peek().val;\\n            TreeNode curr = stack.pop();\\n            if(curr.right!=null){\\n                curr = curr.right;\\n                \\n                while(curr!=null){\\n                    stack.push(curr);\\n                    curr = curr.left;\\n                }\\n            }\\n            return ret;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "    public class BSTIterator {\\n    private Stack<TreeNode> stack = null; \\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<>();\\n        \\n        TreeNode curr = root;\\n        while(curr!=null){\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        \\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        \\n        if(hasNext()){\\n            int ret = stack.peek().val;\\n            TreeNode curr = stack.pop();\\n            if(curr.right!=null){\\n                curr = curr.right;\\n                \\n                while(curr!=null){\\n                    stack.push(curr);\\n                    curr = curr.left;\\n                }\\n            }\\n            return ret;\\n        }\\n        return -1;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2945274,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n     stack<TreeNode*> st;\\n    BSTIterator(TreeNode* root) {\\n        while(root) {\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode* t1 = st.top();\\n        st.pop();\\n        TreeNode* t = t1->right;\\n        while(t)\\n        {\\n            st.push(t);\\n            t = t->left;\\n        }\\n        return t1->val;\\n    }\\n    \\n    bool hasNext() {\\n        if(st.empty())\\n        return false;\\n        return true;\\n        \\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n     stack<TreeNode*> st;\\n    BSTIterator(TreeNode* root) {\\n        while(root) {\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode* t1 = st.top();\\n        st.pop();\\n        TreeNode* t = t1->right;\\n        while(t)\\n        {\\n            st.push(t);\\n            t = t->left;\\n        }\\n        return t1->val;\\n    }\\n    \\n    bool hasNext() {\\n        if(st.empty())\\n        return false;\\n        return true;\\n        \\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967410,
                "title": "binary-search-tree-iterator",
                "content": "Easy C++ Solution ----->\\n  **inOrder Traversal**\\n  \\n  \\n  ```\\n  \\n   \\n       vector<int>v;\\n       void inOrder(TreeNode*  root){\\n           if(root==NULL) return;\\n             inOrder(root->left);\\n            int x;\\n         x = root->val;\\n        v.push_back(x);\\n            \\n        inOrder(root->right);\\n           \\n       }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inOrder(root);  \\n       \\n    }\\n    \\n    int next() {\\n         \\n        int temp =  v[0];\\n         v.erase(v.begin());\\n        \\n        return temp;\\n        \\n    }\\n    \\n    bool hasNext() {\\n        if(v.size()>0) return true;\\n        \\n        else return false;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n  \\n   \\n       vector<int>v;\\n       void inOrder(TreeNode*  root){\\n           if(root==NULL) return;\\n             inOrder(root->left);\\n            int x;\\n         x = root->val;\\n        v.push_back(x);\\n            \\n        inOrder(root->right);\\n           \\n       }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inOrder(root);  \\n       \\n    }\\n    \\n    int next() {\\n         \\n        int temp =  v[0];\\n         v.erase(v.begin());\\n        \\n        return temp;\\n        \\n    }\\n    \\n    bool hasNext() {\\n        if(v.size()>0) return true;\\n        \\n        else return false;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966539,
                "title": "c-35ms-o-n-time-o-h-space-for-recursion",
                "content": "Run an `inorder` traversal to the tree and make connect them like a single linked-list. Now return answer however we want!\\n\\n```\\nclass BSTIterator {\\npublic:\\n    \\n    TreeNode* inorder(TreeNode *cur, TreeNode *pre) {\\n        if (cur == nullptr) return pre;\\n        TreeNode *now = inorder(cur->left, pre);\\n        now->right = cur;\\n\\t\\tnow->left = nullptr;\\n        return inorder(cur->right, now->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root, node);\\n    }\\n    \\n    int next() {\\n        node = node->right;\\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n        return node->right != nullptr;\\n    }\\nprivate:\\n    TreeNode *node = new TreeNode(0);\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Depth-First Search"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    \\n    TreeNode* inorder(TreeNode *cur, TreeNode *pre) {\\n        if (cur == nullptr) return pre;\\n        TreeNode *now = inorder(cur->left, pre);\\n        now->right = cur;\\n\\t\\tnow->left = nullptr;\\n        return inorder(cur->right, now->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root, node);\\n    }\\n    \\n    int next() {\\n        node = node->right;\\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n        return node->right != nullptr;\\n    }\\nprivate:\\n    TreeNode *node = new TreeNode(0);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924032,
                "title": "java-simple",
                "content": "```\\nclass BSTIterator {\\n    ArrayList<Integer> list=new ArrayList<>();\\n    int i=0;\\n    public BSTIterator(TreeNode root) {\\n        inorder(root);\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n    \\n    public int next() {\\n        return list.get(i++);\\n    }\\n    \\n    public boolean hasNext() {\\n        if(i<list.size())\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BSTIterator {\\n    ArrayList<Integer> list=new ArrayList<>();\\n    int i=0;\\n    public BSTIterator(TreeNode root) {\\n        inorder(root);\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n    \\n    public int next() {\\n        return list.get(i++);\\n    }\\n    \\n    public boolean hasNext() {\\n        if(i<list.size())\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515644,
                "title": "python-simple-beats-99-both-approach",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\ndef __init__(self, root: TreeNode):\\n        self.btree = []\\n        self.index = -1\\n        self.inorder(root)\\n    \\n    def inorder(self, node):\\n        if not node:\\n            return\\n        self.inorder(node.left)\\n        self.btree.append(node.val)\\n        self.inorder(node.right)\\n        \\n    def next(self) -> int:\\n        self.index+=1\\n        return self.btree[self.index]\\n    \\n\\n    def hasNext(self) -> bool:\\n        if self.index +1 < len(self.btree):\\n            return True\\n        return False\\n\\n# Approach 2\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.inorder(root)\\n    \\n    def inorder(self, node):\\n        while(node):\\n            self.stack.append(node)\\n            node = node.left\\n        \\n    def next(self) -> int:\\n        smallest = self.stack.pop()\\n        if smallest.right:\\n            self.inorder(smallest.right)\\n        return smallest.val\\n        \\n    def hasNext(self) -> bool:\\n        \\n        return len(self.stack) > 0\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\\nApproach 2\\nRuntime: 60 ms, faster than 99.69% of Python3 online submissions for Binary Search Tree Iterator.\\nMemory Usage: 20.4 MB, less than 72.63% of Python3 online submissions for Binary Search Tree Iterator.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\ndef __init__(self, root: TreeNode):\\n        self.btree = []\\n        self.index = -1\\n        self.inorder(root)\\n    \\n    def inorder(self, node):\\n        if not node:\\n            return\\n        self.inorder(node.left)\\n        self.btree.append(node.val)\\n        self.inorder(node.right)\\n        \\n    def next(self) -> int:\\n        self.index+=1\\n        return self.btree[self.index]\\n    \\n\\n    def hasNext(self) -> bool:\\n        if self.index +1 < len(self.btree):\\n            return True\\n        return False\\n\\n# Approach 2\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.inorder(root)\\n    \\n    def inorder(self, node):\\n        while(node):\\n            self.stack.append(node)\\n            node = node.left\\n        \\n    def next(self) -> int:\\n        smallest = self.stack.pop()\\n        if smallest.right:\\n            self.inorder(smallest.right)\\n        return smallest.val\\n        \\n    def hasNext(self) -> bool:\\n        \\n        return len(self.stack) > 0\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296969,
                "title": "simple-c-solution-complexity-requirements-satisfied",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\nclass BSTIterator {\\n    stack<TreeNode*> s;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        push_left_nodes(root);\\n    }\\n    void push_left_nodes(TreeNode* node)\\n    {\\n        while(node)\\n        {\\n            s.push(node);\\n            node = node->left;\\n        }\\n    }\\n    // TC - average O(1) SC - O(h)\\n    int next() {\\n        TreeNode* left = s.top();\\n        s.pop();\\n        push_left_nodes(left->right);\\n        return left->val;\\n    }\\n    // TC - O(1)\\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator {\\n    stack<TreeNode*> s;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        push_left_nodes(root);\\n    }\\n    void push_left_nodes(TreeNode* node)\\n    {\\n        while(node)\\n        {\\n            s.push(node);\\n            node = node->left;\\n        }\\n    }\\n    // TC - average O(1) SC - O(h)\\n    int next() {\\n        TreeNode* left = s.top();\\n        s.pop();\\n        push_left_nodes(left->right);\\n        return left->val;\\n    }\\n    // TC - O(1)\\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967024,
                "title": "c-iteration-simple-solution-using-stack",
                "content": "```\\nclass BSTIterator {\\n    stack<TreeNode *> s;\\n    \\n    void leftmost_node(TreeNode* root){\\n        while(root){\\n            s.push(root);\\n            root=root->left;\\n        }\\n    }\\npublic:\\n    \\n    BSTIterator(TreeNode* root) {\\n        //s.clear();\\n        leftmost_node(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* top=s.top();\\n        s.pop();\\n        if(top->right)\\n            leftmost_node(top->right);        \\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return s.size()>0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator {\\n    stack<TreeNode *> s;\\n    \\n    void leftmost_node(TreeNode* root){\\n        while(root){\\n            s.push(root);\\n            root=root->left;\\n        }\\n    }\\npublic:\\n    \\n    BSTIterator(TreeNode* root) {\\n        //s.clear();\\n        leftmost_node(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* top=s.top();\\n        s.pop();\\n        if(top->right)\\n            leftmost_node(top->right);        \\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return s.size()>0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966100,
                "title": "php-javascript-swift-stacks-faster-100-o-1-time-o-h-space-explained",
                "content": "I use `parents` array to save stack of active nodes.\\n`Init()` set a smallest element as active (left, left, left,... element).\\nOn call `next()` i get last element from `parents`, delete it, return `val` of it, and change active stack to next element of tree. If deleted element has right childrens, it\\'s new active next elements. Else we do nothing,  because we turn to parent elements in `parents` array yet.\\n`hasNext()` show has stack for new next element or not - it\\'s `parents` length.\\n\\nAnd code..\\n\\n**PHP:**\\n```\\nclass BSTIterator\\n{\\n    private $parents = [];\\n\\n    function __construct($root)\\n    {\\n        while ($root) {\\n            $this->parents[] = $root;\\n            $root = $root->left;\\n        }\\n    }\\n\\n    function next()\\n    {\\n        $cur = array_pop($this->parents);\\n        $val = $cur->val;\\n        if ($cur->right) {\\n            $cur = $cur->right;\\n            while ($cur) {\\n                $this->parents[] = $cur;\\n                $cur = $cur->left;\\n            }\\n        }\\n        return $val;\\n    }\\n\\n    function hasNext()\\n    {\\n        return count($this->parents) > 0;\\n    }\\n}\\n```\\n**JavaScript:**\\n```\\nvar BSTIterator = function (root) {\\n    this.parents = []\\n\\n    while (root) {\\n        this.parents.push(root)\\n        root = root.left\\n    }\\n};\\n\\nBSTIterator.prototype.next = function () {\\n    let cur = this.parents.pop()\\n    const val = cur.val\\n    if (cur.right) {\\n        cur = cur.right\\n        while (cur) {\\n            this.parents.push(cur)\\n            cur = cur.left\\n        }\\n    }\\n    return val\\n};\\n\\nBSTIterator.prototype.hasNext = function () {\\n    return this.parents.length > 0\\n};\\n```\\n**Swift:**\\n```\\nclass BSTIterator {\\n     var parents: [TreeNode?] = []\\n\\n     init(_ root: TreeNode?) {\\n         var root = root\\n\\n         while root != nil {\\n             self.parents.append(root)\\n             root = root?.left\\n         }\\n     }\\n\\n     func next() -> Int {\\n         var cur = self.parents.removeLast()\\n         let val = cur!.val\\n         if (cur?.right != nil) {\\n             cur = cur!.right\\n             while cur != nil {\\n                 self.parents.append(cur)\\n                 cur = cur?.left\\n             }\\n         }\\n         return val\\n     }\\n\\n     func hasNext() -> Bool {\\n         return !self.parents.isEmpty\\n     }\\n }\\n```\\n\\n**Thanks and upvote!**",
                "solutionTags": [
                    "JavaScript",
                    "Swift",
                    "PHP"
                ],
                "code": "```\\nclass BSTIterator\\n{\\n    private $parents = [];\\n\\n    function __construct($root)\\n    {\\n        while ($root) {\\n            $this->parents[] = $root;\\n            $root = $root->left;\\n        }\\n    }\\n\\n    function next()\\n    {\\n        $cur = array_pop($this->parents);\\n        $val = $cur->val;\\n        if ($cur->right) {\\n            $cur = $cur->right;\\n            while ($cur) {\\n                $this->parents[] = $cur;\\n                $cur = $cur->left;\\n            }\\n        }\\n        return $val;\\n    }\\n\\n    function hasNext()\\n    {\\n        return count($this->parents) > 0;\\n    }\\n}\\n```\n```\\nvar BSTIterator = function (root) {\\n    this.parents = []\\n\\n    while (root) {\\n        this.parents.push(root)\\n        root = root.left\\n    }\\n};\\n\\nBSTIterator.prototype.next = function () {\\n    let cur = this.parents.pop()\\n    const val = cur.val\\n    if (cur.right) {\\n        cur = cur.right\\n        while (cur) {\\n            this.parents.push(cur)\\n            cur = cur.left\\n        }\\n    }\\n    return val\\n};\\n\\nBSTIterator.prototype.hasNext = function () {\\n    return this.parents.length > 0\\n};\\n```\n```\\nclass BSTIterator {\\n     var parents: [TreeNode?] = []\\n\\n     init(_ root: TreeNode?) {\\n         var root = root\\n\\n         while root != nil {\\n             self.parents.append(root)\\n             root = root?.left\\n         }\\n     }\\n\\n     func next() -> Int {\\n         var cur = self.parents.removeLast()\\n         let val = cur!.val\\n         if (cur?.right != nil) {\\n             cur = cur!.right\\n             while cur != nil {\\n                 self.parents.append(cur)\\n                 cur = cur?.left\\n             }\\n         }\\n         return val\\n     }\\n\\n     func hasNext() -> Bool {\\n         return !self.parents.isEmpty\\n     }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965879,
                "title": "c-36-ms-99-8-with-stack",
                "content": "```\\nclass BSTIterator {\\nprivate:\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode *root) {\\n        move_left(root);\\n    }\\n\\n    bool hasNext() {\\n        if (st.empty()) return false;\\n        return true;\\n    }\\n\\n    int next() {\\n        TreeNode* tmp = st.top();\\n        st.pop();\\n        if (tmp->right) move_left(tmp->right);\\n        return tmp->val;\\n    }\\n    \\n    void move_left(TreeNode* node)\\n    {\\n        TreeNode* tmp = node;\\n        while (tmp) {st.push(tmp);tmp = tmp->left;}\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass BSTIterator {\\nprivate:\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode *root) {\\n        move_left(root);\\n    }\\n\\n    bool hasNext() {\\n        if (st.empty()) return false;\\n        return true;\\n    }\\n\\n    int next() {\\n        TreeNode* tmp = st.top();\\n        st.pop();\\n        if (tmp->right) move_left(tmp->right);\\n        return tmp->val;\\n    }\\n    \\n    void move_left(TreeNode* node)\\n    {\\n        TreeNode* tmp = node;\\n        while (tmp) {st.push(tmp);tmp = tmp->left;}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965539,
                "title": "c-99-100-memory-10-liner-crispy-af",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    vector<int> v;\\n    int i;\\n    \\n    BSTIterator(TreeNode* root) {\\n        v.clear();\\n        \\n        inorder(root);\\n        \\n        i = 0;\\n    }\\n    \\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    int next() {\\n        return v[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i < v.size();\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```\\n\\nExplanation -\\n\\n1. Inorder traverse tree and add to vector\\n2. Use vector to get next value\\n3. ???\\n4. Profit! \\uD83E\\uDD19\\n\\nAs always,\\n\\uD83E\\uDD19 Stay crispy guys \\uD83E\\uDD19",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    vector<int> v;\\n    int i;\\n    \\n    BSTIterator(TreeNode* root) {\\n        v.clear();\\n        \\n        inorder(root);\\n        \\n        i = 0;\\n    }\\n    \\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    int next() {\\n        return v[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i < v.size();\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401657,
                "title": "simple-javascript-solution",
                "content": "Runtime: 140 ms, faster than 75.80% of JavaScript online submissions for Binary Search Tree Iterator.\\nMemory Usage: 48.3 MB, less than 100.00% of JavaScript online submissions for Binary Search Tree Iterator.\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n */\\nvar BSTIterator = function(root) {\\n    this.cache = []\\n    const traverse = (node) => {\\n        if (node) {\\n            if (node.left) traverse(node.left)\\n            this.cache.push(node.val)\\n            if (node.right) traverse(node.right)\\n        }\\n    }\\n    traverse(root)\\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    return this.cache.shift()\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.cache.length > 0\\n};\\n\\n/** \\n * Your BSTIterator object will be instantiated and called as such:\\n * var obj = new BSTIterator(root)\\n * var param_1 = obj.next()\\n * var param_2 = obj.hasNext()\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n */\\nvar BSTIterator = function(root) {\\n    this.cache = []\\n    const traverse = (node) => {\\n        if (node) {\\n            if (node.left) traverse(node.left)\\n            this.cache.push(node.val)\\n            if (node.right) traverse(node.right)\\n        }\\n    }\\n    traverse(root)\\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    return this.cache.shift()\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.cache.length > 0\\n};\\n\\n/** \\n * Your BSTIterator object will be instantiated and called as such:\\n * var obj = new BSTIterator(root)\\n * var param_1 = obj.next()\\n * var param_2 = obj.hasNext()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52644,
                "title": "java-with-morris-method-4ms-99-without-stack",
                "content": "Morris method is general used to travel Binary tree, and BST Iterator is just like travel tree.\\n    \\n    /** Morris */\\n    public class BSTIterator {\\n        private TreeNode read = null;\\n        public BSTIterator(TreeNode root) {\\n        read = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return read != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        int x = 0;\\n        while ( read != null ){\\n            if ( read.left == null ){\\n                x = read.val;\\n                read = read.right;\\n                break;\\n            }else{\\n                TreeNode tempNode = read.left;\\n                // Find most 'right' child in left subtree\\n                while ( tempNode.right != null && tempNode.right != read ){\\n                    tempNode = tempNode.right;\\n                }\\n                if ( tempNode.right == null ){\\n                    tempNode.right = read;\\n                    read = read.left;\\n                }else{\\n                    x = tempNode.right.val;\\n                    tempNode.right = null;\\n                    read = read.right;\\n                    break;\\n                }\\n            }\\n        }// end_while\\n        return x;\\n    }// end_method\\n}// end_class",
                "solutionTags": [],
                "code": "Morris method is general used to travel Binary tree, and BST Iterator is just like travel tree.\\n    \\n    /** Morris */\\n    public class BSTIterator {\\n        private TreeNode read = null;\\n        public BSTIterator(TreeNode root) {\\n        read = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return read != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        int x = 0;\\n        while ( read != null ){\\n            if ( read.left == null ){\\n                x = read.val;\\n                read = read.right;\\n                break;\\n            }else{\\n                TreeNode tempNode = read.left;\\n                // Find most 'right' child in left subtree\\n                while ( tempNode.right != null && tempNode.right != read ){\\n                    tempNode = tempNode.right;\\n                }\\n                if ( tempNode.right == null ){\\n                    tempNode.right = read;\\n                    read = read.left;\\n                }else{\\n                    x = tempNode.right.val;\\n                    tempNode.right = null;\\n                    read = read.right;\\n                    break;\\n                }\\n            }\\n        }// end_while\\n        return x;\\n    }// end_method\\n}// end_class",
                "codeTag": "Java"
            },
            {
                "id": 52673,
                "title": "c-morris-traverse-solution-o-1-space-easy-understanding",
                "content": "\\n\\n    BSTIterator(TreeNode *root) {\\n        cur = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return cur != nullptr;\\n    }\\n\\n    /** @return the next smallest number */\\n    int next() {\\n        int val = 0;\\n        while (cur) {\\n            if (!cur->left) {\\n                val = cur->val;\\n                cur = cur->right;\\n                return val;\\n            } else {\\n                TreeNode *right_m = cur->left;\\n                while(right_m->right && right_m->right != cur) right_m = right_m->right;\\n                if (!right_m->right) {\\n                    right_m->right = cur;\\n                    cur = cur->left;\\n                } else {\\n                    right_m->right = nullptr;\\n                    val = cur->val;\\n                    cur = cur->right;\\n                    return val;\\n                }\\n            }\\n        }\\n    }\\n    private:\\n    TreeNode *cur;",
                "solutionTags": [],
                "code": "\\n\\n    BSTIterator(TreeNode *root) {\\n        cur = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return cur != nullptr;\\n    }\\n\\n    /** @return the next smallest number */\\n    int next() {\\n        int val = 0;\\n        while (cur) {\\n            if (!cur->left) {\\n                val = cur->val;\\n                cur = cur->right;\\n                return val;\\n            } else {\\n                TreeNode *right_m = cur->left;\\n                while(right_m->right && right_m->right != cur) right_m = right_m->right;\\n                if (!right_m->right) {\\n                    right_m->right = cur;\\n                    cur = cur->left;\\n                } else {\\n                    right_m->right = nullptr;\\n                    val = cur->val;\\n                    cur = cur->right;\\n                    return val;\\n                }\\n            }\\n        }\\n    }\\n    private:\\n    TreeNode *cur;",
                "codeTag": "Unknown"
            },
            {
                "id": 52746,
                "title": "28-ms-c-solution-with-stack",
                "content": "    class BSTIterator {\\n        stack<TreeNode*> s;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            while(root) {\\n                s.push(root);\\n                root =  root->left;\\n            }\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !s.empty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* n = s.top();\\n            s.pop();\\n            TreeNode* r = n->right;\\n            while(r) {\\n                s.push(r);\\n                r = r->left;\\n            }\\n            return n->val;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree"
                ],
                "code": "    class BSTIterator {\\n        stack<TreeNode*> s;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            while(root) {\\n                s.push(root);\\n                root =  root->left;\\n            }\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !s.empty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* n = s.top();\\n            s.pop();\\n            TreeNode* r = n->right;\\n            while(r) {\\n                s.push(r);\\n                r = r->left;\\n            }\\n            return n->val;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 4008782,
                "title": "2-simple-c-solutions-beats-99-7-well-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/eb4fc870-7fb0-460e-8b50-12a2c9c057d3_1693985216.5149693.png)\\n\\n\\n# Approach - 1: Using vector\\n\\n**Logic/Intuition:**\\n\\n- This implementation uses an array to store all the elements of the BST in sorted order upfront. The iterator then simply moves through the array.\\n\\n\\n**Time Complexity:**\\n- The constructor (`BSTIterator`) runs in $$O(n)$$ time, where n is the number of nodes in the BST. It performs a complete in-order traversal to populate the `arr` vector.\\n- The `next()` and `hasNext()` functions each run in $$O(1)$$ time because retrieving an element from an array and checking if the index is within bounds are constant-time operations.\\n\\n**Space Complexity:**\\n- The space complexity of this implementation is $$O(n)$$, where n is the number of nodes in the BST. This space is used to store all elements of the BST in the `arr` vector.\\n\\n# Code\\n```\\nclass BSTIterator {\\npublic:\\n    vector<int> arr = {-1}; //dummy element to take care of indexing\\n    int idx;\\n\\n    void dfs (TreeNode* root) { \\n//simple inorder traversal & storing the elements in the array\\n        if (!root) return;\\n        dfs(root->left);\\n        arr.push_back(root->val);\\n        dfs(root->right);\\n    }\\n\\n    BSTIterator(TreeNode* root) {\\n        dfs (root);\\n        idx = 0;\\n    }\\n    \\n    int next() {\\n        if (hasNext()) {\\n            idx++;\\n            return arr[idx];\\n        }\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        return (idx+1 < arr.size());\\n    }\\n};\\n```\\n\\n# Approach - 2: Using stack (Optimal)\\n**Logic/Intuition:**\\n- The key idea is to use a stack to keep track of the nodes to be visited and their respective positions in the in-order traversal.\\n\\n**Time Complexity:**\\n- The `next()` and `hasNext()` functions each run in $$O(1)$$ time on average because popping from the stack and checking if it\\'s empty are constant-time operations. Even in the worst case, when the BST is skewed, the amortised time complexity of `next()` turns out to be $$O(1)$$.\\n- **This is because each element is being pushed or popped from the stack once at max in the overall run.**\\n\\n**Space Complexity:**\\n- The space complexity of the stack used by the `BSTIterator` class is $$O(h)$$, where h is the height of the BST. In the worst case, when the BST is skewed and the height is equal to the number of nodes (n), the space complexity becomes $$O(n)$$.\\n\\n\\n# Code\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    void helper (TreeNode* root) {\\n// helper func - push all elements to the left of the node (including the node) into the stack\\n        while (root) {\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n\\n    BSTIterator(TreeNode* root) {\\n        helper(root); //to initialise the stack\\n    }\\n    \\n    int next() {\\n        if (st.empty()) return -1;\\n        TreeNode* node = st.top();\\n        st.pop();\\n        helper(node->right);\\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```\\n\\nPlease upvote if you found this solution post helpful.",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Design",
                    "Binary Search Tree",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    vector<int> arr = {-1}; //dummy element to take care of indexing\\n    int idx;\\n\\n    void dfs (TreeNode* root) { \\n//simple inorder traversal & storing the elements in the array\\n        if (!root) return;\\n        dfs(root->left);\\n        arr.push_back(root->val);\\n        dfs(root->right);\\n    }\\n\\n    BSTIterator(TreeNode* root) {\\n        dfs (root);\\n        idx = 0;\\n    }\\n    \\n    int next() {\\n        if (hasNext()) {\\n            idx++;\\n            return arr[idx];\\n        }\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        return (idx+1 < arr.size());\\n    }\\n};\\n```\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    void helper (TreeNode* root) {\\n// helper func - push all elements to the left of the node (including the node) into the stack\\n        while (root) {\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n\\n    BSTIterator(TreeNode* root) {\\n        helper(root); //to initialise the stack\\n    }\\n    \\n    int next() {\\n        if (st.empty()) return -1;\\n        TreeNode* node = st.top();\\n        st.pop();\\n        helper(node->right);\\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615589,
                "title": "python-94-82-faster-easy-iterative-solution",
                "content": "```\\nclass BSTIterator:\\n    st=[]\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.pushall(root)\\n\\n    def next(self) -> int:\\n        temp=self.st.pop()\\n        self.pushall(temp.right)\\n        return temp.val\\n\\n    def hasNext(self) -> bool:\\n        return True if len(self.st)>0 else False\\n\\n    def pushall(self,root):\\n        while root:\\n            self.st.append(root)\\n            root=root.left\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator:\\n    st=[]\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.pushall(root)\\n\\n    def next(self) -> int:\\n        temp=self.st.pop()\\n        self.pushall(temp.right)\\n        return temp.val\\n\\n    def hasNext(self) -> bool:\\n        return True if len(self.st)>0 else False\\n\\n    def pushall(self,root):\\n        while root:\\n            self.st.append(root)\\n            root=root.left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524919,
                "title": "very-easy-java-solution-using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    List<Integer> list=new ArrayList();\\n    int index=0;\\n\\n    public BSTIterator(TreeNode root) {\\n        inorder(root);\\n    }\\n    void inorder(TreeNode root)\\n    {\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n    \\n    public int next() {\\n        return list.get(index++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return index<list.size();\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    List<Integer> list=new ArrayList();\\n    int index=0;\\n\\n    public BSTIterator(TreeNode root) {\\n        inorder(root);\\n    }\\n    void inorder(TreeNode root)\\n    {\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n    \\n    public int next() {\\n        return list.get(index++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return index<list.size();\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012525,
                "title": "easy-c-code-with-sc-tc",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the concept of inorder traversal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) \\nSince we push every element only once. There might be N calls and we are pushing N nodes.\\nSo, avg TC is O(1).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(H) where H is the height of tree.\\n\\n# Code\\n```\\n\\nclass BSTIterator {\\npublic:\\nstack<TreeNode*>s;\\n    BSTIterator(TreeNode* root) {\\n        pushing(root);\\n    }\\n    void pushing(TreeNode *root){\\n        s.push(root);\\n        while(root->left) {root=root->left;s.push(root);}\\n    }\\n    int next() {\\n        TreeNode *temp=s.top();s.pop();\\n        if(temp->right){\\n            pushing(temp->right);\\n        }\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass BSTIterator {\\npublic:\\nstack<TreeNode*>s;\\n    BSTIterator(TreeNode* root) {\\n        pushing(root);\\n    }\\n    void pushing(TreeNode *root){\\n        s.push(root);\\n        while(root->left) {root=root->left;s.push(root);}\\n    }\\n    int next() {\\n        TreeNode *temp=s.top();s.pop();\\n        if(temp->right){\\n            pushing(temp->right);\\n        }\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672648,
                "title": "simple-solution-with-o-n-memory-and-o-1-time",
                "content": "```\\nclass BSTIterator {\\npublic:\\n    int a[100001] = {0};\\n    int count = 0;\\n    int n = 0;\\n    void traversal(TreeNode *root) {\\n        if(!root) return;\\n        traversal(root->left);\\n        a[count++] = root->val;\\n        traversal(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        traversal(root);\\n    }\\n    \\n    int next() {\\n        if(n < count) return a[n++];\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(n < count) return true;\\n        return false;\\n    }\\n};\\n```\\n\\nPlz upvote if you like!!",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    int a[100001] = {0};\\n    int count = 0;\\n    int n = 0;\\n    void traversal(TreeNode *root) {\\n        if(!root) return;\\n        traversal(root->left);\\n        a[count++] = root->val;\\n        traversal(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        traversal(root);\\n    }\\n    \\n    int next() {\\n        if(n < count) return a[n++];\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(n < count) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967502,
                "title": "c-using-stack-o-h-solution",
                "content": "```\\nclass BSTIterator \\n{\\npublic:\\n    stack<TreeNode*> st;\\n    BSTIterator(TreeNode* root) \\n    {\\n        leftTree(root);\\n    }\\n    \\n    int next() \\n    {\\n        TreeNode* top = st.top();\\n        st.pop();\\n        \\n        if(top->right!=NULL)\\n        {\\n            leftTree(top->right);\\n        }\\n        return top->val;\\n    }\\n    \\n    bool hasNext() \\n    {\\n        return st.empty() ? false:true;\\n    }\\n    \\n    void leftTree(TreeNode* root)\\n    {\\n        TreeNode* node = root;\\n        \\n        while(node)\\n        {\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator \\n{\\npublic:\\n    stack<TreeNode*> st;\\n    BSTIterator(TreeNode* root) \\n    {\\n        leftTree(root);\\n    }\\n    \\n    int next() \\n    {\\n        TreeNode* top = st.top();\\n        st.pop();\\n        \\n        if(top->right!=NULL)\\n        {\\n            leftTree(top->right);\\n        }\\n        return top->val;\\n    }\\n    \\n    bool hasNext() \\n    {\\n        return st.empty() ? false:true;\\n    }\\n    \\n    void leftTree(TreeNode* root)\\n    {\\n        TreeNode* node = root;\\n        \\n        while(node)\\n        {\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965728,
                "title": "c-2-solutions-with-w-o-stack-inorder-easy-clean-code",
                "content": "**1. Using Stack ( Iterative )**\\nTime - O(n) (approx.)\\nSpace - O(h)\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n    \\n    BSTIterator(TreeNode* root) {\\n        st.push(root);\\n        \\n        while(root->left)\\n        {\\n            st.push(root->left);\\n            root=root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode *root=st.top();\\n        st.pop();\\n        \\n        int ans=root->val;\\n        \\n        if(root->right)\\n        {\\n            root=root->right;\\n            st.push(root);\\n            while(root->left)\\n            {\\n                st.push(root->left);\\n                root=root->left;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```\\n\\n**2. Without extra space / Converting tree ( Recursive )**\\nTime - O(n)\\nSpace - O(1)\\n```\\nclass BSTIterator {\\npublic:\\n    TreeNode *head,*t; \\n    \\n    void convert(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        convert(root->left);\\n        \\n        t->right=root;\\n        t=t->right;\\n        \\n        convert(root->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        \\n        head=new TreeNode(0);\\n        t=head;\\n        convert(root);\\n    }\\n    \\n    int next() {\\n        head=head->right;\\n        return head->val;\\n    }\\n    \\n    bool hasNext() {\\n        return (head->right!=NULL);\\n    }\\n};\\n```\\n\\n**Do share your views & upvote if you like !!!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n    \\n    BSTIterator(TreeNode* root) {\\n        st.push(root);\\n        \\n        while(root->left)\\n        {\\n            st.push(root->left);\\n            root=root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode *root=st.top();\\n        st.pop();\\n        \\n        int ans=root->val;\\n        \\n        if(root->right)\\n        {\\n            root=root->right;\\n            st.push(root);\\n            while(root->left)\\n            {\\n                st.push(root->left);\\n                root=root->left;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```\n```\\nclass BSTIterator {\\npublic:\\n    TreeNode *head,*t; \\n    \\n    void convert(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        convert(root->left);\\n        \\n        t->right=root;\\n        t=t->right;\\n        \\n        convert(root->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        \\n        head=new TreeNode(0);\\n        t=head;\\n        convert(root);\\n    }\\n    \\n    int next() {\\n        head=head->right;\\n        return head->val;\\n    }\\n    \\n    bool hasNext() {\\n        return (head->right!=NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265415,
                "title": "my-solution-in-avg-o-1-time-and-o-1-space-using-inorder-morris-traversal",
                "content": "```\\npublic static class BSTIterator {\\n        TreeNode curr = null;\\n\\n        public BSTIterator(TreeNode root) {\\n            this.curr = root;\\n        }\\n\\n        // rmn : right most node\\n        private TreeNode getRightMostNode(TreeNode rmn) {\\n            while (rmn.right != null && rmn.right != this.curr)\\n                rmn = rmn.right;\\n            return rmn;\\n        }\\n\\n        private TreeNode morrisTraversal() {\\n            TreeNode res = null;\\n\\n            while (this.curr != null) {\\n                TreeNode leftNode = this.curr.left;\\n                if (leftNode == null) {\\n                    res = this.curr;\\n                    this.curr = this.curr.right;\\n                    break;\\n                } else {\\n                    TreeNode rightMostNode = getRightMostNode(leftNode);\\n                    if (rightMostNode.right == null) {\\n                        rightMostNode.right = this.curr;// thread creation\\n                        this.curr = this.curr.left;\\n                    } else {\\n                        res = this.curr;\\n                        rightMostNode.right = null; // thread cut down\\n                        this.curr = this.curr.right;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return res;\\n        }\\n\\n        public int next() {\\n            TreeNode res = morrisTraversal();\\n            return res.val;\\n        }\\n\\n        public boolean hasNext() {\\n            return this.curr != null;\\n\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "```\\npublic static class BSTIterator {\\n        TreeNode curr = null;\\n\\n        public BSTIterator(TreeNode root) {\\n            this.curr = root;\\n        }\\n\\n        // rmn : right most node\\n        private TreeNode getRightMostNode(TreeNode rmn) {\\n            while (rmn.right != null && rmn.right != this.curr)\\n                rmn = rmn.right;\\n            return rmn;\\n        }\\n\\n        private TreeNode morrisTraversal() {\\n            TreeNode res = null;\\n\\n            while (this.curr != null) {\\n                TreeNode leftNode = this.curr.left;\\n                if (leftNode == null) {\\n                    res = this.curr;\\n                    this.curr = this.curr.right;\\n                    break;\\n                } else {\\n                    TreeNode rightMostNode = getRightMostNode(leftNode);\\n                    if (rightMostNode.right == null) {\\n                        rightMostNode.right = this.curr;// thread creation\\n                        this.curr = this.curr.left;\\n                    } else {\\n                        res = this.curr;\\n                        rightMostNode.right = null; // thread cut down\\n                        this.curr = this.curr.right;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return res;\\n        }\\n\\n        public int next() {\\n            TreeNode res = morrisTraversal();\\n            return res.val;\\n        }\\n\\n        public boolean hasNext() {\\n            return this.curr != null;\\n\\n        }\\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 1178663,
                "title": "c-easy-solution-using-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\n    // stack to maintain next smallest value\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        in(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* curr=st.top();\\n        st.pop();\\n        // push the outer left arm of right subtree\\n        //  as next smallest element will now be the \\n        // left most element of right subtree\\n        in(curr->right);\\n        return curr->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    \\n    // to push outer left arm of root\\n    // like in iterative inorder traversal\\n    void in(TreeNode* root)\\n    {\\n        TreeNode* curr=root;\\n        while(curr)\\n        {\\n            st.push(curr);\\n            curr=curr->left;\\n        }\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\n    // stack to maintain next smallest value\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        in(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* curr=st.top();\\n        st.pop();\\n        // push the outer left arm of right subtree\\n        //  as next smallest element will now be the \\n        // left most element of right subtree\\n        in(curr->right);\\n        return curr->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    \\n    // to push outer left arm of root\\n    // like in iterative inorder traversal\\n    void in(TreeNode* root)\\n    {\\n        TreeNode* curr=root;\\n        while(curr)\\n        {\\n            st.push(curr);\\n            curr=curr->left;\\n        }\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 966361,
                "title": "javascript-generator",
                "content": "```\\nvar BSTIterator = function(root) {\\n    function* generator( xxxx ) {\\n        function* recur(node ) {\\n            if ( ! node ) return\\n\\n            if ( node.left ) yield* recur( node.left )\\n            yield node.val\\n            if ( node.right) yield* recur( node.right )\\n        }\\n        yield* recur( xxxx )\\n    }\\n\\n    this.thing = generator( root )\\n    this.node = this.thing.next()\\n}\\n\\nBSTIterator.prototype.next = function() {\\n    const node = this.node\\n    this.node = this.thing.next()\\n    return node.value\\n}\\n\\nBSTIterator.prototype.hasNext = function() {\\n    return undefined !== this.node.value\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar BSTIterator = function(root) {\\n    function* generator( xxxx ) {\\n        function* recur(node ) {\\n            if ( ! node ) return\\n\\n            if ( node.left ) yield* recur( node.left )\\n            yield node.val\\n            if ( node.right) yield* recur( node.right )\\n        }\\n        yield* recur( xxxx )\\n    }\\n\\n    this.thing = generator( root )\\n    this.node = this.thing.next()\\n}\\n\\nBSTIterator.prototype.next = function() {\\n    const node = this.node\\n    this.node = this.thing.next()\\n    return node.value\\n}\\n\\nBSTIterator.prototype.hasNext = function() {\\n    return undefined !== this.node.value\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 966260,
                "title": "python-generator",
                "content": "```python\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(node):\\n            if node:\\n                # print(root.val)\\n                yield from inorder(node.left)\\n                yield node.val\\n                yield from inorder(node.right)\\n        self.output_queue = collections.deque()\\n        self.generator = inorder(root)\\n        \\n    def next(self) -> int:\\n        if len(self.output_queue) > 0:\\n            return self.output_queue.popleft()\\n        return next(self.generator)\\n\\n    def hasNext(self) -> bool:\\n        try:\\n            self.output_queue.append(next(self.generator))\\n            return True\\n        except StopIteration:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```python\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(node):\\n            if node:\\n                # print(root.val)\\n                yield from inorder(node.left)\\n                yield node.val\\n                yield from inorder(node.right)\\n        self.output_queue = collections.deque()\\n        self.generator = inorder(root)\\n        \\n    def next(self) -> int:\\n        if len(self.output_queue) > 0:\\n            return self.output_queue.popleft()\\n        return next(self.generator)\\n\\n    def hasNext(self) -> bool:\\n        try:\\n            self.output_queue.append(next(self.generator))\\n            return True\\n        except StopIteration:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722865,
                "title": "python-generator-with-yield",
                "content": "```\\n# Python2\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        def inorder(node):\\n            if not node: return\\n            for val in inorder(node.left):\\n                yield val\\n            yield node.val\\n            for val in inorder(node.right):\\n                yield val\\n        self._iter=inorder(root)\\n        self._buffer=None # peeked buffer        \\n \\n    def next(self):\\n        \"\"\"\\n        @return the next smallest number\\n        :rtype: int\\n        \"\"\"\\n        if self.hasNext():\\n            rlt=self._buffer\\n            self._buffer=None\\n            return rlt\\n        else:\\n            return None\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        :rtype: bool\\n        \"\"\"\\n        if self._buffer is None:\\n            self._buffer=next(self._iter,None)\\n\\n        if self._buffer!=None:\\n            return True\\n        else:\\n            return False\\n\\t\\t\\t\\n#Python3\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(node):\\n            if not node: return\\n            yield from inorder(node.left)\\n            yield node.val\\n            yield from inorder(node.right)\\n        self._iter=inorder(root)\\n        self._buffer=None # peeked buffer           \\n\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        if self.hasNext():\\n            rlt=self._buffer\\n            self._buffer=None\\n            return rlt\\n        else:\\n            return None        \\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        if self._buffer is None:\\n            self._buffer=next(self._iter,None)\\n\\n        if self._buffer!=None:\\n            return True\\n        else:\\n            return False        \\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Python2\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        def inorder(node):\\n            if not node: return\\n            for val in inorder(node.left):\\n                yield val\\n            yield node.val\\n            for val in inorder(node.right):\\n                yield val\\n        self._iter=inorder(root)\\n        self._buffer=None # peeked buffer        \\n \\n    def next(self):\\n        \"\"\"\\n        @return the next smallest number\\n        :rtype: int\\n        \"\"\"\\n        if self.hasNext():\\n            rlt=self._buffer\\n            self._buffer=None\\n            return rlt\\n        else:\\n            return None\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        :rtype: bool\\n        \"\"\"\\n        if self._buffer is None:\\n            self._buffer=next(self._iter,None)\\n\\n        if self._buffer!=None:\\n            return True\\n        else:\\n            return False\\n\\t\\t\\t\\n#Python3\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(node):\\n            if not node: return\\n            yield from inorder(node.left)\\n            yield node.val\\n            yield from inorder(node.right)\\n        self._iter=inorder(root)\\n        self._buffer=None # peeked buffer           \\n\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        if self.hasNext():\\n            rlt=self._buffer\\n            self._buffer=None\\n            return rlt\\n        else:\\n            return None        \\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        if self._buffer is None:\\n            self._buffer=next(self._iter,None)\\n\\n        if self._buffer!=None:\\n            return True\\n        else:\\n            return False        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717690,
                "title": "cpp-solution",
                "content": "// Runtime: 160 ms, faster than 5.66% of C++ online submissions for Binary Search Tree Iterator.\\n// Memory Usage: 27.7 MB, less than 66.17% of C++ online submissions for Binary Search Tree Iterator.\\n```\\n//logic : store the left nodes and root of the tree in stack so that the leftmost is at top which is the smallest\\n//when we are removing child nodes eg the smallest one then next smallest  will be its parent node but when we will remove a node which has a right child the we will store again that right child and its left nodes\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\n    void storeLeftNodes(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root =  root->left;\\n        }\\n    }\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        storeLeftNodes(root);\\n    }\\n    \\n    /** @return the next smallest number */\\n    int next() {\\n        if(st.size() == 0) return -1;\\n        TreeNode* temp = st.top();\\n        st.pop();\\n        storeLeftNodes(temp->right);\\n        return temp->val;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return st.size() != 0;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "// Runtime: 160 ms, faster than 5.66% of C++ online submissions for Binary Search Tree Iterator.\\n// Memory Usage: 27.7 MB, less than 66.17% of C++ online submissions for Binary Search Tree Iterator.\\n```\\n//logic : store the left nodes and root of the tree in stack so that the leftmost is at top which is the smallest\\n//when we are removing child nodes eg the smallest one then next smallest  will be its parent node but when we will remove a node which has a right child the we will store again that right child and its left nodes\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\n    void storeLeftNodes(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root =  root->left;\\n        }\\n    }\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        storeLeftNodes(root);\\n    }\\n    \\n    /** @return the next smallest number */\\n    int next() {\\n        if(st.size() == 0) return -1;\\n        TreeNode* temp = st.top();\\n        st.pop();\\n        storeLeftNodes(temp->right);\\n        return temp->val;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return st.size() != 0;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 471971,
                "title": "java-o-h-space",
                "content": "```\\nclass BSTIterator {\\n\\n    // A list whose last element is the next smallest\\n    List<TreeNode> path = new ArrayList<>();\\n    \\n    public BSTIterator(TreeNode root) {\\n        DFS(root, path);\\n    }\\n    \\n    // Find the next smallest element, stop when a node doesn\\'t have left child,\\n    // and that node has the next smallest element.\\n    // The length of path is at most the tree height, thus O(h) space.\\n    public void DFS(TreeNode root, List<TreeNode> path) {\\n        if (root == null) return;\\n        \\n        path.add(root);\\n        \\n        DFS(root.left, path);\\n    }\\n    \\n    /** @return the next smallest number */\\n    // remove the last element, then find the next smallest element in the right sub-tree\\n    public int next() {\\n        TreeNode node = path.remove(path.size() - 1);\\n        DFS(node.right, path); \\n        return node.val;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return path.size() > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator {\\n\\n    // A list whose last element is the next smallest\\n    List<TreeNode> path = new ArrayList<>();\\n    \\n    public BSTIterator(TreeNode root) {\\n        DFS(root, path);\\n    }\\n    \\n    // Find the next smallest element, stop when a node doesn\\'t have left child,\\n    // and that node has the next smallest element.\\n    // The length of path is at most the tree height, thus O(h) space.\\n    public void DFS(TreeNode root, List<TreeNode> path) {\\n        if (root == null) return;\\n        \\n        path.add(root);\\n        \\n        DFS(root.left, path);\\n    }\\n    \\n    /** @return the next smallest number */\\n    // remove the last element, then find the next smallest element in the right sub-tree\\n    public int next() {\\n        TreeNode node = path.remove(path.size() - 1);\\n        DFS(node.right, path); \\n        return node.val;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return path.size() > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378074,
                "title": "c-yield-beats-27-time-100-memory",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class BSTIterator {\\n    private bool hasNext;\\n    private IEnumerator<int> iter;\\n    \\n    private static IEnumerable<int> Inorder(TreeNode root) {\\n        if (root == null) {\\n            yield break;\\n        }\\n        \\n        foreach (var x in Inorder(root.left)) {\\n            yield return x;\\n        }\\n\\n        yield return root.val;\\n        \\n        foreach (var x in Inorder(root.right)) {\\n            yield return x;\\n        }\\n    }\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.iter = Inorder(root).GetEnumerator();\\n        this.hasNext = this.iter.MoveNext();\\n    }\\n    \\n    /** @return the next smallest number */\\n    public int Next() {\\n        var ret = this.iter.Current;\\n        this.hasNext = this.iter.MoveNext();\\n        return ret;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() {\\n        return this.hasNext;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.Next();\\n * bool param_2 = obj.HasNext();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class BSTIterator {\\n    private bool hasNext;\\n    private IEnumerator<int> iter;\\n    \\n    private static IEnumerable<int> Inorder(TreeNode root) {\\n        if (root == null) {\\n            yield break;\\n        }\\n        \\n        foreach (var x in Inorder(root.left)) {\\n            yield return x;\\n        }\\n\\n        yield return root.val;\\n        \\n        foreach (var x in Inorder(root.right)) {\\n            yield return x;\\n        }\\n    }\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.iter = Inorder(root).GetEnumerator();\\n        this.hasNext = this.iter.MoveNext();\\n    }\\n    \\n    /** @return the next smallest number */\\n    public int Next() {\\n        var ret = this.iter.Current;\\n        this.hasNext = this.iter.MoveNext();\\n        return ret;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() {\\n        return this.hasNext;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.Next();\\n * bool param_2 = obj.HasNext();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 272515,
                "title": "clear-javascript-answer-solved-3-ways",
                "content": "Edit: Just read this part \"next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.\" my solution method 2 and 3 aren\\'t valid since it uses more than o(h) memory and does not run in o(1) time. Needs o(n) to set up initial... but I could aregue on average it takes O(n+n-1)/n ~ O(2) or some constant time.\\n\\nmethod 1) inspired by https://leetcode.com/problems/binary-search-tree-iterator/discuss/52694/JavaScript-solution\\nActually solves it in o(h) memory and o(1) average time\\n\\n```\\nvar BSTIterator = function(root) {\\n    this.root = root\\n    this.node = root\\n    this.list =[]\\n    \\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    \\n    while (this.node!=null){\\n        this.list.push(this.node)\\n        this.node = this.node.left\\n    }\\n    let answernode = this.list.pop()\\n    this.node = answernode.right\\n    return answernode.val\\n  \\n};\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.root === null){\\n        return false\\n    }\\n    else if (this.list.length===0 && this.node === null){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};    \\n```\\nmethod 2) uses push and pop by creating a stack that inputs max value first\\n\\n```\\nvar BSTIterator = function(root) {\\n    this.node = root\\n    this.list \\n    \\n};\\nBSTIterator.prototype.next = function() {\\n    if (this.list!=undefined) {\\n        return this.list.pop()\\n    }\\n    else {\\n        let trackingnode = this.node\\n        this.list = helper(trackingnode,[ ])\\n        return this.list.pop()\\n    }\\n    function helper(trackingnode,list){\\n        var track \\n        if (trackingnode.right!=null){\\n            track=trackingnode.right\\n            helper(track,list)\\n        }\\n        list.push(trackingnode.val)\\n        if (trackingnode.left!=null){\\n            track = trackingnode.left\\n            helper(track,list)\\n        }\\n        return list\\n    }\\n};\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.node ===null){\\n        return false\\n    }\\n    else if (this.list === undefined){\\n      \\n        return true\\n    }\\n    else if (this.list.length===0){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};     \\n```\\n\\n\\nmethod 3) uses list and indexing - built the index inorder \\n```\\nvar BSTIterator = function(root) {\\n    this.node = root\\n    this.list \\n    this.count = -1\\n    this.length\\n    \\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    // console.log(this.list)\\n    if (this.list!=undefined) {\\n        this.count++\\n        return this.list[this.count]  \\n    }\\n    else {\\n        let trackingnode = this.node\\n        this.list = helper(trackingnode,[ ])\\n        this.count++\\n        this.length = this.list.length\\n        return this.list[this.count]\\n\\n    }\\n    \\n    function helper(trackingnode,list){\\n        var track \\n        if (trackingnode.left!=null){\\n            track=trackingnode.left\\n            helper(track,list)\\n        }\\n        list.push(trackingnode.val)\\n        if (trackingnode.right!=null){\\n            track = trackingnode.right\\n            helper(track,list)\\n        }\\n        return list\\n    }\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.node ===null){\\n        return false\\n    }\\n    else if (this.length === undefined){\\n        return true\\n    }\\n    else if (this.length-1<=this.count){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};      \\n```",
                "solutionTags": [],
                "code": "```\\nvar BSTIterator = function(root) {\\n    this.root = root\\n    this.node = root\\n    this.list =[]\\n    \\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    \\n    while (this.node!=null){\\n        this.list.push(this.node)\\n        this.node = this.node.left\\n    }\\n    let answernode = this.list.pop()\\n    this.node = answernode.right\\n    return answernode.val\\n  \\n};\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.root === null){\\n        return false\\n    }\\n    else if (this.list.length===0 && this.node === null){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};    \\n```\n```\\nvar BSTIterator = function(root) {\\n    this.node = root\\n    this.list \\n    \\n};\\nBSTIterator.prototype.next = function() {\\n    if (this.list!=undefined) {\\n        return this.list.pop()\\n    }\\n    else {\\n        let trackingnode = this.node\\n        this.list = helper(trackingnode,[ ])\\n        return this.list.pop()\\n    }\\n    function helper(trackingnode,list){\\n        var track \\n        if (trackingnode.right!=null){\\n            track=trackingnode.right\\n            helper(track,list)\\n        }\\n        list.push(trackingnode.val)\\n        if (trackingnode.left!=null){\\n            track = trackingnode.left\\n            helper(track,list)\\n        }\\n        return list\\n    }\\n};\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.node ===null){\\n        return false\\n    }\\n    else if (this.list === undefined){\\n      \\n        return true\\n    }\\n    else if (this.list.length===0){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};     \\n```\n```\\nvar BSTIterator = function(root) {\\n    this.node = root\\n    this.list \\n    this.count = -1\\n    this.length\\n    \\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    // console.log(this.list)\\n    if (this.list!=undefined) {\\n        this.count++\\n        return this.list[this.count]  \\n    }\\n    else {\\n        let trackingnode = this.node\\n        this.list = helper(trackingnode,[ ])\\n        this.count++\\n        this.length = this.list.length\\n        return this.list[this.count]\\n\\n    }\\n    \\n    function helper(trackingnode,list){\\n        var track \\n        if (trackingnode.left!=null){\\n            track=trackingnode.left\\n            helper(track,list)\\n        }\\n        list.push(trackingnode.val)\\n        if (trackingnode.right!=null){\\n            track = trackingnode.right\\n            helper(track,list)\\n        }\\n        return list\\n    }\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.node ===null){\\n        return false\\n    }\\n    else if (this.length === undefined){\\n        return true\\n    }\\n    else if (this.length-1<=this.count){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};      \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52594,
                "title": "o-1-space-java-solution-using-morris-traverse",
                "content": "Re: [Morris traverse solution](/topic/8154/morris-traverse-solution)\\n\\nAs a follow-up in Lintcode, extra space usage O(1) is required which reminds me of Morris Traverse. For anyone who doesn't know Morris traverse, I really recommend you this magic traversal approach. And also you can try to get to know it by the code and comments in the following.  \\n\\n```java\\n    private TreeNode cur;\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.cur = root;\\n    }\\n\\n    public boolean hasNext() {\\n        return cur != null;\\n    }\\n    \\n    public int next() {\\n        TreeNode node = null;\\n        while (cur != null && node == null) {\\n            if (cur.left == null) {         // no left child, then go right (right child or back to root)\\n                node = cur;\\n                cur = cur.right;\\n            } else {\\n                TreeNode rmost = cur.left;\\n                while (rmost.right != null && rmost.right != cur) rmost = rmost.right;\\n                \\n                if (rmost.right == null) {  // 1.link rmost to root (cur) as footprint before go left\\n                    rmost.right = cur;\\n                    cur = cur.left;\\n                } else {                    // 2.We already get back to root by footprint, so restore then go right\\n                    node = cur;\\n                    rmost.right = null;\\n                    cur = cur.right;\\n                }\\n            }\\n        }\\n        return node.val;\\n    }\\n```\\n\\nNote that the key of the algorithm is: **link right pointer of rightmost child of left subtree before go left**, so that when we complete left subtree we can follow the footprint back to root. Then restore rightmost's right pointer and then go for right subtree.\\n\\nTherefore, as the solution using Stack, the time complexity is O(1) amortized, but we only maintain current node rather than an entire stack.",
                "solutionTags": [],
                "code": "```java\\n    private TreeNode cur;\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.cur = root;\\n    }\\n\\n    public boolean hasNext() {\\n        return cur != null;\\n    }\\n    \\n    public int next() {\\n        TreeNode node = null;\\n        while (cur != null && node == null) {\\n            if (cur.left == null) {         // no left child, then go right (right child or back to root)\\n                node = cur;\\n                cur = cur.right;\\n            } else {\\n                TreeNode rmost = cur.left;\\n                while (rmost.right != null && rmost.right != cur) rmost = rmost.right;\\n                \\n                if (rmost.right == null) {  // 1.link rmost to root (cur) as footprint before go left\\n                    rmost.right = cur;\\n                    cur = cur.left;\\n                } else {                    // 2.We already get back to root by footprint, so restore then go right\\n                    node = cur;\\n                    rmost.right = null;\\n                    cur = cur.right;\\n                }\\n            }\\n        }\\n        return node.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52693,
                "title": "my-5ms-java-code-with-explanation-which-beats-95",
                "content": "Basically, my code is trying to modify the structure of the right subtree to make sure the \"next\" node to be the right son of current \"root\", when each time we call function next().\\n\\nLet's consider a tree now. \"root\" is the current node of the tree. \\nIf hasnext()==true, then there are 2 scenarios.(Please draw the tree to better understand.)\\n\\n(1) Its right son doesn't have a left son. This scenario is easy and we can simply return the right son's val and meanwhile set root to the right son.  \\n\\n(2) Its right son has left son. Let's use \"next\" to represent the right son. Then we should do \"next = next.left\" until it doesn't have a left son. Now the \"next.val\" is what we'd like to return. \\nHowever, in this case how can we keep going?\\n\\nMy idea is to modify the structure of the tree, in order to **make the \"next\" node to be the right son of current \"root\", make the \"next\" node to be the right son of current \"root\", make the \"next\" node to be the right son of current \"root\"(Repeat important things for 3 times)**. Basically, there are two things to consider. \\n\\nFirstly, since we want to move node \"next\", don't forget about the right subtree of it!!! So we need a node called \"parent\" to store the original parent of node \"next\" and then we can set parent.left = next.right.\\n\\nSecondly, we need to have a TreeNode called \"right\" to store the original right son of root. Then we can set root.right = next and next.right = right.\\n\\nThen we get a new right subtree and we just set root = next before we return next.val.\\n\\n    public class BSTIterator {\\n\\tTreeNode root = new TreeNode(0); \\n    public BSTIterator(TreeNode root) {\\n        this.root.right = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return (root.right!=null);\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode next = root.right;\\n        if (next.left==null) {\\n        \\troot = next;\\n        \\treturn next.val; \\n        }\\n        TreeNode right = root.right;\\n        TreeNode parent = root;\\n        while (next.left!=null) {\\n        \\tparent = next;\\n        \\tnext = next.left;\\n        }\\n        parent.left = next.right;\\n        root.right = next;\\n        next.right = right;\\n        root = next;\\n        return next.val;\\n    }\\n}",
                "solutionTags": [],
                "code": "Basically, my code is trying to modify the structure of the right subtree to make sure the \"next\" node to be the right son of current \"root\", when each time we call function next().\\n\\nLet's consider a tree now. \"root\" is the current node of the tree. \\nIf hasnext()==true, then there are 2 scenarios.(Please draw the tree to better understand.)\\n\\n(1) Its right son doesn't have a left son. This scenario is easy and we can simply return the right son's val and meanwhile set root to the right son.  \\n\\n(2) Its right son has left son. Let's use \"next\" to represent the right son. Then we should do \"next = next.left\" until it doesn't have a left son. Now the \"next.val\" is what we'd like to return. \\nHowever, in this case how can we keep going?\\n\\nMy idea is to modify the structure of the tree, in order to **make the \"next\" node to be the right son of current \"root\", make the \"next\" node to be the right son of current \"root\", make the \"next\" node to be the right son of current \"root\"(Repeat important things for 3 times)**. Basically, there are two things to consider. \\n\\nFirstly, since we want to move node \"next\", don't forget about the right subtree of it!!! So we need a node called \"parent\" to store the original parent of node \"next\" and then we can set parent.left = next.right.\\n\\nSecondly, we need to have a TreeNode called \"right\" to store the original right son of root. Then we can set root.right = next and next.right = right.\\n\\nThen we get a new right subtree and we just set root = next before we return next.val.\\n\\n    public class BSTIterator {\\n\\tTreeNode root = new TreeNode(0); \\n    public BSTIterator(TreeNode root) {\\n        this.root.right = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return (root.right!=null);\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode next = root.right;\\n        if (next.left==null) {\\n        \\troot = next;\\n        \\treturn next.val; \\n        }\\n        TreeNode right = root.right;\\n        TreeNode parent = root;\\n        while (next.left!=null) {\\n        \\tparent = next;\\n        \\tnext = next.left;\\n        }\\n        parent.left = next.right;\\n        root.right = next;\\n        next.right = right;\\n        root = next;\\n        return next.val;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3911585,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass BSTIterator {\\n    private Stack<TreeNode> st = new Stack<>();\\n\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode tempNode = st.pop();\\n        pushAll(tempNode.right);\\n        return tempNode.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return !st.isEmpty();\\n    }\\n\\n    private void pushAll(TreeNode node) {\\n        while(node != null) {\\n            st.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BSTIterator {\\n    private Stack<TreeNode> st = new Stack<>();\\n\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode tempNode = st.pop();\\n        pushAll(tempNode.right);\\n        return tempNode.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return !st.isEmpty();\\n    }\\n\\n    private void pushAll(TreeNode node) {\\n        while(node != null) {\\n            st.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863835,
                "title": "python-3-different-approaches-and-step-by-step-optimisation-faster-than-98-88-less-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we have to do the in-order tranversal and print the next node in in-order. We can do it in 3 different ways\\n1. Create an inorder array inside class constructor recursively and maintain an index to track current element \\n2. Maintain a stack of elements\\n3. [Most efficient] Scroll down and see this one.  \\n\\n# Approach 1 [Accepted] : create array in constructor\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) -> using recursion + storing in array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.arr = []\\n        self.curr_index = 0\\n        self.in_order(root)\\n        print(self.arr)\\n        \\n    def in_order(self, root):\\n        if not root:\\n            return\\n        self.in_order(root.left)\\n        self.arr.append(root.val)\\n        self.in_order(root.right)\\n\\n    def next(self) -> int:\\n        val = self.arr[self.curr_index]\\n        self.curr_index+=1\\n        return val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.curr_index<=len(self.arr)-1\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\\n## problem with above approach\\nWe are creating the whole in-order array in constructor, which is waste of computation and resource. We should do it on demand when methods are called. \\n\\n----\\n# Approach 2 [Accepted]: Use stack + on-the-go push and pop \\nHere instead of creating the whole array in constructor, we use stack to maintain the part we have not traversed yet. As `next` is called, we will keep `poping` from stack. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) -> using stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        node=self.stack.pop()\\n        r = node.right\\n        while r:\\n            self.stack.append(r)\\n            r = r.left\\n        return node.val\\n            \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.stack\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\\n## Problem/Drawback\\nUsing a stack make space complexity `O(n)`. it would be great if we can get rid of it. \\n\\n# Approach 3: Using Morris Inorder traversal\\nWe all know the [moris in-order traversal](https://www.youtube.com/watch?v=wGXB9OWhPTg&t=632s&ab_channel=TusharRoy-CodingMadeSimple), keep track of right unvisited node by making a tempraroy right pointer to current. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.curr = root\\n\\n    def next(self) -> int:\\n        while self.curr:\\n            if not self.curr.left:\\n                val = self.curr.val\\n                self.curr = self.curr.right\\n                return val\\n            else:\\n                pred = self.curr.left\\n                while pred.right and pred.right!=self.curr:\\n                    pred = pred.right\\n                if pred.right==self.curr:\\n                    pred.right=None\\n                    val = self.curr.val\\n                    self.curr= self.curr.right\\n                    return val\\n                else:\\n                    pred.right = self.curr\\n                    self.curr = self.curr.left\\n\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.curr is not None\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\\n![image.png](https://assets.leetcode.com/users/images/7b4c9dbe-576d-4e21-8e37-4a3705215399_1691169369.2091012.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.arr = []\\n        self.curr_index = 0\\n        self.in_order(root)\\n        print(self.arr)\\n        \\n    def in_order(self, root):\\n        if not root:\\n            return\\n        self.in_order(root.left)\\n        self.arr.append(root.val)\\n        self.in_order(root.right)\\n\\n    def next(self) -> int:\\n        val = self.arr[self.curr_index]\\n        self.curr_index+=1\\n        return val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.curr_index<=len(self.arr)-1\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        node=self.stack.pop()\\n        r = node.right\\n        while r:\\n            self.stack.append(r)\\n            r = r.left\\n        return node.val\\n            \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.stack\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.curr = root\\n\\n    def next(self) -> int:\\n        while self.curr:\\n            if not self.curr.left:\\n                val = self.curr.val\\n                self.curr = self.curr.right\\n                return val\\n            else:\\n                pred = self.curr.left\\n                while pred.right and pred.right!=self.curr:\\n                    pred = pred.right\\n                if pred.right==self.curr:\\n                    pred.right=None\\n                    val = self.curr.val\\n                    self.curr= self.curr.right\\n                    return val\\n                else:\\n                    pred.right = self.curr\\n                    self.curr = self.curr.left\\n\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.curr is not None\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559521,
                "title": "efficient-java-solution-with-explanation",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->All we need to do is to add the values of given binary tree to an ArrayList using DFS algorithm which is the main point of the solution.\\n\\n# Complexity\\n- Time complexity:*O(N)* is the time taken by constructor for storing the values of nodes to ArrayList  \\n    - `next()` would take *O(1)*\\n    - `hasNext()` would take *O(1)*\\n> \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(N)*  -  since we create a new ArrayList to contain the values of nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    List<Integer> list;\\n    int next = 0; //initial index;\\n\\n    public BSTIterator(TreeNode root) {\\n        this.list = new ArrayList<>();\\n        \\n        dfs(root); //collect all the values to the given list using in-order traversal of tree\\n    }\\n    \\n    public int next() {\\n        return  list.get(next++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return list.size() > next;\\n    }\\n   \\n    private void dfs(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        dfs(root.left);\\n        list.add(root.val);\\n        dfs(root.right);\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```\\n# *Please upvote if you like the solution*",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    List<Integer> list;\\n    int next = 0; //initial index;\\n\\n    public BSTIterator(TreeNode root) {\\n        this.list = new ArrayList<>();\\n        \\n        dfs(root); //collect all the values to the given list using in-order traversal of tree\\n    }\\n    \\n    public int next() {\\n        return  list.get(next++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return list.size() > next;\\n    }\\n   \\n    private void dfs(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        dfs(root.left);\\n        list.add(root.val);\\n        dfs(root.right);\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435492,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    int i=0;\\n    //insert in inorder form so that we can iterate through array to give next\\n    vector<int>ans;\\n    TreeNode*temp;\\n    BSTIterator(TreeNode* root) {\\n        //this is function we will insert in inorder form\\n        insertInorder(root);\\n    }\\n    void insertInorder(TreeNode*root){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left){\\n            insertInorder(root->left);\\n        }\\n\\n        //insert into vector\\n        ans.push_back(root->val);\\n\\n        //right call\\n        if(root->right){\\n            insertInorder(root->right);\\n        }\\n    }\\n    int next() {\\n        int temp=ans[i];\\n        i++;\\n        return temp;\\n    }\\n    \\n    bool hasNext() {\\n        if(i>=ans.size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    int i=0;\\n    //insert in inorder form so that we can iterate through array to give next\\n    vector<int>ans;\\n    TreeNode*temp;\\n    BSTIterator(TreeNode* root) {\\n        //this is function we will insert in inorder form\\n        insertInorder(root);\\n    }\\n    void insertInorder(TreeNode*root){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left){\\n            insertInorder(root->left);\\n        }\\n\\n        //insert into vector\\n        ans.push_back(root->val);\\n\\n        //right call\\n        if(root->right){\\n            insertInorder(root->right);\\n        }\\n    }\\n    int next() {\\n        int temp=ans[i];\\n        i++;\\n        return temp;\\n    }\\n    \\n    bool hasNext() {\\n        if(i>=ans.size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340370,
                "title": "java-stack-o-h-space-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to traverse the BST using an inorder traversal algorithm. We can\\'t use recursion as we need to maintain state and report the current position of the iterator when the `next` method is called. So, we can implement the same algorithm using a Stack of our own. At any point of time, the iterator will always point to the node on the top of the stack. This will ensure that we use at max **O(h)** space on the stack.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ on average\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BSTIterator {\\n  Stack<TreeNode> stack;\\n\\n  public BSTIterator(TreeNode root) {\\n    stack = new Stack<>();\\n\\n    for (var a = root; a != null; a = a.left)\\n      stack.push(a);\\n  }\\n  \\n  public int next() {\\n    var node = stack.pop();\\n\\n    for (var a = node.right; a != null; a = a.left)\\n      stack.push(a);\\n\\n    return node.val;\\n  }\\n  \\n  public boolean hasNext() {\\n    return !stack.empty();  \\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass BSTIterator {\\n  Stack<TreeNode> stack;\\n\\n  public BSTIterator(TreeNode root) {\\n    stack = new Stack<>();\\n\\n    for (var a = root; a != null; a = a.left)\\n      stack.push(a);\\n  }\\n  \\n  public int next() {\\n    var node = stack.pop();\\n\\n    for (var a = node.right; a != null; a = a.left)\\n      stack.push(a);\\n\\n    return node.val;\\n  }\\n  \\n  public boolean hasNext() {\\n    return !stack.empty();  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057260,
                "title": "c-two-solutions-o-n-o-h-space-complexity-dry-run",
                "content": "\\n\\n### Complexity\\n- Time complexity: `O(N)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass BSTIterator {\\n    vector<int> nodes;\\n    int curr = -1;\\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        nodes.push_back(root -> val);\\n        inorder(root->right);\\n    }\\n\\npublic:\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        if(curr == nodes.size() - 1) return -1;\\n        curr++;\\n        return nodes[curr];\\n    }\\n    \\n    bool hasNext() {\\n        if(curr == nodes.size() - 1) return false;\\n        return true;\\n    }\\n};\\n```\\n\\n### Complexity\\n- Time complexity: `O(N)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(H)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n### Dry Run\\n\\n***Example : 1***\\ninput : [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\\n\\n1. `BSTIterator(root)`\\n    - ` back ->` [ 7, 3 ] `<- top`\\n2. `next()` \\n    - `back ->` [ 7 ] `<- top` `pop 3`, `return 3` then push all the element of `right of left` trees,\\n3. `next() `\\n    - `back ->` [ ] `<- top` `pop 7` & `return 7`\\n    - become `back ->` [ 15, 9 ] `<- top` `pop 7`\\n4. `hasNext()` return next element present or not i.e `is stack empty`\\n5. `next()`\\n    - `back ->` [ 15 ] `<- top` `pop 9` & `return 9`\\n6. `hasNext() `\\n7. `next()` \\n    - `back ->` [  ] `<- top` `pop 15` & `return 15`\\n    - become `back ->` [ 20 ] `<- top`\\n8. ` next()`\\n    - `back ->` [  ] `<- top` `pop 20` & `return 20`\\n9. `hasNext()` -> in the last stack is empty so return false;\\n\\n---\\n\\n### Code\\n```\\n\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    BSTIterator(TreeNode* root) {\\n        while(root) {\\n            st.push(root);\\n            root = root -> left;\\n        }\\n    }\\n    \\n    int next() {\\n       if(!st.empty()) {\\n           TreeNode *top = st.top(); st.pop();\\n           TreeNode *next = top -> right;\\n            while(next) {\\n                st.push(next);\\n                next = next -> left;\\n            }\\n           return top -> val;\\n       }\\n       return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(!st.empty()) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass BSTIterator {\\n    vector<int> nodes;\\n    int curr = -1;\\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        nodes.push_back(root -> val);\\n        inorder(root->right);\\n    }\\n\\npublic:\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        if(curr == nodes.size() - 1) return -1;\\n        curr++;\\n        return nodes[curr];\\n    }\\n    \\n    bool hasNext() {\\n        if(curr == nodes.size() - 1) return false;\\n        return true;\\n    }\\n};\\n```\n```\\n\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    BSTIterator(TreeNode* root) {\\n        while(root) {\\n            st.push(root);\\n            root = root -> left;\\n        }\\n    }\\n    \\n    int next() {\\n       if(!st.empty()) {\\n           TreeNode *top = st.top(); st.pop();\\n           TreeNode *next = top -> right;\\n            while(next) {\\n                st.push(next);\\n                next = next -> left;\\n            }\\n           return top -> val;\\n       }\\n       return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(!st.empty()) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975103,
                "title": "java-stack-simple-solution",
                "content": "Thid is my simple and intuitive solution on Java.\\n```\\nclass BSTIterator {\\n\\n    Stack<TreeNode> leftNodes = new Stack<>();\\n\\n    public BSTIterator(TreeNode root) {\\n        this.walkOnLeft(root);\\n    }\\n\\n    private void walkOnLeft(TreeNode root) {\\n        while (root != null) {\\n            leftNodes.push(root);\\n            root = root.left;\\n        }\\n    }\\n    \\n    public int next() {\\n        if (!hasNext()) {\\n            return -1;\\n        }\\n\\n        TreeNode currentNode = this.leftNodes.pop();\\n        this.walkOnLeft(currentNode.right);\\n        \\n        return currentNode.val;    \\n    }\\n    \\n    public boolean hasNext() {\\n        return !this.leftNodes.empty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BSTIterator {\\n\\n    Stack<TreeNode> leftNodes = new Stack<>();\\n\\n    public BSTIterator(TreeNode root) {\\n        this.walkOnLeft(root);\\n    }\\n\\n    private void walkOnLeft(TreeNode root) {\\n        while (root != null) {\\n            leftNodes.push(root);\\n            root = root.left;\\n        }\\n    }\\n    \\n    public int next() {\\n        if (!hasNext()) {\\n            return -1;\\n        }\\n\\n        TreeNode currentNode = this.leftNodes.pop();\\n        this.walkOnLeft(currentNode.right);\\n        \\n        return currentNode.val;    \\n    }\\n    \\n    public boolean hasNext() {\\n        return !this.leftNodes.empty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940527,
                "title": "python-solution-faster-than-91-38-of-python-submissions-queue-approach",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n    def inOrderTraversal(self, root, queue):\\n        if (root is None):\\n            return\\n        self.inOrderTraversal(root.left, queue)\\n        queue.append(root.val)\\n        self.inOrderTraversal(root.right, queue)\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.queue = []\\n        self.inOrderTraversal(root, self.queue)\\n\\n    def next(self) -> int:\\n        return self.queue.pop(0)\\n        \\n    def hasNext(self) -> bool:\\n        return self.queue != []\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n    def inOrderTraversal(self, root, queue):\\n        if (root is None):\\n            return\\n        self.inOrderTraversal(root.left, queue)\\n        queue.append(root.val)\\n        self.inOrderTraversal(root.right, queue)\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.queue = []\\n        self.inOrderTraversal(root, self.queue)\\n\\n    def next(self) -> int:\\n        return self.queue.pop(0)\\n        \\n    def hasNext(self) -> bool:\\n        return self.queue != []\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821833,
                "title": "python-solution-using-flattned-bst-to-linked-list-using-morris-treversal-o-1-space-o-1-avg-time",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, rt: Optional[TreeNode]):\\n        root=rt\\n        while root:\\n            if root.left:\\n                t=TreeNode(root.val)\\n                t.right=root.right\\n                x=root.left\\n                while x.right:\\n                    x=x.right\\n                x.right=t\\n                root.right=root.left.right\\n                root.val=root.left.val\\n                root.left=root.left.left\\n            else:\\n                root=root.right\\n        self.root=rt\\n    def next(self) -> int:\\n        t=self.root.val\\n        self.root=self.root.right\\n        return t\\n    def hasNext(self) -> bool:\\n        if self.root:\\n            return True\\n        return False",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, rt: Optional[TreeNode]):\\n        root=rt\\n        while root:\\n            if root.left:\\n                t=TreeNode(root.val)\\n                t.right=root.right\\n                x=root.left\\n                while x.right:\\n                    x=x.right\\n                x.right=t\\n                root.right=root.left.right\\n                root.val=root.left.val\\n                root.left=root.left.left\\n            else:\\n                root=root.right\\n        self.root=rt\\n    def next(self) -> int:\\n        t=self.root.val\\n        self.root=self.root.right\\n        return t\\n    def hasNext(self) -> bool:\\n        if self.root:\\n            return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 2753279,
                "title": "c-stack-recursive-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass BSTIterator {\\npublic:\\n\\n    stack<TreeNode*>s;\\n    BSTIterator(TreeNode* root) {\\n        formlft(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* root=s.top();\\n        s.pop();\\n        formlft(root->right);\\n        return root->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n    void formlft(TreeNode* root){\\n        while(root){\\n            s.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n \\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass BSTIterator {\\npublic:\\n\\n    stack<TreeNode*>s;\\n    BSTIterator(TreeNode* root) {\\n        formlft(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* root=s.top();\\n        s.pop();\\n        formlft(root->right);\\n        return root->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n    void formlft(TreeNode* root){\\n        while(root){\\n            s.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n \\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2682392,
                "title": "c-easy-to-understand-use-of-stack-stl",
                "content": "1. We use Stack for the bst iterator and first store all left nodes first.\\n\\n2.  In function, int next() we simply need to get the top element of stack and pop it from stack , also if it\\'s right exists we push all the left of it\\'s right using pushall() function.\\n\\n3.In function hasNext() , we check if the stack is not empty then there exist next element otherwise don\\'t.\\n\\nHere\\'s the code.\\n\\n```\\n stack <TreeNode* > st;\\n    BSTIterator(TreeNode* root) {\\n        pushall(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* tp=st.top();\\n        st.pop();\\n        pushall(tp->right);\\n        return tp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    void pushall(TreeNode* root){\\n        for(;root!=NULL;st.push(root) , root=root->left);\\n    }\\n```\\n\\nPlease upvote if found helpful !",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n stack <TreeNode* > st;\\n    BSTIterator(TreeNode* root) {\\n        pushall(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* tp=st.top();\\n        st.pop();\\n        pushall(tp->right);\\n        return tp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    void pushall(TreeNode* root){\\n        for(;root!=NULL;st.push(root) , root=root->left);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2663139,
                "title": "c-highly-commented-code-free-meme",
                "content": "For complexity analysis and other stuff, **please** go [here](https://garmadon.notion.site/Binary-Search-Tree-Iterator-dccea6fb7ece425383963612e07b5964).\\n\\n```\\n//An iterator that iterates over the inorder traversal of the BST\\nclass BSTIterator {\\n\\n//Following principles of OOP lol\\nprivate: \\n    stack<TreeNode*> nodeStack;\\n\\npublic:\\n\\n    //Creates the iterator\\n    BSTIterator(TreeNode* root) {\\n        fillStack(root);\\n    }\\n    \\n    //Returns the next element in inorder traversal\\n    int next() {\\n        TreeNode* nextNode = nodeStack.top();\\n        nodeStack.pop();\\n\\n        fillStack(nextNode->right);\\n\\n        return nextNode->val;\\n    }\\n    \\n    //Returns true if more elements are present in the BST\\n    bool hasNext() {\\n        return !nodeStack.empty();\\n    }\\n\\n    //Helper function to fill the stack\\n    void fillStack(TreeNode* root)\\n    {\\n        TreeNode* currNode = root;\\n\\n        while(currNode)\\n        {\\n            nodeStack.push(currNode);\\n            currNode = currNode->left;\\n        }\\n    }\\n};\\n```\\n\\nFREE MEME\\n![image](https://assets.leetcode.com/users/images/478dcee5-cb00-499a-af9e-839330acfab8_1664954202.8649745.png)\\n\\n*Don\\'t you illiterate people forget to upvote!*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//An iterator that iterates over the inorder traversal of the BST\\nclass BSTIterator {\\n\\n//Following principles of OOP lol\\nprivate: \\n    stack<TreeNode*> nodeStack;\\n\\npublic:\\n\\n    //Creates the iterator\\n    BSTIterator(TreeNode* root) {\\n        fillStack(root);\\n    }\\n    \\n    //Returns the next element in inorder traversal\\n    int next() {\\n        TreeNode* nextNode = nodeStack.top();\\n        nodeStack.pop();\\n\\n        fillStack(nextNode->right);\\n\\n        return nextNode->val;\\n    }\\n    \\n    //Returns true if more elements are present in the BST\\n    bool hasNext() {\\n        return !nodeStack.empty();\\n    }\\n\\n    //Helper function to fill the stack\\n    void fillStack(TreeNode* root)\\n    {\\n        TreeNode* currNode = root;\\n\\n        while(currNode)\\n        {\\n            nodeStack.push(currNode);\\n            currNode = currNode->left;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229059,
                "title": "c-stack-solution-t-c-o-n-s-c-o-1",
                "content": "# C++ Stack Solution\\n1. It is like inorder traversal just we are using stack in place of recursion call.\\n2. We are pushing left->left->left in stack\\n3. For hasNext we are checking if stack is empty or not\\n4. next will be top element of stack, we are popping it and then call left->left->left of st.top()->right if exist.\\n\\n***Please Upvote if you like it***\\n\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode *>st;\\n    \\n    void pushAll(TreeNode *cur){\\n        TreeNode *node = cur;\\n        while(node){\\n            st.push(node);\\n            node=node->left;\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n    }\\n    \\n    int next() {\\n        TreeNode *ans = st.top();\\n        st.pop();\\n        if(ans->right){\\n            pushAll(ans->right);\\n        }\\n        return ans->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode *>st;\\n    \\n    void pushAll(TreeNode *cur){\\n        TreeNode *node = cur;\\n        while(node){\\n            st.push(node);\\n            node=node->left;\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n    }\\n    \\n    int next() {\\n        TreeNode *ans = st.top();\\n        st.pop();\\n        if(ans->right){\\n            pushAll(ans->right);\\n        }\\n        return ans->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2216739,
                "title": "simple-python",
                "content": "Simple Iterator Inorder Traversal -\\n* Maintain a stack and initially push all the elements left to the root inside it.\\n* Whenever next() is called, pop the element from that stack and return,\\n* After that push all the elements, right to the popped element (if any) inside the stack.\\n* hasnext() can easily be implemented by checking size of stack.\\n\\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.stack = []\\n        self.push(root)\\n    \\n    def push(self,root):\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    def next(self) -> int:\\n        res = self.stack.pop()\\n        self.push(res.right)\\n        return res.val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack)\\n```\\n\\nComment if you have any doubt.",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.stack = []\\n        self.push(root)\\n    \\n    def push(self,root):\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    def next(self) -> int:\\n        res = self.stack.pop()\\n        self.push(res.right)\\n        return res.val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967706,
                "title": "c-sc-o-h-tc-o-1",
                "content": "```\\nclass BSTIterator {\\n    private: stack<TreeNode *> st;\\npublic:\\n    BSTIterator(TreeNode *root) {\\n        helper(root);\\n    }\\n\\t// if the stack has elements, obvioulsy hasNext is true else false\\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n\\t/** when the elements in the stack are there, while poping them out, you get them in the in-order \\n\\tfashion, but our helper function is adding only the left nodes, so we take the top element, \\n\\tpop it out and then if it has a right node, we call the helper for it \\n\\tand then we return our top node of the stack, which we poped out**/\\n    int next() {\\n        TreeNode *temp = st.top();\\n        st.pop();\\n        helper(temp->right);\\n        return temp->val;\\n    }\\n\\nprivate:\\n    void helper(TreeNode *node) {\\n        while(node != NULL){\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n};\\n/** if its hard to understand, just take a pen and paper and dry run this code with a testcase\\ni\\'m pretty sure you\\'ll understand**/\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator {\\n    private: stack<TreeNode *> st;\\npublic:\\n    BSTIterator(TreeNode *root) {\\n        helper(root);\\n    }\\n\\t// if the stack has elements, obvioulsy hasNext is true else false\\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n\\t/** when the elements in the stack are there, while poping them out, you get them in the in-order \\n\\tfashion, but our helper function is adding only the left nodes, so we take the top element, \\n\\tpop it out and then if it has a right node, we call the helper for it \\n\\tand then we return our top node of the stack, which we poped out**/\\n    int next() {\\n        TreeNode *temp = st.top();\\n        st.pop();\\n        helper(temp->right);\\n        return temp->val;\\n    }\\n\\nprivate:\\n    void helper(TreeNode *node) {\\n        while(node != NULL){\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n};\\n/** if its hard to understand, just take a pen and paper and dry run this code with a testcase\\ni\\'m pretty sure you\\'ll understand**/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967392,
                "title": "c-efficient-optimal-o-h",
                "content": "***DO UPVOTE IF THIS HELPS!!!***\\n\\n\\tstack<TreeNode*>st;  //stack -- O(h) Memory\\n\\n\\tvoid inorder(TreeNode* root){  //partial inorder i.e. pushing all left elements into stack for a root\\n   \\n\\t   if(root==NULL){\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tst.push(root);\\n\\n\\t\\twhile(root->left!=NULL){  //pushing all left elements\\n\\t\\t\\tst.push(root->left);\\n\\t\\t\\troot=root->left;\\n\\t\\t}\\n\\t}\\n\\n\\tBSTIterator(TreeNode* root) {  //calling inorder\\n\\t\\tinorder(root);\\n\\t}\\n\\n\\tint next() {\\n    \\n\\t\\tTreeNode* top=st.top();  //top stores the topmost index \\n\\t\\tst.pop();\\n\\n\\t\\tif(top->right!=NULL){  //check if top has an element to it\\'s right .. if it has, then call inorder\\n\\t\\t\\tinorder(top->right);  //inorder will push all the left elements of top\\'s right node\\n\\t\\t}\\n    \\n\\t\\treturn top->val;  //return top-> value afterwards\\n\\t}\\n\\n\\tbool hasNext() {\\n\\t\\treturn !st.empty();  //return if it is empty or not in boolean\\n\\t}",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "***DO UPVOTE IF THIS HELPS!!!***\\n\\n\\tstack<TreeNode*>st;  //stack -- O(h) Memory\\n\\n\\tvoid inorder(TreeNode* root){  //partial inorder i.e. pushing all left elements into stack for a root\\n   \\n\\t   if(root==NULL){\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tst.push(root);\\n\\n\\t\\twhile(root->left!=NULL){  //pushing all left elements\\n\\t\\t\\tst.push(root->left);\\n\\t\\t\\troot=root->left;\\n\\t\\t}\\n\\t}\\n\\n\\tBSTIterator(TreeNode* root) {  //calling inorder\\n\\t\\tinorder(root);\\n\\t}\\n\\n\\tint next() {\\n    \\n\\t\\tTreeNode* top=st.top();  //top stores the topmost index \\n\\t\\tst.pop();\\n\\n\\t\\tif(top->right!=NULL){  //check if top has an element to it\\'s right .. if it has, then call inorder\\n\\t\\t\\tinorder(top->right);  //inorder will push all the left elements of top\\'s right node\\n\\t\\t}\\n    \\n\\t\\treturn top->val;  //return top-> value afterwards\\n\\t}\\n\\n\\tbool hasNext() {\\n\\t\\treturn !st.empty();  //return if it is empty or not in boolean\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1966077,
                "title": "c-in-order-traversal-o-1-time-o-h-space",
                "content": "Here we perform simple Iterative Inorder traversal. As we initialize our TreeNode, we push all  the left nodes to a stack. And one by one pop as the next() method is called.\\n```\\nclass BSTIterator {\\nprivate:\\n    TreeNode* pt;\\n    stack<TreeNode*> s;\\n\\t\\n    void pushStack(TreeNode *node){\\n        while(node!=nullptr){\\n            s.push(node);\\n            node=node->left;\\n        }\\n    }\\n\\t// pushed the left subtree to the stack\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        pt=root;\\n        pushStack(pt);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=s.top();\\n        s.pop();\\n        pushStack(temp->right);\\n        return temp->val;\\n    }\\n\\t\\n    // We pop the top node return its value \\n\\t// then we push its right subtree to stack to continue inorder traversal\\n\\t\\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n\\t// if stack is empty then we have already traversed out tree\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator {\\nprivate:\\n    TreeNode* pt;\\n    stack<TreeNode*> s;\\n\\t\\n    void pushStack(TreeNode *node){\\n        while(node!=nullptr){\\n            s.push(node);\\n            node=node->left;\\n        }\\n    }\\n\\t// pushed the left subtree to the stack\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        pt=root;\\n        pushStack(pt);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=s.top();\\n        s.pop();\\n        pushStack(temp->right);\\n        return temp->val;\\n    }\\n\\t\\n    // We pop the top node return its value \\n\\t// then we push its right subtree to stack to continue inorder traversal\\n\\t\\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n\\t// if stack is empty then we have already traversed out tree\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965391,
                "title": "clean-java-solution-stack",
                "content": "```\\nclass BSTIterator {\\n    \\n    Stack<TreeNode> stack; \\n\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack() ; \\n        pushLeftArmToStack(root) ;\\n    }\\n    \\n    public int next() {\\n        TreeNode node = stack.pop() ;\\n        pushLeftArmToStack(node.right) ;\\n        return node.val; \\n    }\\n    \\n    public boolean hasNext() {\\n        return !stack.isEmpty() ;\\n    }\\n    \\n    private void pushLeftArmToStack(TreeNode node) {\\n        while(node != null) {\\n            stack.push(node) ;\\n            node = node.left; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator {\\n    \\n    Stack<TreeNode> stack; \\n\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack() ; \\n        pushLeftArmToStack(root) ;\\n    }\\n    \\n    public int next() {\\n        TreeNode node = stack.pop() ;\\n        pushLeftArmToStack(node.right) ;\\n        return node.val; \\n    }\\n    \\n    public boolean hasNext() {\\n        return !stack.isEmpty() ;\\n    }\\n    \\n    private void pushLeftArmToStack(TreeNode node) {\\n        while(node != null) {\\n            stack.push(node) ;\\n            node = node.left; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965173,
                "title": "easy-to-understand-next-hasnext-o-1-time-o-h-space-average",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        \\n\\t\\t#iterates until it finds the node with the lowest value, takes O(h) time and space\\n        current = root\\n        while current:\\n            self.stack.append(current)\\n            current = current.left\\n          \\n    def next(self) -> int:\\n\\t\\t#gets element with lowest value\\n        lowest = self.stack.pop()\\n        \\n\\t\\t#sucessor of a node A = node with value greater than node A.val, but lower than everyone else\\'s value in the tree.\\n\\t\\t#finds \"lowest\" sucessor if it is not in the stack already\\n        suc = None\\n        if lowest.right:\\n            suc = lowest.right\\n        while suc:\\n            self.stack.append(suc)\\n            suc = suc.left\\n\\n        return lowest.val\\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack) > 0\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        \\n\\t\\t#iterates until it finds the node with the lowest value, takes O(h) time and space\\n        current = root\\n        while current:\\n            self.stack.append(current)\\n            current = current.left\\n          \\n    def next(self) -> int:\\n\\t\\t#gets element with lowest value\\n        lowest = self.stack.pop()\\n        \\n\\t\\t#sucessor of a node A = node with value greater than node A.val, but lower than everyone else\\'s value in the tree.\\n\\t\\t#finds \"lowest\" sucessor if it is not in the stack already\\n        suc = None\\n        if lowest.right:\\n            suc = lowest.right\\n        while suc:\\n            self.stack.append(suc)\\n            suc = suc.left\\n\\n        return lowest.val\\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack) > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895239,
                "title": "python-stack",
                "content": "```\\nclass BSTIterator:\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        self.__populateLeftSubtree(root)\\n\\n        \\n    def next(self) -> int:\\n        next = self.stack.pop()\\n        \\n        self.__populateLeftSubtree(next.right)\\n        return next.val\\n\\n        \\n    def hasNext(self) -> bool:\\n        return self.stack\\n        \\n    \\n    def __populateLeftSubtree(self, node) -> None:            \\n        while node:\\n            self.stack.append(node)\\n            node = node.left\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator:\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        self.__populateLeftSubtree(root)\\n\\n        \\n    def next(self) -> int:\\n        next = self.stack.pop()\\n        \\n        self.__populateLeftSubtree(next.right)\\n        return next.val\\n\\n        \\n    def hasNext(self) -> bool:\\n        return self.stack\\n        \\n    \\n    def __populateLeftSubtree(self, node) -> None:            \\n        while node:\\n            self.stack.append(node)\\n            node = node.left\\n",
                "codeTag": "Java"
            },
            {
                "id": 1612075,
                "title": "c-t-o-1-s-o-n-storing-in-order-traversal-in-vector",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator final {\\npublic:\\n    explicit BSTIterator() noexcept = default;\\n    explicit BSTIterator(const BSTIterator&) noexcept = default;\\n\\n    BSTIterator(const TreeNode* root) {\\n        setInOrderTraversal(root);\\n    }\\n\\n    int next() noexcept { return inOrderTraversal_[iterator_++]; }\\n    bool hasNext() const noexcept { return iterator_ < inOrderTraversal_.size(); }\\n\\nprivate:\\n    std::vector<int> inOrderTraversal_;\\n    int iterator_ = 0;\\n\\n    void setInOrderTraversal(const TreeNode* root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n\\n        setInOrderTraversal(root->left);\\n        inOrderTraversal_.push_back(root->val);\\n        setInOrderTraversal(root->right);\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator final {\\npublic:\\n    explicit BSTIterator() noexcept = default;\\n    explicit BSTIterator(const BSTIterator&) noexcept = default;\\n\\n    BSTIterator(const TreeNode* root) {\\n        setInOrderTraversal(root);\\n    }\\n\\n    int next() noexcept { return inOrderTraversal_[iterator_++]; }\\n    bool hasNext() const noexcept { return iterator_ < inOrderTraversal_.size(); }\\n\\nprivate:\\n    std::vector<int> inOrderTraversal_;\\n    int iterator_ = 0;\\n\\n    void setInOrderTraversal(const TreeNode* root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n\\n        setInOrderTraversal(root->left);\\n        inOrderTraversal_.push_back(root->val);\\n        setInOrderTraversal(root->right);\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595906,
                "title": "simple-inorder-tree-iterator-using-stack",
                "content": "```\\n    public class BSTIterator\\n    {\\n        Stack<TreeNode> st;\\n        public BSTIterator(TreeNode root)\\n        {\\n            st = new Stack<TreeNode>();\\n            PopulateStack(root);\\n        }\\n\\n        private void PopulateStack(TreeNode root)\\n        {\\n            while (root != null)\\n            {\\n                st.Push(root);\\n                root = root.left;\\n            }\\n        }\\n\\n        public int Next()\\n        {\\n            var root = st.Pop();\\n            var val = root.val;\\n\\n            root = root.right;\\n            PopulateStack(root);\\n            return val;\\n        }\\n\\n        public bool HasNext()\\n        {\\n            return st.Count() > 0;\\n        }\\n    }",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\n    public class BSTIterator\\n    {\\n        Stack<TreeNode> st;\\n        public BSTIterator(TreeNode root)\\n        {\\n            st = new Stack<TreeNode>();\\n            PopulateStack(root);\\n        }\\n\\n        private void PopulateStack(TreeNode root)\\n        {\\n            while (root != null)\\n            {\\n                st.Push(root);\\n                root = root.left;\\n            }\\n        }\\n\\n        public int Next()\\n        {\\n            var root = st.Pop();\\n            var val = root.val;\\n\\n            root = root.right;\\n            PopulateStack(root);\\n            return val;\\n        }\\n\\n        public bool HasNext()\\n        {\\n            return st.Count() > 0;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1390883,
                "title": "using-python-generator-time-o-1-space-o-1",
                "content": "We can use **python Generators** to achieve **O(1)** time complexity and **O(1)** space complexity for *next()* & *hasNext()* in best case. In worst case time complexity -> **O(1)** and space complexity will be **O(p)** where **p** is **min(Times *hasNext()* called, Total num of Nodes)**\\n\\nThis is possible because python ***Generators*** have capability to **pause** function execution  untill ***next()*** call is made. This means there is no need to precalculate and store stuff anywhere! Everything is calculated at runtime in **O(1)** time & space complexity.\\n\\nThe only catch here is that it doesn\\'t have ***hasNext()*** functionality inbuilt. So we have to create a ***deque*** to store intermediate result everytime **hasNext()** function is called.\\n\\n# Steps:\\n1.  Build a *generator function *to traverse the ***BST*** in ***inorder*** manner.\\n2.  **In next() function**: Check if **backupQueue**(which we created to store intermediate results) has any elements?\\n\\t* If backupQueue is emply then simple fetch next output from the generator.\\n\\t* Else take the leftmost element form the backupQueue.\\n3. **in hasNext() function**: Simply try to fetch the **next** *generator output* and store it in the **queue** (Because it will be required later in **next() function**) & return **True**.  If there is not next element remaining, generator will throw an **exception**.  In that case return **False**.\\n\\nIt goes something like this,\\n\\n```python\\nfrom collections import deque\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        def bstTraverser(root):\\n            if root:\\n                yield from bstTraverser(root.left)\\n                yield root.val\\n                yield from bstTraverser(root.right)\\n                \\n        self.backupList = deque()\\n        self.gen_obj = bstTraverser(root)    \\n                \\n    def next(self) -> int:\\n        if self.backupList:\\n            return self.backupList.popleft()\\n        return next(self.gen_obj)\\n    \\n    def hasNext(self) -> bool:\\n        try:\\n            self.backupList.append(next(self.gen_obj))\\n            return True\\n        except Exception:\\n            return False\\n\\n```\\n\\nThis is not a fast solution. But it\\'s a fun one!",
                "solutionTags": [],
                "code": "```python\\nfrom collections import deque\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        def bstTraverser(root):\\n            if root:\\n                yield from bstTraverser(root.left)\\n                yield root.val\\n                yield from bstTraverser(root.right)\\n                \\n        self.backupList = deque()\\n        self.gen_obj = bstTraverser(root)    \\n                \\n    def next(self) -> int:\\n        if self.backupList:\\n            return self.backupList.popleft()\\n        return next(self.gen_obj)\\n    \\n    def hasNext(self) -> bool:\\n        try:\\n            self.backupList.append(next(self.gen_obj))\\n            return True\\n        except Exception:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364342,
                "title": "golang-stack-time-o-n-space-o-height",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\ntype BSTIterator struct {\\n    st []*TreeNode\\n}\\n\\n\\nfunc Constructor(root *TreeNode) BSTIterator {\\n    iterator := BSTIterator{}\\n    for root != nil {\\n        iterator.st = append(iterator.st, root)\\n        root = root.Left\\n    }\\n    return iterator\\n}\\n\\n\\nfunc (this *BSTIterator) Next() int {\\n    n := len(this.st)\\n    cur := this.st[n-1]\\n    this.st = this.st[:n-1]\\n    res := cur.Val\\n    cur = cur.Right\\n    for cur != nil {\\n        this.st = append(this.st, cur)\\n        cur = cur.Left\\n    }\\n    return res\\n}\\n\\n\\nfunc (this *BSTIterator) HasNext() bool {\\n    return len(this.st) > 0\\n}\\n\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * obj := Constructor(root);\\n * param_1 := obj.Next();\\n * param_2 := obj.HasNext();\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\ntype BSTIterator struct {\\n    st []*TreeNode\\n}\\n\\n\\nfunc Constructor(root *TreeNode) BSTIterator {\\n    iterator := BSTIterator{}\\n    for root != nil {\\n        iterator.st = append(iterator.st, root)\\n        root = root.Left\\n    }\\n    return iterator\\n}\\n\\n\\nfunc (this *BSTIterator) Next() int {\\n    n := len(this.st)\\n    cur := this.st[n-1]\\n    this.st = this.st[:n-1]\\n    res := cur.Val\\n    cur = cur.Right\\n    for cur != nil {\\n        this.st = append(this.st, cur)\\n        cur = cur.Left\\n    }\\n    return res\\n}\\n\\n\\nfunc (this *BSTIterator) HasNext() bool {\\n    return len(this.st) > 0\\n}\\n\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * obj := Constructor(root);\\n * param_1 := obj.Next();\\n * param_2 := obj.HasNext();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351190,
                "title": "java-easy-approach-with-explanation-o-n-stack",
                "content": "```\\nclass BSTIterator\\n{//iterative inorder traversal (inorder of BST is sorted)\\n    ArrayDeque<TreeNode> stack;//Faster than stack \\n    \\n    private void pushAll(TreeNode temp){\\n        //pushing the left nodes on the stack until we reach the null node \\n        while(temp != null){\\n            stack.addLast(temp);//pushing to the stack \\n            temp= temp.left;//moving the left subtree\\n        }\\n    }\\n    \\n    public BSTIterator(TreeNode root) {//parameterised constructor \\n        stack= new ArrayDeque<>();//intializing stack \\n        pushAll(root);\\n    }\\n    \\n    public int next(){\\n        TreeNode pop= stack.removeLast();//smallest element till now \\n        pushAll(pop.right);//pushing all the right node in inorder fashion\\n        return pop.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        if(!stack.isEmpty())//if stack is empty there is no element in the stack, otherwise there is atleast one \\n            return true;\\n        return false;\\n    }\\n}//Please do Upvote, it helps alot\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass BSTIterator\\n{//iterative inorder traversal (inorder of BST is sorted)\\n    ArrayDeque<TreeNode> stack;//Faster than stack \\n    \\n    private void pushAll(TreeNode temp){\\n        //pushing the left nodes on the stack until we reach the null node \\n        while(temp != null){\\n            stack.addLast(temp);//pushing to the stack \\n            temp= temp.left;//moving the left subtree\\n        }\\n    }\\n    \\n    public BSTIterator(TreeNode root) {//parameterised constructor \\n        stack= new ArrayDeque<>();//intializing stack \\n        pushAll(root);\\n    }\\n    \\n    public int next(){\\n        TreeNode pop= stack.removeLast();//smallest element till now \\n        pushAll(pop.right);//pushing all the right node in inorder fashion\\n        return pop.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        if(!stack.isEmpty())//if stack is empty there is no element in the stack, otherwise there is atleast one \\n            return true;\\n        return false;\\n    }\\n}//Please do Upvote, it helps alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342658,
                "title": "python-yield-from",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(root):\\n            if root:\\n                yield from inorder(root.left)\\n                yield root.val\\n                yield from inorder(root.right)\\n        self.iterable = inorder(root)\\n        self._next = next(self.iterable, None)\\n\\n    def next(self) -> int:\\n        _next = self._next\\n        self._next = next(self.iterable, None)\\n        return _next\\n\\n    def hasNext(self) -> bool:\\n        return self._next is not None\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(root):\\n            if root:\\n                yield from inorder(root.left)\\n                yield root.val\\n                yield from inorder(root.right)\\n        self.iterable = inorder(root)\\n        self._next = next(self.iterable, None)\\n\\n    def next(self) -> int:\\n        _next = self._next\\n        self._next = next(self.iterable, None)\\n        return _next\\n\\n    def hasNext(self) -> bool:\\n        return self._next is not None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152226,
                "title": "c-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\n    private:\\n    stack<TreeNode*> st; // this stack will always hold atmost height of the tree\\n    void populateLeftSide(TreeNode* root){ // populate left subtree of the root\\n        while(root){\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\npublic:\\n    BSTIterator(TreeNode* root) {\\n        st = stack<TreeNode*>();\\n        populateLeftSide(root); // init with left subtree of the root\\n    }\\n    \\n    int next() {\\n        TreeNode* top = st.top(); st.pop(); // top element will be returned\\n        if(top->right){ // if there exists a right subtree of the top element, populate in the stack\\n            populateLeftSide(top->right);\\n        }\\n        \\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty(); // simply return if the stack is non-empty\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\n    private:\\n    stack<TreeNode*> st; // this stack will always hold atmost height of the tree\\n    void populateLeftSide(TreeNode* root){ // populate left subtree of the root\\n        while(root){\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\npublic:\\n    BSTIterator(TreeNode* root) {\\n        st = stack<TreeNode*>();\\n        populateLeftSide(root); // init with left subtree of the root\\n    }\\n    \\n    int next() {\\n        TreeNode* top = st.top(); st.pop(); // top element will be returned\\n        if(top->right){ // if there exists a right subtree of the top element, populate in the stack\\n            populateLeftSide(top->right);\\n        }\\n        \\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty(); // simply return if the stack is non-empty\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047309,
                "title": "c-using-stack",
                "content": "\\n\\n    class BSTIterator {\\n    public:\\n        BSTIterator(TreeNode* root) {\\n\\t\\t\\tTreeNode* cur = root;\\n\\t\\t\\twhile(cur) {\\n\\t\\t\\t\\tstk.push(cur);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t}\\n        }\\n    \\n        int next() {\\n\\t\\t\\tTreeNode* cur = stk.top();\\n\\t\\t\\tint res = cur->val;\\n\\t\\t\\tstk.pop();\\n\\n\\t\\t\\tcur = cur->right;\\n\\t\\t\\twhile(cur) {\\n\\t\\t\\t\\tstk.push(cur);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n    \\n\\t\\tbool hasNext() {\\n\\t\\t\\treturn !stk.empty();\\n\\t\\t}\\n    \\n\\tprivate:\\n\\t\\t\\tstd::stack<TreeNode*> stk;\\n\\t};",
                "solutionTags": [],
                "code": "\\n\\n    class BSTIterator {\\n    public:\\n        BSTIterator(TreeNode* root) {\\n\\t\\t\\tTreeNode* cur = root;\\n\\t\\t\\twhile(cur) {\\n\\t\\t\\t\\tstk.push(cur);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t}\\n        }\\n    \\n        int next() {\\n\\t\\t\\tTreeNode* cur = stk.top();\\n\\t\\t\\tint res = cur->val;\\n\\t\\t\\tstk.pop();\\n\\n\\t\\t\\tcur = cur->right;\\n\\t\\t\\twhile(cur) {\\n\\t\\t\\t\\tstk.push(cur);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n    \\n\\t\\tbool hasNext() {\\n\\t\\t\\treturn !stk.empty();\\n\\t\\t}\\n    \\n\\tprivate:\\n\\t\\t\\tstd::stack<TreeNode*> stk;\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 979316,
                "title": "c-queue-with-simple-explanation",
                "content": "**Stats:**\\nRuntime: 140 ms, faster than 94.63% of C# online submissions for Binary Search Tree Iterator.\\nMemory Usage: 38.2 MB, less than 71.99% of C# online submissions for Binary Search Tree Iterator.\\n**Algo**\\n* This builds off knowledge of inorder traversal. Since that prev implementation builds on a list - it\\'s easy to see that this one is a similar data structure except that instead of list we use queue (FIFO)\\n* In the constructur, we use the same traversal logic but with a queue\\n* That makes the job of Next and HasNext trivial as we\\'re just going down the queue \\n\\n```\\npublic class BSTIterator {\\n\\n    Queue<int> q = new Queue<int>();\\n    public BSTIterator(TreeNode root) {\\n        Traverse(root, q);\\n    }\\n    \\n    private void Traverse(TreeNode root, Queue<int> q){\\n\\n        if(root!=null){\\n            Traverse(root.left, q);\\n            q.Enqueue(root.val);\\n            Traverse(root.right, q);\\n        }\\n    }\\n    \\n    public int Next() {\\n        \\n        return q.Dequeue();\\n    }\\n    \\n    public bool HasNext() {\\n\\n        return q.Any();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class BSTIterator {\\n\\n    Queue<int> q = new Queue<int>();\\n    public BSTIterator(TreeNode root) {\\n        Traverse(root, q);\\n    }\\n    \\n    private void Traverse(TreeNode root, Queue<int> q){\\n\\n        if(root!=null){\\n            Traverse(root.left, q);\\n            q.Enqueue(root.val);\\n            Traverse(root.right, q);\\n        }\\n    }\\n    \\n    public int Next() {\\n        \\n        return q.Dequeue();\\n    }\\n    \\n    public bool HasNext() {\\n\\n        return q.Any();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966733,
                "title": "python-linkedlist-solution-descriptive-code-92-runtime",
                "content": "Code is very readable. If you have any questions feel free.\\n**Idea:** In-order traversal the tree and create a Linked List.\\nThen simply return the values in ascending order on the linked list\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# BSTIterator =========\\nclass BSTIterator:\\n    def __init__(self, root: TreeNode):\\n        self.tree: TreeNode = root\\n        self.linked_list = LinkedList.init_from_binarytree(root)\\n        \\n\\n    def next(self) -> int:\\n        self.linked_list.head = self.linked_list.head.next\\n        return self.linked_list.head.val\\n\\n    def hasNext(self) -> bool:\\n        return not self.linked_list.head.next == None\\n    \\n# Linked List Node  =========\\nclass LinkedListNode:\\n    def __init__(self, val, _next = None):\\n        self.val = val\\n        self.next = _next\\n    \\n# Linked List =========\\nclass LinkedList:\\n    def __init__(self):\\n        self.head = LinkedListNode(\"dummy\")\\n        self.tail = self.head\\n        \\n    def add(self, val):\\n        self.tail.next = LinkedListNode(val)\\n        self.tail = self.tail.next\\n        \\n    @staticmethod\\n    def init_from_binarytree(tree_root):\\n        linked_list = LinkedList()\\n        \\n        def in_order_and_set_list(root):\\n            if not root:\\n                return None\\n            \\n            in_order_and_set_list(root.left)\\n            linked_list.add(root.val)\\n            in_order_and_set_list(root.right)\\n        \\n        in_order_and_set_list(tree_root)\\n        return linked_list\\n            \\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# BSTIterator =========\\nclass BSTIterator:\\n    def __init__(self, root: TreeNode):\\n        self.tree: TreeNode = root\\n        self.linked_list = LinkedList.init_from_binarytree(root)\\n        \\n\\n    def next(self) -> int:\\n        self.linked_list.head = self.linked_list.head.next\\n        return self.linked_list.head.val\\n\\n    def hasNext(self) -> bool:\\n        return not self.linked_list.head.next == None\\n    \\n# Linked List Node  =========\\nclass LinkedListNode:\\n    def __init__(self, val, _next = None):\\n        self.val = val\\n        self.next = _next\\n    \\n# Linked List =========\\nclass LinkedList:\\n    def __init__(self):\\n        self.head = LinkedListNode(\"dummy\")\\n        self.tail = self.head\\n        \\n    def add(self, val):\\n        self.tail.next = LinkedListNode(val)\\n        self.tail = self.tail.next\\n        \\n    @staticmethod\\n    def init_from_binarytree(tree_root):\\n        linked_list = LinkedList()\\n        \\n        def in_order_and_set_list(root):\\n            if not root:\\n                return None\\n            \\n            in_order_and_set_list(root.left)\\n            linked_list.add(root.val)\\n            in_order_and_set_list(root.right)\\n        \\n        in_order_and_set_list(tree_root)\\n        return linked_list\\n            \\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886855,
                "title": "python-intuitive-implementaion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.ans=[]\\n        def helper(root):\\n            if root is None:\\n                return\\n            helper(root.left)\\n            self.ans.append(root.val)\\n            helper(root.right)\\n        helper(root)\\n        self.i=0\\n        self.l=len(self.ans)\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        self.i+=1\\n        return self.ans[self.i-1]\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        return self.i!=self.l\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.ans=[]\\n        def helper(root):\\n            if root is None:\\n                return\\n            helper(root.left)\\n            self.ans.append(root.val)\\n            helper(root.right)\\n        helper(root)\\n        self.i=0\\n        self.l=len(self.ans)\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        self.i+=1\\n        return self.ans[self.i-1]\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        return self.i!=self.l\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546816,
                "title": "python-99",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.put(root)\\n        \\n    def put(self,root):\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    def next(self) -> int:\\n        temp = self.stack.pop()\\n        self.put(temp.right)\\n        return temp.val\\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack)>0\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.put(root)\\n        \\n    def put(self,root):\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    def next(self) -> int:\\n        temp = self.stack.pop()\\n        self.put(temp.right)\\n        return temp.val\\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack)>0\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512926,
                "title": "python3-solution-using-queue",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n        self.queue = []\\n        self.get_result(self.root)\\n\\n    def next(self) -> int:\\n        return self.queue.pop(0)\\n            \\n        \\n    def get_result(self,root):\\n        if root==None:\\n            return\\n        self.get_result(root.left)\\n        self.queue.append(root.val)\\n        self.get_result(root.right)\\n            \\n        \\n    def hasNext(self) -> bool:\\n        return not len(self.queue)==0\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n        self.queue = []\\n        self.get_result(self.root)\\n\\n    def next(self) -> int:\\n        return self.queue.pop(0)\\n            \\n        \\n    def get_result(self,root):\\n        if root==None:\\n            return\\n        self.get_result(root.left)\\n        self.queue.append(root.val)\\n        self.get_result(root.right)\\n            \\n        \\n    def hasNext(self) -> bool:\\n        return not len(self.queue)==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512925,
                "title": "python3-recursive-solution",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n        self.prev = float(\"-inf\")\\n        self.prev_ = float(\"-inf\")\\n\\n    def next(self) -> int:\\n        if self.prev_>self.prev:\\n            self.prev = self.prev_\\n        else:\\n            self.prev = self.get_result(self.root)\\n        return self.prev\\n            \\n        \\n    def get_result(self,root):\\n        if root==None:\\n            return None\\n        x = None\\n        if self.prev<root.val:\\n            x = self.get_result(root.left)\\n        else:\\n            x = self.get_result(root.right)\\n        if x==None and root.val>self.prev:\\n            return root.val\\n        return x \\n            \\n        \\n    def hasNext(self) -> bool:\\n        if self.root==None:\\n            return False\\n        x = self.get_result(self.root)\\n        if x==None:\\n            return False\\n        else:\\n            self.prev_ = x\\n            return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n        self.prev = float(\"-inf\")\\n        self.prev_ = float(\"-inf\")\\n\\n    def next(self) -> int:\\n        if self.prev_>self.prev:\\n            self.prev = self.prev_\\n        else:\\n            self.prev = self.get_result(self.root)\\n        return self.prev\\n            \\n        \\n    def get_result(self,root):\\n        if root==None:\\n            return None\\n        x = None\\n        if self.prev<root.val:\\n            x = self.get_result(root.left)\\n        else:\\n            x = self.get_result(root.right)\\n        if x==None and root.val>self.prev:\\n            return root.val\\n        return x \\n            \\n        \\n    def hasNext(self) -> bool:\\n        if self.root==None:\\n            return False\\n        x = self.get_result(self.root)\\n        if x==None:\\n            return False\\n        else:\\n            self.prev_ = x\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318432,
                "title": "python3-beats-99",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.push_lefts(root)\\n    \\n    def push_lefts(self,node):\\n        while node:\\n            self.stack.append(node)\\n            node = node.left\\n            \\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        node = self.stack.pop()\\n        self.push_lefts(node.right)\\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        return len(self.stack) > 0\\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.push_lefts(root)\\n    \\n    def push_lefts(self,node):\\n        while node:\\n            self.stack.append(node)\\n            node = node.left\\n            \\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        node = self.stack.pop()\\n        self.push_lefts(node.right)\\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        return len(self.stack) > 0\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 293278,
                "title": "c-inorder",
                "content": "```\\npublic class BSTIterator {\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        while (root != null) {\\n            stack.Push(root);\\n            root = root.left;\\n        }\\n    }\\n\\n    /** @return the next smallest number */\\n    public int Next() {\\n        var next = stack.Pop();\\n        if (next.right != null) {\\n            var cur = next.right;\\n            while (cur != null) {\\n                stack.Push(cur);\\n                cur = cur.left;\\n            }\\n        }\\n        return next.val;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() {\\n        return stack.Any();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class BSTIterator {\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        while (root != null) {\\n            stack.Push(root);\\n            root = root.left;\\n        }\\n    }\\n\\n    /** @return the next smallest number */\\n    public int Next() {\\n        var next = stack.Pop();\\n        if (next.right != null) {\\n            var cur = next.right;\\n            while (cur != null) {\\n                stack.Push(cur);\\n                cur = cur.left;\\n            }\\n        }\\n        return next.val;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() {\\n        return stack.Any();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189517,
                "title": "c-solution-using-enumerator-interface",
                "content": "yield return is your friend in writing any kind of iterator type thing in C#:\\n```\\npublic static class BSTIteratorExt {\\n  public static IEnumerable<TreeNode> Flatten(this TreeNode root) {\\n    if (root != null) {\\n      foreach(var node in root.left.Flatten()) yield return node;\\n      yield return root;\\n      foreach(var node in root.right.Flatten()) yield return node;\\n    }\\n  }  \\n}\\n\\npublic class BSTIterator {\\n\\n  private IEnumerator<TreeNode> enumerator;\\n  \\n  public BSTIterator(TreeNode root) {\\n    enumerator = root.Flatten().GetEnumerator();\\n  }\\n\\n  /** @return whether we have a next smallest number */\\n  public bool HasNext() {\\n    return enumerator.MoveNext();\\n  }\\n\\n  /** @return the next smallest number */\\n  public int Next() {\\n    return enumerator.Current.val;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic static class BSTIteratorExt {\\n  public static IEnumerable<TreeNode> Flatten(this TreeNode root) {\\n    if (root != null) {\\n      foreach(var node in root.left.Flatten()) yield return node;\\n      yield return root;\\n      foreach(var node in root.right.Flatten()) yield return node;\\n    }\\n  }  \\n}\\n\\npublic class BSTIterator {\\n\\n  private IEnumerator<TreeNode> enumerator;\\n  \\n  public BSTIterator(TreeNode root) {\\n    enumerator = root.Flatten().GetEnumerator();\\n  }\\n\\n  /** @return whether we have a next smallest number */\\n  public bool HasNext() {\\n    return enumerator.MoveNext();\\n  }\\n\\n  /** @return the next smallest number */\\n  public int Next() {\\n    return enumerator.Current.val;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166768,
                "title": "javascript-o-1-time-o-3h-space-explained-step-by-step",
                "content": "To make this solution `O(h)` space, we\\'re just keeping track of parent nodes on our stack, which will go through later (if they are eventually called by the client executing `next`).\\n\\nThis is how it works for `[10, 5, 15, 1, 6]`\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/1484663199409/image_1536070104.png)\\n\\nThe stack will store both TreeNode and numbers. The number will be the exit point, and the TreeNode will have to be expanded. In an OO language, or if you want to make it cleaner you could actually write a class/prototype that returned you the kind of value it is storing ([just like LeetCode NestedTree in a similar problem](https://leetcode.com/problems/flatten-nested-list-iterator/)).\\n\\nInitially we\\'ll extract the root tree node, we first push the right side, then the value of the current node\\'s and then the left side. I marked numbers as `*number*` for clarity.\\n\\n`[15, *10*, 5]`\\n\\nSince the popped value wasn\\'t a number (and the stack has values left to process) we start once again.\\n\\n`[15, 10, 6, *5*, 1]`\\n\\n5 wasn\\'t a number so we keep going\\n\\n`[15, 10, 6, *5*, *1*]`\\n\\nThe TreeNode containing value 1 didn\\'t have children. Hence the next value is going to be a number.\\n\\n`[15, 10, 6, *5*]`\\n`this.cache = 1`\\n\\nWe\\'re now done until the user requests (`next`) a new number.\\n\\n```\\n/**\\n * @constructor\\n * @param {TreeNode} root - root of the binary search tree\\n */\\nvar BSTIterator = function(root) {\\n    this.root = root;\\n    this.stack = root ? [root] : [];\\n    this.cache;\\n};\\n\\nBSTIterator.prototype.cacheNext = function() {\\n    while (this.cache === undefined && this.stack.length > 0) {\\n        const top = this.stack.pop();\\n        if (!(top instanceof TreeNode)) {\\n            // It\\'s a number\\n            this.cache = top;\\n            continue;\\n        }\\n        \\n        // It\\'s a TreeNode\\n        if (top.right) {\\n            this.stack.push(top.right);\\n        }\\n        this.stack.push(top.val);\\n        if (top.left) {\\n            this.stack.push(top.left);\\n        }\\n    }\\n    return this.cache;\\n}\\n\\n\\n/**\\n * @this BSTIterator\\n * @returns {boolean} - whether we have a next smallest number\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.cacheNext() !== undefined;\\n};\\n\\n/**\\n * @this BSTIterator\\n * @returns {number} - the next smallest number\\n */\\nBSTIterator.prototype.next = function() {\\n    const res = this.cacheNext();\\n    this.cache = undefined;\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @constructor\\n * @param {TreeNode} root - root of the binary search tree\\n */\\nvar BSTIterator = function(root) {\\n    this.root = root;\\n    this.stack = root ? [root] : [];\\n    this.cache;\\n};\\n\\nBSTIterator.prototype.cacheNext = function() {\\n    while (this.cache === undefined && this.stack.length > 0) {\\n        const top = this.stack.pop();\\n        if (!(top instanceof TreeNode)) {\\n            // It\\'s a number\\n            this.cache = top;\\n            continue;\\n        }\\n        \\n        // It\\'s a TreeNode\\n        if (top.right) {\\n            this.stack.push(top.right);\\n        }\\n        this.stack.push(top.val);\\n        if (top.left) {\\n            this.stack.push(top.left);\\n        }\\n    }\\n    return this.cache;\\n}\\n\\n\\n/**\\n * @this BSTIterator\\n * @returns {boolean} - whether we have a next smallest number\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.cacheNext() !== undefined;\\n};\\n\\n/**\\n * @this BSTIterator\\n * @returns {number} - the next smallest number\\n */\\nBSTIterator.prototype.next = function() {\\n    const res = this.cacheNext();\\n    this.cache = undefined;\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152762,
                "title": "easiest-arraylist-solution",
                "content": "\\nThe key idea is: **a inorder traverse of a Binary Search Tree should always be sorted.**\\nSo we just put everything in an ArrayList and use ArrayLIst.iterator()! O(1) for each query, and construction of such iterator is O(N).\\n\\n\\n```\\npublic class BSTIterator {\\n    ArrayList<Integer> list;\\n    Iterator<Integer> it;\\n    TreeNode root;\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.root = root;\\n        list =  new ArrayList<Integer>();\\n        inorderTraversal(list, root);\\n        it = list.iterator();\\n    }\\n    \\n    private void inorderTraversal(ArrayList<Integer> list, TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.left != null){\\n            inorderTraversal(list, root.left);\\n        }\\n        list.add(root.val);\\n        if(root.right != null){\\n            inorderTraversal(list, root.right);\\n        }\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return it.hasNext();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        return it.next();      \\n    }\\n}\\n```\\nHope you enjoy this solution :D",
                "solutionTags": [],
                "code": "```\\npublic class BSTIterator {\\n    ArrayList<Integer> list;\\n    Iterator<Integer> it;\\n    TreeNode root;\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.root = root;\\n        list =  new ArrayList<Integer>();\\n        inorderTraversal(list, root);\\n        it = list.iterator();\\n    }\\n    \\n    private void inorderTraversal(ArrayList<Integer> list, TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.left != null){\\n            inorderTraversal(list, root.left);\\n        }\\n        list.add(root.val);\\n        if(root.right != null){\\n            inorderTraversal(list, root.right);\\n        }\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return it.hasNext();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        return it.next();      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52629,
                "title": "4ms-java-solution-beats-99-83",
                "content": "```\\nprivate TreeNode crt;\\n    public BSTIterator(TreeNode root) {\\n        crt = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return crt != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        while (crt.left != null) {\\n            TreeNode temp = crt.left;\\n            while (temp.right != null && temp.right != crt) temp = temp.right;\\n            if (temp.right == null) {\\n                temp.right = crt;\\n                crt = crt.left;\\n            } else {\\n                temp.right = null;\\n                break;\\n            }\\n        }\\n        int re = crt.val;\\n        crt = crt.right;\\n        return re;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate TreeNode crt;\\n    public BSTIterator(TreeNode root) {\\n        crt = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return crt != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        while (crt.left != null) {\\n            TreeNode temp = crt.left;\\n            while (temp.right != null && temp.right != crt) temp = temp.right;\\n            if (temp.right == null) {\\n                temp.right = crt;\\n                crt = crt.left;\\n            } else {\\n                temp.right = null;\\n                break;\\n            }\\n        }\\n        int re = crt.val;\\n        crt = crt.right;\\n        return re;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52639,
                "title": "o-1-space-with-same-time-complex-of-stack-solution-morris-traversal-of-tree",
                "content": "The Stack solution seems use O(h) space well the time complex of next() function is more than O(1). \\nI try to use Morris Tree Traversal to solve this issue which saves space. However the time complex of construction of the class BSTIterator is O(n) (instead of O(h) to building  the Stack). Time complex of next() function keep the same, between O(1) and O(h), since we are always have to find the right child node's most left child.\\n```\\n/**\\n * Definition for binary tree\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\npublic class BSTIterator {\\n    private TreeNode head = null;\\n    \\n    public BSTIterator(TreeNode root) {\\n        TreeNode pre = null;\\n        TreeNode cur = root;\\n        while (cur != null) {\\n            if (cur.left != null) {\\n                pre = cur.left;\\n                while (pre.right != null && pre.right != cur) {\\n                    pre = pre.right;\\n                }\\n                if (pre.right == null) {\\n                    pre.right = cur;\\n                    cur = cur.left;\\n                } else {\\n                    cur = cur.right;\\n                }\\n            } else {\\n                if (head == null) head = cur;\\n                cur = cur.right;\\n            }\\n        }\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return head != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        int ret = head.val;\\n        TreeNode nextNode = head.right;\\n        if (nextNode != null) {\\n            while (nextNode.left != null && nextNode.left.val > head.val) {\\n                nextNode = nextNode.left;\\n            }\\n        } \\n        head = nextNode;\\n        \\n        return ret;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * BSTIterator i = new BSTIterator(root);\\n * while (i.hasNext()) v[f()] = i.next();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for binary tree\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\npublic class BSTIterator {\\n    private TreeNode head = null;\\n    \\n    public BSTIterator(TreeNode root) {\\n        TreeNode pre = null;\\n        TreeNode cur = root;\\n        while (cur != null) {\\n            if (cur.left != null) {\\n                pre = cur.left;\\n                while (pre.right != null && pre.right != cur) {\\n                    pre = pre.right;\\n                }\\n                if (pre.right == null) {\\n                    pre.right = cur;\\n                    cur = cur.left;\\n                } else {\\n                    cur = cur.right;\\n                }\\n            } else {\\n                if (head == null) head = cur;\\n                cur = cur.right;\\n            }\\n        }\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return head != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        int ret = head.val;\\n        TreeNode nextNode = head.right;\\n        if (nextNode != null) {\\n            while (nextNode.left != null && nextNode.left.val > head.val) {\\n                nextNode = nextNode.left;\\n            }\\n        } \\n        head = nextNode;\\n        \\n        return ret;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * BSTIterator i = new BSTIterator(root);\\n * while (i.hasNext()) v[f()] = i.next();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52649,
                "title": "java-solution-taking-o-1-space-and-o-1-time-beating-99-submissions",
                "content": " A typical Morris traversal approach.\\n\\n\\n    public class BSTIterator {\\n        \\n        private TreeNode current;\\n        \\n        public BSTIterator(TreeNode root) {\\n            current = threadAllNodesOnLeftMostBranch(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return current != null;\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            int result = current.val;\\n            \\n            current = current.right;\\n            // If thread(current) returns false, it means that the left sub tree of current is visited.\\n            // So there's no need to call threadAllNodesOnLeftMostBranch on current.\\n            if (current != null && current.left != null && thread(current)) {\\n                // current is already threaded in the if statement, skip it.\\n                current = current.left;\\n                current = threadAllNodesOnLeftMostBranch(current);\\n            }\\n            \\n            return result;\\n        }\\n        \\n        // Thread all nodes on TreeNode root's left-most branch until it reaches the last node on the branch,\\n        // and return the last node\\n        private TreeNode threadAllNodesOnLeftMostBranch(TreeNode root) {\\n            while (root != null && root.left != null) {\\n                   thread(root);\\n                   root = root.left;\\n            }\\n            \\n            return root;\\n        }\\n        \\n        // Thread or unthread TreeNode root with its successor\\n        // Return true if the operation turns out as a threading, and false if unthreading.\\n        private boolean thread(TreeNode root) {\\n            TreeNode predecessor  = root.left;\\n            while (predecessor.right != null && predecessor.right != root) {\\n                predecessor = predecessor.right;\\n            }\\n            if (predecessor.right == null) {\\n                predecessor.right = root;\\n                return true;\\n            } else {\\n                predecessor.right = null;\\n                return false;\\n            }\\n        }\\n    }\\n\\n\\n\\nThese solutions also take O(1) space and O(1) time:\\n\\n[The most voted one][1] has an overhead for threading the tree, it's not as fast as other solutions.\\n\\n[A good approach which does not break the tree][2], the implementation not very concise.\\n\\n[Another approach which breaks the tree structure][3]\\n\\n\\n  [1]: https://leetcode.com/discuss/58469/solution-space-amortized-time-using-morris-tree-traversal\\n  [2]: https://leetcode.com/discuss/22075/solution-morris-traversal-method-space-hasnext-amortized\\n  [3]: https://leetcode.com/discuss/63980/o-1-time-o-1-space-in-worst-case-challenge-me-please",
                "solutionTags": [
                    "Java"
                ],
                "code": " A typical Morris traversal approach.\\n\\n\\n    public class BSTIterator {\\n        \\n        private TreeNode current;\\n        \\n        public BSTIterator(TreeNode root) {\\n            current = threadAllNodesOnLeftMostBranch(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return current != null;\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            int result = current.val;\\n            \\n            current = current.right;\\n            // If thread(current) returns false, it means that the left sub tree of current is visited.\\n            // So there's no need to call threadAllNodesOnLeftMostBranch on current.\\n            if (current != null && current.left != null && thread(current)) {\\n                // current is already threaded in the if statement, skip it.\\n                current = current.left;\\n                current = threadAllNodesOnLeftMostBranch(current);\\n            }\\n            \\n            return result;\\n        }\\n        \\n        // Thread all nodes on TreeNode root's left-most branch until it reaches the last node on the branch,\\n        // and return the last node\\n        private TreeNode threadAllNodesOnLeftMostBranch(TreeNode root) {\\n            while (root != null && root.left != null) {\\n                   thread(root);\\n                   root = root.left;\\n            }\\n            \\n            return root;\\n        }\\n        \\n        // Thread or unthread TreeNode root with its successor\\n        // Return true if the operation turns out as a threading, and false if unthreading.\\n        private boolean thread(TreeNode root) {\\n            TreeNode predecessor  = root.left;\\n            while (predecessor.right != null && predecessor.right != root) {\\n                predecessor = predecessor.right;\\n            }\\n            if (predecessor.right == null) {\\n                predecessor.right = root;\\n                return true;\\n            } else {\\n                predecessor.right = null;\\n                return false;\\n            }\\n        }\\n    }\\n\\n\\n\\nThese solutions also take O(1) space and O(1) time:\\n\\n[The most voted one][1] has an overhead for threading the tree, it's not as fast as other solutions.\\n\\n[A good approach which does not break the tree][2], the implementation not very concise.\\n\\n[Another approach which breaks the tree structure][3]\\n\\n\\n  [1]: https://leetcode.com/discuss/58469/solution-space-amortized-time-using-morris-tree-traversal\\n  [2]: https://leetcode.com/discuss/22075/solution-morris-traversal-method-space-hasnext-amortized\\n  [3]: https://leetcode.com/discuss/63980/o-1-time-o-1-space-in-worst-case-challenge-me-please",
                "codeTag": "Java"
            },
            {
                "id": 52729,
                "title": "c-solution-using-iterative-inorder-traversal",
                "content": "    class BSTIterator {\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            p = root;\\n            while (p) {\\n                s.push(p);\\n                p = p->left;\\n            }\\n        }\\n\\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !s.empty() || p;\\n        }\\n\\n        /** @return the next smallest number */\\n        int next() {\\n            while (p) {\\n                s.push(p);\\n                p = p->left;\\n            }\\n            p = s.top();\\n            int val = p->val;\\n        \\n            s.pop();\\n            p = p->right;\\n        \\n            return val;\\n        }\\n        TreeNode *p;\\n        stack<TreeNode*> s;\\n      };",
                "solutionTags": [],
                "code": "    class BSTIterator {\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            p = root;\\n            while (p) {\\n                s.push(p);\\n                p = p->left;\\n            }\\n        }\\n\\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !s.empty() || p;\\n        }\\n\\n        /** @return the next smallest number */\\n        int next() {\\n            while (p) {\\n                s.push(p);\\n                p = p->left;\\n            }\\n            p = s.top();\\n            int val = p->val;\\n        \\n            s.pop();\\n            p = p->right;\\n        \\n            return val;\\n        }\\n        TreeNode *p;\\n        stack<TreeNode*> s;\\n      };",
                "codeTag": "Java"
            },
            {
                "id": 52761,
                "title": "accepted-java-solution-using-stack",
                "content": "The idea is to use a stack to store ancestors of a left child.\\n\\n    private TreeNode mCurrent;\\n\\tprivate Stack<TreeNode> mAncestors;\\n\\t\\n\\tpublic BSTIterator(TreeNode root) {\\n        this.mCurrent = root;\\n        this.mAncestors = new Stack<TreeNode>();\\n        while (mCurrent != null) {\\n        \\tmAncestors.push(mCurrent);\\n        \\tmCurrent = mCurrent.left;\\n        }\\n    }\\n\\n    public boolean hasNext() {\\n        return (mCurrent != null && mCurrent.right != null) \\n        \\t\\t|| !mAncestors.isEmpty();\\n    }\\n\\n    public int next() {\\n    \\tif (mCurrent == null) {\\n    \\t\\tmCurrent = mAncestors.pop();\\n    \\t} else if (mCurrent.right != null) {\\n    \\t\\tmCurrent = mCurrent.right;\\n    \\t\\twhile (mCurrent.left != null) {\\n            \\tmAncestors.push(mCurrent);\\n            \\tmCurrent = mCurrent.left;\\n            }\\n        } else {\\n        \\tmCurrent = mAncestors.pop();\\n        }\\n        return mCurrent.val;\\n    }",
                "solutionTags": [],
                "code": "The idea is to use a stack to store ancestors of a left child.\\n\\n    private TreeNode mCurrent;\\n\\tprivate Stack<TreeNode> mAncestors;\\n\\t\\n\\tpublic BSTIterator(TreeNode root) {\\n        this.mCurrent = root;\\n        this.mAncestors = new Stack<TreeNode>();\\n        while (mCurrent != null) {\\n        \\tmAncestors.push(mCurrent);\\n        \\tmCurrent = mCurrent.left;\\n        }\\n    }\\n\\n    public boolean hasNext() {\\n        return (mCurrent != null && mCurrent.right != null) \\n        \\t\\t|| !mAncestors.isEmpty();\\n    }\\n\\n    public int next() {\\n    \\tif (mCurrent == null) {\\n    \\t\\tmCurrent = mAncestors.pop();\\n    \\t} else if (mCurrent.right != null) {\\n    \\t\\tmCurrent = mCurrent.right;\\n    \\t\\twhile (mCurrent.left != null) {\\n            \\tmAncestors.push(mCurrent);\\n            \\tmCurrent = mCurrent.left;\\n            }\\n        } else {\\n        \\tmCurrent = mAncestors.pop();\\n        }\\n        return mCurrent.val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3557005,
                "title": "simple-solution-using-queue",
                "content": "# Complexity\\n- Time complexity:\\n  O(N) //inorder traversal during recursion\\n\\n- Space complexity:\\n O(N) \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class BSTIterator {\\n    Queue<int> q;\\n    public BSTIterator(TreeNode root) {\\n       q = new Queue<int>();   \\n       helper(root, q);   \\n    }\\n    private void helper(TreeNode root, Queue<int> q){\\n        if(root == null) return;\\n        helper(root.left, q);\\n        q.Enqueue(root.val);\\n        helper(root.right, q);\\n    }\\n    public int Next() {\\n        return q.Dequeue();\\n    }\\n    \\n    public bool HasNext() {\\n        return q.Count != 0;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.Next();\\n * bool param_2 = obj.HasNext();\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class BSTIterator {\\n    Queue<int> q;\\n    public BSTIterator(TreeNode root) {\\n       q = new Queue<int>();   \\n       helper(root, q);   \\n    }\\n    private void helper(TreeNode root, Queue<int> q){\\n        if(root == null) return;\\n        helper(root.left, q);\\n        q.Enqueue(root.val);\\n        helper(root.right, q);\\n    }\\n    public int Next() {\\n        return q.Dequeue();\\n    }\\n    \\n    public bool HasNext() {\\n        return q.Count != 0;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.Next();\\n * bool param_2 = obj.HasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294604,
                "title": "optimized-solution-o-h-space-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(H)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    Stack<TreeNode>s=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode temp=s.pop();\\n        pushAll(temp.right);\\n        return temp.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return !s.isEmpty();\\n    }\\n    public void pushAll(TreeNode node){\\n        while(node!=null){\\n            s.push(node);\\n            node=node.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    Stack<TreeNode>s=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode temp=s.pop();\\n        pushAll(temp.right);\\n        return temp.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return !s.isEmpty();\\n    }\\n    public void pushAll(TreeNode node){\\n        while(node!=null){\\n            s.push(node);\\n            node=node.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233236,
                "title": "173-binary-search-tree-iterator-java",
                "content": "```\\nclass BSTIterator {\\n    \\n    Stack<TreeNode>  st=new Stack <TreeNode> ();\\n\\n    public BSTIterator(TreeNode root) {\\n        addAll(root);\\n        \\n    }\\n    \\n    public int next() {\\n        TreeNode temp=st.pop();\\n        addAll(temp.right);\\n        return temp.val;\\n        \\n    }\\n    \\n    public boolean hasNext() {\\n    return !st.isEmpty();    \\n    }\\n    \\n    public void addAll(TreeNode root)\\n    {\\n        for(;root!=null; st.push(root) ,root=root.left);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator {\\n    \\n    Stack<TreeNode>  st=new Stack <TreeNode> ();\\n\\n    public BSTIterator(TreeNode root) {\\n        addAll(root);\\n        \\n    }\\n    \\n    public int next() {\\n        TreeNode temp=st.pop();\\n        addAll(temp.right);\\n        return temp.val;\\n        \\n    }\\n    \\n    public boolean hasNext() {\\n    return !st.isEmpty();    \\n    }\\n    \\n    public void addAll(TreeNode root)\\n    {\\n        for(;root!=null; st.push(root) ,root=root.left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204414,
                "title": "100-beats-java-solution",
                "content": "# Code\\n```\\nclass BSTIterator \\n{\\n    List<Integer> li = null ;\\n    Iterator it = null ;\\n    private void traverse( TreeNode root , List li )\\n    {\\n        if(root != null)    \\n        {\\n            traverse(root.left, li);\\n            li.add(root.val);\\n            traverse(root.right, li);\\n        }\\n    }\\n\\n    public BSTIterator(TreeNode root) \\n    {\\n        li = new ArrayList<Integer>() ;\\n        traverse(root, li);\\n        it = li.listIterator();\\n    }\\n    \\n    public int next()\\n    {\\n        return (int)it.next() ;\\n    }\\n    \\n    public boolean hasNext() \\n    {\\n        return it.hasNext();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BSTIterator \\n{\\n    List<Integer> li = null ;\\n    Iterator it = null ;\\n    private void traverse( TreeNode root , List li )\\n    {\\n        if(root != null)    \\n        {\\n            traverse(root.left, li);\\n            li.add(root.val);\\n            traverse(root.right, li);\\n        }\\n    }\\n\\n    public BSTIterator(TreeNode root) \\n    {\\n        li = new ArrayList<Integer>() ;\\n        traverse(root, li);\\n        it = li.listIterator();\\n    }\\n    \\n    public int next()\\n    {\\n        return (int)it.next() ;\\n    }\\n    \\n    public boolean hasNext() \\n    {\\n        return it.hasNext();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201425,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode* > st;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        st.push(root);\\n        inorder(root->left);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        inorder(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode* > st;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        st.push(root);\\n        inorder(root->left);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        inorder(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093329,
                "title": "beats-96-next-hasnext-o-1-time-o-n-dfs",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    TreeNode* root;\\n    vector<int>inorder;\\n    int idx;\\n    BSTIterator(TreeNode* root) {\\n        this->root=root;\\n        fill(root);\\n        idx=0;\\n    }\\n    void fill(TreeNode* curr){\\n        if(!curr)return;\\n        fill(curr->left);\\n        inorder.push_back(curr->val);\\n        fill(curr->right);\\n    }\\n    \\n    int next() {\\n        if(idx<inorder.size()){\\n            int val=inorder[idx++];\\n            return val;\\n        }\\n        else{\\n            return INT_MAX;\\n        }\\n        \\n    }\\n    \\n    bool hasNext() {\\n        return idx<=inorder.size()-1?true:false;\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    TreeNode* root;\\n    vector<int>inorder;\\n    int idx;\\n    BSTIterator(TreeNode* root) {\\n        this->root=root;\\n        fill(root);\\n        idx=0;\\n    }\\n    void fill(TreeNode* curr){\\n        if(!curr)return;\\n        fill(curr->left);\\n        inorder.push_back(curr->val);\\n        fill(curr->right);\\n    }\\n    \\n    int next() {\\n        if(idx<inorder.size()){\\n            int val=inorder[idx++];\\n            return val;\\n        }\\n        else{\\n            return INT_MAX;\\n        }\\n        \\n    }\\n    \\n    bool hasNext() {\\n        return idx<=inorder.size()-1?true:false;\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085029,
                "title": "java-very-easy-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    Stack<TreeNode>st=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode temp=st.pop();\\n        pushAll(temp.right);\\n        return temp.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        if(!st.isEmpty()) return true;\\n        return false;\\n    }\\n\\n    public void pushAll(TreeNode root){\\n        while(root!=null){\\n            st.push(root);\\n            root=root.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    Stack<TreeNode>st=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode temp=st.pop();\\n        pushAll(temp.right);\\n        return temp.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        if(!st.isEmpty()) return true;\\n        return false;\\n    }\\n\\n    public void pushAll(TreeNode root){\\n        while(root!=null){\\n            st.push(root);\\n            root=root.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056768,
                "title": "inorder-traversal-using-a-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    /* \\n       - we will do an inorder traversal and store the elements in a queue\\n       - it will allow us to keep the lowest element in the front\\n       - we will fetch from the queue for every next call\\n       - has next will check whether the queue is empty\\n    */\\n    queue<int>inOrder;\\n    BSTIterator(TreeNode* root) {\\n        getInorder(root);\\n    }\\n    \\n    int next() {\\n        if(inOrder.size() != 0){\\n            int res = inOrder.front();\\n            inOrder.pop();\\n            return res;\\n        }\\n        return 0;\\n    }\\n    \\n    bool hasNext() {\\n        return inOrder.size() > 0;\\n    }\\n\\n    void getInorder(TreeNode* root){\\n        if(!root) return;\\n        getInorder(root->left);\\n        inOrder.push(root->val);\\n        getInorder(root->right);\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    /* \\n       - we will do an inorder traversal and store the elements in a queue\\n       - it will allow us to keep the lowest element in the front\\n       - we will fetch from the queue for every next call\\n       - has next will check whether the queue is empty\\n    */\\n    queue<int>inOrder;\\n    BSTIterator(TreeNode* root) {\\n        getInorder(root);\\n    }\\n    \\n    int next() {\\n        if(inOrder.size() != 0){\\n            int res = inOrder.front();\\n            inOrder.pop();\\n            return res;\\n        }\\n        return 0;\\n    }\\n    \\n    bool hasNext() {\\n        return inOrder.size() > 0;\\n    }\\n\\n    void getInorder(TreeNode* root){\\n        if(!root) return;\\n        getInorder(root->left);\\n        inOrder.push(root->val);\\n        getInorder(root->right);\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053519,
                "title": "java-dfs-queue-100-faster",
                "content": "# Approach\\nGo thru tree using DFS and adding values into queue.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass BSTIterator {\\n        Queue<Integer> list;\\n        public BSTIterator(TreeNode root) {\\n            list = new LinkedList<>();\\n            traverseBST(root, list);\\n        }\\n\\n        public int next() {\\n            return list.poll();\\n        }\\n\\n        public boolean hasNext() {\\n            return !list.isEmpty();\\n        }\\n        \\n        private void traverseBST(TreeNode node, Queue<Integer> list) {\\n            if (node == null) return;\\n            \\n            traverseBST(node.left, list);\\n            list.add(node.val);\\n            traverseBST(node.right, list);\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BSTIterator {\\n        Queue<Integer> list;\\n        public BSTIterator(TreeNode root) {\\n            list = new LinkedList<>();\\n            traverseBST(root, list);\\n        }\\n\\n        public int next() {\\n            return list.poll();\\n        }\\n\\n        public boolean hasNext() {\\n            return !list.isEmpty();\\n        }\\n        \\n        private void traverseBST(TreeNode node, Queue<Integer> list) {\\n            if (node == null) return;\\n            \\n            traverseBST(node.left, list);\\n            list.add(node.val);\\n            traverseBST(node.right, list);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025698,
                "title": "simple-solution-using-threaded-binary-tree-no-use-of-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTried to use Threaded Binary Tree concept\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we check if the tree has any left child if it has we connect the right most node of the left child to the parent. and move to the left of the tree. \\nIf the there is no left child then according to the inorder traversal we return the value of the root and root is changed to root->right;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(1) on an average for each operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1) as no extra space is used\\n\\n# Code\\nclass BSTIterator {\\nprivate : \\nTreeNode * root;\\npublic:\\n    \\n    BSTIterator(TreeNode* r) {\\n        root = r;\\n    }\\n    \\n    int next() {\\n        while (root->left)\\n        {\\n            TreeNode *tmp = root->left;\\n            while(tmp->right && tmp->right != root) tmp = tmp->right;\\n            if (tmp->right == NULL)\\n            {\\n                tmp->right = root;\\n                root = root->left;\\n            }\\n            else\\n            {\\n                tmp->right = NULL;\\n                int ans = root->val;\\n                root = root->right;\\n                return ans;\\n            }\\n\\n        }\\n        int ans = root->val;\\n        root = root->right;\\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        return root != NULL;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTried to use Threaded Binary Tree concept\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we check if the tree has any left child if it has we connect the right most node of the left child to the parent. and move to the left of the tree. \\nIf the there is no left child then according to the inorder traversal we return the value of the root and root is changed to root->right;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(1) on an average for each operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1) as no extra space is used\\n\\n# Code\\nclass BSTIterator {\\nprivate : \\nTreeNode * root;\\npublic:\\n    \\n    BSTIterator(TreeNode* r) {\\n        root = r;\\n    }\\n    \\n    int next() {\\n        while (root->left)\\n        {\\n            TreeNode *tmp = root->left;\\n            while(tmp->right && tmp->right != root) tmp = tmp->right;\\n            if (tmp->right == NULL)\\n            {\\n                tmp->right = root;\\n                root = root->left;\\n            }\\n            else\\n            {\\n                tmp->right = NULL;\\n                int ans = root->val;\\n                root = root->right;\\n                return ans;\\n            }\\n\\n        }\\n        int ans = root->val;\\n        root = root->right;\\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        return root != NULL;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2965908,
                "title": "c-beats-100-explained-using-stack",
                "content": "# Intuition\\nWe know that Inorder Traversal of BST is always in sorted order.\\n\\n    Runtime - 100%\\uD83D\\uDD25 \\n\\n# Approach\\n1. Firstly we will store the preorder traversal of tree in stack.\\n2. Then we will reverse the stack.\\n\\n#  If you like the solution and understand it then Please Upvote.\\u2B06\\uFE0F\\u2764\\uFE0F \\n\\t* PEACE OUT LUV\\u270C\\uFE0F*\\n\\n# Code\\n```\\nclass BSTIterator {\\npublic:\\n    stack<int>st;\\n    stack<int>st1;\\n    void dfs(TreeNode* root, stack<int>&st){\\n        if(root== NULL){\\n            return;\\n        }\\n        dfs(root ->left, st);\\n        st.push(root ->val);\\n        dfs(root ->right, st); \\n    }\\n    BSTIterator(TreeNode* root) {\\n        dfs(root, st1);\\n        while(!st1.empty()){\\n            st.push(st1.top());\\n            st1.pop();\\n        }\\n    }\\n    int next() {\\n        int top = st.top();\\n        st.pop();\\n        return top;\\n    }\\n    bool hasNext() {\\n        if(!st.empty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<int>st;\\n    stack<int>st1;\\n    void dfs(TreeNode* root, stack<int>&st){\\n        if(root== NULL){\\n            return;\\n        }\\n        dfs(root ->left, st);\\n        st.push(root ->val);\\n        dfs(root ->right, st); \\n    }\\n    BSTIterator(TreeNode* root) {\\n        dfs(root, st1);\\n        while(!st1.empty()){\\n            st.push(st1.top());\\n            st1.pop();\\n        }\\n    }\\n    int next() {\\n        int top = st.top();\\n        st.pop();\\n        return top;\\n    }\\n    bool hasNext() {\\n        if(!st.empty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840678,
                "title": "time-o-n-space-o-h-simple-solution",
                "content": "class BSTIterator {\\npublic:\\n    \\n    stack<TreeNode*>st;\\n    \\n    BSTIterator(TreeNode* root) {\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        \\n        TreeNode*root=st.top();st.pop();\\n        int result=root->val;\\n        root=root->right;\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n        return result;\\n    }\\n    \\n    bool hasNext() {\\n        if(st.size()==0) return false;\\n        else return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class BSTIterator {\\npublic:\\n    \\n    stack<TreeNode*>st;\\n    \\n    BSTIterator(TreeNode* root) {\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        \\n        TreeNode*root=st.top();st.pop();\\n        int result=root->val;\\n        root=root->right;\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n        return result;\\n    }\\n    \\n    bool hasNext() {\\n        if(st.size()==0) return false;\\n        else return true;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2641612,
                "title": "using-arraylist-java-solution",
                "content": "We create a ArrayList (tree) to store the value of nodes of the tree, in inorder sequence.\\nWhen the BSTIterator is called for the first time, we call normal inorder function that traverses the tree, and we strore the node values in the tree.\\n\\nWe also create a pointer l = 0, that traverses the Arraylist, and keeps track of the posititon in the tree.\\n```\\nclass BSTIterator {\\n\\n    ArrayList<Integer> tree;\\n    int l = 0;\\n    public BSTIterator(TreeNode root) {\\n        tree = new ArrayList<>();\\n        inorder(root);\\n    }\\n    \\n    public int next() {\\n        return tree.get(l++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return l < tree.size();\\n    }\\n    \\n\\t// adds node values to ArrayList (tree)\\n    private void inorder(TreeNode root) {\\n        if (root != null) {\\n            inorder(root.left);\\n            tree.add(root.val);\\n            inorder(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass BSTIterator {\\n\\n    ArrayList<Integer> tree;\\n    int l = 0;\\n    public BSTIterator(TreeNode root) {\\n        tree = new ArrayList<>();\\n        inorder(root);\\n    }\\n    \\n    public int next() {\\n        return tree.get(l++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return l < tree.size();\\n    }\\n    \\n\\t// adds node values to ArrayList (tree)\\n    private void inorder(TreeNode root) {\\n        if (root != null) {\\n            inorder(root.left);\\n            tree.add(root.val);\\n            inorder(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604737,
                "title": "java-solution-queue",
                "content": "```\\nclass BSTIterator {\\n    Queue<Integer> q = new LinkedList<>();\\n    public BSTIterator(TreeNode root) {\\n        inOrder(root);\\n    }\\n    \\n    public int next() {\\n        return q.poll();\\n    }\\n    \\n    public boolean hasNext() {\\n        return (!q.isEmpty());\\n    }\\n    \\n    public void inOrder(TreeNode root)\\n    {\\n        if(root != null)\\n        {\\n            inOrder(root.left);\\n            q.add(root.val);\\n            inOrder(root.right);\\n        }\\n    }\\n}\\n```\\nIf you like the solution, the please UPVOTE  :)",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Queue"
                ],
                "code": "```\\nclass BSTIterator {\\n    Queue<Integer> q = new LinkedList<>();\\n    public BSTIterator(TreeNode root) {\\n        inOrder(root);\\n    }\\n    \\n    public int next() {\\n        return q.poll();\\n    }\\n    \\n    public boolean hasNext() {\\n        return (!q.isEmpty());\\n    }\\n    \\n    public void inOrder(TreeNode root)\\n    {\\n        if(root != null)\\n        {\\n            inOrder(root.left);\\n            q.add(root.val);\\n            inOrder(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513094,
                "title": "python-solution",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root=root\\n        self.stack=[root]\\n        curr=root.left\\n        while curr:\\n            self.stack.append(curr)\\n            curr=curr.left\\n    def next(self) -> int:\\n        temp=self.stack.pop()\\n        curr=temp.right\\n        while curr:\\n            self.stack.append(curr)\\n            curr=curr.left\\n        return temp.val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.stack\\n        \\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root=root\\n        self.stack=[root]\\n        curr=root.left\\n        while curr:\\n            self.stack.append(curr)\\n            curr=curr.left\\n    def next(self) -> int:\\n        temp=self.stack.pop()\\n        curr=temp.right\\n        while curr:\\n            self.stack.append(curr)\\n            curr=curr.left\\n        return temp.val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.stack\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500651,
                "title": "easy-begineer-friendly-c-dfs-alternative-approach",
                "content": "#### Please upvote if find code useful !\\n\\n\\tclass BSTIterator {\\n\\t\\tvector<int> treeSorted;\\n\\t\\tvoid storeTree(TreeNode* root){\\n\\t\\t\\tif(root == NULL)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tstoreTree(root->left);\\n\\t\\t\\ttreeSorted.push_back(root->val);\\n\\t\\t\\tstoreTree(root->right);\\n\\t\\t}\\n\\n\\tpublic:\\n\\n\\t\\tint index;\\n\\t\\tBSTIterator(TreeNode* root) {\\n\\t\\t\\tstoreTree(root);\\n\\t\\t\\tindex = 0;\\n\\t\\t}\\n\\n\\t\\tint next() {\\n\\t\\t\\tindex++;\\n\\t\\t\\treturn treeSorted[index-1];\\n\\t\\t}\\n\\n\\t\\tbool hasNext() {\\n\\t\\t\\tif(index == treeSorted.size())\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "#### Please upvote if find code useful !\\n\\n\\tclass BSTIterator {\\n\\t\\tvector<int> treeSorted;\\n\\t\\tvoid storeTree(TreeNode* root){\\n\\t\\t\\tif(root == NULL)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tstoreTree(root->left);\\n\\t\\t\\ttreeSorted.push_back(root->val);\\n\\t\\t\\tstoreTree(root->right);\\n\\t\\t}\\n\\n\\tpublic:\\n\\n\\t\\tint index;\\n\\t\\tBSTIterator(TreeNode* root) {\\n\\t\\t\\tstoreTree(root);\\n\\t\\t\\tindex = 0;\\n\\t\\t}\\n\\n\\t\\tint next() {\\n\\t\\t\\tindex++;\\n\\t\\t\\treturn treeSorted[index-1];\\n\\t\\t}\\n\\n\\t\\tbool hasNext() {\\n\\t\\t\\tif(index == treeSorted.size())\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 2474743,
                "title": "python-96-faster",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        cur = root\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n            \\n\\n    def next(self) -> int:\\n        res = self.stack.pop()\\n        cur = res.right\\n        while cur:\\n            self.stack.append(cur)\\n            cur = cur.left\\n        return res.val\\n\\n    def hasNext(self) -> bool:\\n        return self.stack!=[]\\n        \\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        cur = root\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n            \\n\\n    def next(self) -> int:\\n        res = self.stack.pop()\\n        cur = res.right\\n        while cur:\\n            self.stack.append(cur)\\n            cur = cur.left\\n        return res.val\\n\\n    def hasNext(self) -> bool:\\n        return self.stack!=[]\\n        \\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353628,
                "title": "o-1-time-o-h-space-solution-explained-cleanly-with-comments-c",
                "content": "**So How come Time is O(1)?**\\n* So see overall we do the inorder traversal but point to be noticed is there are N next calls also.\\n* So Overall TC O(N), But we have N next() calls\\n* So Time for 1 next() is O(N/N) = O(1) amortized.\\n* Space is O(H) as we store left left left only, not all nodes at a time.\\n\\n```\\n//TC O(1) and O(H) Space\\n\\n//MIMIC inorder\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> stk;\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n         // left is done\\n    }\\n    \\n    int next() {\\n        //root handled\\n        TreeNode* node = stk.top();\\n        int ans = node->val;\\n        stk.pop();\\n        \\n        //right handled\\n        pushAll(node->right);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    bool hasNext() {\\n        return stk.size() != 0; // stk is empty then no next to show simple\\n    }\\n    \\n    void pushAll(TreeNode* root){\\n        //left part - as inorder is like Left left left, once a root is done then check right\\n        while(root!= NULL){\\n            stk.push(root);\\n            root = root->left;\\n        }\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "```\\n//TC O(1) and O(H) Space\\n\\n//MIMIC inorder\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> stk;\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n         // left is done\\n    }\\n    \\n    int next() {\\n        //root handled\\n        TreeNode* node = stk.top();\\n        int ans = node->val;\\n        stk.pop();\\n        \\n        //right handled\\n        pushAll(node->right);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    bool hasNext() {\\n        return stk.size() != 0; // stk is empty then no next to show simple\\n    }\\n    \\n    void pushAll(TreeNode* root){\\n        //left part - as inorder is like Left left left, once a root is done then check right\\n        while(root!= NULL){\\n            stk.push(root);\\n            root = root->left;\\n        }\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350908,
                "title": "c-2-approaches-inorder-partial-inorder",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n***1. Regular Inorder***\\n```\\nclass BSTIterator {\\npublic:\\n    vector<int> ans;\\n    int curr=-1;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        curr++;\\n        return ans[curr];\\n    }\\n    \\n    bool hasNext() {\\n        if(curr+1 < ans.size()) return true;\\n        else return false;\\n    }\\n};\\n```\\n\\n***2. Much more efficient*** (Partial Inorder)\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode* > st;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        st.push(root);\\n        inorder(root->left);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        inorder(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    vector<int> ans;\\n    int curr=-1;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        curr++;\\n        return ans[curr];\\n    }\\n    \\n    bool hasNext() {\\n        if(curr+1 < ans.size()) return true;\\n        else return false;\\n    }\\n};\\n```\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode* > st;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        st.push(root);\\n        inorder(root->left);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        inorder(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184071,
                "title": "c-using-stack-with-explaination",
                "content": "class BSTIterator {\\npublic:\\n\\n    stack<TreeNode*> st;\\n    \\n    BSTIterator(TreeNode* root) {    \\n\\t//To initialize stack\\n        stackFill(root);\\n    }\\n    \\n    int next() {\\n\\t//returns next inorder element and push all left elements which are to the right of the node.\\n        TreeNode* node = st.top();\\n        st.pop();\\n        stackFill(node->right);\\n        \\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n\\t//return true when stack is not empty else false\\n        return !st.empty();\\n    }\\n    \\n\\t//Initialize stack with all elements left to the root, including root\\n    private: \\n        void stackFill(TreeNode* root){\\n            \\n            while(root){\\n                st.push(root);\\n                root = root->left;\\n            }\\n        }\\n};\\n\\nNote: For better understanding and learning, consider dry running code yourself.\\n\\t\\t  For doubts and suggestions comment below.\\n\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class BSTIterator {\\npublic:\\n\\n    stack<TreeNode*> st;\\n    \\n    BSTIterator(TreeNode* root) {    \\n\\t//To initialize stack\\n        stackFill(root);\\n    }\\n    \\n    int next() {\\n\\t//returns next inorder element and push all left elements which are to the right of the node.\\n        TreeNode* node = st.top();\\n        st.pop();\\n        stackFill(node->right);\\n        \\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n\\t//return true when stack is not empty else false\\n        return !st.empty();\\n    }\\n    \\n\\t//Initialize stack with all elements left to the root, including root\\n    private: \\n        void stackFill(TreeNode* root){\\n            \\n            while(root){\\n                st.push(root);\\n                root = root->left;\\n            }\\n        }\\n};\\n\\nNote: For better understanding and learning, consider dry running code yourself.\\n\\t\\t  For doubts and suggestions comment below.\\n\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "codeTag": "Java"
            },
            {
                "id": 1980827,
                "title": "one-template-to-solve-multiple-problems-c-time-o-n-space-o-h",
                "content": "> You could also visit my [blog post](https://manishyadav.dev/blog/binary-tree-traversal) to visually see how we need to make minimal code changes with just one template. Below posted version is copied directly from it\\n\\nOne common interview problem that commonly gets asked by interviewer is to write an in-order binary tree traversal algorithm. This deceptively simple problem in my own opinion is harder than it looks like. Although the recursive version is tidier, it hides the complexity that goes behind it. I, too, ended up memorizing those three lines, only to later realize that sometimes it was much harder to come up with a solution to a problem based on in-order traversal only using recursion.\\n\\n### Inorder Binary Search Tree Traversal\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        //Traverse to the left most node\\n        inorder(root -> left);\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n    }\\n};\\n```\\n\\nRecall our good ol\\' recursive in-order traversal.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        //Traverse to the left most node\\n        inorder(root -> left);\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n    }\\n};\\n```\\nLike a compiler, we can mechanically [convert our function calls to use an explicit stack](https://www.baeldung.com/cs/convert-recursion-to-iteration), but readibility/memoribility would suffer.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        //Traverse to the left most node\\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n        }\\n    }\\n};\\n```\\n\\nThe in-order traversal requires that we print the leftmost node first and the right most node at the end. So basically for each node we need to go as far as down and left as possible. So the line `inorder(root->left)` could be replaced with a while loop to have similar effect.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        //Traverse to the left most node\\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        root = root->right;\\n        }\\n    }\\n};\\n```\\n\\nNow we need to retrieve the top node and store it\\'s right child if it exists\\n\\n\\nAn iterative solution can help us solve multiple tree problems, and the same template could be used for multiple problems.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        \\n        root = root->right;\\n        }\\n    }\\n};\\n```\\n\\nLet\\'s use the same template we created earlier to solve multiple leetcode problem using the same pattern\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        stack<TreeNode*> nodes;\\n        vector<int> result;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        result.push_back(root->val);\\n        \\n        \\n        root = root->right;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nFor leetcode problem [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal), we need to return a list of node so rather than printing. This could be solved by storing the values in a list and returning it.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) {\\n            return true;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if(pre && root->val <= pre->val) return false;\\n        pre = root;\\n        \\n        \\n        root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nSimilarly, in order to [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) could be solved by verifying if the in-order traversal is in ascending order\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        k--;\\n        if (k == 0) return root->val;\\n        \\n        \\n        root = root->right;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nFind [Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) by simply breaking at kth element\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if (root->val == val) return root;\\n        \\n        \\n        root = root->right;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n[Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/) becomes much simpler and one needs to simply check for `val` you are looking for.\\n\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, int val) {\\n        TreeNode* head = new TreeNode(-1);\\n        TreeNode* prev = head;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        prev->right = root;\\n        prev = prev->right;\\n        root->left = NULL;\\n        \\n        \\n        root = root->right;\\n        }\\n        return head->right;\\n    }\\n};\\n```\\n\\n[Increasing Order Search Tree](https://leetcode.com/problems/increasing-order-search-tree/) has similar intuition. Each time we meet a node, link it like a linked list using the right pointer. To facilitate the linking, create a dummy head\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* head) {\\n        TreeNode* first = NULL;\\n        TreeNode* second = NULL;\\n        TreeNode* root = head;\\n        TreeNode* prev = NULL;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if (prev != NULL && prev->val > root->val) {\\n                if (first == NULL) {\\n                    first = prev;\\n                }\\n                second = root;\\n            }\\n            prev = root;\\n        \\n        \\n        root = root->right;\\n        }\\n        swap(first->val, second->val);\\n};\\n```\\n\\nFor [Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/), the question boils down to to find \"2\" elements in a given sorted arrangement , such that both of these elements violate the \"sorted\" order, and swap them back to their original places.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* convertBST(TreeNode* root, int val) {\\n        if (!root) return NULL;\\n        TreeNode* head = root;\\n        \\n        int sum = 0;\\n        int current_val;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->right;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        current_val = root->val;\\n        root->val = root->val + sum;\\n        sum += current_val;\\n        \\n        \\n        root = root->left;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\nFor [Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/), The solution is the modification of inorder travel. Namely, travel right subtree, change the root value, and travel left subtree.\\n\\n```cpp\\nclass BSTIterator {\\n    stack<TreeNode*> nodes;\\n    TreeNode* head;\\n    int result;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        head = root;\\n        \\n        while(head) {\\n            s.push(head);\\n            head = head->left;\\n        }\\n    }\\n    \\n    int next() {\\n        head = s.top(); s.pop();\\n        result = head->val;\\n        if (head->right) {\\n            head = head->right;\\n            \\n            while(head) {\\n              s.push(head);\\n              head = head->left;  \\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```\\n\\nOnce you have realized the pattern, you could see [Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/) problem has the exact same structure\\n 1. Some initialization.\\n 2. A while-loop with a condition that tells whether there is more.\\n 3. The loop body gets the next value and does something with it.\\n\\nThat\\u2019s it! I hope you enjoyed the explanation, not only we managed to understand inorder binary search tree traversal but also managed to solve handful leetcode problems as well and feel free to reach out to me on how I could improve its clarity.\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        //Traverse to the left most node\\n        inorder(root -> left);\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        //Traverse to the left most node\\n        inorder(root -> left);\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        //Traverse to the left most node\\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        //Traverse to the left most node\\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        root = root->right;\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        \\n        root = root->right;\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        stack<TreeNode*> nodes;\\n        vector<int> result;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        result.push_back(root->val);\\n        \\n        \\n        root = root->right;\\n        }\\n        return result;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) {\\n            return true;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if(pre && root->val <= pre->val) return false;\\n        pre = root;\\n        \\n        \\n        root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        k--;\\n        if (k == 0) return root->val;\\n        \\n        \\n        root = root->right;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if (root->val == val) return root;\\n        \\n        \\n        root = root->right;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, int val) {\\n        TreeNode* head = new TreeNode(-1);\\n        TreeNode* prev = head;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        prev->right = root;\\n        prev = prev->right;\\n        root->left = NULL;\\n        \\n        \\n        root = root->right;\\n        }\\n        return head->right;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* head) {\\n        TreeNode* first = NULL;\\n        TreeNode* second = NULL;\\n        TreeNode* root = head;\\n        TreeNode* prev = NULL;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if (prev != NULL && prev->val > root->val) {\\n                if (first == NULL) {\\n                    first = prev;\\n                }\\n                second = root;\\n            }\\n            prev = root;\\n        \\n        \\n        root = root->right;\\n        }\\n        swap(first->val, second->val);\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* convertBST(TreeNode* root, int val) {\\n        if (!root) return NULL;\\n        TreeNode* head = root;\\n        \\n        int sum = 0;\\n        int current_val;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->right;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        current_val = root->val;\\n        root->val = root->val + sum;\\n        sum += current_val;\\n        \\n        \\n        root = root->left;\\n        }\\n        return head;\\n    }\\n};\\n```\n```cpp\\nclass BSTIterator {\\n    stack<TreeNode*> nodes;\\n    TreeNode* head;\\n    int result;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        head = root;\\n        \\n        while(head) {\\n            s.push(head);\\n            head = head->left;\\n        }\\n    }\\n    \\n    int next() {\\n        head = s.top(); s.pop();\\n        result = head->val;\\n        if (head->right) {\\n            head = head->right;\\n            \\n            while(head) {\\n              s.push(head);\\n              head = head->left;  \\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1967147,
                "title": "js-simple-explained-stack-optimal",
                "content": "# 173. Binary Search Tree Iterator \\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n<!-- ### Index:\\n1. [Explaining the Question](#explaining-the-question)\\n2. [Recommended Knowledge](#what-do-we-know)\\n3. [What do we know](#recommended-knowledge)\\n4. [Solution Explanation](#how-were-going-to-do-it)\\n5. [Big *O* Notation](#big-o-notation)\\n6. [Leetcode Results](#leetcode-results)\\n7. [Solution](#the-solution) -->\\n\\n## Explaining The Question\\nWe have a class based question. Where we need to implement a class that can iterate through a binary search tree. Where it can see if their is a next `node` and to be able to move to the next `node`. All done in a `in-order` way. \\n***\\n\\n##  Recommended Knowledge\\n1. Binary Tree\\n2. Binary Search Trees\\n3. Binary Tree - Depth First Search (Recursive In-Order Traversal)\\n4. Stacks\\n5. Classes / Object Oriented Programming\\n\\n\\n## What do we know?\\n1. We have a Binary Search Tree and we need to implement a Tree Iterator.\\n2. We need to create a `hasNext()` which returns a boolean. This method asks if there is a number that exists to the `right`.\\n3. We also need to implement a `next` method, which moves the pointer to the `right` and returns the value at that pointer.\\n4. Our methods can be done in **O(1)** time. Our space is **O(h)**\\n\\n## How we\\'re going to do it:\\n1. We\\'re going to perform a ***In-Order Traversal*** in reverse so we can get all the right most `nodes` onto of the ***stack***. We do this because otherwise we need to use a Queue, which is very poor in Javascript. ***Stacks*** are just great for performance.\\n2. After performing our traversal, we can now move ahead with the other operations.\\n3. For the `next()` function, all we do is pop off the stack. As that is the next item in the list. Then set it to the current `node`\\n4. For` hasNext()`, we just **ask if the length of the list is > 0**\\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is the number of nodes the tree has | As we will always be traversing the entire tree\\n* Space Complexity: *O(**h**)* | As we will be using a ***Stack*** to store the nodes \\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 131 ms faster than ***85.64%*** of JavaScript online submissions for Binary Search Tree Iterator.\\n* Memory Usage: 55.6 MB, less than ***49.86***% of JavaScript online submissions for Binary Search Tree Iterator.\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/684209937/)\\n\\n\\n***\\n\\n# The Solution\\n```\\nvar BSTIterator = function (root) {\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                      173. Binary Search Tree Iterator                      */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n\\t * @author  Samuel Hinchliffe\\n\\t * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n\\t * @see    {@link github.com/Samuel-Hinchliffe}\\n\\t */\\n\\n    /* ----------------------------- Solution Below ----------------------------- */\\n\\n    // Node, this will update whenever we make moves\\n    this.node = root;\\n\\n    // A stack that will be used to get the in-order traversal of the list\\n    this.stack = [];\\n\\n    // Function to get the in-order traversal of the list\\n    const bst_in_order = (node) => {\\n        \\n        // Leaf node? Return up the call stack\\n        if (!node) {\\n            return null;\\n        }\\n\\n        // Go to the right most node\\n        bst_in_order(node.right);\\n\\n        // Once as far right as we can get\\n        // add to the stack\\n        this.stack.push(node);\\n\\n        // Get the left nodes\\n        bst_in_order(node.left);\\n    };\\n\\n    // Populate our stack\\n    bst_in_order(root);\\n};\\n\\nBSTIterator.prototype.next = function () {\\n    // Constant Time: O(1)\\n\\n    // As we already have a stack populated with our\\n    // in-order traversal, all we have to do is take the top\\n    // of the stack and we\\'re all good.\\n    this.node = this.stack.pop();\\n    return this.node.val;\\n};\\n\\nBSTIterator.prototype.hasNext = function () {\\n    // Constant Time: O(1)\\n\\n    // So is their anything in the stack at all?\\n    // What this mean\\'s is. If I am empty, return false, if not\\n    // return true.\\n\\n    return this.stack.length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar BSTIterator = function (root) {\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                      173. Binary Search Tree Iterator                      */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n\\t * @author  Samuel Hinchliffe\\n\\t * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n\\t * @see    {@link github.com/Samuel-Hinchliffe}\\n\\t */\\n\\n    /* ----------------------------- Solution Below ----------------------------- */\\n\\n    // Node, this will update whenever we make moves\\n    this.node = root;\\n\\n    // A stack that will be used to get the in-order traversal of the list\\n    this.stack = [];\\n\\n    // Function to get the in-order traversal of the list\\n    const bst_in_order = (node) => {\\n        \\n        // Leaf node? Return up the call stack\\n        if (!node) {\\n            return null;\\n        }\\n\\n        // Go to the right most node\\n        bst_in_order(node.right);\\n\\n        // Once as far right as we can get\\n        // add to the stack\\n        this.stack.push(node);\\n\\n        // Get the left nodes\\n        bst_in_order(node.left);\\n    };\\n\\n    // Populate our stack\\n    bst_in_order(root);\\n};\\n\\nBSTIterator.prototype.next = function () {\\n    // Constant Time: O(1)\\n\\n    // As we already have a stack populated with our\\n    // in-order traversal, all we have to do is take the top\\n    // of the stack and we\\'re all good.\\n    this.node = this.stack.pop();\\n    return this.node.val;\\n};\\n\\nBSTIterator.prototype.hasNext = function () {\\n    // Constant Time: O(1)\\n\\n    // So is their anything in the stack at all?\\n    // What this mean\\'s is. If I am empty, return false, if not\\n    // return true.\\n\\n    return this.stack.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967129,
                "title": "c-recursion-inorder-traversal",
                "content": "```\\nclass BSTIterator {\\nprivate:\\n    int k;\\n    vector<int> ans;\\npublic:\\n    void inorder(TreeNode *root)\\n    {\\n        if(!root){\\n            return;\\n        }\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n        k=-1;\\n    }\\n    \\n    int next() {\\n        k++;\\n        return ans[k];\\n    }\\n    \\n    bool hasNext() {\\n        if((k+1)<ans.size()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass BSTIterator {\\nprivate:\\n    int k;\\n    vector<int> ans;\\npublic:\\n    void inorder(TreeNode *root)\\n    {\\n        if(!root){\\n            return;\\n        }\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n        k=-1;\\n    }\\n    \\n    int next() {\\n        k++;\\n        return ans[k];\\n    }\\n    \\n    bool hasNext() {\\n        if((k+1)<ans.size()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1966981,
                "title": "easy-solution-python",
                "content": "I just made a stack out of a tree and popped elements off the stack as long as possible.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.mystack = []\\n        self.makeStack(root)\\n        self.mystack.reverse()\\n        return None\\n        \\n\\n    def makeStack(self, root):\\n        if root == None:\\n            return root\\n        self.makeStack(root.left)\\n        self.mystack.append(root.val)\\n        self.makeStack(root.right)\\n        \\n    def next(self) -> int:\\n        if self.mystack == None:\\n            return None\\n        return self.mystack.pop(-1)\\n\\n    def hasNext(self) -> bool:\\n        if self.mystack:\\n            return True\\n        else:\\n            return False\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Binary Tree"
                ],
                "code": "I just made a stack out of a tree and popped elements off the stack as long as possible.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.mystack = []\\n        self.makeStack(root)\\n        self.mystack.reverse()\\n        return None\\n        \\n\\n    def makeStack(self, root):\\n        if root == None:\\n            return root\\n        self.makeStack(root.left)\\n        self.mystack.append(root.val)\\n        self.makeStack(root.right)\\n        \\n    def next(self) -> int:\\n        if self.mystack == None:\\n            return None\\n        return self.mystack.pop(-1)\\n\\n    def hasNext(self) -> bool:\\n        if self.mystack:\\n            return True\\n        else:\\n            return False\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()",
                "codeTag": "Java"
            },
            {
                "id": 1966715,
                "title": "easy-cpp-inorder",
                "content": "```\\nclass BSTIterator {\\npublic:\\n    vector<int> v; int i=0;\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    int next() {\\n        int ele =  v[i];\\n        i++;\\n        return ele;\\n    }\\n    bool hasNext() {\\n        if(i>=v.size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    vector<int> v; int i=0;\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    int next() {\\n        int ele =  v[i];\\n        i++;\\n        return ele;\\n    }\\n    bool hasNext() {\\n        if(i>=v.size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568996,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1566291,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1568762,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567900,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567901,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567750,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1677525,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1576643,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1571378,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1571379,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1568996,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1566291,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1568762,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567900,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567901,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567750,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1677525,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1576643,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1571378,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1571379,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            }
        ]
    },
    {
        "title": "Integer to English Words",
        "question_content": "<p>Convert a non-negative integer <code>num</code> to its English words representation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 123\n<strong>Output:</strong> &quot;One Hundred Twenty Three&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 12345\n<strong>Output:</strong> &quot;Twelve Thousand Three Hundred Forty Five&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 1234567\n<strong>Output:</strong> &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 70625,
                "title": "my-clean-java-solution-very-easy-to-understand",
                "content": "    private final String[] LESS_THAN_20 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n\\tprivate final String[] TENS = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n\\tprivate final String[] THOUSANDS = {\"\", \"Thousand\", \"Million\", \"Billion\"};\\n\\t\\n    public String numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n\\n        int i = 0;\\n        String words = \"\";\\n        \\n        while (num > 0) {\\n            if (num % 1000 != 0)\\n        \\t    words = helper(num % 1000) +THOUSANDS[i] + \" \" + words;\\n        \\tnum /= 1000;\\n        \\ti++;\\n        }\\n        \\n        return words.trim();\\n    }\\n    \\n    private String helper(int num) {\\n        if (num == 0)\\n            return \"\";\\n        else if (num < 20)\\n            return LESS_THAN_20[num] + \" \";\\n        else if (num < 100)\\n            return TENS[num / 10] + \" \" + helper(num % 10);\\n        else\\n            return LESS_THAN_20[num / 100] + \" Hundred \" + helper(num % 100);\\n    }",
                "solutionTags": [],
                "code": "    private final String[] LESS_THAN_20 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n\\tprivate final String[] TENS = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n\\tprivate final String[] THOUSANDS = {\"\", \"Thousand\", \"Million\", \"Billion\"};\\n\\t\\n    public String numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n\\n        int i = 0;\\n        String words = \"\";\\n        \\n        while (num > 0) {\\n            if (num % 1000 != 0)\\n        \\t    words = helper(num % 1000) +THOUSANDS[i] + \" \" + words;\\n        \\tnum /= 1000;\\n        \\ti++;\\n        }\\n        \\n        return words.trim();\\n    }\\n    \\n    private String helper(int num) {\\n        if (num == 0)\\n            return \"\";\\n        else if (num < 20)\\n            return LESS_THAN_20[num] + \" \";\\n        else if (num < 100)\\n            return TENS[num / 10] + \" \" + helper(num % 10);\\n        else\\n            return LESS_THAN_20[num / 100] + \" Hundred \" + helper(num % 100);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70627,
                "title": "short-clean-java-solution",
                "content": "    public class Solution {\\n        private final String[] belowTen = new String[] {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n        private final String[] belowTwenty = new String[] {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        private final String[] belowHundred = new String[] {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        \\n        public String numberToWords(int num) {\\n            if (num == 0) return \"Zero\";\\n            return helper(num); \\n        }\\n        \\n        private String helper(int num) {\\n            String result = new String();\\n            if (num < 10) result = belowTen[num];\\n            else if (num < 20) result = belowTwenty[num -10];\\n            else if (num < 100) result = belowHundred[num/10] + \" \" + helper(num % 10);\\n            else if (num < 1000) result = helper(num/100) + \" Hundred \" +  helper(num % 100);\\n            else if (num < 1000000) result = helper(num/1000) + \" Thousand \" +  helper(num % 1000);\\n            else if (num < 1000000000) result = helper(num/1000000) + \" Million \" +  helper(num % 1000000);\\n            else result = helper(num/1000000000) + \" Billion \" + helper(num % 1000000000);\\n            return result.trim();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        private final String[] belowTen = new String[] {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}",
                "codeTag": "Java"
            },
            {
                "id": 70632,
                "title": "recursive-python",
                "content": "    def numberToWords(self, num):\\n        to19 = 'One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve ' \\\\\\n               'Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen'.split()\\n        tens = 'Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety'.split()\\n        def words(n):\\n            if n < 20:\\n                return to19[n-1:n]\\n            if n < 100:\\n                return [tens[n/10-2]] + words(n%10)\\n            if n < 1000:\\n                return [to19[n/100-1]] + ['Hundred'] + words(n%100)\\n            for p, w in enumerate(('Thousand', 'Million', 'Billion'), 1):\\n                if n < 1000**(p+1):\\n                    return words(n/1000**p) + [w] + words(n%1000**p)\\n        return ' '.join(words(num)) or 'Zero'",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def numberToWords(self, num):\\n        to19 = 'One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve ' \\\\\\n               'Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen'.split()\\n        tens = 'Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety'.split()\\n        def words(n):\\n            if n < 20:\\n                return to19[n-1:n]\\n            if n < 100:\\n                return [tens[n/10-2]] + words(n%10)\\n            if n < 1000:\\n                return [to19[n/100-1]] + ['Hundred'] + words(n%100)\\n            for p, w in enumerate(('Thousand', 'Million', 'Billion'), 1):\\n                if n < 1000**(p+1):\\n                    return words(n/1000**p) + [w] + words(n%1000**p)\\n        return ' '.join(words(num)) or 'Zero'",
                "codeTag": "Python3"
            },
            {
                "id": 2997480,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string one(int num) {\\n    switch(num) {\\n      case 1: return \"One\";\\n      case 2: return \"Two\";\\n      case 3: return \"Three\";\\n      case 4: return \"Four\";\\n      case 5: return \"Five\";\\n      case 6: return \"Six\";\\n      case 7: return \"Seven\";\\n      case 8: return \"Eight\";\\n      case 9: return \"Nine\";\\n    }\\n    return \"\";\\n  }\\n\\n  string twoLessThan20(int num) {\\n    switch(num) {\\n      case 10: return \"Ten\";\\n      case 11: return \"Eleven\";\\n      case 12: return \"Twelve\";\\n      case 13: return \"Thirteen\";\\n      case 14: return \"Fourteen\";\\n      case 15: return \"Fifteen\";\\n      case 16: return \"Sixteen\";\\n      case 17: return \"Seventeen\";\\n      case 18: return \"Eighteen\";\\n      case 19: return \"Nineteen\";\\n    }\\n    return \"\";\\n  }\\n\\n  string ten(int num) {\\n    switch(num) {\\n      case 2: return \"Twenty\";\\n      case 3: return \"Thirty\";\\n      case 4: return \"Forty\";\\n      case 5: return \"Fifty\";\\n      case 6: return \"Sixty\";\\n      case 7: return \"Seventy\";\\n      case 8: return \"Eighty\";\\n      case 9: return \"Ninety\";\\n    }\\n    return \"\";\\n  }\\n\\n  string two(int num) {\\n    if (num == 0)\\n      return \"\";\\n    else if (num < 10)\\n      return one(num);\\n    else if (num < 20)\\n      return twoLessThan20(num);\\n    else {\\n      int tenner = num / 10;\\n      int rest = num - tenner * 10;\\n      if (rest != 0)\\n        return ten(tenner) + \" \" + one(rest);\\n      else\\n        return ten(tenner);\\n    }\\n  }\\n\\n  string three(int num) {\\n    int hundred = num / 100;\\n    int rest = num - hundred * 100;\\n    string res = \"\";\\n    if (hundred*rest != 0)\\n      res = one(hundred) + \" Hundred \" + two(rest);\\n    else if ((hundred == 0) && (rest != 0))\\n      res = two(rest);\\n    else if ((hundred != 0) && (rest == 0))\\n      res = one(hundred) + \" Hundred\";\\n    return res;\\n  }\\n\\n    string numberToWords(int num) {\\n        if (num == 0)\\n      return \"Zero\";\\n\\n    int billion = num / 1000000000;\\n    int million = (num - billion * 1000000000) / 1000000;\\n    int thousand = (num - billion * 1000000000 - million * 1000000) / 1000;\\n    int rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000;\\n\\n    string result = \"\";\\n    if (billion != 0)\\n      result = three(billion) + \" Billion\";\\n    if (million != 0) {\\n      if (result.size()!=0)\\n        result += \" \";\\n      result += three(million) + \" Million\";\\n    }\\n    if (thousand != 0) {\\n      if (result.size()!=0)\\n        result += \" \";\\n      result += three(thousand) + \" Thousand\";\\n    }\\n    if (rest != 0) {\\n      if (result.size()!=0)\\n        result += \" \";\\n      result += three(rest);\\n    }\\n    return result;\\n    }\\n\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num == 0:\\n            return \"Zero\"\\n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\n        suffixes = [\"\", \"Thousand\", \"Million\", \"Billion\", \"Trillion\", \"Quadrillion\", \"Quintillion\", \"Sextillion\", \"Septillion\", \"Octillion\", \"Nonillion\", \"Decillion\"]\\n        words = []\\n        i = 0\\n        while num > 0:\\n            triplet = num % 1000\\n            num = num // 1000\\n            if triplet == 0:\\n                i += 1\\n                continue\\n            temp = []\\n            if triplet // 100 > 0:\\n                temp.append(ones[triplet // 100])\\n                temp.append(\"Hundred\")\\n            if triplet % 100 >= 10 and triplet % 100 <= 19:\\n                temp.append(teens[triplet % 10])\\n            else:\\n                if triplet % 100 >= 20:\\n                    temp.append(tens[triplet % 100 // 10])\\n                if triplet % 10 > 0:\\n                    temp.append(ones[triplet % 10])\\n            if i > 0:\\n                temp.append(suffixes[i])\\n            words = temp + words\\n            i += 1\\n        return \" \".join(words)\\n```\\n\\n```Java []\\nclass Solution {\\n\\n    private final String[] belowTwenty = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\\n            \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private final String[] tens = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n\\n    public String numberToWords(int num) {\\n        if (num == 0) {\\n            return \"Zero\";\\n        }\\n        return helper(num);\\n    }\\n\\n    private String helper(int num) {\\n        StringBuilder result = new StringBuilder();\\n        if (num < 20) {\\n            result.append(belowTwenty[num]);\\n        } else if (num < 100) {\\n            result.append(tens[num / 10]).append(\" \").append(belowTwenty[num % 10]);\\n        } else if (num < 1000) {\\n            result.append(helper(num / 100)).append(\" Hundred \").append(helper(num % 100));\\n        } else if (num < 1000000) {\\n            result.append(helper(num / 1000)).append(\" Thousand \").append(helper(num % 1000));\\n        } else if (num < 1000000000) {\\n            result.append(helper(num / 1000000)).append(\" Million \").append(helper(num % 1000000));\\n        } else {\\n            result.append(helper(num / 1000000000)).append(\" Billion \").append(helper(num % 1000000000));\\n        }\\n        return result.toString().trim();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string one(int num) {\\n    switch(num) {\\n      case 1: return \"One\";\\n      case 2: return \"Two\";\\n      case 3: return \"Three\";\\n      case 4: return \"Four\";\\n      case 5: return \"Five\";\\n      case 6: return \"Six\";\\n      case 7: return \"Seven\";\\n      case 8: return \"Eight\";\\n      case 9: return \"Nine\";\\n    }\\n    return \"\";\\n  }\\n\\n  string twoLessThan20(int num) {\\n    switch(num) {\\n      case 10: return \"Ten\";\\n      case 11: return \"Eleven\";\\n      case 12: return \"Twelve\";\\n      case 13: return \"Thirteen\";\\n      case 14: return \"Fourteen\";\\n      case 15: return \"Fifteen\";\\n      case 16: return \"Sixteen\";\\n      case 17: return \"Seventeen\";\\n      case 18: return \"Eighteen\";\\n      case 19: return \"Nineteen\";\\n    }\\n    return \"\";\\n  }\\n\\n  string ten(int num) {\\n    switch(num) {\\n      case 2: return \"Twenty\";\\n      case 3: return \"Thirty\";\\n      case 4: return \"Forty\";\\n      case 5: return \"Fifty\";\\n      case 6: return \"Sixty\";\\n      case 7: return \"Seventy\";\\n      case 8: return \"Eighty\";\\n      case 9: return \"Ninety\";\\n    }\\n    return \"\";\\n  }\\n\\n  string two(int num) {\\n    if (num == 0)\\n      return \"\";\\n    else if (num < 10)\\n      return one(num);\\n    else if (num < 20)\\n      return twoLessThan20(num);\\n    else {\\n      int tenner = num / 10;\\n      int rest = num - tenner * 10;\\n      if (rest != 0)\\n        return ten(tenner) + \" \" + one(rest);\\n      else\\n        return ten(tenner);\\n    }\\n  }\\n\\n  string three(int num) {\\n    int hundred = num / 100;\\n    int rest = num - hundred * 100;\\n    string res = \"\";\\n    if (hundred*rest != 0)\\n      res = one(hundred) + \" Hundred \" + two(rest);\\n    else if ((hundred == 0) && (rest != 0))\\n      res = two(rest);\\n    else if ((hundred != 0) && (rest == 0))\\n      res = one(hundred) + \" Hundred\";\\n    return res;\\n  }\\n\\n    string numberToWords(int num) {\\n        if (num == 0)\\n      return \"Zero\";\\n\\n    int billion = num / 1000000000;\\n    int million = (num - billion * 1000000000) / 1000000;\\n    int thousand = (num - billion * 1000000000 - million * 1000000) / 1000;\\n    int rest = num - billion * 1000000000 - million * 1000000 - thousand * 1000;\\n\\n    string result = \"\";\\n    if (billion != 0)\\n      result = three(billion) + \" Billion\";\\n    if (million != 0) {\\n      if (result.size()!=0)\\n        result += \" \";\\n      result += three(million) + \" Million\";\\n    }\\n    if (thousand != 0) {\\n      if (result.size()!=0)\\n        result += \" \";\\n      result += three(thousand) + \" Thousand\";\\n    }\\n    if (rest != 0) {\\n      if (result.size()!=0)\\n        result += \" \";\\n      result += three(rest);\\n    }\\n    return result;\\n    }\\n\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num == 0:\\n            return \"Zero\"\\n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\n        suffixes = [\"\", \"Thousand\", \"Million\", \"Billion\", \"Trillion\", \"Quadrillion\", \"Quintillion\", \"Sextillion\", \"Septillion\", \"Octillion\", \"Nonillion\", \"Decillion\"]\\n        words = []\\n        i = 0\\n        while num > 0:\\n            triplet = num % 1000\\n            num = num // 1000\\n            if triplet == 0:\\n                i += 1\\n                continue\\n            temp = []\\n            if triplet // 100 > 0:\\n                temp.append(ones[triplet // 100])\\n                temp.append(\"Hundred\")\\n            if triplet % 100 >= 10 and triplet % 100 <= 19:\\n                temp.append(teens[triplet % 10])\\n            else:\\n                if triplet % 100 >= 20:\\n                    temp.append(tens[triplet % 100 // 10])\\n                if triplet % 10 > 0:\\n                    temp.append(ones[triplet % 10])\\n            if i > 0:\\n                temp.append(suffixes[i])\\n            words = temp + words\\n            i += 1\\n        return \" \".join(words)\\n```\n```Java []\\nclass Solution {\\n\\n    private final String[] belowTwenty = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\\n            \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private final String[] tens = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n\\n    public String numberToWords(int num) {\\n        if (num == 0) {\\n            return \"Zero\";\\n        }\\n        return helper(num);\\n    }\\n\\n    private String helper(int num) {\\n        StringBuilder result = new StringBuilder();\\n        if (num < 20) {\\n            result.append(belowTwenty[num]);\\n        } else if (num < 100) {\\n            result.append(tens[num / 10]).append(\" \").append(belowTwenty[num % 10]);\\n        } else if (num < 1000) {\\n            result.append(helper(num / 100)).append(\" Hundred \").append(helper(num % 100));\\n        } else if (num < 1000000) {\\n            result.append(helper(num / 1000)).append(\" Thousand \").append(helper(num % 1000));\\n        } else if (num < 1000000000) {\\n            result.append(helper(num / 1000000)).append(\" Million \").append(helper(num % 1000000));\\n        } else {\\n            result.append(helper(num / 1000000000)).append(\" Billion \").append(helper(num % 1000000000));\\n        }\\n        return result.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70651,
                "title": "fairly-clear-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        static string numberToWords(int n) {\\n            if(n == 0) return \"Zero\";\\n            else return int_string(n).substr(1);\\n        }\\n    private:\\n        static const char * const below_20[];\\n        static const char * const below_100[];\\n        static string int_string(int n) {\\n            if(n >= 1000000000)   return int_string(n / 1000000000) + \" Billion\" + int_string(n - 1000000000 * (n / 1000000000));\\n            else if(n >= 1000000) return int_string(n / 1000000) + \" Million\" + int_string(n - 1000000 * (n / 1000000));\\n            else if(n >= 1000)    return int_string(n / 1000) + \" Thousand\" + int_string(n - 1000 * (n / 1000));\\n            else if(n >= 100)     return int_string(n / 100) + \" Hundred\" + int_string(n - 100 * (n / 100));\\n            else if(n >= 20)      return string(\" \") + below_100[n / 10 - 2] + int_string(n - 10 * (n / 10));\\n            else if(n >= 1)       return string(\" \") + below_20[n - 1];\\n            else return \"\";\\n            }\\n        }\\n    };\\n\\n    const char * const Solution::below_20[] =  {\"One\", \"Two\", \"Three\", \"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\", \"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n    const char * const Solution::below_100[] = {\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        static string numberToWords(int n) {\\n            if(n == 0) return \"Zero\";\\n            else return int_string(n).substr(1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 70688,
                "title": "python-clean-solution",
                "content": "    def __init__(self):\\n        self.lessThan20 = [\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"]\\n        self.tens = [\"\",\"Ten\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"]\\n        self.thousands = [\"\",\"Thousand\",\"Million\",\"Billion\"]\\n    \\n    def numberToWords(self, num):\\n        if num == 0:\\n            return \"Zero\"\\n        res = \"\"\\n        for i in range(len(self.thousands)):\\n            if num % 1000 != 0:\\n                res = self.helper(num%1000) + self.thousands[i] + \" \" + res\\n            num /= 1000\\n        return res.strip()\\n    \\n    def helper(self, num):\\n        if num == 0:\\n            return \"\"\\n        elif num < 20:\\n            return self.lessThan20[num] + \" \"\\n        elif num < 100:\\n            return self.tens[num/10] + \" \" + self.helper(num%10)\\n        else:\\n            return self.lessThan20[num/100] + \" Hundred \" + self.helper(num%100)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def __init__(self):\\n        self.lessThan20 = [\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"]\\n        self.tens = [\"\",\"Ten\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"]\\n        self.thousands = [\"\",\"Thousand\",\"Million\",\"Billion\"]\\n    \\n    def numberToWords(self, num):\\n        if num == 0:\\n            return \"Zero\"\\n        res = \"\"\\n        for i in range(len(self.thousands)):\\n            if num % 1000 != 0:\\n                res = self.helper(num%1000) + self.thousands[i] + \" \" + res\\n            num /= 1000\\n        return res.strip()\\n    \\n    def helper(self, num):\\n        if num == 0:\\n            return \"\"\\n        elif num < 20:\\n            return self.lessThan20[num] + \" \"\\n        elif num < 100:\\n            return self.tens[num/10] + \" \" + self.helper(num%10)\\n        else:\\n            return self.lessThan20[num/100] + \" Hundred \" + self.helper(num%100)",
                "codeTag": "Python3"
            },
            {
                "id": 1065769,
                "title": "simple-java-solution-1-ms-100-beats",
                "content": "```\\nclass Solution {\\n    String[] tens = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    String[] ones = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\",\\n                    \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n\\n    public String numberToWords(int num) {\\n        if (num == 0)\\n            return \"Zero\";\\n        \\n        return helper(num).trim();\\n    }\\n    \\n    private String helper(int num) {\\n        StringBuilder sb=new StringBuilder();\\n        if (num >= 1000000000) {\\n            sb.append(helper(num / 1000000000)).append(\" Billion \").append( helper(num % 1000000000));\\n        } else if  (num >= 1000000) {\\n            sb.append(helper(num / 1000000)).append(\" Million \").append( helper(num % 1000000));\\n        }else if (num >= 1000) {\\n            sb.append(helper(num / 1000)).append(\" Thousand \").append( helper(num % 1000));\\n        }else if (num >= 100) {\\n            sb.append(helper(num / 100)).append(\" Hundred \").append( helper(num % 100));\\n        }else if (num >= 20) {\\n            sb.append(tens[num / 10]).append(\" \").append( helper(num % 10));\\n        } else {\\n            sb.append(ones[num]);\\n        }\\n        return sb.toString().trim();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String[] tens = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    String[] ones = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\",\\n                    \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n\\n    public String numberToWords(int num) {\\n        if (num == 0)\\n            return \"Zero\";\\n        \\n        return helper(num).trim();\\n    }\\n    \\n    private String helper(int num) {\\n        StringBuilder sb=new StringBuilder();\\n        if (num >= 1000000000) {\\n            sb.append(helper(num / 1000000000)).append(\" Billion \").append( helper(num % 1000000000));\\n        } else if  (num >= 1000000) {\\n            sb.append(helper(num / 1000000)).append(\" Million \").append( helper(num % 1000000));\\n        }else if (num >= 1000) {\\n            sb.append(helper(num / 1000)).append(\" Thousand \").append( helper(num % 1000));\\n        }else if (num >= 100) {\\n            sb.append(helper(num / 100)).append(\" Hundred \").append( helper(num % 100));\\n        }else if (num >= 20) {\\n            sb.append(tens[num / 10]).append(\" \").append( helper(num % 10));\\n        } else {\\n            sb.append(ones[num]);\\n        }\\n        return sb.toString().trim();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70647,
                "title": "4-ms-java-solution",
                "content": "```\\n    public String numberToWords(int num) {\\n        if(num==0) {\\n            return \"Zero\";\\n        }\\n        return helper(num);\\n    }\\n    public String helper(int num) {\\n        String[] words = new String[] {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\\n        \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\", \\n\\t\\t\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        StringBuilder res = new StringBuilder();\\n        \\n        if(num>=1000000000) {\\n            res.append(helper(num/1000000000)).append(\" Billion \").append(helper(num%1000000000));\\n        } else if(num>=1000000) {\\n            res.append(helper(num/1000000)).append(\" Million \").append(helper(num%1000000));\\n        } else if(num>=1000) {\\n            res.append(helper(num/1000)).append(\" Thousand \").append(helper(num%1000));\\n        } else if(num>=100) {\\n            res.append(helper(num/100)).append(\" Hundred \").append(helper(num%100));\\n        } else if(num>=20) {\\n            res.append(words[(num-20)/10+20]).append(\" \").append(words[num%10]);\\n        } else {\\n            res.append(words[num]);\\n        }\\n        \\n        return res.toString().trim();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String numberToWords(int num) {\\n        if(num==0) {\\n            return \"Zero\";\\n        }\\n        return helper(num);\\n    }\\n    public String helper(int num) {\\n        String[] words = new String[] {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\\n        \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\", \\n\\t\\t\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        StringBuilder res = new StringBuilder();\\n        \\n        if(num>=1000000000) {\\n            res.append(helper(num/1000000000)).append(\" Billion \").append(helper(num%1000000000));\\n        } else if(num>=1000000) {\\n            res.append(helper(num/1000000)).append(\" Million \").append(helper(num%1000000));\\n        } else if(num>=1000) {\\n            res.append(helper(num/1000)).append(\" Thousand \").append(helper(num%1000));\\n        } else if(num>=100) {\\n            res.append(helper(num/100)).append(\" Hundred \").append(helper(num%100));\\n        } else if(num>=20) {\\n            res.append(words[(num-20)/10+20]).append(\" \").append(words[num%10]);\\n        } else {\\n            res.append(words[num]);\\n        }\\n        \\n        return res.toString().trim();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3220257,
                "title": "c-recursion-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Declare three string arrays to hold words for numbers (0-19), ten-digit numbers (10-90), and thousands (1K, 1M, 1B).\\n2. Define a helper function that takes an integer as input and returns its English representation.\\n3. In the helper function, use a recursive approach to convert the input number into English words.\\n4. Base cases:\\n    - a. If the number is less than 20, return its corresponding word from the ones array.\\n    - b. If the number is less than 100, return its corresponding word from the tens array plus a recursive call to the helper function with the remainder of the division by 10.\\n    - c. If the number is less than 1000, return its corresponding word from the ones array divided by 100, the word \"Hundred\", and a recursive call to the helper function with the remainder of the division by 100.\\n    - d. For larger numbers, loop through the thousands array from largest to smallest, and recursively call the helper function with the quotient of the input number divided by 1000 raised to the current index of the loop. Append the corresponding word from the thousands array to the result, and then recursively call the helper function with the remainder of the division by 1000 raised to the current index of the loop.\\n1. In the numberToWords function, handle the edge case where the input number is zero. If it is, return the string \"Zero\". Otherwise, call the helper function with the input number, and remove the leading space using substr(1).\\n2. Return the resulting string.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    //globally declare arrays\\n    string ones[20] = {\"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\", \" Seven\", \" Eight\", \" Nine\", \" Ten\", \" Eleven\", \" Twelve\", \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\", \" Eighteen\", \" Nineteen\"};\\n    string tens[10] = {\"\", \" Ten\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\", \" Seventy\", \" Eighty\", \" Ninety\"};\\n    string thousands[4] = {\"\", \" Thousand\", \" Million\", \" Billion\"};\\n    //helper function\\n    string helper(int n) {\\n        if (n < 20) \\n            return ones[n];\\n        if (n < 100) \\n            return tens[n / 10] + helper(n % 10);\\n        if (n < 1000) \\n            return helper(n / 100) + \" Hundred\" + helper(n % 100);\\n        for (int i = 3; i >= 0; i--) {\\n            if (n >= pow(1000, i)) {\\n                return helper(n / pow(1000, i)) + thousands[i] + helper(n % (int)pow(1000, i));\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    string numberToWords(int num) {\\n        // edge case\\n        if (num == 0) \\n            return \"Zero\";\\n        return helper(num).substr(1);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    //globally declare arrays\\n    String[] ones = {\"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\", \" Seven\", \" Eight\", \" Nine\", \" Ten\", \" Eleven\", \" Twelve\", \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\", \" Eighteen\", \" Nineteen\"};\\n    String[] tens = {\"\", \" Ten\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\", \" Seventy\", \" Eighty\", \" Ninety\"};\\n    String[] thousands = {\"\", \" Thousand\", \" Million\", \" Billion\"};\\n    //helper function\\n    public String helper(int n) {\\n        if (n < 20) \\n            return ones[n];\\n        if (n < 100) \\n            return tens[n / 10] + helper(n % 10);\\n        if (n < 1000) \\n            return helper(n / 100) + \" Hundred\" + helper(n % 100);\\n        for (int i = 3; i >= 0; i--) {\\n            if (n >= Math.pow(1000, i)) {\\n                return helper((int)(n / Math.pow(1000, i))) + thousands[i] + helper((int)(n % Math.pow(1000, i)));\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public String numberToWords(int num) {\\n        // edge case\\n        if (num == 0) \\n            return \"Zero\";\\n        return helper(num).substring(1);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        #initialize arrays\\n        self.ones = [\\'\\', \\' One\\', \\' Two\\', \\' Three\\', \\' Four\\', \\' Five\\', \\' Six\\', \\' Seven\\', \\' Eight\\', \\' Nine\\', \\' Ten\\', \\' Eleven\\', \\' Twelve\\', \\' Thirteen\\', \\' Fourteen\\', \\' Fifteen\\', \\' Sixteen\\', \\' Seventeen\\', \\' Eighteen\\', \\' Nineteen\\']\\n        self.tens = [\\'\\', \\' Ten\\', \\' Twenty\\', \\' Thirty\\', \\' Forty\\', \\' Fifty\\', \\' Sixty\\', \\' Seventy\\', \\' Eighty\\', \\' Ninety\\']\\n        self.thousands = [\\'\\', \\' Thousand\\', \\' Million\\', \\' Billion\\']\\n    \\n    def helper(self, n: int) -> str:\\n        if n < 20:\\n            return self.ones[n]\\n        elif n < 100:\\n            return self.tens[n // 10] + self.helper(n % 10)\\n        elif n < 1000:\\n            return self.helper(n // 100) + \\' Hundred\\' + self.helper(n % 100)\\n        else:\\n            for i in range(3, 0, -1):\\n                if n >= 1000 ** i:\\n                    return self.helper(n // (1000 ** i)) + self.thousands[i] + self.helper(n % (1000 ** i))\\n        return \\'\\'\\n    \\n    def numberToWords(self, num: int) -> str:\\n        #edge case\\n        if num == 0:\\n            return \\'Zero\\'\\n        return self.helper(num).lstrip()\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(log10(n))**, where n is the input number. This is because the number of recursive calls is proportional to the number of digits in the input number.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(log10(n))**, where n is the input number. This is because the maximum amount of space used on the call stack is proportional to the number of digits in the input number.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    //globally declare arrays\\n    string ones[20] = {\"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\", \" Seven\", \" Eight\", \" Nine\", \" Ten\", \" Eleven\", \" Twelve\", \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\", \" Eighteen\", \" Nineteen\"};\\n    string tens[10] = {\"\", \" Ten\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\", \" Seventy\", \" Eighty\", \" Ninety\"};\\n    string thousands[4] = {\"\", \" Thousand\", \" Million\", \" Billion\"};\\n    //helper function\\n    string helper(int n) {\\n        if (n < 20) \\n            return ones[n];\\n        if (n < 100) \\n            return tens[n / 10] + helper(n % 10);\\n        if (n < 1000) \\n            return helper(n / 100) + \" Hundred\" + helper(n % 100);\\n        for (int i = 3; i >= 0; i--) {\\n            if (n >= pow(1000, i)) {\\n                return helper(n / pow(1000, i)) + thousands[i] + helper(n % (int)pow(1000, i));\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    string numberToWords(int num) {\\n        // edge case\\n        if (num == 0) \\n            return \"Zero\";\\n        return helper(num).substr(1);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    //globally declare arrays\\n    String[] ones = {\"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\", \" Seven\", \" Eight\", \" Nine\", \" Ten\", \" Eleven\", \" Twelve\", \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\", \" Eighteen\", \" Nineteen\"};\\n    String[] tens = {\"\", \" Ten\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\", \" Seventy\", \" Eighty\", \" Ninety\"};\\n    String[] thousands = {\"\", \" Thousand\", \" Million\", \" Billion\"};\\n    //helper function\\n    public String helper(int n) {\\n        if (n < 20) \\n            return ones[n];\\n        if (n < 100) \\n            return tens[n / 10] + helper(n % 10);\\n        if (n < 1000) \\n            return helper(n / 100) + \" Hundred\" + helper(n % 100);\\n        for (int i = 3; i >= 0; i--) {\\n            if (n >= Math.pow(1000, i)) {\\n                return helper((int)(n / Math.pow(1000, i))) + thousands[i] + helper((int)(n % Math.pow(1000, i)));\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public String numberToWords(int num) {\\n        // edge case\\n        if (num == 0) \\n            return \"Zero\";\\n        return helper(num).substring(1);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def __init__(self):\\n        #initialize arrays\\n        self.ones = [\\'\\', \\' One\\', \\' Two\\', \\' Three\\', \\' Four\\', \\' Five\\', \\' Six\\', \\' Seven\\', \\' Eight\\', \\' Nine\\', \\' Ten\\', \\' Eleven\\', \\' Twelve\\', \\' Thirteen\\', \\' Fourteen\\', \\' Fifteen\\', \\' Sixteen\\', \\' Seventeen\\', \\' Eighteen\\', \\' Nineteen\\']\\n        self.tens = [\\'\\', \\' Ten\\', \\' Twenty\\', \\' Thirty\\', \\' Forty\\', \\' Fifty\\', \\' Sixty\\', \\' Seventy\\', \\' Eighty\\', \\' Ninety\\']\\n        self.thousands = [\\'\\', \\' Thousand\\', \\' Million\\', \\' Billion\\']\\n    \\n    def helper(self, n: int) -> str:\\n        if n < 20:\\n            return self.ones[n]\\n        elif n < 100:\\n            return self.tens[n // 10] + self.helper(n % 10)\\n        elif n < 1000:\\n            return self.helper(n // 100) + \\' Hundred\\' + self.helper(n % 100)\\n        else:\\n            for i in range(3, 0, -1):\\n                if n >= 1000 ** i:\\n                    return self.helper(n // (1000 ** i)) + self.thousands[i] + self.helper(n % (1000 ** i))\\n        return \\'\\'\\n    \\n    def numberToWords(self, num: int) -> str:\\n        #edge case\\n        if num == 0:\\n            return \\'Zero\\'\\n        return self.helper(num).lstrip()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188334,
                "title": "c-4-lines",
                "content": "I only need one definition of numbers in the decreasing order:\\n```\\nvector<pair<int, string>> nums =\\n{\\n    {1000000000, \"Billion\"}, {1000000, \"Million\"}, {1000, \"Thousand\"}, {100, \"Hundred\"},\\n    {90, \"Ninety\"},{80, \"Eighty\"},{70, \"Seventy\"},{60, \"Sixty\"}, \\n    {50, \"Fifty\"}, {40, \"Forty\"}, {30, \"Thirty\"}, {20, \"Twenty\"},\\n    {19, \"Nineteen\"}, {18, \"Eighteen\"}, {17, \"Seventeen\"}, {16, \"Sixteen\"}, {15, \"Fifteen\"},\\n    {14, \"Fourteen\"}, {13, \"Thirteen\"}, {12, \"Twelve\"}, {11, \"Eleven\"}, {10, \"Ten\"},\\n    {9, \"Nine\"},{8, \"Eight\"},{7, \"Seven\"},{6, \"Six\"}, {5, \"Five\"}, {4, \"Four\"}, {3, \"Three\"}, {2, \"Two\"}, {1, \"One\"}\\n};\\n```\\nThe main function is fairly straightforward:\\n```\\nstring numberToWords(int num) {\\n  if (num == 0) return \"Zero\";\\n  for (auto it = nums.begin(); ; ++it)\\n    if (num / it->first > 0)\\n      return (num >= 100 ? numberToWords(num / it->first) + \" \" : \"\") + it->second +\\n        (num % it->first == 0 ? \"\" : \" \" + numberToWords(num % it->first));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<pair<int, string>> nums =\\n{\\n    {1000000000, \"Billion\"}, {1000000, \"Million\"}, {1000, \"Thousand\"}, {100, \"Hundred\"},\\n    {90, \"Ninety\"},{80, \"Eighty\"},{70, \"Seventy\"},{60, \"Sixty\"}, \\n    {50, \"Fifty\"}, {40, \"Forty\"}, {30, \"Thirty\"}, {20, \"Twenty\"},\\n    {19, \"Nineteen\"}, {18, \"Eighteen\"}, {17, \"Seventeen\"}, {16, \"Sixteen\"}, {15, \"Fifteen\"},\\n    {14, \"Fourteen\"}, {13, \"Thirteen\"}, {12, \"Twelve\"}, {11, \"Eleven\"}, {10, \"Ten\"},\\n    {9, \"Nine\"},{8, \"Eight\"},{7, \"Seven\"},{6, \"Six\"}, {5, \"Five\"}, {4, \"Four\"}, {3, \"Three\"}, {2, \"Two\"}, {1, \"One\"}\\n};\\n```\n```\\nstring numberToWords(int num) {\\n  if (num == 0) return \"Zero\";\\n  for (auto it = nums.begin(); ; ++it)\\n    if (num / it->first > 0)\\n      return (num >= 100 ? numberToWords(num / it->first) + \" \" : \"\") + it->second +\\n        (num % it->first == 0 ? \"\" : \" \" + numberToWords(num % it->first));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119847,
                "title": "easy-c-solution-recursion-5-lines-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, string>> nums ={{1000000000, \"Billion\"}, {1000000, \"Million\"}, \\n    {1000, \"Thousand\"}, {100, \"Hundred\"}, {90, \"Ninety\"}, {80, \"Eighty\"}, {70, \"Seventy\"},\\n    {60, \"Sixty\"}, {50, \"Fifty\"}, {40, \"Forty\"}, {30, \"Thirty\"}, {20, \"Twenty\"}, {19, \"Nineteen\"}, \\n    {18, \"Eighteen\"}, {17, \"Seventeen\"}, {16, \"Sixteen\"}, {15, \"Fifteen\"}, {14, \"Fourteen\"}, \\n    {13, \"Thirteen\"}, {12, \"Twelve\"}, {11, \"Eleven\"}, {10, \"Ten\"}, {9, \"Nine\"}, {8, \"Eight\"}, \\n    {7, \"Seven\"}, {6, \"Six\"}, {5, \"Five\"}, {4, \"Four\"}, {3, \"Three\"}, {2, \"Two\"}, {1, \"One\"}};\\n    \\n    string numberToWords(int num) {\\n        if(num == 0)   return \"Zero\";\\n        \\n        for(auto it: nums)\\n            if(num >= it.first)\\n                return (num >= 100 ? numberToWords(num/it.first)+\" \" : \"\") + it.second + (num%it.first == 0 ? \"\" : \" \"+numberToWords(num%it.first));\\n    \\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, string>> nums ={{1000000000, \"Billion\"}, {1000000, \"Million\"}, \\n    {1000, \"Thousand\"}, {100, \"Hundred\"}, {90, \"Ninety\"}, {80, \"Eighty\"}, {70, \"Seventy\"},\\n    {60, \"Sixty\"}, {50, \"Fifty\"}, {40, \"Forty\"}, {30, \"Thirty\"}, {20, \"Twenty\"}, {19, \"Nineteen\"}, \\n    {18, \"Eighteen\"}, {17, \"Seventeen\"}, {16, \"Sixteen\"}, {15, \"Fifteen\"}, {14, \"Fourteen\"}, \\n    {13, \"Thirteen\"}, {12, \"Twelve\"}, {11, \"Eleven\"}, {10, \"Ten\"}, {9, \"Nine\"}, {8, \"Eight\"}, \\n    {7, \"Seven\"}, {6, \"Six\"}, {5, \"Five\"}, {4, \"Four\"}, {3, \"Three\"}, {2, \"Two\"}, {1, \"One\"}};\\n    \\n    string numberToWords(int num) {\\n        if(num == 0)   return \"Zero\";\\n        \\n        for(auto it: nums)\\n            if(num >= it.first)\\n                return (num >= 100 ? numberToWords(num/it.first)+\" \" : \"\") + it.second + (num%it.first == 0 ? \"\" : \" \"+numberToWords(num%it.first));\\n    \\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696285,
                "title": "python-solution-with-interview-tip",
                "content": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        ## RC ##\\n        ## APPROACH : BRUTE FORCE ##\\n        ## Main intent of the interviewer when asked this question is , he is testing how you are handling the test cases and how elagantly you are using sub problems to get to the final solution ## (so focus on edge cases)\\n        ## 1. For a two digit number if there is no ones digit 20 -> twenty + \" \" (number generally), dont leave the space behind, use if else case with \"\" (empty). Similarly for 20,000 etc.\\n        \\n        one_digit = {\\n            1: \\'One\\',\\n            2: \\'Two\\',\\n            3: \\'Three\\',\\n            4: \\'Four\\',\\n            5: \\'Five\\',\\n            6: \\'Six\\',\\n            7: \\'Seven\\',\\n            8: \\'Eight\\',\\n            9: \\'Nine\\'\\n        }\\n\\n        two_digit = {\\n            10: \\'Ten\\',\\n            11: \\'Eleven\\',\\n            12: \\'Twelve\\',\\n            13: \\'Thirteen\\',\\n            14: \\'Fourteen\\',\\n            15: \\'Fifteen\\',\\n            16: \\'Sixteen\\',\\n            17: \\'Seventeen\\',\\n            18: \\'Eighteen\\',\\n            19: \\'Nineteen\\'\\n        }\\n        \\n        tens = {\\n            2: \\'Twenty\\',\\n            3: \\'Thirty\\',\\n            4: \\'Forty\\',\\n            5: \\'Fifty\\',\\n            6: \\'Sixty\\',\\n            7: \\'Seventy\\',\\n            8: \\'Eighty\\',\\n            9: \\'Ninety\\'\\n        }\\n        \\n        def get_three_digit_num(num):\\n            if( not num ) : return \"\"\\n            if( not num// 100 ): return get_two_digit_num(num)\\n            return one_digit[ num // 100 ] + \" Hundred\" + ((\" \" + get_two_digit_num( num % 100 )) if( num % 100 ) else \"\")\\n        \\n        def get_two_digit_num( num ):\\n            if not num:\\n                return \\'\\'\\n            elif num < 10:\\n                return one_digit[ num ]\\n            elif num < 20:\\n                return two_digit[ num ]\\n                    # edge case 1\\n            return tens[ num//10 ] + ((\" \" + one_digit[ num % 10 ]) if( num % 10 ) else \"\")\\n        \\n        # edge case\\n        if(num == 0): return \"Zero\"\\n        \\n        billion = num // 1000000000\\n        million = (num - billion * 1000000000) // 1000000\\n        thousand = (num - billion * 1000000000 - million * 1000000) // 1000\\n        last_three = num - billion * 1000000000 - million * 1000000 - thousand * 1000\\n        \\n        result = \\'\\'\\n        if billion:        \\n            result = get_three_digit_num(billion) + \\' Billion\\'\\n        if million:\\n            # space only when prev result is not None\\n            result += \\' \\' if result else \\'\\'    \\n            result += get_three_digit_num(million) + \\' Million\\'\\n        if thousand:\\n            result += \\' \\' if result else \\'\\'\\n            result += get_three_digit_num(thousand) + \\' Thousand\\'\\n        if last_three:\\n            result += \\' \\' if result else \\'\\'\\n            result += get_three_digit_num(last_three)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        ## RC ##\\n        ## APPROACH : BRUTE FORCE ##\\n        ## Main intent of the interviewer when asked this question is , he is testing how you are handling the test cases and how elagantly you are using sub problems to get to the final solution ## (so focus on edge cases)\\n        ## 1. For a two digit number if there is no ones digit 20 -> twenty + \" \" (number generally), dont leave the space behind, use if else case with \"\" (empty). Similarly for 20,000 etc.\\n        \\n        one_digit = {\\n            1: \\'One\\',\\n            2: \\'Two\\',\\n            3: \\'Three\\',\\n            4: \\'Four\\',\\n            5: \\'Five\\',\\n            6: \\'Six\\',\\n            7: \\'Seven\\',\\n            8: \\'Eight\\',\\n            9: \\'Nine\\'\\n        }\\n\\n        two_digit = {\\n            10: \\'Ten\\',\\n            11: \\'Eleven\\',\\n            12: \\'Twelve\\',\\n            13: \\'Thirteen\\',\\n            14: \\'Fourteen\\',\\n            15: \\'Fifteen\\',\\n            16: \\'Sixteen\\',\\n            17: \\'Seventeen\\',\\n            18: \\'Eighteen\\',\\n            19: \\'Nineteen\\'\\n        }\\n        \\n        tens = {\\n            2: \\'Twenty\\',\\n            3: \\'Thirty\\',\\n            4: \\'Forty\\',\\n            5: \\'Fifty\\',\\n            6: \\'Sixty\\',\\n            7: \\'Seventy\\',\\n            8: \\'Eighty\\',\\n            9: \\'Ninety\\'\\n        }\\n        \\n        def get_three_digit_num(num):\\n            if( not num ) : return \"\"\\n            if( not num// 100 ): return get_two_digit_num(num)\\n            return one_digit[ num // 100 ] + \" Hundred\" + ((\" \" + get_two_digit_num( num % 100 )) if( num % 100 ) else \"\")\\n        \\n        def get_two_digit_num( num ):\\n            if not num:\\n                return \\'\\'\\n            elif num < 10:\\n                return one_digit[ num ]\\n            elif num < 20:\\n                return two_digit[ num ]\\n                    # edge case 1\\n            return tens[ num//10 ] + ((\" \" + one_digit[ num % 10 ]) if( num % 10 ) else \"\")\\n        \\n        # edge case\\n        if(num == 0): return \"Zero\"\\n        \\n        billion = num // 1000000000\\n        million = (num - billion * 1000000000) // 1000000\\n        thousand = (num - billion * 1000000000 - million * 1000000) // 1000\\n        last_three = num - billion * 1000000000 - million * 1000000 - thousand * 1000\\n        \\n        result = \\'\\'\\n        if billion:        \\n            result = get_three_digit_num(billion) + \\' Billion\\'\\n        if million:\\n            # space only when prev result is not None\\n            result += \\' \\' if result else \\'\\'    \\n            result += get_three_digit_num(million) + \\' Million\\'\\n        if thousand:\\n            result += \\' \\' if result else \\'\\'\\n            result += get_three_digit_num(thousand) + \\' Thousand\\'\\n        if last_three:\\n            result += \\' \\' if result else \\'\\'\\n            result += get_three_digit_num(last_three)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387062,
                "title": "simpla-javascript-solution-using-map",
                "content": "```js\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar numberToWords = function(num) {\\n  if (num === 0) {\\n    return \\'Zero\\';\\n  }\\n  \\n  if (num <= 20) {\\n    return translations.get(num);\\n  }\\n  \\n  let result = [];\\n  \\n  for (let [value, translation] of translations) {\\n    const times = Math.floor(num / value);\\n    \\n    if (times === 0) {\\n      continue;\\n    }\\n    \\n    num -= times * value;\\n    \\n    if (times === 1 && value >= 100) {\\n      result.push(\\'One\\', translation);\\n      continue;\\n    }\\n    \\n    if (times === 1) {\\n      result.push(translation);\\n      continue;\\n    }\\n    \\n    result.push(numberToWords(times), translation);\\n  }\\n  \\n  return result.join(\\' \\');\\n};\\n\\nconst translations = new Map([\\n  [1000000000, \\'Billion\\'],\\n  [1000000, \\'Million\\'],\\n  [1000, \\'Thousand\\'],\\n  [100, \\'Hundred\\'],\\n  [90, \\'Ninety\\'],\\n  [80, \\'Eighty\\'],\\n  [70, \\'Seventy\\'],\\n  [60, \\'Sixty\\'],\\n  [50, \\'Fifty\\'],\\n  [40, \\'Forty\\'],\\n  [30, \\'Thirty\\'],\\n  [20, \\'Twenty\\'],\\n  [19, \\'Nineteen\\'],\\n  [18, \\'Eighteen\\'],\\n  [17, \\'Seventeen\\'],\\n  [16, \\'Sixteen\\'],\\n  [15, \\'Fifteen\\'],\\n  [14, \\'Fourteen\\'],\\n  [13, \\'Thirteen\\'],\\n  [12, \\'Twelve\\'],\\n  [11, \\'Eleven\\'],\\n  [10, \\'Ten\\'],\\n  [9, \\'Nine\\'],\\n  [8, \\'Eight\\'],\\n  [7, \\'Seven\\'],\\n  [6, \\'Six\\'],\\n  [5, \\'Five\\'],\\n  [4, \\'Four\\'],\\n  [3, \\'Three\\'],\\n  [2, \\'Two\\'],\\n  [1, \\'One\\'],\\n]);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar numberToWords = function(num) {\\n  if (num === 0) {\\n    return \\'Zero\\';\\n  }\\n  \\n  if (num <= 20) {\\n    return translations.get(num);\\n  }\\n  \\n  let result = [];\\n  \\n  for (let [value, translation] of translations) {\\n    const times = Math.floor(num / value);\\n    \\n    if (times === 0) {\\n      continue;\\n    }\\n    \\n    num -= times * value;\\n    \\n    if (times === 1 && value >= 100) {\\n      result.push(\\'One\\', translation);\\n      continue;\\n    }\\n    \\n    if (times === 1) {\\n      result.push(translation);\\n      continue;\\n    }\\n    \\n    result.push(numberToWords(times), translation);\\n  }\\n  \\n  return result.join(\\' \\');\\n};\\n\\nconst translations = new Map([\\n  [1000000000, \\'Billion\\'],\\n  [1000000, \\'Million\\'],\\n  [1000, \\'Thousand\\'],\\n  [100, \\'Hundred\\'],\\n  [90, \\'Ninety\\'],\\n  [80, \\'Eighty\\'],\\n  [70, \\'Seventy\\'],\\n  [60, \\'Sixty\\'],\\n  [50, \\'Fifty\\'],\\n  [40, \\'Forty\\'],\\n  [30, \\'Thirty\\'],\\n  [20, \\'Twenty\\'],\\n  [19, \\'Nineteen\\'],\\n  [18, \\'Eighteen\\'],\\n  [17, \\'Seventeen\\'],\\n  [16, \\'Sixteen\\'],\\n  [15, \\'Fifteen\\'],\\n  [14, \\'Fourteen\\'],\\n  [13, \\'Thirteen\\'],\\n  [12, \\'Twelve\\'],\\n  [11, \\'Eleven\\'],\\n  [10, \\'Ten\\'],\\n  [9, \\'Nine\\'],\\n  [8, \\'Eight\\'],\\n  [7, \\'Seven\\'],\\n  [6, \\'Six\\'],\\n  [5, \\'Five\\'],\\n  [4, \\'Four\\'],\\n  [3, \\'Three\\'],\\n  [2, \\'Two\\'],\\n  [1, \\'One\\'],\\n]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164087,
                "title": "python-100-and-easy-to-understand-solution",
                "content": "\\n```\\nclass Solution(object):\\n    def numberToWords(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n\\n        n2w = {1e9: \"Billion\", 1e6: \"Million\", 1e3: \"Thousand\", 1e2: \"Hundred\",\\n               90:  \"Ninety\", 80:  \"Eighty\", 70:  \"Seventy\",\\n               60:  \"Sixty\", 50:  \"Fifty\", 40:  \"Forty\",\\n               30:  \"Thirty\", 20:  \"Twenty\", 19: \"Nineteen\",\\n               18:  \"Eighteen\", 17: \"Seventeen\", 16: \"Sixteen\",\\n               15:  \"Fifteen\", 14: \"Fourteen\", 13: \"Thirteen\",\\n               12:  \"Twelve\", 11:  \"Eleven\", 10:  \"Ten\",\\n               9:   \"Nine\", 8:   \"Eight\", 7:   \"Seven\",\\n               6:   \"Six\", 5:   \"Five\", 4: \"Four\", 3: \"Three\",\\n               2: \"Two\", 1: \"One\", 0: \"Zero\"}\\n\\n        keys = [1000000000, 1000000, 1000, 100, 90, 80, 70,\\n               60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 14, 13, 12,\\n               11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\\n\\n        def dp(n):\\n            if n <= 20: return n2w[n]\\n            for div in keys:\\n                d, r = divmod(n, div)\\n                if not d: continue\\n                s1 = dp(d) + \" \" if div >= 100 else \"\"\\n                s2 = \" \" + dp(r) if r else \"\"\\n                return s1 + n2w[div] + s2\\n\\n        return dp(num)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numberToWords(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n\\n        n2w = {1e9: \"Billion\", 1e6: \"Million\", 1e3: \"Thousand\", 1e2: \"Hundred\",\\n               90:  \"Ninety\", 80:  \"Eighty\", 70:  \"Seventy\",\\n               60:  \"Sixty\", 50:  \"Fifty\", 40:  \"Forty\",\\n               30:  \"Thirty\", 20:  \"Twenty\", 19: \"Nineteen\",\\n               18:  \"Eighteen\", 17: \"Seventeen\", 16: \"Sixteen\",\\n               15:  \"Fifteen\", 14: \"Fourteen\", 13: \"Thirteen\",\\n               12:  \"Twelve\", 11:  \"Eleven\", 10:  \"Ten\",\\n               9:   \"Nine\", 8:   \"Eight\", 7:   \"Seven\",\\n               6:   \"Six\", 5:   \"Five\", 4: \"Four\", 3: \"Three\",\\n               2: \"Two\", 1: \"One\", 0: \"Zero\"}\\n\\n        keys = [1000000000, 1000000, 1000, 100, 90, 80, 70,\\n               60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 14, 13, 12,\\n               11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\\n\\n        def dp(n):\\n            if n <= 20: return n2w[n]\\n            for div in keys:\\n                d, r = divmod(n, div)\\n                if not d: continue\\n                s1 = dp(d) + \" \" if div >= 100 else \"\"\\n                s2 = \" \" + dp(r) if r else \"\"\\n                return s1 + n2w[div] + s2\\n\\n        return dp(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158134,
                "title": "shorter-than-the-best-answer-pure-recursion",
                "content": "`IM` stands for Integer map and `SM` stands for String Map. The reason why `IM[i] >= 100` is considered is because if we have some number like 100, 1000 etc..we say it as `one hundred` and `one thousand` but it we have a number like 90, 80 we don\\'t say `one ninety` or `one eighty`\\n\\n``` \\n    private static final int[] IM = {1000000000, 1000000, 1000, 100, 90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 14,13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\\n    private static final String[] SM = {\"Billion\", \"Million\", \"Thousand\", \"Hundred\", \"Ninety\", \"Eighty\", \"Seventy\", \"Sixty\", \"Fifty\", \"Forty\", \"Thirty\", \"Twenty\", \"Nineteen\", \"Eighteen\", \"Seventeen\", \"Sixteen\", \"Fifteen\", \"Fourteen\", \"Thirteen\", \"Twelve\", \"Eleven\", \"Ten\", \"Nine\", \"Eight\", \"Seven\", \"Six\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\"};\\n\\n\\n    public String numberToWords(int num) {\\n        if (num == 0) {\\n            return \"Zero\";\\n        }\\n        return util(num);\\n    }\\n\\n    public String util(int num) {\\n        String ret = \"\";\\n        for (int i = 0;i< IM.length;i++) {\\n            if(num >= IM[i]){\\n                ret = (IM[i] >= 100 ? util(num / IM[i]) + \" \" : \"\") + SM[i] + \" \" + util(num % IM[i]);\\n                break;\\n            }\\n        }\\n        return ret.trim();\\n    } \\n```\\t\\t\\n\\t\\tCould be more optimized by using `StringBuilder` instead of String.",
                "solutionTags": [],
                "code": "``` \\n    private static final int[] IM = {1000000000, 1000000, 1000, 100, 90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 14,13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\\n    private static final String[] SM = {\"Billion\", \"Million\", \"Thousand\", \"Hundred\", \"Ninety\", \"Eighty\", \"Seventy\", \"Sixty\", \"Fifty\", \"Forty\", \"Thirty\", \"Twenty\", \"Nineteen\", \"Eighteen\", \"Seventeen\", \"Sixteen\", \"Fifteen\", \"Fourteen\", \"Thirteen\", \"Twelve\", \"Eleven\", \"Ten\", \"Nine\", \"Eight\", \"Seven\", \"Six\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\"};\\n\\n\\n    public String numberToWords(int num) {\\n        if (num == 0) {\\n            return \"Zero\";\\n        }\\n        return util(num);\\n    }\\n\\n    public String util(int num) {\\n        String ret = \"\";\\n        for (int i = 0;i< IM.length;i++) {\\n            if(num >= IM[i]){\\n                ret = (IM[i] >= 100 ? util(num / IM[i]) + \" \" : \"\") + SM[i] + \" \" + util(num % IM[i]);\\n                break;\\n            }\\n        }\\n        return ret.trim();\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 70756,
                "title": "short-clean-c-code-with-explanation",
                "content": "Function hundredStr() produces a string from integer less than 100.\\n\\nAnd in numberToWords() it uses a for loop to set \"Thousand\",\"Million\",\"Billion\".\\n\\n    class Solution {\\n    public:\\n        string hundredStr(int num){\\n            vector<string> arr1={\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\\n            \"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n            vector<string> arr2={\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n            string ret;\\n            ret=num%100<20?arr1[num%100]:arr2[(num%100)/10]+(num%10?\" \"+arr1[num%10]:\"\");\\n            if(num>99)ret=arr1[num/100]+\" Hundred\"+(num%100?\" \"+ret:\"\");\\n            return ret;\\n        }\\n        string numberToWords(int num) {\\n            string ret;\\n            vector<string> strarr={\"Thousand\",\"Million\",\"Billion\"};\\n            ret=hundredStr(num%1000);\\n            for(int i=0;i<3;i++){\\n                num/=1000;\\n                ret=num%1000?hundredStr(num%1000)+\" \"+strarr[i]+\" \"+ ret:ret;\\n            }\\n            while(ret.back()==' ')ret.pop_back();\\n            return ret.empty()?\"Zero\":ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string hundredStr(int num){\\n            vector<string> arr1={\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\\n            \"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"}",
                "codeTag": "Java"
            },
            {
                "id": 488861,
                "title": "javascript-recursive",
                "content": "```\\nvar numberToWords = function(num) {\\n  const map19 = [null, \\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\', \\'Ten\\', \\'Eleven\\',\\n    \\'Twelve\\', \\'Thirteen\\', \\'Fourteen\\', \\'Fifteen\\', \\'Sixteen\\', \\'Seventeen\\', \\'Eighteen\\', \\'Nineteen\\'];\\n  const mapTens = [null, null, \\'Twenty\\', \\'Thirty\\', \\'Forty\\', \\'Fifty\\', \\'Sixty\\', \\'Seventy\\', \\'Eighty\\', \\'Ninety\\'];\\n  const mapExpo = {\\n    \\'10e8\\': \\'Billion\\',\\n    \\'10e5\\': \\'Million\\',\\n    \\'10e2\\': \\'Thousand\\',\\n    \\'10e1\\': \\'Hundred\\',\\n  };\\n  \\n  function word(n) {\\n    if (n === 0) return [];\\n    if (n <= 19) return [map19[n]];\\n    if (n <= 99) return [mapTens[Math.trunc(n / 10)], ...word(n % 10)];\\n    for (const div of Object.keys(mapExpo)) {\\n      if (Math.trunc(n / div) > 0) {\\n        return [...word(Math.trunc(n / div)), mapExpo[div], ...word(n % div)];\\n      }\\n    }\\n  }\\n  \\n  return word(num).join(\\' \\') || \\'Zero\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberToWords = function(num) {\\n  const map19 = [null, \\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\', \\'Ten\\', \\'Eleven\\',\\n    \\'Twelve\\', \\'Thirteen\\', \\'Fourteen\\', \\'Fifteen\\', \\'Sixteen\\', \\'Seventeen\\', \\'Eighteen\\', \\'Nineteen\\'];\\n  const mapTens = [null, null, \\'Twenty\\', \\'Thirty\\', \\'Forty\\', \\'Fifty\\', \\'Sixty\\', \\'Seventy\\', \\'Eighty\\', \\'Ninety\\'];\\n  const mapExpo = {\\n    \\'10e8\\': \\'Billion\\',\\n    \\'10e5\\': \\'Million\\',\\n    \\'10e2\\': \\'Thousand\\',\\n    \\'10e1\\': \\'Hundred\\',\\n  };\\n  \\n  function word(n) {\\n    if (n === 0) return [];\\n    if (n <= 19) return [map19[n]];\\n    if (n <= 99) return [mapTens[Math.trunc(n / 10)], ...word(n % 10)];\\n    for (const div of Object.keys(mapExpo)) {\\n      if (Math.trunc(n / div) > 0) {\\n        return [...word(Math.trunc(n / div)), mapExpo[div], ...word(n % div)];\\n      }\\n    }\\n  }\\n  \\n  return word(num).join(\\' \\') || \\'Zero\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 70759,
                "title": "my-java-solution",
                "content": "    public String numberToWords(int num) {\\n        if(num == 0)\\n            return \"Zero\";\\n        String[] bigString = new String[]{\"Thousand\",\"Million\",\"Billion\"};\\n        String result =  numberToWordsHelper(num%1000);\\n        num = num/1000;\\n        if(num > 0 && num%1000>0){\\n            result = numberToWordsHelper(num%1000) + \"Thousand \" + result;\\n        }\\n        num = num/1000;\\n        if(num > 0 && num%1000>0){\\n            result = numberToWordsHelper(num%1000) + \"Million \" + result;\\n        }\\n        num = num/1000;\\n        if(num > 0){\\n            result = numberToWordsHelper(num%1000) + \"Billion \" + result;\\n        }\\n        return result.trim();\\n    }\\n    \\n    public String numberToWordsHelper(int num){\\n        String[] digitString = new String[]{\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n        String[] teenString = new String[]{\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\",\"Eighteen\", \"Nineteen\"};\\n        String[] tenString = new String[]{\"\",\"\",\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        String result = \"\";\\n        if(num > 99){\\n            result += digitString[num/100] + \" Hundred \";\\n        }\\n        num = num % 100;\\n        if(num < 20 && num > 9){\\n            result += teenString[num%10]+\" \";\\n        }else{\\n            if(num > 19){\\n                result += tenString[num/10]+\" \";\\n            }\\n            num = num % 10;\\n            if(num > 0)\\n                result += digitString[num]+\" \";\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    public String numberToWords(int num) {\\n        if(num == 0)\\n            return \"Zero\";\\n        String[] bigString = new String[]{\"Thousand\",\"Million\",\"Billion\"};\\n        String result =  numberToWordsHelper(num%1000);\\n        num = num/1000;\\n        if(num > 0 && num%1000>0){\\n            result = numberToWordsHelper(num%1000) + \"Thousand \" + result;\\n        }\\n        num = num/1000;\\n        if(num > 0 && num%1000>0){\\n            result = numberToWordsHelper(num%1000) + \"Million \" + result;\\n        }\\n        num = num/1000;\\n        if(num > 0){\\n            result = numberToWordsHelper(num%1000) + \"Billion \" + result;\\n        }\\n        return result.trim();\\n    }\\n    \\n    public String numberToWordsHelper(int num){\\n        String[] digitString = new String[]{\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n        String[] teenString = new String[]{\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\",\"Eighteen\", \"Nineteen\"};\\n        String[] tenString = new String[]{\"\",\"\",\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        String result = \"\";\\n        if(num > 99){\\n            result += digitString[num/100] + \" Hundred \";\\n        }\\n        num = num % 100;\\n        if(num < 20 && num > 9){\\n            result += teenString[num%10]+\" \";\\n        }else{\\n            if(num > 19){\\n                result += tenString[num/10]+\" \";\\n            }\\n            num = num % 10;\\n            if(num > 0)\\n                result += digitString[num]+\" \";\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1782505,
                "title": "c-simple-logic",
                "content": "class Solution {\\npublic:\\n    \\n    string one[19]={\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n    \\n    string ten[8]={\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n    \\n    \\n    string helper(int n)\\n    {\\n        if(n>=1000000000) return helper(n/1000000000)+\" Billion\"+helper(n%1000000000);\\n        \\n        if(n>=1000000) return helper(n/1000000)+\" Million\"+helper(n%1000000);\\n        \\n        if(n>=1000) return helper(n/1000)+\" Thousand\"+helper(n%1000);\\n        \\n        if(n>=100) return helper(n/100)+\" Hundred\"+helper(n%100);\\n        \\n        if(n>=20) return \" \"+ten[n/10-2]+helper(n%10);\\n        \\n        if(n>=1) return \" \"+one[n-1];\\n        \\n        return \"\";\\n    }\\n    \\n    string numberToWords(int num) {\\n        \\n        if(num==0)\\n            return \"Zero\";\\n        return helper(num).substr(1);\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    string one[19]={\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"}",
                "codeTag": "Java"
            },
            {
                "id": 1990823,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n    String[] tens = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    String[] ones = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\",\\n                    \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n\\n    public String numberToWords(int num) {\\n        if (num == 0)\\n            return \"Zero\";\\n        \\n        return helper(num).trim();\\n    }\\n    \\n    private String helper(int num) {\\n        StringBuilder sb=new StringBuilder();\\n        if (num >= 1000000000) {\\n            sb.append(helper(num / 1000000000)).append(\" Billion \").append( helper(num % 1000000000));\\n        } else if  (num >= 1000000) {\\n            sb.append(helper(num / 1000000)).append(\" Million \").append( helper(num % 1000000));\\n        }else if (num >= 1000) {\\n            sb.append(helper(num / 1000)).append(\" Thousand \").append( helper(num % 1000));\\n        }else if (num >= 100) {\\n            sb.append(helper(num / 100)).append(\" Hundred \").append( helper(num % 100));\\n        }else if (num >= 20) {\\n            sb.append(tens[num / 10]).append(\" \").append( helper(num % 10));\\n        } else {\\n            sb.append(ones[num]);\\n        }\\n        return sb.toString().trim();\\n        \\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    \\n    string ones[21] = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\", \"Twenty\"};\\n    \\n    string tens[10] = {\"##\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    string pref[4] = {\"##\", \"Thousand\", \"Million\", \"Billion\"};\\n    \\n    const int billion = 1000000000;\\n    const int million = 1000000;\\n    const int thousand = 1000;\\n    \\n    string oneDigit(int num)\\n    {\\n        return (num ? ones[num] + \" \" : \"\");\\n    }\\n    \\n    string twoDigit(int num)\\n    {\\n        if(num == 0)\\n            return \"\";\\n        if(num <= 20)\\n            return ones[num] + \" \";\\n        else\\n            return tens[num/10] + \" \" + (num % 10 ? ones[num%10] + \" \" : \"\");\\n    }\\n    \\n    string threeDigit(int num)\\n    {\\n        if(num == 0)\\n            return \"\";\\n        if(num / 10 == 0)\\n            return oneDigit(num);\\n        if(num / 100 == 0)\\n            return twoDigit(num);\\n        \\n        return ones[num/100] + \" Hundred \" + twoDigit(num%100);\\n    }\\n    \\n    string convert(int num)\\n    {   \\n        if(num == 0)\\n            return \"\";\\n        if(num/billion)\\n            return threeDigit(num/billion) + \"Billion \" + convert(num%billion);\\n        if(num/million)\\n            return threeDigit(num/million) + \"Million \" + convert(num%million);\\n        if(num/thousand)\\n            return threeDigit(num/thousand) + \"Thousand \" + convert(num%thousand);\\n        return threeDigit(num);\\n    }\\n    string numberToWords(int num)\\n    {\\n        if(num == 0)\\n            return \"Zero\";\\n        string ans = convert(num);\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        mp = {1: \"One\",   11: \"Eleven\",    10: \"Ten\", \\n              2: \"Two\",   12: \"Twelve\",    20: \"Twenty\", \\n              3: \"Three\", 13: \"Thirteen\",  30: \"Thirty\", \\n              4: \"Four\",  14: \"Fourteen\",  40: \"Forty\",\\n              5: \"Five\",  15: \"Fifteen\",   50: \"Fifty\", \\n              6: \"Six\",   16: \"Sixteen\",   60: \"Sixty\", \\n              7: \"Seven\", 17: \"Seventeen\", 70: \"Seventy\", \\n              8: \"Eight\", 18: \"Eighteen\",  80: \"Eighty\",\\n              9: \"Nine\",  19: \"Nineteen\",  90: \"Ninety\"}\\n        \\n        def fn(n):\\n            \"\"\"Return English words of n (0-999) in array.\"\"\"\\n            if not n: return []\\n            elif n < 20: return [mp[n]]\\n            elif n < 100: return [mp[n//10*10]] + fn(n%10)\\n            else: return [mp[n//100], \"Hundred\"] + fn(n%100)\\n        \\n        ans = []\\n        for i, unit in zip((9, 6, 3, 0), (\"Billion\", \"Million\", \"Thousand\", \"\")): \\n            n, num = divmod(num, 10**i)\\n            ans.extend(fn(n))\\n            if n and unit: ans.append(unit)\\n        return \" \".join(ans) or \"Zero\"\\n```\\n\\n***JavaScript***\\n```\\nvar numberToWords = function(num) {\\n  if (num === 0) {\\n    return \\'Zero\\';\\n  }\\n  \\n  if (num <= 20) {\\n    return translations.get(num);\\n  }\\n  \\n  let result = [];\\n  \\n  for (let [value, translation] of translations) {\\n    const times = Math.floor(num / value);\\n    \\n    if (times === 0) {\\n      continue;\\n    }\\n    \\n    num -= times * value;\\n    \\n    if (times === 1 && value >= 100) {\\n      result.push(\\'One\\', translation);\\n      continue;\\n    }\\n    \\n    if (times === 1) {\\n      result.push(translation);\\n      continue;\\n    }\\n    \\n    result.push(numberToWords(times), translation);\\n  }\\n  \\n  return result.join(\\' \\');\\n};\\n\\nconst translations = new Map([\\n  [1000000000, \\'Billion\\'],\\n  [1000000, \\'Million\\'],\\n  [1000, \\'Thousand\\'],\\n  [100, \\'Hundred\\'],\\n  [90, \\'Ninety\\'],\\n  [80, \\'Eighty\\'],\\n  [70, \\'Seventy\\'],\\n  [60, \\'Sixty\\'],\\n  [50, \\'Fifty\\'],\\n  [40, \\'Forty\\'],\\n  [30, \\'Thirty\\'],\\n  [20, \\'Twenty\\'],\\n  [19, \\'Nineteen\\'],\\n  [18, \\'Eighteen\\'],\\n  [17, \\'Seventeen\\'],\\n  [16, \\'Sixteen\\'],\\n  [15, \\'Fifteen\\'],\\n  [14, \\'Fourteen\\'],\\n  [13, \\'Thirteen\\'],\\n  [12, \\'Twelve\\'],\\n  [11, \\'Eleven\\'],\\n  [10, \\'Ten\\'],\\n  [9, \\'Nine\\'],\\n  [8, \\'Eight\\'],\\n  [7, \\'Seven\\'],\\n  [6, \\'Six\\'],\\n  [5, \\'Five\\'],\\n  [4, \\'Four\\'],\\n  [3, \\'Three\\'],\\n  [2, \\'Two\\'],\\n  [1, \\'One\\'],\\n]);\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n    fun numberToWords(num: Int): String {\\n        if (num == 0) {\\n            return \"Zero\"\\n        }\\n        \\n        return helper(num)\\n    }\\n    \\n    private fun lessTwenty(num: Int): String {\\n        return when(num) {\\n            1 -> \"One\"\\n            2 -> \"Two\"\\n            3 -> \"Three\"\\n            4 -> \"Four\"\\n            5 -> \"Five\"\\n            6 -> \"Six\"\\n            7 -> \"Seven\"\\n            8 -> \"Eight\"\\n            9 -> \"Nine\"\\n            10 -> \"Ten\"\\n            11 -> \"Eleven\"\\n            12 -> \"Twelve\"\\n            13 -> \"Thirteen\"\\n            14 -> \"Fourteen\"\\n            15 -> \"Fifteen\"\\n            16 -> \"Sixteen\"\\n            17 -> \"Seventeen\"\\n            18 -> \"Eighteen\"\\n            19 -> \"Nineteen\"\\n            else -> \"\"\\n        }\\n    }\\n    \\n    private fun tens(num: Int): String {\\n        return when(num) {\\n            20 -> \"Twenty\"\\n            30 -> \"Thirty\"\\n            40 -> \"Forty\"\\n            50 -> \"Fifty\"\\n            60 -> \"Sixty\"\\n            70 -> \"Seventy\"\\n            80 -> \"Eighty\"\\n            90 -> \"Ninety\"\\n            else -> \"\"\\n        }\\n    }\\n    \\n    private fun helper(num: Int): String {\\n        var ans = \"\" // Kotlin uses StringBuilder under the hood\\n        \\n        if (num >= 1_000_000_000) {\\n            ans += helper(num / 1_000_000_000) + \" Billion \" + helper(num % 1_000_000_000)\\n        } else if (num >= 1_000_000) {\\n            ans += helper(num / 1_000_000) + \" Million \" + helper(num % 1_000_000)\\n        } else if (num >= 1_000) {\\n            ans += helper(num / 1_000) + \" Thousand \" + helper(num % 1_000)\\n        } else if (num >= 100) {\\n            ans += helper(num / 100) + \" Hundred \" + helper(num % 100)\\n        } else if (num >= 20) {\\n            ans += tens(num - (num % 10)) + \" \" + lessTwenty(num % 10)\\n        } else if (num < 20) {\\n            ans += lessTwenty(num)\\n        }\\n        \\n        return ans.trim()\\n    }\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    \\n    private let kAtomicWords = [1:\"One\",2:\"Two\",3:\"Three\",4:\"Four\",5:\"Five\",6:\"Six\", \\n                                7:\"Seven\",8:\"Eight\",9:\"Nine\",10:\"Ten\",11:\"Eleven\",\\n                                12:\"Twelve\",13:\"Thirteen\",14:\"Fourteen\",15:\"Fifteen\",\\n                                16:\"Sixteen\",17:\"Seventeen\",18:\"Eighteen\",19:\"Nineteen\",\\n                                20:\"Twenty\",30:\"Thirty\",40:\"Forty\",50:\"Fifty\",60:\"Sixty\",\\n                                70:\"Seventy\",80:\"Eighty\",90:\"Ninety\"]\\n\\n\\tprivate let kAtomicPowers = [100: \"Hundred\",\\n                                1_000: \"Thousand\",\\n                                1_000_000: \"Million\",\\n                                1_000_000_000: \"Billion\",\\n                                1_000_000_000_000: \"Trillion\"]\\n\\n    func numberToWords(_ num: Int) -> String {\\n        guard num != 0 else { return \"Zero\" }\\n        // Remove nils and join by \" \"\\n\\t    return wordFor(num).flatMap{$0}.joined(separator: \" \")\\n    }\\n\\n    /// Recursively build\\n    private func wordFor(_ num: Int) -> [String?] {\\n        var result = [String?]()\\n        \\n\\t    // 0-19\\n\\t    if num < 20 {\\n\\t\\t    result.append(kAtomicWords[num])\\n        }\\n        // 20-99\\n        else if num  < 100 {\\n\\t        let leastSig = num % 10\\n\\t        let mostSig = (num/10) * 10\\n            result.append(kAtomicWords[mostSig])\\n            if leastSig > 0 {\\n               result.append(kAtomicWords[leastSig])\\n            }\\n        }\\n        // 1Y xx - 1YY xxx xxx xxx xxx\\n        else {\\n\\t        // get largest power of number\\n\\t        var power = 100\\n\\t        while (num / (power*10)) > 0 {\\n\\t\\t        power *= 10\\n            }\\n            // divide by 10 until we find closest atomic word power\\n\\t\\t\\twhile kAtomicPowers[power] == nil {\\n\\t\\t\\t\\tpower /= 10\\n            }\\n            \\n\\t        var mostSig = num / power\\n\\t        let remainder = num - (mostSig * power)\\n    \\n            result.append(contentsOf: wordFor(mostSig))\\n            result.append(kAtomicPowers[power])\\n            result.append(contentsOf: wordFor(remainder))\\n        }\\n        \\n        return result\\n    }\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    String[] tens = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    String[] ones = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\",\\n                    \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n\\n    public String numberToWords(int num) {\\n        if (num == 0)\\n            return \"Zero\";\\n        \\n        return helper(num).trim();\\n    }\\n    \\n    private String helper(int num) {\\n        StringBuilder sb=new StringBuilder();\\n        if (num >= 1000000000) {\\n            sb.append(helper(num / 1000000000)).append(\" Billion \").append( helper(num % 1000000000));\\n        } else if  (num >= 1000000) {\\n            sb.append(helper(num / 1000000)).append(\" Million \").append( helper(num % 1000000));\\n        }else if (num >= 1000) {\\n            sb.append(helper(num / 1000)).append(\" Thousand \").append( helper(num % 1000));\\n        }else if (num >= 100) {\\n            sb.append(helper(num / 100)).append(\" Hundred \").append( helper(num % 100));\\n        }else if (num >= 20) {\\n            sb.append(tens[num / 10]).append(\" \").append( helper(num % 10));\\n        } else {\\n            sb.append(ones[num]);\\n        }\\n        return sb.toString().trim();\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    string ones[21] = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\", \"Twenty\"};\\n    \\n    string tens[10] = {\"##\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    string pref[4] = {\"##\", \"Thousand\", \"Million\", \"Billion\"};\\n    \\n    const int billion = 1000000000;\\n    const int million = 1000000;\\n    const int thousand = 1000;\\n    \\n    string oneDigit(int num)\\n    {\\n        return (num ? ones[num] + \" \" : \"\");\\n    }\\n    \\n    string twoDigit(int num)\\n    {\\n        if(num == 0)\\n            return \"\";\\n        if(num <= 20)\\n            return ones[num] + \" \";\\n        else\\n            return tens[num/10] + \" \" + (num % 10 ? ones[num%10] + \" \" : \"\");\\n    }\\n    \\n    string threeDigit(int num)\\n    {\\n        if(num == 0)\\n            return \"\";\\n        if(num / 10 == 0)\\n            return oneDigit(num);\\n        if(num / 100 == 0)\\n            return twoDigit(num);\\n        \\n        return ones[num/100] + \" Hundred \" + twoDigit(num%100);\\n    }\\n    \\n    string convert(int num)\\n    {   \\n        if(num == 0)\\n            return \"\";\\n        if(num/billion)\\n            return threeDigit(num/billion) + \"Billion \" + convert(num%billion);\\n        if(num/million)\\n            return threeDigit(num/million) + \"Million \" + convert(num%million);\\n        if(num/thousand)\\n            return threeDigit(num/thousand) + \"Thousand \" + convert(num%thousand);\\n        return threeDigit(num);\\n    }\\n    string numberToWords(int num)\\n    {\\n        if(num == 0)\\n            return \"Zero\";\\n        string ans = convert(num);\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        mp = {1: \"One\",   11: \"Eleven\",    10: \"Ten\", \\n              2: \"Two\",   12: \"Twelve\",    20: \"Twenty\", \\n              3: \"Three\", 13: \"Thirteen\",  30: \"Thirty\", \\n              4: \"Four\",  14: \"Fourteen\",  40: \"Forty\",\\n              5: \"Five\",  15: \"Fifteen\",   50: \"Fifty\", \\n              6: \"Six\",   16: \"Sixteen\",   60: \"Sixty\", \\n              7: \"Seven\", 17: \"Seventeen\", 70: \"Seventy\", \\n              8: \"Eight\", 18: \"Eighteen\",  80: \"Eighty\",\\n              9: \"Nine\",  19: \"Nineteen\",  90: \"Ninety\"}\\n        \\n        def fn(n):\\n            \"\"\"Return English words of n (0-999) in array.\"\"\"\\n            if not n: return []\\n            elif n < 20: return [mp[n]]\\n            elif n < 100: return [mp[n//10*10]] + fn(n%10)\\n            else: return [mp[n//100], \"Hundred\"] + fn(n%100)\\n        \\n        ans = []\\n        for i, unit in zip((9, 6, 3, 0), (\"Billion\", \"Million\", \"Thousand\", \"\")): \\n            n, num = divmod(num, 10**i)\\n            ans.extend(fn(n))\\n            if n and unit: ans.append(unit)\\n        return \" \".join(ans) or \"Zero\"\\n```\n```\\nvar numberToWords = function(num) {\\n  if (num === 0) {\\n    return \\'Zero\\';\\n  }\\n  \\n  if (num <= 20) {\\n    return translations.get(num);\\n  }\\n  \\n  let result = [];\\n  \\n  for (let [value, translation] of translations) {\\n    const times = Math.floor(num / value);\\n    \\n    if (times === 0) {\\n      continue;\\n    }\\n    \\n    num -= times * value;\\n    \\n    if (times === 1 && value >= 100) {\\n      result.push(\\'One\\', translation);\\n      continue;\\n    }\\n    \\n    if (times === 1) {\\n      result.push(translation);\\n      continue;\\n    }\\n    \\n    result.push(numberToWords(times), translation);\\n  }\\n  \\n  return result.join(\\' \\');\\n};\\n\\nconst translations = new Map([\\n  [1000000000, \\'Billion\\'],\\n  [1000000, \\'Million\\'],\\n  [1000, \\'Thousand\\'],\\n  [100, \\'Hundred\\'],\\n  [90, \\'Ninety\\'],\\n  [80, \\'Eighty\\'],\\n  [70, \\'Seventy\\'],\\n  [60, \\'Sixty\\'],\\n  [50, \\'Fifty\\'],\\n  [40, \\'Forty\\'],\\n  [30, \\'Thirty\\'],\\n  [20, \\'Twenty\\'],\\n  [19, \\'Nineteen\\'],\\n  [18, \\'Eighteen\\'],\\n  [17, \\'Seventeen\\'],\\n  [16, \\'Sixteen\\'],\\n  [15, \\'Fifteen\\'],\\n  [14, \\'Fourteen\\'],\\n  [13, \\'Thirteen\\'],\\n  [12, \\'Twelve\\'],\\n  [11, \\'Eleven\\'],\\n  [10, \\'Ten\\'],\\n  [9, \\'Nine\\'],\\n  [8, \\'Eight\\'],\\n  [7, \\'Seven\\'],\\n  [6, \\'Six\\'],\\n  [5, \\'Five\\'],\\n  [4, \\'Four\\'],\\n  [3, \\'Three\\'],\\n  [2, \\'Two\\'],\\n  [1, \\'One\\'],\\n]);\\n```\n```\\nclass Solution {\\n    fun numberToWords(num: Int): String {\\n        if (num == 0) {\\n            return \"Zero\"\\n        }\\n        \\n        return helper(num)\\n    }\\n    \\n    private fun lessTwenty(num: Int): String {\\n        return when(num) {\\n            1 -> \"One\"\\n            2 -> \"Two\"\\n            3 -> \"Three\"\\n            4 -> \"Four\"\\n            5 -> \"Five\"\\n            6 -> \"Six\"\\n            7 -> \"Seven\"\\n            8 -> \"Eight\"\\n            9 -> \"Nine\"\\n            10 -> \"Ten\"\\n            11 -> \"Eleven\"\\n            12 -> \"Twelve\"\\n            13 -> \"Thirteen\"\\n            14 -> \"Fourteen\"\\n            15 -> \"Fifteen\"\\n            16 -> \"Sixteen\"\\n            17 -> \"Seventeen\"\\n            18 -> \"Eighteen\"\\n            19 -> \"Nineteen\"\\n            else -> \"\"\\n        }\\n    }\\n    \\n    private fun tens(num: Int): String {\\n        return when(num) {\\n            20 -> \"Twenty\"\\n            30 -> \"Thirty\"\\n            40 -> \"Forty\"\\n            50 -> \"Fifty\"\\n            60 -> \"Sixty\"\\n            70 -> \"Seventy\"\\n            80 -> \"Eighty\"\\n            90 -> \"Ninety\"\\n            else -> \"\"\\n        }\\n    }\\n    \\n    private fun helper(num: Int): String {\\n        var ans = \"\" // Kotlin uses StringBuilder under the hood\\n        \\n        if (num >= 1_000_000_000) {\\n            ans += helper(num / 1_000_000_000) + \" Billion \" + helper(num % 1_000_000_000)\\n        } else if (num >= 1_000_000) {\\n            ans += helper(num / 1_000_000) + \" Million \" + helper(num % 1_000_000)\\n        } else if (num >= 1_000) {\\n            ans += helper(num / 1_000) + \" Thousand \" + helper(num % 1_000)\\n        } else if (num >= 100) {\\n            ans += helper(num / 100) + \" Hundred \" + helper(num % 100)\\n        } else if (num >= 20) {\\n            ans += tens(num - (num % 10)) + \" \" + lessTwenty(num % 10)\\n        } else if (num < 20) {\\n            ans += lessTwenty(num)\\n        }\\n        \\n        return ans.trim()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    private let kAtomicWords = [1:\"One\",2:\"Two\",3:\"Three\",4:\"Four\",5:\"Five\",6:\"Six\", \\n                                7:\"Seven\",8:\"Eight\",9:\"Nine\",10:\"Ten\",11:\"Eleven\",\\n                                12:\"Twelve\",13:\"Thirteen\",14:\"Fourteen\",15:\"Fifteen\",\\n                                16:\"Sixteen\",17:\"Seventeen\",18:\"Eighteen\",19:\"Nineteen\",\\n                                20:\"Twenty\",30:\"Thirty\",40:\"Forty\",50:\"Fifty\",60:\"Sixty\",\\n                                70:\"Seventy\",80:\"Eighty\",90:\"Ninety\"]\\n\\n\\tprivate let kAtomicPowers = [100: \"Hundred\",\\n                                1_000: \"Thousand\",\\n                                1_000_000: \"Million\",\\n                                1_000_000_000: \"Billion\",\\n                                1_000_000_000_000: \"Trillion\"]\\n\\n    func numberToWords(_ num: Int) -> String {\\n        guard num != 0 else { return \"Zero\" }\\n        // Remove nils and join by \" \"\\n\\t    return wordFor(num).flatMap{$0}.joined(separator: \" \")\\n    }\\n\\n    /// Recursively build\\n    private func wordFor(_ num: Int) -> [String?] {\\n        var result = [String?]()\\n        \\n\\t    // 0-19\\n\\t    if num < 20 {\\n\\t\\t    result.append(kAtomicWords[num])\\n        }\\n        // 20-99\\n        else if num  < 100 {\\n\\t        let leastSig = num % 10\\n\\t        let mostSig = (num/10) * 10\\n            result.append(kAtomicWords[mostSig])\\n            if leastSig > 0 {\\n               result.append(kAtomicWords[leastSig])\\n            }\\n        }\\n        // 1Y xx - 1YY xxx xxx xxx xxx\\n        else {\\n\\t        // get largest power of number\\n\\t        var power = 100\\n\\t        while (num / (power*10)) > 0 {\\n\\t\\t        power *= 10\\n            }\\n            // divide by 10 until we find closest atomic word power\\n\\t\\t\\twhile kAtomicPowers[power] == nil {\\n\\t\\t\\t\\tpower /= 10\\n            }\\n            \\n\\t        var mostSig = num / power\\n\\t        let remainder = num - (mostSig * power)\\n    \\n            result.append(contentsOf: wordFor(mostSig))\\n            result.append(kAtomicPowers[power])\\n            result.append(contentsOf: wordFor(remainder))\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554429,
                "title": "c-one-dictionary",
                "content": "```\\npublic class Solution {\\n    private static Dictionary<int, string> trials;\\n    \\n    public Solution() {\\n        trials = new Dictionary<int, string> {\\n            {1000000000, \"{0} Billion {1}\"},\\n            {1000000, \"{0} Million {1}\"},\\n            {1000, \"{0} Thousand {1}\"},\\n            {100, \"{0} Hundred {1}\"},\\n            {90, \"Ninety {1}\"},\\n            {80, \"Eighty {1}\"},\\n            {70, \"Seventy {1}\"},\\n            {60, \"Sixty {1}\"},\\n            {50, \"Fifty {1}\"},\\n            {40, \"Forty {1}\"},\\n            {30, \"Thirty {1}\"},\\n            {20, \"Twenty {1}\"},\\n            {19, \"Nineteen\"},\\n            {18, \"Eighteen\"},\\n            {17, \"Seventeen\"},\\n            {16, \"Sixteen\"},\\n            {15, \"Fifteen\"},\\n            {14, \"Fourteen\"},\\n            {13, \"Thirteen\"},            \\n            {12, \"Twelve\"},\\n            {11, \"Eleven\"},\\n            {10, \"Ten\"},\\n            {9, \"Nine\"},\\n            {8, \"Eight\"},\\n            {7, \"Seven\"},\\n            {6, \"Six\"},\\n            {5, \"Five\"},\\n            {4, \"Four\"},\\n            {3, \"Three\"},\\n            {2, \"Two\"},\\n            {1, \"One\"},\\n            {0, \"Zero\"}\\n        };\\n    }\\n    \\n    public string NumberToWords(int num) {        \\n        // Max 2,147,483,647\\n        \\n        foreach (var pair in trials) {\\n            if (num <= 10 && num == pair.Key) {\\n                return pair.Value;\\n            }\\n            \\n            int n = num / pair.Key;\\n            num = num % pair.Key;\\n            if (n >= 1) {\\n                if (num == 0) {\\n                    return string.Format(pair.Value, NumberToWords(n), \"\").Trim();\\n                } else {\\n                    return string.Format(pair.Value, NumberToWords(n), NumberToWords(num));\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private static Dictionary<int, string> trials;\\n    \\n    public Solution() {\\n        trials = new Dictionary<int, string> {\\n            {1000000000, \"{0} Billion {1}\"},\\n            {1000000, \"{0} Million {1}\"},\\n            {1000, \"{0} Thousand {1}\"},\\n            {100, \"{0} Hundred {1}\"},\\n            {90, \"Ninety {1}\"},\\n            {80, \"Eighty {1}\"},\\n            {70, \"Seventy {1}\"},\\n            {60, \"Sixty {1}\"},\\n            {50, \"Fifty {1}\"},\\n            {40, \"Forty {1}\"},\\n            {30, \"Thirty {1}\"},\\n            {20, \"Twenty {1}\"},\\n            {19, \"Nineteen\"},\\n            {18, \"Eighteen\"},\\n            {17, \"Seventeen\"},\\n            {16, \"Sixteen\"},\\n            {15, \"Fifteen\"},\\n            {14, \"Fourteen\"},\\n            {13, \"Thirteen\"},            \\n            {12, \"Twelve\"},\\n            {11, \"Eleven\"},\\n            {10, \"Ten\"},\\n            {9, \"Nine\"},\\n            {8, \"Eight\"},\\n            {7, \"Seven\"},\\n            {6, \"Six\"},\\n            {5, \"Five\"},\\n            {4, \"Four\"},\\n            {3, \"Three\"},\\n            {2, \"Two\"},\\n            {1, \"One\"},\\n            {0, \"Zero\"}\\n        };\\n    }\\n    \\n    public string NumberToWords(int num) {        \\n        // Max 2,147,483,647\\n        \\n        foreach (var pair in trials) {\\n            if (num <= 10 && num == pair.Key) {\\n                return pair.Value;\\n            }\\n            \\n            int n = num / pair.Key;\\n            num = num % pair.Key;\\n            if (n >= 1) {\\n                if (num == 0) {\\n                    return string.Format(pair.Value, NumberToWords(n), \"\").Trim();\\n                } else {\\n                    return string.Format(pair.Value, NumberToWords(n), NumberToWords(num));\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461439,
                "title": "java-my-easy-to-understand-solution",
                "content": "I am breaking down the number into number of billions, number of millions, number of thousands and leaving us hundreds. Each of these will be 3 digits. To convert these 3 digit numbers into strings, I call helper. \\n```\\npublic String numberToWords(int num) {\\n\\tif(num==0) return \"Zero\";\\n\\tint billions = num/1000000000;\\n\\tnum %= 1000000000;\\n\\tint millions = num/1000000;\\n\\tnum %= 1000000;\\n\\tint thousands = num/1000;\\n\\tnum %= 1000;\\n\\tint hundreds = num;\\n\\tStringBuilder s = new StringBuilder();\\n\\tif(billions>0) s.append(helper(billions)+\" Billion \"); \\n\\tif(millions>0) s.append(helper(millions)+\" Million \");\\n\\tif(thousands>0) s.append(helper(thousands)+\" Thousand \");\\n\\tif(hundreds>0) s.append(helper(hundreds));\\n\\n\\treturn s.toString().trim();\\n}\\n\\npublic String helper(int n) {\\n\\tString[] tillNineteen = {\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\\n\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n\\tString[] tens = {\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n\\tint hundred = n/100;\\n\\tn %= 100;\\n\\n\\tStringBuilder s = new StringBuilder();\\n\\tif(hundred!=0) s.append(tillNineteen[hundred]+\" Hundred \");\\n\\tif(n<20) s.append(tillNineteen[n]);\\n\\telse {\\n\\t\\tint ten = n/10;\\n\\t\\tn = n%10;\\n\\t\\ts.append(tens[ten]+\" \"+tillNineteen[n]);\\n\\t}\\n\\treturn s.toString().trim();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String numberToWords(int num) {\\n\\tif(num==0) return \"Zero\";\\n\\tint billions = num/1000000000;\\n\\tnum %= 1000000000;\\n\\tint millions = num/1000000;\\n\\tnum %= 1000000;\\n\\tint thousands = num/1000;\\n\\tnum %= 1000;\\n\\tint hundreds = num;\\n\\tStringBuilder s = new StringBuilder();\\n\\tif(billions>0) s.append(helper(billions)+\" Billion \"); \\n\\tif(millions>0) s.append(helper(millions)+\" Million \");\\n\\tif(thousands>0) s.append(helper(thousands)+\" Thousand \");\\n\\tif(hundreds>0) s.append(helper(hundreds));\\n\\n\\treturn s.toString().trim();\\n}\\n\\npublic String helper(int n) {\\n\\tString[] tillNineteen = {\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\\n\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n\\tString[] tens = {\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n\\tint hundred = n/100;\\n\\tn %= 100;\\n\\n\\tStringBuilder s = new StringBuilder();\\n\\tif(hundred!=0) s.append(tillNineteen[hundred]+\" Hundred \");\\n\\tif(n<20) s.append(tillNineteen[n]);\\n\\telse {\\n\\t\\tint ten = n/10;\\n\\t\\tn = n%10;\\n\\t\\ts.append(tens[ten]+\" \"+tillNineteen[n]);\\n\\t}\\n\\treturn s.toString().trim();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363457,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public String numberToWords(int num) {\\n        if (num < 100) return less100(num);\\n        \\n        StringBuilder result = new StringBuilder();\\n        int billion = 1000000000;\\n        int million = 1000000;\\n        int thousand = 1000;\\n        int hundred = 100;\\n        if (num >= billion)\\n        {\\n            result.append(\"\" + numberToWords(num / billion) + \" Billion \");\\n            num %= billion;\\n        }\\n        if (num >= million)\\n        {\\n            result.append(\"\" + numberToWords(num / million) + \" Million \");\\n            num %= million;\\n        }\\n        if (num >= thousand)\\n        {\\n            result.append(\"\" + numberToWords(num / thousand) + \" Thousand \");\\n            num %= thousand;\\n        }\\n        if (num >= hundred)\\n        {\\n            result.append(\"\" + numberToWords(num / hundred) + \" Hundred \");\\n            num %= hundred;\\n        }\\n        if (num != 0)\\n        {\\n            result.append(less100(num));\\n        }\\n        \\n        return result.toString().trim();\\n    }\\n\\n    String[] map_ = new String[] {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\",\\n                   \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\",\\n                  \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\",\\n                   \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    \\n    String[] tens_ = new String[] {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \\n                                  \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\",\\n                                  \"Ninety\"};\\n    \\n    String less100(int n)\\n    {\\n        if (n < 20) return map_[n];\\n        String result = tens_[n / 10];\\n        n %= 10;\\n        if (n != 0)\\n        {\\n            result += \" \" + map_[n];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String numberToWords(int num) {\\n        if (num < 100) return less100(num);\\n        \\n        StringBuilder result = new StringBuilder();\\n        int billion = 1000000000;\\n        int million = 1000000;\\n        int thousand = 1000;\\n        int hundred = 100;\\n        if (num >= billion)\\n        {\\n            result.append(\"\" + numberToWords(num / billion) + \" Billion \");\\n            num %= billion;\\n        }\\n        if (num >= million)\\n        {\\n            result.append(\"\" + numberToWords(num / million) + \" Million \");\\n            num %= million;\\n        }\\n        if (num >= thousand)\\n        {\\n            result.append(\"\" + numberToWords(num / thousand) + \" Thousand \");\\n            num %= thousand;\\n        }\\n        if (num >= hundred)\\n        {\\n            result.append(\"\" + numberToWords(num / hundred) + \" Hundred \");\\n            num %= hundred;\\n        }\\n        if (num != 0)\\n        {\\n            result.append(less100(num));\\n        }\\n        \\n        return result.toString().trim();\\n    }\\n\\n    String[] map_ = new String[] {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\",\\n                   \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\",\\n                  \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\",\\n                   \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    \\n    String[] tens_ = new String[] {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \\n                                  \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\",\\n                                  \"Ninety\"};\\n    \\n    String less100(int n)\\n    {\\n        if (n < 20) return map_[n];\\n        String result = tens_[n / 10];\\n        n %= 10;\\n        if (n != 0)\\n        {\\n            result += \" \" + map_[n];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361105,
                "title": "java-no-recursion-clean-and-simple-memory-beats-100",
                "content": "**Idea:** The key idea here is to partition the number into 4 groups - billions, millions, thousands and the remaining digits (up to 3). All these 4 groups will have up to 3 digits and will be processed in the same way i.e. by the same function but will differ in their suffixes.\\nP.S.: Why is it classified as a Hard question?\\n\\n```\\nprivate static final Map<Integer, String> BIG_WORD_BY_VAL = new LinkedHashMap<>();\\nprivate static final Map<Integer, String> WORD_BY_VAL = new HashMap<>();\\n\\npublic String numberToWords(int num) {\\n\\tif (num < 21)\\n\\t\\treturn WORD_BY_VAL.get(num);\\n\\t\\n\\tvar ans = new StringBuilder();\\n\\tfor (var entry : BIG_WORD_BY_VAL.entrySet())\\n\\t\\tnum = reduce(num, ans, entry.getKey(), entry.getValue());\\n\\t\\n\\treturn convert(num, ans).toString()\\n\\t\\t\\t\\t\\t\\t    .trim();\\n}\\n\\nprivate int reduce(int num, StringBuilder ans, int denomination, String denominationWord) {\\n\\tif (num >= denomination) {\\n\\t\\tconvert(num / denomination, ans)).append(denominationWord);\\n\\t\\tnum %= denomination;\\n\\t}\\n\\treturn num;\\n}\\n\\n/*\\nThere are three reductions in this method. I\\'ve explained them here sequentially:\\n1. Reduce by 100. This is applicable for b/millions, thousands and hundreds.\\n2. Reduce by 10. If quotient is 1, it means number is between [11, 19], so get name \\nfrom map and the next block (3) will not execute, else multiply the quotient by 10 to get \\nthe word from map \\n3. If remainder is of the form xy, where x = 2 to 9 and y != 0, e.g. 23, so \"twenty three\"\\nwe don\\'t want to do it for 20, 30 etc, because we don\\'t say \"twenty zero\"\\nwe also don\\'t want to do it for [11, 19] because we don\\'t say \"ten one\", \\nthey have their unique names already covered in the map\\n*/\\nprivate StringBuilder convert(int t, StringBuilder ans) {\\n\\tvar hun = t / 100;\\n\\tif (hun != 0)\\n\\t\\tans.append(\" \")\\n\\t\\t   .append(WORD_BY_VAL.get(hun))\\n\\t\\t   .append(\" Hundred\");\\n\\tt %= 100;\\n\\n\\tvar ten = t / 10;\\n\\tif (ten != 0) {\\n\\t\\tans.append(\" \");\\n\\t\\tif (ten == 1) // for 11 to 19\\n\\t\\t\\tans.append(WORD_BY_VAL.get(t));\\n\\t\\telse // for 2x to 9x\\n\\t\\t\\tans.append(WORD_BY_VAL.get(ten * 10));\\n\\t}\\n\\tt %= 10;\\n\\n\\tif (ten != 1 && t != 0)\\n\\t\\tans.append(\" \")\\n\\t\\t   .append(WORD_BY_VAL.get(t));\\n\\t\\t   \\n\\treturn ans;\\n}\\n\\nstatic {\\n\\tBIG_WORD_BY_VAL.put(1_000_000_000, \" Billion\");\\n\\tBIG_WORD_BY_VAL.put(1_000_000, \" Million\");\\n\\tBIG_WORD_BY_VAL.put(1_000, \" Thousand\");\\n\\n\\tWORD_BY_VAL.put(0, \"Zero\");\\n\\tWORD_BY_VAL.put(1, \"One\");\\n\\tWORD_BY_VAL.put(2, \"Two\");\\n\\tWORD_BY_VAL.put(3, \"Three\");\\n\\tWORD_BY_VAL.put(4, \"Four\");\\n\\tWORD_BY_VAL.put(5, \"Five\");\\n\\tWORD_BY_VAL.put(6, \"Six\");\\n\\tWORD_BY_VAL.put(7, \"Seven\");\\n\\tWORD_BY_VAL.put(8, \"Eight\");\\n\\tWORD_BY_VAL.put(9, \"Nine\");\\n\\tWORD_BY_VAL.put(10, \"Ten\");\\n\\tWORD_BY_VAL.put(11, \"Eleven\");\\n\\tWORD_BY_VAL.put(12, \"Twelve\");\\n\\tWORD_BY_VAL.put(13, \"Thirteen\");\\n\\tWORD_BY_VAL.put(14, \"Fourteen\");\\n\\tWORD_BY_VAL.put(15, \"Fifteen\");\\n\\tWORD_BY_VAL.put(16, \"Sixteen\");\\n\\tWORD_BY_VAL.put(17, \"Seventeen\");\\n\\tWORD_BY_VAL.put(18, \"Eighteen\");\\n\\tWORD_BY_VAL.put(19, \"Nineteen\");\\n\\tWORD_BY_VAL.put(20, \"Twenty\");\\n\\tWORD_BY_VAL.put(30, \"Thirty\");\\n\\tWORD_BY_VAL.put(40, \"Forty\");\\n\\tWORD_BY_VAL.put(50, \"Fifty\");\\n\\tWORD_BY_VAL.put(60, \"Sixty\");\\n\\tWORD_BY_VAL.put(70, \"Seventy\");\\n\\tWORD_BY_VAL.put(80, \"Eighty\");\\n\\tWORD_BY_VAL.put(90, \"Ninety\");\\n\\tWORD_BY_VAL.put(100, \"Hundred\");\\n}\\n```\\n\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate static final Map<Integer, String> BIG_WORD_BY_VAL = new LinkedHashMap<>();\\nprivate static final Map<Integer, String> WORD_BY_VAL = new HashMap<>();\\n\\npublic String numberToWords(int num) {\\n\\tif (num < 21)\\n\\t\\treturn WORD_BY_VAL.get(num);\\n\\t\\n\\tvar ans = new StringBuilder();\\n\\tfor (var entry : BIG_WORD_BY_VAL.entrySet())\\n\\t\\tnum = reduce(num, ans, entry.getKey(), entry.getValue());\\n\\t\\n\\treturn convert(num, ans).toString()\\n\\t\\t\\t\\t\\t\\t    .trim();\\n}\\n\\nprivate int reduce(int num, StringBuilder ans, int denomination, String denominationWord) {\\n\\tif (num >= denomination) {\\n\\t\\tconvert(num / denomination, ans)).append(denominationWord);\\n\\t\\tnum %= denomination;\\n\\t}\\n\\treturn num;\\n}\\n\\n/*\\nThere are three reductions in this method. I\\'ve explained them here sequentially:\\n1. Reduce by 100. This is applicable for b/millions, thousands and hundreds.\\n2. Reduce by 10. If quotient is 1, it means number is between [11, 19], so get name \\nfrom map and the next block (3) will not execute, else multiply the quotient by 10 to get \\nthe word from map \\n3. If remainder is of the form xy, where x = 2 to 9 and y != 0, e.g. 23, so \"twenty three\"\\nwe don\\'t want to do it for 20, 30 etc, because we don\\'t say \"twenty zero\"\\nwe also don\\'t want to do it for [11, 19] because we don\\'t say \"ten one\", \\nthey have their unique names already covered in the map\\n*/\\nprivate StringBuilder convert(int t, StringBuilder ans) {\\n\\tvar hun = t / 100;\\n\\tif (hun != 0)\\n\\t\\tans.append(\" \")\\n\\t\\t   .append(WORD_BY_VAL.get(hun))\\n\\t\\t   .append(\" Hundred\");\\n\\tt %= 100;\\n\\n\\tvar ten = t / 10;\\n\\tif (ten != 0) {\\n\\t\\tans.append(\" \");\\n\\t\\tif (ten == 1) // for 11 to 19\\n\\t\\t\\tans.append(WORD_BY_VAL.get(t));\\n\\t\\telse // for 2x to 9x\\n\\t\\t\\tans.append(WORD_BY_VAL.get(ten * 10));\\n\\t}\\n\\tt %= 10;\\n\\n\\tif (ten != 1 && t != 0)\\n\\t\\tans.append(\" \")\\n\\t\\t   .append(WORD_BY_VAL.get(t));\\n\\t\\t   \\n\\treturn ans;\\n}\\n\\nstatic {\\n\\tBIG_WORD_BY_VAL.put(1_000_000_000, \" Billion\");\\n\\tBIG_WORD_BY_VAL.put(1_000_000, \" Million\");\\n\\tBIG_WORD_BY_VAL.put(1_000, \" Thousand\");\\n\\n\\tWORD_BY_VAL.put(0, \"Zero\");\\n\\tWORD_BY_VAL.put(1, \"One\");\\n\\tWORD_BY_VAL.put(2, \"Two\");\\n\\tWORD_BY_VAL.put(3, \"Three\");\\n\\tWORD_BY_VAL.put(4, \"Four\");\\n\\tWORD_BY_VAL.put(5, \"Five\");\\n\\tWORD_BY_VAL.put(6, \"Six\");\\n\\tWORD_BY_VAL.put(7, \"Seven\");\\n\\tWORD_BY_VAL.put(8, \"Eight\");\\n\\tWORD_BY_VAL.put(9, \"Nine\");\\n\\tWORD_BY_VAL.put(10, \"Ten\");\\n\\tWORD_BY_VAL.put(11, \"Eleven\");\\n\\tWORD_BY_VAL.put(12, \"Twelve\");\\n\\tWORD_BY_VAL.put(13, \"Thirteen\");\\n\\tWORD_BY_VAL.put(14, \"Fourteen\");\\n\\tWORD_BY_VAL.put(15, \"Fifteen\");\\n\\tWORD_BY_VAL.put(16, \"Sixteen\");\\n\\tWORD_BY_VAL.put(17, \"Seventeen\");\\n\\tWORD_BY_VAL.put(18, \"Eighteen\");\\n\\tWORD_BY_VAL.put(19, \"Nineteen\");\\n\\tWORD_BY_VAL.put(20, \"Twenty\");\\n\\tWORD_BY_VAL.put(30, \"Thirty\");\\n\\tWORD_BY_VAL.put(40, \"Forty\");\\n\\tWORD_BY_VAL.put(50, \"Fifty\");\\n\\tWORD_BY_VAL.put(60, \"Sixty\");\\n\\tWORD_BY_VAL.put(70, \"Seventy\");\\n\\tWORD_BY_VAL.put(80, \"Eighty\");\\n\\tWORD_BY_VAL.put(90, \"Ninety\");\\n\\tWORD_BY_VAL.put(100, \"Hundred\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213494,
                "title": "python-solution",
                "content": "Recursion. Time complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution:\\n    def numberToWords(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        def helper(num):\\n            if num < 10:\\n                return dic1[num]\\n            elif 10 <= num < 20:\\n                return dic3[num]\\n            elif num < 100:\\n                res = []\\n                q, num = divmod(num, 10)\\n                res.append(dic2[q*10])\\n                if num > 0:\\n                    res.append(\" \"+dic1[num])\\n                return \"\".join(res)\\n            elif num < 1000:\\n                q, num = divmod(num, 100)\\n                if num == 0:\\n                    return dic1[q]+\" \"+\"Hundred\"\\n                else:\\n                    return dic1[q]+\" \"+\"Hundred\"+\" \"+helper(num)\\n            elif num < 1000000:\\n                q, num = divmod(num, 1000)\\n                if num == 0:\\n                    return helper(q)+\" \"+\"Thousand\"\\n                else:\\n                    return helper(q)+\" \"+\"Thousand\"+\" \"+helper(num)\\n            elif num < 1000000000:\\n                q, num = divmod(num, 1000000)\\n                if num == 0:\\n                    return helper(q)+\" \"+\"Million\"\\n                else:\\n                    return helper(q)+\" \"+\"Million\"+\" \"+helper(num)\\n            else:\\n                q, num = divmod(num, 1000000000)\\n                if num == 0:\\n                    return helper(q)+\" \"+\"Billion\"\\n                else:\\n                    return helper(q)+\" \"+\"Billion\"+\" \"+helper(num)  \\n                \\n        if num == 0:\\n            return \"Zero\"\\n        \\n        dic1 = {9:\"Nine\", 8:\"Eight\", 7:\"Seven\", 6:\"Six\", \\n                5:\"Five\", 4:\"Four\", 3:\"Three\", 2:\"Two\", 1:\"One\"}\\n        dic2 = {90:\"Ninety\", 80:\"Eighty\", 70:\"Seventy\", 60:\"Sixty\", \\n                50:\"Fifty\", 40:\"Forty\", 30:\"Thirty\", 20:\"Twenty\"} \\n        dic3 = {19:\"Nineteen\", 18:\"Eighteen\", 17:\"Seventeen\", \\n                16:\"Sixteen\", 15:\"Fifteen\", 14:\"Fourteen\", 13:\"Thirteen\", \\n                12:\"Twelve\", 11:\"Eleven\", 10:\"Ten\"}\\n        \\n        return helper(num)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        def helper(num):\\n            if num < 10:\\n                return dic1[num]\\n            elif 10 <= num < 20:\\n                return dic3[num]\\n            elif num < 100:\\n                res = []\\n                q, num = divmod(num, 10)\\n                res.append(dic2[q*10])\\n                if num > 0:\\n                    res.append(\" \"+dic1[num])\\n                return \"\".join(res)\\n            elif num < 1000:\\n                q, num = divmod(num, 100)\\n                if num == 0:\\n                    return dic1[q]+\" \"+\"Hundred\"\\n                else:\\n                    return dic1[q]+\" \"+\"Hundred\"+\" \"+helper(num)\\n            elif num < 1000000:\\n                q, num = divmod(num, 1000)\\n                if num == 0:\\n                    return helper(q)+\" \"+\"Thousand\"\\n                else:\\n                    return helper(q)+\" \"+\"Thousand\"+\" \"+helper(num)\\n            elif num < 1000000000:\\n                q, num = divmod(num, 1000000)\\n                if num == 0:\\n                    return helper(q)+\" \"+\"Million\"\\n                else:\\n                    return helper(q)+\" \"+\"Million\"+\" \"+helper(num)\\n            else:\\n                q, num = divmod(num, 1000000000)\\n                if num == 0:\\n                    return helper(q)+\" \"+\"Billion\"\\n                else:\\n                    return helper(q)+\" \"+\"Billion\"+\" \"+helper(num)  \\n                \\n        if num == 0:\\n            return \"Zero\"\\n        \\n        dic1 = {9:\"Nine\", 8:\"Eight\", 7:\"Seven\", 6:\"Six\", \\n                5:\"Five\", 4:\"Four\", 3:\"Three\", 2:\"Two\", 1:\"One\"}\\n        dic2 = {90:\"Ninety\", 80:\"Eighty\", 70:\"Seventy\", 60:\"Sixty\", \\n                50:\"Fifty\", 40:\"Forty\", 30:\"Thirty\", 20:\"Twenty\"} \\n        dic3 = {19:\"Nineteen\", 18:\"Eighteen\", 17:\"Seventeen\", \\n                16:\"Sixteen\", 15:\"Fifteen\", 14:\"Fourteen\", 13:\"Thirteen\", \\n                12:\"Twelve\", 11:\"Eleven\", 10:\"Ten\"}\\n        \\n        return helper(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70635,
                "title": "4ms-clean-java-solution",
                "content": "    public class Solution {\\n        public String[] oneToNineteen = new String[]{\\n            \"\",\\n            \"One\",\\n            \"Two\",\\n            \"Three\",\\n            \"Four\",\\n            \"Five\",\\n            \"Six\",\\n            \"Seven\",\\n            \"Eight\",\\n            \"Nine\",\\n            \"Ten\",\\n            \"Eleven\",\\n            \"Twelve\",\\n            \"Thirteen\",\\n            \"Fourteen\",\\n            \"Fifteen\",\\n            \"Sixteen\",\\n            \"Seventeen\",\\n            \"Eighteen\",\\n            \"Nineteen\"\\n        };\\n        \\n        public String[] twentyToNinety = new String[]{\\n            \"\",\\n            \"Ten\",\\n            \"Twenty\",\\n            \"Thirty\",\\n            \"Forty\",\\n            \"Fifty\",\\n            \"Sixty\",\\n            \"Seventy\",\\n            \"Eighty\",\\n            \"Ninety\"\\n        };\\n        \\n        public String[] hunderedToBillion = new String[]{\\n            \"Hundred\",\\n            \"Thousand\",\\n            \"Million\",\\n            \"Billion\"\\n        };\\n        \\n        public String numberToWords(int num) {\\n            if(num == 0){\\n                return \"Zero\";\\n            }\\n            \\n            StringBuilder builder = new StringBuilder();\\n            convert(num, builder);\\n            return builder.toString().trim();\\n        }\\n        \\n        public void convert(int n, StringBuilder builder){\\n            if(n == 0){\\n            \\treturn;\\n            }\\n            \\t\\n            if(n < 20){\\n                builder.append(oneToNineteen[n]);\\n                builder.append(\" \");\\n            }else if(n < 100){\\n                builder.append(twentyToNinety[n/10]);\\n                builder.append(\" \");\\n                convert(n%10, builder);\\n            }else if(n<1000){\\n                convert(n/100, builder);\\n                builder.append(hunderedToBillion[0]);\\n                builder.append(\" \");\\n                convert(n%100, builder);\\n            }else if(n<1000000){\\n                convert(n/1000, builder);\\n                builder.append(hunderedToBillion[1]);\\n                builder.append(\" \");\\n                convert(n%1000, builder);\\n            }else if(n<1000000000){\\n                convert(n/1000000, builder);\\n                builder.append(hunderedToBillion[2]);\\n                builder.append(\" \");\\n                convert(n%1000000, builder);\\n            }else{\\n                convert(n/1000000000, builder);\\n                builder.append(hunderedToBillion[3]);\\n                builder.append(\" \");\\n                convert(n%1000000000, builder);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String[] oneToNineteen = new String[]{\\n            \"\",\\n            \"One\",\\n            \"Two\",\\n            \"Three\",\\n            \"Four\",\\n            \"Five\",\\n            \"Six\",\\n            \"Seven\",\\n            \"Eight\",\\n            \"Nine\",\\n            \"Ten\",\\n            \"Eleven\",\\n            \"Twelve\",\\n            \"Thirteen\",\\n            \"Fourteen\",\\n            \"Fifteen\",\\n            \"Sixteen\",\\n            \"Seventeen\",\\n            \"Eighteen\",\\n            \"Nineteen\"\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 70755,
                "title": "c-solution-4ms",
                "content": "//8ms\\t\\n\\n    string helper(int& num){\\n    \\t\\tconst static char* less_ten[] =\\n    \\t\\t{ \"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\", \" Seven\", \" Eight\", \" Nine\" };\\n    \\t\\tconst static char* less_twenty[] =\\n    \\t\\t{ \" Ten\", \" Eleven\", \" Twelve\", \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\", \" Eighteen\", \" Nineteen\" };\\n    \\t\\tconst static char* less_hundred[] =\\n    \\t\\t{ \"\", \"\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\", \" Seventy\", \" Eighty\", \" Ninety\" };\\n    \\n    \\t\\tint less_thousand = num % 1000;\\n    \\t\\tnum /= 1000;\\n    \\t\\tstring s; \\n    \\t\\t\\n    \\t\\tif (less_thousand != 0){\\n    \\t\\t\\tint hundred = less_thousand / 100;\\n    \\t\\t\\tless_thousand %= 100; \\n    \\t\\t\\tint tenth = less_thousand / 10; \\n    \\t\\t\\tint single = less_thousand % 10; \\n    \\t\\t\\t\\n    \\t\\t\\tif (hundred) s = s + less_ten[hundred] + \" Hundred\";\\n    \\t\\t\\t\\n    \\t\\t\\tif (tenth){\\n    \\t\\t\\t\\tif (tenth == 1){\\n    \\t\\t            s += less_twenty[single];\\n    \\t\\t\\t\\t\\treturn s;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse  s += less_hundred[tenth];\\n    \\n    \\t\\t\\t}\\n    \\t\\t\\tif (single) s += less_ten[single];\\n    \\t\\t}\\n    \\t\\treturn s;\\n    \\t}\\n    \\tstring numberToWords(int num) {\\n    \\t\\tconst static char* unit[] = \\n    \\t\\t    { \"\", \" Thousand\", \" Million\", \" Billion\", \" Triliion\" };\\n    \\t\\t    \\n    \\t\\tstring s;\\n    \\t\\tint i = 0;\\n    \\t\\twhile (num){\\n    \\t\\t\\tstring part = helper(num);\\n    \\t\\t\\tif(i++ == 0){\\n    \\t\\t\\t    s = part; \\n    \\t\\t\\t} \\n    \\t\\t\\telse if (part.size()) s = part + unit[i] + s;\\n    \\t\\t}\\n    \\t\\ts = s.size() ? s.substr(1) : \"Zero\";\\n    \\t\\treturn s;\\n    \\t}\\n\\n\\nA faster version and maybe easier to understand (4ms):\\n\\n    string helper(int num){\\n    \\tconst static char* less_ten[] =\\n    \\t{ \"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\", \" Seven\", \" Eight\", \" Nine\" };\\n    \\tconst static char* less_twenty[] =\\n    \\t{ \" Ten\", \" Eleven\", \" Twelve\", \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\", \" Eighteen\", \" Nineteen\" };\\n    \\tconst static char* less_hundred[] =\\n    \\t{ \"\", \"\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\", \" Seventy\", \" Eighty\", \" Ninety\" };\\n    \\n    \\tstring s; \\n    \\t\\n    \\tif (num != 0){\\n    \\t    //get hundredth, tenth, and single digit\\n    \\t\\tint hundred = num / 100;\\n    \\t\\tnum %= 100; \\n    \\t\\tint tenth = num / 10; \\n    \\t\\tint single = num % 10; \\n    \\t\\t\\n    \\t\\tif (hundred) s = s + less_ten[hundred] + \" Hundred\";\\n    \\t\\t\\n    \\t\\tif (tenth){\\n    \\t\\t\\tif (tenth == 1){ //special handling, choose from less_twenty based on value of single\\n    \\t            s += less_twenty[single];\\n    \\t\\t\\t\\treturn s;\\n    \\t\\t\\t}\\n    \\t\\t\\telse  s += less_hundred[tenth];\\n    \\n    \\t\\t}\\n    \\t\\tif (single) s += less_ten[single];\\n    \\t}\\n    \\treturn s;\\n    }\\n    string numberToWords(int num) {\\n    \\tconst static char* unit[] = \\n    \\t    { \"\", \" Thousand\", \" Million\", \" Billion\" };\\n    \\tint parts[4] = {0};\\n    \\tfor(int i  = 0; i < 4; ++i){\\n    \\t    parts[i] = num % 1000;\\n    \\t    num /= 1000; \\n    \\t}\\n    \\tstring s; \\n    \\tfor(int i = 0; i < 4; ++i){\\n    \\t    if(parts[i] == 0) continue; \\n    \\t    s = helper(parts[i]) + unit[i] + s;  \\n    \\t}\\n    \\ts = s.size() ? s.substr(1) : \"Zero\";\\n    \\treturn s;\\n    }",
                "solutionTags": [],
                "code": "//8ms\\t\\n\\n    string helper(int& num){\\n    \\t\\tconst static char* less_ten[] =\\n    \\t\\t{ \"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\", \" Seven\", \" Eight\", \" Nine\" };\\n    \\t\\tconst static char* less_twenty[] =\\n    \\t\\t{ \" Ten\", \" Eleven\", \" Twelve\", \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\", \" Eighteen\", \" Nineteen\" };\\n    \\t\\tconst static char* less_hundred[] =\\n    \\t\\t{ \"\", \"\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\", \" Seventy\", \" Eighty\", \" Ninety\" };\\n    \\n    \\t\\tint less_thousand = num % 1000;\\n    \\t\\tnum /= 1000;\\n    \\t\\tstring s; \\n    \\t\\t\\n    \\t\\tif (less_thousand != 0){\\n    \\t\\t\\tint hundred = less_thousand / 100;\\n    \\t\\t\\tless_thousand %= 100; \\n    \\t\\t\\tint tenth = less_thousand / 10; \\n    \\t\\t\\tint single = less_thousand % 10; \\n    \\t\\t\\t\\n    \\t\\t\\tif (hundred) s = s + less_ten[hundred] + \" Hundred\";\\n    \\t\\t\\t\\n    \\t\\t\\tif (tenth){\\n    \\t\\t\\t\\tif (tenth == 1){\\n    \\t\\t            s += less_twenty[single];\\n    \\t\\t\\t\\t\\treturn s;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse  s += less_hundred[tenth];\\n    \\n    \\t\\t\\t}\\n    \\t\\t\\tif (single) s += less_ten[single];\\n    \\t\\t}\\n    \\t\\treturn s;\\n    \\t}\\n    \\tstring numberToWords(int num) {\\n    \\t\\tconst static char* unit[] = \\n    \\t\\t    { \"\", \" Thousand\", \" Million\", \" Billion\", \" Triliion\" };\\n    \\t\\t    \\n    \\t\\tstring s;\\n    \\t\\tint i = 0;\\n    \\t\\twhile (num){\\n    \\t\\t\\tstring part = helper(num);\\n    \\t\\t\\tif(i++ == 0){\\n    \\t\\t\\t    s = part; \\n    \\t\\t\\t} \\n    \\t\\t\\telse if (part.size()) s = part + unit[i] + s;\\n    \\t\\t}\\n    \\t\\ts = s.size() ? s.substr(1) : \"Zero\";\\n    \\t\\treturn s;\\n    \\t}\\n\\n\\nA faster version and maybe easier to understand (4ms):\\n\\n    string helper(int num){\\n    \\tconst static char* less_ten[] =\\n    \\t{ \"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\", \" Seven\", \" Eight\", \" Nine\" };\\n    \\tconst static char* less_twenty[] =\\n    \\t{ \" Ten\", \" Eleven\", \" Twelve\", \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\", \" Eighteen\", \" Nineteen\" };\\n    \\tconst static char* less_hundred[] =\\n    \\t{ \"\", \"\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\", \" Seventy\", \" Eighty\", \" Ninety\" };\\n    \\n    \\tstring s; \\n    \\t\\n    \\tif (num != 0){\\n    \\t    //get hundredth, tenth, and single digit\\n    \\t\\tint hundred = num / 100;\\n    \\t\\tnum %= 100; \\n    \\t\\tint tenth = num / 10; \\n    \\t\\tint single = num % 10; \\n    \\t\\t\\n    \\t\\tif (hundred) s = s + less_ten[hundred] + \" Hundred\";\\n    \\t\\t\\n    \\t\\tif (tenth){\\n    \\t\\t\\tif (tenth == 1){ //special handling, choose from less_twenty based on value of single\\n    \\t            s += less_twenty[single];\\n    \\t\\t\\t\\treturn s;\\n    \\t\\t\\t}\\n    \\t\\t\\telse  s += less_hundred[tenth];\\n    \\n    \\t\\t}\\n    \\t\\tif (single) s += less_ten[single];\\n    \\t}\\n    \\treturn s;\\n    }\\n    string numberToWords(int num) {\\n    \\tconst static char* unit[] = \\n    \\t    { \"\", \" Thousand\", \" Million\", \" Billion\" };\\n    \\tint parts[4] = {0};\\n    \\tfor(int i  = 0; i < 4; ++i){\\n    \\t    parts[i] = num % 1000;\\n    \\t    num /= 1000; \\n    \\t}\\n    \\tstring s; \\n    \\tfor(int i = 0; i < 4; ++i){\\n    \\t    if(parts[i] == 0) continue; \\n    \\t    s = helper(parts[i]) + unit[i] + s;  \\n    \\t}\\n    \\ts = s.size() ? s.substr(1) : \"Zero\";\\n    \\treturn s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 528742,
                "title": "python-3-runtime-28ms-recursive-approach",
                "content": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        self.lessThan20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\n        self.tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n        self.thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"];\\n        if num == 0 :\\n            return \"Zero\"\\n        res = \\'\\'\\n        i = 0\\n        while num>0:\\n            if num%1000 != 0:\\n                res = self.helper(num%1000) + self.thousands[i] + \" \" + res\\n            num //= 1000\\n            i += 1\\n        return res.strip()\\n    \\n    def helper(self, num):\\n        if num == 0:\\n            return \"\"\\n        if num < 20:\\n            return self.lessThan20[num] + \" \"\\n        if num < 100:\\n            return self.tens[num//10] + \" \" + self.helper(num%10)\\n        if num < 1000:\\n            return self.lessThan20[num//100] + \" Hundred \" + self.helper(num%100)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        self.lessThan20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\n        self.tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n        self.thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"];\\n        if num == 0 :\\n            return \"Zero\"\\n        res = \\'\\'\\n        i = 0\\n        while num>0:\\n            if num%1000 != 0:\\n                res = self.helper(num%1000) + self.thousands[i] + \" \" + res\\n            num //= 1000\\n            i += 1\\n        return res.strip()\\n    \\n    def helper(self, num):\\n        if num == 0:\\n            return \"\"\\n        if num < 20:\\n            return self.lessThan20[num] + \" \"\\n        if num < 100:\\n            return self.tens[num//10] + \" \" + self.helper(num%10)\\n        if num < 1000:\\n            return self.lessThan20[num//100] + \" Hundred \" + self.helper(num%100)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436775,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    string[] lessThan20 = \",One,Two,Three,Four,Five,Six,Seven,Eight,Nine,Ten,Eleven,Twelve,Thirteen,Fourteen,Fifteen,Sixteen,Seventeen,Eighteen,Nineteen\".Split(\",\");\\n    string[] tens = \",Ten,Twenty,Thirty,Forty,Fifty,Sixty,Seventy,Eighty,Ninety\".Split(\",\");\\n    string[] thousands = \",Thousand,Million,Billion\".Split(\",\"); \\n    \\n    public string NumberToWords(int num) \\n    {\\n        if(num == 0) return \"Zero\";\\n        var result = new List<string>();\\n        for(int i = 0; i < thousands.Length; i++)\\n        {\\n            var lessThanThousand = num % 1000;\\n            num = num / 1000;\\n            if(lessThanThousand != 0)\\n            {\\n                var res = ConvertLessThanThousand(lessThanThousand);\\n                res.Add(thousands[i]);\\n                res.AddRange(result);\\n                result = res;\\n            }\\n        }\\n        \\n        return string.Join(\" \", result.Where(x => !string.IsNullOrWhiteSpace(x))).Trim();\\n    }\\n    \\n    private List<string> ConvertLessThanThousand(int n)\\n    {\\n        var result = new List<string>();\\n        if(n < 20)\\n            result.Add(lessThan20[n]);\\n        else if(n < 100)\\n        {\\n            result.Add(tens[n / 10]);\\n            result.AddRange(ConvertLessThanThousand(n % 10));\\n        }\\n        else\\n        {\\n            result.AddRange(ConvertLessThanThousand(n / 100));\\n            result.Add(\"Hundred\");\\n            result.AddRange(ConvertLessThanThousand(n % 100));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    string[] lessThan20 = \",One,Two,Three,Four,Five,Six,Seven,Eight,Nine,Ten,Eleven,Twelve,Thirteen,Fourteen,Fifteen,Sixteen,Seventeen,Eighteen,Nineteen\".Split(\",\");\\n    string[] tens = \",Ten,Twenty,Thirty,Forty,Fifty,Sixty,Seventy,Eighty,Ninety\".Split(\",\");\\n    string[] thousands = \",Thousand,Million,Billion\".Split(\",\"); \\n    \\n    public string NumberToWords(int num) \\n    {\\n        if(num == 0) return \"Zero\";\\n        var result = new List<string>();\\n        for(int i = 0; i < thousands.Length; i++)\\n        {\\n            var lessThanThousand = num % 1000;\\n            num = num / 1000;\\n            if(lessThanThousand != 0)\\n            {\\n                var res = ConvertLessThanThousand(lessThanThousand);\\n                res.Add(thousands[i]);\\n                res.AddRange(result);\\n                result = res;\\n            }\\n        }\\n        \\n        return string.Join(\" \", result.Where(x => !string.IsNullOrWhiteSpace(x))).Trim();\\n    }\\n    \\n    private List<string> ConvertLessThanThousand(int n)\\n    {\\n        var result = new List<string>();\\n        if(n < 20)\\n            result.Add(lessThan20[n]);\\n        else if(n < 100)\\n        {\\n            result.Add(tens[n / 10]);\\n            result.AddRange(ConvertLessThanThousand(n % 10));\\n        }\\n        else\\n        {\\n            result.AddRange(ConvertLessThanThousand(n / 100));\\n            result.Add(\"Hundred\");\\n            result.AddRange(ConvertLessThanThousand(n % 100));\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70630,
                "title": "3ms-short-c",
                "content": "```\\nclass Solution { \\npublic:\\n    string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        vector<string>thousands({\"\", \" Thousand\", \" Million\", \" Billion\"});\\n        string res = \"\";\\n        int i = 0;\\n        while(num){\\n            if(num % 1000) res = helper(num % 1000) + thousands[i] + (res.size() ? \" \" : \"\") + res;\\n            num /= 1000;\\n            i++;\\n        }\\n        return res;\\n    }\\n    \\n    string helper(int num){\\n        vector<string>lessThan20({\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"});\\n        vector<string>tens({\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"});\\n        if(num >= 100) return lessThan20[num / 100] + \" Hundred\" + (num % 100 ? \" \": \"\") + helper(num % 100);\\n        else if(num >= 20) return tens[num / 10] + (num % 10 ? \" \": \"\") + helper(num % 10);\\n        else return lessThan20[num];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        vector<string>thousands({\"\", \" Thousand\", \" Million\", \" Billion\"});\\n        string res = \"\";\\n        int i = 0;\\n        while(num){\\n            if(num % 1000) res = helper(num % 1000) + thousands[i] + (res.size() ? \" \" : \"\") + res;\\n            num /= 1000;\\n            i++;\\n        }\\n        return res;\\n    }\\n    \\n    string helper(int num){\\n        vector<string>lessThan20({\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"});\\n        vector<string>tens({\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"});\\n        if(num >= 100) return lessThan20[num / 100] + \" Hundred\" + (num % 100 ? \" \": \"\") + helper(num % 100);\\n        else if(num >= 20) return tens[num / 10] + (num % 10 ? \" \": \"\") + helper(num % 10);\\n        else return lessThan20[num];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70692,
                "title": "a-simple-8ms-recursive-method",
                "content": "    class Solution {\\n    public:\\n        string digits[19] = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\"Nine\",\\n                           \"Ten\",\"Eleven\", \"Twelve\", \"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n        string tens[8] = {\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        \\n        string int2english(int num){\\n            if(num >= 1000000000){\\n                return int2english(num / 1000000000) + \" Billion\" + int2english(num % 1000000000);\\n            }\\n            if(num >= 1000000){\\n                return int2english(num / 1000000) + \" Million\" + int2english(num % 1000000);\\n            }\\n            if(num >= 1000){\\n                return int2english(num / 1000) + \" Thousand\" + int2english(num % 1000);\\n            }\\n            if(num >= 100){\\n                return int2english(num / 100) + \" Hundred\" + int2english(num % 100);\\n            }\\n            if(num >= 20){\\n                return \" \" + tens[num / 10 - 2] + int2english(num % 10);\\n            }\\n            if(num > 0){\\n                return \" \" + digits[num - 1];\\n            }\\n            return \"\";\\n        }\\n        \\n        string numberToWords(int num) {\\n            if(num == 0){\\n                return \"Zero\";\\n            }\\n            string ans = int2english(num);\\n            ans = ans.substr(1, ans.length() - 1);\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string digits[19] = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\"Nine\",\\n                           \"Ten\",\"Eleven\", \"Twelve\", \"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"}",
                "codeTag": "Java"
            },
            {
                "id": 2402313,
                "title": "very-easy-and-short-cpp-solution",
                "content": "***Pls Upvote if found helpful***\\n```\\n    string intToString(int n){\\n        string ones[20] = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        string tens[10] = {\"\",\"\",\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"}; \\n\\t\\t// the first two places are left empty so that it helps with the index. Note how Twenty is at index 2, Thirty is at index 3....\\n        \\n        if(n >= 1000000000) return intToString(n/1000000000) + \" Billion\" + intToString(n % 1000000000);\\n        if(n >= 1000000) return intToString(n/1000000) + \" Million\" + intToString(n % 1000000);\\n        if(n >= 1000) return intToString(n/1000) + \" Thousand\" + intToString(n % 1000);\\n        if(n >= 100) return intToString(n/100) + \" Hundred\" + intToString(n % 100);\\n        if(n >= 20) return \" \" + tens[n/10] + intToString(n % 10) ;\\n        if(n >= 1) return \" \" + ones[n];\\n        return \"\";\\n    }\\n    string numberToWords(int num) {\\n         if(num == 0) return \"Zero\";\\n        return intToString(num).substr(1);  // removing the leading space\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string intToString(int n){\\n        string ones[20] = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        string tens[10] = {\"\",\"\",\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"}; \\n\\t\\t// the first two places are left empty so that it helps with the index. Note how Twenty is at index 2, Thirty is at index 3....\\n        \\n        if(n >= 1000000000) return intToString(n/1000000000) + \" Billion\" + intToString(n % 1000000000);\\n        if(n >= 1000000) return intToString(n/1000000) + \" Million\" + intToString(n % 1000000);\\n        if(n >= 1000) return intToString(n/1000) + \" Thousand\" + intToString(n % 1000);\\n        if(n >= 100) return intToString(n/100) + \" Hundred\" + intToString(n % 100);\\n        if(n >= 20) return \" \" + tens[n/10] + intToString(n % 10) ;\\n        if(n >= 1) return \" \" + ones[n];\\n        return \"\";\\n    }\\n    string numberToWords(int num) {\\n         if(num == 0) return \"Zero\";\\n        return intToString(num).substr(1);  // removing the leading space\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939386,
                "title": "short-easy-to-understand-python-code-using-dictionary",
                "content": "```Python\\nclass Solution:        \\n    def numberToWords(self, num: int) -> str:\\n        if num == 0 : return \\'Zero\\' #if condition to handle zero\\n        d = {1000000000 : \\'Billion\\',1000000 : \\'Million\\',1000 : \\'Thousand\\',100 : \\'Hundred\\', \\n\\t\\t90:\\'Ninety\\',80:\\'Eighty\\',70:\\'Seventy\\',60:\\'Sixty\\',50: \\'Fifty\\', 40 : \\'Forty\\', 30 : \\'Thirty\\', 20 : \\'Twenty\\',\\n\\t\\t19 :\\'Nineteen\\',18 :\\'Eighteen\\',17:\\'Seventeen\\',16:\\'Sixteen\\',15:\\'Fifteen\\',14:\\'Fourteen\\',13:\\'Thirteen\\',12:\\'Twelve\\',11:\\'Eleven\\',\\n\\t\\t10:\\'Ten\\',9:\\'Nine\\',8:\\'Eight\\',7:\\'Seven\\',6:\\'Six\\',5:\\'Five\\',4:\\'Four\\',3:\\'Three\\',2:\\'Two\\',1:\\'One\\'} #initiating a dictionary to handle number to word mapping\\n        ans = \"\"                      #initialising the returnable answer variable\\n        for key, value in d.items():  #for loop to iterate through each key-value pair in dictionary \\n            if num//key>0 :           #checking if number is in the range of current key\\n                x = num//key          #finding the multiple of key in num\\n                if key >= 100 :       #logic to add the multiple number x above as word to our answer, We say \"One Hundred\", \"One thoushand\" but we don\\'t say \"One Fifty\", we simply say \"Fifty\"\\n                    ans += self.numberToWords(x) + \\' \\'\\n                ans  += value + \" \"\\n                num = num%key         #preparing the number for next loop i.e removing the value from num which we have already appended the words to answer.\\n        return ans.strip()            #returning answer removing the last blank space\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:        \\n    def numberToWords(self, num: int) -> str:\\n        if num == 0 : return \\'Zero\\' #if condition to handle zero\\n        d = {1000000000 : \\'Billion\\',1000000 : \\'Million\\',1000 : \\'Thousand\\',100 : \\'Hundred\\', \\n\\t\\t90:\\'Ninety\\',80:\\'Eighty\\',70:\\'Seventy\\',60:\\'Sixty\\',50: \\'Fifty\\', 40 : \\'Forty\\', 30 : \\'Thirty\\', 20 : \\'Twenty\\',\\n\\t\\t19 :\\'Nineteen\\',18 :\\'Eighteen\\',17:\\'Seventeen\\',16:\\'Sixteen\\',15:\\'Fifteen\\',14:\\'Fourteen\\',13:\\'Thirteen\\',12:\\'Twelve\\',11:\\'Eleven\\',\\n\\t\\t10:\\'Ten\\',9:\\'Nine\\',8:\\'Eight\\',7:\\'Seven\\',6:\\'Six\\',5:\\'Five\\',4:\\'Four\\',3:\\'Three\\',2:\\'Two\\',1:\\'One\\'} #initiating a dictionary to handle number to word mapping\\n        ans = \"\"                      #initialising the returnable answer variable\\n        for key, value in d.items():  #for loop to iterate through each key-value pair in dictionary \\n            if num//key>0 :           #checking if number is in the range of current key\\n                x = num//key          #finding the multiple of key in num\\n                if key >= 100 :       #logic to add the multiple number x above as word to our answer, We say \"One Hundred\", \"One thoushand\" but we don\\'t say \"One Fifty\", we simply say \"Fifty\"\\n                    ans += self.numberToWords(x) + \\' \\'\\n                ans  += value + \" \"\\n                num = num%key         #preparing the number for next loop i.e removing the value from num which we have already appended the words to answer.\\n        return ans.strip()            #returning answer removing the last blank space\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512440,
                "title": "c-faster-99",
                "content": "```\\npublic class Solution {\\n    private string[] belowTen = new string[] { \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" };\\n    private string[] belowTwenty = new string[] { \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\" };\\n    private string[] belowHundred = new string[] { \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" };\\n    \\n    public string NumberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        return Helper(num);\\n    }\\n    \\n    private string Helper(int num) {\\n        if (num < 10) return belowTen[num];\\n        if (num < 20) return belowTwenty[num % 10];\\n        if (num < 100) return $\"{belowHundred[num / 10]} {belowTen[num % 10]}\".Trim();\\n        if (num < 1000) return $\"{Helper(num / 100)} Hundred {Helper(num % 100)}\".Trim();\\n        if (num < 1000000) return $\"{Helper(num / 1000)} Thousand {Helper(num % 1000)}\".Trim();\\n        if (num < 1000000000) return $\"{Helper(num / 1000000)} Million {Helper(num % 1000000)}\".Trim();\\n        return $\"{Helper(num / 1000000000)} Billion {Helper(num % 1000000000)}\".Trim();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private string[] belowTen = new string[] { \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" };\\n    private string[] belowTwenty = new string[] { \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\" };\\n    private string[] belowHundred = new string[] { \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" };\\n    \\n    public string NumberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        return Helper(num);\\n    }\\n    \\n    private string Helper(int num) {\\n        if (num < 10) return belowTen[num];\\n        if (num < 20) return belowTwenty[num % 10];\\n        if (num < 100) return $\"{belowHundred[num / 10]} {belowTen[num % 10]}\".Trim();\\n        if (num < 1000) return $\"{Helper(num / 100)} Hundred {Helper(num % 100)}\".Trim();\\n        if (num < 1000000) return $\"{Helper(num / 1000)} Thousand {Helper(num % 1000)}\".Trim();\\n        if (num < 1000000000) return $\"{Helper(num / 1000000)} Million {Helper(num % 1000000)}\".Trim();\\n        return $\"{Helper(num / 1000000000)} Billion {Helper(num % 1000000000)}\".Trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360815,
                "title": "javascript-clean-and-short-answer",
                "content": "JavaScript version of popular solution that I found very helpful and intuitive.\\n\\n```\\nconst LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"];\\nconst TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"];\\nconst THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"];\\n\\nvar numberToWords = function(num) {\\n    if(num === 0) {\\n        return \\'Zero\\';\\n    }\\n    let thousandCounter = 0;\\n    let result = \\'\\';\\n    \\n    while(num > 0) {\\n        if(num % 1000 != 0) {\\n            result = numToString(num % 1000) + THOUSANDS[thousandCounter] + \\' \\' + result;\\n        }\\n        num /= 1000;\\n        num = Math.trunc(num);\\n        thousandCounter++;\\n    }\\n    return result.trim();\\n};\\n\\nfunction numToString(num) {\\n    if (num === 0)\\n        return \\'\\';\\n    else if (num < 20)\\n        return LESS_THAN_20[num] + \" \";\\n    else if (num < 100)\\n        return TENS[Math.trunc(num / 10)] + \" \" + numToString(num % 10);\\n    else\\n        return LESS_THAN_20[Math.trunc(num / 100)] + \" Hundred \" + numToString(num % 100);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst LESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"];\\nconst TENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"];\\nconst THOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"];\\n\\nvar numberToWords = function(num) {\\n    if(num === 0) {\\n        return \\'Zero\\';\\n    }\\n    let thousandCounter = 0;\\n    let result = \\'\\';\\n    \\n    while(num > 0) {\\n        if(num % 1000 != 0) {\\n            result = numToString(num % 1000) + THOUSANDS[thousandCounter] + \\' \\' + result;\\n        }\\n        num /= 1000;\\n        num = Math.trunc(num);\\n        thousandCounter++;\\n    }\\n    return result.trim();\\n};\\n\\nfunction numToString(num) {\\n    if (num === 0)\\n        return \\'\\';\\n    else if (num < 20)\\n        return LESS_THAN_20[num] + \" \";\\n    else if (num < 100)\\n        return TENS[Math.trunc(num / 10)] + \" \" + numToString(num % 10);\\n    else\\n        return LESS_THAN_20[Math.trunc(num / 100)] + \" Hundred \" + numToString(num % 100);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168888,
                "title": "please-upvote-for-my-hard-work",
                "content": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num==0:\\n            return \\'Zero\\'\\n        num=str(num)\\n        s=len(num)%3\\n        bx=[]\\n        bx.append(num[:s])\\n        for i in range(s,len(num),3):\\n            bx.append(num[i:i+3])\\n        \\n        def answer(s):\\n            x=\\'\\'\\n            if len(s)==3:\\n                if s[0]==\\'1\\':\\n                    x+=\\'One \\'\\n                if s[0]==\\'2\\':\\n                    x+=\\'Two \\'\\n                if s[0]==\\'3\\':\\n                    x+=\\'Three \\'\\n                if s[0]==\\'4\\':\\n                    x+=\\'Four \\'\\n                if s[0]==\\'5\\':\\n                    x+=\"Five \"\\n                if s[0]==\\'6\\':\\n                    x+=\\'Six \\'\\n                if s[0]==\\'7\\':\\n                    x+=\\'Seven \\'\\n                if s[0]==\\'8\\':\\n                    x+=\\'Eight \\'\\n                if s[0]==\\'9\\':\\n                    x+=\\'Nine \\'\\n                if s[0]!=\\'0\\':\\n                    x+=\\'Hundred \\'\\n            if len(s[len(s)-2:])==2:\\n                if s[len(s)-2]==\\'1\\':\\n                    if s[len(s)-2:]==\\'10\\':\\n                        x+=\\'Ten \\'\\n                    if s[len(s)-2:]==\\'11\\':\\n                        x+=\\'Eleven \\'\\n                    if s[len(s)-2:]==\\'12\\':\\n                        x+=\\'Twelve \\'\\n                    if s[len(s)-2:]==\\'13\\':\\n                        x+=\\'Thirteen \\'\\n                    if s[len(s)-2:]==\\'14\\':\\n                        x+=\\'Fourteen \\'\\n                    if s[len(s)-2:]==\\'15\\':\\n                        x+=\\'Fifteen \\'\\n                    if s[len(s)-2:]==\\'16\\':\\n                        x+=\\'Sixteen \\'\\n                    if s[len(s)-2:]==\\'17\\':\\n                        x+=\\'Seventeen \\'\\n                    if s[len(s)-2:]==\\'18\\':\\n                        x+=\\'Eighteen \\'\\n                    if s[len(s)-2:]==\\'19\\':\\n                        x+=\\'Nineteen \\'\\n                    return x\\n                \\n                elif s[len(s)-2]==\\'2\\':\\n                    x+=\\'Twenty \\'\\n                elif s[len(s)-2]==\\'3\\':\\n                    x+=\\'Thirty \\'\\n                elif s[len(s)-2]==\\'4\\':\\n                    x+=\\'Forty \\'\\n                elif s[len(s)-2]==\\'5\\':\\n                    x+=\\'Fifty \\'\\n                elif s[len(s)-2]==\\'6\\':\\n                    x+=\\'Sixty \\'\\n                elif s[len(s)-2]==\\'7\\':\\n                    x+=\\'Seventy \\'\\n                elif s[len(s)-2]==\\'8\\':\\n                    x+=\\'Eighty \\'\\n                elif s[len(s)-2]==\\'9\\':\\n                    x+=\\'Ninety \\'\\n               \\n            if len(s[len(s)-1:])==1:\\n                if s[len(s)-1]==\\'1\\':\\n                    x+=\\'One \\'\\n                if s[len(s)-1]==\\'2\\':\\n                    x+=\\'Two \\'\\n                if s[len(s)-1]==\\'3\\':\\n                    x+=\\'Three \\'\\n                if s[len(s)-1]==\\'4\\':\\n                    x+=\\'Four \\'\\n                if s[len(s)-1]==\\'5\\':\\n                    x+=\\'Five \\'\\n                if s[len(s)-1]==\\'6\\':\\n                    x+=\\'Six \\'\\n                if s[len(s)-1]==\\'7\\':\\n                    x+=\\'Seven \\'\\n                if s[len(s)-1]==\\'8\\':\\n                    x+=\\'Eight \\'\\n                if s[len(s)-1]==\\'9\\':\\n                    x+=\\'Nine \\' \\n            return x\\n        ans=\\'\\'\\n        f=-len(bx)\\n        while f<0:\\n            if bx[f]==\\'\\' or bx[f]==\\'000\\':\\n                f+=1\\n                continue\\n            if f==-4:\\n                ans+=answer(bx[f])\\n                ans+=\\'Billion \\'\\n            elif f==-3:\\n                ans+=answer(bx[f])\\n                ans+=\\'Million \\'\\n            elif f==-2:\\n                ans+=answer(bx[f])\\n                ans+=\\'Thousand \\'\\n            elif f==-1:\\n                ans+=answer(bx[f])\\n            f+=1\\n        return(ans[:len(ans)-1])\\n        \\n```\\n\\nThank You for your Upvote",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num==0:\\n            return \\'Zero\\'\\n        num=str(num)\\n        s=len(num)%3\\n        bx=[]\\n        bx.append(num[:s])\\n        for i in range(s,len(num),3):\\n            bx.append(num[i:i+3])\\n        \\n        def answer(s):\\n            x=\\'\\'\\n            if len(s)==3:\\n                if s[0]==\\'1\\':\\n                    x+=\\'One \\'\\n                if s[0]==\\'2\\':\\n                    x+=\\'Two \\'\\n                if s[0]==\\'3\\':\\n                    x+=\\'Three \\'\\n                if s[0]==\\'4\\':\\n                    x+=\\'Four \\'\\n                if s[0]==\\'5\\':\\n                    x+=\"Five \"\\n                if s[0]==\\'6\\':\\n                    x+=\\'Six \\'\\n                if s[0]==\\'7\\':\\n                    x+=\\'Seven \\'\\n                if s[0]==\\'8\\':\\n                    x+=\\'Eight \\'\\n                if s[0]==\\'9\\':\\n                    x+=\\'Nine \\'\\n                if s[0]!=\\'0\\':\\n                    x+=\\'Hundred \\'\\n            if len(s[len(s)-2:])==2:\\n                if s[len(s)-2]==\\'1\\':\\n                    if s[len(s)-2:]==\\'10\\':\\n                        x+=\\'Ten \\'\\n                    if s[len(s)-2:]==\\'11\\':\\n                        x+=\\'Eleven \\'\\n                    if s[len(s)-2:]==\\'12\\':\\n                        x+=\\'Twelve \\'\\n                    if s[len(s)-2:]==\\'13\\':\\n                        x+=\\'Thirteen \\'\\n                    if s[len(s)-2:]==\\'14\\':\\n                        x+=\\'Fourteen \\'\\n                    if s[len(s)-2:]==\\'15\\':\\n                        x+=\\'Fifteen \\'\\n                    if s[len(s)-2:]==\\'16\\':\\n                        x+=\\'Sixteen \\'\\n                    if s[len(s)-2:]==\\'17\\':\\n                        x+=\\'Seventeen \\'\\n                    if s[len(s)-2:]==\\'18\\':\\n                        x+=\\'Eighteen \\'\\n                    if s[len(s)-2:]==\\'19\\':\\n                        x+=\\'Nineteen \\'\\n                    return x\\n                \\n                elif s[len(s)-2]==\\'2\\':\\n                    x+=\\'Twenty \\'\\n                elif s[len(s)-2]==\\'3\\':\\n                    x+=\\'Thirty \\'\\n                elif s[len(s)-2]==\\'4\\':\\n                    x+=\\'Forty \\'\\n                elif s[len(s)-2]==\\'5\\':\\n                    x+=\\'Fifty \\'\\n                elif s[len(s)-2]==\\'6\\':\\n                    x+=\\'Sixty \\'\\n                elif s[len(s)-2]==\\'7\\':\\n                    x+=\\'Seventy \\'\\n                elif s[len(s)-2]==\\'8\\':\\n                    x+=\\'Eighty \\'\\n                elif s[len(s)-2]==\\'9\\':\\n                    x+=\\'Ninety \\'\\n               \\n            if len(s[len(s)-1:])==1:\\n                if s[len(s)-1]==\\'1\\':\\n                    x+=\\'One \\'\\n                if s[len(s)-1]==\\'2\\':\\n                    x+=\\'Two \\'\\n                if s[len(s)-1]==\\'3\\':\\n                    x+=\\'Three \\'\\n                if s[len(s)-1]==\\'4\\':\\n                    x+=\\'Four \\'\\n                if s[len(s)-1]==\\'5\\':\\n                    x+=\\'Five \\'\\n                if s[len(s)-1]==\\'6\\':\\n                    x+=\\'Six \\'\\n                if s[len(s)-1]==\\'7\\':\\n                    x+=\\'Seven \\'\\n                if s[len(s)-1]==\\'8\\':\\n                    x+=\\'Eight \\'\\n                if s[len(s)-1]==\\'9\\':\\n                    x+=\\'Nine \\' \\n            return x\\n        ans=\\'\\'\\n        f=-len(bx)\\n        while f<0:\\n            if bx[f]==\\'\\' or bx[f]==\\'000\\':\\n                f+=1\\n                continue\\n            if f==-4:\\n                ans+=answer(bx[f])\\n                ans+=\\'Billion \\'\\n            elif f==-3:\\n                ans+=answer(bx[f])\\n                ans+=\\'Million \\'\\n            elif f==-2:\\n                ans+=answer(bx[f])\\n                ans+=\\'Thousand \\'\\n            elif f==-1:\\n                ans+=answer(bx[f])\\n            f+=1\\n        return(ans[:len(ans)-1])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 70681,
                "title": "the-simplest-recursive-solution-ever-yet-efficient-enough-in-c",
                "content": "    class Solution {\\n    private:\\n        const vector<string> numerals{\"Billion\", \"Million\", \"Thousand\", \"Hundred\", \"Ninety\",\"Eighty\", \"Seventy\",\"Sixty\", \"Fifty\", \"Forty\", \"Thirty\", \"Twenty\", \"Nineteen\", \"Eighteen\", \"Seventeen\", \"Sixteen\", \"Fifteen\", \"Fourteen\", \"Thirteen\", \"Twelve\",\"Eleven\", \"Ten\",\"Nine\", \"Eight\", \"Seven\", \"Six\", \"Five\", \"Four\", \"Three\",\"Two\", \"One\"};\\n        const vector<int> units = {1000000000, 1000000, 1000, 100, 90, 80, 70, 60,50, 40,30,20,19, 18, 17, 16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1};\\n    public:\\n        string numberToWords(int num) \\n        {\\n            if(num == 0) return \"Zero\";\\n            int i = 0;\\n            for(; num < units[i]; ++i) ;\\n            int upper = num/units[i];\\n            int lower = num%units[i];\\n            return (i<4? numberToWords(upper) + \" \" : \"\") + numerals[i] + (lower? \" \" + numberToWords(lower) : \"\");\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    private:\\n        const vector<string> numerals{\"Billion\", \"Million\", \"Thousand\", \"Hundred\", \"Ninety\",\"Eighty\", \"Seventy\",\"Sixty\", \"Fifty\", \"Forty\", \"Thirty\", \"Twenty\", \"Nineteen\", \"Eighteen\", \"Seventeen\", \"Sixteen\", \"Fifteen\", \"Fourteen\", \"Thirteen\", \"Twelve\",\"Eleven\", \"Ten\",\"Nine\", \"Eight\", \"Seven\", \"Six\", \"Five\", \"Four\", \"Three\",\"Two\", \"One\"}",
                "codeTag": "Java"
            },
            {
                "id": 2451300,
                "title": "c-simple-understandable-clean",
                "content": "# ***Please upvote***\\n\\n\\n```\\n    string one[19]={\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n\\n    string ten[8]={\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n    \\n    string f(int n){\\n        if(n>=1000000000) return f(n/1000000000) + \" Billion\" + f(n%1000000000);\\n        \\n        if(n>=1000000) return f(n/1000000) + \" Million\" + f(n%1000000);\\n        \\n        if(n>=1000) return f(n/1000) + \" Thousand\" + f(n%1000);\\n        \\n        if(n>=100) return f(n/100) + \" Hundred\" + f(n%100);\\n        \\n        if(n>=20) return \" \"+ten[n/10-2] +f(n%10);\\n        \\n        if(n>=1) return \" \"+one[n-1];\\n        \\n        return \"\";\\n    }\\n\\n    string numberToWords(int num) {\\n        if(num==0) return \"Zero\";\\n        return f(num).substr(1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\n    string one[19]={\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n\\n    string ten[8]={\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n    \\n    string f(int n){\\n        if(n>=1000000000) return f(n/1000000000) + \" Billion\" + f(n%1000000000);\\n        \\n        if(n>=1000000) return f(n/1000000) + \" Million\" + f(n%1000000);\\n        \\n        if(n>=1000) return f(n/1000) + \" Thousand\" + f(n%1000);\\n        \\n        if(n>=100) return f(n/100) + \" Hundred\" + f(n%100);\\n        \\n        if(n>=20) return \" \"+ten[n/10-2] +f(n%10);\\n        \\n        if(n>=1) return \" \"+one[n-1];\\n        \\n        return \"\";\\n    }\\n\\n    string numberToWords(int num) {\\n        if(num==0) return \"Zero\";\\n        return f(num).substr(1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590535,
                "title": "c-very-easy-and-concise-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<string> under20 = {\\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \\n        \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\\n    };\\n    vector<string> under100 = {\\n        \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"\\n    };\\nprivate:\\n    string helper(int num) {\\n        if (num < 20) {\\n            return under20[num];\\n        } else if (num < 100) {\\n            return under100[num / 10] + \" \" + helper(num % 10);\\n        } else if (num < 1000) {\\n            return helper(num / 100) + \" Hundred \" + helper(num % 100);\\n        } else if (num < (int)1e6) {\\n            return helper(num / 1000) + \" Thousand \" + helper(num % 1000);\\n        } else if (num < (int)1e9) {\\n            return helper(num / (int)1e6) + \" Million \" + helper(num % (int)1e6);\\n        } else {\\n            return helper(num / (int)1e9) + \" Billion \" + helper(num % (int)1e9);\\n        }\\n    }\\npublic:\\n    string numberToWords(int num) {\\n        if (num == 0)\\n            return \"Zero\";\\n        stringstream ss = (stringstream)helper(num);\\n        string data;\\n        string ans = \"\";\\n        while(getline(ss, data, \\' \\')) {\\n            if (data.size()) ans += data + \" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<string> under20 = {\\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \\n        \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\\n    };\\n    vector<string> under100 = {\\n        \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"\\n    };\\nprivate:\\n    string helper(int num) {\\n        if (num < 20) {\\n            return under20[num];\\n        } else if (num < 100) {\\n            return under100[num / 10] + \" \" + helper(num % 10);\\n        } else if (num < 1000) {\\n            return helper(num / 100) + \" Hundred \" + helper(num % 100);\\n        } else if (num < (int)1e6) {\\n            return helper(num / 1000) + \" Thousand \" + helper(num % 1000);\\n        } else if (num < (int)1e9) {\\n            return helper(num / (int)1e6) + \" Million \" + helper(num % (int)1e6);\\n        } else {\\n            return helper(num / (int)1e9) + \" Billion \" + helper(num % (int)1e9);\\n        }\\n    }\\npublic:\\n    string numberToWords(int num) {\\n        if (num == 0)\\n            return \"Zero\";\\n        stringstream ss = (stringstream)helper(num);\\n        string data;\\n        string ans = \"\";\\n        while(getline(ss, data, \\' \\')) {\\n            if (data.size()) ans += data + \" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432213,
                "title": "c-recursive-runtime-0ms-100-00-faster-integer-to-english-words",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string ones[21] = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\", \"Twenty\"};\\n    \\n    string tens[10] = {\"##\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    string pref[4] = {\"##\", \"Thousand\", \"Million\", \"Billion\"};\\n    \\n    const int billion = 1000000000;\\n    const int million = 1000000;\\n    const int thousand = 1000;\\n    \\n    string oneDigit(int num)\\n    {\\n        return (num ? ones[num] + \" \" : \"\");\\n    }\\n    \\n    string twoDigit(int num)\\n    {\\n        if(num == 0)\\n            return \"\";\\n        if(num <= 20)\\n            return ones[num] + \" \";\\n        else\\n            return tens[num/10] + \" \" + (num % 10 ? ones[num%10] + \" \" : \"\");\\n    }\\n    \\n    string threeDigit(int num)\\n    {\\n        if(num == 0)\\n            return \"\";\\n        if(num / 10 == 0)\\n            return oneDigit(num);\\n        if(num / 100 == 0)\\n            return twoDigit(num);\\n        \\n        return ones[num/100] + \" Hundred \" + twoDigit(num%100);\\n    }\\n    \\n    string convert(int num)\\n    {   \\n        if(num == 0)\\n            return \"\";\\n        if(num/billion)\\n            return threeDigit(num/billion) + \"Billion \" + convert(num%billion);\\n        if(num/million)\\n            return threeDigit(num/million) + \"Million \" + convert(num%million);\\n        if(num/thousand)\\n            return threeDigit(num/thousand) + \"Thousand \" + convert(num%thousand);\\n        return threeDigit(num);\\n    }\\n    string numberToWords(int num)\\n    {\\n        if(num == 0)\\n            return \"Zero\";\\n        string ans = convert(num);\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string ones[21] = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\", \"Twenty\"};\\n    \\n    string tens[10] = {\"##\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    string pref[4] = {\"##\", \"Thousand\", \"Million\", \"Billion\"};\\n    \\n    const int billion = 1000000000;\\n    const int million = 1000000;\\n    const int thousand = 1000;\\n    \\n    string oneDigit(int num)\\n    {\\n        return (num ? ones[num] + \" \" : \"\");\\n    }\\n    \\n    string twoDigit(int num)\\n    {\\n        if(num == 0)\\n            return \"\";\\n        if(num <= 20)\\n            return ones[num] + \" \";\\n        else\\n            return tens[num/10] + \" \" + (num % 10 ? ones[num%10] + \" \" : \"\");\\n    }\\n    \\n    string threeDigit(int num)\\n    {\\n        if(num == 0)\\n            return \"\";\\n        if(num / 10 == 0)\\n            return oneDigit(num);\\n        if(num / 100 == 0)\\n            return twoDigit(num);\\n        \\n        return ones[num/100] + \" Hundred \" + twoDigit(num%100);\\n    }\\n    \\n    string convert(int num)\\n    {   \\n        if(num == 0)\\n            return \"\";\\n        if(num/billion)\\n            return threeDigit(num/billion) + \"Billion \" + convert(num%billion);\\n        if(num/million)\\n            return threeDigit(num/million) + \"Million \" + convert(num%million);\\n        if(num/thousand)\\n            return threeDigit(num/thousand) + \"Thousand \" + convert(num%thousand);\\n        return threeDigit(num);\\n    }\\n    string numberToWords(int num)\\n    {\\n        if(num == 0)\\n            return \"Zero\";\\n        string ans = convert(num);\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320416,
                "title": "c-0ms-solution-concise-easy-to-understand",
                "content": "```\\nif(num==0)\\n\\treturn \"Zero\";\\n\\nstring s=\"\";\\nstring THOUSANDS[4] = {\"\",\"Thousand\",\"Million\",\"Billion\"};\\nstring ONES[10]= {\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"};\\nstring TENS[10]= {\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\nstring TENS1[10]={\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n\\nint i=0;\\nwhile(num!=0)\\n{\\nint ones = 0,tens=0,hunds=0;\\nstring s1=\"\";\\n\\nones = num%10; num=num/10; \\ntens = num%10; num=num/10;\\nif(tens==1)\\n\\ts1 = TENS1[ones]+\" \"+s1;\\nelse\\n{\\n\\tif(ones>0)  s1= ONES[ones]+ \" \"+s1;\\n\\tif(tens>0) s1 = TENS[tens]+\" \"+s1;\\n}            \\nhunds = num%10; num=num/10;\\nif(hunds>0) s1 = ONES[hunds]+\" Hundred\"+\" \"+s1;\\n\\nif(i>0 && s1.size()>0) \\n\\ts= s1+THOUSANDS[i]+\" \"+s;\\nelse\\n\\ts=s1+s;\\ni++;\\n}\\n\\nreturn s.substr(0,s.size()-1);\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nif(num==0)\\n\\treturn \"Zero\";\\n\\nstring s=\"\";\\nstring THOUSANDS[4] = {\"\",\"Thousand\",\"Million\",\"Billion\"};\\nstring ONES[10]= {\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"};\\nstring TENS[10]= {\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\nstring TENS1[10]={\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n\\nint i=0;\\nwhile(num!=0)\\n{\\nint ones = 0,tens=0,hunds=0;\\nstring s1=\"\";\\n\\nones = num%10; num=num/10; \\ntens = num%10; num=num/10;\\nif(tens==1)\\n\\ts1 = TENS1[ones]+\" \"+s1;\\nelse\\n{\\n\\tif(ones>0)  s1= ONES[ones]+ \" \"+s1;\\n\\tif(tens>0) s1 = TENS[tens]+\" \"+s1;\\n}            \\nhunds = num%10; num=num/10;\\nif(hunds>0) s1 = ONES[hunds]+\" Hundred\"+\" \"+s1;\\n\\nif(i>0 && s1.size()>0) \\n\\ts= s1+THOUSANDS[i]+\" \"+s;\\nelse\\n\\ts=s1+s;\\ni++;\\n}\\n\\nreturn s.substr(0,s.size()-1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256049,
                "title": "swift-solution",
                "content": "```\\n\\nclass Solution {\\n    let words0_19 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\n\\tlet wordsTens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n\\tlet thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\\n\\tfunc numberToWords(_ num: Int) -> String {\\n\\t\\t\\n\\t\\tguard num != 0 else { return \"Zero\" }\\n\\t\\t\\n\\t\\tvar num = num\\n\\t\\t\\n\\t\\tvar i = 0\\n\\t\\tvar answer = \"\"\\n\\t\\twhile num > 0 {\\n\\t\\t\\tif num % 1000 != 0 {\\n\\t\\t\\t\\tanswer = helper(num % 1000) + thousands[i] + \" \" + answer\\n\\t\\t\\t}\\n\\t\\t\\tnum /= 1000\\n\\t\\t\\ti += 1\\n\\t\\t}\\n\\t\\treturn answer.trimmingCharacters(in: .whitespaces)\\n\\t}\\n\\t\\n\\t// helper take care of cases less than 1000\\n\\tprivate func helper(_ num: Int) -> String {\\n\\t\\tif num == 0 {\\n\\t\\t\\treturn \"\"\\n\\t\\t} else if num < 20 {\\n\\t\\t\\treturn words0_19[num] + \" \"\\n\\t\\t} else if num < 100 {\\n\\t\\t\\treturn wordsTens[num/10] + \" \" + helper(num%10)\\n\\t\\t} else {\\n\\t\\t\\treturn words0_19[num/100] + \" Hundred \" + helper(num%100)\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    let words0_19 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\n\\tlet wordsTens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n\\tlet thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\\n\\tfunc numberToWords(_ num: Int) -> String {\\n\\t\\t\\n\\t\\tguard num != 0 else { return \"Zero\" }\\n\\t\\t\\n\\t\\tvar num = num\\n\\t\\t\\n\\t\\tvar i = 0\\n\\t\\tvar answer = \"\"\\n\\t\\twhile num > 0 {\\n\\t\\t\\tif num % 1000 != 0 {\\n\\t\\t\\t\\tanswer = helper(num % 1000) + thousands[i] + \" \" + answer\\n\\t\\t\\t}\\n\\t\\t\\tnum /= 1000\\n\\t\\t\\ti += 1\\n\\t\\t}\\n\\t\\treturn answer.trimmingCharacters(in: .whitespaces)\\n\\t}\\n\\t\\n\\t// helper take care of cases less than 1000\\n\\tprivate func helper(_ num: Int) -> String {\\n\\t\\tif num == 0 {\\n\\t\\t\\treturn \"\"\\n\\t\\t} else if num < 20 {\\n\\t\\t\\treturn words0_19[num] + \" \"\\n\\t\\t} else if num < 100 {\\n\\t\\t\\treturn wordsTens[num/10] + \" \" + helper(num%10)\\n\\t\\t} else {\\n\\t\\t\\treturn words0_19[num/100] + \" Hundred \" + helper(num%100)\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111644,
                "title": "clean-python-recursion-beat-97",
                "content": "```\\ndef numberToWords(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        self.tens=[\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"]\\n        self.ones=[\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"]\\n        if num==0:\\n            return \"Zero\"\\n        ret=\"\"\\n        if num/1000000000!=0:\\n            ret += self.numberToWords(num/1000000000)+\" Billion \"\\n            num%=1000000000\\n        if num/1000000!=0:\\n            ret += self.numberToWords(num/1000000)+\" Million \"\\n            num%=1000000\\n        if num/1000!=0:\\n            ret += self.numberToWords(num/1000)+\" Thousand \"\\n            num%=1000\\n        if num/100!=0:\\n            ret += self.numberToWords(num/100)+\" Hundred \"\\n            num%=100\\n        if num>=20 and num/10!=0:\\n            ret += self.tens[num/10-2]+\" \"\\n            num%=10\\n        if num!=0:\\n            ret += self.ones[num-1]\\n        return ret.strip()\\n```",
                "solutionTags": [],
                "code": "```\\ndef numberToWords(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        self.tens=[\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"]\\n        self.ones=[\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"]\\n        if num==0:\\n            return \"Zero\"\\n        ret=\"\"\\n        if num/1000000000!=0:\\n            ret += self.numberToWords(num/1000000000)+\" Billion \"\\n            num%=1000000000\\n        if num/1000000!=0:\\n            ret += self.numberToWords(num/1000000)+\" Million \"\\n            num%=1000000\\n        if num/1000!=0:\\n            ret += self.numberToWords(num/1000)+\" Thousand \"\\n            num%=1000\\n        if num/100!=0:\\n            ret += self.numberToWords(num/100)+\" Hundred \"\\n            num%=100\\n        if num>=20 and num/10!=0:\\n            ret += self.tens[num/10-2]+\" \"\\n            num%=10\\n        if num!=0:\\n            ret += self.ones[num-1]\\n        return ret.strip()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 70731,
                "title": "share-my-clean-java-solution",
                "content": "    public String numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        String[] big= {\"\", \"Thousand\", \"Million\", \"Billion\"};\\n        String[] small = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        String[] tens = {\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        String[] ones = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n        StringBuilder res = new StringBuilder();\\n        int count = 0;\\n        while (num != 0) {\\n            int cur = num % 1000;\\n            int o = cur % 10, t = (cur / 10) % 10, h = cur / 100;\\n            StringBuilder tmp = new StringBuilder();\\n            if (h != 0) tmp.append(ones[h] + \" Hundred \");\\n            if (t == 1) tmp.append(small[o] + \" \");\\n            else {\\n                if (t > 1) tmp.append(tens[t-2] + \" \");\\n                if (o > 0) tmp.append(ones[o] + \" \");\\n            }\\n            if(tmp.length() != 0) tmp.append(big[count] + \" \");\\n            res.insert(0, tmp);\\n            num /= 1000;\\n            count++;\\n        }\\n        return res.toString().trim();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        String[] big= {\"\", \"Thousand\", \"Million\", \"Billion\"};\\n        String[] small = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        String[] tens = {\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        String[] ones = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n        StringBuilder res = new StringBuilder();\\n        int count = 0;\\n        while (num != 0) {\\n            int cur = num % 1000;\\n            int o = cur % 10, t = (cur / 10) % 10, h = cur / 100;\\n            StringBuilder tmp = new StringBuilder();\\n            if (h != 0) tmp.append(ones[h] + \" Hundred \");\\n            if (t == 1) tmp.append(small[o] + \" \");\\n            else {\\n                if (t > 1) tmp.append(tens[t-2] + \" \");\\n                if (o > 0) tmp.append(ones[o] + \" \");\\n            }\\n            if(tmp.length() != 0) tmp.append(big[count] + \" \");\\n            res.insert(0, tmp);\\n            num /= 1000;\\n            count++;\\n        }\\n        return res.toString().trim();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3575674,
                "title": "python-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe code you provided seems to be a solution for converting a given number into words based on the provided mapping. It follows a recursive approach to break down the number into its components and build the corresponding word representation.\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        mapping = {\\n          1000000000: \\'Billion\\',\\n          1000000: \\'Million\\',\\n          1000: \\'Thousand\\',\\n          100: \\'Hundred\\',\\n          90: \\'Ninety\\',\\n          80: \\'Eighty\\',\\n          70: \\'Seventy\\',\\n          60: \\'Sixty\\',\\n          50: \\'Fifty\\',\\n          40: \\'Forty\\',\\n          30: \\'Thirty\\',\\n          20: \\'Twenty\\',\\n          19: \\'Nineteen\\',\\n          18: \\'Eighteen\\',\\n          17: \\'Seventeen\\',\\n          16: \\'Sixteen\\',\\n          15: \\'Fifteen\\',\\n          14: \\'Fourteen\\',\\n          13: \\'Thirteen\\',\\n          12: \\'Twelve\\',\\n          11: \\'Eleven\\',\\n          10: \\'Ten\\',\\n          9: \\'Nine\\',\\n          8: \\'Eight\\',\\n          7: \\'Seven\\',\\n          6: \\'Six\\',\\n          5: \\'Five\\',\\n          4: \\'Four\\',\\n          3: \\'Three\\',\\n          2: \\'Two\\',\\n          1: \\'One\\'\\n        }\\n        if num==0:\\n            return \"Zero\"\\n        result=\"\"\\n        \\n        for value, name in mapping.items():\\n            count=0\\n            if num>=value:\\n               count=num//value\\n               num%=value\\n               if count>1 or value>=100:\\n                   result= result+\" \"+self.numberToWords(count)+\" \"+name\\n               else:\\n                   result+=\" \"+name\\n        result=result[1:]\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        mapping = {\\n          1000000000: \\'Billion\\',\\n          1000000: \\'Million\\',\\n          1000: \\'Thousand\\',\\n          100: \\'Hundred\\',\\n          90: \\'Ninety\\',\\n          80: \\'Eighty\\',\\n          70: \\'Seventy\\',\\n          60: \\'Sixty\\',\\n          50: \\'Fifty\\',\\n          40: \\'Forty\\',\\n          30: \\'Thirty\\',\\n          20: \\'Twenty\\',\\n          19: \\'Nineteen\\',\\n          18: \\'Eighteen\\',\\n          17: \\'Seventeen\\',\\n          16: \\'Sixteen\\',\\n          15: \\'Fifteen\\',\\n          14: \\'Fourteen\\',\\n          13: \\'Thirteen\\',\\n          12: \\'Twelve\\',\\n          11: \\'Eleven\\',\\n          10: \\'Ten\\',\\n          9: \\'Nine\\',\\n          8: \\'Eight\\',\\n          7: \\'Seven\\',\\n          6: \\'Six\\',\\n          5: \\'Five\\',\\n          4: \\'Four\\',\\n          3: \\'Three\\',\\n          2: \\'Two\\',\\n          1: \\'One\\'\\n        }\\n        if num==0:\\n            return \"Zero\"\\n        result=\"\"\\n        \\n        for value, name in mapping.items():\\n            count=0\\n            if num>=value:\\n               count=num//value\\n               num%=value\\n               if count>1 or value>=100:\\n                   result= result+\" \"+self.numberToWords(count)+\" \"+name\\n               else:\\n                   result+=\" \"+name\\n        result=result[1:]\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434886,
                "title": "clean-java-soln-easy-to-understand-explanation-9ms-beats-63-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to recursively divide the number into smaller parts until it can be represented as a combination of words. For example, for a number between 0 and 9, we can simply return the corresponding word from the `ones` array. For a number between 10 and 19, we can return the corresponding word from the `special` array. For a number between 20 and 99, we can split the number into its tens and ones digit and recursively call the solve function on each part, and then concatenate the result using the `tens` and `ones` array. For larger numbers, we can similarly split them into their hundreds, thousands, millions, and billions places and call the solve function recursively on each part.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is a recursive approach. The `solve` method is called recursively on smaller parts of the input number until it can be represented as a combination of English words. The approach is based on the observation that numbers can be broken down into their ones, tens, hundreds, thousands, millions, and billions places, and each place can be represented as a combination of words. For example, the number 123,456,789 can be broken down into:\\n\\n123,456,789 = 123 billions + 456 millions + 789 thousands + 0 hundreds + 0 tens + 0 ones\\nEach part can then be represented recursively using the `solve` method. The final string can be constructed by concatenating the strings returned from each recursive call.\\n\\nThis approach is simple and easy to understand, and it results in a concise and readable code. However, it may not be the most efficient approach in terms of time and space complexity, especially for very large input numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(log n), where n is the input number. This is because the number of recursive calls made is proportional to the number of digits in the input number, which is log n.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution is also O(log n), because at most log n recursive calls are made on the call stack, each of which takes up O(1) space for the arrays and StringBuilder.\\n\\n# Code\\n```\\nclass Solution {\\n    public String numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        return solve(num);\\n        \\n    }\\n    private String solve(int num)\\n    {\\n        String ones[]= {\"\",\"One\", \"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"};\\n        String tens[]= {\"\",\"\", \"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n        String special[] ={\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n\\n        // if (num == 0) return \"Zero\";\\n        StringBuilder result = new StringBuilder();\\n        if (num < 10) result.append(ones[num]);\\n        else if (num < 20) result.append(special[num -10]);\\n        else if (num < 100) result.append(tens[num/10]+\" \"+(solve(num % 10)));\\n        else if (num < 1000) result.append(solve(num/100)+\" Hundred \"+(solve(num % 100)));\\n        else if (num < 1000000) result.append(solve(num/1000)+\" Thousand \"+(solve(num % 1000)));\\n        else if (num < 1000000000) result.append(solve(num/1000000)+\" Million \"+(solve(num % 1000000)));\\n        else result.append(solve(num/1000000000)+\" Billion \"+solve(num % 1000000000));\\n        return result.toString().trim();\\n    }\\n}\\n```\\nIf you found this helpful, please don\\'t forget to upvote!\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        return solve(num);\\n        \\n    }\\n    private String solve(int num)\\n    {\\n        String ones[]= {\"\",\"One\", \"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"};\\n        String tens[]= {\"\",\"\", \"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n        String special[] ={\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n\\n        // if (num == 0) return \"Zero\";\\n        StringBuilder result = new StringBuilder();\\n        if (num < 10) result.append(ones[num]);\\n        else if (num < 20) result.append(special[num -10]);\\n        else if (num < 100) result.append(tens[num/10]+\" \"+(solve(num % 10)));\\n        else if (num < 1000) result.append(solve(num/100)+\" Hundred \"+(solve(num % 100)));\\n        else if (num < 1000000) result.append(solve(num/1000)+\" Thousand \"+(solve(num % 1000)));\\n        else if (num < 1000000000) result.append(solve(num/1000000)+\" Million \"+(solve(num % 1000000)));\\n        else result.append(solve(num/1000000000)+\" Billion \"+solve(num % 1000000000));\\n        return result.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235199,
                "title": "273-time-86-78-and-space-94-53-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution is similar to the previous one, but it defines the word lists and scales as instance variables of the class instead of local variables inside the function. It also defines a separate convert function to handle converting each group of three digits, and uses recursion to break down numbers greater than 100 into smaller parts. Finally, it removes any trailing spaces from the resulting string using the strip() method.\\n\\n# Complexity\\n- Time complexity:\\n86.78%\\n\\n- Space complexity:\\n94.53%\\n\\n# Code\\n```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num == 0:\\n            return \\'Zero\\'\\n        \\n        # Define word lists for numbers and scales\\n        self.words1to19 = [\\'\\', \\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\', \\'Ten\\', \\'Eleven\\', \\'Twelve\\', \\'Thirteen\\', \\'Fourteen\\', \\'Fifteen\\', \\'Sixteen\\', \\'Seventeen\\', \\'Eighteen\\', \\'Nineteen\\']\\n        self.words10to90 = [\\'\\', \\'\\', \\'Twenty\\', \\'Thirty\\', \\'Forty\\', \\'Fifty\\', \\'Sixty\\', \\'Seventy\\', \\'Eighty\\', \\'Ninety\\']\\n        self.scales = [\\'\\', \\'Thousand\\', \\'Million\\', \\'Billion\\']\\n        \\n        words = \\'\\'\\n        scaleIndex = 0\\n        while num > 0:\\n            if num % 1000 != 0:\\n                words = self.convert(num % 1000) + self.scales[scaleIndex] + \\' \\' + words\\n            num //= 1000\\n            scaleIndex += 1\\n        \\n        return words.strip()\\n    \\n    def convert(self, num):\\n        if num == 0:\\n            return \\'\\'\\n        elif num < 20:\\n            return self.words1to19[num] + \\' \\'\\n        elif num < 100:\\n            return self.words10to90[num // 10] + \\' \\' + self.convert(num % 10)\\n        else:\\n            return self.words1to19[num // 100] + \\' Hundred \\' + self.convert(num % 100)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num == 0:\\n            return \\'Zero\\'\\n        \\n        # Define word lists for numbers and scales\\n        self.words1to19 = [\\'\\', \\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\', \\'Ten\\', \\'Eleven\\', \\'Twelve\\', \\'Thirteen\\', \\'Fourteen\\', \\'Fifteen\\', \\'Sixteen\\', \\'Seventeen\\', \\'Eighteen\\', \\'Nineteen\\']\\n        self.words10to90 = [\\'\\', \\'\\', \\'Twenty\\', \\'Thirty\\', \\'Forty\\', \\'Fifty\\', \\'Sixty\\', \\'Seventy\\', \\'Eighty\\', \\'Ninety\\']\\n        self.scales = [\\'\\', \\'Thousand\\', \\'Million\\', \\'Billion\\']\\n        \\n        words = \\'\\'\\n        scaleIndex = 0\\n        while num > 0:\\n            if num % 1000 != 0:\\n                words = self.convert(num % 1000) + self.scales[scaleIndex] + \\' \\' + words\\n            num //= 1000\\n            scaleIndex += 1\\n        \\n        return words.strip()\\n    \\n    def convert(self, num):\\n        if num == 0:\\n            return \\'\\'\\n        elif num < 20:\\n            return self.words1to19[num] + \\' \\'\\n        elif num < 100:\\n            return self.words10to90[num // 10] + \\' \\' + self.convert(num % 10)\\n        else:\\n            return self.words1to19[num // 100] + \\' Hundred \\' + self.convert(num % 100)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793986,
                "title": "python-use-chunks-of-3-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a division of the number into chunks of 3 digits each. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        \\n        if num == 0 : return \"Zero\"                               # [1] trivial case\\n        \\n        # here is a collection of English words with correct indices, e.g, ones[1] = \"One\"\\n        mils = [\"\", \"Thousand\", \"Million\", \"Billion\"]\\n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n        teen = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\"] + [t[0:-2] + \"teen\" for t in tens[5:]]\\n        \\n        def helper(cs: int) -> str:                               # [2] this helper function processes\\n            ss = []                                               #     independent 3-digit chunks\\n            \\n            if cs[2] != 0 : ss.append(ones[cs[2]] + \" Hundred\")   # [3] hundreds are treated separately\\n            \\n            if   cs[1] == 0 : ss.append(ones[cs[0]])              # [4] main stuff happens here,\\n            elif cs[1] == 1 : ss.append(teen[cs[0]])              #     namely, we check for \\'tens\\'\\n            else : ss.extend([tens[cs[1]], ones[cs[0]]])          #     and then decide one \\'ones\\'\\n                \\n            return \" \".join(ss).replace(\"  \", \"\").strip()\\n            \\n        digits = []                                               # [5] collect up to 12 digits\\n        for _ in range(12):\\n            num, d = divmod(num, 10)\\n            digits.append(d)\\n        \\n        s = []\\n        for m, i in zip(mils, range(0, len(digits), 3)):           # [6] split digits in chunks of 3\\n            d = digits[i:i+3]                                      #     and process them separately,\\n            if sum(d) != 0 : s.append(f\"{helper(d)} {m}\")\\n        \\n        return \" \".join(s[::-1]).strip()                           # [7] join 3-digit chunks \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        \\n        if num == 0 : return \"Zero\"                               # [1] trivial case\\n        \\n        # here is a collection of English words with correct indices, e.g, ones[1] = \"One\"\\n        mils = [\"\", \"Thousand\", \"Million\", \"Billion\"]\\n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n        teen = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\"] + [t[0:-2] + \"teen\" for t in tens[5:]]\\n        \\n        def helper(cs: int) -> str:                               # [2] this helper function processes\\n            ss = []                                               #     independent 3-digit chunks\\n            \\n            if cs[2] != 0 : ss.append(ones[cs[2]] + \" Hundred\")   # [3] hundreds are treated separately\\n            \\n            if   cs[1] == 0 : ss.append(ones[cs[0]])              # [4] main stuff happens here,\\n            elif cs[1] == 1 : ss.append(teen[cs[0]])              #     namely, we check for \\'tens\\'\\n            else : ss.extend([tens[cs[1]], ones[cs[0]]])          #     and then decide one \\'ones\\'\\n                \\n            return \" \".join(ss).replace(\"  \", \"\").strip()\\n            \\n        digits = []                                               # [5] collect up to 12 digits\\n        for _ in range(12):\\n            num, d = divmod(num, 10)\\n            digits.append(d)\\n        \\n        s = []\\n        for m, i in zip(mils, range(0, len(digits), 3)):           # [6] split digits in chunks of 3\\n            d = digits[i:i+3]                                      #     and process them separately,\\n            if sum(d) != 0 : s.append(f\"{helper(d)} {m}\")\\n        \\n        return \" \".join(s[::-1]).strip()                           # [7] join 3-digit chunks \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213496,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\n var numberToWords = function(num) {\\n    const LT20 = [\\n      \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \\n      \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\\n    ];\\n    const TENS = [\\n      \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" \\n    ];\\n    const thousands = {\\n      \"1e9\": \"Billion\",\\n      \"1e6\": \"Million\",\\n      \"1e3\": \"Thousand\",\\n    };\\n\\n    function toWords(n) {\\n      if (n === 0) return [];\\n      if (n < 20) {\\n        return [LT20[n]];\\n      }\\n      if (n < 100) {\\n        return [TENS[~~(n / 10)]].concat(toWords(n % 10));\\n      }\\n      if (n < 1000) {\\n        return [LT20[~~(n / 100)]].concat(\"Hundred\", toWords(n % 100));\\n      }\\n      for (const [base, word] of Object.entries(thousands)) {\\n        if (n / base >= 1) {\\n          return toWords(~~(n / base)).concat(word, toWords(n % base));\\n        }\\n      }\\n    }\\n\\n    return toWords(num).join(\" \") || \"Zero\"; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\n var numberToWords = function(num) {\\n    const LT20 = [\\n      \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \\n      \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\\n    ];\\n    const TENS = [\\n      \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" \\n    ];\\n    const thousands = {\\n      \"1e9\": \"Billion\",\\n      \"1e6\": \"Million\",\\n      \"1e3\": \"Thousand\",\\n    };\\n\\n    function toWords(n) {\\n      if (n === 0) return [];\\n      if (n < 20) {\\n        return [LT20[n]];\\n      }\\n      if (n < 100) {\\n        return [TENS[~~(n / 10)]].concat(toWords(n % 10));\\n      }\\n      if (n < 1000) {\\n        return [LT20[~~(n / 100)]].concat(\"Hundred\", toWords(n % 100));\\n      }\\n      for (const [base, word] of Object.entries(thousands)) {\\n        if (n / base >= 1) {\\n          return toWords(~~(n / base)).concat(word, toWords(n % base));\\n        }\\n      }\\n    }\\n\\n    return toWords(num).join(\" \") || \"Zero\"; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1019257,
                "title": "c-uff-lot-of-mapping",
                "content": "```\\nclass Solution {\\npublic:\\n    int Hun=100,Thous=1000,Mil=1000000,Bil=1000000000;\\n    string ans=\"\";\\n    unordered_map<int,string>ones;\\n    unordered_map<int,string>tens;\\n    unordered_map<int,string>spl;  //special:11 to 20\\n    unordered_map<int,string>big;\\n    void init(){\\n        ones[0]=\"\",ones[1]=\"One\",ones[2]=\"Two\",ones[3]=\"Three\";\\n        ones[4]=\"Four\",ones[5]=\"Five\",ones[6]=\"Six\",ones[7]=\"Seven\",ones[8]=\"Eight\";\\n        ones[9]=\"Nine\";\\n        \\n        tens[0]=\"\",tens[1]=\"\",tens[2]=\"Twenty\",tens[3]=\"Thirty\";\\n        tens[4]=\"Forty\",tens[5]=\"Fifty\",tens[6]=\"Sixty\",tens[7]=\"Seventy\";\\n        tens[8]=\"Eighty\",tens[9]=\"Ninety\";\\n        \\n        spl[10]=\"Ten\",spl[11]=\"Eleven\",spl[12]=\"Twelve\",spl[13]=\"Thirteen\";\\n        spl[14]=\"Fourteen\",spl[15]=\"Fifteen\",spl[16]=\"Sixteen\",spl[17]=\"Seventeen\",spl[18]=\"Eighteen\";\\n        spl[19]=\"Nineteen\";\\n        \\n        big[Hun]=\"Hundred\",big[Thous]=\"Thousand\",big[Mil]=\"Million\",big[Bil]=\"Billion\";\\n        \\n    }\\n    string three_d(int n){\\n        string temp=\"\";\\n        if(n>=100){\\n            temp+=ones[n/100]+\" \"+big[Hun]+\" \";\\n            n=n%100;\\n        }\\n        if(n>=20){\\n            temp+=tens[n/10]+\" \";    \\n        }else if(n>=10){\\n            temp+=spl[n];\\n            return temp;\\n        }\\n        temp+=ones[n%10];\\n        while(temp.back()==\\' \\')temp.pop_back();\\n        return temp;\\n    }\\n    string numberToWords(int num) {\\n        if(num==0)return \"Zero\";\\n        init();\\n        for(int check : {Bil,Mil,Thous}){\\n            if(num>=check){\\n                ans += three_d(num/check)+\" \"+big[check]+\" \";\\n                num=num%check; \\n            }\\n        }\\n        if(num<1000)ans+=three_d(num);\\n        while(ans.back()==\\' \\')ans.pop_back();\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Hun=100,Thous=1000,Mil=1000000,Bil=1000000000;\\n    string ans=\"\";\\n    unordered_map<int,string>ones;\\n    unordered_map<int,string>tens;\\n    unordered_map<int,string>spl;  //special:11 to 20\\n    unordered_map<int,string>big;\\n    void init(){\\n        ones[0]=\"\",ones[1]=\"One\",ones[2]=\"Two\",ones[3]=\"Three\";\\n        ones[4]=\"Four\",ones[5]=\"Five\",ones[6]=\"Six\",ones[7]=\"Seven\",ones[8]=\"Eight\";\\n        ones[9]=\"Nine\";\\n        \\n        tens[0]=\"\",tens[1]=\"\",tens[2]=\"Twenty\",tens[3]=\"Thirty\";\\n        tens[4]=\"Forty\",tens[5]=\"Fifty\",tens[6]=\"Sixty\",tens[7]=\"Seventy\";\\n        tens[8]=\"Eighty\",tens[9]=\"Ninety\";\\n        \\n        spl[10]=\"Ten\",spl[11]=\"Eleven\",spl[12]=\"Twelve\",spl[13]=\"Thirteen\";\\n        spl[14]=\"Fourteen\",spl[15]=\"Fifteen\",spl[16]=\"Sixteen\",spl[17]=\"Seventeen\",spl[18]=\"Eighteen\";\\n        spl[19]=\"Nineteen\";\\n        \\n        big[Hun]=\"Hundred\",big[Thous]=\"Thousand\",big[Mil]=\"Million\",big[Bil]=\"Billion\";\\n        \\n    }\\n    string three_d(int n){\\n        string temp=\"\";\\n        if(n>=100){\\n            temp+=ones[n/100]+\" \"+big[Hun]+\" \";\\n            n=n%100;\\n        }\\n        if(n>=20){\\n            temp+=tens[n/10]+\" \";    \\n        }else if(n>=10){\\n            temp+=spl[n];\\n            return temp;\\n        }\\n        temp+=ones[n%10];\\n        while(temp.back()==\\' \\')temp.pop_back();\\n        return temp;\\n    }\\n    string numberToWords(int num) {\\n        if(num==0)return \"Zero\";\\n        init();\\n        for(int check : {Bil,Mil,Thous}){\\n            if(num>=check){\\n                ans += three_d(num/check)+\" \"+big[check]+\" \";\\n                num=num%check; \\n            }\\n        }\\n        if(num<1000)ans+=three_d(num);\\n        while(ans.back()==\\' \\')ans.pop_back();\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717955,
                "title": "most-concise-clean-easy-python-solution-99",
                "content": "\\tclass Solution:\\n\\t    def __init__(self):\\n\\t        self.n2w = {\\n\\t               1e9: \"Billion\", 1e6: \"Million\", 1e3: \"Thousand\", 1e2: \"Hundred\",\\n\\t               90:  \"Ninety\", 80:  \"Eighty\", 70:  \"Seventy\",\\n\\t               60:  \"Sixty\", 50:  \"Fifty\", 40:  \"Forty\",\\n\\t               30:  \"Thirty\", 20:  \"Twenty\", 19: \"Nineteen\",\\n\\t               18:  \"Eighteen\", 17: \"Seventeen\", 16: \"Sixteen\",\\n\\t               15:  \"Fifteen\", 14: \"Fourteen\", 13: \"Thirteen\",\\n\\t               12:  \"Twelve\", 11:  \"Eleven\", 10:  \"Ten\",\\n\\t               9:   \"Nine\", 8:   \"Eight\", 7:   \"Seven\",\\n\\t               6:   \"Six\", 5:   \"Five\", 4: \"Four\", 3: \"Three\",\\n\\t               2: \"Two\", 1: \"One\", 0: \"Zero\"\\n\\t        }\\n\\n\\t    def numberToWords(self, n: int) -> str:\\n\\t        if n <= 20: return self.n2w[n]\\n\\t        for div in self.n2w:\\n\\t            d, r = divmod(n, div)\\n\\t            if not d: continue\\n\\t            s1 = self.numberToWords(d) + \" \" if div >= 100 else \"\"\\n\\t            s2 = \" \" + self.numberToWords(r) if r else \"\"\\n\\t            return s1 + self.n2w[div] + s2",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n\\t    def __init__(self):\\n\\t        self.n2w = {\\n\\t               1e9: \"Billion\", 1e6: \"Million\", 1e3: \"Thousand\", 1e2: \"Hundred\",\\n\\t               90:  \"Ninety\", 80:  \"Eighty\", 70:  \"Seventy\",\\n\\t               60:  \"Sixty\", 50:  \"Fifty\", 40:  \"Forty\",\\n\\t               30:  \"Thirty\", 20:  \"Twenty\", 19: \"Nineteen\",\\n\\t               18:  \"Eighteen\", 17: \"Seventeen\", 16: \"Sixteen\",\\n\\t               15:  \"Fifteen\", 14: \"Fourteen\", 13: \"Thirteen\",\\n\\t               12:  \"Twelve\", 11:  \"Eleven\", 10:  \"Ten\",\\n\\t               9:   \"Nine\", 8:   \"Eight\", 7:   \"Seven\",\\n\\t               6:   \"Six\", 5:   \"Five\", 4: \"Four\", 3: \"Three\",\\n\\t               2: \"Two\", 1: \"One\", 0: \"Zero\"\\n\\t        }",
                "codeTag": "Java"
            },
            {
                "id": 690958,
                "title": "1-ms-java-solution-100",
                "content": "```\\nclass Solution {\\n    private static final String[] LESS_THAN_TWENTY = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \\n                                                      \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \\n                                                      \"Fourteen\", \"Fifteen\",  \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private static final String[] TEN_MULTIPLES = { \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \\n                                                  \"Eighty\", \"Ninety\"};\\n    \\n    public String numberToWords(int num) {\\n        if (num==0) {\\n            return \"Zero\";\\n        }\\n        \\n        return numberToWordsHelper(num).toString().trim();\\n    }\\n    \\n    public String numberToWordsHelper(int num) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        if(num >= 1000000000) {\\n            res.append(numberToWordsHelper(num/1000000000)).append(\" Billion \").append(numberToWordsHelper(num%1000000000));\\n        } else if(num >= 1000000) {\\n            res.append(numberToWordsHelper(num/1000000)).append(\" Million \").append(numberToWordsHelper(num%1000000));\\n        } else if(num >= 1000) {\\n            res.append(numberToWordsHelper(num/1000)).append(\" Thousand \").append(numberToWordsHelper(num%1000));\\n        } else if(num >= 100) {\\n            res.append(numberToWordsHelper(num/100)).append(\" Hundred \").append(numberToWordsHelper(num%100));\\n        } else if(num >= 20) {\\n            res.append(TEN_MULTIPLES[(num-20)/10]).append(\" \").append(numberToWordsHelper(num%10));\\n        } else {\\n            res.append(LESS_THAN_TWENTY[num]);\\n        } \\n        \\n        return res.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final String[] LESS_THAN_TWENTY = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \\n                                                      \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \\n                                                      \"Fourteen\", \"Fifteen\",  \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private static final String[] TEN_MULTIPLES = { \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \\n                                                  \"Eighty\", \"Ninety\"};\\n    \\n    public String numberToWords(int num) {\\n        if (num==0) {\\n            return \"Zero\";\\n        }\\n        \\n        return numberToWordsHelper(num).toString().trim();\\n    }\\n    \\n    public String numberToWordsHelper(int num) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        if(num >= 1000000000) {\\n            res.append(numberToWordsHelper(num/1000000000)).append(\" Billion \").append(numberToWordsHelper(num%1000000000));\\n        } else if(num >= 1000000) {\\n            res.append(numberToWordsHelper(num/1000000)).append(\" Million \").append(numberToWordsHelper(num%1000000));\\n        } else if(num >= 1000) {\\n            res.append(numberToWordsHelper(num/1000)).append(\" Thousand \").append(numberToWordsHelper(num%1000));\\n        } else if(num >= 100) {\\n            res.append(numberToWordsHelper(num/100)).append(\" Hundred \").append(numberToWordsHelper(num%100));\\n        } else if(num >= 20) {\\n            res.append(TEN_MULTIPLES[(num-20)/10]).append(\" \").append(numberToWordsHelper(num%10));\\n        } else {\\n            res.append(LESS_THAN_TWENTY[num]);\\n        } \\n        \\n        return res.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 215947,
                "title": "facebook-follow-up-question-and-solution",
                "content": "Without reversing the string, print it in reverse order.\\n\\nfor example: \\n\\t\\t**s :** \"321\"\\n\\t\\t**Output:** \"One Hundred Twenty Three\"\\n\\t\\t\\n```\\nclass Solution {\\n     \\n    private final String[] belowTen = new String[] {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n    private final String[] belowTwenty = new String[] {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private final String[] belowHundred = new String[] {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    public String numberToWords(int num) {\\n        if(num == 0) {\\n            return \"Zero\";\\n        }\\n        return helper(num);\\n    }\\n    public String helper(int num) {\\n        String result = \"\";\\n        int length = (num+\"\").length();\\n        if(num < 10) {\\n            return belowTen[num];\\n        }\\n        else if(length < 3) {\\n            int d1 = num/10 , d2 = num%10;\\n            if(d2 == 1) {\\n            \\treturn belowTwenty[d2];\\n            }\\n            else {\\n                result = belowHundred[d2] + \" \" + belowTen[d1];\\n            }\\n        }\\n        else if(length == 3) {\\n        \\t\\tresult = helper(num%10) + \" Hundred \" + helper(num/10);\\n        }\\n        else if(length == 4) {\\n        \\t\\tresult = belowTen[num%10] + \" Thousand \" + helper(num/10);\\n        }\\n        else if(length == 5) {\\n        \\t\\tresult = helper(num%100) + \" Thousand \" + helper(num/100); \\n        }\\n        else if(length == 6) {\\n        \\t\\tresult = helper(num%1000) + \" Thousand \" + helper(num/1000); \\n        }\\n        else if(length == 7) {\\n        \\t\\tresult = belowTen[num%10] + \" Million \" + helper(num/10);\\n        }\\n        else if(length == 8) {\\n        \\t\\tresult = helper(num%100) + \" Million \" + helper(num/100); \\n        }\\n        else if(length == 9) {\\n    \\t\\t\\tresult = helper(num%1000) + \" Million \" + helper(num/1000); \\n        }\\n        else if(length == 10) {\\n    \\t\\t\\tresult = belowTen[num%10] + \" Billion \" + helper(num/10);\\n        }\\n        else if(length == 11) {\\n    \\t\\t\\tresult = helper(num%100) + \" Billion \" + helper(num/100); \\n        }\\n        else if(length == 12) {\\n\\t\\t\\t    result = helper(num%1000) + \" Billion \" + helper(num/1000); \\n        }\\n        return result.trim();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     \\n    private final String[] belowTen = new String[] {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n    private final String[] belowTwenty = new String[] {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private final String[] belowHundred = new String[] {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    public String numberToWords(int num) {\\n        if(num == 0) {\\n            return \"Zero\";\\n        }\\n        return helper(num);\\n    }\\n    public String helper(int num) {\\n        String result = \"\";\\n        int length = (num+\"\").length();\\n        if(num < 10) {\\n            return belowTen[num];\\n        }\\n        else if(length < 3) {\\n            int d1 = num/10 , d2 = num%10;\\n            if(d2 == 1) {\\n            \\treturn belowTwenty[d2];\\n            }\\n            else {\\n                result = belowHundred[d2] + \" \" + belowTen[d1];\\n            }\\n        }\\n        else if(length == 3) {\\n        \\t\\tresult = helper(num%10) + \" Hundred \" + helper(num/10);\\n        }\\n        else if(length == 4) {\\n        \\t\\tresult = belowTen[num%10] + \" Thousand \" + helper(num/10);\\n        }\\n        else if(length == 5) {\\n        \\t\\tresult = helper(num%100) + \" Thousand \" + helper(num/100); \\n        }\\n        else if(length == 6) {\\n        \\t\\tresult = helper(num%1000) + \" Thousand \" + helper(num/1000); \\n        }\\n        else if(length == 7) {\\n        \\t\\tresult = belowTen[num%10] + \" Million \" + helper(num/10);\\n        }\\n        else if(length == 8) {\\n        \\t\\tresult = helper(num%100) + \" Million \" + helper(num/100); \\n        }\\n        else if(length == 9) {\\n    \\t\\t\\tresult = helper(num%1000) + \" Million \" + helper(num/1000); \\n        }\\n        else if(length == 10) {\\n    \\t\\t\\tresult = belowTen[num%10] + \" Billion \" + helper(num/10);\\n        }\\n        else if(length == 11) {\\n    \\t\\t\\tresult = helper(num%100) + \" Billion \" + helper(num/100); \\n        }\\n        else if(length == 12) {\\n\\t\\t\\t    result = helper(num%1000) + \" Billion \" + helper(num/1000); \\n        }\\n        return result.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70732,
                "title": "share-my-java-recursive-solution",
                "content": "    public class Solution {\\n      String[] lows = \"Zero One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen\".split(\" \");\\n      String[] tens = \"Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety\".split(\" \");\\n      String[] bigs = \"Hundred Thousand Million Billion\".split(\" \");\\n    \\n      public String convert(int n) {\\n        if (n < 20) \\n          return lows[n];\\n        \\n        if (n < 100)\\n          return tens[n / 10 - 2] + helper(n % 10);\\n        \\n        if (n < 1000) \\n          return lows[n / 100] + \" \" + bigs[0] + helper(n % 100);\\n        \\n        int m = 1000;\\n        \\n        for (int i = 1; i < bigs.length; i++, m *= 1000)\\n          if (n / 1000 < m)\\n            return convert(n / m) + \" \" + bigs[i] + helper(n % m);\\n        \\n        return convert(n / m) + \" \" + bigs[bigs.length - 1] + helper(n % m);\\n      }\\n      \\n      public String helper(int n) {\\n        return n == 0 ? \"\" : \" \" + convert(n);\\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      String[] lows = \"Zero One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen\".split(\" \");\\n      String[] tens = \"Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety\".split(\" \");\\n      String[] bigs = \"Hundred Thousand Million Billion\".split(\" \");\\n    \\n      public String convert(int n) {\\n        if (n < 20) \\n          return lows[n];\\n        \\n        if (n < 100)\\n          return tens[n / 10 - 2] + helper(n % 10);\\n        \\n        if (n < 1000) \\n          return lows[n / 100] + \" \" + bigs[0] + helper(n % 100);\\n        \\n        int m = 1000;\\n        \\n        for (int i = 1; i < bigs.length; i++, m *= 1000)\\n          if (n / 1000 < m)\\n            return convert(n / m) + \" \" + bigs[i] + helper(n % m);\\n        \\n        return convert(n / m) + \" \" + bigs[bigs.length - 1] + helper(n % m);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 70761,
                "title": "if-you-know-how-to-read-numbers-you-can-make-it",
                "content": "How to read large numbers\\n\\nNumbers are separated into groups: ones, tens, hundreds, thousands, millions, and so on. Each group contains three subgroups: ones, tens, and hundreds. When writing or reading a large number, begin at the left with the largest group, and proceed to the right. For instance, 7,482 is read as seven thousand, four hundred, eighty-two. The following chart can help in reading large numbers.\\n\\n![enter image description here][1] \\n[How to Read Large Numbers ][2]\\n\\n       class Solution {\\n    public:\\n        string numberToWords(int num) {\\n            if(!num)return \"Zero\";\\n            string ones[20]={\"Zero\",\"One\", \"Two\", \"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n            string tens[10]={\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n            string m[5]={\"Hundred\", \"Thousand\", \"Million\",\"Billion\",\"Trillion\"};\\n            string s = \"\";\\n            int i=0;\\n            while(num){\\n            int t1000 = num%1000;\\n            string res=\"\";\\n            if(t1000){\\n                    int t10=t1000%100;\\n                    if(t10){\\n                        if(t10<20)\\n                            res=ones[t10]+(res.empty()?\"\":\" \")+res;\\n                        else {\\n                            int t1=t10%10;\\n                            if(t1){\\n                                res = ones[t1]+(res.empty()?\"\":\" \")+res;\\n                            }\\n                            res=tens[t10/10]+(res.empty()?\"\":\" \")+res;\\n                        }\\n                    }\\n                    int t100=t1000/100;\\n                    if(t100){\\n                        res=ones[t100]+\" Hundred\"+(res.empty()?\"\":\" \")+res;\\n                    }\\n            if(i>0)\\n                res=res+\" \"+m[i];\\n            }\\n            i++;\\n            if(!res.empty())\\n                s=res+(s.empty()?\"\":\" \")+s;\\n            num/=1000;\\n            }\\n            return s;\\n        }\\n    };\\n\\n\\n  [1]: http://training.nwcg.gov/courses/ffm/images/stories/ch1/b_02.gif\\n  [2]: http://training.nwcg.gov/courses/ffm/index.php?option=com_content&view=article&id=114&Itemid=142",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string numberToWords(int num) {\\n            if(!num)return \"Zero\";\\n            string ones[20]={\"Zero\",\"One\", \"Two\", \"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"}",
                "codeTag": "Java"
            },
            {
                "id": 3442174,
                "title": "my-soll",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n        class Solution {\\npublic:\\nstring ones[20]={\"\", \"One \",  \"Two \", \"Three \", \"Four \", \"Five \", \"Six \", \"Seven \", \"Eight \",\\n                   \"Nine \", \"Ten \", \"Eleven \", \"Twelve \", \"Thirteen \", \"Fourteen \", \"Fifteen \",\\n                   \"Sixteen \",\"Seventeen \",\"Eighteen \",\"Nineteen \"};\\n string tens[10]={\"\",  \"\", \"Twenty \",\"Thirty \",\"Forty \",\"Fifty \",\"Sixty \",\\n                   \"Seventy \",\"Eighty \",\"Ninety \"};\\nstring hundred[10]={\"\", \"One Hundred \",  \"Two Hundred \", \"Three Hundred \", \"Four Hundred \", \"Five Hundred \", \"Six Hundred \", \"Seven Hundred \", \"Eight Hundred \",\\n                   \"Nine Hundred \"};\\nstring convertToWords(int n,string s)\\n{\\n  string str=\"\";\\n  if((n>100)&&((n%100)<=19))\\n  str+=hundred[n/100]+ones[(n%100)];\\n  else if((n>100)&&((n%100)>19))\\n  str+=hundred[n/100]+tens[(n%100)/10]+ones[(n%100)%10];\\n  else if(n%100==0)\\n  str+=hundred[n/100];\\n  else if(n<100&&(n>19))\\n  str+=tens[n/10]+ones[n%10];\\n  else if(n<=19)\\n  str+=ones[n];\\n  if(n)\\n  str+=s;\\n  return str;\\n}\\n             \\n    string numberToWords(int num) {\\n        string out;\\n        if(num==0)\\n        return \"Zero\";\\n        out+=convertToWords((num/1000000000),\"Billion \");\\n        out+=convertToWords(((num/1000000)%1000),\"Million \");\\n        out+=convertToWords(((num/1000)%1000),\"Thousand \");\\n        out+=convertToWords((num%1000),\"\");\\n        return out.substr(0,out.length()-1);\\n    }\\n};\\n        \\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n        class Solution {\\npublic:\\nstring ones[20]={\"\", \"One \",  \"Two \", \"Three \", \"Four \", \"Five \", \"Six \", \"Seven \", \"Eight \",\\n                   \"Nine \", \"Ten \", \"Eleven \", \"Twelve \", \"Thirteen \", \"Fourteen \", \"Fifteen \",\\n                   \"Sixteen \",\"Seventeen \",\"Eighteen \",\"Nineteen \"};\\n string tens[10]={\"\",  \"\", \"Twenty \",\"Thirty \",\"Forty \",\"Fifty \",\"Sixty \",\\n                   \"Seventy \",\"Eighty \",\"Ninety \"};\\nstring hundred[10]={\"\", \"One Hundred \",  \"Two Hundred \", \"Three Hundred \", \"Four Hundred \", \"Five Hundred \", \"Six Hundred \", \"Seven Hundred \", \"Eight Hundred \",\\n                   \"Nine Hundred \"};\\nstring convertToWords(int n,string s)\\n{\\n  string str=\"\";\\n  if((n>100)&&((n%100)<=19))\\n  str+=hundred[n/100]+ones[(n%100)];\\n  else if((n>100)&&((n%100)>19))\\n  str+=hundred[n/100]+tens[(n%100)/10]+ones[(n%100)%10];\\n  else if(n%100==0)\\n  str+=hundred[n/100];\\n  else if(n<100&&(n>19))\\n  str+=tens[n/10]+ones[n%10];\\n  else if(n<=19)\\n  str+=ones[n];\\n  if(n)\\n  str+=s;\\n  return str;\\n}\\n             \\n    string numberToWords(int num) {\\n        string out;\\n        if(num==0)\\n        return \"Zero\";\\n        out+=convertToWords((num/1000000000),\"Billion \");\\n        out+=convertToWords(((num/1000000)%1000),\"Million \");\\n        out+=convertToWords(((num/1000)%1000),\"Thousand \");\\n        out+=convertToWords((num%1000),\"\");\\n        return out.substr(0,out.length()-1);\\n    }\\n};\\n        \\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721641,
                "title": "simple-easy-to-understand-java-solution-using-backtracking",
                "content": "```\\nclass Solution {\\n    String[] ones = {\"\" , \"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n        \\n    String[] tens = {\"\",\"Ten\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n        \\n    int billion = 1000000000;\\n    int million = 1000000;\\n    int thousand = 1000;\\n    int hundred = 100;\\n    \\n    public String numberToWords(int n)\\n    {\\n        if(n == 0)\\n            return \"Zero\";\\n        \\n        return backtrack(n).trim();\\n    }\\n    \\n    private String backtrack(int n)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(n >= billion)\\n            sb.append(backtrack(n/billion)).append(\" Billion \").append(backtrack(n%billion));\\n        else if(n >= million)\\n            sb.append(backtrack(n/million)).append(\" Million \").append(backtrack(n%million));\\n        else if(n >= thousand)\\n            sb.append(backtrack(n/thousand)).append(\" Thousand \").append(backtrack(n%thousand));\\n        else if(n >= hundred)\\n            sb.append(backtrack(n/hundred)).append(\" Hundred \").append(backtrack(n%hundred));\\n        else if(n >= 20)\\n            sb.append(tens[n/10]).append(\" \").append(backtrack(n%10));\\n        else\\n            sb.append(ones[n]);\\n        \\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    String[] ones = {\"\" , \"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n        \\n    String[] tens = {\"\",\"Ten\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n        \\n    int billion = 1000000000;\\n    int million = 1000000;\\n    int thousand = 1000;\\n    int hundred = 100;\\n    \\n    public String numberToWords(int n)\\n    {\\n        if(n == 0)\\n            return \"Zero\";\\n        \\n        return backtrack(n).trim();\\n    }\\n    \\n    private String backtrack(int n)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(n >= billion)\\n            sb.append(backtrack(n/billion)).append(\" Billion \").append(backtrack(n%billion));\\n        else if(n >= million)\\n            sb.append(backtrack(n/million)).append(\" Million \").append(backtrack(n%million));\\n        else if(n >= thousand)\\n            sb.append(backtrack(n/thousand)).append(\" Thousand \").append(backtrack(n%thousand));\\n        else if(n >= hundred)\\n            sb.append(backtrack(n/hundred)).append(\" Hundred \").append(backtrack(n%hundred));\\n        else if(n >= 20)\\n            sb.append(tens[n/10]).append(\" \").append(backtrack(n%10));\\n        else\\n            sb.append(ones[n]);\\n        \\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395168,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    unordered_map<int,string>tens={\\n        {10,\"Ten\"},{20,\"Twenty\"},{30,\"Thirty\"},{40,\"Forty\"},\\n        {50,\"Fifty\"},{60,\"Sixty\"},{70,\"Seventy\"},{80,\"Eighty\"},{90,\"Ninety\"}\\n    };\\n    \\n    unordered_map<int,string>powers{\\n        {3,\"Hundred\"},{4,\"Thousand\"},{7,\"Million\"},{10,\"Billion\"} \\n    };\\n    \\n    vector<string>v1={\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\\n                     \"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\\n                     \"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\",\"Twenty\"};\\n    \\n   \\n    string numberToWords(int num) {\\n        if(num==0)\\n            return \"Zero\";\\n        \\n        stack<string>s;\\n        int i=1;\\n        while(num>0)\\n        {\\n            int x=num%10;\\n            if(x==0)\\n            {\\n                if(i==7)\\n                {\\n                    if(s.top()==powers[4])\\n                        s.pop();\\n                    s.push(powers[i]);\\n                }\\n                   \\n                if(i==4)\\n                    s.push(powers[i]);\\n            }\\n            if(x!=0)\\n            {\\n                if(i==1 || i==3 || i==4 || i==7 || i==10)\\n                {\\n                    if(i==10 && s.top()==\"Million\")\\n                        s.pop();\\n                    \\n                    if(i==7 && s.top()==\"Thousand\")\\n                        s.pop();\\n                        \\n                    \\n                    if(i!=1)\\n                        s.push(powers[i]);\\n                    \\n                    if((i==1 || i==4 || i==7) && (num/10) !=0)\\n                    {\\n                        int k=num/10;\\n                        int pre=k%10;\\n                        if(pre==1)\\n                        {\\n                            pre= pre*10 + x;\\n                            s.push(v1[pre]);\\n                            num/=10;\\n                            i+=1;\\n                        }\\n                        else\\n                            s.push(v1[x]);\\n                    }\\n                    else\\n                        s.push(v1[x]);\\n                    \\n                    \\n                }\\n                else if(i==6 || i==9)\\n                {\\n                    s.push(powers[3]);\\n                    s.push(v1[x]);\\n                }\\n                else if(i==2 || i==5 || i==8)\\n                {\\n                    \\n                    s.push(tens[x*10]);\\n                }\\n                \\n            }\\n            num/=10;\\n            i+=1;\\n        }\\n        \\n        string ans=\"\";\\n        while(!s.empty())\\n        {\\n            ans+=s.top();\\n            ans+=\" \";\\n            s.pop();\\n        }\\n        \\n        ans.pop_back();\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    unordered_map<int,string>tens={\\n        {10,\"Ten\"},{20,\"Twenty\"},{30,\"Thirty\"},{40,\"Forty\"},\\n        {50,\"Fifty\"},{60,\"Sixty\"},{70,\"Seventy\"},{80,\"Eighty\"},{90,\"Ninety\"}\\n    };\\n    \\n    unordered_map<int,string>powers{\\n        {3,\"Hundred\"},{4,\"Thousand\"},{7,\"Million\"},{10,\"Billion\"} \\n    };\\n    \\n    vector<string>v1={\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\\n                     \"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\\n                     \"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\",\"Twenty\"};\\n    \\n   \\n    string numberToWords(int num) {\\n        if(num==0)\\n            return \"Zero\";\\n        \\n        stack<string>s;\\n        int i=1;\\n        while(num>0)\\n        {\\n            int x=num%10;\\n            if(x==0)\\n            {\\n                if(i==7)\\n                {\\n                    if(s.top()==powers[4])\\n                        s.pop();\\n                    s.push(powers[i]);\\n                }\\n                   \\n                if(i==4)\\n                    s.push(powers[i]);\\n            }\\n            if(x!=0)\\n            {\\n                if(i==1 || i==3 || i==4 || i==7 || i==10)\\n                {\\n                    if(i==10 && s.top()==\"Million\")\\n                        s.pop();\\n                    \\n                    if(i==7 && s.top()==\"Thousand\")\\n                        s.pop();\\n                        \\n                    \\n                    if(i!=1)\\n                        s.push(powers[i]);\\n                    \\n                    if((i==1 || i==4 || i==7) && (num/10) !=0)\\n                    {\\n                        int k=num/10;\\n                        int pre=k%10;\\n                        if(pre==1)\\n                        {\\n                            pre= pre*10 + x;\\n                            s.push(v1[pre]);\\n                            num/=10;\\n                            i+=1;\\n                        }\\n                        else\\n                            s.push(v1[x]);\\n                    }\\n                    else\\n                        s.push(v1[x]);\\n                    \\n                    \\n                }\\n                else if(i==6 || i==9)\\n                {\\n                    s.push(powers[3]);\\n                    s.push(v1[x]);\\n                }\\n                else if(i==2 || i==5 || i==8)\\n                {\\n                    \\n                    s.push(tens[x*10]);\\n                }\\n                \\n            }\\n            num/=10;\\n            i+=1;\\n        }\\n        \\n        string ans=\"\";\\n        while(!s.empty())\\n        {\\n            ans+=s.top();\\n            ans+=\" \";\\n            s.pop();\\n        }\\n        \\n        ans.pop_back();\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314838,
                "title": "very-simple-and-easy-to-understand-c-solution-no-recursion",
                "content": "<b>Up Vote if you like the solution \\n```\\nclass Solution {\\npublic:\\n    //Write funtion for 3 digit number first and then add billion, million & thousand to it.\\n    string digitsToWord[10]  = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n    string tensToWord[10] = {\"\", \"teen\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\",\"Ninety\"};\\n    string wordFor10to19[10] = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    string billMillThou[4] = {\"Billion\", \"Million\", \"Thousand\", \"\"};\\n    string convertThreeDigitsToWord(int num){\\n        int hun = num/100, tens = (num%100)/10, unit = num%10};\\n        string s = \"\";\\n        if(hun != 0) s += digitsToWord[hun] + \" Hundred\";\\n        if(tens == 1){\\n            if(s!= \"\") s+= \" \";\\n            s += wordFor10to19[unit];\\n        }else{\\n            if(tens != 0) {\\n                if(s!= \"\") s+= \" \";\\n                s += tensToWord[tens];\\n            }\\n            if(unit != 0){\\n                if(s!= \"\") s+= \" \";\\n                s += digitsToWord[unit]; \\n            } \\n        }\\n        return s;\\n    }\\n    \\n    string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        string ans = \"\";\\n        int billion = 1e9, million = 1e6, thousand = 1e3;\\n        int numArr[4] = { num/billion, (num % billion)/million, (num % million)/thousand, num % thousand };\\n        \\n        for(int i = 0; i < 4; ++i){\\n            if(numArr[i] != 0) {\\n                if(ans != \"\") ans += \" \";\\n                ans += convertThreeDigitsToWord(numArr[i]) + billMillThou[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Write funtion for 3 digit number first and then add billion, million & thousand to it.\\n    string digitsToWord[10]  = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n    string tensToWord[10] = {\"\", \"teen\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\",\"Ninety\"};\\n    string wordFor10to19[10] = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    string billMillThou[4] = {\"Billion\", \"Million\", \"Thousand\", \"\"};\\n    string convertThreeDigitsToWord(int num){\\n        int hun = num/100, tens = (num%100)/10, unit = num%10};\\n        string s = \"\";\\n        if(hun != 0) s += digitsToWord[hun] + \" Hundred\";\\n        if(tens == 1){\\n            if(s!= \"\") s+= \" \";\\n            s += wordFor10to19[unit];\\n        }else{\\n            if(tens != 0) {\\n                if(s!= \"\") s+= \" \";\\n                s += tensToWord[tens];\\n            }\\n            if(unit != 0){\\n                if(s!= \"\") s+= \" \";\\n                s += digitsToWord[unit]; \\n            } \\n        }\\n        return s;\\n    }\\n    \\n    string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        string ans = \"\";\\n        int billion = 1e9, million = 1e6, thousand = 1e3;\\n        int numArr[4] = { num/billion, (num % billion)/million, (num % million)/thousand, num % thousand };\\n        \\n        for(int i = 0; i < 4; ++i){\\n            if(numArr[i] != 0) {\\n                if(ans != \"\") ans += \" \";\\n                ans += convertThreeDigitsToWord(numArr[i]) + billMillThou[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872710,
                "title": "c-easy-clean-code-divided-into-functions-for-easy-understanding",
                "content": "```\\n    string onedigit(int n)\\n    {\\n        if(n==0)\\n            return \"\";\\n        \\n        string word[]={\"One \",\"Two \",\"Three \",\"Four \",\"Five \",\"Six \",\"Seven \",\"Eight \",\"Nine \"};\\n        return word[n-1];\\n    }\\n    \\n    string twodigit(int n)\\n    {\\n        string ans=\"\";\\n        if(n<10)\\n        {\\n            ans+=onedigit(n);\\n        }\\n        else if(n>19)\\n        {\\n            string word[]={\"Twenty \",\"Thirty \",\"Forty \",\"Fifty \",\"Sixty \",\"Seventy \",\"Eighty \",\"Ninety \"};\\n            ans+=word[n/10-2]+onedigit(n%10);\\n        }\\n        else\\n        {\\n            string word[]={\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n            int in=n%10;\\n            ans+=word[in]+\" \";\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string threedigit(int n)\\n    {\\n        string ans=\"\";\\n        \\n        int hundred=n/100;\\n        n=n%100;\\n        if(hundred!=0)\\n            ans+=onedigit(hundred)+\"Hundred \";\\n        \\n        int tens=n;\\n        if(tens!=0)\\n            ans+=twodigit(tens);\\n        \\n        return ans;\\n    }\\n    \\n    string numberToWords(int n) {\\n        \\n        if(n==0)\\n            return \"Zero\";\\n        \\n        string ans=\"\";\\n        \\n        int billion=n/1e9;\\n        n=n%1000000000;\\n        if(billion!=0)\\n            ans+=threedigit(billion)+\"Billion \";\\n        \\n        int million=n/1e6;\\n        n=n%1000000;\\n        if(million!=0)\\n            ans+=threedigit(million)+\"Million \";\\n        \\n        int thousand=n/1e3;\\n        n=n%1000;\\n        if(thousand!=0)\\n            ans+=threedigit(thousand)+\"Thousand \";\\n        \\n        int hundred=n;\\n        ans+=threedigit(hundred);\\n        \\n        ans.pop_back();\\n        return ans;\\n    }\\n```\\n\\n**Do share yor views & upvote if you like !!!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    string onedigit(int n)\\n    {\\n        if(n==0)\\n            return \"\";\\n        \\n        string word[]={\"One \",\"Two \",\"Three \",\"Four \",\"Five \",\"Six \",\"Seven \",\"Eight \",\"Nine \"};\\n        return word[n-1];\\n    }\\n    \\n    string twodigit(int n)\\n    {\\n        string ans=\"\";\\n        if(n<10)\\n        {\\n            ans+=onedigit(n);\\n        }\\n        else if(n>19)\\n        {\\n            string word[]={\"Twenty \",\"Thirty \",\"Forty \",\"Fifty \",\"Sixty \",\"Seventy \",\"Eighty \",\"Ninety \"};\\n            ans+=word[n/10-2]+onedigit(n%10);\\n        }\\n        else\\n        {\\n            string word[]={\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n            int in=n%10;\\n            ans+=word[in]+\" \";\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string threedigit(int n)\\n    {\\n        string ans=\"\";\\n        \\n        int hundred=n/100;\\n        n=n%100;\\n        if(hundred!=0)\\n            ans+=onedigit(hundred)+\"Hundred \";\\n        \\n        int tens=n;\\n        if(tens!=0)\\n            ans+=twodigit(tens);\\n        \\n        return ans;\\n    }\\n    \\n    string numberToWords(int n) {\\n        \\n        if(n==0)\\n            return \"Zero\";\\n        \\n        string ans=\"\";\\n        \\n        int billion=n/1e9;\\n        n=n%1000000000;\\n        if(billion!=0)\\n            ans+=threedigit(billion)+\"Billion \";\\n        \\n        int million=n/1e6;\\n        n=n%1000000;\\n        if(million!=0)\\n            ans+=threedigit(million)+\"Million \";\\n        \\n        int thousand=n/1e3;\\n        n=n%1000;\\n        if(thousand!=0)\\n            ans+=threedigit(thousand)+\"Thousand \";\\n        \\n        int hundred=n;\\n        ans+=threedigit(hundred);\\n        \\n        ans.pop_back();\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829498,
                "title": "readable-javascript-solution",
                "content": "```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar numberToWords = function(num) {\\n    const BILLION = 1000000000;\\n    const MILLION = 1000000;\\n    const THOUSAND = 1000;\\n    const HUNDRED = 100;\\n    const TWENTY = 20;\\n    const TEN = 10;\\n\\n    \\n    const myMap = new Map();\\n    // ones\\n    myMap.set(1, \\'One\\');\\n    myMap.set(2, \\'Two\\');\\n    myMap.set(3, \\'Three\\');\\n    myMap.set(4, \\'Four\\');\\n    myMap.set(5, \\'Five\\');\\n    myMap.set(6, \\'Six\\');\\n    myMap.set(7, \\'Seven\\');\\n    myMap.set(8, \\'Eight\\');\\n    myMap.set(9, \\'Nine\\');\\n    myMap.set(10, \\'Ten\\');\\n    // teens\\n    myMap.set(11, \\'Eleven\\');\\n    myMap.set(12, \\'Twelve\\');\\n    myMap.set(13, \\'Thirteen\\');\\n    myMap.set(14, \\'Fourteen\\');\\n    myMap.set(15, \\'Fifteen\\');\\n    myMap.set(16, \\'Sixteen\\');\\n    myMap.set(17, \\'Seventeen\\');\\n    myMap.set(18, \\'Eighteen\\');\\n    myMap.set(19, \\'Nineteen\\');\\n    // Tens\\n    myMap.set(20, \\'Twenty\\');\\n    myMap.set(30, \\'Thirty\\');\\n    myMap.set(40, \\'Forty\\');\\n    myMap.set(50, \\'Fifty\\');\\n    myMap.set(60, \\'Sixty\\');\\n    myMap.set(70, \\'Seventy\\');\\n    myMap.set(80, \\'Eighty\\');\\n    myMap.set(90, \\'Ninety\\');\\n    \\n    \\n    function buildWord(num){\\n        if(num >= BILLION){\\n            const num_billions = Math.floor(num / BILLION);\\n            const rest = num % BILLION;\\n            return buildWord(num_billions) + \\' Billion\\' + (rest > 0 ? \\' \\' + buildWord(rest) : \\'\\');\\n        } else if(num >= MILLION){\\n            const num_millions = Math.floor(num / MILLION);\\n            const rest = num % MILLION;\\n            return buildWord(num_millions) + \\' Million\\' + (rest > 0 ? \\' \\' + buildWord(rest) : \\'\\');\\n        }else if(num >= THOUSAND){\\n            const num_thousands = Math.floor(num/THOUSAND);\\n            const rest = num % THOUSAND;\\n            return buildWord(num_thousands) + \\' Thousand\\' + (rest > 0 ? \\' \\' + buildWord(rest) : \\'\\');\\n        }else if(num >= HUNDRED){\\n            const num_hundreds = Math.floor(num/HUNDRED);\\n            const rest = num % HUNDRED;\\n            return myMap.get(num_hundreds) + \\' Hundred\\' + (rest > 0 ? \\' \\' + buildWord(rest) : \\'\\');\\n        }else if(num >= TWENTY){\\n            const num_tens = Math.floor(num/TEN) * TEN;\\n            const rest = num % TEN;\\n            return myMap.get(num_tens) + (rest > 0 ? \\' \\' + buildWord(rest) : \\'\\');\\n        }else{\\n            return myMap.get(num);\\n        }\\n    }\\n    \\n    return num === 0 ? \\'Zero\\' : buildWord(num);\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\nvar numberToWords = function(num) {\\n    const BILLION = 1000000000;\\n    const MILLION = 1000000;\\n    const THOUSAND = 1000;\\n    const HUNDRED = 100;\\n    const TWENTY = 20;\\n    const TEN = 10;\\n\\n    \\n    const myMap = new Map();\\n    // ones\\n    myMap.set(1, \\'One\\');\\n    myMap.set(2, \\'Two\\');\\n    myMap.set(3, \\'Three\\');\\n    myMap.set(4, \\'Four\\');\\n    myMap.set(5, \\'Five\\');\\n    myMap.set(6, \\'Six\\');\\n    myMap.set(7, \\'Seven\\');\\n    myMap.set(8, \\'Eight\\');\\n    myMap.set(9, \\'Nine\\');\\n    myMap.set(10, \\'Ten\\');\\n    // teens\\n    myMap.set(11, \\'Eleven\\');\\n    myMap.set(12, \\'Twelve\\');\\n    myMap.set(13, \\'Thirteen\\');\\n    myMap.set(14, \\'Fourteen\\');\\n    myMap.set(15, \\'Fifteen\\');\\n    myMap.set(16, \\'Sixteen\\');\\n    myMap.set(17, \\'Seventeen\\');\\n    myMap.set(18, \\'Eighteen\\');\\n    myMap.set(19, \\'Nineteen\\');\\n    // Tens\\n    myMap.set(20, \\'Twenty\\');\\n    myMap.set(30, \\'Thirty\\');\\n    myMap.set(40, \\'Forty\\');\\n    myMap.set(50, \\'Fifty\\');\\n    myMap.set(60, \\'Sixty\\');\\n    myMap.set(70, \\'Seventy\\');\\n    myMap.set(80, \\'Eighty\\');\\n    myMap.set(90, \\'Ninety\\');\\n    \\n    \\n    function buildWord(num){\\n        if(num >= BILLION){\\n            const num_billions = Math.floor(num / BILLION);\\n            const rest = num % BILLION;\\n            return buildWord(num_billions) + \\' Billion\\' + (rest > 0 ? \\' \\' + buildWord(rest) : \\'\\');\\n        } else if(num >= MILLION){\\n            const num_millions = Math.floor(num / MILLION);\\n            const rest = num % MILLION;\\n            return buildWord(num_millions) + \\' Million\\' + (rest > 0 ? \\' \\' + buildWord(rest) : \\'\\');\\n        }else if(num >= THOUSAND){\\n            const num_thousands = Math.floor(num/THOUSAND);\\n            const rest = num % THOUSAND;\\n            return buildWord(num_thousands) + \\' Thousand\\' + (rest > 0 ? \\' \\' + buildWord(rest) : \\'\\');\\n        }else if(num >= HUNDRED){\\n            const num_hundreds = Math.floor(num/HUNDRED);\\n            const rest = num % HUNDRED;\\n            return myMap.get(num_hundreds) + \\' Hundred\\' + (rest > 0 ? \\' \\' + buildWord(rest) : \\'\\');\\n        }else if(num >= TWENTY){\\n            const num_tens = Math.floor(num/TEN) * TEN;\\n            const rest = num % TEN;\\n            return myMap.get(num_tens) + (rest > 0 ? \\' \\' + buildWord(rest) : \\'\\');\\n        }else{\\n            return myMap.get(num);\\n        }\\n    }\\n    \\n    return num === 0 ? \\'Zero\\' : buildWord(num);\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809419,
                "title": "c-simple-solution-easy-to-understand-recursive",
                "content": "we have created  2 arrays for all of the unique entry that can occur.\\n```\\nclass Solution {\\npublic:\\n    string digits[19] = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\"Nine\",\\n\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",   \"Nineteen\"};\\n    \\n    string tens[8] = {\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    string int2english(int num){\\n        if(num >= 1000000000){\\n            return int2english(num / 1000000000) + \" Billion\" + int2english(num % 1000000000);\\n        }\\n        if(num >= 1000000){\\n            return int2english(num / 1000000) + \" Million\" + int2english(num % 1000000);\\n        }\\n        if(num >= 1000){\\n            return int2english(num / 1000) + \" Thousand\" + int2english(num % 1000);\\n        }\\n        if(num >= 100){\\n            return int2english(num / 100) + \" Hundred\" + int2english(num % 100);\\n        }\\n        if(num >= 20){\\n            return \" \" + tens[num / 10 - 2] + int2english(num % 10);\\n        }\\n        if(num > 0){\\n            return \" \" + digits[num - 1];\\n        }\\n        return \"\";\\n    }\\n    //Main Driver Function\\n    string numberToWords(int num) {\\n        if(num == 0){\\n            return \"Zero\";\\n        }\\n        string ans = int2english(num);\\n        ans = ans.substr(1, ans.length() - 1);\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you liked the Solution!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string digits[19] = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\"Nine\",\\n\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",   \"Nineteen\"};\\n    \\n    string tens[8] = {\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    string int2english(int num){\\n        if(num >= 1000000000){\\n            return int2english(num / 1000000000) + \" Billion\" + int2english(num % 1000000000);\\n        }\\n        if(num >= 1000000){\\n            return int2english(num / 1000000) + \" Million\" + int2english(num % 1000000);\\n        }\\n        if(num >= 1000){\\n            return int2english(num / 1000) + \" Thousand\" + int2english(num % 1000);\\n        }\\n        if(num >= 100){\\n            return int2english(num / 100) + \" Hundred\" + int2english(num % 100);\\n        }\\n        if(num >= 20){\\n            return \" \" + tens[num / 10 - 2] + int2english(num % 10);\\n        }\\n        if(num > 0){\\n            return \" \" + digits[num - 1];\\n        }\\n        return \"\";\\n    }\\n    //Main Driver Function\\n    string numberToWords(int num) {\\n        if(num == 0){\\n            return \"Zero\";\\n        }\\n        string ans = int2english(num);\\n        ans = ans.substr(1, ans.length() - 1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507731,
                "title": "100-faster-c-clear-code",
                "content": "Implementation heavy Problem, so no need for explanation.\\n\\n```\\nPlease UPVOTE IF YOU LIKE MY CODE (<>)\\n```\\n\\n```\\nclass Word{\\n    \\npublic: \\n    int power;\\n    string word;\\n    Word(int pp, string word) {\\n\\n        this->power = (int)pow(10, pp);\\n        this->word = word;\\n    }\\n};\\n\\nclass WordList{\\n    \\n  public:\\n    Word *ten, *hundred, *thousand, *million, *billion;\\n    \\n    WordList() {\\n        \\n        ten = new Word(1, \"Ten\");\\n        hundred = new Word(2, \"Hundred\");\\n        thousand = new Word(3, \"Thousand\");\\n        million = new Word(6, \"Million\");\\n        billion = new Word(9, \"Billion\");\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    string solve(WordList *arr, int num) {\\n        \\n        string result = \"\";\\n        \\n        int billions = num / arr->billion->power;\\n        \\n        if(billions) {\\n            \\n            if(result.size()) result += \" \";\\n            result += solve(arr, billions);\\n            result += \" \";\\n            result += arr->billion->word;\\n            \\n            num %= arr->billion->power;\\n        }\\n        \\n        int millions = num / arr->million->power;\\n         \\n        if(millions) {\\n            \\n            if(result.size()) result += \" \";\\n            result += solve(arr, millions);\\n            result += \" \";\\n            result += arr->million->word;\\n            \\n            num %= arr->million->power;\\n        }\\n        \\n        int thousands = num / arr->thousand->power;\\n        \\n        if(thousands) {\\n            \\n            if(result.size()) result += \" \";\\n            result += solve(arr, thousands);\\n            result += \" \";\\n            result += arr->thousand->word;\\n            \\n            num %= arr->thousand->power;\\n        }\\n        \\n        int hundreds = num / arr->hundred->power;\\n        //cout<<hundreds<<endl;\\n        if(hundreds) {\\n            \\n            if(result.size()) result += \" \";\\n            result += solve(arr, hundreds);\\n            result += \" \";\\n            result += arr->hundred->word;\\n            \\n            num %= arr->hundred->power;\\n        }\\n        \\n        int tens = num / arr->ten->power;\\n        //cout<<tens<<endl;\\n        if(tens) {\\n            \\n            if(result.size() && result[result.size() - 1] != \\' \\')\\n                result += \" \";\\n            switch(tens) {\\n                    \\n                case 1: {\\n                    \\n                    num %= arr->ten->power;\\n                    switch(num) {\\n                            \\n                        case 0: {\\n                            \\n                            result += \"Ten\";\\n                            break;\\n                        }\\n                        case 1: {\\n                            \\n                            result += \"Eleven\";\\n                            break;\\n                        }\\n                        case 2: {\\n                            \\n                            result += \"Twelve\";\\n                            break;\\n                        }\\n                        case 3: {\\n                            \\n                            result += \"Thirteen\";\\n                            break;\\n                        }\\n                        case 4: {\\n                            \\n                            result += \"Fourteen\";\\n                            break;\\n                        }\\n                        case 5: {\\n                            \\n                            result += \"Fifteen\";\\n                            break;\\n                        }\\n                        case 6: {\\n                            \\n                            result += \"Sixteen\";\\n                            break;\\n                        }\\n                        case 7: {\\n                            \\n                            result += \"Seventeen\";\\n                            break;\\n                        }\\n                        case 8: {\\n                            \\n                            result += \"Eighteen\";\\n                            break;\\n                        }\\n                        case 9: {\\n                            \\n                            result += \"Nineteen\";\\n                            break;\\n                        }\\n                        default: {\\n                            \\n                            break;\\n                        }\\n                    }\\n                    \\n                    return result;\\n                }\\n                case 2: {\\n                    \\n                    result += \"Twenty\";\\n                    break;\\n                }\\n                case 3: {\\n                    \\n                    result += \"Thirty\";\\n                    break;\\n                }\\n                case 4: {\\n                    \\n                    result += \"Forty\";\\n                    break;\\n                }\\n                case 5: {\\n                    \\n                    result += \"Fifty\";\\n                    break;\\n                }\\n                case 6: {\\n                    \\n                    result += \"Sixty\";\\n                    break;\\n                }\\n                case 7: {\\n                    \\n                    result += \"Seventy\";\\n                    break;\\n                }\\n                case 8: {\\n                    \\n                    result += \"Eighty\";\\n                    break;\\n                }\\n                case 9: {\\n                    \\n                    result += \"Ninety\";\\n                    break;\\n                }\\n                default: {\\n                    \\n                    break;\\n                }\\n            }\\n            \\n            num %= arr->ten->power;\\n        }\\n        \\n        if(num) {\\n            \\n            if(result.size() && result[result.size() - 1] != \\' \\')\\n                result += \" \";\\n            switch(num) {\\n                case 1: {\\n\\n                    result += \"One\";\\n                    break;\\n                }\\n                case 2: {\\n\\n                    result += \"Two\";\\n                    break;\\n                }\\n                case 3: {\\n\\n                    result += \"Three\";\\n                    break;\\n                }\\n                case 4: {\\n\\n                    result += \"Four\";\\n                    break;\\n                }\\n                case 5: {\\n\\n                    result += \"Five\";\\n                    break;\\n                }\\n                case 6: {\\n\\n                    result += \"Six\";\\n                    break;\\n                }\\n                case 7: {\\n\\n                    result += \"Seven\";\\n                    break;\\n                }\\n                case 8: {\\n\\n                    result += \"Eight\";\\n                    break;\\n                }\\n                case 9: {\\n\\n                    result += \"Nine\";\\n                    break;\\n                }\\n                default: {\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    string numberToWords(int num) {\\n        \\n        if(num == 0) return \"Zero\";\\n        \\n        WordList *arr = new WordList();\\n        \\n        return solve(arr, num);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nPlease UPVOTE IF YOU LIKE MY CODE (<>)\\n```\n```\\nclass Word{\\n    \\npublic: \\n    int power;\\n    string word;\\n    Word(int pp, string word) {\\n\\n        this->power = (int)pow(10, pp);\\n        this->word = word;\\n    }\\n};\\n\\nclass WordList{\\n    \\n  public:\\n    Word *ten, *hundred, *thousand, *million, *billion;\\n    \\n    WordList() {\\n        \\n        ten = new Word(1, \"Ten\");\\n        hundred = new Word(2, \"Hundred\");\\n        thousand = new Word(3, \"Thousand\");\\n        million = new Word(6, \"Million\");\\n        billion = new Word(9, \"Billion\");\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    string solve(WordList *arr, int num) {\\n        \\n        string result = \"\";\\n        \\n        int billions = num / arr->billion->power;\\n        \\n        if(billions) {\\n            \\n            if(result.size()) result += \" \";\\n            result += solve(arr, billions);\\n            result += \" \";\\n            result += arr->billion->word;\\n            \\n            num %= arr->billion->power;\\n        }\\n        \\n        int millions = num / arr->million->power;\\n         \\n        if(millions) {\\n            \\n            if(result.size()) result += \" \";\\n            result += solve(arr, millions);\\n            result += \" \";\\n            result += arr->million->word;\\n            \\n            num %= arr->million->power;\\n        }\\n        \\n        int thousands = num / arr->thousand->power;\\n        \\n        if(thousands) {\\n            \\n            if(result.size()) result += \" \";\\n            result += solve(arr, thousands);\\n            result += \" \";\\n            result += arr->thousand->word;\\n            \\n            num %= arr->thousand->power;\\n        }\\n        \\n        int hundreds = num / arr->hundred->power;\\n        //cout<<hundreds<<endl;\\n        if(hundreds) {\\n            \\n            if(result.size()) result += \" \";\\n            result += solve(arr, hundreds);\\n            result += \" \";\\n            result += arr->hundred->word;\\n            \\n            num %= arr->hundred->power;\\n        }\\n        \\n        int tens = num / arr->ten->power;\\n        //cout<<tens<<endl;\\n        if(tens) {\\n            \\n            if(result.size() && result[result.size() - 1] != \\' \\')\\n                result += \" \";\\n            switch(tens) {\\n                    \\n                case 1: {\\n                    \\n                    num %= arr->ten->power;\\n                    switch(num) {\\n                            \\n                        case 0: {\\n                            \\n                            result += \"Ten\";\\n                            break;\\n                        }\\n                        case 1: {\\n                            \\n                            result += \"Eleven\";\\n                            break;\\n                        }\\n                        case 2: {\\n                            \\n                            result += \"Twelve\";\\n                            break;\\n                        }\\n                        case 3: {\\n                            \\n                            result += \"Thirteen\";\\n                            break;\\n                        }\\n                        case 4: {\\n                            \\n                            result += \"Fourteen\";\\n                            break;\\n                        }\\n                        case 5: {\\n                            \\n                            result += \"Fifteen\";\\n                            break;\\n                        }\\n                        case 6: {\\n                            \\n                            result += \"Sixteen\";\\n                            break;\\n                        }\\n                        case 7: {\\n                            \\n                            result += \"Seventeen\";\\n                            break;\\n                        }\\n                        case 8: {\\n                            \\n                            result += \"Eighteen\";\\n                            break;\\n                        }\\n                        case 9: {\\n                            \\n                            result += \"Nineteen\";\\n                            break;\\n                        }\\n                        default: {\\n                            \\n                            break;\\n                        }\\n                    }\\n                    \\n                    return result;\\n                }\\n                case 2: {\\n                    \\n                    result += \"Twenty\";\\n                    break;\\n                }\\n                case 3: {\\n                    \\n                    result += \"Thirty\";\\n                    break;\\n                }\\n                case 4: {\\n                    \\n                    result += \"Forty\";\\n                    break;\\n                }\\n                case 5: {\\n                    \\n                    result += \"Fifty\";\\n                    break;\\n                }\\n                case 6: {\\n                    \\n                    result += \"Sixty\";\\n                    break;\\n                }\\n                case 7: {\\n                    \\n                    result += \"Seventy\";\\n                    break;\\n                }\\n                case 8: {\\n                    \\n                    result += \"Eighty\";\\n                    break;\\n                }\\n                case 9: {\\n                    \\n                    result += \"Ninety\";\\n                    break;\\n                }\\n                default: {\\n                    \\n                    break;\\n                }\\n            }\\n            \\n            num %= arr->ten->power;\\n        }\\n        \\n        if(num) {\\n            \\n            if(result.size() && result[result.size() - 1] != \\' \\')\\n                result += \" \";\\n            switch(num) {\\n                case 1: {\\n\\n                    result += \"One\";\\n                    break;\\n                }\\n                case 2: {\\n\\n                    result += \"Two\";\\n                    break;\\n                }\\n                case 3: {\\n\\n                    result += \"Three\";\\n                    break;\\n                }\\n                case 4: {\\n\\n                    result += \"Four\";\\n                    break;\\n                }\\n                case 5: {\\n\\n                    result += \"Five\";\\n                    break;\\n                }\\n                case 6: {\\n\\n                    result += \"Six\";\\n                    break;\\n                }\\n                case 7: {\\n\\n                    result += \"Seven\";\\n                    break;\\n                }\\n                case 8: {\\n\\n                    result += \"Eight\";\\n                    break;\\n                }\\n                case 9: {\\n\\n                    result += \"Nine\";\\n                    break;\\n                }\\n                default: {\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    string numberToWords(int num) {\\n        \\n        if(num == 0) return \"Zero\";\\n        \\n        WordList *arr = new WordList();\\n        \\n        return solve(arr, num);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1053030,
                "title": "js-solution-non-recursive-o-n",
                "content": "This solution relies on the fact that in the tests, all first letters of each work are capital. This helps resolve some complexity on adding spaces in the right places.\\n\\n```\\nvar numberToWords = function(num) {\\n\\n    let result = \"\";\\n   \\n    const   billion = Math.floor(num / 1000000000),\\n            million =  Math.floor( (num - (billion * 1000000000) ) / 1000000),\\n            thousand = Math.floor( (num - (billion * 1000000000) - (million * 1000000) ) / 1000),\\n            rest =  num - billion * 1000000000 - million * 1000000 - thousand * 1000;\\n           \\n    if(num === 0) return \"Zero\";\\n    \\n    if(num < 20 ) return map[num];\\n    \\n    if(billion) {\\n        result += map[billion] + \\'Billion\\';\\n    }\\n    \\n    if(million) {\\n        result += getHundreds(million) + \\'Million\\';\\n    }\\n    \\n    if(thousand) {\\n        result += getHundreds(thousand) + \\'Thousand\\';\\n    }\\n    \\n    if(rest) {\\n        result += getHundreds(rest);\\n    }\\n    \\n    return result.match(/[A-Z][a-z]+/g).join(\\' \\');\\n};\\n\\nfunction getHundreds(num) {\\n    let hundred = Math.floor(num / 100);\\n    let rest = num - (hundred*100);\\n    let result = \"\";\\n    if(hundred !== 0) {\\n        result += numberToText(hundred) + \\'Hundred\\';\\n    }\\n    if(rest !== 0) {\\n        result += numberToText(rest);\\n    }\\n   \\n    return result;\\n    \\n}\\n\\nfunction numberToText(num) {\\n    if(!map[num]) {\\n        return getTens(num)\\n    }\\n    return map[num] \\n}\\n\\nfunction getTens(num) { \\n    let tens = Math.floor(num / 10);\\n    let rest = num - (tens*10);\\n    return map[tens*10] + \\' \\' + map[rest];\\n}\\n\\n\\nlet map = {\\n    1: \\'One\\',\\n    2: \\'Two\\',\\n    3: \\'Three\\',\\n    4: \\'Four\\',\\n    5: \\'Five\\',\\n    6: \\'Six\\',\\n    7: \\'Seven\\',\\n    8: \\'Eight\\',\\n    9: \\'Nine\\',\\n    10: \\'Ten\\',\\n    11: \\'Eleven\\',\\n    12: \\'Twelve\\',\\n    13: \\'Thirteen\\',\\n    14: \\'Fourteen\\',\\n    15: \\'Fifteen\\',\\n    16: \\'Sixteen\\',\\n    17: \\'Seventeen\\',\\n    18: \\'Eighteen\\',\\n    19: \\'Nineteen\\',\\n    20: \\'Twenty\\',\\n    30: \\'Thirty\\',\\n    40: \\'Forty\\',\\n    50: \\'Fifty\\',\\n    60: \\'Sixty\\',\\n    70: \\'Seventy\\',\\n    80: \\'Eighty\\',\\n    90: \\'Ninety\\'\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberToWords = function(num) {\\n\\n    let result = \"\";\\n   \\n    const   billion = Math.floor(num / 1000000000),\\n            million =  Math.floor( (num - (billion * 1000000000) ) / 1000000),\\n            thousand = Math.floor( (num - (billion * 1000000000) - (million * 1000000) ) / 1000),\\n            rest =  num - billion * 1000000000 - million * 1000000 - thousand * 1000;\\n           \\n    if(num === 0) return \"Zero\";\\n    \\n    if(num < 20 ) return map[num];\\n    \\n    if(billion) {\\n        result += map[billion] + \\'Billion\\';\\n    }\\n    \\n    if(million) {\\n        result += getHundreds(million) + \\'Million\\';\\n    }\\n    \\n    if(thousand) {\\n        result += getHundreds(thousand) + \\'Thousand\\';\\n    }\\n    \\n    if(rest) {\\n        result += getHundreds(rest);\\n    }\\n    \\n    return result.match(/[A-Z][a-z]+/g).join(\\' \\');\\n};\\n\\nfunction getHundreds(num) {\\n    let hundred = Math.floor(num / 100);\\n    let rest = num - (hundred*100);\\n    let result = \"\";\\n    if(hundred !== 0) {\\n        result += numberToText(hundred) + \\'Hundred\\';\\n    }\\n    if(rest !== 0) {\\n        result += numberToText(rest);\\n    }\\n   \\n    return result;\\n    \\n}\\n\\nfunction numberToText(num) {\\n    if(!map[num]) {\\n        return getTens(num)\\n    }\\n    return map[num] \\n}\\n\\nfunction getTens(num) { \\n    let tens = Math.floor(num / 10);\\n    let rest = num - (tens*10);\\n    return map[tens*10] + \\' \\' + map[rest];\\n}\\n\\n\\nlet map = {\\n    1: \\'One\\',\\n    2: \\'Two\\',\\n    3: \\'Three\\',\\n    4: \\'Four\\',\\n    5: \\'Five\\',\\n    6: \\'Six\\',\\n    7: \\'Seven\\',\\n    8: \\'Eight\\',\\n    9: \\'Nine\\',\\n    10: \\'Ten\\',\\n    11: \\'Eleven\\',\\n    12: \\'Twelve\\',\\n    13: \\'Thirteen\\',\\n    14: \\'Fourteen\\',\\n    15: \\'Fifteen\\',\\n    16: \\'Sixteen\\',\\n    17: \\'Seventeen\\',\\n    18: \\'Eighteen\\',\\n    19: \\'Nineteen\\',\\n    20: \\'Twenty\\',\\n    30: \\'Thirty\\',\\n    40: \\'Forty\\',\\n    50: \\'Fifty\\',\\n    60: \\'Sixty\\',\\n    70: \\'Seventy\\',\\n    80: \\'Eighty\\',\\n    90: \\'Ninety\\'\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1007897,
                "title": "javascript-easy-to-understand-recursion",
                "content": "```\\nconst numberToWords = (num) => {\\n        if (num == 0) return \"Zero\";\\n        return helperRecurse(num); \\n    }\\n    \\nconst helperRecurse = (num) => {\\n    const belowTen = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\\n    const belowTwenty = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"];\\n    const belowHundred = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"];\\n    let result = \\'\\'\\n    if (num < 10) result = belowTen[num];\\n    else if (num < 20) result = belowTwenty[num -10];\\n    else if (num < 100) result = belowHundred[Math.floor(num/10)] + \" \" + helperRecurse(num % 10);\\n    else if (num < 1000) result = helperRecurse(Math.floor(num/100)) + \" Hundred \" +  helperRecurse(num % 100);\\n    else if (num < 1000000) result = helperRecurse(Math.floor(num/1000)) + \" Thousand \" +  helperRecurse(num % 1000);\\n    else if (num < 1000000000) result = helperRecurse(Math.floor(num/1000000)) + \" Million \" +  helperRecurse(num % 1000000);\\n    else result = helperRecurse(Math.floor(num/1000000000)) + \" Billion \" + helperRecurse(num % 1000000000);\\n    return result.trim();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst numberToWords = (num) => {\\n        if (num == 0) return \"Zero\";\\n        return helperRecurse(num); \\n    }\\n    \\nconst helperRecurse = (num) => {\\n    const belowTen = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\\n    const belowTwenty = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"];\\n    const belowHundred = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"];\\n    let result = \\'\\'\\n    if (num < 10) result = belowTen[num];\\n    else if (num < 20) result = belowTwenty[num -10];\\n    else if (num < 100) result = belowHundred[Math.floor(num/10)] + \" \" + helperRecurse(num % 10);\\n    else if (num < 1000) result = helperRecurse(Math.floor(num/100)) + \" Hundred \" +  helperRecurse(num % 100);\\n    else if (num < 1000000) result = helperRecurse(Math.floor(num/1000)) + \" Thousand \" +  helperRecurse(num % 1000);\\n    else if (num < 1000000000) result = helperRecurse(Math.floor(num/1000000)) + \" Million \" +  helperRecurse(num % 1000000);\\n    else result = helperRecurse(Math.floor(num/1000000000)) + \" Billion \" + helperRecurse(num % 1000000000);\\n    return result.trim();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902299,
                "title": "simple-java-solution-2-ms-95-41",
                "content": "```\\nclass Solution {\\n \\n    private static final TreeMap<Integer,String> map = new TreeMap<>(); \\n    \\n    static {\\n        getMap(map);\\n    }\\n              \\n    public String numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        StringBuilder sb = new StringBuilder();\\n        while(num > 0) {\\n           Integer key = map.floorKey(num);\\n           Integer n = num/key;\\n            if(key < 100 && map.containsKey(key)) {\\n                sb.append(\" \").append(map.get(key));\\n            } else if(n < 100 && map.containsKey(n)) {\\n                sb.append(\" \").append(map.get(n)).append(\" \").append(map.get(key));\\n            } else {\\n                sb.append(\" \").append(numberToWords(n)).append(\" \").append(map.get(key));\\n            }\\n           num = num%key;\\n        }\\n        return sb.toString().trim();\\n    }\\n    \\n    \\n    private static TreeMap<Integer,String> getMap(TreeMap<Integer,String> map) {\\n        map.put(0,\"Zero\");\\n        map.put(1,\"One\");                  \\n        map.put(2,\"Two\");                         \\n        map.put(3,\"Three\");      \\n        map.put(4,\"Four\");           \\n        map.put(5,\"Five\");            \\n        map.put(6,\"Six\");                     \\n        map.put(7,\"Seven\");              \\n        map.put(8,\"Eight\");            \\n        map.put(9,\"Nine\");            \\n        map.put(10,\"Ten\");             \\n        map.put(11,\"Eleven\");             \\n        map.put(12,\"Twelve\");          \\n        map.put(13,\"Thirteen\");                     \\n        map.put(14,\"Fourteen\");                    \\n        map.put(15,\"Fifteen\");                     \\n        map.put(16,\"Sixteen\");                     \\n        map.put(17,\"Seventeen\");                     \\n        map.put(18,\"Eighteen\");                    \\n        map.put(19,\"Nineteen\");                    \\n        map.put(20,\"Twenty\");                     \\n        map.put(30,\"Thirty\");                     \\n        map.put(40,\"Forty\");                    \\n        map.put(50,\"Fifty\");                     \\n        map.put(60,\"Sixty\");                   \\n        map.put(70,\"Seventy\"); \\n        map.put(80, \"Eighty\");\\n        map.put(90,\"Ninety\");                     \\n        map.put(100,\"Hundred\");          \\n        map.put(1000 , \"Thousand\");        \\n        map.put(1000000,\"Million\");              \\n        map.put(1000000000,\"Billion\"); \\n        return map;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n \\n    private static final TreeMap<Integer,String> map = new TreeMap<>(); \\n    \\n    static {\\n        getMap(map);\\n    }\\n              \\n    public String numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        StringBuilder sb = new StringBuilder();\\n        while(num > 0) {\\n           Integer key = map.floorKey(num);\\n           Integer n = num/key;\\n            if(key < 100 && map.containsKey(key)) {\\n                sb.append(\" \").append(map.get(key));\\n            } else if(n < 100 && map.containsKey(n)) {\\n                sb.append(\" \").append(map.get(n)).append(\" \").append(map.get(key));\\n            } else {\\n                sb.append(\" \").append(numberToWords(n)).append(\" \").append(map.get(key));\\n            }\\n           num = num%key;\\n        }\\n        return sb.toString().trim();\\n    }\\n    \\n    \\n    private static TreeMap<Integer,String> getMap(TreeMap<Integer,String> map) {\\n        map.put(0,\"Zero\");\\n        map.put(1,\"One\");                  \\n        map.put(2,\"Two\");                         \\n        map.put(3,\"Three\");      \\n        map.put(4,\"Four\");           \\n        map.put(5,\"Five\");            \\n        map.put(6,\"Six\");                     \\n        map.put(7,\"Seven\");              \\n        map.put(8,\"Eight\");            \\n        map.put(9,\"Nine\");            \\n        map.put(10,\"Ten\");             \\n        map.put(11,\"Eleven\");             \\n        map.put(12,\"Twelve\");          \\n        map.put(13,\"Thirteen\");                     \\n        map.put(14,\"Fourteen\");                    \\n        map.put(15,\"Fifteen\");                     \\n        map.put(16,\"Sixteen\");                     \\n        map.put(17,\"Seventeen\");                     \\n        map.put(18,\"Eighteen\");                    \\n        map.put(19,\"Nineteen\");                    \\n        map.put(20,\"Twenty\");                     \\n        map.put(30,\"Thirty\");                     \\n        map.put(40,\"Forty\");                    \\n        map.put(50,\"Fifty\");                     \\n        map.put(60,\"Sixty\");                   \\n        map.put(70,\"Seventy\"); \\n        map.put(80, \"Eighty\");\\n        map.put(90,\"Ninety\");                     \\n        map.put(100,\"Hundred\");          \\n        map.put(1000 , \"Thousand\");        \\n        map.put(1000000,\"Million\");              \\n        map.put(1000000000,\"Billion\"); \\n        return map;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764375,
                "title": "python3-straightforward",
                "content": "Here, I separate the number in English into two parts \\n1) thousands, millions, billions\\n2) hundreds-tens-digits\\n\\nWithin each 1000 unit, the code to create hundreds-tens-digits can be done through a helper function. \\n\\n\\n```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        mp = {1: \"One\",   11: \"Eleven\",    10: \"Ten\", \\n              2: \"Two\",   12: \"Twelve\",    20: \"Twenty\", \\n              3: \"Three\", 13: \"Thirteen\",  30: \"Thirty\", \\n              4: \"Four\",  14: \"Fourteen\",  40: \"Forty\",\\n              5: \"Five\",  15: \"Fifteen\",   50: \"Fifty\", \\n              6: \"Six\",   16: \"Sixteen\",   60: \"Sixty\", \\n              7: \"Seven\", 17: \"Seventeen\", 70: \"Seventy\", \\n              8: \"Eight\", 18: \"Eighteen\",  80: \"Eighty\",\\n              9: \"Nine\",  19: \"Nineteen\",  90: \"Ninety\"}\\n        \\n        def fn(n):\\n            \"\"\"Return English words of n (0-999) in array.\"\"\"\\n            if not n: return []\\n            elif n < 20: return [mp[n]]\\n            elif n < 100: return [mp[n//10*10]] + fn(n%10)\\n            else: return [mp[n//100], \"Hundred\"] + fn(n%100)\\n        \\n        ans = []\\n        for i, unit in zip((9, 6, 3, 0), (\"Billion\", \"Million\", \"Thousand\", \"\")): \\n            n, num = divmod(num, 10**i)\\n            ans.extend(fn(n))\\n            if n and unit: ans.append(unit)\\n        return \" \".join(ans) or \"Zero\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        mp = {1: \"One\",   11: \"Eleven\",    10: \"Ten\", \\n              2: \"Two\",   12: \"Twelve\",    20: \"Twenty\", \\n              3: \"Three\", 13: \"Thirteen\",  30: \"Thirty\", \\n              4: \"Four\",  14: \"Fourteen\",  40: \"Forty\",\\n              5: \"Five\",  15: \"Fifteen\",   50: \"Fifty\", \\n              6: \"Six\",   16: \"Sixteen\",   60: \"Sixty\", \\n              7: \"Seven\", 17: \"Seventeen\", 70: \"Seventy\", \\n              8: \"Eight\", 18: \"Eighteen\",  80: \"Eighty\",\\n              9: \"Nine\",  19: \"Nineteen\",  90: \"Ninety\"}\\n        \\n        def fn(n):\\n            \"\"\"Return English words of n (0-999) in array.\"\"\"\\n            if not n: return []\\n            elif n < 20: return [mp[n]]\\n            elif n < 100: return [mp[n//10*10]] + fn(n%10)\\n            else: return [mp[n//100], \"Hundred\"] + fn(n%100)\\n        \\n        ans = []\\n        for i, unit in zip((9, 6, 3, 0), (\"Billion\", \"Million\", \"Thousand\", \"\")): \\n            n, num = divmod(num, 10**i)\\n            ans.extend(fn(n))\\n            if n and unit: ans.append(unit)\\n        return \" \".join(ans) or \"Zero\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500628,
                "title": "super-short-20-lines-python-solution",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.under20=[\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\\n                 \"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\\n                 \"Eighteen\",\"Nineteen\"]\\n        self.tens=[\"\",\"Ten\",\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n        self.places=[\"\",\"Hundred\",\"Thousand\",\"Million\",\"Billion\"]\\n        self.placethresholds=[0,1000,1000000,1000000000,3000000000] #3billion cuz max input is ~2.4bill\\n        self.placedivision=[0,100,1000,1000000,1000000000]\\n    def numberToWords(self, num: int) -> str:\\n        return(\"Zero\" if num == 0 else \\' \\'.join(filter(None,self.helper(num))))\\n    def helper(self,num):\\n        if num < 20:\\n            return [self.under20[num]]\\n        elif num < 100:\\n            return [self.tens[num//10]]+self.helper(num%10)\\n        for i in range(len(self.placethresholds)-1,-1,-1):\\n            if self.placethresholds[i-1] <= num < self.placethresholds[i]:\\n                return self.helper(num//self.placedivision[i])+[self.places[i]]+self.helper(num%self.placedivision[i])\\n                \\n```\\n\\nA more intuitive version:\\n```\\n    def __init__(self):\\n        self.under20=[\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\\n                 \"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\\n                 \"Eighteen\",\"Nineteen\"]\\n        self.tens=[\"\",\"Ten\",\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n        self.places=[\"Hundred\",\"Thousand\",\"Million\",\"Billion\"]\\n        \\n    def numberToWords(self, num: int) -> str:\\n        return(\"Zero\" if num == 0 else \\' \\'.join(filter(None,self.helper(num))))\\n\\n    def helper(self,num):\\n        if num < 20:\\n            return [self.under20[num]]\\n        elif num < 100:\\n            return [self.tens[num//10]]+self.helper(num%10)\\n        elif num < 1000:\\n            return self.helper(num//100)+[self.places[0]]+self.helper(num%100)\\n        elif num < 1000000: #thousands\\n            return self.helper(num//1000)+[self.places[1]]+self.helper(num%1000)\\n        elif num < 1000000000: #millions\\n            return self.helper(num//1000000)+[self.places[2]]+self.helper(num%1000000)     \\n        else: #billions\\n            return self.helper(num//1000000000)+[self.places[3]]+self.helper(num%1000000000)   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.under20=[\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\\n                 \"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\\n                 \"Eighteen\",\"Nineteen\"]\\n        self.tens=[\"\",\"Ten\",\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n        self.places=[\"\",\"Hundred\",\"Thousand\",\"Million\",\"Billion\"]\\n        self.placethresholds=[0,1000,1000000,1000000000,3000000000] #3billion cuz max input is ~2.4bill\\n        self.placedivision=[0,100,1000,1000000,1000000000]\\n    def numberToWords(self, num: int) -> str:\\n        return(\"Zero\" if num == 0 else \\' \\'.join(filter(None,self.helper(num))))\\n    def helper(self,num):\\n        if num < 20:\\n            return [self.under20[num]]\\n        elif num < 100:\\n            return [self.tens[num//10]]+self.helper(num%10)\\n        for i in range(len(self.placethresholds)-1,-1,-1):\\n            if self.placethresholds[i-1] <= num < self.placethresholds[i]:\\n                return self.helper(num//self.placedivision[i])+[self.places[i]]+self.helper(num%self.placedivision[i])\\n                \\n```\n```\\n    def __init__(self):\\n        self.under20=[\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\\n                 \"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\\n                 \"Eighteen\",\"Nineteen\"]\\n        self.tens=[\"\",\"Ten\",\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\n        self.places=[\"Hundred\",\"Thousand\",\"Million\",\"Billion\"]\\n        \\n    def numberToWords(self, num: int) -> str:\\n        return(\"Zero\" if num == 0 else \\' \\'.join(filter(None,self.helper(num))))\\n\\n    def helper(self,num):\\n        if num < 20:\\n            return [self.under20[num]]\\n        elif num < 100:\\n            return [self.tens[num//10]]+self.helper(num%10)\\n        elif num < 1000:\\n            return self.helper(num//100)+[self.places[0]]+self.helper(num%100)\\n        elif num < 1000000: #thousands\\n            return self.helper(num//1000)+[self.places[1]]+self.helper(num%1000)\\n        elif num < 1000000000: #millions\\n            return self.helper(num//1000000)+[self.places[2]]+self.helper(num%1000000)     \\n        else: #billions\\n            return self.helper(num//1000000000)+[self.places[3]]+self.helper(num%1000000000)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 349269,
                "title": "java-solution-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n    /**\\n        How we count number like 123456789?\\n        We break into 3 digits like 123,456,789. Then starts with 789 -> Seven Hundred Eighty Nine + \"\"\\n        Then 456 --> Four Hundred Fifty Six + Thousand\\n        Then 123 --> One Hundred Twenty Three + Million.\\n        So we can solve this problem by converting every 3 digits and adding \", thousand, million, etc\\n        Using %1000, we can get last 3 digit, and call convert func then append above thousand string, and we need to append these in front of our string because we are working from the end of the number to higher digits.\\n        If any time num%1000 == 0, we don\\'t add anything. For example 1,000,456 -> One Million Four Hundred Fifty Six. There is no Thousand at all.\\n        Converting 3 digits can be done recursively, if 0 or <20, base case.\\n        Between 20 - 99, we append LESSTHANHUNDRED string and we need to convert the last digit as well which we can call convert(num%10)\\n        Similar process for 100-999. Don\\'t forget the spaces we need to add during converting.\\n        Time complexity: O(N) - N is the number of digits\\n    */\\n    private String [] LESSTHANTWENTY = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private String [] LESSTHANHUNDRED = {\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    private String [] ABOVEHUNDRED = {\"\",\"Thousand\", \"Million\", \"Billion\", \"Trillion\"};\\n    public String numberToWords(int num) {\\n        if(num == 0)\\n            return \"Zero\";\\n        int index = 0;\\n        String ans = new String();\\n        while(num > 0){\\n            if(num%1000 != 0)\\n                ans = convertThreeDigitsNum(num%1000) + ABOVEHUNDRED[index] + \" \" + ans;\\n            num/=1000;\\n            index++;\\n        }\\n        return ans.trim();\\n    }\\n    private String convertThreeDigitsNum(int num){\\n        if(num == 0) //Something like 60, Sixty + convertThreeDigitsNum(60%10)\\n            return \"\";\\n        else if(num < 20)\\n            return LESSTHANTWENTY[num - 1] + \" \";\\n        else if(num >= 20 && num < 100)\\n            return LESSTHANHUNDRED[num/10 - 2] + \" \" + convertThreeDigitsNum(num%10);\\n        else\\n            return LESSTHANTWENTY[num/100 - 1] + \" Hundred \" + convertThreeDigitsNum(num%100);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n        How we count number like 123456789?\\n        We break into 3 digits like 123,456,789. Then starts with 789 -> Seven Hundred Eighty Nine + \"\"\\n        Then 456 --> Four Hundred Fifty Six + Thousand\\n        Then 123 --> One Hundred Twenty Three + Million.\\n        So we can solve this problem by converting every 3 digits and adding \", thousand, million, etc\\n        Using %1000, we can get last 3 digit, and call convert func then append above thousand string, and we need to append these in front of our string because we are working from the end of the number to higher digits.\\n        If any time num%1000 == 0, we don\\'t add anything. For example 1,000,456 -> One Million Four Hundred Fifty Six. There is no Thousand at all.\\n        Converting 3 digits can be done recursively, if 0 or <20, base case.\\n        Between 20 - 99, we append LESSTHANHUNDRED string and we need to convert the last digit as well which we can call convert(num%10)\\n        Similar process for 100-999. Don\\'t forget the spaces we need to add during converting.\\n        Time complexity: O(N) - N is the number of digits\\n    */\\n    private String [] LESSTHANTWENTY = {\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private String [] LESSTHANHUNDRED = {\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    private String [] ABOVEHUNDRED = {\"\",\"Thousand\", \"Million\", \"Billion\", \"Trillion\"};\\n    public String numberToWords(int num) {\\n        if(num == 0)\\n            return \"Zero\";\\n        int index = 0;\\n        String ans = new String();\\n        while(num > 0){\\n            if(num%1000 != 0)\\n                ans = convertThreeDigitsNum(num%1000) + ABOVEHUNDRED[index] + \" \" + ans;\\n            num/=1000;\\n            index++;\\n        }\\n        return ans.trim();\\n    }\\n    private String convertThreeDigitsNum(int num){\\n        if(num == 0) //Something like 60, Sixty + convertThreeDigitsNum(60%10)\\n            return \"\";\\n        else if(num < 20)\\n            return LESSTHANTWENTY[num - 1] + \" \";\\n        else if(num >= 20 && num < 100)\\n            return LESSTHANHUNDRED[num/10 - 2] + \" \" + convertThreeDigitsNum(num%10);\\n        else\\n            return LESSTHANTWENTY[num/100 - 1] + \" Hundred \" + convertThreeDigitsNum(num%100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201498,
                "title": "ruby-clean-solution-borrowed-from-java-solution-ac-beats-100",
                "content": "```\\n# @param {Integer} num\\n# @return {String}\\n\\nLESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\\n  \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\nTENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\nTHOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"]\\n\\ndef number_to_words(num)\\n   return \"Zero\" if num ==0\\n    words = \"\"\\n    i = 0\\n    while (num > 0)\\n        if (num % 1000 != 0)\\n    \\t    words = helper(num % 1000) +THOUSANDS[i] + \" \" + words\\n        end\\n    \\tnum /= 1000\\n    \\ti+=1\\n    end\\n\\n    words.strip!\\nend\\n\\ndef helper(num)\\n      return \\'\\' if num == 0\\n      if (num < 20)\\n          return LESS_THAN_20[num] + \" \"\\n      elsif (num < 100)\\n          return TENS[num / 10] + \" \" + helper(num % 10)\\n      else\\n          return LESS_THAN_20[num / 100] + \" Hundred \" + helper(num % 100)\\n      end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer} num\\n# @return {String}\\n\\nLESS_THAN_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\\n  \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\nTENS = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\\nTHOUSANDS = [\"\", \"Thousand\", \"Million\", \"Billion\"]\\n\\ndef number_to_words(num)\\n   return \"Zero\" if num ==0\\n    words = \"\"\\n    i = 0\\n    while (num > 0)\\n        if (num % 1000 != 0)\\n    \\t    words = helper(num % 1000) +THOUSANDS[i] + \" \" + words\\n        end\\n    \\tnum /= 1000\\n    \\ti+=1\\n    end\\n\\n    words.strip!\\nend\\n\\ndef helper(num)\\n      return \\'\\' if num == 0\\n      if (num < 20)\\n          return LESS_THAN_20[num] + \" \"\\n      elsif (num < 100)\\n          return TENS[num / 10] + \" \" + helper(num % 10)\\n      else\\n          return LESS_THAN_20[num / 100] + \" Hundred \" + helper(num % 100)\\n      end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 70735,
                "title": "clear-python-solution",
                "content": "    def numberToWords(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        if num == 0:\\n            return 'Zero'\\n        ddict = {1: 'One', 2: 'Two', 3: \"Three\", 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine',\\n                 10: 'Ten', 11: 'Eleven', 12: 'Twelve', 13: 'Thirteen', 14: 'Fourteen', 15:'Fifteen', 16: 'Sixteen',\\n                 17: 'Seventeen', 18: 'Eighteen', 19: 'Nineteen', 20: 'Twenty', 30: 'Thirty', 40: 'Forty', 50: 'Fifty',\\n                 60: 'Sixty', 70: 'Seventy', 80: 'Eighty', 90: 'Ninety'}\\n        base = ['', 'Thousand', 'Million', 'Billion']\\n        result, exp = '', 1000\\n        i, chunk = 0, 0\\n        while num:\\n            chunk = num % exp\\n            if chunk:\\n                result = base[i] + ' ' + result\\n                one = chunk % 10\\n                two = (chunk % 100) - one\\n                three = chunk // 100\\n                if two == 10:\\n                    result = ddict[two+one] + ' ' + result\\n                else:\\n                    if one:\\n                        result = ddict[one] + ' ' + result\\n                    if two:\\n                        result = ddict[two] + ' ' +result\\n                if three:\\n                    result = ddict[three] + ' Hundred ' + result\\n            num //= exp\\n            i += 1\\n        return result.rstrip()",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def numberToWords(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        if num == 0:\\n            return 'Zero'\\n        ddict = {1: 'One', 2: 'Two', 3: \"Three\", 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine',\\n                 10: 'Ten', 11: 'Eleven', 12: 'Twelve', 13: 'Thirteen', 14: 'Fourteen', 15:'Fifteen', 16: 'Sixteen',\\n                 17: 'Seventeen', 18: 'Eighteen', 19: 'Nineteen', 20: 'Twenty', 30: 'Thirty', 40: 'Forty', 50: 'Fifty',\\n                 60: 'Sixty', 70: 'Seventy', 80: 'Eighty', 90: 'Ninety'}\\n        base = ['', 'Thousand', 'Million', 'Billion']\\n        result, exp = '', 1000\\n        i, chunk = 0, 0\\n        while num:\\n            chunk = num % exp\\n            if chunk:\\n                result = base[i] + ' ' + result\\n                one = chunk % 10\\n                two = (chunk % 100) - one\\n                three = chunk // 100\\n                if two == 10:\\n                    result = ddict[two+one] + ' ' + result\\n                else:\\n                    if one:\\n                        result = ddict[one] + ' ' + result\\n                    if two:\\n                        result = ddict[two] + ' ' +result\\n                if three:\\n                    result = ddict[three] + ' Hundred ' + result\\n            num //= exp\\n            i += 1\\n        return result.rstrip()",
                "codeTag": "Python3"
            },
            {
                "id": 70765,
                "title": "share-my-python-solution",
                "content": "\\n    def numberToWords(self, num):\\n        if num == 0: return \"Zero\"\\n        d= {0: \"Zero\", 1:\"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\", 10 : \"Ten\", 11: \"Eleven\", 12: \"Twelve\", 13: \"Thirteen\", 14: \"Fourteen\", 15: \"Fifteen\", 16: \"Sixteen\", 17: \"Seventeen\", 18: \"Eighteen\", 19: \"Nineteen\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\", 50: \"Fifty\", 60: \"Sixty\", 70: \"Seventy\", 80: \"Eighty\", 90: \"Ninety\"}\\n        unit = [[], [\"Thousand\"], [\"Million\"], [\"Billion\"]]\\n        res, i = [], 0\\n        while num != 0:\\n            cur = num%1000\\n            res = self.threedigits(cur, d, unit[i]) + res\\n            num //= 1000\\n            i += 1\\n        return \" \".join(res)\\n    def threedigits(self, num, d, unit):\\n        res = []\\n        if num == 0:\\n            return res\\n        if num/100 != 0:\\n            res = [d[num/100] + \" \" + \"Hundred\"]\\n        res += self.twodigits(num%100, d)\\n        res += unit\\n        return res\\n    \\n    def twodigits(self, num, d):\\n        if num == 0: return []\\n        if num in d: return [d[num]]\\n        return [d[(num/10)*10], d[num%10]]",
                "solutionTags": [],
                "code": "\\n    def numberToWords(self, num):\\n        if num == 0: return \"Zero\"\\n        d= {0: \"Zero\", 1:\"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\", 10 : \"Ten\", 11: \"Eleven\", 12: \"Twelve\", 13: \"Thirteen\", 14: \"Fourteen\", 15: \"Fifteen\", 16: \"Sixteen\", 17: \"Seventeen\", 18: \"Eighteen\", 19: \"Nineteen\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\", 50: \"Fifty\", 60: \"Sixty\", 70: \"Seventy\", 80: \"Eighty\", 90: \"Ninety\"}\\n        unit = [[], [\"Thousand\"], [\"Million\"], [\"Billion\"]]\\n        res, i = [], 0\\n        while num != 0:\\n            cur = num%1000\\n            res = self.threedigits(cur, d, unit[i]) + res\\n            num //= 1000\\n            i += 1\\n        return \" \".join(res)\\n    def threedigits(self, num, d, unit):\\n        res = []\\n        if num == 0:\\n            return res\\n        if num/100 != 0:\\n            res = [d[num/100] + \" \" + \"Hundred\"]\\n        res += self.twodigits(num%100, d)\\n        res += unit\\n        return res\\n    \\n    def twodigits(self, num, d):\\n        if num == 0: return []\\n        if num in d: return [d[num]]\\n        return [d[(num/10)*10], d[num%10]]",
                "codeTag": "Python3"
            },
            {
                "id": 2653977,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        mapper = {1e9: \"Billion\", 1e6: \"Million\", 1e3: \"Thousand\", 1e2: \"Hundred\",\\n               90:  \"Ninety\", 80:  \"Eighty\", 70:  \"Seventy\",\\n               60:  \"Sixty\", 50:  \"Fifty\", 40:  \"Forty\",\\n               30:  \"Thirty\", 20:  \"Twenty\", 19: \"Nineteen\",\\n               18:  \"Eighteen\", 17: \"Seventeen\", 16: \"Sixteen\",\\n               15:  \"Fifteen\", 14: \"Fourteen\", 13: \"Thirteen\",\\n               12:  \"Twelve\", 11:  \"Eleven\", 10:  \"Ten\",\\n               9:   \"Nine\", 8:   \"Eight\", 7:   \"Seven\",\\n               6:   \"Six\", 5:   \"Five\", 4: \"Four\", 3: \"Three\",\\n               2: \"Two\", 1: \"One\", 0: \"Zero\"}\\n        \\n        def dfs(n: int) -> str:\\n            if n <= 20:\\n                return mapper[n]\\n\\n            for val, word in mapper.items():\\n                quo, rem = divmod(n, val)\\n                if quo:\\n                    higher, lower = \"\", \"\"\\n                    # if it is Billion, Million, Thousand or Hundred, we say One Billion, Two Million etc.\\n                    # but for numbers less than 100, we only say Ninety Three(we don\\'t say One Ninety Three)\\n                    if val >= 100:\\n                        higher = dfs(quo) + \" \"\\n                    if rem:\\n                        lower = \" \" + dfs(rem)\\n\\n                    return higher + word + lower\\n        \\n        return dfs(num)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        mapper = {1e9: \"Billion\", 1e6: \"Million\", 1e3: \"Thousand\", 1e2: \"Hundred\",\\n               90:  \"Ninety\", 80:  \"Eighty\", 70:  \"Seventy\",\\n               60:  \"Sixty\", 50:  \"Fifty\", 40:  \"Forty\",\\n               30:  \"Thirty\", 20:  \"Twenty\", 19: \"Nineteen\",\\n               18:  \"Eighteen\", 17: \"Seventeen\", 16: \"Sixteen\",\\n               15:  \"Fifteen\", 14: \"Fourteen\", 13: \"Thirteen\",\\n               12:  \"Twelve\", 11:  \"Eleven\", 10:  \"Ten\",\\n               9:   \"Nine\", 8:   \"Eight\", 7:   \"Seven\",\\n               6:   \"Six\", 5:   \"Five\", 4: \"Four\", 3: \"Three\",\\n               2: \"Two\", 1: \"One\", 0: \"Zero\"}\\n        \\n        def dfs(n: int) -> str:\\n            if n <= 20:\\n                return mapper[n]\\n\\n            for val, word in mapper.items():\\n                quo, rem = divmod(n, val)\\n                if quo:\\n                    higher, lower = \"\", \"\"\\n                    # if it is Billion, Million, Thousand or Hundred, we say One Billion, Two Million etc.\\n                    # but for numbers less than 100, we only say Ninety Three(we don\\'t say One Ninety Three)\\n                    if val >= 100:\\n                        higher = dfs(quo) + \" \"\\n                    if rem:\\n                        lower = \" \" + dfs(rem)\\n\\n                    return higher + word + lower\\n        \\n        return dfs(num)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484320,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num==0:\\n            return \"Zero\"\\n        belowTwenty = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\\n                    \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\\n                    \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \\n            \"Eighty\", \"Ninety\"]\\n        def helper(num: int) -> str:\\n            if num<20:\\n                s = belowTwenty[num]\\n            elif num<100:\\n                s = tens[num//10] + \" \" + belowTwenty[num%10]\\n            elif num<1000:\\n                s = helper(num//100) + \" Hundred \" + helper(num%100)\\n            elif num<1000000:\\n                s = helper(num//1000) + \" Thousand \" + helper(num%1000)\\n            elif num<1000000000:\\n                s = helper(num//1000000) + \" Million \" + helper(num%1000000)\\n            else:\\n                s = helper(num//1000000000) + \" Billion \" + helper(num%1000000000)\\n            return s.strip()\\n        return helper(num)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num==0:\\n            return \"Zero\"\\n        belowTwenty = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\\n                    \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\\n                    \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \\n            \"Eighty\", \"Ninety\"]\\n        def helper(num: int) -> str:\\n            if num<20:\\n                s = belowTwenty[num]\\n            elif num<100:\\n                s = tens[num//10] + \" \" + belowTwenty[num%10]\\n            elif num<1000:\\n                s = helper(num//100) + \" Hundred \" + helper(num%100)\\n            elif num<1000000:\\n                s = helper(num//1000) + \" Thousand \" + helper(num%1000)\\n            elif num<1000000000:\\n                s = helper(num//1000000) + \" Million \" + helper(num%1000000)\\n            else:\\n                s = helper(num//1000000000) + \" Billion \" + helper(num%1000000000)\\n            return s.strip()\\n        return helper(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237000,
                "title": "c-solution-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    string numberToWords(int num) {\\n        vector<pair<int,string>> v={{1000000000,\"Billion\"},{1000000,\"Million\"},{1000,\"Thousand\"},{100,\"Hundred\"},{90,\"Ninety\"},{80,\"Eighty\"},{70,\"Seventy\"},{60,\"Sixty\"},{50,\"Fifty\"},{40,\"Forty\"},{30,\"Thirty\"},{20,\"Twenty\"},{19,\"Nineteen\"},{18,\"Eighteen\"},{17,\"Seventeen\"},{16,\"Sixteen\"},{15,\"Fifteen\"},{14,\"Fourteen\"},{13,\"Thirteen\"}, {12,\"Twelve\"}, {11,\"Eleven\"},{10,\"Ten\"},{9,\"Nine\"},{8, \"Eight\"},{7,\"Seven\"},{6,\"Six\"},{5,\"Five\"},{4,\"Four\"},{3,\"Three\"},{2,\"Two\"},{1,\"One\"}};\\n        \\n        if(num==0)return \"Zero\";\\n        \\n        for(auto it:v){\\n            if(num>=it.first){\\n                return (num>=100 ? numberToWords(num/it.first)+\" \" : \"\")+it.second+(num%it.first==0 ? \"\" : \" \"+numberToWords(num%it.first));\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string numberToWords(int num) {\\n        vector<pair<int,string>> v={{1000000000,\"Billion\"},{1000000,\"Million\"},{1000,\"Thousand\"},{100,\"Hundred\"},{90,\"Ninety\"},{80,\"Eighty\"},{70,\"Seventy\"},{60,\"Sixty\"},{50,\"Fifty\"},{40,\"Forty\"},{30,\"Thirty\"},{20,\"Twenty\"},{19,\"Nineteen\"},{18,\"Eighteen\"},{17,\"Seventeen\"},{16,\"Sixteen\"},{15,\"Fifteen\"},{14,\"Fourteen\"},{13,\"Thirteen\"}, {12,\"Twelve\"}, {11,\"Eleven\"},{10,\"Ten\"},{9,\"Nine\"},{8, \"Eight\"},{7,\"Seven\"},{6,\"Six\"},{5,\"Five\"},{4,\"Four\"},{3,\"Three\"},{2,\"Two\"},{1,\"One\"}};\\n        \\n        if(num==0)return \"Zero\";\\n        \\n        for(auto it:v){\\n            if(num>=it.first){\\n                return (num>=100 ? numberToWords(num/it.first)+\" \" : \"\")+it.second+(num%it.first==0 ? \"\" : \" \"+numberToWords(num%it.first));\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021835,
                "title": "easy-to-understand-recursive-python-solution",
                "content": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if not num: return \\'Zero\\'\\n        ones = {1:\\' One\\', 2:\\' Two\\', 3:\\' Three\\', 4:\\' Four\\', 5:\\' Five\\', 6:\\' Six\\', 7:\\' Seven\\', 8:\\' Eight\\', 9:\\' Nine\\', \\n\\t\\t\\t\\t10:\\' Ten\\', 11:\\' Eleven\\', 12:\\' Twelve\\', 13:\\' Thirteen\\', 14:\\' Fourteen\\', 15:\\' Fifteen\\', 16:\\' Sixteen\\', \\n\\t\\t\\t\\t17:\\' Seventeen\\', 18:\\' Eighteen\\', 19:\\' Nineteen\\'}\\n        tens = {2:\\' Twenty\\', 3:\\' Thirty\\', 4:\\' Forty\\', 5:\\' Fifty\\', 6:\\' Sixty\\', 7:\\' Seventy\\', 8:\\' Eighty\\', 9:\\' Ninety\\'}\\n\\t\\t\\n        self.output = \\'\\'\\n        def wordify(num):\\n            if num // 1000000000:\\n                wordify(num // 1000000000)\\n                self.output += \\' Billion\\'\\n                wordify(num % 1000000000)\\n            elif num // 1000000:\\n                wordify(num // 1000000)\\n                self.output += \\' Million\\'\\n                wordify(num % 1000000)\\n            elif num // 1000:\\n                wordify(num // 1000)\\n                self.output += \\' Thousand\\'\\n                wordify(num % 1000)\\n            elif num // 100:\\n                wordify(num // 100)\\n                self.output += \\' Hundred\\'\\n                wordify(num % 100)\\n            elif num // 10 - 1 > 0:\\n                self.output += tens[num // 10]\\n                wordify(num % 10)\\n            elif num:\\n                self.output += ones[num]\\n        wordify(num)\\n        return self.output[1:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if not num: return \\'Zero\\'\\n        ones = {1:\\' One\\', 2:\\' Two\\', 3:\\' Three\\', 4:\\' Four\\', 5:\\' Five\\', 6:\\' Six\\', 7:\\' Seven\\', 8:\\' Eight\\', 9:\\' Nine\\', \\n\\t\\t\\t\\t10:\\' Ten\\', 11:\\' Eleven\\', 12:\\' Twelve\\', 13:\\' Thirteen\\', 14:\\' Fourteen\\', 15:\\' Fifteen\\', 16:\\' Sixteen\\', \\n\\t\\t\\t\\t17:\\' Seventeen\\', 18:\\' Eighteen\\', 19:\\' Nineteen\\'}\\n        tens = {2:\\' Twenty\\', 3:\\' Thirty\\', 4:\\' Forty\\', 5:\\' Fifty\\', 6:\\' Sixty\\', 7:\\' Seventy\\', 8:\\' Eighty\\', 9:\\' Ninety\\'}\\n\\t\\t\\n        self.output = \\'\\'\\n        def wordify(num):\\n            if num // 1000000000:\\n                wordify(num // 1000000000)\\n                self.output += \\' Billion\\'\\n                wordify(num % 1000000000)\\n            elif num // 1000000:\\n                wordify(num // 1000000)\\n                self.output += \\' Million\\'\\n                wordify(num % 1000000)\\n            elif num // 1000:\\n                wordify(num // 1000)\\n                self.output += \\' Thousand\\'\\n                wordify(num % 1000)\\n            elif num // 100:\\n                wordify(num // 100)\\n                self.output += \\' Hundred\\'\\n                wordify(num % 100)\\n            elif num // 10 - 1 > 0:\\n                self.output += tens[num // 10]\\n                wordify(num % 10)\\n            elif num:\\n                self.output += ones[num]\\n        wordify(num)\\n        return self.output[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837846,
                "title": "python3-runtime-16-ms-faster-than-99-14-memory-13-9-mb-less-than-96-31",
                "content": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num == 0: \\n\\t\\t\\treturn \\'Zero\\'\\n        ds1 = [1000000000, 1000000, 1000, 100]\\n        ws1 = [\\'Billion\\', \\'Million\\', \\'Thousand\\', \\'Hundred\\']\\n        ds2 = [90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\\n        ws2 = [\\'Ninety\\', \\'Eighty\\', \\'Seventy\\', \\'Sixty\\', \\'Fifty\\', \\'Forty\\', \\'Thirty\\', \\'Twenty\\', \\n               \\'Nineteen\\', \\'Eighteen\\', \\'Seventeen\\', \\'Sixteen\\', \\'Fifteen\\', \\'Fourteen\\', \\'Thirteen\\', \\'Twelve\\', \\'Eleven\\',\\'Ten\\',\\n               \\'Nine\\', \\'Eight\\', \\'Seven\\', \\'Six\\', \\'Five\\', \\'Four\\', \\'Three\\', \\'Two\\', \\'One\\'] \\n        i = 0\\n        ls = []\\n        while i < len(ds1):\\n            if num >= ds1[i]:\\n                num1, num = divmod(num, ds1[i])\\n                if num1:\\n                    ls.append(self.numberToWords(num1))\\n                    ls.append(ws1[i]) \\n            i += 1\\n        i = 0\\n        while num:\\n            if num < ds2[i]:\\n                i += 1\\n            else:\\n                num -= ds2[i]\\n                ls.append(ws2[i])\\n        return \\' \\'.join(ls)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num == 0: \\n\\t\\t\\treturn \\'Zero\\'\\n        ds1 = [1000000000, 1000000, 1000, 100]\\n        ws1 = [\\'Billion\\', \\'Million\\', \\'Thousand\\', \\'Hundred\\']\\n        ds2 = [90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\\n        ws2 = [\\'Ninety\\', \\'Eighty\\', \\'Seventy\\', \\'Sixty\\', \\'Fifty\\', \\'Forty\\', \\'Thirty\\', \\'Twenty\\', \\n               \\'Nineteen\\', \\'Eighteen\\', \\'Seventeen\\', \\'Sixteen\\', \\'Fifteen\\', \\'Fourteen\\', \\'Thirteen\\', \\'Twelve\\', \\'Eleven\\',\\'Ten\\',\\n               \\'Nine\\', \\'Eight\\', \\'Seven\\', \\'Six\\', \\'Five\\', \\'Four\\', \\'Three\\', \\'Two\\', \\'One\\'] \\n        i = 0\\n        ls = []\\n        while i < len(ds1):\\n            if num >= ds1[i]:\\n                num1, num = divmod(num, ds1[i])\\n                if num1:\\n                    ls.append(self.numberToWords(num1))\\n                    ls.append(ws1[i]) \\n            i += 1\\n        i = 0\\n        while num:\\n            if num < ds2[i]:\\n                i += 1\\n            else:\\n                num -= ds2[i]\\n                ls.append(ws2[i])\\n        return \\' \\'.join(ls)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721460,
                "title": "my-java-solution",
                "content": "class Solution {\\n    static String[] oneTo19 = {\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\"\\n\\t\\t\\t,\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\\n\\t\\t\\t\"Eighteen\",\"Nineteen\"};\\n\\tstatic String[] twentyTo100 = {\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\"\\n\\t\\t\\t,\"Eighty\",\"Ninety\"};\\n    public String numberToWords(int num) {\\n        if(num==0) return \"Zero\";\\n        else return cal(num);\\n    }\\n    public String cal(int num){\\n    if(num<20) return oneTo19[num];\\n\\t\\telse if(num<100) return twentyTo100[num/10] +(num%10==0? \"\":\" \"+oneTo19[num%10]);\\n\\t\\telse if(num<1000)\\n\\t\\t\\treturn oneTo19[num/100]+\" Hundred\"+(num%100==0?\"\":\" \")+cal(num%100);\\n\\t\\telse if(num<1000000)\\n\\t\\t\\treturn cal(num/1000)+\" Thousand\"+(num%1000==0?\"\":\" \")+cal(num%1000);\\n\\t\\telse if(num<1000000000)\\n\\t\\t\\treturn cal(num/1000000)+\" Million\"+(num%1000000==0?\"\":\" \")+cal(num%1000000);\\n        else if(num>=1000000000)\\n\\t\\t\\treturn cal(num/1000000000)+\" Billion\"+(num%1000000000==0?\"\":\" \")+cal(num%1000000000);\\n\\t\\treturn null;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static String[] oneTo19 = {\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\"\\n\\t\\t\\t,\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\\n\\t\\t\\t\"Eighteen\",\"Nineteen\"}",
                "codeTag": "Java"
            },
            {
                "id": 1640857,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    String[] belowTen = {\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"};\\n    String[] belowTwenty = {\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n    String[] belowHundred = {\"\",\"Ten\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n    public String numberToWords(int num) {\\n        if(num==0)\\n            return \"Zero\";\\n        return helper(num);\\n    }\\n    private String helper(int num) {\\n        String res = new String();\\n        if(num<10) res=belowTen[num];\\n        else if(num<20) res=belowTwenty[num-10];\\n        else if(num<100) res=belowHundred[num/10]+\" \"+helper(num%10);\\n        else if(num<1000) res=helper(num/100)+\" Hundred \"+helper(num%100);\\n        else if(num<1000000) res= helper(num/1000)+\" Thousand \"+ helper(num%1000);\\n        else if(num<1000000000) res= helper(num/1000000)+\" Million \"+ helper(num%1000000);\\n        else\\n            res=helper(num/1000000000)+\" Billion \"+ helper(num%1000000000);\\n        return res.trim();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String[] belowTen = {\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"};\\n    String[] belowTwenty = {\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n    String[] belowHundred = {\"\",\"Ten\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n    public String numberToWords(int num) {\\n        if(num==0)\\n            return \"Zero\";\\n        return helper(num);\\n    }\\n    private String helper(int num) {\\n        String res = new String();\\n        if(num<10) res=belowTen[num];\\n        else if(num<20) res=belowTwenty[num-10];\\n        else if(num<100) res=belowHundred[num/10]+\" \"+helper(num%10);\\n        else if(num<1000) res=helper(num/100)+\" Hundred \"+helper(num%100);\\n        else if(num<1000000) res= helper(num/1000)+\" Thousand \"+ helper(num%1000);\\n        else if(num<1000000000) res= helper(num/1000000)+\" Million \"+ helper(num%1000000);\\n        else\\n            res=helper(num/1000000000)+\" Billion \"+ helper(num%1000000000);\\n        return res.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615249,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public final String[] belowTwenty = {\"\",\"One\", \"Two\", \"Three\", \"Four\",\"Five\", \"Six\",\"Seven\", \"Eight\", \"Nine\",\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\",\"Nineteen\"};\\n      public  final String[] belowHundred ={\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" };\\n    public String numberToWords(int num) {\\n        if(num==0) return \"Zero\";\\n        else\\n            return helper(num);\\n    }\\n    public String helper(int num){\\n        StringBuilder result =new StringBuilder();\\n        if(num<20){\\n           result.append(belowTwenty[num]);\\n        }\\n        else if (num<100){\\n            result.append(belowHundred[num/10]) .append(\" \").append(helper(num%10));\\n        }\\n        else if(num<1000){\\n            result.append(helper(num/100)).append(\" Hundred \").append(helper(num%100));\\n        }\\n        else if(num<1000000){\\n            result.append(helper(num/1000)).append(\" Thousand \").append(helper(num%1000));\\n        }\\n        else if(num<1000000000){\\n            result.append(helper(num/1000000)).append(\" Million \").append(helper(num%1000000));\\n        }\\n        else{\\n            result.append(helper(num/1000000000)). append(\" Billion \").append(helper(num%1000000000));\\n        }  \\n      return result.toString().trim();  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public final String[] belowTwenty = {\"\",\"One\", \"Two\", \"Three\", \"Four\",\"Five\", \"Six\",\"Seven\", \"Eight\", \"Nine\",\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\",\"Nineteen\"};\\n      public  final String[] belowHundred ={\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" };\\n    public String numberToWords(int num) {\\n        if(num==0) return \"Zero\";\\n        else\\n            return helper(num);\\n    }\\n    public String helper(int num){\\n        StringBuilder result =new StringBuilder();\\n        if(num<20){\\n           result.append(belowTwenty[num]);\\n        }\\n        else if (num<100){\\n            result.append(belowHundred[num/10]) .append(\" \").append(helper(num%10));\\n        }\\n        else if(num<1000){\\n            result.append(helper(num/100)).append(\" Hundred \").append(helper(num%100));\\n        }\\n        else if(num<1000000){\\n            result.append(helper(num/1000)).append(\" Thousand \").append(helper(num%1000));\\n        }\\n        else if(num<1000000000){\\n            result.append(helper(num/1000000)).append(\" Million \").append(helper(num%1000000));\\n        }\\n        else{\\n            result.append(helper(num/1000000000)). append(\" Billion \").append(helper(num%1000000000));\\n        }  \\n      return result.toString().trim();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610762,
                "title": "if-solution-is-helpful-please-upvote-me",
                "content": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num==0:\\n            return \"Zero\"\\n        d={1: \\'One\\', 2: \\'Two\\', 3: \"Three\", 4: \\'Four\\', 5: \\'Five\\', 6: \\'Six\\', 7: \\'Seven\\', 8: \\'Eight\\', 9: \\'Nine\\',\\n         10: \\'Ten\\', 11: \\'Eleven\\', 12: \\'Twelve\\', 13: \\'Thirteen\\', 14: \\'Fourteen\\', 15:\\'Fifteen\\', 16: \\'Sixteen\\',\\n         17: \\'Seventeen\\', 18: \\'Eighteen\\', 19: \\'Nineteen\\', 20: \\'Twenty\\', 30: \\'Thirty\\', 40: \\'Forty\\', 50: \\'Fifty\\',\\n         60: \\'Sixty\\', 70: \\'Seventy\\', 80: \\'Eighty\\', 90: \\'Ninety\\', 100: \\'Hundred\\', 1000: \\'Thousand\\', 1000000: \\'Million\\', 1000000000: \\'Billion\\'}\\n        res=\"\"\\n        ans=self.solve(num,d,res)\\n        return \" \".join(ans.split())\\n    def solve(self,num,d,res):\\n        if num==0:\\n            return res\\n        elif num<20:\\n            res+=d[num]\\n            return res\\n        elif 20<=num<100:\\n            res+=d[(num//10)*10]+\" \"+self.solve(num%10,d,res)\\n            return res\\n        elif 100<=num<1000:\\n            res+=d[(num//100)]+ \" \" +d[100]+\" \"+self.solve(num%100,d,res)\\n            return res\\n        elif 1000<=num<1000000:\\n            res+=self.solve(num//1000,d,res)+\" \"+d[1000]+\" \"+self.solve(num%1000,d,res)\\n            return res\\n        elif 1000000<=num<1000000000:\\n            res+=self.solve(num//1000000,d,res)+ \" \" + d[1000000] +\" \"+self.solve(num%1000000,d,res)\\n            return res\\n        else:\\n            res+=self.solve(num//1000000000,d,res)+\" \"+d[1000000000]+\" \"+self.solve(num%1000000000,d,res)\\n            return res",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "class Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num==0:\\n            return \"Zero\"\\n        d={1: \\'One\\', 2: \\'Two\\', 3: \"Three\", 4: \\'Four\\', 5: \\'Five\\', 6: \\'Six\\', 7: \\'Seven\\', 8: \\'Eight\\', 9: \\'Nine\\',\\n         10: \\'Ten\\', 11: \\'Eleven\\', 12: \\'Twelve\\', 13: \\'Thirteen\\', 14: \\'Fourteen\\', 15:\\'Fifteen\\', 16: \\'Sixteen\\',\\n         17: \\'Seventeen\\', 18: \\'Eighteen\\', 19: \\'Nineteen\\', 20: \\'Twenty\\', 30: \\'Thirty\\', 40: \\'Forty\\', 50: \\'Fifty\\',\\n         60: \\'Sixty\\', 70: \\'Seventy\\', 80: \\'Eighty\\', 90: \\'Ninety\\', 100: \\'Hundred\\', 1000: \\'Thousand\\', 1000000: \\'Million\\', 1000000000: \\'Billion\\'}",
                "codeTag": "Java"
            },
            {
                "id": 1510400,
                "title": "java-clean-code-100-faster",
                "content": "```\\npublic String numberToWords(int num) {\\n        \\n        if(num == 0) {\\n            return \"Zero\";\\n        }\\n        \\n        int bil = (int)(num / (Math.pow(10, 9)));\\n        int mil = (int)((num % Math.pow(10, 9)) / Math.pow(10, 6));\\n        int thou = (int)((num % Math.pow(10, 6)) / Math.pow(10, 3));\\n        int rem = (int) (num % Math.pow(10, 3));\\n        \\n        StringBuilder sb = new StringBuilder();\\n        if(bil != 0) {\\n            sb.append(findTuple(bil));\\n            sb.append(\" \");\\n            sb.append(\"Billion \");\\n        }\\n        if(mil != 0) {\\n            sb.append(findTuple(mil));\\n            sb.append(\" \");\\n            sb.append(\"Million \");\\n        }\\n        if(thou != 0) {\\n            sb.append(findTuple(thou));\\n            sb.append(\" \");\\n            sb.append(\"Thousand \");\\n        }\\n        if(rem != 0) {\\n            sb.append(findTuple(rem));\\n        }\\n        return sb.toString().trim();\\n    }\\n    \\n    private String findTuple(int tuple) {\\n        int h = tuple/100;\\n        int t = (tuple%100) / 10;\\n        int o = tuple%10;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        if( h != 0) {\\n            sb.append(findSingles(h));\\n            sb.append(\" \");\\n            sb.append(\"Hundred \");\\n        }\\n        \\n        if(t >= 2) {\\n            sb.append(findSingles(t*10));\\n            sb.append(\" \");\\n        }\\n        \\n        if(t == 1) {\\n            o = o+10;\\n        }\\n        \\n        if(o != 0) {\\n            sb.append(findSingles(o));\\n        }\\n        return sb.toString().trim();\\n    }\\n    \\n    private String findSingles(int single) {\\n        switch(single) {\\n            case 1: return \"One\";\\n            case 2: return \"Two\";\\n            case 3: return \"Three\";\\n            case 4: return \"Four\";\\n            case 5: return \"Five\";\\n            case 6: return \"Six\";\\n            case 7: return \"Seven\";\\n            case 8: return \"Eight\";\\n            case 9: return \"Nine\";\\n            case 10: return \"Ten\";\\n            case 11: return \"Eleven\";\\n            case 12: return \"Twelve\";\\n            case 13: return \"Thirteen\";\\n            case 14: return \"Fourteen\";\\n            case 15: return \"Fifteen\";\\n            case 16: return \"Sixteen\";\\n            case 17: return \"Seventeen\";\\n            case 18: return \"Eighteen\";\\n            case 19: return \"Nineteen\";\\n            case 20: return \"Twenty\";\\n            case 30: return \"Thirty\";\\n            case 40: return \"Forty\";\\n            case 50: return \"Fifty\";\\n            case 60: return \"Sixty\";\\n            case 70: return \"Seventy\";\\n            case 80: return \"Eighty\";\\n            case 90: return \"Ninety\";\\n        }\\n        return null;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic String numberToWords(int num) {\\n        \\n        if(num == 0) {\\n            return \"Zero\";\\n        }\\n        \\n        int bil = (int)(num / (Math.pow(10, 9)));\\n        int mil = (int)((num % Math.pow(10, 9)) / Math.pow(10, 6));\\n        int thou = (int)((num % Math.pow(10, 6)) / Math.pow(10, 3));\\n        int rem = (int) (num % Math.pow(10, 3));\\n        \\n        StringBuilder sb = new StringBuilder();\\n        if(bil != 0) {\\n            sb.append(findTuple(bil));\\n            sb.append(\" \");\\n            sb.append(\"Billion \");\\n        }\\n        if(mil != 0) {\\n            sb.append(findTuple(mil));\\n            sb.append(\" \");\\n            sb.append(\"Million \");\\n        }\\n        if(thou != 0) {\\n            sb.append(findTuple(thou));\\n            sb.append(\" \");\\n            sb.append(\"Thousand \");\\n        }\\n        if(rem != 0) {\\n            sb.append(findTuple(rem));\\n        }\\n        return sb.toString().trim();\\n    }\\n    \\n    private String findTuple(int tuple) {\\n        int h = tuple/100;\\n        int t = (tuple%100) / 10;\\n        int o = tuple%10;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        if( h != 0) {\\n            sb.append(findSingles(h));\\n            sb.append(\" \");\\n            sb.append(\"Hundred \");\\n        }\\n        \\n        if(t >= 2) {\\n            sb.append(findSingles(t*10));\\n            sb.append(\" \");\\n        }\\n        \\n        if(t == 1) {\\n            o = o+10;\\n        }\\n        \\n        if(o != 0) {\\n            sb.append(findSingles(o));\\n        }\\n        return sb.toString().trim();\\n    }\\n    \\n    private String findSingles(int single) {\\n        switch(single) {\\n            case 1: return \"One\";\\n            case 2: return \"Two\";\\n            case 3: return \"Three\";\\n            case 4: return \"Four\";\\n            case 5: return \"Five\";\\n            case 6: return \"Six\";\\n            case 7: return \"Seven\";\\n            case 8: return \"Eight\";\\n            case 9: return \"Nine\";\\n            case 10: return \"Ten\";\\n            case 11: return \"Eleven\";\\n            case 12: return \"Twelve\";\\n            case 13: return \"Thirteen\";\\n            case 14: return \"Fourteen\";\\n            case 15: return \"Fifteen\";\\n            case 16: return \"Sixteen\";\\n            case 17: return \"Seventeen\";\\n            case 18: return \"Eighteen\";\\n            case 19: return \"Nineteen\";\\n            case 20: return \"Twenty\";\\n            case 30: return \"Thirty\";\\n            case 40: return \"Forty\";\\n            case 50: return \"Fifty\";\\n            case 60: return \"Sixty\";\\n            case 70: return \"Seventy\";\\n            case 80: return \"Eighty\";\\n            case 90: return \"Ninety\";\\n        }\\n        return null;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468577,
                "title": "c-ultra-fast-scalable-compact",
                "content": "```\\nclass Solution {\\nprivate:\\n    const int thresholds[4] {1000000000,1000000,1000, 100};\\n    const string powDictonary[4] = {\" Billion\",\" Million\",\" Thousand\", \" Hundred\"};\\n    const string lowDictonary[16] = {\"Zero\", \"One\", \"Two\", \"Three\", \\n                              \"Four\", \"Five\",\"Six\", \"Seven\", \"Eight\", \"Nine\",\\n                              \"Ten\", \"Eleven\", \"Twelve\",\"Thirteen\",\"Fourteen\"};\\n    const string sub100Dic[8] = {\"Twen\",\"Thir\",\"For\",\\n                                 \"Fif\",\"Six\",\"Seven\",\"Eigh\",\"Nine\"};\\npublic:      \\n    \\n    string numberToWords(int num, int thresholdInx = 0) {         \\n        if(num < 15) return lowDictonary[num];\\n        if(num < 20) return sub100Dic[num - 12] + \"teen\";\\n        if(num < 100) return sub100Dic[num/10 -2]+(num % 10 ? \"ty \" + lowDictonary[num % 10] : \"ty\");\\n        \\n        for(; num < thresholds[thresholdInx]; thresholdInx++);                \\n        int x = thresholds[thresholdInx], up = num / x, below = num % x;\\n               \\n        if(!below) return numberToWords(up, thresholdInx + 1) + powDictonary[thresholdInx];\\n        \\n        return numberToWords(up, thresholdInx + 1) + powDictonary[thresholdInx]  + \" \" + \\n            numberToWords(below, thresholdInx + 1);       \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int thresholds[4] {1000000000,1000000,1000, 100};\\n    const string powDictonary[4] = {\" Billion\",\" Million\",\" Thousand\", \" Hundred\"};\\n    const string lowDictonary[16] = {\"Zero\", \"One\", \"Two\", \"Three\", \\n                              \"Four\", \"Five\",\"Six\", \"Seven\", \"Eight\", \"Nine\",\\n                              \"Ten\", \"Eleven\", \"Twelve\",\"Thirteen\",\"Fourteen\"};\\n    const string sub100Dic[8] = {\"Twen\",\"Thir\",\"For\",\\n                                 \"Fif\",\"Six\",\"Seven\",\"Eigh\",\"Nine\"};\\npublic:      \\n    \\n    string numberToWords(int num, int thresholdInx = 0) {         \\n        if(num < 15) return lowDictonary[num];\\n        if(num < 20) return sub100Dic[num - 12] + \"teen\";\\n        if(num < 100) return sub100Dic[num/10 -2]+(num % 10 ? \"ty \" + lowDictonary[num % 10] : \"ty\");\\n        \\n        for(; num < thresholds[thresholdInx]; thresholdInx++);                \\n        int x = thresholds[thresholdInx], up = num / x, below = num % x;\\n               \\n        if(!below) return numberToWords(up, thresholdInx + 1) + powDictonary[thresholdInx];\\n        \\n        return numberToWords(up, thresholdInx + 1) + powDictonary[thresholdInx]  + \" \" + \\n            numberToWords(below, thresholdInx + 1);       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320223,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\n#define billion 1000000000\\n#define million 1000000\\n#define thousand 1000\\n#define hundred 100\\n\\tstring tensNum(int num) {\\n\\t\\tswitch (num) {\\n\\t\\tcase 1:return \"Ten \";\\n\\t\\tcase 2:return \"Twenty \";\\n\\t\\tcase 3:return \"Thirty \";\\n\\t\\tcase 4:return \"Forty \";\\n\\t\\tcase 5:return \"Fifty \";\\n\\t\\tcase 6:return \"Sixty \";\\n\\t\\tcase 7:return \"Seventy \";\\n\\t\\tcase 8:return \"Eighty \";\\n\\t\\tcase 9:return \"Ninety \";\\n\\t\\tdefaut:\\n\\t\\t\\treturn\"\";\\n\\t\\t}\\n\\t\\treturn \"\";\\n\\t}\\n\\tstring teensVal(int num) {\\n\\t\\tswitch (num) {\\n\\t\\tcase 11:return \"Eleven \";\\n\\t\\tcase 12:return \"Twelve \";\\n\\t\\tcase 13:return \"Thirteen \";\\n\\t\\tcase 14:return \"Fourteen \";\\n\\t\\tcase 15:return \"Fifteen \";\\n\\t\\tcase 16:return \"Sixteen \";\\n\\t\\tcase 17:return \"Seventeen \";\\n\\t\\tcase 18:return \"Eighteen \";\\n\\t\\tcase 19:return \"Nineteen \";\\n\\t\\tdefaut:\\n\\t\\t\\treturn\"\";\\n\\t\\t}\\n\\t\\treturn \"\";\\n\\t}\\n\\tstring onesVal(int num) {\\n\\t\\tswitch (num) {\\n\\t\\tcase 0:return \"Zero \";\\n\\t\\tcase 1:return \"One \";\\n\\t\\tcase 2:return \"Two \";\\n\\t\\tcase 3:return \"Three \";\\n\\t\\tcase 4:return \"Four \";\\n\\t\\tcase 5:return \"Five \";\\n\\t\\tcase 6:return \"Six \";\\n\\t\\tcase 7:return \"Seven \";\\n\\t\\tcase 8:return \"Eight \";\\n\\t\\tcase 9:return \"Nine \";\\n\\t\\tdefaut:\\n\\t\\t\\treturn\"\";\\n\\t\\t}\\n\\t\\treturn \"\";\\n\\t}\\n\\tstring tensVal(int& num) {\\n\\t\\tstring ans;\\n\\t\\tif (num % 10 == 0) {\\n\\t\\t\\tans += tensNum(num / 10);\\n\\t\\t}\\n\\t\\telse if (num < 20 && num > 10) {\\n\\t\\t\\tans += teensVal(num);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (num > 10) {\\n\\t\\t\\t\\tint val = num / 10;\\n\\t\\t\\t\\tans += tensNum(val);\\n\\t\\t\\t\\tnum %= 10;\\n\\t\\t\\t}\\n\\t\\t\\tans += onesVal(num);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\tstring hundreds(int& num) {\\n\\t\\tstring ans;\\n\\t\\tif (num / hundred) {\\n\\t\\t\\tint val = num / hundred;\\n\\t\\t\\tans += onesVal(val) + \"Hundred \";\\n\\t\\t\\tnum %= hundred;\\n\\t\\t}\\n\\t\\tans += tensVal(num);\\n\\t\\treturn ans;\\n\\t}\\npublic:\\n\\n\\tstring numberToWords(int num) {\\n\\t\\tif (num == 0)\\n\\t\\t\\treturn \"Zero\";\\n\\t\\tstring ans;\\n\\t\\tif (num / billion) {\\n\\t\\t\\tint val = num / billion;\\n\\t\\t\\tans += hundreds(val) + \"Billion \";\\n\\t\\t\\tnum %= billion;\\n\\t\\t}\\n\\t\\tif (num / million) {\\n\\t\\t\\tint val = num / million;\\n\\t\\t\\tans += hundreds(val) + \"Million \";\\n\\t\\t\\tnum %= million;\\n\\t\\t}\\n\\t\\tif (num / thousand) {\\n\\t\\t\\tint val = num / thousand;\\n\\t\\t\\tans += hundreds(val) + \"Thousand \";\\n\\t\\t\\tnum %= thousand;\\n\\t\\t}\\n\\t\\tans += hundreds(num);\\n\\t\\tif (!ans.empty())\\n\\t\\t\\tans = ans.substr(0, ans.size() - 1);\\n\\t\\treturn ans;\\n\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n#define billion 1000000000\\n#define million 1000000\\n#define thousand 1000\\n#define hundred 100\\n\\tstring tensNum(int num) {\\n\\t\\tswitch (num) {\\n\\t\\tcase 1:return \"Ten \";\\n\\t\\tcase 2:return \"Twenty \";\\n\\t\\tcase 3:return \"Thirty \";\\n\\t\\tcase 4:return \"Forty \";\\n\\t\\tcase 5:return \"Fifty \";\\n\\t\\tcase 6:return \"Sixty \";\\n\\t\\tcase 7:return \"Seventy \";\\n\\t\\tcase 8:return \"Eighty \";\\n\\t\\tcase 9:return \"Ninety \";\\n\\t\\tdefaut:\\n\\t\\t\\treturn\"\";\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1245009,
                "title": "clean-fastest-c-solution-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    string onesName(int n) {  // function for naming digits between 1 to 9\\n        switch(n) {\\n            case 1 : return \"One\";break;\\n            case 2: return \"Two\"; break;\\n            case 3: return \"Three\"; break;\\n            case 4: return \"Four\"; break;\\n            case 5: return \"Five\"; break;\\n            case 6: return \"Six\"; break;\\n            case 7: return \"Seven\"; break;\\n            case 8: return \"Eight\"; break;\\n            case 9: return \"Nine\"; break;\\n        }\\n        return \"\";\\n    }\\n    \\n    string tensName(int n) {  // function for naming digits 10, 20, 30... 90.\\n        switch(n) {\\n            case 1: return \"Ten\"; break;\\n            case 2: return \"Twenty\"; break;\\n            case 3: return \"Thirty\"; break;\\n            case 4: return \"Forty\"; break;\\n            case 5: return \"Fifty\"; break;\\n            case 6: return \"Sixty\"; break;\\n            case 7: return \"Seventy\"; break;\\n            case 8: return \"Eighty\"; break;\\n            case 9: return \"Ninety\"; break;\\n        }\\n        return \"\";\\n    }\\n    \\n    string giveThreeName(int n) {  // full name of digits from 1 to 100\\n        string res = \"\";\\n        if(n / 100 > 0)\\n            res += onesName(n / 100) + \" Hundred\";\\n        \\n        if(n / 100 > 0 && n % 100 > 0) res += \" \";  // managing spaces\\n        \\n        int t = n % 100;\\n        if(t >= 20 || t <= 10) {\\n            if(t / 10 > 0)\\n                res += tensName(t / 10);\\n            \\n            if(t / 10 > 0 && t % 10 > 0) res += \" \";\\n            \\n            if(t % 10 > 0)\\n                res += onesName(t % 10);\\n        }\\n        else {  // for the part where the tens number is between 11 to 19\\n            switch(t) {\\n                case 11: res += \"Eleven\"; break;\\n                case 12: res += \"Twelve\"; break;\\n                case 13: res += \"Thirteen\"; break;\\n                case 14: res += \"Fourteen\"; break;\\n                case 15: res += \"Fifteen\"; break;\\n                case 16: res += \"Sixteen\"; break;\\n                case 17: res += \"Seventeen\"; break;\\n                case 18: res += \"Eighteen\"; break;\\n                case 19: res += \"Nineteen\"; break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        \\n        string res = \"\";\\n        res = giveThreeName(num % 1000) + res;\\n        num /= 1000;\\n        \\n        if(num > 0) {\\n            if(num % 1000 > 0)\\n                res = giveThreeName(num % 1000) + \" Thousand \" + res;\\n            num /= 1000;\\n        }\\n        \\n        if(num > 0) {\\n            if(num % 1000 > 0)\\n                res = giveThreeName(num % 1000) + \" Million \" + res;\\n            num /= 1000;\\n        }\\n        \\n        if(num > 0) {\\n            res = giveThreeName(num % 1000) + \" Billion \" + res;\\n        }\\n        \\n        if(res.back() == \\' \\') res.pop_back();\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string onesName(int n) {  // function for naming digits between 1 to 9\\n        switch(n) {\\n            case 1 : return \"One\";break;\\n            case 2: return \"Two\"; break;\\n            case 3: return \"Three\"; break;\\n            case 4: return \"Four\"; break;\\n            case 5: return \"Five\"; break;\\n            case 6: return \"Six\"; break;\\n            case 7: return \"Seven\"; break;\\n            case 8: return \"Eight\"; break;\\n            case 9: return \"Nine\"; break;\\n        }\\n        return \"\";\\n    }\\n    \\n    string tensName(int n) {  // function for naming digits 10, 20, 30... 90.\\n        switch(n) {\\n            case 1: return \"Ten\"; break;\\n            case 2: return \"Twenty\"; break;\\n            case 3: return \"Thirty\"; break;\\n            case 4: return \"Forty\"; break;\\n            case 5: return \"Fifty\"; break;\\n            case 6: return \"Sixty\"; break;\\n            case 7: return \"Seventy\"; break;\\n            case 8: return \"Eighty\"; break;\\n            case 9: return \"Ninety\"; break;\\n        }\\n        return \"\";\\n    }\\n    \\n    string giveThreeName(int n) {  // full name of digits from 1 to 100\\n        string res = \"\";\\n        if(n / 100 > 0)\\n            res += onesName(n / 100) + \" Hundred\";\\n        \\n        if(n / 100 > 0 && n % 100 > 0) res += \" \";  // managing spaces\\n        \\n        int t = n % 100;\\n        if(t >= 20 || t <= 10) {\\n            if(t / 10 > 0)\\n                res += tensName(t / 10);\\n            \\n            if(t / 10 > 0 && t % 10 > 0) res += \" \";\\n            \\n            if(t % 10 > 0)\\n                res += onesName(t % 10);\\n        }\\n        else {  // for the part where the tens number is between 11 to 19\\n            switch(t) {\\n                case 11: res += \"Eleven\"; break;\\n                case 12: res += \"Twelve\"; break;\\n                case 13: res += \"Thirteen\"; break;\\n                case 14: res += \"Fourteen\"; break;\\n                case 15: res += \"Fifteen\"; break;\\n                case 16: res += \"Sixteen\"; break;\\n                case 17: res += \"Seventeen\"; break;\\n                case 18: res += \"Eighteen\"; break;\\n                case 19: res += \"Nineteen\"; break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        \\n        string res = \"\";\\n        res = giveThreeName(num % 1000) + res;\\n        num /= 1000;\\n        \\n        if(num > 0) {\\n            if(num % 1000 > 0)\\n                res = giveThreeName(num % 1000) + \" Thousand \" + res;\\n            num /= 1000;\\n        }\\n        \\n        if(num > 0) {\\n            if(num % 1000 > 0)\\n                res = giveThreeName(num % 1000) + \" Million \" + res;\\n            num /= 1000;\\n        }\\n        \\n        if(num > 0) {\\n            res = giveThreeName(num % 1000) + \" Billion \" + res;\\n        }\\n        \\n        if(res.back() == \\' \\') res.pop_back();\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011294,
                "title": "iterative-python-solution-that-beats-90",
                "content": "The observation is, we process numbers under 1000 many times potentially. Say 5,393,212  in million portion, there is 5; in thousand portion, 393; in last portion, 212.  So we create a function called n2w that takes number under 1000 and return corresponding words. The main loop seperates the Billion, Million and Thousand parts, and calls n2w when needed.\\n\\n```\\n    def numberToWords(self, num: int) -> str:\\n        if num == 0: return \\'Zero\\'\\n\\n        m = { 1000000000: \\'Billion\\', 1000000: \\'Million\\', 1000: \\'Thousand\\'}\\n        \\n        n = { 100: \\'Hundred\\', 90: \\'Ninety\\', 80: \\'Eighty\\', 70:\\'Seventy\\', 60: \\'Sixty\\', 50: \\'Fifty\\', 40: \\'Forty\\',\\n         30: \\'Thirty\\', 20: \\'Twenty\\', 19: \\'Nineteen\\', 18: \\'Eighteen\\', 17: \\'Seventeen\\', 16: \\'Sixteen\\', 15: \\'Fifteen\\', 14:\\'Fourteen\\',\\n         13: \\'Thirteen\\', 12: \\'Twelve\\', 11: \\'Eleven\\', 10: \\'Ten\\', 9:\\'Nine\\', 8:\\'Eight\\', 7:\\'Seven\\', 6:\\'Six\\', 5:\\'Five\\', 4:\\'Four\\', 3:\\'Three\\', 2:\\'Two\\',1:\\'One\\'\\n        }\\n\\n        def n2w(curr):\\n            words = []\\n            if curr >= 100:\\n                words += n[curr//100], n[100]\\n                curr = curr % 100\\n\\n            for j in n:\\n                if curr >= j:\\n                    words += n[j],\\n                    curr -= j\\n            return words\\n\\n        ret = []\\n        for i in m:\\n            if num >= i:\\n                curr = num // i\\n                ret += n2w(curr)\\n                num = num % i\\n                ret += m[i],\\n        \\n        ret += n2w(num)\\n\\n        return \\' \\'.join(ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\n    def numberToWords(self, num: int) -> str:\\n        if num == 0: return \\'Zero\\'\\n\\n        m = { 1000000000: \\'Billion\\', 1000000: \\'Million\\', 1000: \\'Thousand\\'}\\n        \\n        n = { 100: \\'Hundred\\', 90: \\'Ninety\\', 80: \\'Eighty\\', 70:\\'Seventy\\', 60: \\'Sixty\\', 50: \\'Fifty\\', 40: \\'Forty\\',\\n         30: \\'Thirty\\', 20: \\'Twenty\\', 19: \\'Nineteen\\', 18: \\'Eighteen\\', 17: \\'Seventeen\\', 16: \\'Sixteen\\', 15: \\'Fifteen\\', 14:\\'Fourteen\\',\\n         13: \\'Thirteen\\', 12: \\'Twelve\\', 11: \\'Eleven\\', 10: \\'Ten\\', 9:\\'Nine\\', 8:\\'Eight\\', 7:\\'Seven\\', 6:\\'Six\\', 5:\\'Five\\', 4:\\'Four\\', 3:\\'Three\\', 2:\\'Two\\',1:\\'One\\'\\n        }\\n\\n        def n2w(curr):\\n            words = []\\n            if curr >= 100:\\n                words += n[curr//100], n[100]\\n                curr = curr % 100\\n\\n            for j in n:\\n                if curr >= j:\\n                    words += n[j],\\n                    curr -= j\\n            return words\\n\\n        ret = []\\n        for i in m:\\n            if num >= i:\\n                curr = num // i\\n                ret += n2w(curr)\\n                num = num % i\\n                ret += m[i],\\n        \\n        ret += n2w(num)\\n\\n        return \\' \\'.join(ret)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 972047,
                "title": "java-solution-1-ms-100",
                "content": "```\\n\\nclass Solution {\\n    \\n     public String units(long num) {\\n        switch((int)num) {\\n            case 1: return \"One\";\\n            case 2: return \"Two\";\\n            case 3: return \"Three\";\\n            case 4: return \"Four\";\\n            case 5: return \"Five\";\\n            case 6: return \"Six\";\\n            case 7: return \"Seven\";\\n            case 8: return \"Eight\";\\n            case 9: return \"Nine\";\\n            case 10: return \"Ten\";\\n            case 11: return \"Eleven\";\\n            case 12: return \"Twelve\";\\n            case 13: return \"Thirteen\";\\n            case 14: return \"Fourteen\";\\n            case 15: return \"Fifteen\";\\n            case 16: return \"Sixteen\";\\n            case 17: return \"Seventeen\";\\n            case 18: return \"Eighteen\";\\n            case 19: return \"Nineteen\";\\n        }\\n        return \"\";\\n    }\\n    \\n     public String tens(long num) {\\n        switch((int)num) {\\n            case 2: return \"Twenty\";\\n            case 3: return \"Thirty\";\\n            case 4: return \"Forty\";\\n            case 5: return \"Fifty\";\\n            case 6: return \"Sixty\";\\n            case 7: return \"Seventy\";\\n            case 8: return \"Eighty\";\\n            case 9: return \"Ninety\";\\n        }\\n        return \"\";\\n    }\\n    \\n    public String numberToWords(long num) {\\n        \\n        if(num == 0)\\n            return \"Zero\";\\n                 \\n        StringBuilder output = new StringBuilder();\\n                        \\n        while(num > 0){\\n            if (num < 20){\\n                output.append(units(num));\\n                num -= num;\\n            }\\n            else if(num < 100){\\n                output.append(tens(num / 10));\\n                num = num % 10;\\n            }else if(num < 1000){\\n                output.append(units(num / 100));\\n                output.append(\" Hundred\");\\n                num = num % 100;\\n            }else if(num < 1000000){\\n                output.append(numberToWords(num / 1000));\\n                output.append(\" Thousand\");\\n                num = num % 1000;\\n            }else if(num < 1000000000){\\n                output.append(numberToWords(num / 1000000));\\n                output.append(\" Million\");\\n                num = num % 1000000;\\n            }else {\\n                output.append(numberToWords(num / 1000000000));\\n                output.append(\" Billion\");\\n                num = num % 1000000000;\\n            }\\n            \\n            if(num > 0){\\n                output.append(\" \");\\n            }\\n        }\\n        \\n        return output.toString();\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n     public String units(long num) {\\n        switch((int)num) {\\n            case 1: return \"One\";\\n            case 2: return \"Two\";\\n            case 3: return \"Three\";\\n            case 4: return \"Four\";\\n            case 5: return \"Five\";\\n            case 6: return \"Six\";\\n            case 7: return \"Seven\";\\n            case 8: return \"Eight\";\\n            case 9: return \"Nine\";\\n            case 10: return \"Ten\";\\n            case 11: return \"Eleven\";\\n            case 12: return \"Twelve\";\\n            case 13: return \"Thirteen\";\\n            case 14: return \"Fourteen\";\\n            case 15: return \"Fifteen\";\\n            case 16: return \"Sixteen\";\\n            case 17: return \"Seventeen\";\\n            case 18: return \"Eighteen\";\\n            case 19: return \"Nineteen\";\\n        }\\n        return \"\";\\n    }\\n    \\n     public String tens(long num) {\\n        switch((int)num) {\\n            case 2: return \"Twenty\";\\n            case 3: return \"Thirty\";\\n            case 4: return \"Forty\";\\n            case 5: return \"Fifty\";\\n            case 6: return \"Sixty\";\\n            case 7: return \"Seventy\";\\n            case 8: return \"Eighty\";\\n            case 9: return \"Ninety\";\\n        }\\n        return \"\";\\n    }\\n    \\n    public String numberToWords(long num) {\\n        \\n        if(num == 0)\\n            return \"Zero\";\\n                 \\n        StringBuilder output = new StringBuilder();\\n                        \\n        while(num > 0){\\n            if (num < 20){\\n                output.append(units(num));\\n                num -= num;\\n            }\\n            else if(num < 100){\\n                output.append(tens(num / 10));\\n                num = num % 10;\\n            }else if(num < 1000){\\n                output.append(units(num / 100));\\n                output.append(\" Hundred\");\\n                num = num % 100;\\n            }else if(num < 1000000){\\n                output.append(numberToWords(num / 1000));\\n                output.append(\" Thousand\");\\n                num = num % 1000;\\n            }else if(num < 1000000000){\\n                output.append(numberToWords(num / 1000000));\\n                output.append(\" Million\");\\n                num = num % 1000000;\\n            }else {\\n                output.append(numberToWords(num / 1000000000));\\n                output.append(\" Billion\");\\n                num = num % 1000000000;\\n            }\\n            \\n            if(num > 0){\\n                output.append(\" \");\\n            }\\n        }\\n        \\n        return output.toString();\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919404,
                "title": "clean-java-solution-1ms",
                "content": "```\\nclass Solution {\\n    private static final String[] ones = new String[]{\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"};\\n    private static final String[] tens = new String[]{\"Ten\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n    private static final String[] special = new String[] {\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"\\n    };\\n    \\n    private static final int billion = 1000000000;\\n    private static final int million = 1000000;\\n    private static final int thousand = 1000;\\n    \\n    public String numberToWords(int num) {\\n        if (num == 0) {\\n            return \"Zero\";\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        boolean flag = false;\\n        if (num >= billion) {\\n            int b = num / billion;\\n            getSegment(b, sb);\\n            sb.append(\" Billion\");\\n            num = num % billion;\\n            flag = true;\\n        }\\n        if (num >= million) {\\n            if (flag) sb.append(\\' \\');\\n            int m = num / million;\\n            getSegment(m, sb);\\n            sb.append(\" Million\");\\n            num = num % million;\\n            flag = true;\\n        }\\n        if (num >= thousand) {\\n            if (flag) sb.append(\\' \\');\\n            int  t = num / thousand;\\n            getSegment(t, sb);\\n            sb.append(\" Thousand\");\\n            num = num % thousand;\\n            flag = true;\\n        }\\n        \\n        if (flag && num > 0) sb.append(\\' \\');\\n        getSegment(num, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void getSegment(int val, StringBuilder sb) {\\n        boolean flag = false;\\n        \\n        if (val >= 100) {\\n            int hunds = val / 100;\\n            sb.append(ones[hunds-1]);\\n            sb.append(\\' \\');\\n            sb.append(\"Hundred\");\\n            val = val % 100;\\n            flag = true;\\n        }\\n        if (val >= 10) {\\n            if (flag) sb.append(\\' \\');\\n            if (val >= 11 && val <= 19) {\\n                int ind = val - 10;\\n                sb.append(special[ind-1]);\\n                val = 0;\\n            } else {\\n                int t = val / 10;\\n                sb.append(tens[t-1]);\\n                val = val % 10;\\n            }               \\n            flag = true;\\n        }\\n        if (val >= 1) {\\n            if (flag) sb.append(\\' \\');\\n            sb.append(ones[val-1]);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private static final String[] ones = new String[]{\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"}",
                "codeTag": "Java"
            },
            {
                "id": 867830,
                "title": "c-0ms-clean-and-short-solution-and-no-worry-about-corner-cases",
                "content": "The trick is to add space on each string, and at the end, we will only have one space on the back, we can pop it back, and get the correct answer.\\nAnother trick is to add \"\" as for zero thus we do not need to judge for this special case. \\n```\\nclass Solution { \\n    vector<string> twen{\"\", \"One \", \"Two \", \"Three \", \"Four \", \"Five \", \"Six \", \"Seven \", \"Eight \", \"Nine \", \"Ten \", \"Eleven \", \"Twelve \", \"Thirteen \", \"Fourteen \", \"Fifteen \", \"Sixteen \", \"Seventeen \", \"Eighteen \", \"Nineteen \"};\\n    vector<string> tens{\"Twenty \", \"Thirty \", \"Forty \", \"Fifty \", \"Sixty \", \"Seventy \", \"Eighty \", \"Ninety \"};\\n    vector<string> thou{\"\", \"Thousand \", \"Million \", \"Billion \"};\\n    \\n    string base(int num) {\\n        string ans;\\n        if (num >= 100) {\\n            ans += twen[num / 100] + \"Hundred \";\\n            num %= 100;\\n        }\\n        if (num >= 20) {\\n\\t\\t\\tans += tens[num / 10 - 2];\\n\\t\\t\\tnum %= 10;\\n\\t\\t}\\n        ans += twen[num];\\n        return ans;\\n    }\\n    \\npublic:\\n    string numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        string ans;\\n        for (int j = 1e9, i = 3; j > 0; i--, j /= 1000) {\\n            if (num < j) continue;\\n            ans += base(num / j) + thou[i];\\n            num %= j;\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    vector<string> twen{\"\", \"One \", \"Two \", \"Three \", \"Four \", \"Five \", \"Six \", \"Seven \", \"Eight \", \"Nine \", \"Ten \", \"Eleven \", \"Twelve \", \"Thirteen \", \"Fourteen \", \"Fifteen \", \"Sixteen \", \"Seventeen \", \"Eighteen \", \"Nineteen \"};\\n    vector<string> tens{\"Twenty \", \"Thirty \", \"Forty \", \"Fifty \", \"Sixty \", \"Seventy \", \"Eighty \", \"Ninety \"};\\n    vector<string> thou{\"\", \"Thousand \", \"Million \", \"Billion \"};\\n    \\n    string base(int num) {\\n        string ans;\\n        if (num >= 100) {\\n            ans += twen[num / 100] + \"Hundred \";\\n            num %= 100;\\n        }\\n        if (num >= 20) {\\n\\t\\t\\tans += tens[num / 10 - 2];\\n\\t\\t\\tnum %= 10;\\n\\t\\t}\\n        ans += twen[num];\\n        return ans;\\n    }\\n    \\npublic:\\n    string numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        string ans;\\n        for (int j = 1e9, i = 3; j > 0; i--, j /= 1000) {\\n            if (num < j) continue;\\n            ans += base(num / j) + thou[i];\\n            num %= j;\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805996,
                "title": "simple-97-java",
                "content": "```\\nclass Solution {\\n    public String numberToWords(int num) {\\n        StringBuilder res = new StringBuilder(\"\");\\n        String[] s = {\"Hundred\", \"Thousand\", \"Million\", \"Billion\"};\\n        String[] w0 = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n        String[] w1 = {\"Zero\",\"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        String[] w2 = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\" ,\"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        // num < 2^31 -> at most 10 digits we want to know how many billions, millions,\\n        // thousands and the rest we have. so we need 4 numbers when #3 = billions, #2 = millions etc.\\n        // every number is 3 digits, for example - 1234567891 = 1B + 234M + 567T + 891\\n        int[] numArr = new int[4];   \\n        int i = 0;\\n        while(num>0){\\n            numArr[i++] += (num%1000);\\n            num/=1000;\\n        }\\n        //numArr[3]*Billion + numArr[2]*Million + numArr[1]*Thusand + numArr[0] = num\\n        for(int i = 3; i>=0 ;i--){ \\n            // example: num = 123,123-> numArr[0] = numArr[1] = 123\\n            if(numArr[i]!=0){\\n                if(numArr[i] > 99){ \\n                    res.append(w0[numArr[i]/100]).append(\" \").append(s[0]).append(\" \"); // One Hundred\\n                    numArr[i] = numArr[i] - (numArr[i]/100)*100; // numArr[i] = 23\\n                }if(numArr[i] > 19){ \\n                    res.append(w1[numArr[i]/10]).append(\" \"); // Twenty\\n                    numArr[i] = numArr[i] - (numArr[i]/10)*10; // numArr[i] = 3\\n                }if(numArr[i]  > 9){\\n                    res.append(w2[numArr[i]%10]).append(\" \");\\n                    numArr[i] = 0;\\n                }if(numArr[i]  > 0)\\n                    res.append(w0[numArr[i]]).append(\" \");  // Three\\n                if(i!=0)    \\n                    res.append(s[i]).append(\" \"); // when i=1: Thousand\\n            }\\n        }\\n        // if num == 0 nothing was done -> res = \"\";\\n        return res.length() == 0 ? w0[0] : res.substring(0,res.length()-1).toString(); //SB toString, remove last space\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String numberToWords(int num) {\\n        StringBuilder res = new StringBuilder(\"\");\\n        String[] s = {\"Hundred\", \"Thousand\", \"Million\", \"Billion\"};\\n        String[] w0 = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n        String[] w1 = {\"Zero\",\"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        String[] w2 = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\" ,\"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        // num < 2^31 -> at most 10 digits we want to know how many billions, millions,\\n        // thousands and the rest we have. so we need 4 numbers when #3 = billions, #2 = millions etc.\\n        // every number is 3 digits, for example - 1234567891 = 1B + 234M + 567T + 891\\n        int[] numArr = new int[4];   \\n        int i = 0;\\n        while(num>0){\\n            numArr[i++] += (num%1000);\\n            num/=1000;\\n        }\\n        //numArr[3]*Billion + numArr[2]*Million + numArr[1]*Thusand + numArr[0] = num\\n        for(int i = 3; i>=0 ;i--){ \\n            // example: num = 123,123-> numArr[0] = numArr[1] = 123\\n            if(numArr[i]!=0){\\n                if(numArr[i] > 99){ \\n                    res.append(w0[numArr[i]/100]).append(\" \").append(s[0]).append(\" \"); // One Hundred\\n                    numArr[i] = numArr[i] - (numArr[i]/100)*100; // numArr[i] = 23\\n                }if(numArr[i] > 19){ \\n                    res.append(w1[numArr[i]/10]).append(\" \"); // Twenty\\n                    numArr[i] = numArr[i] - (numArr[i]/10)*10; // numArr[i] = 3\\n                }if(numArr[i]  > 9){\\n                    res.append(w2[numArr[i]%10]).append(\" \");\\n                    numArr[i] = 0;\\n                }if(numArr[i]  > 0)\\n                    res.append(w0[numArr[i]]).append(\" \");  // Three\\n                if(i!=0)    \\n                    res.append(s[i]).append(\" \"); // when i=1: Thousand\\n            }\\n        }\\n        // if num == 0 nothing was done -> res = \"\";\\n        return res.length() == 0 ? w0[0] : res.substring(0,res.length()-1).toString(); //SB toString, remove last space\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797515,
                "title": "python-divide-and-conquer-three-steps",
                "content": "```python\\ndef numberToWords(self, num: int) -> str:\\n\\n\\tif num == 0: return \"Zero\"\\n\\n\\tp1 = {1 : \"One\",\\n\\t\\t  2 : \"Two\",\\n\\t\\t  3 : \"Three\",\\n\\t\\t  4 : \"Four\",\\n\\t\\t  5 : \"Five\",\\n\\t\\t  6 : \"Six\",\\n\\t\\t  7 : \"Seven\",\\n\\t\\t  8 : \"Eight\",\\n\\t\\t  9 : \"Nine\"}\\n\\n\\tp2 = {2 : \"Twenty\",\\n\\t\\t  3 : \"Thirty\",\\n\\t\\t  4 : \"Forty\",\\n\\t\\t  5 : \"Fifty\",\\n\\t\\t  6 : \"Sixty\",\\n\\t\\t  7 : \"Seventy\",\\n\\t\\t  8 : \"Eighty\",\\n\\t\\t  9 : \"Ninety\"}\\n\\n\\tteen = {10 :\"Ten\",\\n\\t\\t\\t 11 :\"Eleven\",\\n\\t\\t\\t 12 :\"Twelve\",\\n\\t\\t\\t 13 :\"Thirteen\",\\n\\t\\t\\t 14 :\"Fourteen\",\\n\\t\\t\\t 15 :\"Fifteen\",\\n\\t\\t\\t 16 :\"Sixteen\",\\n\\t\\t\\t 17 :\"Seventeen\",\\n\\t\\t\\t 18 :\"Eighteen\",\\n\\t\\t\\t 19 :\"Nineteen\"}\\n\\n\\t# 1. Split num into groups of 3\\n\\tstrings = []\\n\\tcount = 0\\n\\tcurr = \\'\\'\\n\\tfor n in str(num)[::-1]:\\n\\t\\tif count == 3:\\n\\t\\t\\tstrings.append(curr[::-1])\\n\\t\\t\\tcount = 1\\n\\t\\t\\tcurr = n\\n\\t\\telse:\\n\\t\\t\\tcurr += n\\n\\t\\t\\tcount += 1\\n\\telse:\\n\\t\\tstrings.append(curr[::-1])\\n\\n\\tsegment = [\"\", \"Thousand\", \"Million\", \"Billion\"][:len(strings)]\\n\\n\\t# 2. Convert num to words as if each were 0 <= num <= 999\\n\\tres = []\\n\\twhile strings:\\n\\t\\ts = strings.pop()\\n\\t\\tcurr = \\'\\'\\n\\t\\tif (len(s) == 3) and (s[0] != \\'0\\'):\\n\\t\\t\\tcurr += p1[int(s[0])] + \" Hundred\"\\n\\n\\t\\ta = int(s[-2:])\\n\\t\\tif 0 < a < 10:\\n\\t\\t\\tcurr += \\' \\' + p1[a]\\n\\t\\telif 10 <= a <= 19:\\n\\t\\t\\tcurr += \\' \\' + teen[a]\\n\\t\\telif 20 <= a <= 99:\\n\\t\\t\\ta, b = int(s[-2]), int(s[-1])\\n\\t\\t\\tif b:\\n\\t\\t\\t\\tcurr += \\' \\' + p2[a] + \\' \\' + p1[b]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcurr += \\' \\' + p2[a]\\n\\n\\t\\t# 3. Concatenate strings separated by \"Thousand\", \"Million\" and \"Billion\"\\n\\t\\tif curr:\\n\\t\\t\\tres.append(curr)\\n\\t\\t\\tres.append(segment.pop())\\n\\t\\telse:\\n\\t\\t\\tsegment.pop()\\n\\n\\treturn \\' \\'.join(res).strip().replace(\\'  \\',\\' \\')\\n```\\n<img src=\"https://assets.leetcode.com/users/images/e4dfe120-a701-4abf-a6c5-b749a4ef3e7b_1597693942.4971507.png\" width=\"55%\">",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```python\\ndef numberToWords(self, num: int) -> str:\\n\\n\\tif num == 0: return \"Zero\"\\n\\n\\tp1 = {1 : \"One\",\\n\\t\\t  2 : \"Two\",\\n\\t\\t  3 : \"Three\",\\n\\t\\t  4 : \"Four\",\\n\\t\\t  5 : \"Five\",\\n\\t\\t  6 : \"Six\",\\n\\t\\t  7 : \"Seven\",\\n\\t\\t  8 : \"Eight\",\\n\\t\\t  9 : \"Nine\"}\\n\\n\\tp2 = {2 : \"Twenty\",\\n\\t\\t  3 : \"Thirty\",\\n\\t\\t  4 : \"Forty\",\\n\\t\\t  5 : \"Fifty\",\\n\\t\\t  6 : \"Sixty\",\\n\\t\\t  7 : \"Seventy\",\\n\\t\\t  8 : \"Eighty\",\\n\\t\\t  9 : \"Ninety\"}\\n\\n\\tteen = {10 :\"Ten\",\\n\\t\\t\\t 11 :\"Eleven\",\\n\\t\\t\\t 12 :\"Twelve\",\\n\\t\\t\\t 13 :\"Thirteen\",\\n\\t\\t\\t 14 :\"Fourteen\",\\n\\t\\t\\t 15 :\"Fifteen\",\\n\\t\\t\\t 16 :\"Sixteen\",\\n\\t\\t\\t 17 :\"Seventeen\",\\n\\t\\t\\t 18 :\"Eighteen\",\\n\\t\\t\\t 19 :\"Nineteen\"}\\n\\n\\t# 1. Split num into groups of 3\\n\\tstrings = []\\n\\tcount = 0\\n\\tcurr = \\'\\'\\n\\tfor n in str(num)[::-1]:\\n\\t\\tif count == 3:\\n\\t\\t\\tstrings.append(curr[::-1])\\n\\t\\t\\tcount = 1\\n\\t\\t\\tcurr = n\\n\\t\\telse:\\n\\t\\t\\tcurr += n\\n\\t\\t\\tcount += 1\\n\\telse:\\n\\t\\tstrings.append(curr[::-1])\\n\\n\\tsegment = [\"\", \"Thousand\", \"Million\", \"Billion\"][:len(strings)]\\n\\n\\t# 2. Convert num to words as if each were 0 <= num <= 999\\n\\tres = []\\n\\twhile strings:\\n\\t\\ts = strings.pop()\\n\\t\\tcurr = \\'\\'\\n\\t\\tif (len(s) == 3) and (s[0] != \\'0\\'):\\n\\t\\t\\tcurr += p1[int(s[0])] + \" Hundred\"\\n\\n\\t\\ta = int(s[-2:])\\n\\t\\tif 0 < a < 10:\\n\\t\\t\\tcurr += \\' \\' + p1[a]\\n\\t\\telif 10 <= a <= 19:\\n\\t\\t\\tcurr += \\' \\' + teen[a]\\n\\t\\telif 20 <= a <= 99:\\n\\t\\t\\ta, b = int(s[-2]), int(s[-1])\\n\\t\\t\\tif b:\\n\\t\\t\\t\\tcurr += \\' \\' + p2[a] + \\' \\' + p1[b]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcurr += \\' \\' + p2[a]\\n\\n\\t\\t# 3. Concatenate strings separated by \"Thousand\", \"Million\" and \"Billion\"\\n\\t\\tif curr:\\n\\t\\t\\tres.append(curr)\\n\\t\\t\\tres.append(segment.pop())\\n\\t\\telse:\\n\\t\\t\\tsegment.pop()\\n\\n\\treturn \\' \\'.join(res).strip().replace(\\'  \\',\\' \\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 738197,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private final String[] SPECIALS = {\"\",\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private final String[] TENS = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\",\"Seventy\", \"Eighty\", \"Ninety\"};\\n    private final String[] THOUSANDS = {\"\", \"Thousand\", \"Million\", \"Billion\"};\\n    \\n    public String numberToWords(int num) {\\n        if (num == 0)\\n            return \"Zero\";\\n        int index = 0;\\n        String res = \"\";\\n        while (num > 0){\\n            if (num % 1000 != 0){\\n                res = helper(num % 1000) + THOUSANDS[index] + \" \" + res;\\n            }\\n            index++;\\n            num /= 1000;\\n        }\\n        return res.trim();\\n    }\\n    \\n    private String helper(int num){\\n        if (num == 0){\\n            return \"\";\\n        } else if (num < 20){\\n            return SPECIALS[num] + \" \";\\n        } else if (num < 100){\\n            return TENS[num / 10] + \" \" + helper(num % 10);\\n        } else {\\n            return SPECIALS[num / 100] + \" Hundred \" + helper(num % 100);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private final String[] SPECIALS = {\"\",\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private final String[] TENS = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\",\"Seventy\", \"Eighty\", \"Ninety\"};\\n    private final String[] THOUSANDS = {\"\", \"Thousand\", \"Million\", \"Billion\"};\\n    \\n    public String numberToWords(int num) {\\n        if (num == 0)\\n            return \"Zero\";\\n        int index = 0;\\n        String res = \"\";\\n        while (num > 0){\\n            if (num % 1000 != 0){\\n                res = helper(num % 1000) + THOUSANDS[index] + \" \" + res;\\n            }\\n            index++;\\n            num /= 1000;\\n        }\\n        return res.trim();\\n    }\\n    \\n    private String helper(int num){\\n        if (num == 0){\\n            return \"\";\\n        } else if (num < 20){\\n            return SPECIALS[num] + \" \";\\n        } else if (num < 100){\\n            return TENS[num / 10] + \" \" + helper(num % 10);\\n        } else {\\n            return SPECIALS[num / 100] + \" Hundred \" + helper(num % 100);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633286,
                "title": "c-easy-solution-runtime-faster-than-85-33-memory-usage-less-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    string numtoword(int digit) //this function return number < 100 to string\\n\\t{\\n    if (digit == 1) return \"One\";\\n    if (digit == 2) return \"Two\";\\n    if (digit == 3) return \"Three\";\\n    if (digit == 4) return \"Four\";\\n    if (digit == 5) return \"Five\";\\n    if (digit == 6) return \"Six\";\\n    if (digit == 7) return \"Seven\";\\n    if (digit == 8) return \"Eight\";\\n    if (digit == 9) return \"Nine\";\\n    if (digit == 10) return \"Ten\";\\n    if (digit == 11) return \"Eleven\";\\n    if (digit == 12) return \"Twelve\";\\n    if (digit == 13) return \"Thirteen\";\\n    if (digit == 14) return \"Fourteen\";\\n    if (digit == 15) return \"Fifteen\";\\n    if (digit == 16) return \"Sixteen\";\\n    if (digit == 17) return \"Seventeen\";\\n    if (digit == 18) return \"Eighteen\";\\n    if (digit == 19) return \"Nineteen\";\\n    if (digit >= 90) return \"Ninety\";\\n    if (digit >= 80) return \"Eighty\";\\n    if (digit >= 70) return \"Seventy\";\\n    if (digit >= 60) return \"Sixty\";\\n    if (digit >= 50) return \"Fifty\";\\n    if (digit >= 40) return \"Forty\";\\n    if (digit >= 30) return \"Thirty\";\\n    if (digit >= 20) return \"Twenty\";\\n    return{};\\n        \\n}\\n     string numberToWords(int num) {\\n        string str;\\n    if(num==0) //check if the input is 0\\n    {\\n        str=\"Zero\";\\n        return str;\\n    }\\n     if(num/1000000000>0) // check the billion then return the function itself to return < 1000000000;\\n     {\\n         int a=num/1000000000;\\n         str=numberToWords(a)+\" Billion \";\\n         num=num-a*1000000000;\\n     }\\n    if(num/1000000>0) // check the million then return the function itself to return < 1000000;\\n    {\\n        int b=num/1000000;\\n        str=str+numberToWords(b)+\" Million \";\\n        num=num-b*1000000;\\n    }\\n    if(num/1000>0) // check the thousand then return the function itself to return < 1000;\\n    {\\n        int c=num/1000;\\n        str=str+numberToWords(c)+\" Thousand \";\\n        num=num-c*1000;\\n        \\n    }\\n    if(num/100>0) //hundred, we use the above function to return < 999 value\\n    {\\n        int d=num/100; \\n        str=str+numtoword(d)+\" Hundred \";\\n        num=num-d*100;\\n     \\n    }\\n    if(num>20)\\n    {\\n        int e=num/10;\\n        str=str+numtoword(num);\\n        if(num%10 != 0)\\n        {\\n        num=num-e*10;\\n        str=str+\\' \\'+numtoword(num);\\n        }\\n    }\\n    else str=str+numtoword(num);\\n    int last=str.size()-1; \\n    if(str[last]==\\' \\'){\\n        str.erase(last,1);  // delete the space of the string\\n    }\\n    return str;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string numtoword(int digit) //this function return number < 100 to string\\n\\t{\\n    if (digit == 1) return \"One\";\\n    if (digit == 2) return \"Two\";\\n    if (digit == 3) return \"Three\";\\n    if (digit == 4) return \"Four\";\\n    if (digit == 5) return \"Five\";\\n    if (digit == 6) return \"Six\";\\n    if (digit == 7) return \"Seven\";\\n    if (digit == 8) return \"Eight\";\\n    if (digit == 9) return \"Nine\";\\n    if (digit == 10) return \"Ten\";\\n    if (digit == 11) return \"Eleven\";\\n    if (digit == 12) return \"Twelve\";\\n    if (digit == 13) return \"Thirteen\";\\n    if (digit == 14) return \"Fourteen\";\\n    if (digit == 15) return \"Fifteen\";\\n    if (digit == 16) return \"Sixteen\";\\n    if (digit == 17) return \"Seventeen\";\\n    if (digit == 18) return \"Eighteen\";\\n    if (digit == 19) return \"Nineteen\";\\n    if (digit >= 90) return \"Ninety\";\\n    if (digit >= 80) return \"Eighty\";\\n    if (digit >= 70) return \"Seventy\";\\n    if (digit >= 60) return \"Sixty\";\\n    if (digit >= 50) return \"Fifty\";\\n    if (digit >= 40) return \"Forty\";\\n    if (digit >= 30) return \"Thirty\";\\n    if (digit >= 20) return \"Twenty\";\\n    return{};\\n        \\n}\\n     string numberToWords(int num) {\\n        string str;\\n    if(num==0) //check if the input is 0\\n    {\\n        str=\"Zero\";\\n        return str;\\n    }\\n     if(num/1000000000>0) // check the billion then return the function itself to return < 1000000000;\\n     {\\n         int a=num/1000000000;\\n         str=numberToWords(a)+\" Billion \";\\n         num=num-a*1000000000;\\n     }\\n    if(num/1000000>0) // check the million then return the function itself to return < 1000000;\\n    {\\n        int b=num/1000000;\\n        str=str+numberToWords(b)+\" Million \";\\n        num=num-b*1000000;\\n    }\\n    if(num/1000>0) // check the thousand then return the function itself to return < 1000;\\n    {\\n        int c=num/1000;\\n        str=str+numberToWords(c)+\" Thousand \";\\n        num=num-c*1000;\\n        \\n    }\\n    if(num/100>0) //hundred, we use the above function to return < 999 value\\n    {\\n        int d=num/100; \\n        str=str+numtoword(d)+\" Hundred \";\\n        num=num-d*100;\\n     \\n    }\\n    if(num>20)\\n    {\\n        int e=num/10;\\n        str=str+numtoword(num);\\n        if(num%10 != 0)\\n        {\\n        num=num-e*10;\\n        str=str+\\' \\'+numtoword(num);\\n        }\\n    }\\n    else str=str+numtoword(num);\\n    int last=str.size()-1; \\n    if(str[last]==\\' \\'){\\n        str.erase(last,1);  // delete the space of the string\\n    }\\n    return str;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561398,
                "title": "simpler-javascript-solution",
                "content": "```\\nlet numberToWords = num => {\\n  if (num === 0) return \\'Zero\\';\\n  // prettier-ignore\\n  let unit = [\\'\\', \\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\', \\'Ten\\', \\'Eleven\\', \\'Twelve\\', \\'Thirteen\\', \\'Fourteen\\', \\'Fifteen\\', \\'Sixteen\\', \\'Seventeen\\', \\'Eighteen\\', \\'Nineteen\\'];\\n  let tens = [\\'\\', \\'Ten\\', \\'Twenty\\', \\'Thirty\\', \\'Forty\\', \\'Fifty\\', \\'Sixty\\', \\'Seventy\\', \\'Eighty\\', \\'Ninety\\'];\\n  let exp = [\\'\\', \\' Thousand\\', \\' Million\\', \\' Billion\\'];\\n\\n  let threeToWord = sub => {\\n    let word = \\'\\';\\n    if (sub > 99) {\\n      word = unit[Math.floor(sub / 100)] + \\' Hundred \\';\\n      sub = sub % 100;\\n    }\\n    if (sub > 19) {\\n      word += tens[Math.floor(sub / 10)] + \\' \\';\\n      sub = sub % 10;\\n    }\\n    word += unit[sub];\\n    return word.trim();\\n  };\\n\\n  let translate = [];\\n\\n  for (let i = 0; num; i++, num = Math.floor(num / 1000)) {\\n    let three = num % 1000;\\n    let word = threeToWord(three);\\n    if (word) {\\n      translate.unshift(word + exp[i]);\\n    }\\n  }\\n\\n  return translate.join(\\' \\').trim();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet numberToWords = num => {\\n  if (num === 0) return \\'Zero\\';\\n  // prettier-ignore\\n  let unit = [\\'\\', \\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\', \\'Ten\\', \\'Eleven\\', \\'Twelve\\', \\'Thirteen\\', \\'Fourteen\\', \\'Fifteen\\', \\'Sixteen\\', \\'Seventeen\\', \\'Eighteen\\', \\'Nineteen\\'];\\n  let tens = [\\'\\', \\'Ten\\', \\'Twenty\\', \\'Thirty\\', \\'Forty\\', \\'Fifty\\', \\'Sixty\\', \\'Seventy\\', \\'Eighty\\', \\'Ninety\\'];\\n  let exp = [\\'\\', \\' Thousand\\', \\' Million\\', \\' Billion\\'];\\n\\n  let threeToWord = sub => {\\n    let word = \\'\\';\\n    if (sub > 99) {\\n      word = unit[Math.floor(sub / 100)] + \\' Hundred \\';\\n      sub = sub % 100;\\n    }\\n    if (sub > 19) {\\n      word += tens[Math.floor(sub / 10)] + \\' \\';\\n      sub = sub % 10;\\n    }\\n    word += unit[sub];\\n    return word.trim();\\n  };\\n\\n  let translate = [];\\n\\n  for (let i = 0; num; i++, num = Math.floor(num / 1000)) {\\n    let three = num % 1000;\\n    let word = threeToWord(three);\\n    if (word) {\\n      translate.unshift(word + exp[i]);\\n    }\\n  }\\n\\n  return translate.join(\\' \\').trim();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 533745,
                "title": "javascript-solution-91",
                "content": "```\\nconst map = {\\n  0: \\'Zero\\',\\n  1: \\'One\\',\\n  2: \\'Two\\',\\n  3: \\'Three\\',\\n  4: \\'Four\\',\\n  5: \\'Five\\',\\n  6: \\'Six\\',\\n  7: \\'Seven\\',\\n  8: \\'Eight\\',\\n  9: \\'Nine\\',\\n  10: \\'Ten\\',\\n  11: \\'Eleven\\',\\n  12: \\'Twelve\\',\\n  13: \\'Thirteen\\',\\n  14: \\'Fourteen\\',\\n  15: \\'Fifteen\\',\\n  16: \\'Sixteen\\',\\n  17: \\'Seventeen\\',\\n  18: \\'Eighteen\\',\\n  19: \\'Nineteen\\',\\n  20: \\'Twenty\\',\\n  30: \\'Thirty\\',\\n  40: \\'Forty\\',\\n  50: \\'Fifty\\',\\n  60: \\'Sixty\\',\\n  70: \\'Seventy\\',\\n  80: \\'Eighty\\',\\n  90: \\'Ninety\\',\\n}\\n\\n\\nvar numberToWords = function(num) {\\n  if (num === 0) return map[num];\\n  const groups = [\\'\\', \\'Thousand\\', \\'Million\\', \\'Billion\\'];\\n  let groupsIndex = 0;\\n  let result = \\'\\';\\n  \\n  while (num > 0) {\\n    let currentGroup = num % 1000;\\n      \\n    if (currentGroup !== 0) {\\n        if (result.length > 0) {\\n            result = parseHundreds(currentGroup) + \\' \\' + groups[groupsIndex] + \\' \\' + result;\\n        } else {\\n            result = parseHundreds(currentGroup) + \\' \\' + groups[groupsIndex];\\n        }\\n    }\\n    \\n    num = parseInt(num/1000);\\n    groupsIndex++;\\n  }\\n  \\n  return result.trim();\\n};\\n\\n\\nfunction parseHundreds(cashGroup) {\\n    const HUNDRED = \\'Hundred\\';\\n    const tensVal = cashGroup % 100;\\n    const tensString = parseTens(tensVal);\\n    const hundredsPlace = parseInt(cashGroup / 100);\\n\\n    if ( hundredsPlace === 0 ) {\\n        return tensString; // forty-seven \\n    }\\n    let result = map[hundredsPlace] + \\' \\' + HUNDRED;\\n    if (tensString) {\\n        result += \\' \\' + tensString\\n    }\\n\\n    return result; \\n}\\n  \\nfunction parseTens(val) {\\n  if (val === 0) return \\'\\'; \\n\\n  if (val < 20) {\\n    return map[val];\\n  } \\n  const tensPlace = parseInt(val /10) * 10;\\n  \\n  const onesPlace = val % 10;\\n  if (onesPlace === 0) {\\n    return map[tensPlace];\\n  }\\n  \\n  return map[tensPlace] + \\' \\' + map[val % 10];\\n}\\n```\\n\\nRuntime: 60 ms, faster than 91.33% of JavaScript online submissions for Integer to English Words.\\nMemory Usage: 35.1 MB, less than 75.00% of JavaScript online submissions for Integer to English Words.\\n\\nHundreds place is repeated for each thousands group and so is the tens and single digits. Idea is to divide each thousand group and handle the hundreds and tens place separately.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst map = {\\n  0: \\'Zero\\',\\n  1: \\'One\\',\\n  2: \\'Two\\',\\n  3: \\'Three\\',\\n  4: \\'Four\\',\\n  5: \\'Five\\',\\n  6: \\'Six\\',\\n  7: \\'Seven\\',\\n  8: \\'Eight\\',\\n  9: \\'Nine\\',\\n  10: \\'Ten\\',\\n  11: \\'Eleven\\',\\n  12: \\'Twelve\\',\\n  13: \\'Thirteen\\',\\n  14: \\'Fourteen\\',\\n  15: \\'Fifteen\\',\\n  16: \\'Sixteen\\',\\n  17: \\'Seventeen\\',\\n  18: \\'Eighteen\\',\\n  19: \\'Nineteen\\',\\n  20: \\'Twenty\\',\\n  30: \\'Thirty\\',\\n  40: \\'Forty\\',\\n  50: \\'Fifty\\',\\n  60: \\'Sixty\\',\\n  70: \\'Seventy\\',\\n  80: \\'Eighty\\',\\n  90: \\'Ninety\\',\\n}\\n\\n\\nvar numberToWords = function(num) {\\n  if (num === 0) return map[num];\\n  const groups = [\\'\\', \\'Thousand\\', \\'Million\\', \\'Billion\\'];\\n  let groupsIndex = 0;\\n  let result = \\'\\';\\n  \\n  while (num > 0) {\\n    let currentGroup = num % 1000;\\n      \\n    if (currentGroup !== 0) {\\n        if (result.length > 0) {\\n            result = parseHundreds(currentGroup) + \\' \\' + groups[groupsIndex] + \\' \\' + result;\\n        } else {\\n            result = parseHundreds(currentGroup) + \\' \\' + groups[groupsIndex];\\n        }\\n    }\\n    \\n    num = parseInt(num/1000);\\n    groupsIndex++;\\n  }\\n  \\n  return result.trim();\\n};\\n\\n\\nfunction parseHundreds(cashGroup) {\\n    const HUNDRED = \\'Hundred\\';\\n    const tensVal = cashGroup % 100;\\n    const tensString = parseTens(tensVal);\\n    const hundredsPlace = parseInt(cashGroup / 100);\\n\\n    if ( hundredsPlace === 0 ) {\\n        return tensString; // forty-seven \\n    }\\n    let result = map[hundredsPlace] + \\' \\' + HUNDRED;\\n    if (tensString) {\\n        result += \\' \\' + tensString\\n    }\\n\\n    return result; \\n}\\n  \\nfunction parseTens(val) {\\n  if (val === 0) return \\'\\'; \\n\\n  if (val < 20) {\\n    return map[val];\\n  } \\n  const tensPlace = parseInt(val /10) * 10;\\n  \\n  const onesPlace = val % 10;\\n  if (onesPlace === 0) {\\n    return map[tensPlace];\\n  }\\n  \\n  return map[tensPlace] + \\' \\' + map[val % 10];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 513526,
                "title": "clean-generic-java-recursion",
                "content": "```java\\nclass Solution {\\n    \\n    int B = 1000000000;\\n    int M = 1000000;\\n    int T = 1000;\\n    int H = 100;\\n\\n    Map<Integer, String> hund;\\n    Map<Integer, String> teen;\\n    Map<Integer, String> one;\\n    \\n    public String numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        \\n        hund = new HashMap<>();\\n        hund.put(9, \"Ninety\");\\n        hund.put(8, \"Eighty\");\\n        hund.put(7, \"Seventy\");\\n        hund.put(6, \"Sixty\");\\n        hund.put(5, \"Fifty\");\\n        hund.put(4, \"Forty\");\\n        hund.put(3, \"Thirty\");\\n        hund.put(2, \"Twenty\");\\n        \\n        teen = new HashMap<>();\\n        teen.put(19, \"Nineteen\");\\n        teen.put(18, \"Eighteen\");\\n        teen.put(17, \"Seventeen\");\\n        teen.put(16, \"Sixteen\");\\n        teen.put(15, \"Fifteen\");\\n        teen.put(14, \"Fourteen\");\\n        teen.put(13, \"Thirteen\");\\n        teen.put(12, \"Twelve\");\\n        teen.put(11, \"Eleven\");\\n        teen.put(10, \"Ten\");\\n        \\n        one = new HashMap<>();\\n        one.put(9, \"Nine\");\\n        one.put(8, \"Eight\");\\n        one.put(7, \"Seven\");\\n        one.put(6, \"Six\");\\n        one.put(5, \"Five\");\\n        one.put(4, \"Four\");\\n        one.put(3, \"Three\");\\n        one.put(2, \"Two\");\\n        one.put(1, \"One\");\\n        \\n        return convert(num).trim();\\n    }\\n    \\n    String convert(int num) {\\n        String res = \"\";\\n\\n        if (num >= B) {\\n            res = convert(num / B) + \" Billion \" + convert(num % B);\\n        } else if (num >= M) {\\n            res = convert(num / M) + \" Million \" + convert(num % M);\\n        } else if (num >= T) {\\n            res = convert(num / T) + \" Thousand \" + convert(num % T);\\n        } else if (num >= H) {\\n            res = convert(num / H) + \" Hundred \" + convert(num % H);\\n        } else if (num >= 20) {\\n            res = hund.get(num / 10) + \" \" + convert(num % 10);\\n        } else if (num >= 10) {\\n            res = teen.get(num);\\n        } else if (num > 0) {\\n            res = one.get(num);\\n        }\\n        \\n        return res.trim(); // there will be extra spaces\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    int B = 1000000000;\\n    int M = 1000000;\\n    int T = 1000;\\n    int H = 100;\\n\\n    Map<Integer, String> hund;\\n    Map<Integer, String> teen;\\n    Map<Integer, String> one;\\n    \\n    public String numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        \\n        hund = new HashMap<>();\\n        hund.put(9, \"Ninety\");\\n        hund.put(8, \"Eighty\");\\n        hund.put(7, \"Seventy\");\\n        hund.put(6, \"Sixty\");\\n        hund.put(5, \"Fifty\");\\n        hund.put(4, \"Forty\");\\n        hund.put(3, \"Thirty\");\\n        hund.put(2, \"Twenty\");\\n        \\n        teen = new HashMap<>();\\n        teen.put(19, \"Nineteen\");\\n        teen.put(18, \"Eighteen\");\\n        teen.put(17, \"Seventeen\");\\n        teen.put(16, \"Sixteen\");\\n        teen.put(15, \"Fifteen\");\\n        teen.put(14, \"Fourteen\");\\n        teen.put(13, \"Thirteen\");\\n        teen.put(12, \"Twelve\");\\n        teen.put(11, \"Eleven\");\\n        teen.put(10, \"Ten\");\\n        \\n        one = new HashMap<>();\\n        one.put(9, \"Nine\");\\n        one.put(8, \"Eight\");\\n        one.put(7, \"Seven\");\\n        one.put(6, \"Six\");\\n        one.put(5, \"Five\");\\n        one.put(4, \"Four\");\\n        one.put(3, \"Three\");\\n        one.put(2, \"Two\");\\n        one.put(1, \"One\");\\n        \\n        return convert(num).trim();\\n    }\\n    \\n    String convert(int num) {\\n        String res = \"\";\\n\\n        if (num >= B) {\\n            res = convert(num / B) + \" Billion \" + convert(num % B);\\n        } else if (num >= M) {\\n            res = convert(num / M) + \" Million \" + convert(num % M);\\n        } else if (num >= T) {\\n            res = convert(num / T) + \" Thousand \" + convert(num % T);\\n        } else if (num >= H) {\\n            res = convert(num / H) + \" Hundred \" + convert(num % H);\\n        } else if (num >= 20) {\\n            res = hund.get(num / 10) + \" \" + convert(num % 10);\\n        } else if (num >= 10) {\\n            res = teen.get(num);\\n        } else if (num > 0) {\\n            res = one.get(num);\\n        }\\n        \\n        return res.trim(); // there will be extra spaces\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454191,
                "title": "javascript-clean-soluation",
                "content": "This soluation is from https://leetcode.com/problems/integer-to-english-words/discuss/70627/Short-clean-Java-solution, written in js.\\n```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\n\\nconst belowTen = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\\nconst belowTwenty = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"];\\nconst belowHundred = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"];\\n\\nvar numberToWords = function(num) {\\n    if(num === 0) return \\'Zero\\'\\n    return helper(num);\\n};\\n\\nconst helper = (num) => {\\n    let result = \\'\\';\\n  \\n    if(num < 10) result = belowTen[num];\\n    else if(num < 20) result = belowTwenty[num-10];\\n    else if(num < 100) result = belowHundred[Math.floor(num/10)] + \\' \\' + helper(num%10);\\n    else if(num < 1000) result = belowTen[Math.floor(num/100)] + \\' Hundred \\' + helper(num % 100);\\n    else if(num < 10000) result = belowTen[Math.floor(num/1000)] + \\' Thousand \\' + helper(num % 1000);\\n    else if(num < 1000000) result = helper(Math.floor(num/1000)) + \\' Thousand \\' + helper(num%1000);\\n    else if(num < 1000000000) result = helper(Math.floor(num/1000000)) + \\' Million \\' + helper(num%1000000);\\n    else if(num < 1000000000000) result = helper(Math.floor(num/1000000000)) + \\' Billion \\' + helper(num%1000000000);\\n\\n    return result.trim();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {string}\\n */\\n\\nconst belowTen = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\\nconst belowTwenty = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"];\\nconst belowHundred = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"];\\n\\nvar numberToWords = function(num) {\\n    if(num === 0) return \\'Zero\\'\\n    return helper(num);\\n};\\n\\nconst helper = (num) => {\\n    let result = \\'\\';\\n  \\n    if(num < 10) result = belowTen[num];\\n    else if(num < 20) result = belowTwenty[num-10];\\n    else if(num < 100) result = belowHundred[Math.floor(num/10)] + \\' \\' + helper(num%10);\\n    else if(num < 1000) result = belowTen[Math.floor(num/100)] + \\' Hundred \\' + helper(num % 100);\\n    else if(num < 10000) result = belowTen[Math.floor(num/1000)] + \\' Thousand \\' + helper(num % 1000);\\n    else if(num < 1000000) result = helper(Math.floor(num/1000)) + \\' Thousand \\' + helper(num%1000);\\n    else if(num < 1000000000) result = helper(Math.floor(num/1000000)) + \\' Million \\' + helper(num%1000000);\\n    else if(num < 1000000000000) result = helper(Math.floor(num/1000000000)) + \\' Billion \\' + helper(num%1000000000);\\n\\n    return result.trim();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371404,
                "title": "python-solution-for-any-number-s-lenght",
                "content": "```\\nclass Solution(object):  \\n    def numberToWords(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        if num == 0:                     # special case\\n            return \"Zero\"\\n        number = str(num)\\n        splitedNumber = self.separate_number_by_hundreds(number)\\n        humanizedHundreds = [self.humanize_hundreds(number3) for number3 in splitedNumber]\\n        humanizedHundreds = self.append_decimal_name_to_hundreds(humanizedHundreds)\\n        finalHumanizedNumber = self.construct_final_number(humanizedHundreds)\\n        return finalHumanizedNumber\\n    \\n    \\n    def separate_number_by_hundreds(self, number):\\n        \"\"\"\\n        :param number: string of number\\n        :return: list of string numbers - splitted by every 3rd digit param\\n        :example: \"73798234\" |-> [\\'73\\', \\'798\\', \\'234\\']\\n        \"\"\"\\n        separated_operands = []\\n        ln = len(number)\\n        if ln % 3 != 0:\\n            separated_operands.append(number[:ln % 3])\\n        for k in range(ln % 3, ln, 3):\\n            separated_operands.append(number[k: k + 3])\\n        return separated_operands\\n    \\n    \\n    def humanize_hundreds(self, number3):\\n        \"\"\"\\n        :param number3: string of 3, 2 or 1-digit int number\\n        :return: humanized representation of number\\n        :example: \"178\" |-> \"One Hundred Seventy Eight\"\\n        \"\"\"\\n        res = \\'\\'\\n        numlen = len(number3)\\n        if numlen == 3:\\n            if number3[0] != \\'0\\':\\n                if number3[1] == \\'1\\':\\n                    res = \"{} Hundred {}\".format(self.digits[number3[0]], self.teens[number3[2]])\\n                elif number3[1] != \\'0\\':\\n                    res = \"{} Hundred {} {}\".format(self.digits[number3[0]], self.tens[number3[1]], self.digits[number3[2]])\\n                else:\\n                    res = \"{} Hundred {}\".format(self.digits[number3[0]], self.digits[number3[2]])\\n            else:\\n                if number3[1] == \\'1\\':\\n                    res = \"{}\".format(self.teens[number3[2]])\\n                elif number3[1] != \\'0\\':\\n                    res = \"{} {}\".format(self.tens[number3[1]], self.digits[number3[2]])\\n                else:\\n                    res = \"{}\".format(self.digits[number3[2]])\\n\\n        elif numlen == 2:\\n            if number3[0] != \\'1\\':\\n                res = \"{} {}\".format(self.tens[number3[0]], self.digits[number3[1]])\\n            else:\\n                res = \"{}\".format(self.teens[number3[1]])\\n                \\n        else:\\n            res = \"{}\".format(self.digits[number3[0]])\\n            \\n        return res.rstrip()\\n    \\n    \\n    def append_decimal_name_to_hundreds(self, humanizedHundreds):\\n        \"\"\"\\n        :param humanizedHundreds: string list of humanized representation of 3, 2 or 1-digit numbers:\\n        :return: modified list, append decimal name for each hundred\\n        :example: \"One Hundred Seventy Eight\" |-> \"One Hundred Seventy Eight Thousands\"\\n        \"\"\"\\n        hhlen = len(humanizedHundreds)\\n        res = list(\\n                    map(\\n                        lambda (i, hundname): \"{} {}\".format(hundname, self.decimals[hhlen-i-1 if hundname != \"\" else -1]),\\n                        enumerate(humanizedHundreds)\\n                    )\\n                )\\n        res = [el for el in res if el != \" delete_me\"]\\n        return res\\n    \\n    \\n    def construct_final_number(self, humanizedHundreds):\\n        \"\"\"\\n        :param humanizedHundreds: string list of 3, 2 or 1-digit string numbers\\n        :return: joined by \\' \\' elements\\n        \"\"\"\\n        return \\' \\'.join(humanizedHundreds).rstrip()\\n    \\n    \\n    digits = {\\n    \\'0\\': \\'\\',       # write nothing in case of zero DIGIT in number. zero as a number is another case and processes aside\\n    \\'1\\': \\'One\\',\\n    \\'2\\': \\'Two\\',\\n    \\'3\\': \\'Three\\',\\n    \\'4\\': \\'Four\\',\\n    \\'5\\': \\'Five\\',\\n    \\'6\\': \\'Six\\',\\n    \\'7\\': \\'Seven\\',\\n    \\'8\\': \\'Eight\\',\\n    \\'9\\': \\'Nine\\'\\n}\\n\\n    tens = {                # key means \\'x0\\' for x from 0 to 9\\n    \\'0\\': \\'\\',\\n    \\'2\\': \\'Twenty\\',          # \\'1\\' is NOT EXPECTED\\n    \\'3\\': \\'Thirty\\',\\n    \\'4\\': \\'Forty\\',\\n    \\'5\\': \\'Fifty\\',\\n    \\'6\\': \\'Sixty\\',\\n    \\'7\\': \\'Seventy\\',\\n    \\'8\\': \\'Eighty\\',\\n    \\'9\\': \\'Ninety\\'\\n}\\n\\n    teens = {               # key means \\'1x\\' for x from 0 to 9\\n    \\'0\\': \\'Ten\\',\\n    \\'1\\': \\'Eleven\\',\\n    \\'2\\': \\'Twelve\\',\\n    \\'3\\': \\'Thirteen\\',\\n    \\'4\\': \\'Fourteen\\',\\n    \\'5\\': \\'Fifteen\\',\\n    \\'6\\': \\'Sixteen\\',\\n    \\'7\\': \\'Seventeen\\',\\n    \\'8\\': \\'Eighteen\\',\\n    \\'9\\': \\'Nineteen\\'\\n}\\n\\n    decimals = {\\n    -1: \\'delete_me\\',    # in case if all digits are zeros\\n    0: \\'\\',\\n    1: \\'Thousand\\',\\n    2: \\'Million\\',\\n    3: \\'Billion\\',\\n    4: \\'Trillion\\',\\n    5: \\'Quadrillion\\',\\n    6: \\'Quintillion\\',\\n    7: \\'Sextillion\\',\\n    8: \\'Septillion\\',\\n    9: \\'Octillion\\',\\n    10: \\'Nonillion\\',\\n    11: \\'Decillion\\',\\n    12: \\'Undecillion\\',\\n    13: \\'Duodecillion\\',\\n    14: \\'Rredecillion\\',\\n    15: \\'Quattuordecillion\\',\\n    16: \\'Quindecillion\\',\\n    17: \\'Sexdecillion\\',\\n    18: \\'Septendecillion\\',\\n    19: \\'Octodecillion\\',\\n    20: \\'Novemdecillion\\',\\n    21: \\'Vigintillion\\',\\n    22: \\'Unvigintillion\\',\\n    23: \\'Duovigintillion\\',\\n    24: \\'Rrevigintillion\\',\\n    25: \\'Quattuorvigintillion\\',\\n    26: \\'Quinvigintillion\\',\\n    27: \\'Sexvigintillion\\',\\n    28: \\'Septenvigintillion\\',\\n    29: \\'Octovigintillion\\',\\n    30: \\'Novemvigintillion\\',\\n    31: \\'Trigintillion\\',\\n    32: \\'Untrigintillion\\',\\n    33: \\'Duotrigintillion\\',\\n    34: \\'Tretrigintillion\\',\\n    35: \\'Quattuortrigintillion\\',\\n    36: \\'Quintrigintillion\\',\\n    37: \\'Sextrigintillion\\',\\n    38: \\'Septentrigintillion\\',\\n    39: \\'Octotrigintillion\\',\\n    40: \\'Novemtrigintillion\\',\\n    41: \\'Quadragintillion\\',\\n    42: \\'Unquadragintillion\\',\\n    43: \\'Duoquadragintillion\\',\\n    44: \\'Trequadragintillion\\',\\n    45: \\'Quattuorquadragintillion\\',\\n    46: \\'Quinquadragintillion\\',\\n    47: \\'Sexquadragintillion\\',\\n    48: \\'Septenquadragintillion\\',\\n    49: \\'Octoquadragintillion\\',\\n    50: \\'Novemquadragintillion\\',\\n    51: \\'Quinquagintillion\\',\\n    52: \\'Unquinquagintillion\\',\\n    53: \\'Duoquinquagintillion\\',\\n    54: \\'Trequinquagintillion\\',\\n    55: \\'Quattuorquinquagintillion\\',\\n    56: \\'Quinquinquagintillion\\',\\n    57: \\'Sexquinquagintillion\\',\\n    58: \\'Septenquinquagintillion\\',\\n    59: \\'Octoquinquagintillion\\',\\n    60: \\'Novemquinquagintillion\\',\\n    61: \\'Sexagintillion\\',\\n    62: \\'Unsexagintillion\\',\\n    63: \\'Duosexagintillion\\',\\n    64: \\'Tresexagintillion\\',\\n    65: \\'Quattuorsexagintillion\\',\\n    66: \\'Quinsexagintillion\\',\\n    67: \\'Sexsexagintillion\\',\\n    68: \\'Septensexagintillion\\',\\n    69: \\'Octosexagintillion\\',\\n    70: \\'Novemsexagintillion\\',\\n    71: \\'Septuagintillion\\',\\n    72: \\'Unseptuagintillion\\',\\n    73: \\'Duoseptuagintillion\\',\\n    74: \\'Treseptuagintillion\\',\\n    75: \\'Quattuorseptuagintillion\\',\\n    76: \\'Quinseptuagintillion\\',\\n    77: \\'Sexseptuagintillion\\',\\n    78: \\'Septenseptuagintillion\\',\\n    79: \\'Octoseptuagintillion\\',\\n    80: \\'Novemseptuagintillion\\',\\n    81: \\'Octogintillion\\',\\n    82: \\'Unoctogintillion\\',\\n    83: \\'Duooctogintillion\\',\\n    84: \\'Treoctogintillion\\',\\n    85: \\'Quattuoroctogintillion\\',\\n    86: \\'Quinoctogintillion\\',\\n    87: \\'Sexoctogintillion\\',\\n    88: \\'Septoctogintillion\\',\\n    89: \\'Octooctogintillion\\',\\n    90: \\'Novemoctogintillion\\',\\n    91: \\'Nonagintillion\\',\\n    92: \\'Unnonagintillion\\',\\n    93: \\'Duononagintillion\\',\\n    94: \\'Trenonagintillion\\',\\n    95: \\'Quattuornonagintillion\\',\\n    96: \\'Quinnonagintillion\\',\\n    97: \\'Sexnonagintillion\\',\\n    98: \\'Septennonagintillion\\',\\n    99: \\'Octononagintillion\\',\\n    100: \\'Novemnonagintillion\\',\\n    101: \\'Centillion\\'\\n}\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):  \\n    def numberToWords(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: str\\n        \"\"\"\\n        if num == 0:                     # special case\\n            return \"Zero\"\\n        number = str(num)\\n        splitedNumber = self.separate_number_by_hundreds(number)\\n        humanizedHundreds = [self.humanize_hundreds(number3) for number3 in splitedNumber]\\n        humanizedHundreds = self.append_decimal_name_to_hundreds(humanizedHundreds)\\n        finalHumanizedNumber = self.construct_final_number(humanizedHundreds)\\n        return finalHumanizedNumber\\n    \\n    \\n    def separate_number_by_hundreds(self, number):\\n        \"\"\"\\n        :param number: string of number\\n        :return: list of string numbers - splitted by every 3rd digit param\\n        :example: \"73798234\" |-> [\\'73\\', \\'798\\', \\'234\\']\\n        \"\"\"\\n        separated_operands = []\\n        ln = len(number)\\n        if ln % 3 != 0:\\n            separated_operands.append(number[:ln % 3])\\n        for k in range(ln % 3, ln, 3):\\n            separated_operands.append(number[k: k + 3])\\n        return separated_operands\\n    \\n    \\n    def humanize_hundreds(self, number3):\\n        \"\"\"\\n        :param number3: string of 3, 2 or 1-digit int number\\n        :return: humanized representation of number\\n        :example: \"178\" |-> \"One Hundred Seventy Eight\"\\n        \"\"\"\\n        res = \\'\\'\\n        numlen = len(number3)\\n        if numlen == 3:\\n            if number3[0] != \\'0\\':\\n                if number3[1] == \\'1\\':\\n                    res = \"{} Hundred {}\".format(self.digits[number3[0]], self.teens[number3[2]])\\n                elif number3[1] != \\'0\\':\\n                    res = \"{} Hundred {} {}\".format(self.digits[number3[0]], self.tens[number3[1]], self.digits[number3[2]])\\n                else:\\n                    res = \"{} Hundred {}\".format(self.digits[number3[0]], self.digits[number3[2]])\\n            else:\\n                if number3[1] == \\'1\\':\\n                    res = \"{}\".format(self.teens[number3[2]])\\n                elif number3[1] != \\'0\\':\\n                    res = \"{} {}\".format(self.tens[number3[1]], self.digits[number3[2]])\\n                else:\\n                    res = \"{}\".format(self.digits[number3[2]])\\n\\n        elif numlen == 2:\\n            if number3[0] != \\'1\\':\\n                res = \"{} {}\".format(self.tens[number3[0]], self.digits[number3[1]])\\n            else:\\n                res = \"{}\".format(self.teens[number3[1]])\\n                \\n        else:\\n            res = \"{}\".format(self.digits[number3[0]])\\n            \\n        return res.rstrip()\\n    \\n    \\n    def append_decimal_name_to_hundreds(self, humanizedHundreds):\\n        \"\"\"\\n        :param humanizedHundreds: string list of humanized representation of 3, 2 or 1-digit numbers:\\n        :return: modified list, append decimal name for each hundred\\n        :example: \"One Hundred Seventy Eight\" |-> \"One Hundred Seventy Eight Thousands\"\\n        \"\"\"\\n        hhlen = len(humanizedHundreds)\\n        res = list(\\n                    map(\\n                        lambda (i, hundname): \"{} {}\".format(hundname, self.decimals[hhlen-i-1 if hundname != \"\" else -1]),\\n                        enumerate(humanizedHundreds)\\n                    )\\n                )\\n        res = [el for el in res if el != \" delete_me\"]\\n        return res\\n    \\n    \\n    def construct_final_number(self, humanizedHundreds):\\n        \"\"\"\\n        :param humanizedHundreds: string list of 3, 2 or 1-digit string numbers\\n        :return: joined by \\' \\' elements\\n        \"\"\"\\n        return \\' \\'.join(humanizedHundreds).rstrip()\\n    \\n    \\n    digits = {\\n    \\'0\\': \\'\\',       # write nothing in case of zero DIGIT in number. zero as a number is another case and processes aside\\n    \\'1\\': \\'One\\',\\n    \\'2\\': \\'Two\\',\\n    \\'3\\': \\'Three\\',\\n    \\'4\\': \\'Four\\',\\n    \\'5\\': \\'Five\\',\\n    \\'6\\': \\'Six\\',\\n    \\'7\\': \\'Seven\\',\\n    \\'8\\': \\'Eight\\',\\n    \\'9\\': \\'Nine\\'\\n}\\n\\n    tens = {                # key means \\'x0\\' for x from 0 to 9\\n    \\'0\\': \\'\\',\\n    \\'2\\': \\'Twenty\\',          # \\'1\\' is NOT EXPECTED\\n    \\'3\\': \\'Thirty\\',\\n    \\'4\\': \\'Forty\\',\\n    \\'5\\': \\'Fifty\\',\\n    \\'6\\': \\'Sixty\\',\\n    \\'7\\': \\'Seventy\\',\\n    \\'8\\': \\'Eighty\\',\\n    \\'9\\': \\'Ninety\\'\\n}\\n\\n    teens = {               # key means \\'1x\\' for x from 0 to 9\\n    \\'0\\': \\'Ten\\',\\n    \\'1\\': \\'Eleven\\',\\n    \\'2\\': \\'Twelve\\',\\n    \\'3\\': \\'Thirteen\\',\\n    \\'4\\': \\'Fourteen\\',\\n    \\'5\\': \\'Fifteen\\',\\n    \\'6\\': \\'Sixteen\\',\\n    \\'7\\': \\'Seventeen\\',\\n    \\'8\\': \\'Eighteen\\',\\n    \\'9\\': \\'Nineteen\\'\\n}\\n\\n    decimals = {\\n    -1: \\'delete_me\\',    # in case if all digits are zeros\\n    0: \\'\\',\\n    1: \\'Thousand\\',\\n    2: \\'Million\\',\\n    3: \\'Billion\\',\\n    4: \\'Trillion\\',\\n    5: \\'Quadrillion\\',\\n    6: \\'Quintillion\\',\\n    7: \\'Sextillion\\',\\n    8: \\'Septillion\\',\\n    9: \\'Octillion\\',\\n    10: \\'Nonillion\\',\\n    11: \\'Decillion\\',\\n    12: \\'Undecillion\\',\\n    13: \\'Duodecillion\\',\\n    14: \\'Rredecillion\\',\\n    15: \\'Quattuordecillion\\',\\n    16: \\'Quindecillion\\',\\n    17: \\'Sexdecillion\\',\\n    18: \\'Septendecillion\\',\\n    19: \\'Octodecillion\\',\\n    20: \\'Novemdecillion\\',\\n    21: \\'Vigintillion\\',\\n    22: \\'Unvigintillion\\',\\n    23: \\'Duovigintillion\\',\\n    24: \\'Rrevigintillion\\',\\n    25: \\'Quattuorvigintillion\\',\\n    26: \\'Quinvigintillion\\',\\n    27: \\'Sexvigintillion\\',\\n    28: \\'Septenvigintillion\\',\\n    29: \\'Octovigintillion\\',\\n    30: \\'Novemvigintillion\\',\\n    31: \\'Trigintillion\\',\\n    32: \\'Untrigintillion\\',\\n    33: \\'Duotrigintillion\\',\\n    34: \\'Tretrigintillion\\',\\n    35: \\'Quattuortrigintillion\\',\\n    36: \\'Quintrigintillion\\',\\n    37: \\'Sextrigintillion\\',\\n    38: \\'Septentrigintillion\\',\\n    39: \\'Octotrigintillion\\',\\n    40: \\'Novemtrigintillion\\',\\n    41: \\'Quadragintillion\\',\\n    42: \\'Unquadragintillion\\',\\n    43: \\'Duoquadragintillion\\',\\n    44: \\'Trequadragintillion\\',\\n    45: \\'Quattuorquadragintillion\\',\\n    46: \\'Quinquadragintillion\\',\\n    47: \\'Sexquadragintillion\\',\\n    48: \\'Septenquadragintillion\\',\\n    49: \\'Octoquadragintillion\\',\\n    50: \\'Novemquadragintillion\\',\\n    51: \\'Quinquagintillion\\',\\n    52: \\'Unquinquagintillion\\',\\n    53: \\'Duoquinquagintillion\\',\\n    54: \\'Trequinquagintillion\\',\\n    55: \\'Quattuorquinquagintillion\\',\\n    56: \\'Quinquinquagintillion\\',\\n    57: \\'Sexquinquagintillion\\',\\n    58: \\'Septenquinquagintillion\\',\\n    59: \\'Octoquinquagintillion\\',\\n    60: \\'Novemquinquagintillion\\',\\n    61: \\'Sexagintillion\\',\\n    62: \\'Unsexagintillion\\',\\n    63: \\'Duosexagintillion\\',\\n    64: \\'Tresexagintillion\\',\\n    65: \\'Quattuorsexagintillion\\',\\n    66: \\'Quinsexagintillion\\',\\n    67: \\'Sexsexagintillion\\',\\n    68: \\'Septensexagintillion\\',\\n    69: \\'Octosexagintillion\\',\\n    70: \\'Novemsexagintillion\\',\\n    71: \\'Septuagintillion\\',\\n    72: \\'Unseptuagintillion\\',\\n    73: \\'Duoseptuagintillion\\',\\n    74: \\'Treseptuagintillion\\',\\n    75: \\'Quattuorseptuagintillion\\',\\n    76: \\'Quinseptuagintillion\\',\\n    77: \\'Sexseptuagintillion\\',\\n    78: \\'Septenseptuagintillion\\',\\n    79: \\'Octoseptuagintillion\\',\\n    80: \\'Novemseptuagintillion\\',\\n    81: \\'Octogintillion\\',\\n    82: \\'Unoctogintillion\\',\\n    83: \\'Duooctogintillion\\',\\n    84: \\'Treoctogintillion\\',\\n    85: \\'Quattuoroctogintillion\\',\\n    86: \\'Quinoctogintillion\\',\\n    87: \\'Sexoctogintillion\\',\\n    88: \\'Septoctogintillion\\',\\n    89: \\'Octooctogintillion\\',\\n    90: \\'Novemoctogintillion\\',\\n    91: \\'Nonagintillion\\',\\n    92: \\'Unnonagintillion\\',\\n    93: \\'Duononagintillion\\',\\n    94: \\'Trenonagintillion\\',\\n    95: \\'Quattuornonagintillion\\',\\n    96: \\'Quinnonagintillion\\',\\n    97: \\'Sexnonagintillion\\',\\n    98: \\'Septennonagintillion\\',\\n    99: \\'Octononagintillion\\',\\n    100: \\'Novemnonagintillion\\',\\n    101: \\'Centillion\\'\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359354,
                "title": "very-simple-100-php-recursive-solution",
                "content": "It seems like a complicated solution until you break it down.\\n\\n1. Loop through the numbers description array, starting from the largest number in the array\\n2. Find the biggest number in the array that will fit into this input number\\n2. Divide the number by this value and get the quotient (for example if you have 2500, you divide by 1000 and floor it to give you 2)\\n3. Call the function again with this quotient to give you a prefix\\n4. Add the word and prefix to the string and minus the quotient * found value from the final number (e.g. in the above example above you\\'d get minus 2000 from 2500 to give 500)\\n5. Repeat for the remaining numbers until the number is zero\\n\\nA special case is if the current number is 1. We need to make sure that 1 is not printed before values less than 100, for example you do not want \"one twenty\" and you could also get stuck in an endless loop if the if clause is not added, as 1/1 = 1.\\n\\n```\\nfunction numberToWords($num) {\\n        \\n        $numbersDesc = [\\n            1000000000 => \\'Billion\\',\\n            1000000 => \\'Million\\',\\n            1000 => \\'Thousand\\',\\n            100 => \\'Hundred\\',\\n            90 => \\'Ninety\\',\\n            80 => \\'Eighty\\',\\n            70 => \\'Seventy\\',\\n            60 => \\'Sixty\\',\\n            50 => \\'Fifty\\',\\n            40 => \\'Forty\\',\\n            30 => \\'Thirty\\',\\n            20 => \\'Twenty\\',\\n            19 => \\'Nineteen\\', \\n            18 => \\'Eighteen\\', \\n            17 => \\'Seventeen\\', \\n            16 => \\'Sixteen\\', \\n            15 => \\'Fifteen\\', \\n            14 => \\'Fourteen\\', \\n            13 => \\'Thirteen\\', \\n            12 => \\'Twelve\\', \\n            11 => \\'Eleven\\', \\n            10 => \\'Ten\\', \\n            9 => \\'Nine\\', \\n            8 => \\'Eight\\', \\n            7 => \\'Seven\\', \\n            6 => \\'Six\\', \\n            5 => \\'Five\\', \\n            4 => \\'Four\\', \\n            3 => \\'Three\\', \\n            2 => \\'Two\\', \\n            1 => \\'One\\'\\n        ];\\n        \\n        if(!$num){\\n            return \"Zero\";\\n        }\\n        \\n        $finalWord = \"\";\\n        foreach($numbersDesc as $key=>$word){\\n            if($num >= $key){\\n                $current = floor($num/$key);\\n                $prefix = $finalWord ? \" \" : \"\";\\n                if(!($current == 1 && ($num == 1 || $key < 100))){\\n                    $prefix = $prefix.$this->numberToWords($current) .\" \";\\n                }\\n                \\n                $finalWord = $finalWord . $prefix . $word;\\n                $num -= ($current*$key);\\n            }\\n        }\\n        \\n        return $finalWord;\\n    }",
                "solutionTags": [],
                "code": "It seems like a complicated solution until you break it down.\\n\\n1. Loop through the numbers description array, starting from the largest number in the array\\n2. Find the biggest number in the array that will fit into this input number\\n2. Divide the number by this value and get the quotient (for example if you have 2500, you divide by 1000 and floor it to give you 2)\\n3. Call the function again with this quotient to give you a prefix\\n4. Add the word and prefix to the string and minus the quotient * found value from the final number (e.g. in the above example above you\\'d get minus 2000 from 2500 to give 500)\\n5. Repeat for the remaining numbers until the number is zero\\n\\nA special case is if the current number is 1. We need to make sure that 1 is not printed before values less than 100, for example you do not want \"one twenty\" and you could also get stuck in an endless loop if the if clause is not added, as 1/1 = 1.\\n\\n```\\nfunction numberToWords($num) {\\n        \\n        $numbersDesc = [\\n            1000000000 => \\'Billion\\',\\n            1000000 => \\'Million\\',\\n            1000 => \\'Thousand\\',\\n            100 => \\'Hundred\\',\\n            90 => \\'Ninety\\',\\n            80 => \\'Eighty\\',\\n            70 => \\'Seventy\\',\\n            60 => \\'Sixty\\',\\n            50 => \\'Fifty\\',\\n            40 => \\'Forty\\',\\n            30 => \\'Thirty\\',\\n            20 => \\'Twenty\\',\\n            19 => \\'Nineteen\\', \\n            18 => \\'Eighteen\\', \\n            17 => \\'Seventeen\\', \\n            16 => \\'Sixteen\\', \\n            15 => \\'Fifteen\\', \\n            14 => \\'Fourteen\\', \\n            13 => \\'Thirteen\\', \\n            12 => \\'Twelve\\', \\n            11 => \\'Eleven\\', \\n            10 => \\'Ten\\', \\n            9 => \\'Nine\\', \\n            8 => \\'Eight\\', \\n            7 => \\'Seven\\', \\n            6 => \\'Six\\', \\n            5 => \\'Five\\', \\n            4 => \\'Four\\', \\n            3 => \\'Three\\', \\n            2 => \\'Two\\', \\n            1 => \\'One\\'\\n        ];\\n        \\n        if(!$num){\\n            return \"Zero\";\\n        }\\n        \\n        $finalWord = \"\";\\n        foreach($numbersDesc as $key=>$word){\\n            if($num >= $key){\\n                $current = floor($num/$key);\\n                $prefix = $finalWord ? \" \" : \"\";\\n                if(!($current == 1 && ($num == 1 || $key < 100))){\\n                    $prefix = $prefix.$this->numberToWords($current) .\" \";\\n                }\\n                \\n                $finalWord = $finalWord . $prefix . $word;\\n                $num -= ($current*$key);\\n            }\\n        }\\n        \\n        return $finalWord;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 313546,
                "title": "java-solution",
                "content": "```\\npublic String numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        String[] pv = {\"\", \"Thousand\", \"Million\", \"Billion\"};\\n        String res = \"\";\\n        int i = 0;\\n        while(num > 0){\\n            if(num % 1000 != 0)\\n                res = toWords(num % 1000)+pv[i]+\" \"+res;\\n            num /= 1000;\\n            i++;\\n        }\\n        return res.trim();\\n    }\\n    private String toWords(int n){\\n        String res = \"\";\\n        String[] ones_tens = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        String[] hundreds = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        if(n == 0)\\n            res = \"\";\\n        else if(n < 20)\\n            res = ones_tens[n % 20]+\" \";\\n        else if(n < 100)\\n            res = hundreds[n / 10]+\" \"+toWords(n % 10);\\n        else\\n            res = ones_tens[n / 100]+\" Hundred \"+toWords(n % 100);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        String[] pv = {\"\", \"Thousand\", \"Million\", \"Billion\"};\\n        String res = \"\";\\n        int i = 0;\\n        while(num > 0){\\n            if(num % 1000 != 0)\\n                res = toWords(num % 1000)+pv[i]+\" \"+res;\\n            num /= 1000;\\n            i++;\\n        }\\n        return res.trim();\\n    }\\n    private String toWords(int n){\\n        String res = \"\";\\n        String[] ones_tens = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        String[] hundreds = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        if(n == 0)\\n            res = \"\";\\n        else if(n < 20)\\n            res = ones_tens[n % 20]+\" \";\\n        else if(n < 100)\\n            res = hundreds[n / 10]+\" \"+toWords(n % 10);\\n        else\\n            res = ones_tens[n / 100]+\" Hundred \"+toWords(n % 100);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 70660,
                "title": "short-clean-java-solution-using-math-log10-and-math-pow",
                "content": "No need for loops or many if statements\\n\\n```\\n    private static final String[] BELOW_TWENTY = new String[] {\"\", \"One\", \"Two\", ..., \"Nineteen\"};\\n    private static final String[] BELOW_HUNDRED = new String[] {\"\", \"\", \"Twenty\", \"Thirty\", ..., \"Ninety\"};\\n    private static final String[] ABOVE_HUNDRED = new String[] {\"Hundred\", \"Thousand\", \"Million\", \"Billion\"};\\n    \\n    public String numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        return helper(num); \\n    }\\n    \\n    private String helper(int num) {\\n        if (num < 20) return BELOW_TWENTY[num];\\n        if (num < 100) return (BELOW_HUNDRED[num / 10] + \" \" + BELOW_TWENTY[num % 10]).trim();\\n        int aboveHundredIndex = (int)Math.log10(num) / 3;\\n        int divisor = aboveHundredIndex == 0 ? 100 : (int)Math.pow(1000, aboveHundredIndex);\\n        return (helper(num / divisor) + \" \" + ABOVE_HUNDRED[aboveHundredIndex] + \" \" + helper(num % divisor)).trim();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private static final String[] BELOW_TWENTY = new String[] {\"\", \"One\", \"Two\", ..., \"Nineteen\"};\\n    private static final String[] BELOW_HUNDRED = new String[] {\"\", \"\", \"Twenty\", \"Thirty\", ..., \"Ninety\"};\\n    private static final String[] ABOVE_HUNDRED = new String[] {\"Hundred\", \"Thousand\", \"Million\", \"Billion\"};\\n    \\n    public String numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        return helper(num); \\n    }\\n    \\n    private String helper(int num) {\\n        if (num < 20) return BELOW_TWENTY[num];\\n        if (num < 100) return (BELOW_HUNDRED[num / 10] + \" \" + BELOW_TWENTY[num % 10]).trim();\\n        int aboveHundredIndex = (int)Math.log10(num) / 3;\\n        int divisor = aboveHundredIndex == 0 ? 100 : (int)Math.pow(1000, aboveHundredIndex);\\n        return (helper(num / divisor) + \" \" + ABOVE_HUNDRED[aboveHundredIndex] + \" \" + helper(num % divisor)).trim();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 70675,
                "title": "generalizable-c-solution-with-explanation",
                "content": "Basic idea: simple simulation with two helper functions parseAnswer and underThousand, whose function is straight-forward to understand. Just keep the possible edge cases in mind - basically zeroes & tens and the spaces.\\n```\\nclass Solution {\\npublic:\\n    string parseAnswer(vector<string>& ans) {\\n        string tmp = \"\";\\n        for (int i = 0; i < ans.size(); i++) {\\n            if (i)\\n                tmp += \" \";\\n            tmp += ans[i];\\n        }\\n        return tmp;\\n    }\\n    \\n    string underThousand(string s) {\\n        string number[10] = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n        string tys[10] = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        string tens[10] = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        vector<string> ans;\\n        if (s == \"000\") {\\n            return number[0];\\n        }\\n        \\n        int s0 = s[0] - '0';\\n        int s1 = s[1] - '0';\\n        int s2 = s[2] - '0';\\n        \\n        if (s0 != 0)\\n            ans.push_back(number[s0] + \" Hundred\");\\n        \\n        if (s1 == 1)\\n            ans.push_back(tens[s2]);\\n        else if (s1 != 0)\\n            ans.push_back(tys[s1]);\\n        \\n        if (s2 != 0 && s1 != 1)\\n            ans.push_back(number[s2]);\\n        \\n        return parseAnswer(ans);\\n    }\\n    \\n    string numberToWords(int num) {\\n        // generalizable if you add suffixes for bigger numbers here\\n        string suffix[] = {\"\", \" Thousand\", \" Million\", \" Billion\", \" Trillion\"};\\n        string s = to_string(num);\\n        vector<string> ans;\\n        \\n        while (s.length() % 3 != 0)\\n            s = \"0\" + s;\\n        if (s == \"000\")\\n            return \"Zero\";\\n        \\n        for (int i = 0; i < s.length(); i+=3) {\\n            string tmp = underThousand(s.substr(i, 3));\\n            if (tmp != \"Zero\") {\\n                tmp += suffix[(s.length()-i)/3 - 1];\\n                ans.push_back(tmp);\\n            }\\n        }\\n        \\n        return parseAnswer(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string parseAnswer(vector<string>& ans) {\\n        string tmp = \"\";\\n        for (int i = 0; i < ans.size(); i++) {\\n            if (i)\\n                tmp += \" \";\\n            tmp += ans[i];\\n        }\\n        return tmp;\\n    }\\n    \\n    string underThousand(string s) {\\n        string number[10] = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n        string tys[10] = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n        string tens[10] = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        vector<string> ans;\\n        if (s == \"000\") {\\n            return number[0];\\n        }\\n        \\n        int s0 = s[0] - '0';\\n        int s1 = s[1] - '0';\\n        int s2 = s[2] - '0';\\n        \\n        if (s0 != 0)\\n            ans.push_back(number[s0] + \" Hundred\");\\n        \\n        if (s1 == 1)\\n            ans.push_back(tens[s2]);\\n        else if (s1 != 0)\\n            ans.push_back(tys[s1]);\\n        \\n        if (s2 != 0 && s1 != 1)\\n            ans.push_back(number[s2]);\\n        \\n        return parseAnswer(ans);\\n    }\\n    \\n    string numberToWords(int num) {\\n        // generalizable if you add suffixes for bigger numbers here\\n        string suffix[] = {\"\", \" Thousand\", \" Million\", \" Billion\", \" Trillion\"};\\n        string s = to_string(num);\\n        vector<string> ans;\\n        \\n        while (s.length() % 3 != 0)\\n            s = \"0\" + s;\\n        if (s == \"000\")\\n            return \"Zero\";\\n        \\n        for (int i = 0; i < s.length(); i+=3) {\\n            string tmp = underThousand(s.substr(i, 3));\\n            if (tmp != \"Zero\") {\\n                tmp += suffix[(s.length()-i)/3 - 1];\\n                ans.push_back(tmp);\\n            }\\n        }\\n        \\n        return parseAnswer(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70685,
                "title": "clear-python-solution-with-explanation-and-comments",
                "content": " \\n##Key idea\\nWe divide the number into N parts from the right to the left, and each part weighs 3 if possible. All the parts follow the same pattern of converting, so we want a helper method to do the work. Next we distribute the base words (aka \"Thousand\", \"Million\") to each part and combine them. \\n\\nThis question has lots of edge cases, and it very hard to notice all of them before the tests._(:\\u0437\\u300d\\u2220)_\\n\\n    def numberToWords(self, num):\\n        if num == 0:\\n            return \"Zero\"\\n            \\n        result = \"\"\\n        str_num = str(num)[::-1]\\n        # Divede the string into N parts, where len(each part) <= 3\\n        dividing_list = [str_num[i:i+3][::-1] for i in xrange(0, len(str_num), 3)]\\n        \\n        # Distribute the base according to the index of dividing_list\\n        base = [\"\", \" Thousand \", \" Million \", \" Billion \"]\\n        for i in range(len(dividing_list)):\\n            tem = self.convert_three_to_eng(dividing_list[i])\\n            result = tem + (\"\" if not tem else base[i]) + result\\n        \\n        # Avoide undesirable space\\n        return \" \".join(result.split())\\n    \\n    \\n    def convert_three_to_eng(self, s):\\n        # Helper lists, pay attention to the index\\n        one = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\\n        ten = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\n        ten_a = [\"\", \"\", \"Twenty \", \"Thirty \", \"Forty \", \"Fifty \", \"Sixty \", \"Seventy \", \"Eighty \", \"Ninety \"]\\n        \\n        num = int(s)\\n        result = \"\"\\n        \\n        # Same like the roman numeral problem algorithm: from high base to the low base\\n        if num / 100 != 0:\\n            result = one[(num / 100)] + \" Hundred \"\\n        if (num % 100) / 10 == 1:\\n            result += ten[num % 10]\\n            return result\\n        else:\\n            result += ten_a[(num % 100) / 10] + one[num % 10]\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": " \\n##Key idea\\nWe divide the number into N parts from the right to the left, and each part weighs 3 if possible. All the parts follow the same pattern of converting, so we want a helper method to do the work. Next we distribute the base words (aka \"Thousand\", \"Million\") to each part and combine them. \\n\\nThis question has lots of edge cases, and it very hard to notice all of them before the tests._(:\\u0437\\u300d\\u2220)_\\n\\n    def numberToWords(self, num):\\n        if num == 0:\\n            return \"Zero\"\\n            \\n        result = \"\"\\n        str_num = str(num)[::-1]\\n        # Divede the string into N parts, where len(each part) <= 3\\n        dividing_list = [str_num[i:i+3][::-1] for i in xrange(0, len(str_num), 3)]\\n        \\n        # Distribute the base according to the index of dividing_list\\n        base = [\"\", \" Thousand \", \" Million \", \" Billion \"]\\n        for i in range(len(dividing_list)):\\n            tem = self.convert_three_to_eng(dividing_list[i])\\n            result = tem + (\"\" if not tem else base[i]) + result\\n        \\n        # Avoide undesirable space\\n        return \" \".join(result.split())\\n    \\n    \\n    def convert_three_to_eng(self, s):\\n        # Helper lists, pay attention to the index\\n        one = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\\n        ten = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\\n        ten_a = [\"\", \"\", \"Twenty \", \"Thirty \", \"Forty \", \"Fifty \", \"Sixty \", \"Seventy \", \"Eighty \", \"Ninety \"]\\n        \\n        num = int(s)\\n        result = \"\"\\n        \\n        # Same like the roman numeral problem algorithm: from high base to the low base\\n        if num / 100 != 0:\\n            result = one[(num / 100)] + \" Hundred \"\\n        if (num % 100) / 10 == 1:\\n            result += ten[num % 10]\\n            return result\\n        else:\\n            result += ten_a[(num % 100) / 10] + one[num % 10]\\n            return result",
                "codeTag": "Python3"
            },
            {
                "id": 70711,
                "title": "a-c-solution-with-lambda-expression",
                "content": "    class Solution {\\n    public:\\n      string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        \\n        unordered_map<int,string> readings = { {0, \"\"}, {1, \"One\"}, {2, \"Two\"}, {3, \"Three\"}, {4, \"Four\"}, {5, \"Five\"}, {6, \"Six\"}, {7, \"Seven\"}, {8, \"Eight\"}, {9, \"Nine\"}, {10, \"Ten\"}, {11, \"Eleven\"}, {12, \"Twelve\"}, {13, \"Thirteen\"}, {14, \"Fourteen\"}, {15, \"Fifteen\"}, {16, \"Sixteen\"}, {17, \"Seventeen\"}, {18, \"Eighteen\"}, {19, \"Nineteen\"}, {20, \"Twenty\"}, {30, \"Thirty\"}, {40, \"Forty\"}, {50, \"Fifty\"}, {60, \"Sixty\"}, {70, \"Seventy\"}, {80, \"Eighty\"}, {90, \"Ninety\"}, {100, \"Hundred\"}, {1000, \"Thousand\"}, {1000000, \"Million\"}, {1000000000, \"Billion\"}};\\n        vector<int> bases = {100, 1000, 1000000, 1000000000};\\n        \\n        std::function<string(int, int)> read = [&] (int n, int index) {\\n          if(n <= 20) return readings[n];\\n          if(n < 100) {\\n              string ret = readings[n - n % 10];\\n              if(!ret.empty() && n % 10) ret += \" \";\\n              return ret + readings[n % 10];\\n          }\\n          \\n          int radix = bases[index];\\n          int result = n / radix, rest = n % radix;\\n          string ret;\\n          if(result) {\\n            ret = read(result, index - 1) + \" \" + readings[radix] + (rest ? \" \" : \"\");\\n          }\\n          return ret += read(rest, index - 1);\\n        };\\n        \\n        return read(num, bases.size() - 1);\\n      }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n      string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        \\n        unordered_map<int,string> readings = { {0, \"\"}",
                "codeTag": "Java"
            },
            {
                "id": 70712,
                "title": "java-easy-version-to-understand",
                "content": "    \\tstatic String[] lessThan20 = { \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\\n\\t\\t\\t\"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\" };\\n\\tstatic String[] tens = { \"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" };\\n\\tstatic String[] thousands = { \"\", \"Thousand\", \"Million\", \"Billion\" };\\n\\n\\tpublic static String helper(int number) {\\n\\t\\tif (number == 0)\\n\\t\\t\\treturn \"\";\\n\\t\\tif (number < 20)\\n\\t\\t\\treturn lessThan20[number] + \" \";\\n\\t\\tif (number < 100)\\n\\t\\t\\treturn tens[number / 10] + \" \" + helper(number % 10);\\n\\t\\telse\\n\\t\\t\\treturn lessThan20[number / 100] + \" Hundred \" + helper(number % 100);\\n\\t}\\n\\n\\tpublic static String numberToWords(int num) {\\n\\t\\tif (num == 0)\\n\\t\\t\\treturn \"Zero\";\\n\\t\\tString word = \"\";\\n\\t\\tfor (int i = 0; i < thousands.length; i++) {\\n\\t\\t\\tint tmp = num % 1000;\\n\\t\\t\\tnum /= 1000;\\n\\t\\t\\tif (tmp == 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tword = helper(tmp) + thousands[i] + \" \" + word;\\n\\t\\t}\\n\\t\\treturn word.trim();\\n\\t}",
                "solutionTags": [],
                "code": "    \\tstatic String[] lessThan20 = { \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\\n\\t\\t\\t\"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\" };\\n\\tstatic String[] tens = { \"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" };\\n\\tstatic String[] thousands = { \"\", \"Thousand\", \"Million\", \"Billion\" };\\n\\n\\tpublic static String helper(int number) {\\n\\t\\tif (number == 0)\\n\\t\\t\\treturn \"\";\\n\\t\\tif (number < 20)\\n\\t\\t\\treturn lessThan20[number] + \" \";\\n\\t\\tif (number < 100)\\n\\t\\t\\treturn tens[number / 10] + \" \" + helper(number % 10);\\n\\t\\telse\\n\\t\\t\\treturn lessThan20[number / 100] + \" Hundred \" + helper(number % 100);\\n\\t}\\n\\n\\tpublic static String numberToWords(int num) {\\n\\t\\tif (num == 0)\\n\\t\\t\\treturn \"Zero\";\\n\\t\\tString word = \"\";\\n\\t\\tfor (int i = 0; i < thousands.length; i++) {\\n\\t\\t\\tint tmp = num % 1000;\\n\\t\\t\\tnum /= 1000;\\n\\t\\t\\tif (tmp == 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tword = helper(tmp) + thousands[i] + \" \" + word;\\n\\t\\t}\\n\\t\\treturn word.trim();\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 70745,
                "title": "java-clean-solution",
                "content": "    private String[] digit = new String[] {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n\\tprivate String[] teen = new String[] {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n\\tprivate String[] ten = new String[] {\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n\\tprivate String[] thousand = new String[] {\"Thousand\", \"Million\", \"Billion\"};\\n\\n\\tpublic String numberToWords(int num) {\\n\\t\\tString ans;\\n\\t\\tif (num == 0)\\n\\t\\t\\treturn digit[num];\\n\\t\\t\\n\\t\\tans = hundredHelper(num%1000);\\n\\t\\tnum = num/1000;\\n\\t\\tint i = 0;\\n\\t\\twhile (i < 3 && num > 0) {\\n\\t\\t\\tif (num % 1000 > 0)\\n\\t\\t\\t\\tans = hundredHelper(num%1000) + thousand[i] + \" \" + ans;\\n\\t\\t\\tnum = num/1000;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans.trim();\\n\\t}\\n\\t\\n\\tpublic String hundredHelper(int num) {\\n\\t\\tString nstr = \"\";\\n\\t\\tif (num >= 100) {\\n\\t\\t\\tnstr = digit[num/100] + \" Hundred \";\\n\\t\\t}\\n\\t\\tnum = num%100;\\n\\t\\tif (num >= 20) {\\n\\t\\t\\tif (num % 10 != 0)\\n\\t\\t\\t\\tnstr = nstr + ten[num/10 - 2] + \" \" +  digit[num%10] + \" \";\\n\\t\\t\\telse\\n\\t\\t\\t\\tnstr = nstr + ten[num/10 - 2] + \" \";\\n\\t\\t} else if (num >= 10) {\\n\\t\\t\\tnstr = nstr + teen[num%10] + \" \";\\n\\t\\t} else if (num > 0){\\n\\t\\t\\tnstr = nstr + digit[num] + \" \";\\n\\t\\t}\\n\\t\\treturn nstr;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    private String[] digit = new String[] {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n\\tprivate String[] teen = new String[] {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n\\tprivate String[] ten = new String[] {\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n\\tprivate String[] thousand = new String[] {\"Thousand\", \"Million\", \"Billion\"};\\n\\n\\tpublic String numberToWords(int num) {\\n\\t\\tString ans;\\n\\t\\tif (num == 0)\\n\\t\\t\\treturn digit[num];\\n\\t\\t\\n\\t\\tans = hundredHelper(num%1000);\\n\\t\\tnum = num/1000;\\n\\t\\tint i = 0;\\n\\t\\twhile (i < 3 && num > 0) {\\n\\t\\t\\tif (num % 1000 > 0)\\n\\t\\t\\t\\tans = hundredHelper(num%1000) + thousand[i] + \" \" + ans;\\n\\t\\t\\tnum = num/1000;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans.trim();\\n\\t}\\n\\t\\n\\tpublic String hundredHelper(int num) {\\n\\t\\tString nstr = \"\";\\n\\t\\tif (num >= 100) {\\n\\t\\t\\tnstr = digit[num/100] + \" Hundred \";\\n\\t\\t}\\n\\t\\tnum = num%100;\\n\\t\\tif (num >= 20) {\\n\\t\\t\\tif (num % 10 != 0)\\n\\t\\t\\t\\tnstr = nstr + ten[num/10 - 2] + \" \" +  digit[num%10] + \" \";\\n\\t\\t\\telse\\n\\t\\t\\t\\tnstr = nstr + ten[num/10 - 2] + \" \";\\n\\t\\t} else if (num >= 10) {\\n\\t\\t\\tnstr = nstr + teen[num%10] + \" \";\\n\\t\\t} else if (num > 0){\\n\\t\\t\\tnstr = nstr + digit[num] + \" \";\\n\\t\\t}\\n\\t\\treturn nstr;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 70746,
                "title": "easy-understanding-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> unit1 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n        vector<string> unit2 = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n            \\n        string number2string(int num)\\n        {\\n            string ret;\\n            if (num >= 100)\\n            {\\n                ret += unit1[num/100] + \" Hundred\" + \" \";\\n                num = num % 100;\\n            }\\n            if (num >= 20)\\n            {\\n                ret += unit2[num/10] + \" \";\\n                num = num % 10;\\n            }\\n            if (0<num && num<20)\\n                ret += unit1[num] + \" \";\\n                \\n            return ret;\\n        }\\n        \\n        string numberToWords(int num) \\n        {\\n            string ret;\\n            if (num >= 1000000000)\\n            {\\n                ret += number2string(num/1000000000) + \"Billion\" + \" \";\\n                num = num % 1000000000;\\n            }\\n            if (num >= 1000000)\\n            {\\n                ret += number2string(num/1000000) + \"Million\" + \" \";\\n                num = num % 1000000;\\n            }\\n            if (num >= 1000)\\n            {\\n                ret += number2string(num/1000) + \"Thousand\" + \" \";\\n                num = num % 1000;\\n            }\\n            if (num < 1000)\\n            {\\n                ret += number2string(num);\\n            }\\n            \\n            if (ret.empty())\\n                return \"Zero\";\\n                \\n            return ret.substr(0, ret.size()-1);;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<string> unit1 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"}",
                "codeTag": "Java"
            },
            {
                "id": 70754,
                "title": "4ms-c-non-recursive-solution",
                "content": "    const char* digits[20] = {\"Zero\",\" One\",\" Two\",\" Three\",\" Four\",\" Five\",\" Six\",\" Seven\",\" Eight\",\" Nine\",\\n                        \" Ten\",\" Eleven\",\" Twelve\",\" Thirteen\",\" Fourteen\",\" Fifteen\",\" Sixteen\",\" Seventeen\",\" Eighteen\",\" Nineteen\"};\\n    const char* tens[10] = {\"\",\"\",\" Twenty\",\" Thirty\",\" Forty\",\" Fifty\",\" Sixty\",\" Seventy\",\" Eighty\",\" Ninety\"};\\n    const char* many[5] = {\"\",\" Thousand\",\" Million\",\" Billion\",\" Trillion\"};\\n    \\n    string lessThousandToWords(int num) {\\n        string ans;\\n        if (num / 100)\\n            ans = ans + digits[num/100] + \" Hundred\";\\n        num %= 100;\\n        if (num < 20 && num > 0)\\n            ans += digits[num];\\n        else {\\n            ans +=  tens[num/10];\\n            num %= 10;\\n            if (num > 0)\\n                ans += digits[num];\\n        }\\n        return ans;\\n    }\\n\\n    string numberToWords(int num) {\\n        if (num == 0)\\n            return digits[0];\\n        string ans, sub;\\n        int level = 0;\\n        while (num) {\\n            sub = lessThousandToWords(num%1000);\\n            if (sub != \"\")\\n                ans = sub + many[level] + ans;\\n            ++level;\\n            num /= 1000;\\n        }\\n        return ans.substr(1,ans.size()-1);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    const char* digits[20] = {\"Zero\",\" One\",\" Two\",\" Three\",\" Four\",\" Five\",\" Six\",\" Seven\",\" Eight\",\" Nine\",\\n                        \" Ten\",\" Eleven\",\" Twelve\",\" Thirteen\",\" Fourteen\",\" Fifteen\",\" Sixteen\",\" Seventeen\",\" Eighteen\",\" Nineteen\"};\\n    const char* tens[10] = {\"\",\"\",\" Twenty\",\" Thirty\",\" Forty\",\" Fifty\",\" Sixty\",\" Seventy\",\" Eighty\",\" Ninety\"};\\n    const char* many[5] = {\"\",\" Thousand\",\" Million\",\" Billion\",\" Trillion\"};\\n    \\n    string lessThousandToWords(int num) {\\n        string ans;\\n        if (num / 100)\\n            ans = ans + digits[num/100] + \" Hundred\";\\n        num %= 100;\\n        if (num < 20 && num > 0)\\n            ans += digits[num];\\n        else {\\n            ans +=  tens[num/10];\\n            num %= 10;\\n            if (num > 0)\\n                ans += digits[num];\\n        }\\n        return ans;\\n    }\\n\\n    string numberToWords(int num) {\\n        if (num == 0)\\n            return digits[0];\\n        string ans, sub;\\n        int level = 0;\\n        while (num) {\\n            sub = lessThousandToWords(num%1000);\\n            if (sub != \"\")\\n                ans = sub + many[level] + ans;\\n            ++level;\\n            num /= 1000;\\n        }\\n        return ans.substr(1,ans.size()-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3800480,
                "title": "c-easiest-with-detailed-explanation-easily-understandable",
                "content": "# Intuition\\nThe idea behind the function is to recursively divide the given number into different scales (Billion, Million, Thousand, and Hundred) and then handle the remaining digits separately. The function iterates through the nms vector, starting from the largest number (Billion) to the smallest number (One), and tries to find the largest scale that is less than or equal to the given number.\\n\\n1. If the number is zero (num == 0), it returns the string \"Zero\", as there is no need to perform any further calculations.\\n\\n2. It then iterates through the nms vector to find the largest scale that is less than or equal to the given number. For example, if num is 1234567, the function will find \"Million\" as the largest scale less than or equal to 1234567.\\n\\n3. Once the largest scale is found, the function recursively calls itself with the division of num by the value of the scale (e.g., 1234567 / 1000000), which provides the word representation for the larger part of the number.\\n\\n4. It then appends the corresponding English word for the scale (e.g., \"Million\") to the result string.\\n\\n5. Next, it recursively calls itself with the remainder of the division (e.g., 1234567 % 1000000), which represents the smaller part of the number that needs to be handled separately.\\n\\n6. It appends the corresponding English word for the remaining part of the number (if it\\'s not zero) to the result string.\\n\\n7. The function repeats this process until the entire number is converted to its English word representation.\\n\\n8. Finally, the function returns the result string, which is the English word representation of the input number.\\n\\n**For Example:** \\n\\n*Input:* num = 1234567\\n*Output:* \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\\n\\n\\nIn this example, the function finds the largest scale \"Million\" that is less than or equal to 1234567 and recursively calls itself for the larger part (1) and the remaining part (234567) of the number. It continues the process until the entire number is converted to its English word representation.\\n\\n# Approach\\nC++ implementation of a function that converts a given integer num to its English word representation. It uses a recursive approach to build the word representation by dividing the number into different scales such as Billion, Million, Thousand, and Hundred, and handling the remaining digits separately.\\n\\nThe function uses a vector<pair<int, string>> named nms to store the mappings of integer values to their corresponding English words. The nms vector contains mappings for numbers from 1 to 1000, including the individual numbers from 1 to 20 and the multiples of 10 up to 100. It also contains special words for Thousand, Million, and Billion.\\n\\n# Complexity\\n- Time complexity:\\n**O(log10(num))**\\n\\n- Space complexity:\\n**O(log10(num))**\\n\\n![upvote.jpg](https://assets.leetcode.com/users/images/965f25b9-5c44-4c9c-aec5-869f87a7eca1_1690023004.5086956.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<pair<int, string>>nms =\\n{\\n    {1000000000, \"Billion\"}, {1000000, \"Million\"}, {1000, \"Thousand\"}, {100, \"Hundred\"},\\n    {90, \"Ninety\"},{80, \"Eighty\"},{70, \"Seventy\"},{60, \"Sixty\"}, \\n    {50, \"Fifty\"}, {40, \"Forty\"}, {30, \"Thirty\"}, {20, \"Twenty\"},\\n    {19, \"Nineteen\"}, {18, \"Eighteen\"}, {17, \"Seventeen\"}, {16, \"Sixteen\"}, {15, \"Fifteen\"},\\n    {14, \"Fourteen\"}, {13, \"Thirteen\"}, {12, \"Twelve\"}, {11, \"Eleven\"}, {10, \"Ten\"},\\n    {9, \"Nine\"},{8, \"Eight\"},{7, \"Seven\"},{6, \"Six\"}, {5, \"Five\"}, {4, \"Four\"}, {3, \"Three\"}, {2, \"Two\"}, {1, \"One\"}\\n};\\n    string numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        for(auto it:nms){\\n            if(num>=it.first){\\n                string a=\"\";\\n                if(num>=100){\\n                    a=numberToWords(num/it.first)+\" \";\\n                }\\n                string b=it.second;\\n                string c=\"\";\\n                if(num%it.first!=0){\\n                    c=\" \"+numberToWords(num % it.first);\\n                }\\n                return a+b+c;\\n            }\\n            \\n        }\\n        return \"\" ;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<pair<int, string>>nms =\\n{\\n    {1000000000, \"Billion\"}, {1000000, \"Million\"}, {1000, \"Thousand\"}, {100, \"Hundred\"},\\n    {90, \"Ninety\"},{80, \"Eighty\"},{70, \"Seventy\"},{60, \"Sixty\"}, \\n    {50, \"Fifty\"}, {40, \"Forty\"}, {30, \"Thirty\"}, {20, \"Twenty\"},\\n    {19, \"Nineteen\"}, {18, \"Eighteen\"}, {17, \"Seventeen\"}, {16, \"Sixteen\"}, {15, \"Fifteen\"},\\n    {14, \"Fourteen\"}, {13, \"Thirteen\"}, {12, \"Twelve\"}, {11, \"Eleven\"}, {10, \"Ten\"},\\n    {9, \"Nine\"},{8, \"Eight\"},{7, \"Seven\"},{6, \"Six\"}, {5, \"Five\"}, {4, \"Four\"}, {3, \"Three\"}, {2, \"Two\"}, {1, \"One\"}\\n};\\n    string numberToWords(int num) {\\n        if (num == 0) return \"Zero\";\\n        for(auto it:nms){\\n            if(num>=it.first){\\n                string a=\"\";\\n                if(num>=100){\\n                    a=numberToWords(num/it.first)+\" \";\\n                }\\n                string b=it.second;\\n                string c=\"\";\\n                if(num%it.first!=0){\\n                    c=\" \"+numberToWords(num % it.first);\\n                }\\n                return a+b+c;\\n            }\\n            \\n        }\\n        return \"\" ;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721486,
                "title": "easy-c-solution-beat-100",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log10k)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(log10K)\\n\\n# Code\\n```\\nclass Solution {\\n    vector<pair<int,string>> mp={\\n        {1000000000,\"Billion\"},{1000000,\"Million\"},{1000,\"Thousand\"},{100,\"Hundred\"},{90,\"Ninety\"},{80,\"Eighty\"},{70,\"Seventy\"},{60,\"Sixty\"},{50,\"Fifty\"},{40,\"Forty\"},{30,\"Thirty\"},{20,\"Twenty\"},{19,\"Nineteen\"},{18,\"Eighteen\"},{17,\"Seventeen\"},{16,\"Sixteen\"},{15,\"Fifteen\"},{14,\"Fourteen\"},{13,\"Thirteen\"},{12,\"Twelve\"},{11,\"Eleven\"},{10,\"Ten\"},{9,\"Nine\"},{8,\"Eight\"},{7,\"Seven\"},{6,\"Six\"},{5,\"Five\"},{4,\"Four\"},{3,\"Three\"},{2,\"Two\"},{1,\"One\"},{0,\"Zero\"}};\\npublic:\\n    string numberToWords(int num) {\\n        for(auto it:mp){\\n            if(num>=it.first){\\n                string a=\"\";\\n                if(num>=100){\\n                    a=numberToWords(num/it.first)+\" \";\\n                }\\n                string b=it.second;\\n                string c=\"\";\\n                if(num!=0&&(num%it.first)!=0)\\n                    c=\" \"+numberToWords(num%it.first);\\n                return a+b+c;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<pair<int,string>> mp={\\n        {1000000000,\"Billion\"},{1000000,\"Million\"},{1000,\"Thousand\"},{100,\"Hundred\"},{90,\"Ninety\"},{80,\"Eighty\"},{70,\"Seventy\"},{60,\"Sixty\"},{50,\"Fifty\"},{40,\"Forty\"},{30,\"Thirty\"},{20,\"Twenty\"},{19,\"Nineteen\"},{18,\"Eighteen\"},{17,\"Seventeen\"},{16,\"Sixteen\"},{15,\"Fifteen\"},{14,\"Fourteen\"},{13,\"Thirteen\"},{12,\"Twelve\"},{11,\"Eleven\"},{10,\"Ten\"},{9,\"Nine\"},{8,\"Eight\"},{7,\"Seven\"},{6,\"Six\"},{5,\"Five\"},{4,\"Four\"},{3,\"Three\"},{2,\"Two\"},{1,\"One\"},{0,\"Zero\"}};\\npublic:\\n    string numberToWords(int num) {\\n        for(auto it:mp){\\n            if(num>=it.first){\\n                string a=\"\";\\n                if(num>=100){\\n                    a=numberToWords(num/it.first)+\" \";\\n                }\\n                string b=it.second;\\n                string c=\"\";\\n                if(num!=0&&(num%it.first)!=0)\\n                    c=\" \"+numberToWords(num%it.first);\\n                return a+b+c;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136972,
                "title": "c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n# Code\\n```\\npublic class Solution {\\npublic Dictionary<int, string> dict = new Dictionary<int, string>();\\n    public string NumberToWords(int num) {\\n        \\n        if(num == 0) return \"Zero\";\\n        InitDict();\\n\\n        var r = Convert(num);\\n        return r.Substring(0, r.Length - 1);\\n        \\n        \\n    }\\n\\n    public string Convert(int num) {\\n\\n        foreach (var key in dict.Keys)\\n        {\\n            if (num >= key)\\n            {\\n                var res = dict[key] + \" \" + Convert(num % key);\\n                if(num >= 100) res = Convert(num / key) + res;\\n                return res;\\n            }\\n        }\\n\\n        return \"\";\\n\\n    }\\n\\n\\n\\n    public void InitDict() {\\n        dict.Add(1000000000, \"Billion\");\\n        dict.Add(1000000, \"Million\");\\n        dict.Add(1000, \"Thousand\");\\n        dict.Add(100, \"Hundred\");\\n        dict.Add(90, \"Ninety\");\\n        dict.Add(80, \"Eighty\");\\n        dict.Add(70, \"Seventy\");\\n        dict.Add(60, \"Sixty\");\\n        dict.Add(50, \"Fifty\");\\n        dict.Add(40, \"Forty\");\\n        dict.Add(30, \"Thirty\");\\n        dict.Add(20, \"Twenty\");\\n        dict.Add(19, \"Nineteen\");\\n        dict.Add(18, \"Eighteen\");\\n        dict.Add(17, \"Seventeen\");\\n        dict.Add(16, \"Sixteen\");\\n        dict.Add(15, \"Fifteen\");\\n        dict.Add(14, \"Fourteen\");\\n        dict.Add(13, \"Thirteen\");\\n        dict.Add(12, \"Twelve\");\\n        dict.Add(11, \"Eleven\");\\n        dict.Add(10, \"Ten\");\\n        dict.Add(9, \"Nine\");\\n        dict.Add(8, \"Eight\");\\n        dict.Add(7, \"Seven\");\\n        dict.Add(6, \"Six\");\\n        dict.Add(5, \"Five\");\\n        dict.Add(4, \"Four\");\\n        dict.Add(3, \"Three\");\\n        dict.Add(2, \"Two\");\\n        dict.Add(1, \"One\");\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\npublic Dictionary<int, string> dict = new Dictionary<int, string>();\\n    public string NumberToWords(int num) {\\n        \\n        if(num == 0) return \"Zero\";\\n        InitDict();\\n\\n        var r = Convert(num);\\n        return r.Substring(0, r.Length - 1);\\n        \\n        \\n    }\\n\\n    public string Convert(int num) {\\n\\n        foreach (var key in dict.Keys)\\n        {\\n            if (num >= key)\\n            {\\n                var res = dict[key] + \" \" + Convert(num % key);\\n                if(num >= 100) res = Convert(num / key) + res;\\n                return res;\\n            }\\n        }\\n\\n        return \"\";\\n\\n    }\\n\\n\\n\\n    public void InitDict() {\\n        dict.Add(1000000000, \"Billion\");\\n        dict.Add(1000000, \"Million\");\\n        dict.Add(1000, \"Thousand\");\\n        dict.Add(100, \"Hundred\");\\n        dict.Add(90, \"Ninety\");\\n        dict.Add(80, \"Eighty\");\\n        dict.Add(70, \"Seventy\");\\n        dict.Add(60, \"Sixty\");\\n        dict.Add(50, \"Fifty\");\\n        dict.Add(40, \"Forty\");\\n        dict.Add(30, \"Thirty\");\\n        dict.Add(20, \"Twenty\");\\n        dict.Add(19, \"Nineteen\");\\n        dict.Add(18, \"Eighteen\");\\n        dict.Add(17, \"Seventeen\");\\n        dict.Add(16, \"Sixteen\");\\n        dict.Add(15, \"Fifteen\");\\n        dict.Add(14, \"Fourteen\");\\n        dict.Add(13, \"Thirteen\");\\n        dict.Add(12, \"Twelve\");\\n        dict.Add(11, \"Eleven\");\\n        dict.Add(10, \"Ten\");\\n        dict.Add(9, \"Nine\");\\n        dict.Add(8, \"Eight\");\\n        dict.Add(7, \"Seven\");\\n        dict.Add(6, \"Six\");\\n        dict.Add(5, \"Five\");\\n        dict.Add(4, \"Four\");\\n        dict.Add(3, \"Three\");\\n        dict.Add(2, \"Two\");\\n        dict.Add(1, \"One\");\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792335,
                "title": "java-simple-solution-clean-code-recursion",
                "content": "```\\nclass Solution {\\n    \\n    String[] ones = {\"\" , \"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n        \\n    String[] tens = {\"\",\"Ten\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n        \\n    int billion = 1000000000;\\n    int million = 1000000;\\n    int thousand = 1000;\\n    int hundred = 100;\\n    \\n    \\n    private String solve(int num){\\n        \\n        String ans = \"\";\\n        \\n        if(num >= billion){\\n            ans = solve(num / billion) + \" Billion \" + solve(num % billion);\\n        }\\n        else if(num >= million){\\n            ans = solve(num / million) + \" Million \" + solve(num % million);\\n        }\\n        else if(num >= thousand){\\n            ans = solve(num / thousand) + \" Thousand \" + solve(num % thousand);\\n        }\\n        else if(num >= hundred){\\n            ans = solve(num / hundred) + \" Hundred \" + solve(num % hundred);\\n        }\\n        else if(num <= 19){\\n            ans = ones[num]; \\n        }\\n        else{\\n            ans = tens[num / 10] + \" \" + solve(num % 10);\\n        }\\n        \\n        return ans.trim();\\n    }\\n    \\n    \\n    public String numberToWords(int num) {\\n        if(num == 0){\\n            return \"Zero\";\\n        }\\n        \\n        return solve(num).trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    String[] ones = {\"\" , \"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n        \\n    String[] tens = {\"\",\"Ten\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n        \\n    int billion = 1000000000;\\n    int million = 1000000;\\n    int thousand = 1000;\\n    int hundred = 100;\\n    \\n    \\n    private String solve(int num){\\n        \\n        String ans = \"\";\\n        \\n        if(num >= billion){\\n            ans = solve(num / billion) + \" Billion \" + solve(num % billion);\\n        }\\n        else if(num >= million){\\n            ans = solve(num / million) + \" Million \" + solve(num % million);\\n        }\\n        else if(num >= thousand){\\n            ans = solve(num / thousand) + \" Thousand \" + solve(num % thousand);\\n        }\\n        else if(num >= hundred){\\n            ans = solve(num / hundred) + \" Hundred \" + solve(num % hundred);\\n        }\\n        else if(num <= 19){\\n            ans = ones[num]; \\n        }\\n        else{\\n            ans = tens[num / 10] + \" \" + solve(num % 10);\\n        }\\n        \\n        return ans.trim();\\n    }\\n    \\n    \\n    public String numberToWords(int num) {\\n        if(num == 0){\\n            return \"Zero\";\\n        }\\n        \\n        return solve(num).trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749504,
                "title": "c-horrible",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string numberToWords(int num) {\\n        if(num/1000000000 > 0) return num%1000000000==0 ? numberToWords(num/1000000000) + \" Billion\" : numberToWords(num/1000000000) + \" Billion \" + numberToWords(num%1000000000);\\n        if(num/1000000 > 0) return num%1000000==0 ? numberToWords(num/1000000) + \" Million\" : numberToWords(num/1000000) + \" Million \" + numberToWords(num%1000000);        \\n        if(num/1000 > 0) return num%1000==0 ? numberToWords(num/1000) + \" Thousand\" : numberToWords(num/1000) + \" Thousand \" + numberToWords(num%1000);        \\n        if(num/100 > 0) return num%100==0 ? numberToWords(num/100) + \" Hundred\" : numberToWords(num/100) + \" Hundred \" + numberToWords(num%100);        \\n        if(num/90 > 0) return num==90 ? \"Ninety\" : \"Ninety \" + numberToWords(num%90);\\n        if(num/80 > 0) return num==80 ? \"Eighty\": \"Eighty \" + numberToWords(num%80);        \\n        if(num/70 > 0) return num==70 ? \"Seventy\": \"Seventy \" + numberToWords(num%70);        \\n        if(num/60 > 0) return num==60 ? \"Sixty\" : \"Sixty \" + numberToWords(num%60);        \\n        if(num/50 > 0) return num==50 ? \"Fifty\" : \"Fifty \" + numberToWords(num%50);\\n        if(num/40 > 0) return num==40 ? \"Forty\" : \"Forty \" + numberToWords(num%40);        \\n        if(num/30 > 0) return num==30 ? \"Thirty\" : \"Thirty \" + numberToWords(num%30);        \\n        if(num/20 > 0) return num==20 ? \"Twenty\": \"Twenty \" + numberToWords(num%20);        \\n        switch(num)\\n        {\\n            case 19: return \"Nineteen\";\\n            case 18: return \"Eighteen\";\\n            case 17: return \"Seventeen\";\\n            case 16: return \"Sixteen\";\\n            case 15: return \"Fifteen\";\\n            case 14: return \"Fourteen\";\\n            case 13: return \"Thirteen\";\\n            case 12: return \"Twelve\";\\n            case 11: return \"Eleven\";\\n            case 10: return \"Ten\";\\n            case 9: return \"Nine\";\\n            case 8: return \"Eight\";\\n            case 7: return \"Seven\";\\n            case 6: return \"Six\";\\n            case 5: return \"Five\";\\n            case 4: return \"Four\";\\n            case 3: return \"Three\";\\n            case 2: return \"Two\";\\n            case 1: return \"One\";\\n        }\\n\\n        return \"Zero\";\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string numberToWords(int num) {\\n        if(num/1000000000 > 0) return num%1000000000==0 ? numberToWords(num/1000000000) + \" Billion\" : numberToWords(num/1000000000) + \" Billion \" + numberToWords(num%1000000000);\\n        if(num/1000000 > 0) return num%1000000==0 ? numberToWords(num/1000000) + \" Million\" : numberToWords(num/1000000) + \" Million \" + numberToWords(num%1000000);        \\n        if(num/1000 > 0) return num%1000==0 ? numberToWords(num/1000) + \" Thousand\" : numberToWords(num/1000) + \" Thousand \" + numberToWords(num%1000);        \\n        if(num/100 > 0) return num%100==0 ? numberToWords(num/100) + \" Hundred\" : numberToWords(num/100) + \" Hundred \" + numberToWords(num%100);        \\n        if(num/90 > 0) return num==90 ? \"Ninety\" : \"Ninety \" + numberToWords(num%90);\\n        if(num/80 > 0) return num==80 ? \"Eighty\": \"Eighty \" + numberToWords(num%80);        \\n        if(num/70 > 0) return num==70 ? \"Seventy\": \"Seventy \" + numberToWords(num%70);        \\n        if(num/60 > 0) return num==60 ? \"Sixty\" : \"Sixty \" + numberToWords(num%60);        \\n        if(num/50 > 0) return num==50 ? \"Fifty\" : \"Fifty \" + numberToWords(num%50);\\n        if(num/40 > 0) return num==40 ? \"Forty\" : \"Forty \" + numberToWords(num%40);        \\n        if(num/30 > 0) return num==30 ? \"Thirty\" : \"Thirty \" + numberToWords(num%30);        \\n        if(num/20 > 0) return num==20 ? \"Twenty\": \"Twenty \" + numberToWords(num%20);        \\n        switch(num)\\n        {\\n            case 19: return \"Nineteen\";\\n            case 18: return \"Eighteen\";\\n            case 17: return \"Seventeen\";\\n            case 16: return \"Sixteen\";\\n            case 15: return \"Fifteen\";\\n            case 14: return \"Fourteen\";\\n            case 13: return \"Thirteen\";\\n            case 12: return \"Twelve\";\\n            case 11: return \"Eleven\";\\n            case 10: return \"Ten\";\\n            case 9: return \"Nine\";\\n            case 8: return \"Eight\";\\n            case 7: return \"Seven\";\\n            case 6: return \"Six\";\\n            case 5: return \"Five\";\\n            case 4: return \"Four\";\\n            case 3: return \"Three\";\\n            case 2: return \"Two\";\\n            case 1: return \"One\";\\n        }\\n\\n        return \"Zero\";\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691379,
                "title": "java-simple-solution-w-time-space-complexity-explained-o-1",
                "content": "# Intuition\\nJava Solution to Integer to English Words.\\n\\nComments included for reference.\\n\\n# Approach\\nSolved using a recursive helper function to break down the number into smaller parts and combine each part to return the final String representation of the number. Used StringBuilder to improve performance over adding to Strings.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ since we will only recurse a constant number of times.\\n    - In the worst case scenario, when a number is greater than one billion, for example, the function helper is called a constant number of times. If you derive the recursion tree of this function, you\\'ll see that the longest path in this situation (number greater than one billion) is: helper(num > 10^9) is the first to be called, then helper(10^6 < num < 10^9) is called (from the else statement), then helper(10^3 < num < 10^6), then helper(10^2 < num < 10^3), then helper(20 < num < 10^2), and finally, helper(num < 20), when returns a string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ since a constant single String is returned.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private final String[] LESS_THAN_20 = new String[] {\\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\\n    };\\n    private final String[] TENS = new String[] {\\n        \"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"\\n    };\\n    private final int billion = 1000000000;\\n    private final int million = 1000000;\\n    private final int thousand = 1000;\\n    private final int hundred = 100;\\n    private final int ten = 10;\\n\\n    public String numberToWords(int num) {\\n        // Default case when input num is 0\\n        if (num == 0) return \"Zero\";\\n\\n        return converterHelper(num);\\n    }\\n\\n    /**\\n     * Recursive Helper Function To Build String Representation Of An Input Non-Negative Integer.\\n     */\\n    private String converterHelper(int num) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        // Number is greater than or equal to 1,000,000,000\\n        if (num >= billion)\\n        {\\n            sb.append(converterHelper(num / billion)).append(\" Billion \").append(converterHelper(num % billion));\\n        }\\n        // Numer is greater than or equal to 1,000,000\\n        else if (num >= million)\\n        {\\n            sb.append(converterHelper(num / million)).append(\" Million \").append(converterHelper(num % million));\\n        }\\n        // Number is greater than or equal to 1,000\\n        else if (num >= thousand)\\n        {\\n            sb.append(converterHelper(num / thousand)).append(\" Thousand \").append(converterHelper(num % thousand));\\n        }\\n        // Number is greater than or equal to 100\\n        else if (num >= hundred)\\n        {\\n            sb.append(converterHelper(num / hundred)).append(\" Hundred \").append(converterHelper(num % hundred));\\n        }\\n        // Number is greater than or equal to 20\\n        else if (num >= 20)\\n        {\\n            sb.append(TENS[num / ten]).append(\" \").append(converterHelper(num % ten));\\n        }\\n        // Number is less less than 20, find number in LESS_THAN_20 array and append to sb\\n        else\\n        {\\n            sb.append(LESS_THAN_20[num]);\\n        }\\n\\n        // Return the converted String representation of the input integer \\'num\\' with leading and trailing spaces trimmed\\n        return sb.toString().trim();\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    private final String[] LESS_THAN_20 = new String[] {\\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\\n    };\\n    private final String[] TENS = new String[] {\\n        \"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"\\n    };\\n    private final int billion = 1000000000;\\n    private final int million = 1000000;\\n    private final int thousand = 1000;\\n    private final int hundred = 100;\\n    private final int ten = 10;\\n\\n    public String numberToWords(int num) {\\n        // Default case when input num is 0\\n        if (num == 0) return \"Zero\";\\n\\n        return converterHelper(num);\\n    }\\n\\n    /**\\n     * Recursive Helper Function To Build String Representation Of An Input Non-Negative Integer.\\n     */\\n    private String converterHelper(int num) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        // Number is greater than or equal to 1,000,000,000\\n        if (num >= billion)\\n        {\\n            sb.append(converterHelper(num / billion)).append(\" Billion \").append(converterHelper(num % billion));\\n        }\\n        // Numer is greater than or equal to 1,000,000\\n        else if (num >= million)\\n        {\\n            sb.append(converterHelper(num / million)).append(\" Million \").append(converterHelper(num % million));\\n        }\\n        // Number is greater than or equal to 1,000\\n        else if (num >= thousand)\\n        {\\n            sb.append(converterHelper(num / thousand)).append(\" Thousand \").append(converterHelper(num % thousand));\\n        }\\n        // Number is greater than or equal to 100\\n        else if (num >= hundred)\\n        {\\n            sb.append(converterHelper(num / hundred)).append(\" Hundred \").append(converterHelper(num % hundred));\\n        }\\n        // Number is greater than or equal to 20\\n        else if (num >= 20)\\n        {\\n            sb.append(TENS[num / ten]).append(\" \").append(converterHelper(num % ten));\\n        }\\n        // Number is less less than 20, find number in LESS_THAN_20 array and append to sb\\n        else\\n        {\\n            sb.append(LESS_THAN_20[num]);\\n        }\\n\\n        // Return the converted String representation of the input integer \\'num\\' with leading and trailing spaces trimmed\\n        return sb.toString().trim();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571623,
                "title": "javascript-simple-methodical",
                "content": "```\\nvar numberToWords = function(num) {\\n    if (num === 0) return \\'Zero\\';\\n    const map = {\\n        1: \\'One\\',\\n        2: \\'Two\\',\\n        3: \\'Three\\',\\n        4: \\'Four\\',\\n        5: \\'Five\\',\\n        6: \\'Six\\',\\n        7: \\'Seven\\',\\n        8: \\'Eight\\',\\n        9: \\'Nine\\',\\n        10: \\'Ten\\',\\n        11: \\'Eleven\\',\\n        12: \\'Twelve\\',\\n        13: \\'Thirteen\\',\\n        14: \\'Fourteen\\',\\n        15: \\'Fifteen\\',\\n        16: \\'Sixteen\\',\\n        17: \\'Seventeen\\',\\n        18: \\'Eighteen\\',\\n        19: \\'Nineteen\\',\\n        20: \\'Twenty\\',\\n        30: \\'Thirty\\',\\n        40: \\'Forty\\',\\n        50: \\'Fifty\\',\\n        60: \\'Sixty\\',\\n        70: \\'Seventy\\',\\n        80: \\'Eighty\\',\\n        90: \\'Ninety\\',\\n    }\\n    \\n    const billion = 1000000000;\\n    const million = 1000000;\\n    const thousand = 1000;\\n    const hundred = 100;\\n    const tens = 10;\\n    \\n    const convertNum = (num) => {\\n        let str = \\'\\';\\n        if (num >= hundred) {\\n            str += map[Math.floor(num / hundred)] + \\' Hundred \\';\\n            num = num % hundred;\\n        }\\n        if (num >= tens) {\\n            if (map[num]) {\\n                str += map[num] + \\' \\';\\n                num -= num;\\n            } else {\\n                str += map[Math.floor(num / tens) * tens] + \\' \\';\\n                num = num % tens;\\n            }\\n        }\\n        if (num >= 1) {\\n            str += map[num];\\n        }\\n        return str.trim();\\n    }\\n    \\n    let str = \\'\\';\\n    if (num >= billion) {\\n        str += convertNum(Math.floor(num / billion)) + \\' Billion \\';\\n        num = num % billion;\\n    }\\n    if (num >= million) {\\n        str += convertNum(Math.floor(num / million)) + \\' Million \\';\\n        num = num % million;\\n    }\\n    if (num >= thousand) {\\n        str += convertNum(Math.floor(num / thousand)) + \\' Thousand \\';\\n        num = num % thousand;\\n    }\\n    str += convertNum(Math.floor(num))\\n    return str.trim();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberToWords = function(num) {\\n    if (num === 0) return \\'Zero\\';\\n    const map = {\\n        1: \\'One\\',\\n        2: \\'Two\\',\\n        3: \\'Three\\',\\n        4: \\'Four\\',\\n        5: \\'Five\\',\\n        6: \\'Six\\',\\n        7: \\'Seven\\',\\n        8: \\'Eight\\',\\n        9: \\'Nine\\',\\n        10: \\'Ten\\',\\n        11: \\'Eleven\\',\\n        12: \\'Twelve\\',\\n        13: \\'Thirteen\\',\\n        14: \\'Fourteen\\',\\n        15: \\'Fifteen\\',\\n        16: \\'Sixteen\\',\\n        17: \\'Seventeen\\',\\n        18: \\'Eighteen\\',\\n        19: \\'Nineteen\\',\\n        20: \\'Twenty\\',\\n        30: \\'Thirty\\',\\n        40: \\'Forty\\',\\n        50: \\'Fifty\\',\\n        60: \\'Sixty\\',\\n        70: \\'Seventy\\',\\n        80: \\'Eighty\\',\\n        90: \\'Ninety\\',\\n    }\\n    \\n    const billion = 1000000000;\\n    const million = 1000000;\\n    const thousand = 1000;\\n    const hundred = 100;\\n    const tens = 10;\\n    \\n    const convertNum = (num) => {\\n        let str = \\'\\';\\n        if (num >= hundred) {\\n            str += map[Math.floor(num / hundred)] + \\' Hundred \\';\\n            num = num % hundred;\\n        }\\n        if (num >= tens) {\\n            if (map[num]) {\\n                str += map[num] + \\' \\';\\n                num -= num;\\n            } else {\\n                str += map[Math.floor(num / tens) * tens] + \\' \\';\\n                num = num % tens;\\n            }\\n        }\\n        if (num >= 1) {\\n            str += map[num];\\n        }\\n        return str.trim();\\n    }\\n    \\n    let str = \\'\\';\\n    if (num >= billion) {\\n        str += convertNum(Math.floor(num / billion)) + \\' Billion \\';\\n        num = num % billion;\\n    }\\n    if (num >= million) {\\n        str += convertNum(Math.floor(num / million)) + \\' Million \\';\\n        num = num % million;\\n    }\\n    if (num >= thousand) {\\n        str += convertNum(Math.floor(num / thousand)) + \\' Thousand \\';\\n        num = num % thousand;\\n    }\\n    str += convertNum(Math.floor(num))\\n    return str.trim();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2568555,
                "title": "python-solution-with-explanation-and-comments",
                "content": "Each number in english can be split into group of 3 numbers each when speaking in words. Essentially the problem turns into break an input number into group of 3 numbers that we can called three_digits_to_str each with a few special cases.\\n\\nThis is why three_digits_to_str is used repeatedly to call for each set of group of 3 numbers after we do the math for each.\\n\\nthree_digits_to_str turns into get first digit for the hundred AND two_digits_int_to_str. \\n\\nA special case that we need to account for is in the two_digits_int_to_str. We need to account for number < 20 but > 10\\n\\nOnce we solved this sub problem of three_digits_to_str, we can tackle the bigger ones. This invovles continously getting the string result for \"Billion\", \"Million\", and \"Thousand\" and append them all into a string when needed (The floor division returns some number instead of 0)\\n\\nYou might wonder why after we get to thousand unit, we do not continue dividing and getting the number for hundred. This is because for each group of number (billion group, million group, thousand group), we have a problem of converting int of a number < 999 to a string. So it makes more sense to move this to a function that we can call again. \\n\\nDuring interview, you should not spend all the time coming up with the dictionary for each set of number. Instead, communicate your idea to the interviewer and start each dict with the first and last number that you want to represent. Example:\\n self.ONE_DIGIT = {\\n 1: \"One\",\\n ...\\n 9: \"Nine\",\\n }\\n\\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.ONE_DIGIT = {\\n            1: \\'One\\',\\n            2: \\'Two\\',\\n            3: \\'Three\\',\\n            4: \\'Four\\',\\n            5: \\'Five\\',\\n            6: \\'Six\\',\\n            7: \\'Seven\\',\\n            8: \\'Eight\\',\\n            9: \\'Nine\\'\\n        }\\n        \\n        self.LESS_THAN_20 = {\\n            10: \\'Ten\\',\\n            11: \\'Eleven\\',\\n            12: \\'Twelve\\',\\n            13: \\'Thirteen\\',\\n            14: \\'Fourteen\\',\\n            15: \\'Fifteen\\',\\n            16: \\'Sixteen\\',\\n            17: \\'Seventeen\\',\\n            18: \\'Eighteen\\',\\n            19: \\'Nineteen\\'\\n        }\\n        \\n        self.FIRST_DIGIT_LESS_THAN_99 = {\\n            2: \\'Twenty\\',\\n            3: \\'Thirty\\',\\n            4: \\'Forty\\',\\n            5: \\'Fifty\\',\\n            6: \\'Sixty\\',\\n            7: \\'Seventy\\',\\n            8: \\'Eighty\\',\\n            9: \\'Ninety\\'\\n        }\\n        \\n    def three_digits_to_str(self, num:int):\\n        hundred = num //100\\n        less_than_hundred = num - hundred * 100\\n        \\n        if hundred and less_than_hundred:\\n            return self.ONE_DIGIT[hundred] + \" Hundred \" + self.two_digits_int_to_str(less_than_hundred)\\n        elif not hundred and less_than_hundred:\\n            return self.two_digits_int_to_str(less_than_hundred)\\n        elif hundred and not less_than_hundred:\\n            return self.ONE_DIGIT[hundred] + \" Hundred\"\\n        \\n    def numberToWords(self, num: int) -> str:\\n        if not num:\\n            return \"Zero\"\\n        \\n        billion = num // 1000000000\\n        million = (num - billion * 1000000000) // 1000000\\n        thousand = (num - billion * 1000000000 - million * 1000000) // 1000\\n        less_than_thousand = num - billion * 1000000000 - million * 1000000 - thousand * 1000\\n        \\n        result = \"\"\\n        if billion:\\n            result = self.three_digits_to_str(billion) + \" Billion \"\\n        if million:\\n            result += self.three_digits_to_str(million) + \" Million \"\\n        if thousand:\\n            result += self.three_digits_to_str(thousand) + \" Thousand \"\\n        if less_than_thousand:\\n            result += self.three_digits_to_str(less_than_thousand)\\n        return result.strip()\\n            \\n    def two_digits_int_to_str(self, num:int) -> str:\\n        # This returns empty if num is 0\\n        if not num:\\n            return \"\"\\n        elif num < 10:\\n            return self.ONE_DIGIT[num]   \\n        elif num < 20:\\n            return self.LESS_THAN_20[num]\\n        else:\\n            first_digit = num//10\\n            second_digit = num%10\\n            if second_digit:\\n                return self.FIRST_DIGIT_LESS_THAN_99[first_digit] + \" \" + self.ONE_DIGIT[second_digit]\\n            else:\\n                return self.FIRST_DIGIT_LESS_THAN_99[first_digit]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.ONE_DIGIT = {\\n            1: \\'One\\',\\n            2: \\'Two\\',\\n            3: \\'Three\\',\\n            4: \\'Four\\',\\n            5: \\'Five\\',\\n            6: \\'Six\\',\\n            7: \\'Seven\\',\\n            8: \\'Eight\\',\\n            9: \\'Nine\\'\\n        }\\n        \\n        self.LESS_THAN_20 = {\\n            10: \\'Ten\\',\\n            11: \\'Eleven\\',\\n            12: \\'Twelve\\',\\n            13: \\'Thirteen\\',\\n            14: \\'Fourteen\\',\\n            15: \\'Fifteen\\',\\n            16: \\'Sixteen\\',\\n            17: \\'Seventeen\\',\\n            18: \\'Eighteen\\',\\n            19: \\'Nineteen\\'\\n        }\\n        \\n        self.FIRST_DIGIT_LESS_THAN_99 = {\\n            2: \\'Twenty\\',\\n            3: \\'Thirty\\',\\n            4: \\'Forty\\',\\n            5: \\'Fifty\\',\\n            6: \\'Sixty\\',\\n            7: \\'Seventy\\',\\n            8: \\'Eighty\\',\\n            9: \\'Ninety\\'\\n        }\\n        \\n    def three_digits_to_str(self, num:int):\\n        hundred = num //100\\n        less_than_hundred = num - hundred * 100\\n        \\n        if hundred and less_than_hundred:\\n            return self.ONE_DIGIT[hundred] + \" Hundred \" + self.two_digits_int_to_str(less_than_hundred)\\n        elif not hundred and less_than_hundred:\\n            return self.two_digits_int_to_str(less_than_hundred)\\n        elif hundred and not less_than_hundred:\\n            return self.ONE_DIGIT[hundred] + \" Hundred\"\\n        \\n    def numberToWords(self, num: int) -> str:\\n        if not num:\\n            return \"Zero\"\\n        \\n        billion = num // 1000000000\\n        million = (num - billion * 1000000000) // 1000000\\n        thousand = (num - billion * 1000000000 - million * 1000000) // 1000\\n        less_than_thousand = num - billion * 1000000000 - million * 1000000 - thousand * 1000\\n        \\n        result = \"\"\\n        if billion:\\n            result = self.three_digits_to_str(billion) + \" Billion \"\\n        if million:\\n            result += self.three_digits_to_str(million) + \" Million \"\\n        if thousand:\\n            result += self.three_digits_to_str(thousand) + \" Thousand \"\\n        if less_than_thousand:\\n            result += self.three_digits_to_str(less_than_thousand)\\n        return result.strip()\\n            \\n    def two_digits_int_to_str(self, num:int) -> str:\\n        # This returns empty if num is 0\\n        if not num:\\n            return \"\"\\n        elif num < 10:\\n            return self.ONE_DIGIT[num]   \\n        elif num < 20:\\n            return self.LESS_THAN_20[num]\\n        else:\\n            first_digit = num//10\\n            second_digit = num%10\\n            if second_digit:\\n                return self.FIRST_DIGIT_LESS_THAN_99[first_digit] + \" \" + self.ONE_DIGIT[second_digit]\\n            else:\\n                return self.FIRST_DIGIT_LESS_THAN_99[first_digit]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541005,
                "title": "brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string one(int num)\\n    {\\n        switch(num)\\n        {\\n            case 1: return \"One\";\\n            case 2: return \"Two\";\\n            case 3: return \"Three\";\\n            case 4: return \"Four\";\\n            case 5: return \"Five\";\\n            case 6: return \"Six\";\\n            case 7: return \"Seven\";\\n            case 8: return \"Eight\";\\n            case 9: return \"Nine\";\\n            default: return \"\";\\n        }\\n    }\\n    string ten(int num)\\n    {\\n        switch(num)\\n        {\\n            case 2: return \"Twenty\";\\n            case 3: return \"Thirty\";\\n            case 4: return \"Forty\";\\n            case 5: return \"Fifty\";\\n            case 6: return \"Sixty\";\\n            case 7: return \"Seventy\";\\n            case 8: return \"Eighty\";\\n            case 9: return \"Ninety\";\\n            default: return \"\";\\n        }\\n    }\\n    string lessThan20(int num)\\n    {\\n        switch(num)\\n        {\\n            case 10: return \"Ten\";\\n            case 11: return \"Eleven\";\\n            case 12: return \"Twelve\";\\n            case 13: return \"Thirteen\";\\n            case 14: return \"Fourteen\";\\n            case 15: return \"Fifteen\";\\n            case 16: return \"Sixteen\";\\n            case 17: return \"Seventeen\";\\n            case 18: return \"Eighteen\";\\n            case 19: return \"Nineteen\";\\n            default: return \"\";\\n        }\\n    }\\n    \\n    string value(int n){\\n        string st = to_string(n);\\n        string s = \"\";\\n        if(st.size() == 3){\\n            int hundred = n/100;\\n            n = n%100;\\n            s += one(hundred) + \" Hundred\";\\n        }\\n        if(9 < n && n < 100){\\n            if(s.size() != 0) s += \" \";\\n            if(n < 20) {\\n                s += lessThan20(n);\\n                return s;\\n            }\\n            else s += ten(n/10);\\n            n = n%10;\\n            \\n        }\\n        if(n != 0){\\n            if(s.size() != 0) s += \" \";\\n            s += one(n);\\n        }\\n        return s;\\n    }\\n    \\n    string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        string ans = \"\";\\n        int billion = num/ (1000000000);\\n        num %= 1000000000;\\n        int million = num/1000000;\\n        num %= 1000000;\\n        int thousand = num/1000;\\n        num %= 1000;\\n        if(billion != 0){\\n            ans += value(billion) + \" Billion\";\\n        }\\n        if(million != 0){\\n            if(ans.size() != 0) ans += \" \";\\n            ans += value(million) + \" Million\";\\n        }\\n        if(thousand != 0){\\n            if(ans.size() != 0) ans += \" \";\\n            ans += value(thousand) + \" Thousand\";\\n        }\\n        if(num != 0){\\n            if(ans.size() != 0) ans += \" \";\\n            ans += value(num);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string one(int num)\\n    {\\n        switch(num)\\n        {\\n            case 1: return \"One\";\\n            case 2: return \"Two\";\\n            case 3: return \"Three\";\\n            case 4: return \"Four\";\\n            case 5: return \"Five\";\\n            case 6: return \"Six\";\\n            case 7: return \"Seven\";\\n            case 8: return \"Eight\";\\n            case 9: return \"Nine\";\\n            default: return \"\";\\n        }\\n    }\\n    string ten(int num)\\n    {\\n        switch(num)\\n        {\\n            case 2: return \"Twenty\";\\n            case 3: return \"Thirty\";\\n            case 4: return \"Forty\";\\n            case 5: return \"Fifty\";\\n            case 6: return \"Sixty\";\\n            case 7: return \"Seventy\";\\n            case 8: return \"Eighty\";\\n            case 9: return \"Ninety\";\\n            default: return \"\";\\n        }\\n    }\\n    string lessThan20(int num)\\n    {\\n        switch(num)\\n        {\\n            case 10: return \"Ten\";\\n            case 11: return \"Eleven\";\\n            case 12: return \"Twelve\";\\n            case 13: return \"Thirteen\";\\n            case 14: return \"Fourteen\";\\n            case 15: return \"Fifteen\";\\n            case 16: return \"Sixteen\";\\n            case 17: return \"Seventeen\";\\n            case 18: return \"Eighteen\";\\n            case 19: return \"Nineteen\";\\n            default: return \"\";\\n        }\\n    }\\n    \\n    string value(int n){\\n        string st = to_string(n);\\n        string s = \"\";\\n        if(st.size() == 3){\\n            int hundred = n/100;\\n            n = n%100;\\n            s += one(hundred) + \" Hundred\";\\n        }\\n        if(9 < n && n < 100){\\n            if(s.size() != 0) s += \" \";\\n            if(n < 20) {\\n                s += lessThan20(n);\\n                return s;\\n            }\\n            else s += ten(n/10);\\n            n = n%10;\\n            \\n        }\\n        if(n != 0){\\n            if(s.size() != 0) s += \" \";\\n            s += one(n);\\n        }\\n        return s;\\n    }\\n    \\n    string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        string ans = \"\";\\n        int billion = num/ (1000000000);\\n        num %= 1000000000;\\n        int million = num/1000000;\\n        num %= 1000000;\\n        int thousand = num/1000;\\n        num %= 1000;\\n        if(billion != 0){\\n            ans += value(billion) + \" Billion\";\\n        }\\n        if(million != 0){\\n            if(ans.size() != 0) ans += \" \";\\n            ans += value(million) + \" Million\";\\n        }\\n        if(thousand != 0){\\n            if(ans.size() != 0) ans += \" \";\\n            ans += value(thousand) + \" Thousand\";\\n        }\\n        if(num != 0){\\n            if(ans.size() != 0) ans += \" \";\\n            ans += value(num);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489495,
                "title": "c-question-asked-in-dp-world-company-most-simple-recursive-code-exist-ever",
                "content": "```\\n// Asked in DP World Company\\nclass Solution {\\npublic:\\n    \\n    // 0 to 19\\n    string ones[20] = {\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\\n    \"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n    \\n    // tens only\\n    string tens[10] = {\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n    \\n    /* Thousand - 1000\\n       Million  - 1000 000\\n       Billion  - 1000 000 000 \\n    */\\n    \\n    string helper(int num) \\n    {\\n        if(num >=1000000000) \\n        {\\n            return helper(num/1000000000) + \" Billion\" + helper(num%1000000000);\\n        } \\n        else if(num >=1000000) \\n        {\\n            return helper(num/1000000) + \" Million\" + helper(num%1000000);\\n        } \\n        else if(num>=1000) \\n        {\\n            return helper(num/1000) + \" Thousand\" + helper(num%1000);\\n        } \\n        else if(num >=100) \\n        {\\n            return helper(num/100) + \" Hundred\" + helper(num%100);\\n        } \\n        else if(num >= 20) \\n        {\\n            return \" \" + tens[num/10] + helper(num%10);\\n        } \\n        else // 0 to 19...\\n            return (ones[num]!=\"\") ?  \" \" + ones[num] : \"\";\\n        return \"\";\\n    }\\n    \\n    string numberToWords(int num) \\n    {\\n        if(num == 0) return \"Zero\";\\n        \\n        string ans = helper(num);\\n        return ans.substr(1); // pass start index\\n    }  \\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n// Asked in DP World Company\\nclass Solution {\\npublic:\\n    \\n    // 0 to 19\\n    string ones[20] = {\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\\n    \"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n    \\n    // tens only\\n    string tens[10] = {\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n    \\n    /* Thousand - 1000\\n       Million  - 1000 000\\n       Billion  - 1000 000 000 \\n    */\\n    \\n    string helper(int num) \\n    {\\n        if(num >=1000000000) \\n        {\\n            return helper(num/1000000000) + \" Billion\" + helper(num%1000000000);\\n        } \\n        else if(num >=1000000) \\n        {\\n            return helper(num/1000000) + \" Million\" + helper(num%1000000);\\n        } \\n        else if(num>=1000) \\n        {\\n            return helper(num/1000) + \" Thousand\" + helper(num%1000);\\n        } \\n        else if(num >=100) \\n        {\\n            return helper(num/100) + \" Hundred\" + helper(num%100);\\n        } \\n        else if(num >= 20) \\n        {\\n            return \" \" + tens[num/10] + helper(num%10);\\n        } \\n        else // 0 to 19...\\n            return (ones[num]!=\"\") ?  \" \" + ones[num] : \"\";\\n        return \"\";\\n    }\\n    \\n    string numberToWords(int num) \\n    {\\n        if(num == 0) return \"Zero\";\\n        \\n        string ans = helper(num);\\n        return ans.substr(1); // pass start index\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420008,
                "title": "java-100-faster-clean-code",
                "content": "Upvote if the solution helped :) For all my optimized solutions, visit my [GitHub Repo](https://github.com/abhideepghosh/Leetcode-Solutions).\\n```\\n/*\\nRuntime: 2 ms, faster than 99.52% of Java online submissions for Integer to English Words.\\nMemory Usage: 40.6 MB, less than 97.55% of Java online submissions for Integer to English Words.\\n*/\\nclass Solution {\\n    private final String[] LESS_THAN_TWENTY = {\"\", \"One \", \"Two \", \"Three \", \"Four \", \"Five \", \"Six \", \"Seven \", \"Eight \", \"Nine \", \"Ten \", \"Eleven \", \"Twelve \", \"Thirteen \", \"Fourteen \", \"Fifteen \", \"Sixteen \", \"Seventeen \", \"Eighteen \", \"Nineteen \"};\\n    private final String[] TWENTY_TO_NINETY = {\"\", \"\", \"Twenty \", \"Thirty \", \"Forty \", \"Fifty \", \"Sixty \", \"Seventy \", \"Eighty \", \"Ninety \"};\\n    private final String[] THOUSANDS = {\"\", \"Thousand \", \"Million \", \"Billion \"};\\n    \\n    public String numberToWords(int num) {\\n        if (num == 0) {\\n            return \"Zero\";\\n        }\\n        StringBuilder res = new StringBuilder();\\n       \\n        for (int i = 3; i > 0; i--) {\\n            int n = (int) Math.pow(1000, i);\\n            if (num >= n) {\\n                res.append(getSymbol(num / n)).append(THOUSANDS[i]);\\n                num %= n;\\n            }\\n        }\\n\\n        res.append(getSymbol(num));\\n        return res.toString().trim();                                                \\n    } \\n    private String getSymbol(int num) {\\n        StringBuilder str = new StringBuilder();\\n        if (num >= 100) {\\n            str.append(LESS_THAN_TWENTY[num / 100]).append(\"Hundred \");\\n            num %= 100;\\n        }\\n        if (num >= 20) {\\n            str.append(TWENTY_TO_NINETY[num / 10]).append(LESS_THAN_TWENTY[num % 10]);\\n        } else {\\n            str.append(LESS_THAN_TWENTY[num]);\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nRuntime: 2 ms, faster than 99.52% of Java online submissions for Integer to English Words.\\nMemory Usage: 40.6 MB, less than 97.55% of Java online submissions for Integer to English Words.\\n*/\\nclass Solution {\\n    private final String[] LESS_THAN_TWENTY = {\"\", \"One \", \"Two \", \"Three \", \"Four \", \"Five \", \"Six \", \"Seven \", \"Eight \", \"Nine \", \"Ten \", \"Eleven \", \"Twelve \", \"Thirteen \", \"Fourteen \", \"Fifteen \", \"Sixteen \", \"Seventeen \", \"Eighteen \", \"Nineteen \"};\\n    private final String[] TWENTY_TO_NINETY = {\"\", \"\", \"Twenty \", \"Thirty \", \"Forty \", \"Fifty \", \"Sixty \", \"Seventy \", \"Eighty \", \"Ninety \"};\\n    private final String[] THOUSANDS = {\"\", \"Thousand \", \"Million \", \"Billion \"};\\n    \\n    public String numberToWords(int num) {\\n        if (num == 0) {\\n            return \"Zero\";\\n        }\\n        StringBuilder res = new StringBuilder();\\n       \\n        for (int i = 3; i > 0; i--) {\\n            int n = (int) Math.pow(1000, i);\\n            if (num >= n) {\\n                res.append(getSymbol(num / n)).append(THOUSANDS[i]);\\n                num %= n;\\n            }\\n        }\\n\\n        res.append(getSymbol(num));\\n        return res.toString().trim();                                                \\n    } \\n    private String getSymbol(int num) {\\n        StringBuilder str = new StringBuilder();\\n        if (num >= 100) {\\n            str.append(LESS_THAN_TWENTY[num / 100]).append(\"Hundred \");\\n            num %= 100;\\n        }\\n        if (num >= 20) {\\n            str.append(TWENTY_TO_NINETY[num / 10]).append(LESS_THAN_TWENTY[num % 10]);\\n        } else {\\n            str.append(LESS_THAN_TWENTY[num]);\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253154,
                "title": "python3-integer-to-english-words-recursive-approach-clean-and-concise-code-hash-map",
                "content": "```class Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num==0:\\n            return \"Zero\"\\n    \\n        dic = {1000000000 : \\'Billion\\',1000000 : \\'Million\\',1000 : \\'Thousand\\',100 : \\'Hundred\\', \\n\\t\\t90:\\'Ninety\\',80:\\'Eighty\\',70:\\'Seventy\\',60:\\'Sixty\\',50: \\'Fifty\\', 40 : \\'Forty\\', 30 : \\'Thirty\\', 20 : \\'Twenty\\',\\n\\t\\t19 :\\'Nineteen\\',18 :\\'Eighteen\\',17:\\'Seventeen\\',16:\\'Sixteen\\',15:\\'Fifteen\\',14:\\'Fourteen\\',13:\\'Thirteen\\',12:\\'Twelve\\',11:\\'Eleven\\',\\n\\t\\t10:\\'Ten\\',9:\\'Nine\\',8:\\'Eight\\',7:\\'Seven\\',6:\\'Six\\',5:\\'Five\\',4:\\'Four\\',3:\\'Three\\',2:\\'Two\\',1:\\'One\\'}\\n            \\n        res=\"\"\\n        for x,y in dic.items():\\n            if num//x:\\n                count=num//x\\n                if x>=100:\\n                    res+=self.numberToWords(count)+\" \"\\n                res+=y+\" \"\\n                num=num%x\\n        return res.strip()",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "class Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num==0:\\n            return \"Zero\"\\n    \\n        dic = {1000000000 : \\'Billion\\',1000000 : \\'Million\\',1000 : \\'Thousand\\',100 : \\'Hundred\\', \\n\\t\\t90:\\'Ninety\\',80:\\'Eighty\\',70:\\'Seventy\\',60:\\'Sixty\\',50: \\'Fifty\\', 40 : \\'Forty\\', 30 : \\'Thirty\\', 20 : \\'Twenty\\',\\n\\t\\t19 :\\'Nineteen\\',18 :\\'Eighteen\\',17:\\'Seventeen\\',16:\\'Sixteen\\',15:\\'Fifteen\\',14:\\'Fourteen\\',13:\\'Thirteen\\',12:\\'Twelve\\',11:\\'Eleven\\',\\n\\t\\t10:\\'Ten\\',9:\\'Nine\\',8:\\'Eight\\',7:\\'Seven\\',6:\\'Six\\',5:\\'Five\\',4:\\'Four\\',3:\\'Three\\',2:\\'Two\\',1:\\'One\\'}",
                "codeTag": "Java"
            },
            {
                "id": 2172904,
                "title": "faster-than-100-low-memory-simple",
                "content": "```\\nfunc numberToWords(num int) string {\\n    if num == 0 {\\n        return \"Zero\"\\n    }\\n    billions := num / 1000000000\\n    num = num % 1000000000\\n    \\n    millions := num / 1000000\\n    num = num % 1000000\\n    \\n    thousands := num / 1000\\n    num = num % 1000\\n    \\n    s := []string{}\\n    if billions > 0 {\\n        s = append(s, toStr(billions)...)\\n        s = append(s, \"Billion\")\\n    }\\n    if millions > 0 {\\n        s = append(s, toStr(millions)...)\\n        s = append(s, \"Million\")\\n    }\\n    if thousands > 0 {\\n        s = append(s, toStr(thousands)...)\\n        s = append(s, \"Thousand\")\\n    }\\n    s = append(s, toStr(num)...)\\n    return strings.Join(s, \" \")\\n}\\n\\nfunc toStr(n int) []string {\\n    s := []string{}\\n    digitNames := []string {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",}\\n    tenNames := []string {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\",}\\n    teenNames := []string {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"}\\n    \\n    hundreds := n / 100\\n    n = n % 100\\n    tens := n / 10\\n    n = n % 10\\n    if hundreds > 0 {\\n        s = append(s, digitNames[hundreds], \"Hundred\")\\n    }\\n    if tens > 0 {\\n        if tens == 1 {\\n            s = append(s, teenNames[n])\\n            n = 0\\n        } else {\\n            s = append(s, tenNames[tens])\\n        }\\n    }\\n    if n > 0 {\\n        s = append(s, digitNames[n])\\n    }\\n    return s\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numberToWords(num int) string {\\n    if num == 0 {\\n        return \"Zero\"\\n    }\\n    billions := num / 1000000000\\n    num = num % 1000000000\\n    \\n    millions := num / 1000000\\n    num = num % 1000000\\n    \\n    thousands := num / 1000\\n    num = num % 1000\\n    \\n    s := []string{}\\n    if billions > 0 {\\n        s = append(s, toStr(billions)...)\\n        s = append(s, \"Billion\")\\n    }\\n    if millions > 0 {\\n        s = append(s, toStr(millions)...)\\n        s = append(s, \"Million\")\\n    }\\n    if thousands > 0 {\\n        s = append(s, toStr(thousands)...)\\n        s = append(s, \"Thousand\")\\n    }\\n    s = append(s, toStr(num)...)\\n    return strings.Join(s, \" \")\\n}\\n\\nfunc toStr(n int) []string {\\n    s := []string{}\\n    digitNames := []string {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",}\\n    tenNames := []string {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\",}\\n    teenNames := []string {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"}\\n    \\n    hundreds := n / 100\\n    n = n % 100\\n    tens := n / 10\\n    n = n % 10\\n    if hundreds > 0 {\\n        s = append(s, digitNames[hundreds], \"Hundred\")\\n    }\\n    if tens > 0 {\\n        if tens == 1 {\\n            s = append(s, teenNames[n])\\n            n = 0\\n        } else {\\n            s = append(s, tenNames[tens])\\n        }\\n    }\\n    if n > 0 {\\n        s = append(s, digitNames[n])\\n    }\\n    return s\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2152130,
                "title": "java-simple-string-and-array-concept",
                "content": "```\\n public static String numberToWords(int num) {\\n            \\n            if(num==0) return \"Zero\";\\n            \\n           String N[]={\"Billion\", \"Million\", \"Thousand\", \"Hundred\", \"Ninety\", \"Eighty\", \"Seventy\", \"Sixty\", \"Fifty\", \"Forty\", \"Thirty\", \"Twenty\", \"Nineteen\",\"Eighteen\", \"Seventeen\", \"Sixteen\", \"Fifteen\", \"Fourteen\", \"Thirteen\", \"Twelve\", \"Eleven\",\"Ten\", \"Nine\", \"Eight\", \"Seven\", \"Six\", \"Five\",\"Four\", \"Three\", \"Two\", \"One\"};\\n            \\n            int n[]={1000000000, 1000000, 1000, 100, 90, 80, 70, 60, 50 ,40, 30, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\\n            \\n            String res=\"\";\\n            \\n            for(int i=0; i<4; i++)\\n            {\\n                int count=0;\\n                while(num-n[i]>=0)\\n                {\\n                    count++;\\n                    num-=n[i];\\n                }\\n                if(count>0)\\n                {\\n                    res+=numberToWords(count)+\" \"+ N[i]+\" \";\\n                }\\n            }\\n            \\n            for(int i=4; i<n.length; i++)\\n            {\\n                while(num-n[i]>=0)\\n                {\\n                    res+=N[i]+\" \";\\n                    num-=n[i];\\n                }\\n            }\\n            return res.trim();\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n public static String numberToWords(int num) {\\n            \\n            if(num==0) return \"Zero\";\\n            \\n           String N[]={\"Billion\", \"Million\", \"Thousand\", \"Hundred\", \"Ninety\", \"Eighty\", \"Seventy\", \"Sixty\", \"Fifty\", \"Forty\", \"Thirty\", \"Twenty\", \"Nineteen\",\"Eighteen\", \"Seventeen\", \"Sixteen\", \"Fifteen\", \"Fourteen\", \"Thirteen\", \"Twelve\", \"Eleven\",\"Ten\", \"Nine\", \"Eight\", \"Seven\", \"Six\", \"Five\",\"Four\", \"Three\", \"Two\", \"One\"};\\n            \\n            int n[]={1000000000, 1000000, 1000, 100, 90, 80, 70, 60, 50 ,40, 30, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\\n            \\n            String res=\"\";\\n            \\n            for(int i=0; i<4; i++)\\n            {\\n                int count=0;\\n                while(num-n[i]>=0)\\n                {\\n                    count++;\\n                    num-=n[i];\\n                }\\n                if(count>0)\\n                {\\n                    res+=numberToWords(count)+\" \"+ N[i]+\" \";\\n                }\\n            }\\n            \\n            for(int i=4; i<n.length; i++)\\n            {\\n                while(num-n[i]>=0)\\n                {\\n                    res+=N[i]+\" \";\\n                    num-=n[i];\\n                }\\n            }\\n            return res.trim();\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910356,
                "title": "integer-to-english-words-solution-java",
                "content": "class Solution {\\n  public String numberToWords(int num) {\\n    return num == 0 ? \"Zero\" : helper(num);\\n  }\\n\\n  private final String[] belowTwenty = {\"\",        \"One\",     \"Two\",       \"Three\",    \"Four\",\\n                                        \"Five\",    \"Six\",     \"Seven\",     \"Eight\",    \"Nine\",\\n                                        \"Ten\",     \"Eleven\",  \"Twelve\",    \"Thirteen\", \"Fourteen\",\\n                                        \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n  private final String[] tens = {\"\",      \"\",      \"Twenty\",  \"Thirty\", \"Forty\",\\n                                 \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n\\n  private String helper(int num) {\\n    StringBuilder s = new StringBuilder();\\n\\n    if (num < 20)\\n      s.append(belowTwenty[num]);\\n    else if (num < 100)\\n      s.append(tens[num / 10]).append(\" \").append(belowTwenty[num % 10]);\\n    else if (num < 1000)\\n      s.append(helper(num / 100)).append(\" Hundred \").append(helper(num % 100));\\n    else if (num < 1000000)\\n      s.append(helper(num / 1000)).append(\" Thousand \").append(helper(num % 1000));\\n    else if (num < 1000000000)\\n      s.append(helper(num / 1000000)).append(\" Million \").append(helper(num % 1000000));\\n    else\\n      s.append(helper(num / 1000000000)).append(\" Billion \").append(helper(num % 1000000000));\\n\\n    return s.toString().trim();\\n  }\\n}",
                "solutionTags": [
                    "Math",
                    "String",
                    "Recursion"
                ],
                "code": "class Solution {\\n  public String numberToWords(int num) {\\n    return num == 0 ? \"Zero\" : helper(num);\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1875069,
                "title": "c-easy-solution-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> grp {\"\", \" Thousand\", \" Million\", \" Billion\", \" Trillion\"};\\n    vector<string> tns {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    vector<string> ons {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n    vector<string> ele {\"\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    \\n    string getT(int n) {\\n        auto t = n / 10;\\n        auto o = n % 10;\\n        if (n >= 11 && n < 20) \\n            return ele[o];\\n        if (t && o) \\n            return tns[t] + \" \" + ons[o];\\n        if (t) \\n            return tns[t];\\n        if (o) \\n            return ons[o];\\n        return \"\";\\n    }\\n    \\n    string getH(int n) {\\n        auto h = n / 100;\\n        auto t = n % 100;\\n        if (h && t) \\n            return ons[h] + \" Hundred \" + getT(t);\\n        if (h)\\n            return ons[h] + \" Hundred\";\\n        if (t) \\n            return getT(t);\\n        return \"\";\\n    }\\n    \\n    string numberToWords(int num) {\\n        if (num == 0)\\n            return \"Zero\";\\n        string ret = \"\";\\n        auto i = 0;\\n        while (num) {\\n            auto h = num % 1000;\\n            if (h)\\n                ret = getH(h) + grp[i] + (ret.size()? \" \": \"\") + ret;\\n            i++;\\n            num /= 1000;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> grp {\"\", \" Thousand\", \" Million\", \" Billion\", \" Trillion\"};\\n    vector<string> tns {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    vector<string> ons {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n    vector<string> ele {\"\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    \\n    string getT(int n) {\\n        auto t = n / 10;\\n        auto o = n % 10;\\n        if (n >= 11 && n < 20) \\n            return ele[o];\\n        if (t && o) \\n            return tns[t] + \" \" + ons[o];\\n        if (t) \\n            return tns[t];\\n        if (o) \\n            return ons[o];\\n        return \"\";\\n    }\\n    \\n    string getH(int n) {\\n        auto h = n / 100;\\n        auto t = n % 100;\\n        if (h && t) \\n            return ons[h] + \" Hundred \" + getT(t);\\n        if (h)\\n            return ons[h] + \" Hundred\";\\n        if (t) \\n            return getT(t);\\n        return \"\";\\n    }\\n    \\n    string numberToWords(int num) {\\n        if (num == 0)\\n            return \"Zero\";\\n        string ret = \"\";\\n        auto i = 0;\\n        while (num) {\\n            auto h = num % 1000;\\n            if (h)\\n                ret = getH(h) + grp[i] + (ret.size()? \" \": \"\") + ret;\\n            i++;\\n            num /= 1000;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845943,
                "title": "python-recursion",
                "content": "**Python Recursion**\\n```class Solution:\\n    def numberToWords(self, num: int) -> str:\\n        def helper(num):\\n            result=\"\"\\n            belowTen=[\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"]\\n            belowTwenty=[\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"]\\n            belowHundred=[\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"]\\n            if(num<10):\\n                result= belowTen[num]\\n            elif(num>=10 and num<20):\\n                result= belowTwenty[num-10]\\n            elif  (num>=20 and num<100):\\n                result= belowHundred[int(num/10)-2] +\" \" +  helper(num%10)\\n            elif  (num>=100 and num<1000):\\n                result =helper(num//100) + \" Hundred \" +  helper(num%100)\\n            elif  (num>=1000 and num<1000000):\\n                result= helper(num//1000) + \" Thousand \" +  helper(num%1000)\\n            elif  (num>=1000000 and num<1000000000):\\n                result= helper(num//1000000) + \" Million \" +  helper(num%1000000)\\n            elif  (num>=1000000000):\\n                result= helper(num//1000000000) + \" Billion \" +  helper(num%1000000000)\\n            return result.strip()\\n      \\n        if(num==0):\\n            return \"Zero\"\\n        return helper(num)      \\n    ```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```class Solution:\\n    def numberToWords(self, num: int) -> str:\\n        def helper(num):\\n            result=\"\"\\n            belowTen=[\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"]\\n            belowTwenty=[\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"]\\n            belowHundred=[\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"]\\n            if(num<10):\\n                result= belowTen[num]\\n            elif(num>=10 and num<20):\\n                result= belowTwenty[num-10]\\n            elif  (num>=20 and num<100):\\n                result= belowHundred[int(num/10)-2] +\" \" +  helper(num%10)\\n            elif  (num>=100 and num<1000):\\n                result =helper(num//100) + \" Hundred \" +  helper(num%100)\\n            elif  (num>=1000 and num<1000000):\\n                result= helper(num//1000) + \" Thousand \" +  helper(num%1000)\\n            elif  (num>=1000000 and num<1000000000):\\n                result= helper(num//1000000) + \" Million \" +  helper(num%1000000)\\n            elif  (num>=1000000000):\\n                result= helper(num//1000000000) + \" Billion \" +  helper(num%1000000000)\\n            return result.strip()\\n      \\n        if(num==0):\\n            return \"Zero\"\\n        return helper(num)      \\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 1800313,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,string>mp={\\n{1000000000, \"Billion\"}, {1000000,\"Million\"}, {1000, \"Thousand\"}, {100, \"Hundred\"}, \\n\\n{90, \"Ninety\"}, {80, \"Eighty\"}, {70, \"Seventy\"}, {60, \"Sixty\"}, {50, \"Fifty\"}, {40, \"Forty\"}, {30, \"Thirty\"}, {20, \"Twenty\"}, {10, \"Ten\"}, \\n    \\n{19, \"Nineteen\"}, {18, \"Eighteen\"}, {17, \"Seventeen\"}, {16, \"Sixteen\"}, {15, \"Fifteen\"}, {14, \"Fourteen\"}, {13, \"Thirteen\"}, {12, \"Twelve\"}, {11, \"Eleven\"}, \\n      \\n{9, \"Nine\"}, {8, \"Eight\"}, {7, \"Seven\"}, {6, \"Six\"}, {5, \"Five\"}, {4, \"Four\"}, {3, \"Three\"}, {2, \"Two\"}, {1, \"One\"}, {0, \"Zero\"}\\n};\\n    string numberToWords(int num) {\\n        \\n        if(num<=20)\\n        {\\n          return mp[num];\\n        }\\n        \\n        auto it = mp.upper_bound(num);\\n        it--;\\n        string pre=\"\",suf=\"\";\\n        if(it->first>=100)\\n        {\\n          pre = numberToWords(num/it->first)+\" \";  \\n        }\\n        if(num%it->first!=0)\\n        {\\n            suf=\" \"+numberToWords(num%it->first);\\n        }\\n        return pre+it->second+suf;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,string>mp={\\n{1000000000, \"Billion\"}, {1000000,\"Million\"}, {1000, \"Thousand\"}, {100, \"Hundred\"}, \\n\\n{90, \"Ninety\"}, {80, \"Eighty\"}, {70, \"Seventy\"}, {60, \"Sixty\"}, {50, \"Fifty\"}, {40, \"Forty\"}, {30, \"Thirty\"}, {20, \"Twenty\"}, {10, \"Ten\"}, \\n    \\n{19, \"Nineteen\"}, {18, \"Eighteen\"}, {17, \"Seventeen\"}, {16, \"Sixteen\"}, {15, \"Fifteen\"}, {14, \"Fourteen\"}, {13, \"Thirteen\"}, {12, \"Twelve\"}, {11, \"Eleven\"}, \\n      \\n{9, \"Nine\"}, {8, \"Eight\"}, {7, \"Seven\"}, {6, \"Six\"}, {5, \"Five\"}, {4, \"Four\"}, {3, \"Three\"}, {2, \"Two\"}, {1, \"One\"}, {0, \"Zero\"}\\n};\\n    string numberToWords(int num) {\\n        \\n        if(num<=20)\\n        {\\n          return mp[num];\\n        }\\n        \\n        auto it = mp.upper_bound(num);\\n        it--;\\n        string pre=\"\",suf=\"\";\\n        if(it->first>=100)\\n        {\\n          pre = numberToWords(num/it->first)+\" \";  \\n        }\\n        if(num%it->first!=0)\\n        {\\n            suf=\" \"+numberToWords(num%it->first);\\n        }\\n        return pre+it->second+suf;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764169,
                "title": "iterative-approach-java",
                "content": "```\\nclass Solution {\\n    String[] bigUnits = {\"\", \" Thousand\", \" Million\", \" Billion\"};\\n    String[] digits = {\"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\", \" Seven\", \" Eight\", \" Nine\"};\\n    String[] tens = {\"\", \"\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\", \" Seventy\", \" Eighty\", \" Ninety\"};\\n    String[] tenToTwenty = {\" Ten\", \" Eleven\", \" Twelve\", \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\", \" Eighteen\", \" Nineteen\"};\\n    \\n    public String numberToWords(int num) {\\n        if(num==0){\\n            return \"Zero\";\\n        }\\n        StringBuilder result = new StringBuilder();\\n        int bigUnitIndex = 0;\\n        while(num!=0){\\n            if(num % 1000 !=0 ){\\n            result.insert(0, parseThreeDigits(num % 1000) + bigUnits[bigUnitIndex] + \"\");\\n            }\\n            num /= 1000;\\n            bigUnitIndex++;\\n        }\\n        \\n        return result.toString().trim();\\n    }\\n    \\n    private String parseThreeDigits(int num){\\n        StringBuilder result = new StringBuilder();\\n        if(num > 99){\\n            result.append(digits[num / 100] + \" Hundred\");\\n            num = num % 100;\\n        }\\n        if(num > 19){\\n            result.append(tens[num/10]);\\n            num = num % 10;\\n        }\\n        if(num > 9){\\n            result.append(tenToTwenty[num%10]);\\n            return result.toString();\\n        }\\n        \\n        return result.append(digits[num]).toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String[] bigUnits = {\"\", \" Thousand\", \" Million\", \" Billion\"};\\n    String[] digits = {\"\", \" One\", \" Two\", \" Three\", \" Four\", \" Five\", \" Six\", \" Seven\", \" Eight\", \" Nine\"};\\n    String[] tens = {\"\", \"\", \" Twenty\", \" Thirty\", \" Forty\", \" Fifty\", \" Sixty\", \" Seventy\", \" Eighty\", \" Ninety\"};\\n    String[] tenToTwenty = {\" Ten\", \" Eleven\", \" Twelve\", \" Thirteen\", \" Fourteen\", \" Fifteen\", \" Sixteen\", \" Seventeen\", \" Eighteen\", \" Nineteen\"};\\n    \\n    public String numberToWords(int num) {\\n        if(num==0){\\n            return \"Zero\";\\n        }\\n        StringBuilder result = new StringBuilder();\\n        int bigUnitIndex = 0;\\n        while(num!=0){\\n            if(num % 1000 !=0 ){\\n            result.insert(0, parseThreeDigits(num % 1000) + bigUnits[bigUnitIndex] + \"\");\\n            }\\n            num /= 1000;\\n            bigUnitIndex++;\\n        }\\n        \\n        return result.toString().trim();\\n    }\\n    \\n    private String parseThreeDigits(int num){\\n        StringBuilder result = new StringBuilder();\\n        if(num > 99){\\n            result.append(digits[num / 100] + \" Hundred\");\\n            num = num % 100;\\n        }\\n        if(num > 19){\\n            result.append(tens[num/10]);\\n            num = num % 10;\\n        }\\n        if(num > 9){\\n            result.append(tenToTwenty[num%10]);\\n            return result.toString();\\n        }\\n        \\n        return result.append(digits[num]).toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716305,
                "title": "c-using-recursion",
                "content": "Using @kelvinzhong comment on @popffabrik solution\\n\\nTime: O(d)\\nSpace: O(d)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string ones[10] ={\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"};\\n    string tens[10] ={\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n    string specials[10] = {\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n    \\n    string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        string val = helper(num);\\n        string ans = \"\";\\n        for(char c : val) {\\n            if(c >=\\'A\\' && c<=\\'Z\\') {\\n                ans += \" \";\\n            } \\n            ans += c;\\n        }\\n        return ans.substr(1);\\n    }\\n    \\n    string helper(int num) {\\n        if(num >=1000000000) {\\n            return helper(num/1000000000) + \"Billion\" + helper(num%1000000000);\\n        } else if(num >=1000000) {\\n            return helper(num/1000000) + \"Million\" + helper(num%1000000);\\n        } else if(num>=1000) {\\n            return helper(num/1000) + \"Thousand\" + helper(num%1000);\\n        } else if(num >=100) {\\n            return helper(num/100) + \"Hundred\" + helper(num%100);\\n        } else if(num >=20) {\\n            return tens[num/10] +helper(num%10);\\n        } else if(num>=10) {\\n            return specials[num - 10];\\n        } else if(num>=1) return ones[num];\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string ones[10] ={\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"};\\n    string tens[10] ={\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n    string specials[10] = {\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\n    \\n    string numberToWords(int num) {\\n        if(num == 0) return \"Zero\";\\n        string val = helper(num);\\n        string ans = \"\";\\n        for(char c : val) {\\n            if(c >=\\'A\\' && c<=\\'Z\\') {\\n                ans += \" \";\\n            } \\n            ans += c;\\n        }\\n        return ans.substr(1);\\n    }\\n    \\n    string helper(int num) {\\n        if(num >=1000000000) {\\n            return helper(num/1000000000) + \"Billion\" + helper(num%1000000000);\\n        } else if(num >=1000000) {\\n            return helper(num/1000000) + \"Million\" + helper(num%1000000);\\n        } else if(num>=1000) {\\n            return helper(num/1000) + \"Thousand\" + helper(num%1000);\\n        } else if(num >=100) {\\n            return helper(num/100) + \"Hundred\" + helper(num%100);\\n        } else if(num >=20) {\\n            return tens[num/10] +helper(num%10);\\n        } else if(num>=10) {\\n            return specials[num - 10];\\n        } else if(num>=1) return ones[num];\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674906,
                "title": "easy-solution-o-n-time-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string numberToWords(int num) {\\n        if(num==0){\\n            return \"Zero\";\\n        }\\n        string rst=solve(num);\\n        if(rst[rst.size()-1]==\\' \\')\\n        rst.pop_back();\\n        return rst;\\n    }\\n    string solve(int num){\\n        if(num==0){\\n            return \"\";\\n        }\\n        if(num>=1000000000){\\n            return solve(num/1000000000)+\"Billion \"+solve(num%1000000000);\\n        }else if(num>=1000000){\\n            return solve(num/1000000)+\"Million \"+solve(num%1000000);\\n        }else if(num>=1000){\\n            return solve(num/1000)+\"Thousand \"+solve(num%1000);\\n        }else if(num>=100){\\n            return solve(num/100)+\"Hundred \"+solve(num%100);\\n        }\\n        else if(num>=20){\\n            return two_digit(num/10)+single_digit(num%10);\\n        }else if(num>=10){\\n            return other_num(num);\\n        }else{\\n            return single_digit(num);\\n        }\\n    }\\n    \\n    string other_num(int n){\\n        switch(n){\\n            case 10:\\n                return \"Ten \";\\n            case 11:\\n                return \"Eleven \";\\n            case 12:\\n                return \"Twelve \";\\n            case 13:\\n                return \"Thirteen \";\\n            case 14:\\n                return \"Fourteen \";\\n            case 15:\\n                return \"Fifteen \";\\n            case 16:\\n                return \"Sixteen \";\\n            case 17:\\n                return \"Seventeen \";\\n            case 18:\\n                return \"Eighteen \";\\n            case 19:\\n                return \"Nineteen \";\\n            default:\\n                return \"\";\\n        }\\n    }\\n    \\n    // 1000000\\n    string two_digit(int n){\\n        switch(n){\\n            case 2:\\n                return \"Twenty \";\\n            case 3:\\n                return \"Thirty \";\\n            case 4:\\n                return \"Forty \";\\n            case 5:\\n                return \"Fifty \";\\n            case 6:\\n                return \"Sixty \";\\n            case 7:\\n                return \"Seventy \";\\n            case 8:\\n                return \"Eighty \";\\n            case 9:\\n                return \"Ninety \";\\n            default:\\n                return \"\";\\n        }\\n    }\\n    \\n    string single_digit(int n){\\n        switch(n){\\n            case 1:\\n                return \"One \";\\n            case 2:\\n                return \"Two \";\\n            case 3:\\n                return \"Three \";\\n            case 4:\\n                return \"Four \";\\n            case 5:\\n                return \"Five \";\\n            case 6:\\n                return \"Six \";\\n            case 7:\\n                return \"Seven \";\\n            case 8:\\n                return \"Eight \";\\n            case 9:\\n                return \"Nine \";\\n            default:\\n                return \"\";\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string numberToWords(int num) {\\n        if(num==0){\\n            return \"Zero\";\\n        }\\n        string rst=solve(num);\\n        if(rst[rst.size()-1]==\\' \\')\\n        rst.pop_back();\\n        return rst;\\n    }\\n    string solve(int num){\\n        if(num==0){\\n            return \"\";\\n        }\\n        if(num>=1000000000){\\n            return solve(num/1000000000)+\"Billion \"+solve(num%1000000000);\\n        }else if(num>=1000000){\\n            return solve(num/1000000)+\"Million \"+solve(num%1000000);\\n        }else if(num>=1000){\\n            return solve(num/1000)+\"Thousand \"+solve(num%1000);\\n        }else if(num>=100){\\n            return solve(num/100)+\"Hundred \"+solve(num%100);\\n        }\\n        else if(num>=20){\\n            return two_digit(num/10)+single_digit(num%10);\\n        }else if(num>=10){\\n            return other_num(num);\\n        }else{\\n            return single_digit(num);\\n        }\\n    }\\n    \\n    string other_num(int n){\\n        switch(n){\\n            case 10:\\n                return \"Ten \";\\n            case 11:\\n                return \"Eleven \";\\n            case 12:\\n                return \"Twelve \";\\n            case 13:\\n                return \"Thirteen \";\\n            case 14:\\n                return \"Fourteen \";\\n            case 15:\\n                return \"Fifteen \";\\n            case 16:\\n                return \"Sixteen \";\\n            case 17:\\n                return \"Seventeen \";\\n            case 18:\\n                return \"Eighteen \";\\n            case 19:\\n                return \"Nineteen \";\\n            default:\\n                return \"\";\\n        }\\n    }\\n    \\n    // 1000000\\n    string two_digit(int n){\\n        switch(n){\\n            case 2:\\n                return \"Twenty \";\\n            case 3:\\n                return \"Thirty \";\\n            case 4:\\n                return \"Forty \";\\n            case 5:\\n                return \"Fifty \";\\n            case 6:\\n                return \"Sixty \";\\n            case 7:\\n                return \"Seventy \";\\n            case 8:\\n                return \"Eighty \";\\n            case 9:\\n                return \"Ninety \";\\n            default:\\n                return \"\";\\n        }\\n    }\\n    \\n    string single_digit(int n){\\n        switch(n){\\n            case 1:\\n                return \"One \";\\n            case 2:\\n                return \"Two \";\\n            case 3:\\n                return \"Three \";\\n            case 4:\\n                return \"Four \";\\n            case 5:\\n                return \"Five \";\\n            case 6:\\n                return \"Six \";\\n            case 7:\\n                return \"Seven \";\\n            case 8:\\n                return \"Eight \";\\n            case 9:\\n                return \"Nine \";\\n            default:\\n                return \"\";\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576843,
                "title": "c-simple-short-solution-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string numberToWords(int num) {\\n        if(num == 0)\\n        {\\n            return \"Zero\";\\n        }\\n        \\n        std::vector<std::string> words;\\n        words.push_back(int2str(num % 1000));\\n        num /= 1000;\\n        if(num % 1000 != 0)\\n        {\\n            words.push_back(int2str(num % 1000) + \" Thousand\");\\n        }\\n        num /= 1000;\\n        if(num % 1000 != 0)\\n        {\\n            words.push_back(int2str(num % 1000) + \" Million\");\\n        }\\n        num /= 1000;\\n        if(num % 1000 != 0)\\n        {\\n            words.push_back(int2str(num % 1000) + \" Billion\");\\n        }\\n        std::string result;\\n        while(!words.empty())\\n        {\\n            result += words.back();\\n            result.push_back(\\' \\');\\n            words.pop_back();\\n        }\\n        while(result.back() == \\' \\')\\n        {\\n            result.pop_back();\\n        }\\n        return result;\\n    }\\nprivate:\\n    std::string int2str(int num)\\n    {\\n        std::string result;\\n        if(num / 100 != 0)\\n        {\\n            result += table0_19[num / 100] + \" Hundred \";\\n            num %= 100;\\n        }\\n        if(num <= 19)\\n        {\\n            result += table0_19[num];\\n        }\\n        else if(num >= 20 && num <= 99)\\n        {\\n            result += table20_99[num / 10] + \" \" + table0_19[num % 10];\\n        }\\n        while(!result.empty() && result.back() == \\' \\')\\n        {\\n            result.pop_back();\\n        }\\n        return result;\\n    }\\n    \\n    std::vector<std::string> table0_19{\"\", \"One\", \"Two\", \"Three\", \"Four\",\\n                                       \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\\n                                       \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \\n                                       \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    std::vector<std::string> table20_99{\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string numberToWords(int num) {\\n        if(num == 0)\\n        {\\n            return \"Zero\";\\n        }\\n        \\n        std::vector<std::string> words;\\n        words.push_back(int2str(num % 1000));\\n        num /= 1000;\\n        if(num % 1000 != 0)\\n        {\\n            words.push_back(int2str(num % 1000) + \" Thousand\");\\n        }\\n        num /= 1000;\\n        if(num % 1000 != 0)\\n        {\\n            words.push_back(int2str(num % 1000) + \" Million\");\\n        }\\n        num /= 1000;\\n        if(num % 1000 != 0)\\n        {\\n            words.push_back(int2str(num % 1000) + \" Billion\");\\n        }\\n        std::string result;\\n        while(!words.empty())\\n        {\\n            result += words.back();\\n            result.push_back(\\' \\');\\n            words.pop_back();\\n        }\\n        while(result.back() == \\' \\')\\n        {\\n            result.pop_back();\\n        }\\n        return result;\\n    }\\nprivate:\\n    std::string int2str(int num)\\n    {\\n        std::string result;\\n        if(num / 100 != 0)\\n        {\\n            result += table0_19[num / 100] + \" Hundred \";\\n            num %= 100;\\n        }\\n        if(num <= 19)\\n        {\\n            result += table0_19[num];\\n        }\\n        else if(num >= 20 && num <= 99)\\n        {\\n            result += table20_99[num / 10] + \" \" + table0_19[num % 10];\\n        }\\n        while(!result.empty() && result.back() == \\' \\')\\n        {\\n            result.pop_back();\\n        }\\n        return result;\\n    }\\n    \\n    std::vector<std::string> table0_19{\"\", \"One\", \"Two\", \"Three\", \"Four\",\\n                                       \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\\n                                       \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \\n                                       \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    std::vector<std::string> table20_99{\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534557,
                "title": "c-easy-to-understand",
                "content": "\\n    string single_digits[20] = { \"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" , \"Ten\", \"Eleven\",  \"Twelve\",\"Thirteen\",  \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\",\"Eighteen\", \"Nineteen\" };\\n\\n    string tens_multiple[10] = { \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\",\"Fifty\",\"Sixty\",  \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    string generate(int num)\\n    {\\n        string ans = \"\";\\n        int number = num / 100;\\n        if(number != 0)\\n            ans += single_digits[number] + \" \" + \"Hundred \";\\n        number = num % 100;\\n        \\n        if(number >= 20)\\n        {\\n            if(num % 10 != 0)\\n                ans += tens_multiple[number / 10] + \" \" + single_digits[number % 10] + \" \";\\n            else\\n                ans += tens_multiple[number / 10] + \" \";\\n        }\\n        else\\n        {\\n            if(number == 0)\\n                return ans;\\n            ans += single_digits[number] + \" \";\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string numberToWords(int num) {\\n        if(num == 0)\\n            return \"Zero\";\\n        string ans = \"\";\\n        bool flag = false;\\n        int number = num / 1000000000;\\n        if(number != 0)\\n            ans += single_digits[number] + \" \" + \"Billion \";\\n        num = num % 1000000000;\\n        \\n        number = num / 1000000;\\n        if(number != 0)\\n            ans += generate(number) + \"Million \";\\n        num = num % 1000000;\\n        \\n        number = num / 1000;\\n        if(number != 0)\\n            ans += generate(number) + \"Thousand \";\\n        num = num % 1000;\\n        \\n        ans += generate(num);\\n        \\n        ans.pop_back();\\n        return ans;",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    string single_digits[20] = { \"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" , \"Ten\", \"Eleven\",  \"Twelve\",\"Thirteen\",  \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\",\"Eighteen\", \"Nineteen\" };\\n\\n    string tens_multiple[10] = { \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\",\"Fifty\",\"Sixty\",  \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    string generate(int num)\\n    {\\n        string ans = \"\";\\n        int number = num / 100;\\n        if(number != 0)\\n            ans += single_digits[number] + \" \" + \"Hundred \";\\n        number = num % 100;\\n        \\n        if(number >= 20)\\n        {\\n            if(num % 10 != 0)\\n                ans += tens_multiple[number / 10] + \" \" + single_digits[number % 10] + \" \";\\n            else\\n                ans += tens_multiple[number / 10] + \" \";\\n        }\\n        else\\n        {\\n            if(number == 0)\\n                return ans;\\n            ans += single_digits[number] + \" \";\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    string numberToWords(int num) {\\n        if(num == 0)\\n            return \"Zero\";\\n        string ans = \"\";\\n        bool flag = false;\\n        int number = num / 1000000000;\\n        if(number != 0)\\n            ans += single_digits[number] + \" \" + \"Billion \";\\n        num = num % 1000000000;\\n        \\n        number = num / 1000000;\\n        if(number != 0)\\n            ans += generate(number) + \"Million \";\\n        num = num % 1000000;\\n        \\n        number = num / 1000;\\n        if(number != 0)\\n            ans += generate(number) + \"Thousand \";\\n        num = num % 1000;\\n        \\n        ans += generate(num);\\n        \\n        ans.pop_back();\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1516206,
                "title": "python-runtime-36ms",
                "content": "very complex, but I can do it \\n ```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        SingleDigit = (\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\\n        DoubleDigit = (\"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\\n        ZeroDigit = (\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\\n        \\n        words= []\\n        num = list(str(num))\\n        if num[0] == \"0\": return \"Zero\"\\n        \\n        def SingleDigitFun():\\n            while num[0] == \"0\":\\n                del num[0]\\n                if num == []:\\n                    break\\n            else:\\n                if len(num) in (10, 9, 7, 6, 4, 3, 1):\\n                    words.append(SingleDigit[int(num[0])-1])\\n                    del num[0]\\n                    if len(num) == 9:\\n                        words.append(\"Billion\")\\n                    elif len(num) == 8:\\n                        words.append(\"Hundred\")\\n                        if num[0:2] == [\"0\",\"0\"]:\\n                            words.append(\"Million\")\\n                    elif len(num) == 6:\\n                        words.append(\"Million\")\\n                    elif len(num) == 5:\\n                        words.append(\"Hundred\")\\n                        if num[0:2] == [\"0\",\"0\"]:\\n                            words.append(\"Thousand\")\\n                    elif len(num) == 3:\\n                        words.append(\"Thousand\")\\n                    elif len(num) == 2:\\n                        words.append(\"Hundred\")\\n                    \\n        def DoubleDigitFun():\\n            while num[0] == \"0\":\\n                if num != []:\\n                    del num[0]\\n                if num == [] or len(num) <= 1:\\n                    break\\n            else:\\n                if num[0] == \"1\":\\n                    if num[1] == \"0\" and len(num) in (8, 5, 2):\\n                        words.append(\"Ten\")\\n                        del num[0]\\n                        del num[0]\\n                        if len(num) == 6:\\n                            words.append(\"Million\")\\n                        elif len(num) == 3:\\n                            words.append(\"Thousand\")\\n                    else:\\n                        if len(num) in (5,8,2):\\n                            words.append(DoubleDigit[int(num[1])-1])\\n                        if len(num) == 8:\\n                            words.append(\"Million\")\\n                            del num[0]\\n                            del num[0]\\n                        elif len(num) == 5:\\n                            words.append(\"Thousand\")\\n                            del num[0]\\n                            del num[0]\\n                else:\\n                    if len(num) in (8, 5, 2):\\n                        words.append(ZeroDigit[int(num[0])-2])\\n                        if num[1] != \"0\":\\n                            words.append(SingleDigit[int(num[1])-1])\\n                        if len(num) == 8:\\n                            words.append(\"Million\")\\n                        if len(num) == 5:\\n                            words.append(\"Thousand\")\\n                        del num[0]\\n                        del num[0]\\n        \\n        if len(num) == 10:\\n            SingleDigitFun()\\n        if len(num) == 9:\\n            SingleDigitFun()\\n        if len(num) == 8:\\n            DoubleDigitFun()\\n            \\n        if len(num) == 7:\\n            SingleDigitFun()\\n        if len(num) == 6:\\n            SingleDigitFun()\\n        if len(num) == 5:\\n            DoubleDigitFun()\\n            \\n        if len(num) == 4:\\n            SingleDigitFun()\\n        if len(num) == 3:\\n            SingleDigitFun()\\n        if len(num) == 2:\\n            DoubleDigitFun()\\n            \\n        if len(num) == 1:\\n            SingleDigitFun()\\n        \\n        return \" \".join(words)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        SingleDigit = (\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\\n        DoubleDigit = (\"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\")\\n        ZeroDigit = (\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\")\\n        \\n        words= []\\n        num = list(str(num))\\n        if num[0] == \"0\": return \"Zero\"\\n        \\n        def SingleDigitFun():\\n            while num[0] == \"0\":\\n                del num[0]\\n                if num == []:\\n                    break\\n            else:\\n                if len(num) in (10, 9, 7, 6, 4, 3, 1):\\n                    words.append(SingleDigit[int(num[0])-1])\\n                    del num[0]\\n                    if len(num) == 9:\\n                        words.append(\"Billion\")\\n                    elif len(num) == 8:\\n                        words.append(\"Hundred\")\\n                        if num[0:2] == [\"0\",\"0\"]:\\n                            words.append(\"Million\")\\n                    elif len(num) == 6:\\n                        words.append(\"Million\")\\n                    elif len(num) == 5:\\n                        words.append(\"Hundred\")\\n                        if num[0:2] == [\"0\",\"0\"]:\\n                            words.append(\"Thousand\")\\n                    elif len(num) == 3:\\n                        words.append(\"Thousand\")\\n                    elif len(num) == 2:\\n                        words.append(\"Hundred\")\\n                    \\n        def DoubleDigitFun():\\n            while num[0] == \"0\":\\n                if num != []:\\n                    del num[0]\\n                if num == [] or len(num) <= 1:\\n                    break\\n            else:\\n                if num[0] == \"1\":\\n                    if num[1] == \"0\" and len(num) in (8, 5, 2):\\n                        words.append(\"Ten\")\\n                        del num[0]\\n                        del num[0]\\n                        if len(num) == 6:\\n                            words.append(\"Million\")\\n                        elif len(num) == 3:\\n                            words.append(\"Thousand\")\\n                    else:\\n                        if len(num) in (5,8,2):\\n                            words.append(DoubleDigit[int(num[1])-1])\\n                        if len(num) == 8:\\n                            words.append(\"Million\")\\n                            del num[0]\\n                            del num[0]\\n                        elif len(num) == 5:\\n                            words.append(\"Thousand\")\\n                            del num[0]\\n                            del num[0]\\n                else:\\n                    if len(num) in (8, 5, 2):\\n                        words.append(ZeroDigit[int(num[0])-2])\\n                        if num[1] != \"0\":\\n                            words.append(SingleDigit[int(num[1])-1])\\n                        if len(num) == 8:\\n                            words.append(\"Million\")\\n                        if len(num) == 5:\\n                            words.append(\"Thousand\")\\n                        del num[0]\\n                        del num[0]\\n        \\n        if len(num) == 10:\\n            SingleDigitFun()\\n        if len(num) == 9:\\n            SingleDigitFun()\\n        if len(num) == 8:\\n            DoubleDigitFun()\\n            \\n        if len(num) == 7:\\n            SingleDigitFun()\\n        if len(num) == 6:\\n            SingleDigitFun()\\n        if len(num) == 5:\\n            DoubleDigitFun()\\n            \\n        if len(num) == 4:\\n            SingleDigitFun()\\n        if len(num) == 3:\\n            SingleDigitFun()\\n        if len(num) == 2:\\n            DoubleDigitFun()\\n            \\n        if len(num) == 1:\\n            SingleDigitFun()\\n        \\n        return \" \".join(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494854,
                "title": "short-java-solution-runtime-1ms",
                "content": "```\\nclass Solution {\\n    private static String[] lessThanTwenty = new String[] {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private static String[] tens = new String[]{\"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    public String numberToWords(int num) {\\n        if(num == 0) {\\n            return \"Zero\";\\n        }\\n        return helper(num);\\n    }\\n    \\n    private String helper(int num) {\\n        StringBuilder res = new StringBuilder();\\n        if(num >= 1000000000) {\\n            res.append(helper(num/1000000000)).append(\" Billion \").append(helper(num%1000000000));\\n        } else if(num >= 1000000) {\\n             res.append(helper(num/1000000)).append(\" Million \").append(helper(num%1000000));\\n        } else if(num >= 1000) {\\n            res.append(helper(num/1000)).append(\" Thousand \").append(helper(num%1000));\\n        } else if(num >= 100) {\\n            res.append(helper(num/100)).append(\" Hundred \").append(helper(num%100));\\n        } else if(num >=20) {\\n            res.append(tens[num/10-1]).append(\" \").append(helper(num%10));\\n        } else {\\n            res.append(lessThanTwenty[num]);\\n        }\\n        \\n        return res.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static String[] lessThanTwenty = new String[] {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    private static String[] tens = new String[]{\"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    public String numberToWords(int num) {\\n        if(num == 0) {\\n            return \"Zero\";\\n        }\\n        return helper(num);\\n    }\\n    \\n    private String helper(int num) {\\n        StringBuilder res = new StringBuilder();\\n        if(num >= 1000000000) {\\n            res.append(helper(num/1000000000)).append(\" Billion \").append(helper(num%1000000000));\\n        } else if(num >= 1000000) {\\n             res.append(helper(num/1000000)).append(\" Million \").append(helper(num%1000000));\\n        } else if(num >= 1000) {\\n            res.append(helper(num/1000)).append(\" Thousand \").append(helper(num%1000));\\n        } else if(num >= 100) {\\n            res.append(helper(num/100)).append(\" Hundred \").append(helper(num%100));\\n        } else if(num >=20) {\\n            res.append(tens[num/10-1]).append(\" \").append(helper(num%10));\\n        } else {\\n            res.append(lessThanTwenty[num]);\\n        }\\n        \\n        return res.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472547,
                "title": "python-solution",
                "content": "~~~\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        \\n        less_than_20 = \"One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen\".split()\\n        less_than_100 = \"Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety\".split()\\n\\n        def words(num):\\n            if num == 0:\\n                return []\\n            elif num < 20:\\n                return [ less_than_20[num-1] ]\\n            elif num < 100:\\n                return [ less_than_100[(num//10)-2] ] + words(num%10)\\n            elif num < 1000:\\n                return [ less_than_20[(num//100)-1] ] + [\"Hundred\"] + words(num%100)\\n            else:\\n                for i, p in enumerate(\"Thousand Million Billion\".split(), 1):\\n                    if num < 1000 ** (i+1):\\n                        return words(num//1000**i) + [p] + words(num%1000**i)\\n        return \" \".join(words(num)) or \"Zero\"\\n                \\n                    \\n~~~",
                "solutionTags": [],
                "code": "~~~\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        \\n        less_than_20 = \"One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen\".split()\\n        less_than_100 = \"Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety\".split()\\n\\n        def words(num):\\n            if num == 0:\\n                return []\\n            elif num < 20:\\n                return [ less_than_20[num-1] ]\\n            elif num < 100:\\n                return [ less_than_100[(num//10)-2] ] + words(num%10)\\n            elif num < 1000:\\n                return [ less_than_20[(num//100)-1] ] + [\"Hundred\"] + words(num%100)\\n            else:\\n                for i, p in enumerate(\"Thousand Million Billion\".split(), 1):\\n                    if num < 1000 ** (i+1):\\n                        return words(num//1000**i) + [p] + words(num%1000**i)\\n        return \" \".join(words(num)) or \"Zero\"\\n                \\n                    \\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 1423923,
                "title": "python-recursion-solution",
                "content": "```\\nclass Solution:\\n    \\n    def numberToWords(self, num: int, idx=0) -> str:\\n        \\n        if not num: return \"Zero\"\\n        return self.getWords(num)\\n        \\n    def getWords(self, num):\\n        units = \\'One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen \\'\\n        tens = \\'Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety \\'\\n        bosses = [\\'Thousand\\', \\'Million\\', \\'Billion\\', \\'Trillion\\']\\n        \\n        s = \\'\\'\\n        if not num: return s\\n        \\n        if num < 20:\\n            return (units.split(\\' \\')[num - 1]).strip()\\n        \\n        if num <= 99:\\n            return (tens.split(\\' \\')[num // 10 - 2] + \\' \\' + self.getWords(num%10)).strip()\\n        \\n        if num <= 999:\\n            return (units.split(\\' \\')[num // 100 - 1] + \\' Hundred \\' + self.getWords(num%100)).strip()\\n        \\n        for i, p in enumerate(bosses):\\n            if 1000**(i+1) <= num < 1000**(i+2):\\n                return (self.getWords(num//1000**(i+1)) + \\' \\' + p + \\' \\' + self.getWords(num%1000**(i+1))).strip()\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def numberToWords(self, num: int, idx=0) -> str:\\n        \\n        if not num: return \"Zero\"\\n        return self.getWords(num)\\n        \\n    def getWords(self, num):\\n        units = \\'One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen \\'\\n        tens = \\'Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety \\'\\n        bosses = [\\'Thousand\\', \\'Million\\', \\'Billion\\', \\'Trillion\\']\\n        \\n        s = \\'\\'\\n        if not num: return s\\n        \\n        if num < 20:\\n            return (units.split(\\' \\')[num - 1]).strip()\\n        \\n        if num <= 99:\\n            return (tens.split(\\' \\')[num // 10 - 2] + \\' \\' + self.getWords(num%10)).strip()\\n        \\n        if num <= 999:\\n            return (units.split(\\' \\')[num // 100 - 1] + \\' Hundred \\' + self.getWords(num%100)).strip()\\n        \\n        for i, p in enumerate(bosses):\\n            if 1000**(i+1) <= num < 1000**(i+2):\\n                return (self.getWords(num//1000**(i+1)) + \\' \\' + p + \\' \\' + self.getWords(num%1000**(i+1))).strip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368872,
                "title": "python-solution-simple-easy-to-understand",
                "content": "```BILLION = 1000000000\\nMILLION = 1000000\\nTHOUSAND = 1000\\nHUNDRED = 100\\n\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.lessThan20 = [\"\",\"One \",\"Two \",\"Three \",\"Four \",\"Five \",\"Six \",\"Seven \",\"Eight \",\"Nine \",\"Ten \",\"Eleven \",\"Twelve \",\"Thirteen \",\"Fourteen \",\"Fifteen \",\"Sixteen \",\"Seventeen \",\"Eighteen \",\"Nineteen \"]\\n        self.tens = [\"\",\"Ten \",\"Twenty \",\"Thirty \",\"Forty \",\"Fifty \",\"Sixty \",\"Seventy \",\"Eighty \",\"Ninety \"]\\n        \\n    def helper (self, num):\\n        s = \"\"\\n        new_num = num//HUNDRED\\n        if new_num != 0:\\n            s+=self.lessThan20[new_num] + \"Hundred \"\\n        new_num = num%100\\n        if new_num <20:\\n            s+= self.lessThan20[new_num]\\n        else:\\n            s+= self.tens[new_num//10]+ self.lessThan20[new_num%10]\\n        return s\\n        \\n        \\n        \\n    def numberToWords(self, num):\\n        if num == 0:\\n            return \"Zero\"\\n        s = \"\"\\n        #simplified\\n        new_num = num//BILLION\\n\\n        if new_num !=0:\\n            sub_str = self.helper(new_num%1000)\\n            if sub_str != \"\":\\n                s += sub_str+\"Billion \"\\n        new_num = num//MILLION\\n        if new_num !=0:\\n            sub_str = self.helper(new_num%1000)\\n            if sub_str != \"\":\\n                s += sub_str+\"Million \"\\n        new_num = num//THOUSAND\\n        if new_num !=0:\\n            sub_str = self.helper(new_num%1000)\\n            if sub_str != \"\":\\n                s += sub_str+\"Thousand \"\\n            \\n        s += self.helper(num%1000)\\n    \\n        return s[:-1]",
                "solutionTags": [],
                "code": "```BILLION = 1000000000\\nMILLION = 1000000\\nTHOUSAND = 1000\\nHUNDRED = 100\\n\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.lessThan20 = [\"\",\"One \",\"Two \",\"Three \",\"Four \",\"Five \",\"Six \",\"Seven \",\"Eight \",\"Nine \",\"Ten \",\"Eleven \",\"Twelve \",\"Thirteen \",\"Fourteen \",\"Fifteen \",\"Sixteen \",\"Seventeen \",\"Eighteen \",\"Nineteen \"]\\n        self.tens = [\"\",\"Ten \",\"Twenty \",\"Thirty \",\"Forty \",\"Fifty \",\"Sixty \",\"Seventy \",\"Eighty \",\"Ninety \"]\\n        \\n    def helper (self, num):\\n        s = \"\"\\n        new_num = num//HUNDRED\\n        if new_num != 0:\\n            s+=self.lessThan20[new_num] + \"Hundred \"\\n        new_num = num%100\\n        if new_num <20:\\n            s+= self.lessThan20[new_num]\\n        else:\\n            s+= self.tens[new_num//10]+ self.lessThan20[new_num%10]\\n        return s\\n        \\n        \\n        \\n    def numberToWords(self, num):\\n        if num == 0:\\n            return \"Zero\"\\n        s = \"\"\\n        #simplified\\n        new_num = num//BILLION\\n\\n        if new_num !=0:\\n            sub_str = self.helper(new_num%1000)\\n            if sub_str != \"\":\\n                s += sub_str+\"Billion \"\\n        new_num = num//MILLION\\n        if new_num !=0:\\n            sub_str = self.helper(new_num%1000)\\n            if sub_str != \"\":\\n                s += sub_str+\"Million \"\\n        new_num = num//THOUSAND\\n        if new_num !=0:\\n            sub_str = self.helper(new_num%1000)\\n            if sub_str != \"\":\\n                s += sub_str+\"Thousand \"\\n            \\n        s += self.helper(num%1000)\\n    \\n        return s[:-1]",
                "codeTag": "Java"
            },
            {
                "id": 1355001,
                "title": "c-with-helper-function-easy-to-understand",
                "content": "Helper function is wordy but pretty straightforward, I think.\\n```\\nclass Solution {\\npublic:\\n    \\n    // conver a num less than 1000 to word \\n    string hundred_to_word(int num) {\\n        string ret;\\n        int hundred = num / 100;\\n        int ten = num / 10 % 10;\\n        int one = num % 10;\\n        switch (hundred) {\\n        case 0: break;\\n        case 1: ret = \"One Hundred\"; break;\\n        case 2: ret = \"Two Hundred\";   break;\\n        case 3: ret = \"Three Hundred\"; break;\\n        case 4: ret = \"Four Hundred\"; break;\\n        case 5: ret = \"Five Hundred\"; break;\\n        case 6: ret = \"Six Hundred\"; break;\\n        case 7: ret = \"Seven Hundred\"; break;\\n        case 8: ret = \"Eight Hundred\"; break;\\n        case 9: ret = \"Nine Hundred\"; break;\\n        }\\n        if (hundred && (ten || one)) {\\n            ret += \" \";\\n        }\\n        if (ten == 1) {\\n            switch (one) {\\n            case 0: return ret += \"Ten\";\\n            case 1: return ret += \"Eleven\";\\n            case 2: return ret += \"Twelve\";\\n            case 3: return ret += \"Thirteen\";\\n            case 4: return ret += \"Fourteen\";\\n            case 5: return ret += \"Fifteen\";\\n            case 6: return ret += \"Sixteen\";\\n            case 7: return ret += \"Seventeen\";\\n            case 8: return ret += \"Eighteen\";\\n            case 9: return ret += \"Nineteen\";\\n            }\\n        } else if (ten) {\\n            switch (ten) {\\n            case 2: ret += \"Twenty\"; break;\\n            case 3: ret += \"Thirty\"; break;\\n            case 4: ret += \"Forty\"; break;\\n            case 5: ret += \"Fifty\"; break;\\n            case 6: ret += \"Sixty\"; break;\\n            case 7: ret += \"Seventy\"; break;\\n            case 8: ret += \"Eighty\"; break;\\n            case 9: ret += \"Ninety\"; break;\\n            }\\n        }\\n        if (!one) {\\n            return ret;\\n        } else {\\n            if (ten) {\\n                ret += \" \";\\n            }\\n            switch (one) {\\n            case 1: ret += \"One\"; break;\\n            case 2: ret += \"Two\"; break;\\n            case 3: ret += \"Three\"; break;\\n            case 4: ret += \"Four\"; break;\\n            case 5: ret += \"Five\"; break;\\n            case 6: ret += \"Six\"; break;\\n            case 7: ret += \"Seven\"; break;\\n            case 8: ret += \"Eight\"; break;\\n            case 9: ret += \"Nine\"; break;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    string numberToWords(int num) {\\n        if (num == 0) { // edge case\\n            return \"Zero\";\\n        }\\n        \\n        int billion = num / 1000000000;\\n        int million = num / 1000000 % 1000;\\n        int thousand = num / 1000 % 1000;\\n        int hundred = num % 1000; // anything less than 1000 is considered together\\n        string ans;\\n        stringstream ss;\\n        \\n        if (billion) {\\n            ss << hundred_to_word(billion) << \" Billion\";\\n        }\\n        if (million) {\\n            if (billion) {\\n                ss << \" \";\\n            }\\n            ss << hundred_to_word(million) << \" Million\";\\n        }\\n        if (thousand) {\\n            if (billion || million) {\\n                ss << \" \";\\n            }\\n            ss << hundred_to_word(thousand) << \" Thousand\";\\n        }\\n        if (hundred) {\\n            if (billion || million || thousand) {\\n                ss << \" \";\\n            }\\n            ss << hundred_to_word(hundred);\\n        }\\n        return ss.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // conver a num less than 1000 to word \\n    string hundred_to_word(int num) {\\n        string ret;\\n        int hundred = num / 100;\\n        int ten = num / 10 % 10;\\n        int one = num % 10;\\n        switch (hundred) {\\n        case 0: break;\\n        case 1: ret = \"One Hundred\"; break;\\n        case 2: ret = \"Two Hundred\";   break;\\n        case 3: ret = \"Three Hundred\"; break;\\n        case 4: ret = \"Four Hundred\"; break;\\n        case 5: ret = \"Five Hundred\"; break;\\n        case 6: ret = \"Six Hundred\"; break;\\n        case 7: ret = \"Seven Hundred\"; break;\\n        case 8: ret = \"Eight Hundred\"; break;\\n        case 9: ret = \"Nine Hundred\"; break;\\n        }\\n        if (hundred && (ten || one)) {\\n            ret += \" \";\\n        }\\n        if (ten == 1) {\\n            switch (one) {\\n            case 0: return ret += \"Ten\";\\n            case 1: return ret += \"Eleven\";\\n            case 2: return ret += \"Twelve\";\\n            case 3: return ret += \"Thirteen\";\\n            case 4: return ret += \"Fourteen\";\\n            case 5: return ret += \"Fifteen\";\\n            case 6: return ret += \"Sixteen\";\\n            case 7: return ret += \"Seventeen\";\\n            case 8: return ret += \"Eighteen\";\\n            case 9: return ret += \"Nineteen\";\\n            }\\n        } else if (ten) {\\n            switch (ten) {\\n            case 2: ret += \"Twenty\"; break;\\n            case 3: ret += \"Thirty\"; break;\\n            case 4: ret += \"Forty\"; break;\\n            case 5: ret += \"Fifty\"; break;\\n            case 6: ret += \"Sixty\"; break;\\n            case 7: ret += \"Seventy\"; break;\\n            case 8: ret += \"Eighty\"; break;\\n            case 9: ret += \"Ninety\"; break;\\n            }\\n        }\\n        if (!one) {\\n            return ret;\\n        } else {\\n            if (ten) {\\n                ret += \" \";\\n            }\\n            switch (one) {\\n            case 1: ret += \"One\"; break;\\n            case 2: ret += \"Two\"; break;\\n            case 3: ret += \"Three\"; break;\\n            case 4: ret += \"Four\"; break;\\n            case 5: ret += \"Five\"; break;\\n            case 6: ret += \"Six\"; break;\\n            case 7: ret += \"Seven\"; break;\\n            case 8: ret += \"Eight\"; break;\\n            case 9: ret += \"Nine\"; break;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    string numberToWords(int num) {\\n        if (num == 0) { // edge case\\n            return \"Zero\";\\n        }\\n        \\n        int billion = num / 1000000000;\\n        int million = num / 1000000 % 1000;\\n        int thousand = num / 1000 % 1000;\\n        int hundred = num % 1000; // anything less than 1000 is considered together\\n        string ans;\\n        stringstream ss;\\n        \\n        if (billion) {\\n            ss << hundred_to_word(billion) << \" Billion\";\\n        }\\n        if (million) {\\n            if (billion) {\\n                ss << \" \";\\n            }\\n            ss << hundred_to_word(million) << \" Million\";\\n        }\\n        if (thousand) {\\n            if (billion || million) {\\n                ss << \" \";\\n            }\\n            ss << hundred_to_word(thousand) << \" Thousand\";\\n        }\\n        if (hundred) {\\n            if (billion || million || thousand) {\\n                ss << \" \";\\n            }\\n            ss << hundred_to_word(hundred);\\n        }\\n        return ss.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242341,
                "title": "python-simple-clean-code-with-comments-and-explanation",
                "content": "The key is to repeatedly get the representation of the least significant three digits. We must calculate this representation directly, and there are several edge cases to consider. This is outlined in the function `getHundreds`, which in turn calls on `getTens` to get the representation of the least significant two digits.\\n\\nWhen `num` > 10^3, we take care to add the place name (thousand, million, billion) after the value at that place.\\n\\n```python\\ndef numberToWords(self, num: int) -> str:\\n        number_to_word = {1 : \"One\", 2 : \"Two\", 3 : \"Three\", 4 : \"Four\",\\n             5 : \"Five\", 6 : \"Six\", 7 : \"Seven\", 8 : \"Eight\", 9 : \"Nine\",\\n             10 : \"Ten\", 11 : \"Eleven\", 12 : \"Twelve\", 13 : \"Thirteen\", 14 : \"Fourteen\",\\n             15 : \"Fifteen\", 16 : \"Sixteen\", 17 : \"Seventeen\", 18 : \"Eighteen\", 19 : \"Nineteen\",\\n            20 : \"Twenty\", 30 : \"Thirty\", 40 : \"Forty\", 50 : \"Fifty\", 60 : \"Sixty\", 70 : \"Seventy\", 80 :\\n            \"Eighty\", 90 : \"Ninety\", 100 : \"Hundred\", 1000 : \"Thousand\", 1000000 : \"Million\", 1000000000 : \"Billion\"}\\n        \\n        # Zero is an edge case as it doesn\\'t appear in any number except itself\\n        if num == 0:\\n            return \"Zero\"\\n        \\n        # Gets string representation of numbers < 10**2\\n        def getTens(num):\\n            res = []\\n            if num:\\n                if num <= 20:\\n                    res.append(number_to_word[num])\\n                else:\\n                    for i in range(2):\\n                        num, rem = divmod(num, 10)\\n                        if rem:\\n                            res.append(number_to_word[rem*10**i])\\n            return res\\n        \\n        # Gets string representation of numbers < 10**3        \\n        def getHundreds(num):\\n            res = []\\n            num, rem = divmod(num, 100)\\n            res.extend(getTens(rem))\\n            if num:\\n                res.append(number_to_word[100])\\n                res.append(number_to_word[num])\\n            return res\\n        \\n        res = []\\n        for i in range(0, len(str(num)), 3):\\n            num, rem = divmod(num, 1000) # get last three digits in number\\n            if rem:\\n                if i >= 3:\\n                    res.append(number_to_word[10**i]) # add place representation if greater than 10**3 \\n                res.extend(getHundreds(rem)) # add hundreds representation\\n                \\n        return \\' \\'.join(res[::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef numberToWords(self, num: int) -> str:\\n        number_to_word = {1 : \"One\", 2 : \"Two\", 3 : \"Three\", 4 : \"Four\",\\n             5 : \"Five\", 6 : \"Six\", 7 : \"Seven\", 8 : \"Eight\", 9 : \"Nine\",\\n             10 : \"Ten\", 11 : \"Eleven\", 12 : \"Twelve\", 13 : \"Thirteen\", 14 : \"Fourteen\",\\n             15 : \"Fifteen\", 16 : \"Sixteen\", 17 : \"Seventeen\", 18 : \"Eighteen\", 19 : \"Nineteen\",\\n            20 : \"Twenty\", 30 : \"Thirty\", 40 : \"Forty\", 50 : \"Fifty\", 60 : \"Sixty\", 70 : \"Seventy\", 80 :\\n            \"Eighty\", 90 : \"Ninety\", 100 : \"Hundred\", 1000 : \"Thousand\", 1000000 : \"Million\", 1000000000 : \"Billion\"}\\n        \\n        # Zero is an edge case as it doesn\\'t appear in any number except itself\\n        if num == 0:\\n            return \"Zero\"\\n        \\n        # Gets string representation of numbers < 10**2\\n        def getTens(num):\\n            res = []\\n            if num:\\n                if num <= 20:\\n                    res.append(number_to_word[num])\\n                else:\\n                    for i in range(2):\\n                        num, rem = divmod(num, 10)\\n                        if rem:\\n                            res.append(number_to_word[rem*10**i])\\n            return res\\n        \\n        # Gets string representation of numbers < 10**3        \\n        def getHundreds(num):\\n            res = []\\n            num, rem = divmod(num, 100)\\n            res.extend(getTens(rem))\\n            if num:\\n                res.append(number_to_word[100])\\n                res.append(number_to_word[num])\\n            return res\\n        \\n        res = []\\n        for i in range(0, len(str(num)), 3):\\n            num, rem = divmod(num, 1000) # get last three digits in number\\n            if rem:\\n                if i >= 3:\\n                    res.append(number_to_word[10**i]) # add place representation if greater than 10**3 \\n                res.extend(getHundreds(rem)) # add hundreds representation\\n                \\n        return \\' \\'.join(res[::-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1225537,
                "title": "c-faster-than-100-array-simple",
                "content": "```\\nstring ones[]={\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\nstring tens[]={\"\",\"Ten\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n     \\nclass Solution {\\n    string util(int n){\\n        string res=\"\";\\n        if(n>=100){\\n            res+= ones[n/100]+\" Hundred \";\\n            n%=100;\\n        }\\n        if(n>=20){\\n            res+= tens[n/10]+\" \";\\n            n%=10;\\n        }\\n        if(n>0){\\n            res+= ones[n]+\" \";\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    string numberToWords(int n) {\\n        string res =\"\",temp;\\n        string h[]={\"\",\"Thousand \",\"Million \",\"Billion \"};\\n        \\n        if(n==0)\\n            return \"Zero\";\\n        \\n        int i=0;\\n        while(n>0){\\n            temp=util(n%1000);\\n//             handling case of Zero in between the number\\n            if(temp.length()>0)\\n                res = temp+h[i]+res;\\n            n/=1000;\\n            i++;\\n        }\\n        \\n//         removing excess space at the end of the res\\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```\\n\\nI am taking chunks of 3 digit numbers from the end of the number and converting them using the util function, then adding thousand/million as per the number of chunk being converted.\\nUtil function simply converts numbers from range [1,999] inclusive using simple logic and string stored in global arrays.",
                "solutionTags": [],
                "code": "```\\nstring ones[]={\"\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\",\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"};\\nstring tens[]={\"\",\"Ten\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"};\\n     \\nclass Solution {\\n    string util(int n){\\n        string res=\"\";\\n        if(n>=100){\\n            res+= ones[n/100]+\" Hundred \";\\n            n%=100;\\n        }\\n        if(n>=20){\\n            res+= tens[n/10]+\" \";\\n            n%=10;\\n        }\\n        if(n>0){\\n            res+= ones[n]+\" \";\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    string numberToWords(int n) {\\n        string res =\"\",temp;\\n        string h[]={\"\",\"Thousand \",\"Million \",\"Billion \"};\\n        \\n        if(n==0)\\n            return \"Zero\";\\n        \\n        int i=0;\\n        while(n>0){\\n            temp=util(n%1000);\\n//             handling case of Zero in between the number\\n            if(temp.length()>0)\\n                res = temp+h[i]+res;\\n            n/=1000;\\n            i++;\\n        }\\n        \\n//         removing excess space at the end of the res\\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082771,
                "title": "c-easy-to-understand-recursive-solution-0ms",
                "content": "```\\n unordered_map<int,string> mp; \\n   string helper(int i,int n,string& str)\\n   {\\n       if(i>=n) { return \"\";  }\\n       if(str[i]==\\'0\\') { return helper(i+1,n,str);  }\\n       if(n-i==1) {   return mp[str[i]-\\'0\\'];   } \\n       if(n-i==2){\\n           if(str[i]==\\'1\\'){\\n               if(str[i+1]-\\'0\\'>=1 && str[i+1]-\\'0\\'<=9){\\n                   return mp[stoi(str.substr(i))];\\n               }\\n               else{\\n                   return \"Ten\" + helper(i+1,n,str);\\n               }\\n           }\\n           else{\\n            if(str[i]==\\'2\\') { return \"Twenty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'3\\') { return \"Thirty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'4\\') { return \"Forty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'5\\') { return \"Fifty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'6\\') { return \"Sixty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'7\\') { return \"Seventy\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'8\\') { return \"Eighty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'9\\') { return \"Ninety\" + helper(i+1,n,str);  }\\n           }\\n       }\\n       if(n-i==3){\\n           if(str[i]==\\'1\\') { return \"OneHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'2\\') { return \"TwoHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'3\\') { return \"ThreeHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'4\\') { return \"FourHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'5\\') { return \"FiveHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'6\\') { return \"SixHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'7\\') { return \"SevenHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'8\\') { return \"EightHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'9\\') { return \"NineHundred\" + helper(i+1,n,str);   }\\n       }\\n       return \"\";\\n   }\\n    \\n   string genStringForNum(int i,int n,string& str)\\n   {\\n       if(n-i<=3) { \\n             string t = str.substr(i);\\n             return helper(0,t.length(),t);\\n       }\\n       if(str[i]==\\'0\\') { return genStringForNum(i+1,n,str);   }\\n       if(n-i==4){\\n           return mp[str[i]-\\'0\\'] + \"Thousand\" + genStringForNum(i+1,n,str);\\n       }\\n       if(n-i==5){\\n           string t = str.substr(i,2);\\n           return helper(0,2,t) + \"Thousand\" + genStringForNum(i+2,n,str);\\n       }\\n       if(n-i==6){\\n           string t = str.substr(i,3);          \\n           return helper(0,3,t) + \"Thousand\" + genStringForNum(i+3,n,str);\\n       }\\n       if(n-i==7){\\n           return  mp[str[i]-\\'0\\'] + \"Million\" + genStringForNum(i+1,n,str);\\n       }\\n       if(n-i==8){\\n        string t = str.substr(i,2);     \\n            return helper(0,2,t) + \"Million\" + genStringForNum(i+2,n,str);\\n       }\\n       if(n-i==9){\\n         string t = str.substr(i,3);   \\n           return helper(0,3,t) + \"Million\" + genStringForNum(i+3,n,str);\\n       }\\n       if(n-i==10){\\n           return mp[str[i]-\\'0\\'] + \"Billion\" + genStringForNum(i+1,n,str);\\n       }    \\n      return \"\";\\n   }\\n    \\n    string numberToWords(int num) {\\n     if (num==0) {  return \"Zero\";  }\\n     string str = to_string(num);\\n     int len,i;   \\n     mp[11] = \"Eleven\" ;\\n     mp[12] = \"Twelve\" ;\\n     mp[13] = \"Thirteen\";\\n     mp[14] = \"Fourteen\";\\n     mp[15] = \"Fifteen\";\\n     mp[16] = \"Sixteen\";\\n     mp[17] = \"Seventeen\";\\n     mp[18] = \"Eighteen\";\\n     mp[19] = \"Nineteen\";   \\n     mp[1] =  \"One\";  \\n     mp[2] =  \"Two\";\\n     mp[3] =  \"Three\";\\n     mp[4] =  \"Four\";\\n     mp[5] =  \"Five\";\\n     mp[6] =  \"Six\";\\n     mp[7] = \"Seven\";\\n     mp[8] = \"Eight\";\\n     mp[9] = \"Nine\";\\n        \\n    string temp = genStringForNum(0,str.length(),str); \\n    string ans=\"\";\\n    ans += temp[0];\\n    for(i=1;i<temp.length();i++){\\n        if(isupper(temp[i])){   ans += \" \";  }\\n        ans += temp[i]; \\n    }    \\n    return ans;\\n    }\\n```",
                "solutionTags": [
                    "String",
                    "Recursion"
                ],
                "code": "```\\n unordered_map<int,string> mp; \\n   string helper(int i,int n,string& str)\\n   {\\n       if(i>=n) { return \"\";  }\\n       if(str[i]==\\'0\\') { return helper(i+1,n,str);  }\\n       if(n-i==1) {   return mp[str[i]-\\'0\\'];   } \\n       if(n-i==2){\\n           if(str[i]==\\'1\\'){\\n               if(str[i+1]-\\'0\\'>=1 && str[i+1]-\\'0\\'<=9){\\n                   return mp[stoi(str.substr(i))];\\n               }\\n               else{\\n                   return \"Ten\" + helper(i+1,n,str);\\n               }\\n           }\\n           else{\\n            if(str[i]==\\'2\\') { return \"Twenty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'3\\') { return \"Thirty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'4\\') { return \"Forty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'5\\') { return \"Fifty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'6\\') { return \"Sixty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'7\\') { return \"Seventy\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'8\\') { return \"Eighty\" + helper(i+1,n,str);  }\\n            if(str[i]==\\'9\\') { return \"Ninety\" + helper(i+1,n,str);  }\\n           }\\n       }\\n       if(n-i==3){\\n           if(str[i]==\\'1\\') { return \"OneHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'2\\') { return \"TwoHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'3\\') { return \"ThreeHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'4\\') { return \"FourHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'5\\') { return \"FiveHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'6\\') { return \"SixHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'7\\') { return \"SevenHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'8\\') { return \"EightHundred\" + helper(i+1,n,str);   }\\n           if(str[i]==\\'9\\') { return \"NineHundred\" + helper(i+1,n,str);   }\\n       }\\n       return \"\";\\n   }\\n    \\n   string genStringForNum(int i,int n,string& str)\\n   {\\n       if(n-i<=3) { \\n             string t = str.substr(i);\\n             return helper(0,t.length(),t);\\n       }\\n       if(str[i]==\\'0\\') { return genStringForNum(i+1,n,str);   }\\n       if(n-i==4){\\n           return mp[str[i]-\\'0\\'] + \"Thousand\" + genStringForNum(i+1,n,str);\\n       }\\n       if(n-i==5){\\n           string t = str.substr(i,2);\\n           return helper(0,2,t) + \"Thousand\" + genStringForNum(i+2,n,str);\\n       }\\n       if(n-i==6){\\n           string t = str.substr(i,3);          \\n           return helper(0,3,t) + \"Thousand\" + genStringForNum(i+3,n,str);\\n       }\\n       if(n-i==7){\\n           return  mp[str[i]-\\'0\\'] + \"Million\" + genStringForNum(i+1,n,str);\\n       }\\n       if(n-i==8){\\n        string t = str.substr(i,2);     \\n            return helper(0,2,t) + \"Million\" + genStringForNum(i+2,n,str);\\n       }\\n       if(n-i==9){\\n         string t = str.substr(i,3);   \\n           return helper(0,3,t) + \"Million\" + genStringForNum(i+3,n,str);\\n       }\\n       if(n-i==10){\\n           return mp[str[i]-\\'0\\'] + \"Billion\" + genStringForNum(i+1,n,str);\\n       }    \\n      return \"\";\\n   }\\n    \\n    string numberToWords(int num) {\\n     if (num==0) {  return \"Zero\";  }\\n     string str = to_string(num);\\n     int len,i;   \\n     mp[11] = \"Eleven\" ;\\n     mp[12] = \"Twelve\" ;\\n     mp[13] = \"Thirteen\";\\n     mp[14] = \"Fourteen\";\\n     mp[15] = \"Fifteen\";\\n     mp[16] = \"Sixteen\";\\n     mp[17] = \"Seventeen\";\\n     mp[18] = \"Eighteen\";\\n     mp[19] = \"Nineteen\";   \\n     mp[1] =  \"One\";  \\n     mp[2] =  \"Two\";\\n     mp[3] =  \"Three\";\\n     mp[4] =  \"Four\";\\n     mp[5] =  \"Five\";\\n     mp[6] =  \"Six\";\\n     mp[7] = \"Seven\";\\n     mp[8] = \"Eight\";\\n     mp[9] = \"Nine\";\\n        \\n    string temp = genStringForNum(0,str.length(),str); \\n    string ans=\"\";\\n    ans += temp[0];\\n    for(i=1;i<temp.length();i++){\\n        if(isupper(temp[i])){   ans += \" \";  }\\n        ans += temp[i]; \\n    }    \\n    return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076919,
                "title": "elegant-o-n-python-solution",
                "content": "Uses the classic trick of mod + division to read the given number\\'s digits three at a time starting from the end (like popping three digits from the end of the number until there are no more digits left). Converting this triple-digit chunk into words is then done while handling the special cases by indexing into lists of words. Thousand quantifiers are only added after the first chunk has been processed - i.e. `len(words) > 0` . To be able to put it in the right order later,`words` is a list of lists, where each inner list is a list of the words describing the given chunk.\\n\\nFinally, to convert to the output string we need to switch the order of the chunks around, because we processed the number in reverse order, and then flatten the resulting list of word chunks (to flatten we use the `sum(listOfLists, [])` pattern).\\n\\nThe only case we do not automatically handle with the aforementioned algo is `num == 0`, because Zero only appears in this one special case, we therefore handle it separately before any of the other processing.\\n\\n```\\nclass Solution:\\n  # time O(n), space O(n)\\n  def numberToWords(self, num: int) -> str:\\n    if not num:\\n      return \\'Zero\\'\\n      \\n    ones = [\\'\\', \\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\', \\'Ten\\', \\'Eleven\\', \\'Twelve\\', \\'Thirteen\\', \\'Fourteen\\', \\'Fifteen\\', \\'Sixteen\\', \\'Seventeen\\', \\'Eighteen\\', \\'Nineteen\\']\\n    tens = [\\'\\', \\'\\', \\'Twenty\\', \\'Thirty\\', \\'Forty\\', \\'Fifty\\', \\'Sixty\\', \\'Seventy\\', \\'Eighty\\', \\'Ninety\\']\\n    thousands = [\\'\\', \\'Thousand\\', \\'Million\\', \\'Billion\\']\\n    \\n    words = []\\n\\n    while num:\\n      chunk_words = []\\n\\n      chunk = num % 1000\\n      if chunk > 99:\\n        chunk_words.extend([ones[chunk // 100], \\'Hundred\\'])\\n        chunk %= 100\\n      if chunk > 19:\\n        chunk_words.append(tens[chunk // 10])\\n        chunk %= 10\\n      if chunk:\\n        chunk_words.append(ones[chunk])\\n\\n      if chunk_words and len(words):\\n        chunk_words.append(thousands[len(words)])\\n\\n      words.append(chunk_words)\\n      num //= 1000\\n\\n    return \\' \\'.join(sum(reversed(words), []))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  # time O(n), space O(n)\\n  def numberToWords(self, num: int) -> str:\\n    if not num:\\n      return \\'Zero\\'\\n      \\n    ones = [\\'\\', \\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\', \\'Ten\\', \\'Eleven\\', \\'Twelve\\', \\'Thirteen\\', \\'Fourteen\\', \\'Fifteen\\', \\'Sixteen\\', \\'Seventeen\\', \\'Eighteen\\', \\'Nineteen\\']\\n    tens = [\\'\\', \\'\\', \\'Twenty\\', \\'Thirty\\', \\'Forty\\', \\'Fifty\\', \\'Sixty\\', \\'Seventy\\', \\'Eighty\\', \\'Ninety\\']\\n    thousands = [\\'\\', \\'Thousand\\', \\'Million\\', \\'Billion\\']\\n    \\n    words = []\\n\\n    while num:\\n      chunk_words = []\\n\\n      chunk = num % 1000\\n      if chunk > 99:\\n        chunk_words.extend([ones[chunk // 100], \\'Hundred\\'])\\n        chunk %= 100\\n      if chunk > 19:\\n        chunk_words.append(tens[chunk // 10])\\n        chunk %= 10\\n      if chunk:\\n        chunk_words.append(ones[chunk])\\n\\n      if chunk_words and len(words):\\n        chunk_words.append(thousands[len(words)])\\n\\n      words.append(chunk_words)\\n      num //= 1000\\n\\n    return \\' \\'.join(sum(reversed(words), []))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072138,
                "title": "kotlin-clean-and-simple-using-recursion",
                "content": "```\\nclass Solution {\\n    fun numberToWords(num: Int): String {\\n        if (num == 0) {\\n            return \"Zero\"\\n        }\\n        \\n        return helper(num)\\n    }\\n    \\n    private fun lessTwenty(num: Int): String {\\n        return when(num) {\\n            1 -> \"One\"\\n            2 -> \"Two\"\\n            3 -> \"Three\"\\n            4 -> \"Four\"\\n            5 -> \"Five\"\\n            6 -> \"Six\"\\n            7 -> \"Seven\"\\n            8 -> \"Eight\"\\n            9 -> \"Nine\"\\n            10 -> \"Ten\"\\n            11 -> \"Eleven\"\\n            12 -> \"Twelve\"\\n            13 -> \"Thirteen\"\\n            14 -> \"Fourteen\"\\n            15 -> \"Fifteen\"\\n            16 -> \"Sixteen\"\\n            17 -> \"Seventeen\"\\n            18 -> \"Eighteen\"\\n            19 -> \"Nineteen\"\\n            else -> \"\"\\n        }\\n    }\\n    \\n    private fun tens(num: Int): String {\\n        return when(num) {\\n            20 -> \"Twenty\"\\n            30 -> \"Thirty\"\\n            40 -> \"Forty\"\\n            50 -> \"Fifty\"\\n            60 -> \"Sixty\"\\n            70 -> \"Seventy\"\\n            80 -> \"Eighty\"\\n            90 -> \"Ninety\"\\n            else -> \"\"\\n        }\\n    }\\n    \\n    private fun helper(num: Int): String {\\n        var ans = \"\" // Kotlin uses StringBuilder under the hood\\n        \\n        if (num >= 1_000_000_000) {\\n            ans += helper(num / 1_000_000_000) + \" Billion \" + helper(num % 1_000_000_000)\\n        } else if (num >= 1_000_000) {\\n            ans += helper(num / 1_000_000) + \" Million \" + helper(num % 1_000_000)\\n        } else if (num >= 1_000) {\\n            ans += helper(num / 1_000) + \" Thousand \" + helper(num % 1_000)\\n        } else if (num >= 100) {\\n            ans += helper(num / 100) + \" Hundred \" + helper(num % 100)\\n        } else if (num >= 20) {\\n            ans += tens(num - (num % 10)) + \" \" + lessTwenty(num % 10)\\n        } else if (num < 20) {\\n            ans += lessTwenty(num)\\n        }\\n        \\n        return ans.trim()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    fun numberToWords(num: Int): String {\\n        if (num == 0) {\\n            return \"Zero\"\\n        }\\n        \\n        return helper(num)\\n    }\\n    \\n    private fun lessTwenty(num: Int): String {\\n        return when(num) {\\n            1 -> \"One\"\\n            2 -> \"Two\"\\n            3 -> \"Three\"\\n            4 -> \"Four\"\\n            5 -> \"Five\"\\n            6 -> \"Six\"\\n            7 -> \"Seven\"\\n            8 -> \"Eight\"\\n            9 -> \"Nine\"\\n            10 -> \"Ten\"\\n            11 -> \"Eleven\"\\n            12 -> \"Twelve\"\\n            13 -> \"Thirteen\"\\n            14 -> \"Fourteen\"\\n            15 -> \"Fifteen\"\\n            16 -> \"Sixteen\"\\n            17 -> \"Seventeen\"\\n            18 -> \"Eighteen\"\\n            19 -> \"Nineteen\"\\n            else -> \"\"\\n        }\\n    }\\n    \\n    private fun tens(num: Int): String {\\n        return when(num) {\\n            20 -> \"Twenty\"\\n            30 -> \"Thirty\"\\n            40 -> \"Forty\"\\n            50 -> \"Fifty\"\\n            60 -> \"Sixty\"\\n            70 -> \"Seventy\"\\n            80 -> \"Eighty\"\\n            90 -> \"Ninety\"\\n            else -> \"\"\\n        }\\n    }\\n    \\n    private fun helper(num: Int): String {\\n        var ans = \"\" // Kotlin uses StringBuilder under the hood\\n        \\n        if (num >= 1_000_000_000) {\\n            ans += helper(num / 1_000_000_000) + \" Billion \" + helper(num % 1_000_000_000)\\n        } else if (num >= 1_000_000) {\\n            ans += helper(num / 1_000_000) + \" Million \" + helper(num % 1_000_000)\\n        } else if (num >= 1_000) {\\n            ans += helper(num / 1_000) + \" Thousand \" + helper(num % 1_000)\\n        } else if (num >= 100) {\\n            ans += helper(num / 100) + \" Hundred \" + helper(num % 100)\\n        } else if (num >= 20) {\\n            ans += tens(num - (num % 10)) + \" \" + lessTwenty(num % 10)\\n        } else if (num < 20) {\\n            ans += lessTwenty(num)\\n        }\\n        \\n        return ans.trim()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058230,
                "title": "python-short-modular-code-extended-up-to-decillion-10-33",
                "content": "If you like my code, please hit ^ button. \\uD83D\\uDE0A Good luck at the interview!\\n```\\nclass Solution(object):\\n    def numberToWords(self, num):\\n        \\n        if not num: return \\'Zero\\'\\n        \\n        singles = {1:\\'One\\', 2:\\'Two\\', 3:\\'Three\\', 4:\\'Four\\', 5:\\'Five\\', 6:\\'Six\\', 7:\\'Seven\\', 8:\\'Eight\\', 9:\\'Nine\\', 10:\\'Ten\\',\\n                  11:\\'Eleven\\', 12:\\'Twelve\\', 13:\\'Thirteen\\', 14:\\'Fourteen\\', 15:\\'Fifteen\\', 16:\\'Sixteen\\', 17:\\'Seventeen\\',\\n                  18:\\'Eighteen\\', 19:\\'Nineteen\\'}\\n        \\n        tens = {2:\\'Twenty\\', 3:\\'Thirty\\', 4:\\'Forty\\', 5:\\'Fifty\\', 6:\\'Sixty\\', 7:\\'Seventy\\', 8:\\'Eighty\\', 9:\\'Ninety\\'}\\n        \\n        mags = [\\'\\', \\'Thousand\\', \\'Million\\', \\'Billion\\', \\'Trillion\\', \\'Quadrillion\\', \\\\\\n\\t\\t\\'Quintrillion\\', \\'Sextillion\\', \\'Septillion\\', \\'Octillion\\', \\'Nonillion\\', \\'Decillion\\']\\n        \\n        def num2word(num):\\n            hun, ten = num // 100, num % 100\\n            word = []\\n            \\n            if hun:\\n                word.append(singles[hun])\\n                word.append(\\'Hundred\\')\\n            \\n            if ten in singles:\\n                word.append(singles[ten])\\n            else:\\n                t, s = ten // 10, ten % 10\\n                \\n                if t in tens:\\n                    word.append(tens[t])\\n                if s in singles:\\n                    word.append(singles[s])\\n                \\n            return \\' \\'.join(word)\\n        \\n        result = []\\n        i = 0\\n        while num:\\n            part = num % 1000\\n            num = num // 1000\\n            \\n            if part and i:\\n                result.append(mags[i])\\n            \\n            part = num2word(part)\\n            if part:\\n                result.append(part)\\n                \\n            i += 1\\n            \\n        return \\' \\'.join(reversed(result))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numberToWords(self, num):\\n        \\n        if not num: return \\'Zero\\'\\n        \\n        singles = {1:\\'One\\', 2:\\'Two\\', 3:\\'Three\\', 4:\\'Four\\', 5:\\'Five\\', 6:\\'Six\\', 7:\\'Seven\\', 8:\\'Eight\\', 9:\\'Nine\\', 10:\\'Ten\\',\\n                  11:\\'Eleven\\', 12:\\'Twelve\\', 13:\\'Thirteen\\', 14:\\'Fourteen\\', 15:\\'Fifteen\\', 16:\\'Sixteen\\', 17:\\'Seventeen\\',\\n                  18:\\'Eighteen\\', 19:\\'Nineteen\\'}\\n        \\n        tens = {2:\\'Twenty\\', 3:\\'Thirty\\', 4:\\'Forty\\', 5:\\'Fifty\\', 6:\\'Sixty\\', 7:\\'Seventy\\', 8:\\'Eighty\\', 9:\\'Ninety\\'}\\n        \\n        mags = [\\'\\', \\'Thousand\\', \\'Million\\', \\'Billion\\', \\'Trillion\\', \\'Quadrillion\\', \\\\\\n\\t\\t\\'Quintrillion\\', \\'Sextillion\\', \\'Septillion\\', \\'Octillion\\', \\'Nonillion\\', \\'Decillion\\']\\n        \\n        def num2word(num):\\n            hun, ten = num // 100, num % 100\\n            word = []\\n            \\n            if hun:\\n                word.append(singles[hun])\\n                word.append(\\'Hundred\\')\\n            \\n            if ten in singles:\\n                word.append(singles[ten])\\n            else:\\n                t, s = ten // 10, ten % 10\\n                \\n                if t in tens:\\n                    word.append(tens[t])\\n                if s in singles:\\n                    word.append(singles[s])\\n                \\n            return \\' \\'.join(word)\\n        \\n        result = []\\n        i = 0\\n        while num:\\n            part = num % 1000\\n            num = num // 1000\\n            \\n            if part and i:\\n                result.append(mags[i])\\n            \\n            part = num2word(part)\\n            if part:\\n                result.append(part)\\n                \\n            i += 1\\n            \\n        return \\' \\'.join(reversed(result))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029431,
                "title": "c-some-fun-with-linq",
                "content": "```\\npublic class Solution\\n{\\n    public string NumberToWords(int num)\\n        => string.Join(\" \", NumberToWordsRecursive(num).DefaultIfEmpty(\"Zero\"));\\n\\n    private IEnumerable<string> NumberToWordsRecursive(int num)\\n    {\\n        foreach (var (val, str) in majors.Where(t => num >= t.val))\\n            return NumberToWordsRecursive(num / val).Append(str).Concat(NumberToWordsRecursive(num % val));\\n\\n        return num == 0 ? Enumerable.Empty<string>() // 0\\n             : num < 20 && num != 10 ? new[] { words[num % 10 - 1, num / 10] } // 1..9, 11..19\\n             : NumberToWordsRecursive(num % 10).Prepend(words[num / 10 - 1, 2]); // 10, 20..99\\n    }\\n    \\n    private static readonly (int val, string str)[] majors =\\n    {\\n        (1_000_000_000, \"Billion\"),\\n        (1_000_000, \"Million\"),\\n        (1_000, \"Thousand\"),\\n        (1_00, \"Hundred\"),\\n    };\\n\\n    private static readonly string[,] words = \\n    {\\n        { \"One\",   \"Eleven\",    \"Ten\"     },\\n        { \"Two\",   \"Twelve\",    \"Twenty\"  },\\n        { \"Three\", \"Thirteen\",  \"Thirty\"  },\\n        { \"Four\",  \"Fourteen\",  \"Forty\"   },\\n        { \"Five\",  \"Fifteen\",   \"Fifty\"   },\\n        { \"Six\",   \"Sixteen\",   \"Sixty\"   },\\n        { \"Seven\", \"Seventeen\", \"Seventy\" },\\n        { \"Eight\", \"Eighteen\",  \"Eighty\"  },\\n        { \"Nine\",  \"Nineteen\",  \"Ninety\"  },\\n    };\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public string NumberToWords(int num)\\n        => string.Join(\" \", NumberToWordsRecursive(num).DefaultIfEmpty(\"Zero\"));\\n\\n    private IEnumerable<string> NumberToWordsRecursive(int num)\\n    {\\n        foreach (var (val, str) in majors.Where(t => num >= t.val))\\n            return NumberToWordsRecursive(num / val).Append(str).Concat(NumberToWordsRecursive(num % val));\\n\\n        return num == 0 ? Enumerable.Empty<string>() // 0\\n             : num < 20 && num != 10 ? new[] { words[num % 10 - 1, num / 10] } // 1..9, 11..19\\n             : NumberToWordsRecursive(num % 10).Prepend(words[num / 10 - 1, 2]); // 10, 20..99\\n    }\\n    \\n    private static readonly (int val, string str)[] majors =\\n    {\\n        (1_000_000_000, \"Billion\"),\\n        (1_000_000, \"Million\"),\\n        (1_000, \"Thousand\"),\\n        (1_00, \"Hundred\"),\\n    };\\n\\n    private static readonly string[,] words = \\n    {\\n        { \"One\",   \"Eleven\",    \"Ten\"     },\\n        { \"Two\",   \"Twelve\",    \"Twenty\"  },\\n        { \"Three\", \"Thirteen\",  \"Thirty\"  },\\n        { \"Four\",  \"Fourteen\",  \"Forty\"   },\\n        { \"Five\",  \"Fifteen\",   \"Fifty\"   },\\n        { \"Six\",   \"Sixteen\",   \"Sixty\"   },\\n        { \"Seven\", \"Seventeen\", \"Seventy\" },\\n        { \"Eight\", \"Eighteen\",  \"Eighty\"  },\\n        { \"Nine\",  \"Nineteen\",  \"Ninety\"  },\\n    };\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025520,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> below20 {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    vector<string> below100 {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    string solve(int n){\\n        if(n<20){\\n            return below20[n];\\n        }else if(n<100){\\n            string tens=below100[n/10];\\n            string ones=below20[n%10];\\n            \\n            return tens+(ones.empty()?\"\":\" \")+ones;\\n        }else if(n<1000){\\n            string hundred=solve(n/100)+\" Hundred\";\\n            string tens=solve(n%100);\\n            \\n            return hundred+(tens.empty()?\"\":\" \")+tens;\\n        }else if(n<1000000){\\n            string thousand=solve(n/1000)+\" Thousand\";\\n            string hundred=solve(n%1000);\\n            \\n            return thousand+(hundred.empty()?\"\":\" \")+hundred;\\n        }else if(n<1000000000){\\n            string million=solve(n/1000000)+\" Million\";\\n            string thousand=solve(n%1000000);\\n            \\n            return million + (thousand.empty()?\"\":\" \")+thousand;\\n        }else {\\n            string billion=solve(n/1000000000)+\" Billion\";\\n            string million=solve(n%1000000000);\\n            \\n            return billion+(million.empty()?\"\":\" \")+million;\\n        }\\n    }\\n    \\n    string numberToWords(int n) {\\n        if(n==0)return \"Zero\";\\n        return solve(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> below20 {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    vector<string> below100 {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    \\n    string solve(int n){\\n        if(n<20){\\n            return below20[n];\\n        }else if(n<100){\\n            string tens=below100[n/10];\\n            string ones=below20[n%10];\\n            \\n            return tens+(ones.empty()?\"\":\" \")+ones;\\n        }else if(n<1000){\\n            string hundred=solve(n/100)+\" Hundred\";\\n            string tens=solve(n%100);\\n            \\n            return hundred+(tens.empty()?\"\":\" \")+tens;\\n        }else if(n<1000000){\\n            string thousand=solve(n/1000)+\" Thousand\";\\n            string hundred=solve(n%1000);\\n            \\n            return thousand+(hundred.empty()?\"\":\" \")+hundred;\\n        }else if(n<1000000000){\\n            string million=solve(n/1000000)+\" Million\";\\n            string thousand=solve(n%1000000);\\n            \\n            return million + (thousand.empty()?\"\":\" \")+thousand;\\n        }else {\\n            string billion=solve(n/1000000000)+\" Billion\";\\n            string million=solve(n%1000000000);\\n            \\n            return billion+(million.empty()?\"\":\" \")+million;\\n        }\\n    }\\n    \\n    string numberToWords(int n) {\\n        if(n==0)return \"Zero\";\\n        return solve(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968260,
                "title": "java-simple-solution-using-stack",
                "content": "Special case: 0 - Zero. Not defined in the problem description.\\nAnd we can\\'t have Zero in any other case.\\n\\nThe simplest idea - process triplets of digits (hundreds) from right to left.\\nPush the word for current order (thousands, millions etc) onto the stack.\\nPush the current string representation (1-9, 10-19 and 20-99 are all distinct cases) onto the stack.\\nPush \"Hundred\" only before processing 3-rd digit from the right of current triple.\\nThen just pop from the stack into a string builder of your choice.\\n\\nI guess the code can be refactored into something more compact, with less IFs, but who cares really?\\n\\n```\\nclass Solution {\\n    \\n    final private static String[] digits={\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n    final private static String[] teens={\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    final private static String[] tens={\"AAA\", \"BBB\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    final private static String[] order={\"\", \"Thousand\", \"Million\", \"Billion\", \"Trillion\", \"Quadrillion\", \"Zillion\", \"Gazillion\", \"Shmazillion\", \"Abracadabrazillion\"};\\n    \\n    final private Stack<String> st = new Stack<>();\\n    \\n    public String numberToWords(int num) {\\n        \\n        int ord=0;\\n        if (num==0)\\n            return digits[0];\\n        while (num>0) {\\n            processNum(num%1000,ord);\\n            num/=1000;\\n            ord++;\\n        }\\n        \\n        StringBuilder sb=new StringBuilder();\\n        while (!st.empty()) {\\n            if (sb.length()>0)\\n                sb.append(\" \");\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n\\n    private void processNum(int num, int ord) {\\n        if (ord>0 && num>0)\\n            st.push(order[ord]);\\n        if (num<10) {\\n            if (num>0)\\n                st.push(digits[num]);\\n            return;\\n        }\\n        if (num<20) {\\n            st.push(teens[num%10]);\\n            return;\\n        }\\n        if (num<100) {\\n            if (num%10>0)\\n                st.push(digits[num%10]);\\n            st.push(tens[num/10]);\\n            return;\\n        }\\n        //100~999 here\\n        int rem=num%100;\\n        if (rem<10){\\n            if (rem>0)\\n                st.push(digits[rem]);\\n        }\\n        else if (rem<20)\\n            st.push(teens[rem%10]);\\n        else {\\n            if (rem%10>0)\\n                st.push(digits[rem%10]);\\n            st.push(tens[rem/10]);\\n        }\\n        rem=num/100;\\n        st.push(\"Hundred\");\\n        st.push(digits[rem]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    final private static String[] digits={\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\\n    final private static String[] teens={\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    final private static String[] tens={\"AAA\", \"BBB\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    final private static String[] order={\"\", \"Thousand\", \"Million\", \"Billion\", \"Trillion\", \"Quadrillion\", \"Zillion\", \"Gazillion\", \"Shmazillion\", \"Abracadabrazillion\"};\\n    \\n    final private Stack<String> st = new Stack<>();\\n    \\n    public String numberToWords(int num) {\\n        \\n        int ord=0;\\n        if (num==0)\\n            return digits[0];\\n        while (num>0) {\\n            processNum(num%1000,ord);\\n            num/=1000;\\n            ord++;\\n        }\\n        \\n        StringBuilder sb=new StringBuilder();\\n        while (!st.empty()) {\\n            if (sb.length()>0)\\n                sb.append(\" \");\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n\\n    private void processNum(int num, int ord) {\\n        if (ord>0 && num>0)\\n            st.push(order[ord]);\\n        if (num<10) {\\n            if (num>0)\\n                st.push(digits[num]);\\n            return;\\n        }\\n        if (num<20) {\\n            st.push(teens[num%10]);\\n            return;\\n        }\\n        if (num<100) {\\n            if (num%10>0)\\n                st.push(digits[num%10]);\\n            st.push(tens[num/10]);\\n            return;\\n        }\\n        //100~999 here\\n        int rem=num%100;\\n        if (rem<10){\\n            if (rem>0)\\n                st.push(digits[rem]);\\n        }\\n        else if (rem<20)\\n            st.push(teens[rem%10]);\\n        else {\\n            if (rem%10>0)\\n                st.push(digits[rem%10]);\\n            st.push(tens[rem/10]);\\n        }\\n        rem=num/100;\\n        st.push(\"Hundred\");\\n        st.push(digits[rem]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845978,
                "title": "quick-and-simple-java-solution-with-a-stack-for-the-output",
                "content": "Need to proces the digits in groups of 3 since that\\'s how the patterns repeat. Each new group of 3 digits can get the \"thousands\" designation representing a number larger than zero.  Notice that \"Ten\" is in the teens group since it\\'s a special case of when digit2 is a 1 this way I didn\\'t need to create any special handling for it.\\n\\nI\\'m using a stack for easy reversal of the string output at the end. \\nDon\\'t forget about the Zero :)\\n\\n```\\nclass Solution {\\n        \\n    private String[] ones = new String[] {\\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\\n    };\\n    \\n    private String[] teens = new String[] {\\n        \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\\n    };\\n    \\n    private String[] tens = new String[] {\\n        \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"\\n    };\\n    \\n    private String[] thousands = new String[] {\\n        \"\", \"Thousand\", \"Million\", \"Billion\"\\n    };\\n    \\n    public String numberToWords(int num) {\\n        \\n        if(num == 0) return \"Zero\";\\n        \\n        Deque<String> stack = new ArrayDeque<String>();\\n        int group = 0;\\n        \\n        // Process the digits in groups of 3\\n        \\n        while(num > 0) {\\n            int digit3 = num % 10; num /= 10;\\n            int digit2 = num % 10; num /= 10;\\n            int digit1 = num % 10; num /= 10;\\n            \\n            if(digit1 * 100 + digit2 * 10 + digit3 > 0) {\\n                stack.push(thousands[group]);\\n            }\\n            \\n            if(digit2 == 1) {\\n                stack.push(teens[digit3]);\\n            } else {\\n                stack.push(ones[digit3]);\\n                stack.push(tens[digit2]);\\n            }\\n            if(digit1 > 0) {\\n                stack.push(\"Hundred\");\\n                stack.push(ones[digit1]);                \\n            }\\n            \\n            group++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(stack.size() > 0) {\\n            String s = stack.pop();\\n            if(s.length() > 0) {\\n                if(sb.length() > 0) sb.append(\" \");\\n                sb.append(s);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        \\n    private String[] ones = new String[] {\\n        \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\\n    };\\n    \\n    private String[] teens = new String[] {\\n        \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\\n    };\\n    \\n    private String[] tens = new String[] {\\n        \"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"\\n    };\\n    \\n    private String[] thousands = new String[] {\\n        \"\", \"Thousand\", \"Million\", \"Billion\"\\n    };\\n    \\n    public String numberToWords(int num) {\\n        \\n        if(num == 0) return \"Zero\";\\n        \\n        Deque<String> stack = new ArrayDeque<String>();\\n        int group = 0;\\n        \\n        // Process the digits in groups of 3\\n        \\n        while(num > 0) {\\n            int digit3 = num % 10; num /= 10;\\n            int digit2 = num % 10; num /= 10;\\n            int digit1 = num % 10; num /= 10;\\n            \\n            if(digit1 * 100 + digit2 * 10 + digit3 > 0) {\\n                stack.push(thousands[group]);\\n            }\\n            \\n            if(digit2 == 1) {\\n                stack.push(teens[digit3]);\\n            } else {\\n                stack.push(ones[digit3]);\\n                stack.push(tens[digit2]);\\n            }\\n            if(digit1 > 0) {\\n                stack.push(\"Hundred\");\\n                stack.push(ones[digit1]);                \\n            }\\n            \\n            group++;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(stack.size() > 0) {\\n            String s = stack.pop();\\n            if(s.length() > 0) {\\n                if(sb.length() > 0) sb.append(\" \");\\n                sb.append(s);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786011,
                "title": "python-easy-and-compact-solution",
                "content": "To be fair this problem doesn\\'t seem to be \\'hard\\' level, normally I can\\'t crack those (Mark to myself: delete this statement once I start looking for a job) :)\\nIt is stated that input in this problem is going to be less that `2**31 - 1`, which means that we have to deal with billions at max. \\nThe main trick is to convert numbers between 1 and 999 to text and then do it several times  for billions, millions, thousands and hundreds adding according rank word representation.\\nI\\'m using 2 dictionaries: one for general cases (1-9, 20-30-...-90, 100-200-...-900) and another for so-called exceptions (10-19). In order to make this dict just a little bit cleaner I do not keep word \\'hundred\\' in there and add it separately. Although I end up storing same values twice with different keys, but I do it intentionally so that accessing these values is done easier later on. The same thing happens with key \\'10\\' where I store one fake value to keep indexing consistent.\\nTo convert numbers between 1-999 to text I created a `hundredsText` helper function. We go in a loop and check whether a number is larger than 100, 10 and 1 at each step. If yes I store value from `words` dict to `result` list and then decrease num accordingly. Also there\\'s an early exit in case we come across one of our exceptions.\\nAll that is left is to use this helper function for each rank of the number if it\\'s larger or equal to 1 billion, 1 million and so on.\\n```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num == 0: return \\'Zero\\'\\n        self.words = {100:(\\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\'),\\n                      10:(\\'Onety\\',\\'Twenty\\', \\'Thirty\\', \\'Forty\\', \\'Fifty\\', \\'Sixty\\', \\'Seventy\\', \\'Eighty\\', \\'Ninety\\'), \\n                      1:(\\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\')}\\n\\n        self.exc = {10:\\'Ten\\',11:\\'Eleven\\', 12:\\'Twelve\\', 13:\\'Thirteen\\', 14:\\'Fourteen\\', \\n                    15:\\'Fifteen\\', 16:\\'Sixteen\\', 17:\\'Seventeen\\', 18:\\'Eighteen\\', 19:\\'Nineteen\\'}\\n        check = ((1000000000, \\'Billion\\'), (1000000, \\'Million\\'), (1000,\\'Thousand\\'), (1, \\'\\'))\\n        self.result = []\\n        \\n        for x, rank in check:\\n            if num > x-1:\\n                self.hundredsText(num//x)\\n                if rank: self.result.append(rank)\\n                num %= x\\n        return \\' \\'.join(self.result)\\n        \\n    def hundredsText(self, num):\\n        check = ((100, \\' Hundred\\'), (10, \\'\\'), (1, \\'\\'))\\n        for x, rank in check:\\n            if num > 9 and num < 20:\\n                self.result.append(self.exc[num])\\n                break\\n            if num > x-1:\\n                self.result.append(self.words[x][num//x-1] + rank)\\n                num %= x\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num == 0: return \\'Zero\\'\\n        self.words = {100:(\\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\'),\\n                      10:(\\'Onety\\',\\'Twenty\\', \\'Thirty\\', \\'Forty\\', \\'Fifty\\', \\'Sixty\\', \\'Seventy\\', \\'Eighty\\', \\'Ninety\\'), \\n                      1:(\\'One\\', \\'Two\\', \\'Three\\', \\'Four\\', \\'Five\\', \\'Six\\', \\'Seven\\', \\'Eight\\', \\'Nine\\')}\\n\\n        self.exc = {10:\\'Ten\\',11:\\'Eleven\\', 12:\\'Twelve\\', 13:\\'Thirteen\\', 14:\\'Fourteen\\', \\n                    15:\\'Fifteen\\', 16:\\'Sixteen\\', 17:\\'Seventeen\\', 18:\\'Eighteen\\', 19:\\'Nineteen\\'}\\n        check = ((1000000000, \\'Billion\\'), (1000000, \\'Million\\'), (1000,\\'Thousand\\'), (1, \\'\\'))\\n        self.result = []\\n        \\n        for x, rank in check:\\n            if num > x-1:\\n                self.hundredsText(num//x)\\n                if rank: self.result.append(rank)\\n                num %= x\\n        return \\' \\'.join(self.result)\\n        \\n    def hundredsText(self, num):\\n        check = ((100, \\' Hundred\\'), (10, \\'\\'), (1, \\'\\'))\\n        for x, rank in check:\\n            if num > 9 and num < 20:\\n                self.result.append(self.exc[num])\\n                break\\n            if num > x-1:\\n                self.result.append(self.words[x][num//x-1] + rank)\\n                num %= x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774566,
                "title": "clean-clear-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string ones[20] = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\",\\n                       \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\\n                       \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\\n                      \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    string tens[10] = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\",\\n                       \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    string others[4] = {\"Hundred\", \"Thousand\", \"Million\", \"Billion\"};\\n    int billions = 1000000000;\\n    int millions = 1000000;\\n    int thousands = 1000;\\n    int hundreds = 100;\\n    //int tens = 20;\\n    string numberToWords(int num, int val, int otherIndex) {\\n        string ans = \"\";\\n        ans += numberToWords(num/val);\\n        ans += \" \";\\n        ans += others[otherIndex];\\n        if(num%val != 0) {\\n            ans += \" \";\\n            ans += numberToWords(num%val);\\n        }\\n        return ans;\\n    }\\n    string numberToWords(int num) {\\n        \\n        if(num >= billions)\\n            return numberToWords(num, billions, 3);\\n        if(num >= millions)\\n            return numberToWords(num, millions, 2);\\n        if(num >= thousands)\\n            return numberToWords(num, thousands, 1);\\n        if(num >= hundreds)\\n            return numberToWords(num, hundreds, 0);\\n        if(num < 20) \\n            return ones[num];\\n        int n = num/10;\\n        string ans = tens[n];\\n        if(num%10 != 0) {\\n            ans += \" \";\\n            ans += ones[num%10];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string ones[20] = {\"Zero\", \"One\", \"Two\", \"Three\", \"Four\",\\n                       \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\\n                       \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\\n                      \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\\n    string tens[10] = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\",\\n                       \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\\n    string others[4] = {\"Hundred\", \"Thousand\", \"Million\", \"Billion\"};\\n    int billions = 1000000000;\\n    int millions = 1000000;\\n    int thousands = 1000;\\n    int hundreds = 100;\\n    //int tens = 20;\\n    string numberToWords(int num, int val, int otherIndex) {\\n        string ans = \"\";\\n        ans += numberToWords(num/val);\\n        ans += \" \";\\n        ans += others[otherIndex];\\n        if(num%val != 0) {\\n            ans += \" \";\\n            ans += numberToWords(num%val);\\n        }\\n        return ans;\\n    }\\n    string numberToWords(int num) {\\n        \\n        if(num >= billions)\\n            return numberToWords(num, billions, 3);\\n        if(num >= millions)\\n            return numberToWords(num, millions, 2);\\n        if(num >= thousands)\\n            return numberToWords(num, thousands, 1);\\n        if(num >= hundreds)\\n            return numberToWords(num, hundreds, 0);\\n        if(num < 20) \\n            return ones[num];\\n        int n = num/10;\\n        string ans = tens[n];\\n        if(num%10 != 0) {\\n            ans += \" \";\\n            ans += ones[num%10];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656195,
                "title": "python3-36-ms-faster-than-46-72-of-python-submissions",
                "content": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num==0:\\n            return (\\'Zero\\')\\n        s=\\'\\'\\n        ones_teens={0:\\'\\',1:\\'One\\',2:\\'Two\\',3:\\'Three\\',4:\\'Four\\', 5:\\'Five\\',6:\\'Six\\',7:\\'Seven\\',8:\\'Eight\\',9:\\'Nine\\',10:\\'Ten\\',11:\\'Eleven\\',12:\\'Twelve\\',13:\\'Thirteen\\',14:\\'Fourteen\\',15:\\'Fifteen\\',16:\\'Sixteen\\',17:\\'Seventeen\\',18:\\'Eighteen\\',19:\\'Nineteen\\',20:\\'Twenty\\'}\\n        tens={20:\\'Twenty\\',30:\\'Thirty\\',40:\\'Forty\\',50:\\'Fifty\\',60:\\'Sixty\\',70:\\'Seventy\\',80:\\'Eighty\\',90:\\'Ninety\\'}\\n        if num<=20:\\n            s=s+\\' \\'+ones_teens[num]\\n            return s.strip()\\n        elif num<100:\\n            if int(num%10)!=0:\\n                s=s+\\' \\'+tens[num//10*10]+\\' \\'+Solution.numberToWords(self,int(num%10))\\n                return s.strip()\\n            else:\\n                s=s+\\' \\'+tens[num//10*10]+\\' \\'\\n                return s.strip()\\n        elif num<1000:\\n            if int(num%100)!=0:\\n                s=s+ones_teens[num//100]+\\' \\'+\\'Hundred \\'+Solution.numberToWords(self,int(num%100))\\n                return s.strip()\\n            else:\\n                s=s+ones_teens[num//100]+\\' \\'+\\'Hundred \\'\\n                return s.strip()\\n        elif num<1000000:\\n            if int(num%1000)!=0:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000)+\\' Thousand \\'+Solution.numberToWords(self,int(num%1000))\\n                return s.strip()\\n            else:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000)+\\' Thousand \\'\\n                return s.strip()\\n        elif num<1000000000:\\n            if int(num%1000000)!=0:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000000)+\\' Million \\'+Solution.numberToWords(self,int(num%1000000))\\n                return s.strip()\\n            else:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000000)+\\' Million \\'\\n                return s.strip()\\n        elif num<1000000000000:\\n            if int(num%1000000000)!=0:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000000000)+\\' Billion \\'+Solution.numberToWords(self,int(num%1000000000))\\n                return s.strip()\\n            else:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000000000)+\\' Billion \\'\\n                return s.strip()\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberToWords(self, num: int) -> str:\\n        if num==0:\\n            return (\\'Zero\\')\\n        s=\\'\\'\\n        ones_teens={0:\\'\\',1:\\'One\\',2:\\'Two\\',3:\\'Three\\',4:\\'Four\\', 5:\\'Five\\',6:\\'Six\\',7:\\'Seven\\',8:\\'Eight\\',9:\\'Nine\\',10:\\'Ten\\',11:\\'Eleven\\',12:\\'Twelve\\',13:\\'Thirteen\\',14:\\'Fourteen\\',15:\\'Fifteen\\',16:\\'Sixteen\\',17:\\'Seventeen\\',18:\\'Eighteen\\',19:\\'Nineteen\\',20:\\'Twenty\\'}\\n        tens={20:\\'Twenty\\',30:\\'Thirty\\',40:\\'Forty\\',50:\\'Fifty\\',60:\\'Sixty\\',70:\\'Seventy\\',80:\\'Eighty\\',90:\\'Ninety\\'}\\n        if num<=20:\\n            s=s+\\' \\'+ones_teens[num]\\n            return s.strip()\\n        elif num<100:\\n            if int(num%10)!=0:\\n                s=s+\\' \\'+tens[num//10*10]+\\' \\'+Solution.numberToWords(self,int(num%10))\\n                return s.strip()\\n            else:\\n                s=s+\\' \\'+tens[num//10*10]+\\' \\'\\n                return s.strip()\\n        elif num<1000:\\n            if int(num%100)!=0:\\n                s=s+ones_teens[num//100]+\\' \\'+\\'Hundred \\'+Solution.numberToWords(self,int(num%100))\\n                return s.strip()\\n            else:\\n                s=s+ones_teens[num//100]+\\' \\'+\\'Hundred \\'\\n                return s.strip()\\n        elif num<1000000:\\n            if int(num%1000)!=0:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000)+\\' Thousand \\'+Solution.numberToWords(self,int(num%1000))\\n                return s.strip()\\n            else:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000)+\\' Thousand \\'\\n                return s.strip()\\n        elif num<1000000000:\\n            if int(num%1000000)!=0:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000000)+\\' Million \\'+Solution.numberToWords(self,int(num%1000000))\\n                return s.strip()\\n            else:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000000)+\\' Million \\'\\n                return s.strip()\\n        elif num<1000000000000:\\n            if int(num%1000000000)!=0:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000000000)+\\' Billion \\'+Solution.numberToWords(self,int(num%1000000000))\\n                return s.strip()\\n            else:\\n                s=s+\\' \\'+Solution.numberToWords(self,num//1000000000)+\\' Billion \\'\\n                return s.strip()\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566607,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1791950,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1565010,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1566774,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1746118,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1570830,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1572181,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1702144,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1572559,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1576146,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1566607,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1791950,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1565010,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1566774,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1746118,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1570830,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1572181,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1702144,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1572559,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 1576146,
                "content": [
                    {
                        "username": "a2421",
                        "content": "If I get this question in an interview I\\'m just going to hang up."
                    },
                    {
                        "username": "ossacomu",
                        "content": "[@kartikdangi01](/kartikdangi01) what happened?"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "I was asked the same question today and guess what \\uD83D\\uDE2D"
                    },
                    {
                        "username": "dheeraj15cs20",
                        "content": "[@mredwan](/mredwan) I have done the same in today\\'s interview for Insight consultant."
                    },
                    {
                        "username": "Mihreteab",
                        "content": "\\uD83E\\uDD23 dying here..."
                    },
                    {
                        "username": "mredwan",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "trickster_77",
                        "content": "        d = {0: \"Zero\",\\n            1: \"One\",\\n            2: \"Two\",\\n            3: \"Three\",\\n            4: \"Four\",\\n            5: \"Five\",\\n            6: \"Six\",\\n            7: \"Seven\",\\n            8: \"Eight\",\\n            9: \"Nine\",\\n            10: \"Ten\",\\n            11: \"Eleven\",\\n            12: \"Twelve\",\\n            13: \"Thirteen\",\\n            14: \"Fourteen\",\\n            15: \"Fifteen\",\\n            16: \"Sixteen\",\\n            17: \"Seventeen\",\\n            18: \"Eighteen\",\\n            19: \"Nineteen\",\\n            20: \"Twenty\",\\n            30: \"Thirty\",\\n            40: \"Forty\",\\n            50: \"Fifty\",\\n            60: \"Sixty\",\\n            70: \"Seventy\",\\n            80: \"Eighty\",\\n            90: \"Ninety\",\\n            100: \"Hundred\",\\n            1000: \"Thousand\",\\n            1000000: \"Million\",\\n            1000000000: \"Billion\"\\n            }\\nYou need this :)"
                    },
                    {
                        "username": "manavbhagat",
                        "content": "thankyou man... :)\\n"
                    },
                    {
                        "username": "Karilli",
                        "content": "f*** i just coded the whole dictionary :(((((("
                    },
                    {
                        "username": "protikkbiswas",
                        "content": "Thanks man..."
                    },
                    {
                        "username": "sathyanarayanandhanuskodi98",
                        "content": "Thank you!!"
                    },
                    {
                        "username": "UntitledCoder",
                        "content": "Thanks! you saved me a lot of finger exercise "
                    },
                    {
                        "username": "anonymous_user_13",
                        "content": "As given in the question, we have to print english words corresponding to number. For example:\\n124 as one hundred twenty four.\\nSo, what if we want to print the number in reverse order without reversing the number itself.\\nFor example, in this case : 124 will be given as input and output should be four hundred twenty one?\\nConstraint here is **you are not allowed to reverse the number.**"
                    },
                    {
                        "username": "mrredo",
                        "content": "for loop the string from right to  left"
                    },
                    {
                        "username": "bgy36ww",
                        "content": "I got this during a phone interview. This question is super long and redundant to write. How does writing this question during a 40 mins phone interview even makes sense?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "40 mins? Now FAANG interviews are of 45 mins long and 10 minutes will be resume review and crap. At best we only have 30ish minutes for thinking and coding!!\nI guess if an interviewer really asked you this in an interview, he is not really expecting you to finish all but just to show him your idea."
                    },
                    {
                        "username": "DanielStatler",
                        "content": "god damn it i already did this task but in georgian instead of english i dont wanna do it again"
                    },
                    {
                        "username": "byuns9334",
                        "content": "why would interviewer want to know if candiate can solve this problem?"
                    },
                    {
                        "username": "tifandotme",
                        "content": "[@Finesse](/Finesse) yeah, most requested feature from a client. definitely\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because this is something that programmers really do on their job"
                    },
                    {
                        "username": "terrancepyrope",
                        "content": "I\\'ve never heard anyone say \"One Hundred One\". \"One Hundred and One\" or \"One Hundred And One\" would make more sense.\\n\\nAlso, it\\'s \"Twenty-One\", not \"Twenty One\".\\n\\nNow I understand why this task has so many dislikes (apart from the many corner-cases, which in my opinion weren\\'t as bad as I had expected)."
                    },
                    {
                        "username": "PhilipSmith",
                        "content": "Question actually very easy, just takes lots of lines of code. Probably should be marked Medium."
                    },
                    {
                        "username": "Finesse",
                        "content": "60 solid lines of Python code in my case, 22 of which are number names (no intentional minification)"
                    },
                    {
                        "username": "XinweiWalt",
                        "content": "Writing One, two .... Million.. this takes longlong time, it\\'s better if leetcode can provide number string in the question, we can copy and paste."
                    },
                    {
                        "username": "jhackgpu",
                        "content": "I understand this problem can be very menial and inplementing a solution is mostly monkey work, but a good chunk of coding is just that. I can understand the sentiment when using a language like Python or Java, languages with very good support for String concatenation, but if you use C there is a genuine challenge with respect to memory management"
                    },
                    {
                        "username": "Finesse",
                        "content": "It was fun to implement to me. Split the number into chunks of 3 digits, and you\\'ve made the problem much simpler. Probably, you need to find a better algorithm to make the task no so tedious."
                    }
                ]
            },
            {
                "id": 2001105,
                "content": [
                    {
                        "username": "Vialor",
                        "content": "I\\'m glad that Leetcode is not in French."
                    },
                    {
                        "username": "maurei",
                        "content": "I\\'m really not sure why this is a hard level question... I guess my prep work has been paying off :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "A good medium to me"
                    },
                    {
                        "username": "Msey",
                        "content": "it should be medium"
                    },
                    {
                        "username": "jl4930",
                        "content": "I won\\'t put my code here this time, it\\'s quick but ugly and I really don\\'t want to polish it."
                    },
                    {
                        "username": "AmekiKyou",
                        "content": "I am typically using fourteen and fourty, ninteen and ninty\\n\\nHowever, it seems that it should be fourteen and forty, nineteen and ninety"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "How this is a hard problem this should be categorized in easy section"
                    },
                    {
                        "username": "bhaweshsinha03",
                        "content": "This is a time consuming question which cannot be completed within 40 Mins, even though the question itself is very easy to handle and after the reading of problem statement the solution automatically triggers to the mind, weather creating dictionary for any integers corresponding to their word as their value is the only method to solve this problem, and again I repeat, it is time consuming...."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Comments on Time and Space Complexities of the recursive code."
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    }; "
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    };"
                    }
                ]
            },
            {
                "id": 1889067,
                "content": [
                    {
                        "username": "Vialor",
                        "content": "I\\'m glad that Leetcode is not in French."
                    },
                    {
                        "username": "maurei",
                        "content": "I\\'m really not sure why this is a hard level question... I guess my prep work has been paying off :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "A good medium to me"
                    },
                    {
                        "username": "Msey",
                        "content": "it should be medium"
                    },
                    {
                        "username": "jl4930",
                        "content": "I won\\'t put my code here this time, it\\'s quick but ugly and I really don\\'t want to polish it."
                    },
                    {
                        "username": "AmekiKyou",
                        "content": "I am typically using fourteen and fourty, ninteen and ninty\\n\\nHowever, it seems that it should be fourteen and forty, nineteen and ninety"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "How this is a hard problem this should be categorized in easy section"
                    },
                    {
                        "username": "bhaweshsinha03",
                        "content": "This is a time consuming question which cannot be completed within 40 Mins, even though the question itself is very easy to handle and after the reading of problem statement the solution automatically triggers to the mind, weather creating dictionary for any integers corresponding to their word as their value is the only method to solve this problem, and again I repeat, it is time consuming...."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Comments on Time and Space Complexities of the recursive code."
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    }; "
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    };"
                    }
                ]
            },
            {
                "id": 1856667,
                "content": [
                    {
                        "username": "Vialor",
                        "content": "I\\'m glad that Leetcode is not in French."
                    },
                    {
                        "username": "maurei",
                        "content": "I\\'m really not sure why this is a hard level question... I guess my prep work has been paying off :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "A good medium to me"
                    },
                    {
                        "username": "Msey",
                        "content": "it should be medium"
                    },
                    {
                        "username": "jl4930",
                        "content": "I won\\'t put my code here this time, it\\'s quick but ugly and I really don\\'t want to polish it."
                    },
                    {
                        "username": "AmekiKyou",
                        "content": "I am typically using fourteen and fourty, ninteen and ninty\\n\\nHowever, it seems that it should be fourteen and forty, nineteen and ninety"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "How this is a hard problem this should be categorized in easy section"
                    },
                    {
                        "username": "bhaweshsinha03",
                        "content": "This is a time consuming question which cannot be completed within 40 Mins, even though the question itself is very easy to handle and after the reading of problem statement the solution automatically triggers to the mind, weather creating dictionary for any integers corresponding to their word as their value is the only method to solve this problem, and again I repeat, it is time consuming...."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Comments on Time and Space Complexities of the recursive code."
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    }; "
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    };"
                    }
                ]
            },
            {
                "id": 1572298,
                "content": [
                    {
                        "username": "Vialor",
                        "content": "I\\'m glad that Leetcode is not in French."
                    },
                    {
                        "username": "maurei",
                        "content": "I\\'m really not sure why this is a hard level question... I guess my prep work has been paying off :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "A good medium to me"
                    },
                    {
                        "username": "Msey",
                        "content": "it should be medium"
                    },
                    {
                        "username": "jl4930",
                        "content": "I won\\'t put my code here this time, it\\'s quick but ugly and I really don\\'t want to polish it."
                    },
                    {
                        "username": "AmekiKyou",
                        "content": "I am typically using fourteen and fourty, ninteen and ninty\\n\\nHowever, it seems that it should be fourteen and forty, nineteen and ninety"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "How this is a hard problem this should be categorized in easy section"
                    },
                    {
                        "username": "bhaweshsinha03",
                        "content": "This is a time consuming question which cannot be completed within 40 Mins, even though the question itself is very easy to handle and after the reading of problem statement the solution automatically triggers to the mind, weather creating dictionary for any integers corresponding to their word as their value is the only method to solve this problem, and again I repeat, it is time consuming...."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Comments on Time and Space Complexities of the recursive code."
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    }; "
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    };"
                    }
                ]
            },
            {
                "id": 1572042,
                "content": [
                    {
                        "username": "Vialor",
                        "content": "I\\'m glad that Leetcode is not in French."
                    },
                    {
                        "username": "maurei",
                        "content": "I\\'m really not sure why this is a hard level question... I guess my prep work has been paying off :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "A good medium to me"
                    },
                    {
                        "username": "Msey",
                        "content": "it should be medium"
                    },
                    {
                        "username": "jl4930",
                        "content": "I won\\'t put my code here this time, it\\'s quick but ugly and I really don\\'t want to polish it."
                    },
                    {
                        "username": "AmekiKyou",
                        "content": "I am typically using fourteen and fourty, ninteen and ninty\\n\\nHowever, it seems that it should be fourteen and forty, nineteen and ninety"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "How this is a hard problem this should be categorized in easy section"
                    },
                    {
                        "username": "bhaweshsinha03",
                        "content": "This is a time consuming question which cannot be completed within 40 Mins, even though the question itself is very easy to handle and after the reading of problem statement the solution automatically triggers to the mind, weather creating dictionary for any integers corresponding to their word as their value is the only method to solve this problem, and again I repeat, it is time consuming...."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Comments on Time and Space Complexities of the recursive code."
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    }; "
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    };"
                    }
                ]
            },
            {
                "id": 2053332,
                "content": [
                    {
                        "username": "Vialor",
                        "content": "I\\'m glad that Leetcode is not in French."
                    },
                    {
                        "username": "maurei",
                        "content": "I\\'m really not sure why this is a hard level question... I guess my prep work has been paying off :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "A good medium to me"
                    },
                    {
                        "username": "Msey",
                        "content": "it should be medium"
                    },
                    {
                        "username": "jl4930",
                        "content": "I won\\'t put my code here this time, it\\'s quick but ugly and I really don\\'t want to polish it."
                    },
                    {
                        "username": "AmekiKyou",
                        "content": "I am typically using fourteen and fourty, ninteen and ninty\\n\\nHowever, it seems that it should be fourteen and forty, nineteen and ninety"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "How this is a hard problem this should be categorized in easy section"
                    },
                    {
                        "username": "bhaweshsinha03",
                        "content": "This is a time consuming question which cannot be completed within 40 Mins, even though the question itself is very easy to handle and after the reading of problem statement the solution automatically triggers to the mind, weather creating dictionary for any integers corresponding to their word as their value is the only method to solve this problem, and again I repeat, it is time consuming...."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Comments on Time and Space Complexities of the recursive code."
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    }; "
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    };"
                    }
                ]
            },
            {
                "id": 2020318,
                "content": [
                    {
                        "username": "Vialor",
                        "content": "I\\'m glad that Leetcode is not in French."
                    },
                    {
                        "username": "maurei",
                        "content": "I\\'m really not sure why this is a hard level question... I guess my prep work has been paying off :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "A good medium to me"
                    },
                    {
                        "username": "Msey",
                        "content": "it should be medium"
                    },
                    {
                        "username": "jl4930",
                        "content": "I won\\'t put my code here this time, it\\'s quick but ugly and I really don\\'t want to polish it."
                    },
                    {
                        "username": "AmekiKyou",
                        "content": "I am typically using fourteen and fourty, ninteen and ninty\\n\\nHowever, it seems that it should be fourteen and forty, nineteen and ninety"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "How this is a hard problem this should be categorized in easy section"
                    },
                    {
                        "username": "bhaweshsinha03",
                        "content": "This is a time consuming question which cannot be completed within 40 Mins, even though the question itself is very easy to handle and after the reading of problem statement the solution automatically triggers to the mind, weather creating dictionary for any integers corresponding to their word as their value is the only method to solve this problem, and again I repeat, it is time consuming...."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Comments on Time and Space Complexities of the recursive code."
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    }; "
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    };"
                    }
                ]
            },
            {
                "id": 2004336,
                "content": [
                    {
                        "username": "Vialor",
                        "content": "I\\'m glad that Leetcode is not in French."
                    },
                    {
                        "username": "maurei",
                        "content": "I\\'m really not sure why this is a hard level question... I guess my prep work has been paying off :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "A good medium to me"
                    },
                    {
                        "username": "Msey",
                        "content": "it should be medium"
                    },
                    {
                        "username": "jl4930",
                        "content": "I won\\'t put my code here this time, it\\'s quick but ugly and I really don\\'t want to polish it."
                    },
                    {
                        "username": "AmekiKyou",
                        "content": "I am typically using fourteen and fourty, ninteen and ninty\\n\\nHowever, it seems that it should be fourteen and forty, nineteen and ninety"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "How this is a hard problem this should be categorized in easy section"
                    },
                    {
                        "username": "bhaweshsinha03",
                        "content": "This is a time consuming question which cannot be completed within 40 Mins, even though the question itself is very easy to handle and after the reading of problem statement the solution automatically triggers to the mind, weather creating dictionary for any integers corresponding to their word as their value is the only method to solve this problem, and again I repeat, it is time consuming...."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Comments on Time and Space Complexities of the recursive code."
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    }; "
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    };"
                    }
                ]
            },
            {
                "id": 1950833,
                "content": [
                    {
                        "username": "Vialor",
                        "content": "I\\'m glad that Leetcode is not in French."
                    },
                    {
                        "username": "maurei",
                        "content": "I\\'m really not sure why this is a hard level question... I guess my prep work has been paying off :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "A good medium to me"
                    },
                    {
                        "username": "Msey",
                        "content": "it should be medium"
                    },
                    {
                        "username": "jl4930",
                        "content": "I won\\'t put my code here this time, it\\'s quick but ugly and I really don\\'t want to polish it."
                    },
                    {
                        "username": "AmekiKyou",
                        "content": "I am typically using fourteen and fourty, ninteen and ninty\\n\\nHowever, it seems that it should be fourteen and forty, nineteen and ninety"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "How this is a hard problem this should be categorized in easy section"
                    },
                    {
                        "username": "bhaweshsinha03",
                        "content": "This is a time consuming question which cannot be completed within 40 Mins, even though the question itself is very easy to handle and after the reading of problem statement the solution automatically triggers to the mind, weather creating dictionary for any integers corresponding to their word as their value is the only method to solve this problem, and again I repeat, it is time consuming...."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Comments on Time and Space Complexities of the recursive code."
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    }; "
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    };"
                    }
                ]
            },
            {
                "id": 1950830,
                "content": [
                    {
                        "username": "Vialor",
                        "content": "I\\'m glad that Leetcode is not in French."
                    },
                    {
                        "username": "maurei",
                        "content": "I\\'m really not sure why this is a hard level question... I guess my prep work has been paying off :)"
                    },
                    {
                        "username": "Finesse",
                        "content": "A good medium to me"
                    },
                    {
                        "username": "Msey",
                        "content": "it should be medium"
                    },
                    {
                        "username": "jl4930",
                        "content": "I won\\'t put my code here this time, it\\'s quick but ugly and I really don\\'t want to polish it."
                    },
                    {
                        "username": "AmekiKyou",
                        "content": "I am typically using fourteen and fourty, ninteen and ninty\\n\\nHowever, it seems that it should be fourteen and forty, nineteen and ninety"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "How this is a hard problem this should be categorized in easy section"
                    },
                    {
                        "username": "bhaweshsinha03",
                        "content": "This is a time consuming question which cannot be completed within 40 Mins, even though the question itself is very easy to handle and after the reading of problem statement the solution automatically triggers to the mind, weather creating dictionary for any integers corresponding to their word as their value is the only method to solve this problem, and again I repeat, it is time consuming...."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Comments on Time and Space Complexities of the recursive code."
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    }; "
                    },
                    {
                        "username": "goyal0ankit",
                        "content": "unordered_map<int,string> d = {\\n        {0, \"Zero\"},\\n        {1, \"One\"},\\n        {2, \"Two\"},\\n        {3, \"Three\"},\\n        {4, \"Four\"},\\n        {5, \"Five\"},\\n        {6, \"Six\"},\\n        {7, \"Seven\"},\\n        {8, \"Eight\"},\\n        {9, \"Nine\"},\\n        {10, \"Ten\"},\\n        {11, \"Eleven\"},\\n        {12, \"Twelve\"},\\n        {13, \"Thirteen\"},\\n        {14, \"Fourteen\"},\\n        {15, \"Fifteen\"},\\n        {16, \"Sixteen\"},\\n        {17, \"Seventeen\"},\\n        {18, \"Eighteen\"},\\n        {19, \"Nineteen\"},\\n        {20, \"Twenty\"},\\n        {30, \"Thirty\"},\\n        {40, \"Forty\"},\\n        {50, \"Fifty\"},\\n        {60, \"Sixty\"},\\n        {70, \"Seventy\"},\\n        {80, \"Eighty\"},\\n        {90, \"Ninety\"},\\n        {100, \"Hundred\"},\\n        {1000, \"Thousand\"},\\n        {1000000, \"Million\"},\\n        {1000000000, \"Billion\"}\\n    };"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find K Pairs with Smallest Sums",
        "question_content": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> sorted in <strong>non-decreasing&nbsp;order</strong> and an integer <code>k</code>.</p>\n\n<p>Define a pair <code>(u, v)</code> which consists of one element from the first array and one element from the second array.</p>\n\n<p>Return <em>the</em> <code>k</code> <em>pairs</em> <code>(u<sub>1</sub>, v<sub>1</sub>), (u<sub>2</sub>, v<sub>2</sub>), ..., (u<sub>k</sub>, v<sub>k</sub>)</code> <em>with the smallest sums</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n<strong>Output:</strong> [[1,2],[1,4],[1,6]]\n<strong>Explanation:</strong> The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n<strong>Output:</strong> [[1,1],[1,1]]\n<strong>Explanation:</strong> The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [3], k = 3\n<strong>Output:</strong> [[1,3],[2,3]]\n<strong>Explanation:</strong> All possible pairs are returned from the sequence: [1,3],[2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums1</code> and <code>nums2</code> both are sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 84551,
                "title": "simple-java-o-klogk-solution-with-explanation",
                "content": "Basic idea: Use min_heap to keep track on next minimum pair sum, and we only need to maintain K possible candidates in the data structure.\\n\\nSome observations: For every numbers in nums1, its best partner(yields min sum) always strats from nums2[0] since arrays are all sorted; And for a specific number in nums1, its next candidate sould be **[this specific number]** + **nums2[current_associated_index + 1]**, unless out of boundary;)\\n\\nHere is a simple example demonstrate how this algorithm works.\\n\\n![image](https://cloud.githubusercontent.com/assets/8743900/17332795/0bb46cfe-589e-11e6-90b5-5d3c9696c4f0.png)\\n\\n\\nThe run time complexity is O(kLogk) since que.size <= k and we do at most k loop.\\n\\n```\\npublic class Solution {\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<int[]> que = new PriorityQueue<>((a,b)->a[0]+a[1]-b[0]-b[1]);\\n        List<int[]> res = new ArrayList<>();\\n        if(nums1.length==0 || nums2.length==0 || k==0) return res;\\n        for(int i=0; i<nums1.length && i<k; i++) que.offer(new int[]{nums1[i], nums2[0], 0});\\n        while(k-- > 0 && !que.isEmpty()){\\n            int[] cur = que.poll();\\n            res.add(new int[]{cur[0], cur[1]});\\n            if(cur[2] == nums2.length-1) continue;\\n            que.offer(new int[]{cur[0],nums2[cur[2]+1], cur[2]+1});\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<int[]> que = new PriorityQueue<>((a,b)->a[0]+a[1]-b[0]-b[1]);\\n        List<int[]> res = new ArrayList<>();\\n        if(nums1.length==0 || nums2.length==0 || k==0) return res;\\n        for(int i=0; i<nums1.length && i<k; i++) que.offer(new int[]{nums1[i], nums2[0], 0});\\n        while(k-- > 0 && !que.isEmpty()){\\n            int[] cur = que.poll();\\n            res.add(new int[]{cur[0], cur[1]});\\n            if(cur[2] == nums2.length-1) continue;\\n            que.offer(new int[]{cur[0],nums2[cur[2]+1], cur[2]+1});\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84550,
                "title": "slow-1-liner-to-fast-solutions",
                "content": "Several solutions from naive to more elaborate. I found it helpful to visualize the input as an **m\\xD7n matrix** of sums, for example for nums1=[1,7,11], and nums2=[2,4,6]:\\n\\n          2   4   6\\n       +------------\\n     1 |  3   5   7\\n     7 |  9  11  13\\n    11 | 13  15  17\\n\\nOf course the smallest pair overall is in the top left corner, the one with sum 3. We don\\'t even need to look anywhere else. After including that pair in the output, the next-smaller pair must be the next on the right (sum=5) or the next below (sum=9). We can keep a \"horizon\" of possible candidates, implemented as a heap / priority-queue, and roughly speaking we\\'ll grow from the top left corner towards the right/bottom. That\\'s what my solution 5 does. Solution 4 is similar, not quite as efficient but a lot shorter and my favorite.\\n<br>\\n\\n## **Solution 1: Brute Force** <sup>(accepted in 560 ms)</sup>\\n\\nJust produce all pairs, sort them by sum, and return the first k.\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        return sorted(itertools.product(nums1, nums2), key=sum)[:k]\\n\\n## **Solution 2: Clean Brute Force** <sup>(accepted in 532 ms)</sup>\\n\\nThe above produces tuples and while the judge doesn\\'t care, it\\'s cleaner to make them lists as requested:\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        return map(list, sorted(itertools.product(nums1, nums2), key=sum)[:k])\\n\\n## **Solution 3: Less Brute Force** <sup>(accepted in 296 ms)</sup>\\n\\nStill going through all pairs, but only with a generator and `heapq.nsmallest`, which uses a heap of size k. So this only takes O(k) extra memory and O(mn log k) time.\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        return map(list, heapq.nsmallest(k, itertools.product(nums1, nums2), key=sum))\\n\\nOr (accepted in 368 ms):\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        return heapq.nsmallest(k, ([u, v] for u in nums1 for v in nums2), key=sum)\\n\\n## **Solution 4: Efficient**  <sup>(accepted in 112 ms)</sup>\\n\\nThe brute force solutions computed the whole matrix (see visualization above). This solution doesn\\'t. It turns each row into a generator of triples [u+v, u, v], only computing the next when asked for one. And then merges these generators with a heap. Takes O(m + k\\\\*log(m)) time and O(m) extra space.\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        streams = map(lambda u: ([u+v, u, v] for v in nums2), nums1)\\n        stream = heapq.merge(*streams)\\n        return [suv[1:] for suv in itertools.islice(stream, k)]\\n\\n## **Solution 5: More efficient**  <sup>(accepted in 104 ms)</sup>\\n\\nThe previous solution right away considered (the first pair of) all matrix rows (see visualization above). This one doesn\\'t. It starts off only with the very first pair at the top-left corner of the matrix, and expands from there as needed. Whenever a pair is chosen into the output result, the next pair in the row gets added to the priority queue of current options. Also, if the chosen pair is the first one in its row, then the first pair in the next row is added to the queue.\\n\\nHere\\'s a visualization of a possible state:\\n```\\n# # # # # ? . .\\n# # # ? . . . .\\n# ? . . . . . .   \"#\" means pair already in the output\\n# ? . . . . . .   \"?\" means pair currently in the queue\\n# ? . . . . . .\\n? . . . . . . .\\n. . . . . . . .\\n```\\nAs I mentioned in the comments, that could be further improved. Two of those `?` don\\'t actually need to be in the queue yet. I\\'ll leave that as an exercise for the reader :-)\\n```\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        queue = []\\n        def push(i, j):\\n            if i < len(nums1) and j < len(nums2):\\n                heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\\n        push(0, 0)\\n        pairs = []\\n        while queue and len(pairs) < k:\\n            _, i, j = heapq.heappop(queue)\\n            pairs.append([nums1[i], nums2[j]])\\n            push(i, j + 1)\\n            if j == 0:\\n                push(i + 1, 0)\\n        return pairs",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# # # # # ? . .\\n# # # ? . . . .\\n# ? . . . . . .   \"#\" means pair already in the output\\n# ? . . . . . .   \"?\" means pair currently in the queue\\n# ? . . . . . .\\n? . . . . . . .\\n. . . . . . . .\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209985,
                "title": "python-heap-solution-with-detail-explanation",
                "content": "I\\'d like to share this elegant design with heap with you guys, which was originally conceived of by someone else. \\n\\nconsider two input arrays:\\nnums1=[a1,a2,a3]\\nnums2=[b1,b2,b3]\\n\\nand let\\'s say k=3\\n\\nWe know the brutal force way to do it is to calc (a1, b1), (a1, b2), (a1,b3)....(a3,b3)\\'s sum respectively and sort the sums, and pick the top 3 of them. This algorithm is O(n2). And we need an algorithm better than that.\\n\\nSo, the overall idea of the algorithm:\\nMaintain a min-heap to keep only part of the whole set of combinations of all elements from nums1 and nums2. That way, we can avoid the brutal force way which is O(n2). We only push necessary pairs into the heap, until we find all of the k pairs.\\n\\nHow we achieve that (for the sake of explanation, ignore the corner cases for now):\\n1, create a heap, then push (S0, N1, N2) into the heap, where N1 is the position of first element in nums1, N2 is the position of first element in nums2, S0 is the sum of N1 and N2. Mark (N1,N2) as visited.\\n2, Pop the root element (S0, N1,N2) out of the heap, add (N1,N2) to the result to be returned. and immediately push (S1, N1+1,N2) and (S2, N1, N2+1) into the heap, where S1 =  nums1[N1+1]+nums2[N2],  S2 = nums1[N1] + nums2[N2+1]. Here, if a pair (Nx, Ny) has already been visited, we\\'ll ignore it and not push it to the heap.\\n3, repeat this, until all k pairs have been added into the return list. Return the list. \\n\\nThe complexity of this algorithm is O(klgk) if k<n, because we repeat k times, and each time we do a O(lgk) heappush.\\n\\nWhy this algorithm works? The real question is, in this algorithm, how do we know that the sum of the pair that got heappopped earlier is always smaller than the sum of any pair that got heappushed later. Why we so sure about that?\\n\\nBecause, look at the process:\\nWe heappop the minimal pair (S0, N1, N2), then immediately heappush two larger pairs (S1, N1+1,N2) and (S2, N1, N2+1). (why S1 and S2 always larger than S0? Because the two arrays are sorted.) And right after the heappush, the heap gets re-heaped, and of course the root at this point is larger (at least equal) than (S0, N1, N2). Remember though, the root now maybe (S1, N1+1,N2) or (S2, N1, N2+1) or any other pair that already exists in the heap after that heappop operation. This process gets repeated over and over again until finished.\\n\\nFrom this, we can conclude that, the pairs that get heappushed is always larger than the pairs that get heappopped earlier. It might be smaller than other pairs that are currently in the heap, but we don\\u2019t care about that. We only care about pairs that got pushed or popped.\\n\\nThe beauty of this algorithm is, it works perfectly under the fact: two array are sorted. If the arrays were to be unsorted, we would not be able to guarentee that the two pairs get heappushed are always larger than the pair that gets heappopped, thus it would be possible that a pair that gets heappopped later is larger than one gets heappopped ealier, which would fail to produce the correct answer.\\n\\n\\nThe code:\\n```\\nfrom heapq import *\\nclass Solution:\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n\\n        if not nums1 or not nums2:\\n            return []\\n\\n        visited = []\\n        heap = []\\n        output = []\\n\\n        heappush(heap, (nums1[0] + nums2[0], 0, 0))\\n        visited.append((0, 0))\\n\\n        while len(output) < k and heap:\\n\\n            val = heappop(heap)\\n            output.append((nums1[val[1]], nums2[val[2]]))\\n\\n            if val[1] + 1 < len(nums1) and (val[1] + 1, val[2]) not in visited:\\n                heappush(heap, (nums1[val[1] + 1] + nums2[val[2]], val[1] + 1, val[2]))\\n                visited.append((val[1] + 1, val[2]))\\n\\n            if val[2] + 1 < len(nums2) and (val[1], val[2] + 1) not in visited:\\n                heappush(heap, (nums1[val[1]] + nums2[val[2] + 1], val[1], val[2] + 1))\\n                visited.append((val[1], val[2] + 1))\\n\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import *\\nclass Solution:\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n\\n        if not nums1 or not nums2:\\n            return []\\n\\n        visited = []\\n        heap = []\\n        output = []\\n\\n        heappush(heap, (nums1[0] + nums2[0], 0, 0))\\n        visited.append((0, 0))\\n\\n        while len(output) < k and heap:\\n\\n            val = heappop(heap)\\n            output.append((nums1[val[1]], nums2[val[2]]))\\n\\n            if val[1] + 1 < len(nums1) and (val[1] + 1, val[2]) not in visited:\\n                heappush(heap, (nums1[val[1] + 1] + nums2[val[2]], val[1] + 1, val[2]))\\n                visited.append((val[1] + 1, val[2]))\\n\\n            if val[2] + 1 < len(nums2) and (val[1], val[2] + 1) not in visited:\\n                heappush(heap, (nums1[val[1]] + nums2[val[2] + 1], val[1], val[2] + 1))\\n                visited.append((val[1], val[2] + 1))\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84607,
                "title": "clean-16ms-c-o-n-space-o-klogn-time-solution-using-priority-queue",
                "content": "Here, N = min(k, n).\\n          K = min(k, mn) \\n        where m, n is the size of two arrays and k is the k in the problem.\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>> result;\\n        if (nums1.empty() || nums2.empty() || k <= 0)\\n            return result;\\n        auto comp = [&nums1, &nums2](pair<int, int> a, pair<int, int> b) {\\n            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];};\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> min_heap(comp);\\n        min_heap.emplace(0, 0);\\n        while(k-- > 0 && min_heap.size())\\n        {\\n            auto idx_pair = min_heap.top(); min_heap.pop();\\n            result.emplace_back(nums1[idx_pair.first], nums2[idx_pair.second]);\\n            if (idx_pair.first + 1 < nums1.size())\\n                min_heap.emplace(idx_pair.first + 1, idx_pair.second);\\n            if (idx_pair.first == 0 && idx_pair.second + 1 < nums2.size())\\n                min_heap.emplace(idx_pair.first, idx_pair.second + 1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int,int>> result;\\n        if (nums1.empty() || nums2.empty() || k <= 0)\\n            return result;\\n        auto comp = [&nums1, &nums2](pair<int, int> a, pair<int, int> b) {\\n            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];};\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> min_heap(comp);\\n        min_heap.emplace(0, 0);\\n        while(k-- > 0 && min_heap.size())\\n        {\\n            auto idx_pair = min_heap.top(); min_heap.pop();\\n            result.emplace_back(nums1[idx_pair.first], nums2[idx_pair.second]);\\n            if (idx_pair.first + 1 < nums1.size())\\n                min_heap.emplace(idx_pair.first + 1, idx_pair.second);\\n            if (idx_pair.first == 0 && idx_pair.second + 1 < nums2.size())\\n                min_heap.emplace(idx_pair.first, idx_pair.second + 1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84566,
                "title": "share-my-solution-which-beat-96-42",
                "content": "This problem is exactly the same as Leetcode378 Kth Smallest Element in a Sorted Matrix, the only difference is this problem give two array while 378 gives a matrix, but they are the same. You can check my previous post for 378 to see how it works.\\nhttps://discuss.leetcode.com/topic/52948/share-my-thoughts-and-solution\\n\\n```\\npublic class Solution {\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<Tuple> pq = new PriorityQueue<Tuple>();\\n        int m = nums1.length, n = nums2.length;\\n        List<int[]> res = new ArrayList<int[]>();\\n        if(nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0 || k <= 0) return res;\\n        for(int j = 0; j <= n-1; j++) pq.offer(new Tuple(0, j, nums1[0]+nums2[j]));\\n        for(int i = 0; i < Math.min(k, m *n); i++) {\\n            Tuple t = pq.poll();\\n            res.add(new int[]{nums1[t.x], nums2[t.y]});\\n            if(t.x == m - 1) continue;\\n            pq.offer(new Tuple (t.x + 1, t.y, nums1[t.x + 1] + nums2[t.y]));\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Tuple implements Comparable<Tuple> {\\n    int x, y, val;\\n    public Tuple (int x, int y, int val) {\\n        this.x = x;\\n        this.y = y;\\n        this.val = val;\\n    }\\n    \\n    @Override\\n    public int compareTo (Tuple that) {\\n        return this.val - that.val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<Tuple> pq = new PriorityQueue<Tuple>();\\n        int m = nums1.length, n = nums2.length;\\n        List<int[]> res = new ArrayList<int[]>();\\n        if(nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0 || k <= 0) return res;\\n        for(int j = 0; j <= n-1; j++) pq.offer(new Tuple(0, j, nums1[0]+nums2[j]));\\n        for(int i = 0; i < Math.min(k, m *n); i++) {\\n            Tuple t = pq.poll();\\n            res.add(new int[]{nums1[t.x], nums2[t.y]});\\n            if(t.x == m - 1) continue;\\n            pq.offer(new Tuple (t.x + 1, t.y, nums1[t.x + 1] + nums2[t.y]));\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Tuple implements Comparable<Tuple> {\\n    int x, y, val;\\n    public Tuple (int x, int y, int val) {\\n        this.x = x;\\n        this.y = y;\\n        this.val = val;\\n    }\\n    \\n    @Override\\n    public int compareTo (Tuple that) {\\n        return this.val - that.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596658,
                "title": "c-solution-with-diagram-explaination-for-beginners",
                "content": "```\\nWe will be solving this question using heaps.\\nThe main idea will be to use a max heap to store k smallest elements.\\nWe can solve this using a min heap also but using a max heap saves memory as in stores only k elements.\\n\\nLet nums1 = [1,7,11], nums2 = [2,4,6], k = 3\\n we are going to create a heap containing pair(sum,pair(nums1[i],nums2[j])).\\n Thus the heap will heapify itself making the largest sum come on top.\\n\\n              maxheap\\n\\n           |                |\\n           |                |    <-------nums1[0] &&  nums2[0]\\n           |                |\\n           |   {3,{1,2}}    |\\n           |________________|   \\n\\n           We will keep proceeding until we hit the size k.\\n\\n             maxheap\\n\\n           |                |\\n           |                |    <-------nums1[0] &&  nums2[1]\\n           |   {5,{1,4}}    |\\n           |   {3,{1,2}}    |\\n           |________________| \\n\\n\\n             maxheap\\n\\n           |                |\\n           |   {7,{1,6}}    |    <-------nums1[0] &&  nums2[2]\\n           |   {5,{1,4}}    |\\n           |   {3,{1,2}}    |\\n           |________________| \\n\\n\\n           After this we keep checking if the sum is smaller than the top of the heap if yes replace.\\n\\n           However in this example this is the answer.\\n\\n           Before pushing it to the array reverse it as the heap stores it in decreasing sum.\\n\\n           [[1,2],[1,4],[1,6]]  this will be the final output\\n\\n    //code\\n      vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n      priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                int sum=nums1[i]+nums2[j];\\n                if(pq.size()<k)pq.push({sum,{nums1[i],nums2[j]}});\\n                else if(sum<pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty())\\n        {\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nWe will be solving this question using heaps.\\nThe main idea will be to use a max heap to store k smallest elements.\\nWe can solve this using a min heap also but using a max heap saves memory as in stores only k elements.\\n\\nLet nums1 = [1,7,11], nums2 = [2,4,6], k = 3\\n we are going to create a heap containing pair(sum,pair(nums1[i],nums2[j])).\\n Thus the heap will heapify itself making the largest sum come on top.\\n\\n              maxheap\\n\\n           |                |\\n           |                |    <-------nums1[0] &&  nums2[0]\\n           |                |\\n           |   {3,{1,2}}    |\\n           |________________|   \\n\\n           We will keep proceeding until we hit the size k.\\n\\n             maxheap\\n\\n           |                |\\n           |                |    <-------nums1[0] &&  nums2[1]\\n           |   {5,{1,4}}    |\\n           |   {3,{1,2}}    |\\n           |________________| \\n\\n\\n             maxheap\\n\\n           |                |\\n           |   {7,{1,6}}    |    <-------nums1[0] &&  nums2[2]\\n           |   {5,{1,4}}    |\\n           |   {3,{1,2}}    |\\n           |________________| \\n\\n\\n           After this we keep checking if the sum is smaller than the top of the heap if yes replace.\\n\\n           However in this example this is the answer.\\n\\n           Before pushing it to the array reverse it as the heap stores it in decreasing sum.\\n\\n           [[1,2],[1,4],[1,6]]  this will be the final output\\n\\n    //code\\n      vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n      priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                int sum=nums1[i]+nums2[j];\\n                if(pq.size()<k)pq.push({sum,{nums1[i],nums2[j]}});\\n                else if(sum<pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty())\\n        {\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3686980,
                "title": "from-dumb-to-pro-with-just-one-visit-my-promise-to-you-with-efficient-selection-of-k-smallest-pair",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to find the k smallest pairs from two sorted arrays, `nums1` and `nums2`, based on their pair sums. The approach used in the code is optimized to avoid inserting all pairs into the priority queue, which would result in a time complexity of $O(N^2 log N^2)$ and lead to a Time Limit Exceeded (TLE) error.\\n\\nTo overcome this, the code follows a specific method to find the k smallest pairs efficiently. It starts by inserting the pair sums of each element from `nums1` and the first element of `nums2` into a priority queue. Since both arrays are sorted, the pair sums will be in increasing order.\\n\\nBy utilizing a priority queue, the smallest sum pair is always accessible at the top. The code then pops the smallest pair from the priority queue and adds it to the result vector. Next, it inserts the next pair, which consists of the same element from `nums1` but the next element from `nums2`.\\n\\nThe code repeats this process, gradually inserting pairs with increasing elements from `nums2`, until it has added k pairs to the result vector or the priority queue becomes empty (i.e., all pairs have been explored). This ensures that only the k smallest pairs are considered.\\n\\nFinally, the code returns the resulting vector containing the k smallest pairs.\\n\\nOverall, the approach intelligently uses the priority queue to avoid unnecessary computations, allowing for an optimized solution with a time complexity of $O(K log N)$, where N represents the size of `nums1` and K is the given parameter for the number of smallest pairs to find.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an empty result vector `resV` to store the k smallest pairs.\\n2. Create a priority queue `pq` to store pairs of elements from `nums1` and `nums2` with the smallest sums. The pairs are sorted by their sum in ascending order.\\n3. Iterate through each element `x` in `nums1`.\\n    - Calculate the sum of `x` and the first element of `nums2` (since `nums2` is sorted, the first element has the smallest value).\\n    - Push the pair consisting of the sum and the index of the first element in `nums2` (which is 0) into the priority queue.\\n4. While `k` is greater than 0 and the priority queue is not empty, perform the following steps:\\n    - Get the pair with the smallest sum from the top of the priority queue.\\n    - Extract the sum and the index from the pair.\\n    - Create a pair by subtracting the value of the second element in the pair from the sum and the value of the second element itself.\\n    - Add the created pair to the result vector `resV`.\\n    - Remove the pair from the priority queue.\\n    - If there are more elements in `nums2` (i.e., the index of the second element is less than the size of `nums2` minus 1), calculate the sum of the next pair by subtracting the current second element from the sum and adding the next element in `nums2`. Push this new pair into the priority queue.\\n    - Decrement `k` by 1.\\n5. Return the resulting vector `resV` containing the k smallest pairs.\\n\\nThe approach essentially involves maintaining a priority queue to keep track of the smallest sums and their corresponding pairs. By iteratively extracting the smallest sum and updating the index of the second element from `nums2`, the code ensures that only the k smallest pairs are included in the result.\\n\\n# Complexity\\n- Time Complexity:\\n    - The maximum size of the priority queue `pq` is `nums1.size()` (denoted as `n1`), as for each element in nums1, we push one element into the priority queue. The maximum number of iterations that can happen is `k`, as the loop runs until k smallest pairs are found or until the priority queue is empty.\\n    - **Therefore, the time complexity of the given code is $O(k * log (n1))$, where n1 is the size of nums1 and k is the desired number of smallest pairs to be found.**\\n\\n- Space Complexity:\\n    - The additional space used by the code includes the result vector `resV` and the priority queue `pq`.\\n    - The result vector `resV` will contain at most k pairs, so it occupies $O(k)$ space.\\n    - The priority queue `pq` can hold at most k pairs as well, resulting in $O(n1)$ space.\\n    - **Therefore, the overall space complexity is $O(n1 + k)$.**\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> resV; // Result vector to store the pairs\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        // Priority queue to store pairs with smallest sums, sorted by the sum\\n\\n        // Push the initial pairs into the priority queue\\n        for(int x : nums1) {\\n            pq.push({x + nums2[0], 0}); // The sum and the index of the second element in nums2\\n        }\\n\\n        // Pop the k smallest pairs from the priority queue\\n        while(k-- && !pq.empty()) {\\n            int sum = pq.top().first; // Get the smallest sum\\n            int pos = pq.top().second; // Get the index of the second element in nums2\\n\\n            resV.push_back({sum - nums2[pos], nums2[pos]}); // Add the pair to the result vector\\n            pq.pop(); // Remove the pair from the priority queue\\n\\n            // If there are more elements in nums2, push the next pair into the priority queue\\n            if(pos + 1 < nums2.size()) {\\n                pq.push({sum - nums2[pos] + nums2[pos + 1], pos + 1});\\n            }\\n        }\\n\\n        return resV; // Return the k smallest pairs\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> resV = new ArrayList<>(); // Result list to store the pairs\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        // Priority queue to store pairs with smallest sums, sorted by the sum\\n\\n        // Push the initial pairs into the priority queue\\n        for (int x : nums1) {\\n            pq.offer(new int[]{x + nums2[0], 0}); // The sum and the index of the second element in nums2\\n        }\\n\\n        // Pop the k smallest pairs from the priority queue\\n        while (k > 0 && !pq.isEmpty()) {\\n            int[] pair = pq.poll();\\n            int sum = pair[0]; // Get the smallest sum\\n            int pos = pair[1]; // Get the index of the second element in nums2\\n\\n            List<Integer> currentPair = new ArrayList<>();\\n            currentPair.add(sum - nums2[pos]);\\n            currentPair.add(nums2[pos]);\\n            resV.add(currentPair); // Add the pair to the result list\\n\\n            // If there are more elements in nums2, push the next pair into the priority queue\\n            if (pos + 1 < nums2.length) {\\n                pq.offer(new int[]{sum - nums2[pos] + nums2[pos + 1], pos + 1});\\n            }\\n\\n            k--; // Decrement k\\n        }\\n\\n        return resV; // Return the k smallest pairs\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        resV = []  # Result list to store the pairs\\n        pq = []  # Priority queue to store pairs with smallest sums, sorted by the sum\\n\\n        # Push the initial pairs into the priority queue\\n        for x in nums1:\\n            heapq.heappush(pq, [x + nums2[0], 0])  # The sum and the index of the second element in nums2\\n\\n        # Pop the k smallest pairs from the priority queue\\n        while k > 0 and pq:\\n            pair = heapq.heappop(pq)\\n            s, pos = pair[0], pair[1]  # Get the smallest sum and the index of the second element in nums2\\n\\n            resV.append([s - nums2[pos], nums2[pos]])  # Add the pair to the result list\\n\\n            # If there are more elements in nums2, push the next pair into the priority queue\\n            if pos + 1 < len(nums2):\\n                heapq.heappush(pq, [s - nums2[pos] + nums2[pos + 1], pos + 1])\\n\\n            k -= 1  # Decrement k\\n\\n        return resV  # Return the k smallest pairs\\n```\\n*Thank you for taking the time to read my post in its entirety. I appreciate your attention and hope you found it informative and helpful.*\\n\\n**PLEASE UPVOTE THIS POST IF YOU FOUND IT HELPFUL**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> resV; // Result vector to store the pairs\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        // Priority queue to store pairs with smallest sums, sorted by the sum\\n\\n        // Push the initial pairs into the priority queue\\n        for(int x : nums1) {\\n            pq.push({x + nums2[0], 0}); // The sum and the index of the second element in nums2\\n        }\\n\\n        // Pop the k smallest pairs from the priority queue\\n        while(k-- && !pq.empty()) {\\n            int sum = pq.top().first; // Get the smallest sum\\n            int pos = pq.top().second; // Get the index of the second element in nums2\\n\\n            resV.push_back({sum - nums2[pos], nums2[pos]}); // Add the pair to the result vector\\n            pq.pop(); // Remove the pair from the priority queue\\n\\n            // If there are more elements in nums2, push the next pair into the priority queue\\n            if(pos + 1 < nums2.size()) {\\n                pq.push({sum - nums2[pos] + nums2[pos + 1], pos + 1});\\n            }\\n        }\\n\\n        return resV; // Return the k smallest pairs\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> resV = new ArrayList<>(); // Result list to store the pairs\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        // Priority queue to store pairs with smallest sums, sorted by the sum\\n\\n        // Push the initial pairs into the priority queue\\n        for (int x : nums1) {\\n            pq.offer(new int[]{x + nums2[0], 0}); // The sum and the index of the second element in nums2\\n        }\\n\\n        // Pop the k smallest pairs from the priority queue\\n        while (k > 0 && !pq.isEmpty()) {\\n            int[] pair = pq.poll();\\n            int sum = pair[0]; // Get the smallest sum\\n            int pos = pair[1]; // Get the index of the second element in nums2\\n\\n            List<Integer> currentPair = new ArrayList<>();\\n            currentPair.add(sum - nums2[pos]);\\n            currentPair.add(nums2[pos]);\\n            resV.add(currentPair); // Add the pair to the result list\\n\\n            // If there are more elements in nums2, push the next pair into the priority queue\\n            if (pos + 1 < nums2.length) {\\n                pq.offer(new int[]{sum - nums2[pos] + nums2[pos + 1], pos + 1});\\n            }\\n\\n            k--; // Decrement k\\n        }\\n\\n        return resV; // Return the k smallest pairs\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        resV = []  # Result list to store the pairs\\n        pq = []  # Priority queue to store pairs with smallest sums, sorted by the sum\\n\\n        # Push the initial pairs into the priority queue\\n        for x in nums1:\\n            heapq.heappush(pq, [x + nums2[0], 0])  # The sum and the index of the second element in nums2\\n\\n        # Pop the k smallest pairs from the priority queue\\n        while k > 0 and pq:\\n            pair = heapq.heappop(pq)\\n            s, pos = pair[0], pair[1]  # Get the smallest sum and the index of the second element in nums2\\n\\n            resV.append([s - nums2[pos], nums2[pos]])  # Add the pair to the result list\\n\\n            # If there are more elements in nums2, push the next pair into the priority queue\\n            if pos + 1 < len(nums2):\\n                heapq.heappush(pq, [s - nums2[pos] + nums2[pos + 1], pos + 1])\\n\\n            k -= 1  # Decrement k\\n\\n        return resV  # Return the k smallest pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84569,
                "title": "java-9ms-heap-queue-solution-k-log-k",
                "content": "Frist, we take the first k elements of nums1 and paired with nums2[0] as the starting pairs so that we have (0,0), (1,0), (2,0),.....(k-1,0) in the heap.\\nEach time after we pick the pair with min sum, we put the new pair with the second index +1. ie, pick (0,0), we put back (0,1). Therefore, the heap alway maintains at most min(k, len(nums1)) elements.    \\n\\n```\\npublic class Solution {\\n    class Pair{\\n        int[] pair;\\n        int idx; // current index to nums2\\n        long sum;\\n        Pair(int idx, int n1, int n2){\\n            this.idx = idx;\\n            pair = new int[]{n1, n2};\\n            sum = (long) n1 + (long) n2;\\n        }\\n    }\\n    class CompPair implements Comparator<Pair> {\\n        public int compare(Pair p1, Pair p2){\\n            return Long.compare(p1.sum, p2.sum);\\n        }\\n    }\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> ret = new ArrayList<>();\\n        if (nums1==null || nums2==null || nums1.length ==0 || nums2.length ==0) return ret;\\n        int len1 = nums1.length, len2=nums2.length;  \\n\\n        PriorityQueue<Pair> q = new PriorityQueue(k, new CompPair()); \\n        for (int i=0; i<nums1.length && i<k ; i++) { // only need first k number in nums1 to start  \\n            q.offer( new Pair(0, nums1[i],nums2[0]) );\\n        }\\n        for (int i=1; i<=k && !q.isEmpty(); i++) { // get the first k sums\\n            Pair p = q.poll(); \\n            ret.add( p.pair );\\n            if (p.idx < len2 -1 ) { // get to next value in nums2\\n                int next = p.idx+1;\\n                q.offer( new Pair(next, p.pair[0], nums2[next]) );\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    class Pair{\\n        int[] pair;\\n        int idx; // current index to nums2\\n        long sum;\\n        Pair(int idx, int n1, int n2){\\n            this.idx = idx;\\n            pair = new int[]{n1, n2};\\n            sum = (long) n1 + (long) n2;\\n        }\\n    }\\n    class CompPair implements Comparator<Pair> {\\n        public int compare(Pair p1, Pair p2){\\n            return Long.compare(p1.sum, p2.sum);\\n        }\\n    }\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> ret = new ArrayList<>();\\n        if (nums1==null || nums2==null || nums1.length ==0 || nums2.length ==0) return ret;\\n        int len1 = nums1.length, len2=nums2.length;  \\n\\n        PriorityQueue<Pair> q = new PriorityQueue(k, new CompPair()); \\n        for (int i=0; i<nums1.length && i<k ; i++) { // only need first k number in nums1 to start  \\n            q.offer( new Pair(0, nums1[i],nums2[0]) );\\n        }\\n        for (int i=1; i<=k && !q.isEmpty(); i++) { // get the first k sums\\n            Pair p = q.poll(); \\n            ret.add( p.pair );\\n            if (p.idx < len2 -1 ) { // get to next value in nums2\\n                int next = p.idx+1;\\n                q.offer( new Pair(next, p.pair[0], nums2[next]) );\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84629,
                "title": "bfs-python-104ms-with-comments",
                "content": "![0_1467926471298_matrix.jpg](/uploads/files/1467926471951-matrix.jpg) \\nGiven the matrix for [1,7,11] and [2,4,6], we can do BFS from the top-left position to expand candidates from only right cell and bottom cell. Since we treat it as a graph, we need to skip visited vertices as I used a dictionary `visited`.\\n\\n```\\nclass Solution(object):\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        import heapq\\n        ret = []\\n        if len(nums1) * len(nums2) > 0:\\n            queue = [(nums1[0] + nums2[0], (0, 0))]\\n            visited = {}\\n            while len(ret) < k and queue:\\n                _, (i, j) = heapq.heappop(queue)\\n                ret.append((nums1[i], nums2[j]))\\n                if j + 1 < len(nums2) and (i, j + 1) not in visited:\\n                        heapq.heappush(queue, (nums1[i] + nums2[j + 1], (i, j + 1)))\\n                        visited[(i, j + 1)] = 1\\n                if i + 1 < len(nums1) and (i + 1, j) not in visited:\\n                        heapq.heappush(queue, (nums1[i + 1] + nums2[j], (i + 1, j)))\\n                        visited[(i + 1, j)] = 1\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        import heapq\\n        ret = []\\n        if len(nums1) * len(nums2) > 0:\\n            queue = [(nums1[0] + nums2[0], (0, 0))]\\n            visited = {}\\n            while len(ret) < k and queue:\\n                _, (i, j) = heapq.heappop(queue)\\n                ret.append((nums1[i], nums2[j]))\\n                if j + 1 < len(nums2) and (i, j + 1) not in visited:\\n                        heapq.heappush(queue, (nums1[i] + nums2[j + 1], (i, j + 1)))\\n                        visited[(i, j + 1)] = 1\\n                if i + 1 < len(nums1) and (i + 1, j) not in visited:\\n                        heapq.heappush(queue, (nums1[i + 1] + nums2[j], (i + 1, j)))\\n                        visited[(i + 1, j)] = 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84577,
                "title": "o-k-solution",
                "content": "Now that I can find the [kth smallest element in a sorted n\\xd7n matrix in time O(min(n, k))](https://discuss.leetcode.com/topic/53126/o-n-from-paper-yes-o-rows), I can finally solve this problem in O(k).\\n\\n**The idea:**\\n1. If `nums1` or `nums2` are larger than `k`, shrink them to size `k`.\\n2. Build a virtual matrix of the pair sums, i.e., `matrix[i][j] = nums1[i] + nums2[j]`. Make it a square matrix by padding with \"infinity\" if necessary. With \"virtual\" I mean its entries will be computed on the fly, and only those that are needed. This is necessary to stay within O(k) time.\\n3. Find the kth smallest sum `kthSum` by using that other algorithm.\\n4. Use a saddleback search variation to discount the pairs with sum **smaller** than `kthSum`. After this, `k` tells how many pairs we need whose sum **equals** `kthSum`.\\n5. Collect all pairs with sum smaller than `kthSum` as well as `k` pairs whose sum equals `kthSum`.\\n\\nEach of those steps only takes O(k) time.\\n\\nThe code (minus the code for kthSmallest, which you can copy verbatim from my solution to the other problem):\\n\\n```\\nclass Solution(object):\\n    def kSmallestPairs(self, nums1_, nums2_, k):\\n\\n        # Use at most the first k of each, then get the sizes.\\n        nums1 = nums1_[:k]\\n        nums2 = nums2_[:k]\\n        m, n = len(nums1), len(nums2)\\n\\n        # Gotta Catch 'Em All?\\n        if k >= m * n:\\n            return [[a, b] for a in nums1 for b in nums2]\\n        \\n        # Build a virtual matrix.\\n        N, inf = max(m, n), float('inf')\\n        class Row:\\n            def __init__(self, i):\\n                self.i = i\\n            def __getitem__(self, j):\\n                return nums1[self.i] + nums2[j] if self.i < m and j < n else inf\\n        matrix = map(Row, range(N))\\n\\n        # Get the k-th sum.\\n        kthSum = self.kthSmallest(matrix, k)\\n\\n        # Discount the pairs with sum smaller than the k-th.\\n        j = min(k, n)\\n        for a in nums1:\\n            while j and a + nums2[j-1] >= kthSum:\\n                j -= 1\\n            k -= j\\n\\n        # Collect and return the pairs.\\n        pairs = []\\n        for a in nums1:\\n            for b in nums2:\\n                if a + b >= kthSum + (k > 0):\\n                    break\\n                pairs.append([a, b])\\n                k -= a + b == kthSum\\n        return pairs\\n\\n    def kthSmallest(self, matrix, k):\\n        \\n        # copy & paste from https://discuss.leetcode.com/topic/53126/o-n-from-paper-yes-o-rows\\n```\\nThanks to @zhiqing_xiao for pointing out that my previous way of capping the input lists might not be O(k). It was this:\\n\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        del nums1[k:]\\n        del nums2[k:]",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kSmallestPairs(self, nums1_, nums2_, k):\\n\\n        # Use at most the first k of each, then get the sizes.\\n        nums1 = nums1_[:k]\\n        nums2 = nums2_[:k]\\n        m, n = len(nums1), len(nums2)\\n\\n        # Gotta Catch 'Em All?\\n        if k >= m * n:\\n            return [[a, b] for a in nums1 for b in nums2]\\n        \\n        # Build a virtual matrix.\\n        N, inf = max(m, n), float('inf')\\n        class Row:\\n            def __init__(self, i):\\n                self.i = i\\n            def __getitem__(self, j):\\n                return nums1[self.i] + nums2[j] if self.i < m and j < n else inf\\n        matrix = map(Row, range(N))\\n\\n        # Get the k-th sum.\\n        kthSum = self.kthSmallest(matrix, k)\\n\\n        # Discount the pairs with sum smaller than the k-th.\\n        j = min(k, n)\\n        for a in nums1:\\n            while j and a + nums2[j-1] >= kthSum:\\n                j -= 1\\n            k -= j\\n\\n        # Collect and return the pairs.\\n        pairs = []\\n        for a in nums1:\\n            for b in nums2:\\n                if a + b >= kthSum + (k > 0):\\n                    break\\n                pairs.append([a, b])\\n                k -= a + b == kthSum\\n        return pairs\\n\\n    def kthSmallest(self, matrix, k):\\n        \\n        # copy & paste from https://discuss.leetcode.com/topic/53126/o-n-from-paper-yes-o-rows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346755,
                "title": "c-simple-c-code-priority-queue",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < n; i++)\\n            pq.push({nums1[i]+nums2[0],{i,0}});\\n        while(!pq.empty() && k--)\\n        {\\n            pair<int,pair<int,int>> tp = pq.top();\\n            int x = tp.second.first, y = tp.second.second;\\n            pq.pop();\\n            ans.push_back({nums1[x], nums2[y]});\\n            if(y != m-1)\\n                pq.push({nums1[x]+nums2[y+1],{x, y+1}});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < n; i++)\\n            pq.push({nums1[i]+nums2[0],{i,0}});\\n        while(!pq.empty() && k--)\\n        {\\n            pair<int,pair<int,int>> tp = pq.top();\\n            int x = tp.second.first, y = tp.second.second;\\n            pq.pop();\\n            ans.push_back({nums1[x], nums2[y]});\\n            if(y != m-1)\\n                pq.push({nums1[x]+nums2[y+1],{x, y+1}});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84568,
                "title": "c-priority-queue-solution",
                "content": "nums1: m     nums2: n \\ntime complexity: O(m * n logk)\\nspace complexity O(k)\\n\\n72ms solution:\\n```\\nclass Solution {\\nprivate:\\n    struct mycompare{\\n        bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n            return p1.first + p1.second < p2.first + p2.second;\\n        }\\n    };\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> res;\\n        priority_queue<pair<int,int>, vector<pair<int, int> >, mycompare> pq;\\n        for(int i = 0; i < min((int)nums1.size(), k); i++){\\n            for(int j = 0; j < min((int)nums2.size(), k); j++){\\n                if(pq.size() < k)\\n                    pq.push(make_pair(nums1[i], nums2[j]));\\n                else if(nums1[i] + nums2[j] < pq.top().first + pq.top().second){\\n                    pq.push(make_pair(nums1[i], nums2[j]));\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        while(!pq.empty()){\\n            res.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n1132ms solution:\\n```\\nclass Solution {\\nprivate:\\n    struct mycompare{\\n        bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n            return p1.first + p1.second < p2.first + p2.second;\\n        }\\n    };\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> res;\\n        priority_queue<pair<int,int>, vector<pair<int, int> >, mycompare> pq;\\n        for(int num1 : nums1){\\n            for(int num2 : nums2){\\n                pq.push(make_pair(num1, num2));\\n                if(pq.size() > k) pq.pop();\\n            }\\n        }\\n        while(!pq.empty()){\\n            res.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n40ms solution:\\n```\\nclass Solution {\\npublic:\\nvector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> res;\\n        int m = (int)nums1.size();\\n        int n = (int)nums2.size();\\n        k = min(k, m * n);\\n        vector<int> indice(m, 0);\\n        while(k-- > 0){\\n            int tmp_index = 0;\\n            long tmp_sum = LONG_MAX;\\n            for(int i = 0; i < m; i++){\\n                if(indice[i] < n && tmp_sum >= nums1[i] + nums2[indice[i]]){\\n                    tmp_index = i;\\n                    tmp_sum = nums1[i] + nums2[indice[i]];\\n                }\\n            }\\n            res.push_back(make_pair(nums1[tmp_index], nums2[indice[tmp_index]]));\\n            indice[tmp_index]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct mycompare{\\n        bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n            return p1.first + p1.second < p2.first + p2.second;\\n        }\\n    };\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> res;\\n        priority_queue<pair<int,int>, vector<pair<int, int> >, mycompare> pq;\\n        for(int i = 0; i < min((int)nums1.size(), k); i++){\\n            for(int j = 0; j < min((int)nums2.size(), k); j++){\\n                if(pq.size() < k)\\n                    pq.push(make_pair(nums1[i], nums2[j]));\\n                else if(nums1[i] + nums2[j] < pq.top().first + pq.top().second){\\n                    pq.push(make_pair(nums1[i], nums2[j]));\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        while(!pq.empty()){\\n            res.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    struct mycompare{\\n        bool operator()(pair<int, int>& p1, pair<int, int>& p2){\\n            return p1.first + p1.second < p2.first + p2.second;\\n        }\\n    };\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> res;\\n        priority_queue<pair<int,int>, vector<pair<int, int> >, mycompare> pq;\\n        for(int num1 : nums1){\\n            for(int num2 : nums2){\\n                pq.push(make_pair(num1, num2));\\n                if(pq.size() > k) pq.pop();\\n            }\\n        }\\n        while(!pq.empty()){\\n            res.push_back(pq.top());\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> res;\\n        int m = (int)nums1.size();\\n        int n = (int)nums2.size();\\n        k = min(k, m * n);\\n        vector<int> indice(m, 0);\\n        while(k-- > 0){\\n            int tmp_index = 0;\\n            long tmp_sum = LONG_MAX;\\n            for(int i = 0; i < m; i++){\\n                if(indice[i] < n && tmp_sum >= nums1[i] + nums2[indice[i]]){\\n                    tmp_index = i;\\n                    tmp_sum = nums1[i] + nums2[indice[i]];\\n                }\\n            }\\n            res.push_back(make_pair(nums1[tmp_index], nums2[indice[tmp_index]]));\\n            indice[tmp_index]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84611,
                "title": "java-10ms-solution-no-priority-queue",
                "content": "Because both array are sorted, so we can keep track of the paired index. Therefore, we do not need to go through all combinations when k < nums1.length + num2.length. Time complexity is O(k*m) where m is the length of the shorter array.\\n\\n\\n```\\npublic List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> ret = new ArrayList<int[]>();\\n        if (nums1.length == 0 || nums2.length == 0 || k == 0) {\\n            return ret;\\n        }\\n        \\n        int[] index = new int[nums1.length];\\n        while (k-- > 0) {\\n            int min_val = Integer.MAX_VALUE;\\n            int in = -1;\\n            for (int i = 0; i < nums1.length; i++) {\\n                if (index[i] >= nums2.length) {\\n                    continue;\\n                }\\n                if (nums1[i] + nums2[index[i]] < min_val) {\\n                    min_val = nums1[i] + nums2[index[i]];\\n                    in = i;\\n                }\\n            }\\n            if (in == -1) {\\n                break;\\n            }\\n            int[] temp = {nums1[in], nums2[index[in]]};\\n            ret.add(temp);\\n            index[in]++;\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> ret = new ArrayList<int[]>();\\n        if (nums1.length == 0 || nums2.length == 0 || k == 0) {\\n            return ret;\\n        }\\n        \\n        int[] index = new int[nums1.length];\\n        while (k-- > 0) {\\n            int min_val = Integer.MAX_VALUE;\\n            int in = -1;\\n            for (int i = 0; i < nums1.length; i++) {\\n                if (index[i] >= nums2.length) {\\n                    continue;\\n                }\\n                if (nums1[i] + nums2[index[i]] < min_val) {\\n                    min_val = nums1[i] + nums2[index[i]];\\n                    in = i;\\n                }\\n            }\\n            if (in == -1) {\\n                break;\\n            }\\n            int[] temp = {nums1[in], nums2[index[in]]};\\n            ret.add(temp);\\n            index[in]++;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 421316,
                "title": "python-bfs-beating-97-52-ms",
                "content": "Use BFS with heap. In each iteration, we get the pair with minimal sum and then push its neighboring right and bottom (if exists) into the heap. Repeat `k` or at most `m*n` times of such iterations. Time complexity `O(k lg k)`. Space complexity `O(k)` for the heap.\\n\\n```\\n\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        res = []\\n        from heapq import heappush, heappop\\n        m, n, visited = len(nums1), len(nums2), set()\\n        if m == 0 or n == 0: return [] \\n        h = [(nums1[0]+nums2[0], (0, 0))]\\n        for _ in range(min(k, (m*n))):\\n            val, (i, j) = heappop(h)\\n            res.append([nums1[i], nums2[j]])\\n            if i+1 < m and (i+1, j) not in visited:\\n                heappush(h, (nums1[i+1]+nums2[j], (i+1, j)))\\n                visited.add((i+1, j))\\n            if j+1 < n and (i, j+1) not in visited:\\n                heappush(h, (nums1[i]+nums2[j+1], (i, j+1)))\\n                visited.add((i, j+1))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        res = []\\n        from heapq import heappush, heappop\\n        m, n, visited = len(nums1), len(nums2), set()\\n        if m == 0 or n == 0: return [] \\n        h = [(nums1[0]+nums2[0], (0, 0))]\\n        for _ in range(min(k, (m*n))):\\n            val, (i, j) = heappop(h)\\n            res.append([nums1[i], nums2[j]])\\n            if i+1 < m and (i+1, j) not in visited:\\n                heappush(h, (nums1[i+1]+nums2[j], (i+1, j)))\\n                visited.add((i+1, j))\\n            if j+1 < n and (i, j+1) not in visited:\\n                heappush(h, (nums1[i]+nums2[j+1], (i, j+1)))\\n                visited.add((i, j+1))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3687087,
                "title": "c-heap-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->When approaching this problem, my initial thoughts would be to consider the following steps:\\n\\n1. Start by initializing an empty vector to store the k smallest pairs.\\n2. Iterate through each element in `nums1` and `nums2`, combining them to form pairs and calculating their sums.\\n3. Keep track of the k smallest pairs encountered so far.\\n4. To efficiently keep track of the k smallest pairs, we can use a priority queue (min-heap) with a size limit of k. This way, we can always maintain the k smallest pairs at the top of the queue.\\n5. As we iterate through the pairs, add them to the priority queue. If the size of the queue exceeds k, remove the largest pair to maintain the size limit.\\n6. Once we finish iterating through all pairs, the k smallest pairs will be present in the priority queue.\\n7. Retrieve the pairs from the priority queue and store them in the result vector.\\n8. Finally, return the result vector containing the k smallest pairs.\\n\\nBy utilizing a priority queue to track the k smallest pairs, we can efficiently solve the problem while avoiding the need for sorting the entire list of pairs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve the problem of finding the k smallest pairs from two input vectors, here is the approach taken in the provided program:\\n\\n1. Initialize an empty answer vector, `ans`, to store the k smallest pairs.\\n2. Create a priority queue, `pq`, with elements as pairs. Each pair consists of the sum of two elements and the corresponding pair of values from `nums1` and `nums2`. The priority queue is implemented as a max-heap.\\n3. Iterate over each element in `nums1` using a loop.\\n4. For each element in `nums1`, iterate over each element in `nums2` using a nested loop.\\n5. Calculate the sum of the current pair of elements from `nums1` and `nums2`.\\n6. If the size of the priority queue, `pq`, is less than k, add the current pair to the queue.\\n7. If the sum of the current pair is smaller than the largest sum in the priority queue, remove the largest sum from the queue and add the current pair to maintain the k smallest pairs.\\n8. If the sum of the current pair is greater than the largest sum in the priority queue, break the inner loop since the sums will only increase from this point onwards.\\n9. After processing all combinations of pairs, retrieve the k smallest pairs from the priority queue, `pq`, and store them in the answer vector, `ans`.\\n10. Return the answer vector, `ans`, as the result.\\n\\nThe program utilizes the priority queue to keep track of the k smallest pairs efficiently. By iterating through the pairs and comparing the sums, it ensures that only the k smallest pairs are retained in the priority queue, resulting in the desired output.\\n\\n# Complexity\\n- Time complexity: O(N1 * N2 * log k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\nvector<vector<int>> ans;\\npriority_queue<pair<int, pair<int, int>>> pq; // max-heap to store the k smallest pairs\\n    for (int i = 0; i < nums1.size(); i++) {\\n        for (int j = 0; j < nums2.size(); j++) {\\n            int sum = nums1[i] + nums2[j];\\n\\n            // If the priority queue size is less than k, add the pair\\n            if (pq.size() < k)\\n                pq.push({sum, {nums1[i], nums2[j]}});\\n            else if (sum < pq.top().first) {\\n                // If the current sum is smaller than the largest sum in the priority queue,\\n                // remove the largest sum and add the current sum\\n                pq.pop();\\n                pq.push({sum, {nums1[i], nums2[j]}});\\n            } else if (sum > pq.top().first) {\\n                // If the current sum is larger than the largest sum in the priority queue,\\n                // break the inner loop since sums will only increase from this point onwards\\n                break;\\n            }\\n        }\\n    }\\n\\n    // Retrieve the k smallest pairs from the priority queue and store them in the answer vector\\n    while (!pq.empty()) {\\n        ans.push_back({pq.top().second.first, pq.top().second.second});\\n        pq.pop();\\n    }\\n\\n    return ans;\\n}\\n};\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/ae99217b-e43b-4541-a560-c8da197dde66_1687833200.634842.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\nvector<vector<int>> ans;\\npriority_queue<pair<int, pair<int, int>>> pq; // max-heap to store the k smallest pairs\\n    for (int i = 0; i < nums1.size(); i++) {\\n        for (int j = 0; j < nums2.size(); j++) {\\n            int sum = nums1[i] + nums2[j];\\n\\n            // If the priority queue size is less than k, add the pair\\n            if (pq.size() < k)\\n                pq.push({sum, {nums1[i], nums2[j]}});\\n            else if (sum < pq.top().first) {\\n                // If the current sum is smaller than the largest sum in the priority queue,\\n                // remove the largest sum and add the current sum\\n                pq.pop();\\n                pq.push({sum, {nums1[i], nums2[j]}});\\n            } else if (sum > pq.top().first) {\\n                // If the current sum is larger than the largest sum in the priority queue,\\n                // break the inner loop since sums will only increase from this point onwards\\n                break;\\n            }\\n        }\\n    }\\n\\n    // Retrieve the k smallest pairs from the priority queue and store them in the answer vector\\n    while (!pq.empty()) {\\n        ans.push_back({pq.top().second.first, pq.top().second.second});\\n        pq.pop();\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502531,
                "title": "java-priorityqueue-with-intuition-easy-to-understand",
                "content": "**Intuition:**\\n- Store the smallest `k` pair of elements in a `minHeap` and then poll it out and store the same in the final result. \\n- Intuitively we can think of **O(k^2 log k)** solution, which will be to store each combination of `k` elements of `nums1` and `k` elements of `nums2` in the `minHeap` and then poll first `k` elements from the `minHeap` and add in the final result.\\n- We can do better than that. We can store combinations of `k` elements from `nums1` and `nums2[0]` (the first element of nums2) in *O(k log k)* time. (We could have done the other way as well, storing `nums1[0]` and all `nums2` combination, but the overall time complexity will still be the same).\\n- Now we poll out each element from the `minHeap` and at the same time we add the **pair of the next nums2[] element and the curr polled element of `nums1`** in the `minHeap` until we get `k` elements OR the `minHeap` is empty. \\n- For getting the next `nums2` element we can store the curr index of `nums2` in the `minHeap` when we are storing the `nums1` and `nums2` pair.\\n- This step will again take *O(k log k)* time. Hence our overall time complexity reduces to *O(2\\\\*(k log k))* which is effectively **O(k log k)**.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        \\n\\t\\t//In the minHeap array, 0th element refers to the curr element in nums1 and 1st element refers to curr element in nums2 \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b) -> (a[0] + a[1]) - (b[0] + b[1]));\\n        \\n\\t\\t// The 2nd element in the minHeap is the index of nums2, the corresponding element of nums2 is in index1 of minHeap\\n        for(int i=0; i < nums1.length && i < k; i++)\\n            minHeap.add(new int[]{nums1[i], nums2[0], 0});\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        for(int i=0; i < k && !minHeap.isEmpty(); i++){\\n            int[] curr = minHeap.poll();\\n            result.add(List.of(curr[0], curr[1]));\\n            int nums2Idx = curr[2];\\n            if(nums2Idx < nums2.length - 1)\\n                minHeap.add(new int[]{curr[0], nums2[nums2Idx + 1], nums2Idx + 1});\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        \\n\\t\\t//In the minHeap array, 0th element refers to the curr element in nums1 and 1st element refers to curr element in nums2 \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b) -> (a[0] + a[1]) - (b[0] + b[1]));\\n        \\n\\t\\t// The 2nd element in the minHeap is the index of nums2, the corresponding element of nums2 is in index1 of minHeap\\n        for(int i=0; i < nums1.length && i < k; i++)\\n            minHeap.add(new int[]{nums1[i], nums2[0], 0});\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        for(int i=0; i < k && !minHeap.isEmpty(); i++){\\n            int[] curr = minHeap.poll();\\n            result.add(List.of(curr[0], curr[1]));\\n            int nums2Idx = curr[2];\\n            if(nums2Idx < nums2.length - 1)\\n                minHeap.add(new int[]{curr[0], nums2[nums2Idx + 1], nums2Idx + 1});\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612792,
                "title": "klogk-c-code-with-explanation-commments",
                "content": "\\n\\n\\n**Pro Tip:- insert -ve sum to use max Heap as min Heap**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ans;\\n        int n=nums1.size(),m=nums2.size();\\n        if(n==0||m==0) return (ans);\\n        priority_queue<tuple<int,int, int>> pq;\\n        pq.push({-nums1[0]-nums2[0],0,0});   // insert initial pair in priority queue\\n        while(pq.size()&&ans.size()<k)       // pq.size() is necessary coz k can be larger than m*n\\n        {\\n            auto topp=pq.top();                // extracting smallest element from pq\\n            int i=get<1>(topp);\\n            int j=get<2>(topp);\\n            pq.pop();\\n            ans.push_back({nums1[i],nums2[j]});   // insert smallest pair in ans vector\\n            if(j==0&&i+1<n) pq.push({-nums1[i+1]-nums2[j],i+1,j});   // very important part in whole solN \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://leetcode.com/problems/find-k-pairs-with-smallest-sums/discuss/84551/simple-Java-O(KlogK)-solution-with-explanation\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Nicely shown with diagrams in this post\\t\\t\\t\\n\\t\\t\\t\\n            if(i<n&&j+1<m) pq.push({-nums1[i]-nums2[j+1],i,j+1});\\n        }\\n        return (ans);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ans;\\n        int n=nums1.size(),m=nums2.size();\\n        if(n==0||m==0) return (ans);\\n        priority_queue<tuple<int,int, int>> pq;\\n        pq.push({-nums1[0]-nums2[0],0,0});   // insert initial pair in priority queue\\n        while(pq.size()&&ans.size()<k)       // pq.size() is necessary coz k can be larger than m*n\\n        {\\n            auto topp=pq.top();                // extracting smallest element from pq\\n            int i=get<1>(topp);\\n            int j=get<2>(topp);\\n            pq.pop();\\n            ans.push_back({nums1[i],nums2[j]});   // insert smallest pair in ans vector\\n            if(j==0&&i+1<n) pq.push({-nums1[i+1]-nums2[j],i+1,j});   // very important part in whole solN \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://leetcode.com/problems/find-k-pairs-with-smallest-sums/discuss/84551/simple-Java-O(KlogK)-solution-with-explanation\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Nicely shown with diagrams in this post\\t\\t\\t\\n\\t\\t\\t\\n            if(i<n&&j+1<m) pq.push({-nums1[i]-nums2[j+1],i,j+1});\\n        }\\n        return (ans);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945108,
                "title": "c-easy-to-understand-beginner-friendly",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>ans;\\n        priority_queue<pair<int,pair<int,int>>>pq;\\n\\n\\n\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                int sum=nums1[i]+nums2[j];\\n                \\n                if(pq.size()<k) pq.push({sum,{nums1[i],nums2[j]}});\\n\\n                else if(sum<pq.top().first){\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        while(!pq.empty()){\\n            \\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n//If it helps plzz don\\'t forget to UpVote it :)\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>ans;\\n        priority_queue<pair<int,pair<int,int>>>pq;\\n\\n\\n\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                int sum=nums1[i]+nums2[j];\\n                \\n                if(pq.size()<k) pq.push({sum,{nums1[i],nums2[j]}});\\n\\n                else if(sum<pq.top().first){\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        while(!pq.empty()){\\n            \\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\n//If it helps plzz don\\'t forget to UpVote it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155676,
                "title": "python-heapq-solution-beats-96",
                "content": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        if not nums1 or not nums2: return []\\n        n, res, cnt, heap = len(nums2), [], 0, [(nums1[i] + nums2[0], i, 0) for i in range(len(nums1))]\\n        while heap and cnt < k:\\n            cnt += 1\\n            sm, i, j = heapq.heappop(heap)\\n            res.append([nums1[i], nums2[j]])\\n            if j + 1 < n: heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        if not nums1 or not nums2: return []\\n        n, res, cnt, heap = len(nums2), [], 0, [(nums1[i] + nums2[0], i, 0) for i in range(len(nums1))]\\n        while heap and cnt < k:\\n            cnt += 1\\n            sm, i, j = heapq.heappop(heap)\\n            res.append([nums1[i], nums2[j]])\\n            if j + 1 < n: heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84642,
                "title": "9-lines-in-python",
                "content": "```\\nclass Solution(object):\\n    def kSmallestPairs(self, nums1, nums2, k, heap=[]):\\n        for n1 in nums1:\\n            for n2 in nums2:\\n                if len(heap) < k: heapq.heappush(heap, (-n1-n2, [n1, n2]))\\n                else:\\n                    if heap and -heap[0][0] > n1 + n2:\\n                        heapq.heappop(heap)\\n                        heapq.heappush(heap, (-n1-n2, [n1, n2]))\\n                    else: break\\n        return [heapq.heappop(heap)[1] for _ in range(k) if heap]\\n\\n        # 27 / 27 test cases passed.\\n\\t# Status: Accepted\\n        # Runtime: 112 ms\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kSmallestPairs(self, nums1, nums2, k, heap=[]):\\n        for n1 in nums1:\\n            for n2 in nums2:\\n                if len(heap) < k: heapq.heappush(heap, (-n1-n2, [n1, n2]))\\n                else:\\n                    if heap and -heap[0][0] > n1 + n2:\\n                        heapq.heappop(heap)\\n                        heapq.heappush(heap, (-n1-n2, [n1, n2]))\\n                    else: break\\n        return [heapq.heappop(heap)[1] for _ in range(k) if heap]\\n\\n        # 27 / 27 test cases passed.\\n\\t# Status: Accepted\\n        # Runtime: 112 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426280,
                "title": "two-c-solutions-bruteforce-optimised",
                "content": "**1. Brute Force** -> ```O(m*n log(m*n))``` where ```m``` and ```n``` are size of ```nums1``` and ```nums2```  \\n\\n```\\n\\ttypedef pair<int, pair<int, int>> pi;\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pi> pq;\\n        vector<vector<int>> ans;\\n          \\n        for(int i=0; i<nums1.size(); i++){\\n            for(int j=0; j<nums2.size(); j++){\\n                pq.push({nums1[i]+nums2[j], {nums1[i], nums2[j]}});\\n                if(pq.size() > k){\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!pq.empty()){\\n            vector<int> temp = {pq.top().second.first, pq.top().second.second};\\n            ans.push_back(temp);\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n**2. Optimised** -> ```O(n logn)``` assuming ```k<=n```\\n\\nUsing -> Min heap, Map \\nInstead of brute forcing through all the possible sum combinations we should find a way to limit our search space to possible candidate sum combinations.  \\n\\n1. Sort both arrays array A and array B(Not needed as already given sorted).\\n2. Create a min heap i.e priority_queue in C++ to store the sum combinations along with the indices of elements from both arrays A and B which make up the sum. Heap is ordered by the sum.\\n3. Initialize the heap with the minimum possible sum combination i.e (A[0] + B[0]) and with the indices of elements from both arrays (0, 0). The tuple inside min heap will be (A[0] + B[0], 0, 0). Heap is ordered by first value i.e sum of both elements.\\n4. Pop the heap to get the current smallest sum and along with the indices of the element that make up the sum. Let the tuple be (sum, i, j). \\n* Next insert (A[i + 1] + B[j], i + 1, j) and (A[i] + B[j + 1], i, j + 1) into the min heap but make sure that the pair of indices i.e (i + 1, j) and (i, j + 1) are not already present in the min heap.To check this we can use set in C++.\\n* Go back to 4 until K times.\\n\\n```\\ntypedef pair<int, pair<int, int>> pii;\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\\n        vector<vector<int>> ans;\\n        set<pair<int, int>> myset;\\n        \\n        pq.push({nums1[0]+nums2[0], {0, 0}});\\n        myset.insert({0,0});\\n        \\n        int flag = 1;\\n        for(int cnt=0; cnt<k and flag; cnt++){\\n\\n            pii temp = pq.top();    pq.pop();\\n            \\n            int i = temp.second.first;\\n            int j = temp.second.second;\\n\\n            ans.push_back({nums1[i], nums2[j]});\\n            \\n            flag = 0;\\n            if(i+1 < nums1.size()){\\n                int sum = nums1[i+1] + nums2[j];\\n                \\n                pair<int, int> tempPair = {i+1, j};\\n                if(myset.find(tempPair) == myset.end()){\\n                    pq.push({sum, tempPair});\\n                    myset.insert({tempPair});\\n                }\\n                flag = 1;\\n            }\\n            \\n            if(j+1 < nums2.size()){\\n                int sum = nums1[i] + nums2[j+1];\\n                pair<int, int> tempPair = {i, j+1};\\n                if(myset.find(tempPair) == myset.end()){\\n                    pq.push({sum, tempPair});\\n                    myset.insert({tempPair});\\n                }\\n                flag = 1;\\n            }\\n            \\n        }\\n                \\n        return ans;\\n    }\\n```\\n\\n**Please UPVOTE if you find it helpful.**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```O(m*n log(m*n))```\n```m```\n```n```\n```nums1```\n```nums2```\n```\\n\\ttypedef pair<int, pair<int, int>> pi;\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pi> pq;\\n        vector<vector<int>> ans;\\n          \\n        for(int i=0; i<nums1.size(); i++){\\n            for(int j=0; j<nums2.size(); j++){\\n                pq.push({nums1[i]+nums2[j], {nums1[i], nums2[j]}});\\n                if(pq.size() > k){\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!pq.empty()){\\n            vector<int> temp = {pq.top().second.first, pq.top().second.second};\\n            ans.push_back(temp);\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n```\n```O(n logn)```\n```k<=n```\n```\\ntypedef pair<int, pair<int, int>> pii;\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\\n        vector<vector<int>> ans;\\n        set<pair<int, int>> myset;\\n        \\n        pq.push({nums1[0]+nums2[0], {0, 0}});\\n        myset.insert({0,0});\\n        \\n        int flag = 1;\\n        for(int cnt=0; cnt<k and flag; cnt++){\\n\\n            pii temp = pq.top();    pq.pop();\\n            \\n            int i = temp.second.first;\\n            int j = temp.second.second;\\n\\n            ans.push_back({nums1[i], nums2[j]});\\n            \\n            flag = 0;\\n            if(i+1 < nums1.size()){\\n                int sum = nums1[i+1] + nums2[j];\\n                \\n                pair<int, int> tempPair = {i+1, j};\\n                if(myset.find(tempPair) == myset.end()){\\n                    pq.push({sum, tempPair});\\n                    myset.insert({tempPair});\\n                }\\n                flag = 1;\\n            }\\n            \\n            if(j+1 < nums2.size()){\\n                int sum = nums1[i] + nums2[j+1];\\n                pair<int, int> tempPair = {i, j+1};\\n                if(myset.find(tempPair) == myset.end()){\\n                    pq.push({sum, tempPair});\\n                    myset.insert({tempPair});\\n                }\\n                flag = 1;\\n            }\\n            \\n        }\\n                \\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1235006,
                "title": "java-clean-concise-optimal-code-min-heap-data-structure-2ms-time-100-faster-soln",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        \\n        List<List<Integer>> pairs = new ArrayList<> ();\\n        if (nums1.length == 0 || nums2.length == 0 || k == 0) {\\n            return pairs;\\n        }\\n        \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<> ((arr1, arr2) -> arr1[0] + arr1[1] - arr2[0] - arr2[1]);\\n        \\n        for (int i = 0; i < nums1.length && i < k; i++) {\\n            minHeap.offer (new int[] {nums1[i], nums2[0], 0});\\n        }\\n        \\n        while (k-- != 0 && !minHeap.isEmpty ()) {\\n            int[] curr = minHeap.poll ();\\n            pairs.add (List.of (curr[0], curr[1]));\\n            if (curr[2] + 1 < nums2.length) {\\n                minHeap.offer (new int[] {curr[0], nums2[curr[2] + 1], curr[2] + 1});\\n            }\\n        }\\n        \\n        return pairs;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        \\n        List<List<Integer>> pairs = new ArrayList<> ();\\n        if (nums1.length == 0 || nums2.length == 0 || k == 0) {\\n            return pairs;\\n        }\\n        \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<> ((arr1, arr2) -> arr1[0] + arr1[1] - arr2[0] - arr2[1]);\\n        \\n        for (int i = 0; i < nums1.length && i < k; i++) {\\n            minHeap.offer (new int[] {nums1[i], nums2[0], 0});\\n        }\\n        \\n        while (k-- != 0 && !minHeap.isEmpty ()) {\\n            int[] curr = minHeap.poll ();\\n            pairs.add (List.of (curr[0], curr[1]));\\n            if (curr[2] + 1 < nums2.length) {\\n                minHeap.offer (new int[] {curr[0], nums2[curr[2] + 1], curr[2] + 1});\\n            }\\n        }\\n        \\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701122,
                "title": "python-simple-heap-solution-explained",
                "content": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        hq = []\\n        heapq.heapify(hq)\\n        \\n        # add all the pairs that we can form with\\n        # all the (first k) items in nums1 with the first\\n        # item in nums2\\n        for i in range(min(len(nums1), k)):\\n            heapq.heappush(hq, (nums1[i]+nums2[0], nums1[i], nums2[0], 0))\\n\\n        # since the smallest pair will\\n        # be the first element from both nums1 and nums2. We\\'ll\\n        # start with that and then subsequently, we\\'ll pop it out\\n        # from the heap and also insert the pair of the current\\n        # element from nums1 with the next nums2 element\\n        out = []\\n        while k > 0 and hq:\\n            _, n1, n2, idx = heapq.heappop(hq)\\n            out.append((n1, n2))\\n            if idx + 1 < len(nums2):\\n                # the heap will ensure that the smallest element\\n                # based on the sum will remain on top and the\\n                # next iteration will give us the pair we require\\n                heapq.heappush(hq, (n1+nums2[idx+1], n1, nums2[idx+1], idx+1))\\n            k -= 1\\n                \\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        hq = []\\n        heapq.heapify(hq)\\n        \\n        # add all the pairs that we can form with\\n        # all the (first k) items in nums1 with the first\\n        # item in nums2\\n        for i in range(min(len(nums1), k)):\\n            heapq.heappush(hq, (nums1[i]+nums2[0], nums1[i], nums2[0], 0))\\n\\n        # since the smallest pair will\\n        # be the first element from both nums1 and nums2. We\\'ll\\n        # start with that and then subsequently, we\\'ll pop it out\\n        # from the heap and also insert the pair of the current\\n        # element from nums1 with the next nums2 element\\n        out = []\\n        while k > 0 and hq:\\n            _, n1, n2, idx = heapq.heappop(hq)\\n            out.append((n1, n2))\\n            if idx + 1 < len(nums2):\\n                # the heap will ensure that the smallest element\\n                # based on the sum will remain on top and the\\n                # next iteration will give us the pair we require\\n                heapq.heappush(hq, (n1+nums2[idx+1], n1, nums2[idx+1], idx+1))\\n            k -= 1\\n                \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84583,
                "title": "three-different-solutions-in-c-well-explained",
                "content": "### Solutions\\n\\n#### Priority_queue\\nIntuitively we can use priority_queue to sort the pair and collect the top k in the min heap. Time complexity will be O(nlogn) and space O(n) where n is the multiple of size1 and size2.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        vector<pair<int, int>> v;\\n        if(nums1.empty() || nums2.empty()) return v;\\n        auto cmp = [](const pair<int, int>& a, const pair<int, int>& b) {\\n            return a.first+a.second > b.first+b.second; };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> minHeap(cmp);\\n        for(auto n: nums1)\\n            for(auto m: nums2)\\n                minHeap.emplace(n, m);\\n        while(minHeap.size() && k--)\\n        {\\n            v.emplace_back(minHeap.top());\\n            minHeap.pop();\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n#### Index array\\nActually we can index the array via comparison referring to [Super Ugly Number](https://leetcode.com/problems/super-ugly-number/) and easily we collect the pairs from the sum of the smallest to the biggest.\\n\\nTime complexity will be O(km) and space cost O(n) where n and m are the sizes of the arrays respectively.\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        vector<pair<int, int>> v;\\n        if(nums1.empty() || nums2.empty()) return v;\\n        int indexes[nums1.size()]{0};\\n        int size = min(k, int(nums1.size()*nums2.size()));\\n        while(size)\\n        {\\n            int t = INT_MAX;\\n            for(int i = 0; i < nums1.size(); ++i)\\n            {\\n                if(indexes[i] == nums2.size()) continue;\\n                t = min(t, nums1[i]+nums2[indexes[i]]);\\n            }\\n            for(int i = 0; i < nums1.size(); ++i)\\n            {\\n                if(indexes[i]<nums2.size() && nums1[i]+nums2[indexes[i]]==t)\\n                    v.emplace_back(nums1[i], nums2[indexes[i]++]), size--;\\n                if(!size) return v;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n#### Combination\\nInspired by the index-array solution, we can further optimize the priority_queue solution where we only insert the next potential smallest one each time avoid inserting all the pairs at the first time. Time complexity now would be O(klogm) where k is from the problem while m is the size of the second array.\\n\\n> **Analysis for validity** If the current smallest pair is (i, j), then next potential smallest pair should be (i+1, j) or (i, j+1). But to ensure each pair will be covered, we can insert the next column index into the minimal heap only when the row index is 0. Minimal heap is where all the potential smallest pairs are stored. P.S. To ease the problem, you can put each index pair as each cell of a matrix composed of the index of the two arrays.\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        vector<pair<int,int>> v;\\n        if(nums1.empty() || nums2.empty()) return v;\\n        auto cmp = [&nums1, &nums2](const pair<int, int>& a, const pair<int, int>&b) {\\n            return nums1[a.first]+nums2[a.second] > nums1[b.first]+nums2[b.second]; };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> minHeap(cmp);\\n        minHeap.emplace(0, 0);\\n        while(minHeap.size() && k--)\\n        {\\n            auto t = minHeap.top(); minHeap.pop();\\n            v.emplace_back(nums1[t.first], nums2[t.second]);\\n            if(t.first<nums1.size()-1) minHeap.emplace(t.first+1, t.second);\\n            if(t.first==0 && t.second<nums2.size()-1) minHeap.emplace(t.first, t.second+1);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        vector<pair<int, int>> v;\\n        if(nums1.empty() || nums2.empty()) return v;\\n        auto cmp = [](const pair<int, int>& a, const pair<int, int>& b) {\\n            return a.first+a.second > b.first+b.second; };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> minHeap(cmp);\\n        for(auto n: nums1)\\n            for(auto m: nums2)\\n                minHeap.emplace(n, m);\\n        while(minHeap.size() && k--)\\n        {\\n            v.emplace_back(minHeap.top());\\n            minHeap.pop();\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        vector<pair<int, int>> v;\\n        if(nums1.empty() || nums2.empty()) return v;\\n        int indexes[nums1.size()]{0};\\n        int size = min(k, int(nums1.size()*nums2.size()));\\n        while(size)\\n        {\\n            int t = INT_MAX;\\n            for(int i = 0; i < nums1.size(); ++i)\\n            {\\n                if(indexes[i] == nums2.size()) continue;\\n                t = min(t, nums1[i]+nums2[indexes[i]]);\\n            }\\n            for(int i = 0; i < nums1.size(); ++i)\\n            {\\n                if(indexes[i]<nums2.size() && nums1[i]+nums2[indexes[i]]==t)\\n                    v.emplace_back(nums1[i], nums2[indexes[i]++]), size--;\\n                if(!size) return v;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        vector<pair<int,int>> v;\\n        if(nums1.empty() || nums2.empty()) return v;\\n        auto cmp = [&nums1, &nums2](const pair<int, int>& a, const pair<int, int>&b) {\\n            return nums1[a.first]+nums2[a.second] > nums1[b.first]+nums2[b.second]; };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> minHeap(cmp);\\n        minHeap.emplace(0, 0);\\n        while(minHeap.size() && k--)\\n        {\\n            auto t = minHeap.top(); minHeap.pop();\\n            v.emplace_back(nums1[t.first], nums2[t.second]);\\n            if(t.first<nums1.size()-1) minHeap.emplace(t.first+1, t.second);\\n            if(t.first==0 && t.second<nums2.size()-1) minHeap.emplace(t.first, t.second+1);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371356,
                "title": "c-minheap-solution-o-k-log-n",
                "content": "Runtime: 88 ms, faster than 32.84% of C++ online submissions for Find K Pairs with Smallest Sums.\\nMemory Usage: 65.5 MB, less than 11.21% of C++ online submissions for Find K Pairs with Smallest Sums.\\n\\n```\\nHere we have to find K pair of numbers whose sum is the minimum from given 2 sorted array. Observation\\nis that if we want K pairs of numbers with minimum sum from 2 sorted array the minimum K sums will\\nalways be in the K * K combination of 2 sorted array numbers. We can use MinHeap priority queue to store\\nthe minimum sums, first we add all sums from nums1[0] to nums1[min(n1,K)] with nums2[0], and also index 0\\nwhich is the index X of nums2 and the nums1 item to the MinHeap. Each time we get the minimum sum the\\nnext min sum can be nums1 item + nums2[X+1] and so we push it to MinHeap.  \\n\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        vector<vector<int>>res; // result vector\\n        \\n        // MinHeap to store min sums\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pQ;\\n        \\n        // push all nums1[0] to nums1[min(n1,k)] sum with nums2[0]\\n        // Min Heap tuple is <sum,nums1 item, nums2 index taken>\\n        for(int i=0;i<n1 && i<k;i++)pQ.push({nums1[i]+nums2[0],nums1[i],0});\\n        \\n        // Run loop k times or queue is empty\\n        while(k-- && !pQ.empty())\\n        {\\n            auto t = pQ.top();  // get min sum tuple\\n            pQ.pop();\\n            res.push_back({t[1],nums2[t[2]]});  // push it to result\\n            \\n            if(t[2]==n2-1)continue; // nums2 index already at the max range\\n            \\n            // if current tuple nums1 item + nums2[nums2 index] gives a min sum\\n            // then the next min sum can be nums1 item + nums2 [nums2 index +1]\\n            // as we already added K nums1 items in the Min Heap\\n            pQ.push({t[1]+nums2[t[2]+1],t[1],t[2]+1});  \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nHere we have to find K pair of numbers whose sum is the minimum from given 2 sorted array. Observation\\nis that if we want K pairs of numbers with minimum sum from 2 sorted array the minimum K sums will\\nalways be in the K * K combination of 2 sorted array numbers. We can use MinHeap priority queue to store\\nthe minimum sums, first we add all sums from nums1[0] to nums1[min(n1,K)] with nums2[0], and also index 0\\nwhich is the index X of nums2 and the nums1 item to the MinHeap. Each time we get the minimum sum the\\nnext min sum can be nums1 item + nums2[X+1] and so we push it to MinHeap.  \\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        vector<vector<int>>res; // result vector\\n        \\n        // MinHeap to store min sums\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pQ;\\n        \\n        // push all nums1[0] to nums1[min(n1,k)] sum with nums2[0]\\n        // Min Heap tuple is <sum,nums1 item, nums2 index taken>\\n        for(int i=0;i<n1 && i<k;i++)pQ.push({nums1[i]+nums2[0],nums1[i],0});\\n        \\n        // Run loop k times or queue is empty\\n        while(k-- && !pQ.empty())\\n        {\\n            auto t = pQ.top();  // get min sum tuple\\n            pQ.pop();\\n            res.push_back({t[1],nums2[t[2]]});  // push it to result\\n            \\n            if(t[2]==n2-1)continue; // nums2 index already at the max range\\n            \\n            // if current tuple nums1 item + nums2[nums2 index] gives a min sum\\n            // then the next min sum can be nums1 item + nums2 [nums2 index +1]\\n            // as we already added K nums1 items in the Min Heap\\n            pQ.push({t[1]+nums2[t[2]+1],t[1],t[2]+1});  \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408879,
                "title": "python-minheap-o-klogk-clean-concise",
                "content": "```python\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        minHeap = []\\n        for i in range(min(len(nums1), k)):\\n            # tuple of (sum of nums1[i] + nums2[0], nums1[i], nums2[0], index of nums2 start = 0)\\n            heappush(minHeap, (nums1[i] + nums2[0], nums1[i], nums2[0], 0))\\n\\n        ans = []\\n        while k > 0 and minHeap:\\n            _, u, v, i = heappop(minHeap)\\n            ans.append([u, v])\\n            if i + 1 < len(nums2):\\n                newSum = u + nums2[i + 1]\\n                heappush(minHeap, (newSum, u, nums2[i + 1], i + 1))\\n            k -= 1\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(KlogK)`, where `K <= 1000`\\n- Space: `O(K)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        minHeap = []\\n        for i in range(min(len(nums1), k)):\\n            # tuple of (sum of nums1[i] + nums2[0], nums1[i], nums2[0], index of nums2 start = 0)\\n            heappush(minHeap, (nums1[i] + nums2[0], nums1[i], nums2[0], 0))\\n\\n        ans = []\\n        while k > 0 and minHeap:\\n            _, u, v, i = heappop(minHeap)\\n            ans.append([u, v])\\n            if i + 1 < len(nums2):\\n                newSum = u + nums2[i + 1]\\n                heappush(minHeap, (newSum, u, nums2[i + 1], i + 1))\\n            k -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010012,
                "title": "python-solution-with-thinking-process",
                "content": "[373. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/discuss/1010012/Python-solution-with-thinking-process)\\n[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1004232/Python-solution-with-thinking-process)\\nheap: list of tuple (nums1[i] + nums2[j], i, j), which is initialized with j = 0 and i = 0, 1, ..., len(nums1) - 1.\\nWe maintain a heap. In the while loop, we pop the smallest element (nums1[i] + nums2[j], i, j) from the heap, and push (nums1[i] + nums2[j+1], i, j+1) to the heap if it exists.\\n```\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        l1, l2 = len(nums1), len(nums2)\\n        if not nums1 or not nums2:\\n            return []\\n        heap = [(nums1[i] + nums2[0], i, 0) for i in range(l1)]\\n        heapq.heapify(heap)\\n        res = []\\n        while k > 0 and heap:\\n            s, i, j = heapq.heappop(heap)\\n            res.append([nums1[i], nums2[j]])\\n            if j + 1 < l2:\\n                heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j + 1))\\n            k -= 1\\n        return res\\n```\\nTime complexity O(n + k * log n), where n is len(nums1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        l1, l2 = len(nums1), len(nums2)\\n        if not nums1 or not nums2:\\n            return []\\n        heap = [(nums1[i] + nums2[0], i, 0) for i in range(l1)]\\n        heapq.heapify(heap)\\n        res = []\\n        while k > 0 and heap:\\n            s, i, j = heapq.heappop(heap)\\n            res.append([nums1[i], nums2[j]])\\n            if j + 1 < l2:\\n                heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j + 1))\\n            k -= 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 884449,
                "title": "thought-process-and-strategy",
                "content": "The below documents my thought process to arrive at the optimal solution.\\n\\nFirst, let\\'s start with a brute force solution that gets all possible pairs, sort it, and return the first `k` pairs. One can do so by putting all pairs in a list and sorting the list or by using priority queue. The following brute-force solution uses a priority queue.\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return (o1[1] + o1[0]) - (o2[1] + o2[0]);\\n            }\\n        });\\n        \\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                pq.add(new int[]{num1, num2});\\n            }\\n        }\\n        int size = pq.size();\\n        \\n        List<List<Integer>> ans = new ArrayList();\\n        for (int i = 0; i < Math.min(k, size); i++) {\\n            int[] pair = pq.remove();\\n            List<Integer> subsolution = new ArrayList();\\n            subsolution.add(pair[0]);\\n            subsolution.add(pair[1]);\\n            ans.add(subsolution);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nLet `N` be the length of `nums1` and `M` be the length of `nums2`. The time complexity is `~O(NM log(NM))` because we are effectively sorting an array of size `NM`. The space complexity is `~O(NM)` because there are `NM` number of possible pairs.\\n\\nWe can note that the brute force solution did not take advantage of the fact that the inputs are sorted. Therefore, let\\'s contemplate how we can use the sorted nature of the input to our advantage.\\n\\nOne observation is that, for each `num1` of `nums1`, the optimal `num2` in `nums2`, such that `num1+num2` is minimal, begins from index `0`. If the index for `num2` is exhausted for `num1`, we will have explored all pairs that begin with `num1`.\\n\\nFrom this observation, we can imagine a solution that keeps track of optimal `num2` indices for each `num1` in `nums1`:\\n\\n```python\\n# pseudocode\\noptimalIdx = [0,0,0,0,...,0]\\n\\nfor num1, idx1 of nums1:\\n\\n  minSum = INFINITY, minNum1Idx = -1\\n  for num2, idx2 of nums2:\\n    if optimalIdx[idx1] > len(optimalIdx) - 1:\\n\\t  continue\\n\\n    if num1+num2 < minSum:\\n\\t  minNum1Idx = idx1\\n\\n  ans.add([num1, num2])\\n  optimalidx[minNum1Idx]++\\n```\\n\\nThe above solution iterates through all `num1` and for each `num1`, iterates through all `num2` at the possible optimal indices to get the pair with a smallest sum containing `num1`. We can see that the nested loop makes the time complexity `~O(NM)` and is a bottleneck.\\n\\nHow can we solve the bottleneck? If the bottleneck lies in having to keep iterating to find maximum/minimum, we can try to use a priority queue abstract data type.\\n\\nUsing PriorityQueue, let us:\\n\\n* keep track of the next pair with the smallest sum \\n* add the next possible candidate to the priority queue, whenever we obtain a pair with the smallest sum.\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        List<List<Integer>> ans = new ArrayList();\\n        \\n        if (n == 0 || m == 0) {\\n            return ans;\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return (nums1[o1[0]] + nums2[o1[1]]) - (nums1[o2[0]] + nums2[o2[1]]);\\n            }\\n        });\\n        \\n\\t\\t// initialize with all pairs that begin with a number in `nums1` and the first number in `nums2`\\n        for (int i = 0; i < n; i++) {\\n            pq.add(new int[]{i, 0});\\n        }\\n\\n        int size = pq.size();\\n        \\n        for (int i = 0; i < Math.min(k, n*m); i++) {\\n            int[] pair = pq.remove();\\n            \\n            if (pair[1] < m - 1) {\\n                pq.add(new int[]{pair[0], pair[1]+1});\\n            }\\n            \\n            List<Integer> subsolution = new ArrayList();\\n            subsolution.add(nums1[pair[0]]);\\n            subsolution.add(nums2[pair[1]]);\\n            ans.add(subsolution);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nFor me, I could not proceed further. But upon reading some other solutions, we can realize that it is unnecessary to initialize the priority queue with all pairs that begin with a number in `nums1`. It suffices to put up to `k` pairs initially.\\n\\nWhy? The reason is that we keep adding new possible candidates upon obtaining the smalleset sum pair from the priority queue. Whether we initialize the priority queue with all possible pairs is immaterial because we will add those pairs as we wend our way through the algorithm. Therefore, we arrive at the following optimal solution.\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        List<List<Integer>> ans = new ArrayList();\\n        \\n        if (n == 0 || m == 0) {\\n            return ans;\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return (nums1[o1[0]] + nums2[o1[1]]) - (nums1[o2[0]] + nums2[o2[1]]);\\n            }\\n        });\\n        \\n        for (int i = 0; i < Math.min(k, n); i++) {\\n            pq.add(new int[]{i, 0});\\n        }\\n\\n        int size = pq.size();\\n        \\n        for (int i = 0; i < Math.min(k, n*m); i++) {\\n            int[] pair = pq.remove();\\n            \\n            if (pair[1] < m - 1) {\\n                pq.add(new int[]{pair[0], pair[1]+1});\\n            }\\n            \\n            List<Integer> subsolution = new ArrayList();\\n            subsolution.add(nums1[pair[0]]);\\n            subsolution.add(nums2[pair[1]]);\\n            ans.add(subsolution);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nTime complexity is `~O(k logk)` because the priority queue has up to `k` elements. For the same reason, the solution takes `~O(k)` space.",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return (o1[1] + o1[0]) - (o2[1] + o2[0]);\\n            }\\n        });\\n        \\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                pq.add(new int[]{num1, num2});\\n            }\\n        }\\n        int size = pq.size();\\n        \\n        List<List<Integer>> ans = new ArrayList();\\n        for (int i = 0; i < Math.min(k, size); i++) {\\n            int[] pair = pq.remove();\\n            List<Integer> subsolution = new ArrayList();\\n            subsolution.add(pair[0]);\\n            subsolution.add(pair[1]);\\n            ans.add(subsolution);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```python\\n# pseudocode\\noptimalIdx = [0,0,0,0,...,0]\\n\\nfor num1, idx1 of nums1:\\n\\n  minSum = INFINITY, minNum1Idx = -1\\n  for num2, idx2 of nums2:\\n    if optimalIdx[idx1] > len(optimalIdx) - 1:\\n\\t  continue\\n\\n    if num1+num2 < minSum:\\n\\t  minNum1Idx = idx1\\n\\n  ans.add([num1, num2])\\n  optimalidx[minNum1Idx]++\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        List<List<Integer>> ans = new ArrayList();\\n        \\n        if (n == 0 || m == 0) {\\n            return ans;\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return (nums1[o1[0]] + nums2[o1[1]]) - (nums1[o2[0]] + nums2[o2[1]]);\\n            }\\n        });\\n        \\n\\t\\t// initialize with all pairs that begin with a number in `nums1` and the first number in `nums2`\\n        for (int i = 0; i < n; i++) {\\n            pq.add(new int[]{i, 0});\\n        }\\n\\n        int size = pq.size();\\n        \\n        for (int i = 0; i < Math.min(k, n*m); i++) {\\n            int[] pair = pq.remove();\\n            \\n            if (pair[1] < m - 1) {\\n                pq.add(new int[]{pair[0], pair[1]+1});\\n            }\\n            \\n            List<Integer> subsolution = new ArrayList();\\n            subsolution.add(nums1[pair[0]]);\\n            subsolution.add(nums2[pair[1]]);\\n            ans.add(subsolution);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        List<List<Integer>> ans = new ArrayList();\\n        \\n        if (n == 0 || m == 0) {\\n            return ans;\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return (nums1[o1[0]] + nums2[o1[1]]) - (nums1[o2[0]] + nums2[o2[1]]);\\n            }\\n        });\\n        \\n        for (int i = 0; i < Math.min(k, n); i++) {\\n            pq.add(new int[]{i, 0});\\n        }\\n\\n        int size = pq.size();\\n        \\n        for (int i = 0; i < Math.min(k, n*m); i++) {\\n            int[] pair = pq.remove();\\n            \\n            if (pair[1] < m - 1) {\\n                pq.add(new int[]{pair[0], pair[1]+1});\\n            }\\n            \\n            List<Integer> subsolution = new ArrayList();\\n            subsolution.add(nums1[pair[0]]);\\n            subsolution.add(nums2[pair[1]]);\\n            ans.add(subsolution);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84633,
                "title": "java-easy-understandable-bfs-with-priorityqueue",
                "content": "use a matrix to represent all combination of pairs from nums1 and nums2. Do a bfs from [0][0]. However, use a PriorityQueue instead of regular queue.\\n```\\npublic class Solution {\\n    final int[][] neighbors = {{0, 1}, {1, 0}};\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> list = new ArrayList<>();\\n        if (nums1 == null || nums2 == null || nums1.length == 0 || nums2.length == 0 || k == 0) {\\n            return list;\\n        }\\n        int m = nums1.length, n = nums2.length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<Pair> minHeap = new PriorityQueue<>();\\n        minHeap.offer(new Pair(0, 0, nums1[0] + nums2[0]));\\n        visited[0][0] = true;\\n        while (k > 0 && !minHeap.isEmpty()) {\\n            Pair min = minHeap.poll();\\n            list.add(new int[] {nums1[min.row], nums2[min.col]});\\n            k--;\\n            for (int[] neighbor : neighbors) {\\n                int row1 = min.row + neighbor[0];\\n                int col1 = min.col + neighbor[1];\\n                if (row1 < 0 || row1 == m || col1 < 0 || col1 == n || visited[row1][col1]) {\\n                    continue;\\n                }\\n                visited[row1][col1] = true;\\n                minHeap.offer(new Pair(row1, col1, nums1[row1] + nums2[col1]));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair> {\\n    int row;\\n    int col;\\n    int value;\\n    \\n    Pair(int row, int col, int value) {\\n        this.row = row;\\n        this.col = col;\\n        this.value = value;\\n    }\\n    \\n    public int compareTo(Pair other) {\\n        return value - other.value;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    final int[][] neighbors = {{0, 1}, {1, 0}};\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> list = new ArrayList<>();\\n        if (nums1 == null || nums2 == null || nums1.length == 0 || nums2.length == 0 || k == 0) {\\n            return list;\\n        }\\n        int m = nums1.length, n = nums2.length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<Pair> minHeap = new PriorityQueue<>();\\n        minHeap.offer(new Pair(0, 0, nums1[0] + nums2[0]));\\n        visited[0][0] = true;\\n        while (k > 0 && !minHeap.isEmpty()) {\\n            Pair min = minHeap.poll();\\n            list.add(new int[] {nums1[min.row], nums2[min.col]});\\n            k--;\\n            for (int[] neighbor : neighbors) {\\n                int row1 = min.row + neighbor[0];\\n                int col1 = min.col + neighbor[1];\\n                if (row1 < 0 || row1 == m || col1 < 0 || col1 == n || visited[row1][col1]) {\\n                    continue;\\n                }\\n                visited[row1][col1] = true;\\n                minHeap.offer(new Pair(row1, col1, nums1[row1] + nums2[col1]));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair> {\\n    int row;\\n    int col;\\n    int value;\\n    \\n    Pair(int row, int col, int value) {\\n        this.row = row;\\n        this.col = col;\\n        this.value = value;\\n    }\\n    \\n    public int compareTo(Pair other) {\\n        return value - other.value;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687075,
                "title": "video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/2KgvcmQsIfA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] A, int[] B, int k) {\\n        int n = A.length;\\n        int m = B.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        HashSet<Pair<Integer,Integer>>hashSet = new HashSet<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> pair;\\n        int i,j;\\n        pq.add(new int[]{A[0]+B[0],0,0});\\n        hashSet.add(new Pair<Integer, Integer>(0, 0));\\n        while (!pq.isEmpty() && k-->0){\\n            int [] min = pq.remove();\\n            i = min[1];\\n            j = min[2];\\n            ans.add(Arrays.asList(A[i],B[j]));\\n            if(i<n-1 && !hashSet.contains(new Pair<Integer, Integer>(i+1,j))){\\n                pq.offer(new int[]{A[i+1]+B[j],i+1,j});\\n                hashSet.add(new Pair<Integer, Integer>(i+1,j));;\\n            }\\n\\n            if(j<m-1 && !hashSet.contains(new Pair<Integer, Integer>(i,j+1))){\\n                pq.offer(new int[]{A[i]+B[j+1],i,j+1});\\n                hashSet.add(new Pair<Integer, Integer>(i,j+1));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```\\nstruct pair_hash {\\n    template<class T1, class T2>\\n    size_t operator () (const pair<T1, T2>& p) const {\\n        auto h1 = hash<T1>{}(p.first);\\n        auto h2 = hash<T2>{}(p.second);\\n        return h1 ^ h2;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& A, vector<int>& B, int k) {\\n        int n = A.size();\\n        int m = B.size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        unordered_set<pair<int, int>, pair_hash> hashSet;\\n        vector<vector<int>> ans;\\n        pq.push({A[0] + B[0], 0, 0});\\n        hashSet.insert(make_pair(0, 0));\\n        while (!pq.empty() && k-- > 0) {\\n            vector<int> minValue = pq.top();\\n            pq.pop();\\n            int i = minValue[1];\\n            int j = minValue[2];\\n            ans.push_back({A[i], B[j]});\\n            if (i < n - 1 && hashSet.find(make_pair(i + 1, j)) == hashSet.end()) {\\n                pq.push({A[i + 1] + B[j], i + 1, j});\\n                hashSet.insert(make_pair(i + 1, j));\\n            }\\n\\n            if (j < m - 1 && hashSet.find(make_pair(i, j + 1)) == hashSet.end()) {\\n                pq.push({A[i] + B[j + 1], i, j + 1});\\n                hashSet.insert(make_pair(i, j + 1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nclass Solution:\\n    def kSmallestPairs(self, A: List[int], B: List[int], k: int) -> List[List[int]]:\\n        n = len(A)\\n        m = len(B)\\n        pq = []\\n        hashSet = set()\\n        ans = []\\n        heappush(pq, (A[0] + B[0], 0, 0))\\n        hashSet.add((0, 0))\\n        while pq and k > 0:\\n            min_val, i, j = heappop(pq)\\n            ans.append([A[i], B[j]])\\n            if i < n - 1 and (i + 1, j) not in hashSet:\\n                heappush(pq, (A[i + 1] + B[j], i + 1, j))\\n                hashSet.add((i + 1, j))\\n            if j < m - 1 and (i, j + 1) not in hashSet:\\n                heappush(pq, (A[i] + B[j + 1], i, j + 1))\\n                hashSet.add((i, j + 1))\\n            k -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] A, int[] B, int k) {\\n        int n = A.length;\\n        int m = B.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        HashSet<Pair<Integer,Integer>>hashSet = new HashSet<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> pair;\\n        int i,j;\\n        pq.add(new int[]{A[0]+B[0],0,0});\\n        hashSet.add(new Pair<Integer, Integer>(0, 0));\\n        while (!pq.isEmpty() && k-->0){\\n            int [] min = pq.remove();\\n            i = min[1];\\n            j = min[2];\\n            ans.add(Arrays.asList(A[i],B[j]));\\n            if(i<n-1 && !hashSet.contains(new Pair<Integer, Integer>(i+1,j))){\\n                pq.offer(new int[]{A[i+1]+B[j],i+1,j});\\n                hashSet.add(new Pair<Integer, Integer>(i+1,j));;\\n            }\\n\\n            if(j<m-1 && !hashSet.contains(new Pair<Integer, Integer>(i,j+1))){\\n                pq.offer(new int[]{A[i]+B[j+1],i,j+1});\\n                hashSet.add(new Pair<Integer, Integer>(i,j+1));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nstruct pair_hash {\\n    template<class T1, class T2>\\n    size_t operator () (const pair<T1, T2>& p) const {\\n        auto h1 = hash<T1>{}(p.first);\\n        auto h2 = hash<T2>{}(p.second);\\n        return h1 ^ h2;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& A, vector<int>& B, int k) {\\n        int n = A.size();\\n        int m = B.size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        unordered_set<pair<int, int>, pair_hash> hashSet;\\n        vector<vector<int>> ans;\\n        pq.push({A[0] + B[0], 0, 0});\\n        hashSet.insert(make_pair(0, 0));\\n        while (!pq.empty() && k-- > 0) {\\n            vector<int> minValue = pq.top();\\n            pq.pop();\\n            int i = minValue[1];\\n            int j = minValue[2];\\n            ans.push_back({A[i], B[j]});\\n            if (i < n - 1 && hashSet.find(make_pair(i + 1, j)) == hashSet.end()) {\\n                pq.push({A[i + 1] + B[j], i + 1, j});\\n                hashSet.insert(make_pair(i + 1, j));\\n            }\\n\\n            if (j < m - 1 && hashSet.find(make_pair(i, j + 1)) == hashSet.end()) {\\n                pq.push({A[i] + B[j + 1], i, j + 1});\\n                hashSet.insert(make_pair(i, j + 1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def kSmallestPairs(self, A: List[int], B: List[int], k: int) -> List[List[int]]:\\n        n = len(A)\\n        m = len(B)\\n        pq = []\\n        hashSet = set()\\n        ans = []\\n        heappush(pq, (A[0] + B[0], 0, 0))\\n        hashSet.add((0, 0))\\n        while pq and k > 0:\\n            min_val, i, j = heappop(pq)\\n            ans.append([A[i], B[j]])\\n            if i < n - 1 and (i + 1, j) not in hashSet:\\n                heappush(pq, (A[i + 1] + B[j], i + 1, j))\\n                hashSet.add((i + 1, j))\\n            if j < m - 1 and (i, j + 1) not in hashSet:\\n                heappush(pq, (A[i] + B[j + 1], i, j + 1))\\n                hashSet.add((i, j + 1))\\n            k -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687835,
                "title": "find-k-pair-priority-queue-due-to-tme",
                "content": "Hi,\\n\\nI am writing this solution to people who are struggling with TME and beginners who are finding difficult to understand other solution in a easy manner.\\n\\n**Intution:**\\nOnce I saw the solution I thought this the approach should be to go for priority queue and write away wrote an approach finding all the sum combination by nums1 * nums2 and storing in priority queue.\\n\\nSomething like this..\\n```\\n    public List<List<Integer>> kSmallestPairs1(int[] nums1, int[] nums2, int k) {\\n    \\tList<List<Integer>> res = new ArrayList();\\n    \\tint l1 = nums1.length, l2 = nums2.length;\\n    \\tPriorityQueue<Node> pq = new PriorityQueue<Node>((a, b)->(a.sum - b.sum));\\n    \\tfor(int i=0; i<l1; i++) {\\n    \\t\\tfor(int j=0; j<l2; j++) {\\n    \\t\\t\\tNode one = new Node();\\n    \\t\\t\\tone.a = nums1[i];\\n    \\t\\t\\tone.b = nums2[j];\\n    \\t\\t\\tone.sum = nums1[i] + nums2[j];\\n    \\t\\t\\tpq.add(one);\\n    \\t\\t}\\n    \\t}\\n    \\twhile(!pq.isEmpty() && k-->0) {\\n    \\t\\tList<Integer> list = new ArrayList<Integer>();\\n    \\t\\tNode one = pq.poll();\\n    \\t\\tlist.add(one.a);\\n    \\t\\tlist.add(one.b);\\n    \\t\\tres.add(list);\\n    \\t}\\n    \\treturn res;\\n    }\\n    \\n    class Node{\\n    \\tint sum;\\n    \\tint a;\\n    \\tint b;\\n    }\\n\\t\\n```\\n\\n\\tBut I ended up in TME the reason is the values given are in long range, storing it all was causing the problem, so we need to add to the priority queue in incremental manner for nums2 by making following changes to the above code.\\n\\n```\\n\\n\\tclass Node{\\n    \\tint sum;\\n    \\tint a;\\n    \\tint b;\\n    \\tint index;\\n    \\tNode(int a, int b, int sum, int index){\\n    \\t\\tthis.a = a;\\n    \\t\\tthis.b = b;\\n    \\t\\tthis.sum = sum;\\n    \\t\\tthis.index = index;\\n    \\t}\\n    }\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n    \\tList<List<Integer>> res = new ArrayList();\\n    \\tint l1 = nums1.length, l2 = nums2.length;\\n    \\tPriorityQueue<Node> pq = new PriorityQueue<Node>((a, b)->(a.sum - b.sum));\\n    \\tfor(int i=0; i<l1; i++) {\\n    \\t\\t\\tNode one = new Node(nums1[i], nums2[0], nums1[i]+nums2[0], 0);\\n    \\t\\t\\tpq.add(one);\\n    \\t}\\n    \\twhile(!pq.isEmpty() && k-->0) {\\n    \\t\\tList<Integer> list = new ArrayList<Integer>();\\n    \\t\\tNode one = pq.poll();\\n    \\t\\tlist.add(one.a);\\n    \\t\\tlist.add(one.b);\\n    \\t\\tres.add(list);\\n    \\t\\tif (one.index + 1 < nums2.length) {\\n    \\t\\t\\tNode two = new Node(one.a, nums2[one.index+1], one.a+nums2[one.index+1], one.index+1);\\n    \\t\\t\\tpq.add(two);\\n    \\t\\t}\\n\\n    \\t}\\n    \\treturn res;\\n    }\\n\\t\\n```\\n\\n\\n\\n\\n\\n\\t**Idea**\\n\\tThe main idea to add the next possible lower sum to the priority queue each step to avoid TME.\\n\\t\\n\\tHappy learning and upvote if this helped you out...\\n\\t\\n\\t",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public List<List<Integer>> kSmallestPairs1(int[] nums1, int[] nums2, int k) {\\n    \\tList<List<Integer>> res = new ArrayList();\\n    \\tint l1 = nums1.length, l2 = nums2.length;\\n    \\tPriorityQueue<Node> pq = new PriorityQueue<Node>((a, b)->(a.sum - b.sum));\\n    \\tfor(int i=0; i<l1; i++) {\\n    \\t\\tfor(int j=0; j<l2; j++) {\\n    \\t\\t\\tNode one = new Node();\\n    \\t\\t\\tone.a = nums1[i];\\n    \\t\\t\\tone.b = nums2[j];\\n    \\t\\t\\tone.sum = nums1[i] + nums2[j];\\n    \\t\\t\\tpq.add(one);\\n    \\t\\t}\\n    \\t}\\n    \\twhile(!pq.isEmpty() && k-->0) {\\n    \\t\\tList<Integer> list = new ArrayList<Integer>();\\n    \\t\\tNode one = pq.poll();\\n    \\t\\tlist.add(one.a);\\n    \\t\\tlist.add(one.b);\\n    \\t\\tres.add(list);\\n    \\t}\\n    \\treturn res;\\n    }\\n    \\n    class Node{\\n    \\tint sum;\\n    \\tint a;\\n    \\tint b;\\n    }\\n\\t\\n```\n```\\n\\n\\tclass Node{\\n    \\tint sum;\\n    \\tint a;\\n    \\tint b;\\n    \\tint index;\\n    \\tNode(int a, int b, int sum, int index){\\n    \\t\\tthis.a = a;\\n    \\t\\tthis.b = b;\\n    \\t\\tthis.sum = sum;\\n    \\t\\tthis.index = index;\\n    \\t}\\n    }\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n    \\tList<List<Integer>> res = new ArrayList();\\n    \\tint l1 = nums1.length, l2 = nums2.length;\\n    \\tPriorityQueue<Node> pq = new PriorityQueue<Node>((a, b)->(a.sum - b.sum));\\n    \\tfor(int i=0; i<l1; i++) {\\n    \\t\\t\\tNode one = new Node(nums1[i], nums2[0], nums1[i]+nums2[0], 0);\\n    \\t\\t\\tpq.add(one);\\n    \\t}\\n    \\twhile(!pq.isEmpty() && k-->0) {\\n    \\t\\tList<Integer> list = new ArrayList<Integer>();\\n    \\t\\tNode one = pq.poll();\\n    \\t\\tlist.add(one.a);\\n    \\t\\tlist.add(one.b);\\n    \\t\\tres.add(list);\\n    \\t\\tif (one.index + 1 < nums2.length) {\\n    \\t\\t\\tNode two = new Node(one.a, nums2[one.index+1], one.a+nums2[one.index+1], one.index+1);\\n    \\t\\t\\tpq.add(two);\\n    \\t\\t}\\n\\n    \\t}\\n    \\treturn res;\\n    }\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505893,
                "title": "heap-custom-comparator-c",
                "content": "Comparator *comp* will keep the pairs in heap in Descending order of their sums i.e., topmost pair will denote the smallest sum.\\nFirst we will insert pair(0, 0) in the heap which is necessarily the smallest sum as both arrays are in ascending order.\\n                   \\n\\n         |->(0, 1) -> (1, 1), (0, 2) -> .....\\n    (0, 0) \\n         |->(1, 0) -> (2, 0) -> ....\\n\\n\\neverytime the pair of indices pop out of the heap will necessarily be the next smaller sum.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ret;\\n        auto comp = [&nums1, &nums2](const pair<int, int>  &a, const pair<int, int> &b) {\\n            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\\n        };\\n        priority_queue< pair<int, int>, vector<pair<int, int>>, decltype(comp) >pq(comp);\\n        pq.push({0, 0});\\n        while(pq.size() && k--) {\\n            auto idx = pq.top();\\n            pq.pop();\\n            int i = idx.first, j = idx.second;\\n            ret.push_back(vector<int>({nums1[i], nums2[j]}));\\n            if(i == 0 && j+1 < nums2.size())pq.push({i, j+1});\\n            if(i+1 < nums1.size())pq.push({i+1, j});\\n        }\\n        return ret;\\n    }\\n};\\n```\\nO(N) space and O(KlogN) time\\nwhere, N = min(N, K)\\n       K = min(K, M*N)\\n       M, N = size of both arrays.",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ret;\\n        auto comp = [&nums1, &nums2](const pair<int, int>  &a, const pair<int, int> &b) {\\n            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\\n        };\\n        priority_queue< pair<int, int>, vector<pair<int, int>>, decltype(comp) >pq(comp);\\n        pq.push({0, 0});\\n        while(pq.size() && k--) {\\n            auto idx = pq.top();\\n            pq.pop();\\n            int i = idx.first, j = idx.second;\\n            ret.push_back(vector<int>({nums1[i], nums2[j]}));\\n            if(i == 0 && j+1 < nums2.size())pq.push({i, j+1});\\n            if(i+1 < nums1.size())pq.push({i+1, j});\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849689,
                "title": "clean-c-code-using-priority-queue-o-klogk",
                "content": "```\\nvector<vector<int>> kSmallestPairs(vector<int>& v1, vector<int>& v2, int k) {\\n    \\n    vector<vector<int> > ans;\\n\\n    priority_queue<pair<int, pair<int, int> >, vector<pair<int, pair<int, int> >> , greater<pair<int, pair<int, int> >> > pq;\\n\\n    int n = v1.size(), m = v2.size();\\n    \\n    for(int i=0;i<min(n, k);i++) \\n        pq.push({v1[i] + v2[0], {i, 0}});\\n    \\n    while(!pq.empty() && k--) {\\n        \\n        auto [i, j] = pq.top().second; pq.pop();\\n        ans.push_back({v1[i], v2[j]});\\n        \\n        if (j < m - 1) \\n            pq.push({v1[i] + v2[j+1], {i, j+1}});\\n    }\\n    return ans;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<vector<int>> kSmallestPairs(vector<int>& v1, vector<int>& v2, int k) {\\n    \\n    vector<vector<int> > ans;\\n\\n    priority_queue<pair<int, pair<int, int> >, vector<pair<int, pair<int, int> >> , greater<pair<int, pair<int, int> >> > pq;\\n\\n    int n = v1.size(), m = v2.size();\\n    \\n    for(int i=0;i<min(n, k);i++) \\n        pq.push({v1[i] + v2[0], {i, 0}});\\n    \\n    while(!pq.empty() && k--) {\\n        \\n        auto [i, j] = pq.top().second; pq.pop();\\n        ans.push_back({v1[i], v2[j]});\\n        \\n        if (j < m - 1) \\n            pq.push({v1[i] + v2[j+1], {i, j+1}});\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 550283,
                "title": "java-min-heap-easy-to-understand-beats-78-of-submission",
                "content": "- Create a priority queue (Min Heap) with a custom comparator\\n- Create a visited array viisted[i][j] which tells nums1[i] and nums2[j] is already been added to priority queue\\n- Since all the elements are sorted we add (nums1[0],nums2[0]) which is the smallest sum pair possible and mark visited[0][0] as true.\\n- When we pop a element from priority queue we add the popped element in the resultant list and new pairs in the priority queue which are formed by (i+1,j),(i,j+1),(i+1,j+1) and mark them as visited in our visited array.\\n- This process continues while our PriorityQueue is empty and result list equal to size `k`.\\n- Time Complexity: 0(MN log(MN))\\n- Space Complexity: 0(MN) \\n\\n```\\nclass Solution {\\n    \\n    int[][] dirs = {{0,1},{1,0},{1,1}};\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        // EDGE CASE\\n        if(nums1==null || nums2==null || nums1.length==0 || nums2.length==0) return result;\\n        \\n        // visited array\\n        boolean[][] visited = new boolean[nums1.length][nums2.length];\\n        \\n        // Min Heap\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->{\\n            return  ( a[0]+a[1] ) - ( b[0]+b[1] ) ;\\n        });\\n        \\n        \\n        int[] temp = new int[]{nums1[0],nums2[0],0,0};\\n        pq.add(temp);\\n        visited[0][0]= true;\\n        \\n        while(!pq.isEmpty()){\\n            int[] arr = pq.poll();\\n            List<Integer> ls = new ArrayList<>();\\n            ls.add(arr[0]);ls.add(arr[1]);\\n            result.add(ls);\\n            \\n            if(result.size()==k) break;\\n            int i=arr[2],j=arr[3];\\n            \\n            for(int[] dir : dirs){\\n                int dx=i+dir[0],dy=j+dir[1];\\n                if(dx<0 || dx>=nums1.length || dy<0 || dy>=nums2.length || visited[dx][dy]) continue;\\n                pq.add(new int[]{nums1[dx],nums2[dy],dx,dy});   \\n                visited[dx][dy] = true;\\n            }\\n        }\\n        \\n        return result;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[][] dirs = {{0,1},{1,0},{1,1}};\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        \\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        // EDGE CASE\\n        if(nums1==null || nums2==null || nums1.length==0 || nums2.length==0) return result;\\n        \\n        // visited array\\n        boolean[][] visited = new boolean[nums1.length][nums2.length];\\n        \\n        // Min Heap\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->{\\n            return  ( a[0]+a[1] ) - ( b[0]+b[1] ) ;\\n        });\\n        \\n        \\n        int[] temp = new int[]{nums1[0],nums2[0],0,0};\\n        pq.add(temp);\\n        visited[0][0]= true;\\n        \\n        while(!pq.isEmpty()){\\n            int[] arr = pq.poll();\\n            List<Integer> ls = new ArrayList<>();\\n            ls.add(arr[0]);ls.add(arr[1]);\\n            result.add(ls);\\n            \\n            if(result.size()==k) break;\\n            int i=arr[2],j=arr[3];\\n            \\n            for(int[] dir : dirs){\\n                int dx=i+dir[0],dy=j+dir[1];\\n                if(dx<0 || dx>=nums1.length || dy<0 || dy>=nums2.length || visited[dx][dy]) continue;\\n                pq.add(new int[]{nums1[dx],nums2[dy],dx,dy});   \\n                visited[dx][dy] = true;\\n            }\\n        }\\n        \\n        return result;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687265,
                "title": "c-basic-implementation-easy-explanation",
                "content": "# Intuition & Approach\\nBasic Intuition was that the K pairs will be generated by using at max  First K Elements  from each Arrays i.e\\n1. Either take all K Element from `Nums1` and one Element from `Nums2`\\n2. Take all K Element from `Nums2` and one Element from `Nums1`\\n3. Or any Combination\\n\\n### Solve :-\\n\\nDefine a MIN Priority Queue with `Pair<int, Pair<int, int>>` to store sum, `firstArrayIndex`, `secondArrayIndex` respectively\\n \\nTaking `Point 1` as Base i.e All K elements of First Array and 1 element from Second Array and storing them in MIN-HEAP\\n\\nLooping K times and each time the TOP element is the Best Possible Pair\\n\\nInserting the Next Element of SecondArray to generate different Pairs\\n\\n\\n## This can also be done using by taking Point 2 as base\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(k*log(min(n1, n2)))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define pp pair<int, pair<int, int>>\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        vector<vector<int>> ans;  \\n         \\n        // Create a min-heap to store pairs of indices and their sums\\n        priority_queue<pp, vector<pp>, greater<pp>> pq;\\n            \\n        // Push the initial pairs into the priority queue\\n        for (int i = 0; i < k && i < n1; i++)\\n            pq.push({nums1[i] + nums2[0], {i, 0}});\\n\\n        // Process the pairs until k pairs are obtained or the priority queue is empty\\n        while (k > 0 && !pq.empty()) {\\n            // Extract the pair with the smallest sum from the priority queue\\n            auto curr = pq.top();\\n            pq.pop();\\n\\n            int firstArrayIndex = curr.second.first;\\n            int secondArrayIndex = curr.second.second;\\n\\n            // Add the pair to the answer vector\\n            ans.push_back({nums1[firstArrayIndex], nums2[secondArrayIndex]});\\n\\n            // Push the next pair with the same first index but the next second index\\n            if (secondArrayIndex + 1 < n2) {\\n                pq.push({nums1[firstArrayIndex] + nums2[secondArrayIndex + 1], {firstArrayIndex, secondArrayIndex + 1}});\\n            }\\n          \\n            k--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pp pair<int, pair<int, int>>\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        vector<vector<int>> ans;  \\n         \\n        // Create a min-heap to store pairs of indices and their sums\\n        priority_queue<pp, vector<pp>, greater<pp>> pq;\\n            \\n        // Push the initial pairs into the priority queue\\n        for (int i = 0; i < k && i < n1; i++)\\n            pq.push({nums1[i] + nums2[0], {i, 0}});\\n\\n        // Process the pairs until k pairs are obtained or the priority queue is empty\\n        while (k > 0 && !pq.empty()) {\\n            // Extract the pair with the smallest sum from the priority queue\\n            auto curr = pq.top();\\n            pq.pop();\\n\\n            int firstArrayIndex = curr.second.first;\\n            int secondArrayIndex = curr.second.second;\\n\\n            // Add the pair to the answer vector\\n            ans.push_back({nums1[firstArrayIndex], nums2[secondArrayIndex]});\\n\\n            // Push the next pair with the same first index but the next second index\\n            if (secondArrayIndex + 1 < n2) {\\n                pq.push({nums1[firstArrayIndex] + nums2[secondArrayIndex + 1], {firstArrayIndex, secondArrayIndex + 1}});\\n            }\\n          \\n            k--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687179,
                "title": "c-easy-explanation-self-explanatory-code-greedy-algorithm",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach followed by the code can be summarized as follows:\\n\\n1. Create an empty `res` vector to store the k smallest pairs.\\n\\n2. Check if either `nums1` or `nums2` is empty or if k is zero. If any of these conditions are true, return the empty result vector.\\n\\n3. Define a custom comparator `cmp` as a lambda function. This comparator compares two pairs `(a, b)` based on the sum of their corresponding values in `nums1` and `nums2`, i.e., `(nums1[a.first] + nums2[a.second])` and `(nums1[b.first] + nums2[b.second])`. The purpose of this comparator is to order the pairs in a priority queue in a way that the pair with the smallest sum is at the top.\\n\\n4. Create a priority queue called `pq`, which stores pairs of indices `(i, j)` from `nums1` and `nums2` respectively. The priority queue is initialized with the custom comparator `cmp`. This priority queue will maintain the k smallest pairs based on their sum.\\n\\n5. Iterate from `i = 0` to `min(k, nums1.size()) - 1`. For each `i`, push the pair `(i, 0)` into the priority queue. This means that for each value of `i` in `nums1`, the pair with `i` as the index from `nums1` and 0 as the index from `nums2` is added to the priority queue. This initialization step ensures that we consider the pairs with the smallest values from `nums1` initially.\\n\\n6. While `k` is greater than 0 and the priority queue `pq` is not empty, do the following:\\n   - Retrieve the pair with the smallest sum from the top of the priority queue and store it in `idx`.\\n   - Remove the pair from the priority queue.\\n   - Add the pair `(nums1[idx.first], nums2[idx.second])` to the result vector `res`.\\n   - If `idx.second + 1` is less than the size of `nums2`, it means there are more pairs with the same index from `nums1` but with different indices from `nums2`. In this case, push the pair `(idx.first, idx.second + 1)` into the priority queue to consider the next pair with the same `idx.first` but the next index from `nums2`.\\n   - Decrement `k` by 1.\\n\\n7. Return the result vector `res` containing the k smallest pairs.\\n\\nThe approach utilizes a priority queue to efficiently maintain the k smallest pairs based on their sums. By adding pairs with the smallest values from `nums1` initially, it ensures that the algorithm considers the pairs with the smallest sums first.\\n\\n# Complexity\\n- Time complexity:\\nO(min(k, nums1.size()) log k + k)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)]\\\\$$ -->\\n\\n- Space complexity:    \\n O(min(k, nums1.size())).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> res; // Result vector to store the k smallest pairs\\n        \\n        if (nums1.empty() || nums2.empty() || k == 0) {\\n            return res; // If any of the input vectors is empty or k is zero, return an empty result\\n        }\\n        \\n        auto cmp = [&](const pair<int, int>& a, const pair<int, int>& b) {\\n            // Custom comparator function to determine the order in priority queue based on sum of pair values\\n            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\\n        };\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);\\n        // Priority queue to store pairs, with the smallest sum at the top\\n        \\n        for (int i = 0; i < min(k, static_cast<int>(nums1.size())); ++i) {\\n            pq.push({i, 0}); // Push the indices of the pairs with the smallest values of nums1 into the priority queue\\n        }\\n        \\n        while (k-- > 0 && !pq.empty()) {\\n            auto idx = pq.top(); // Get the pair with the smallest sum from the priority queue\\n            pq.pop(); // Remove the pair from the priority queue\\n            res.push_back({nums1[idx.first], nums2[idx.second]}); // Add the pair to the result vector\\n            \\n            if (idx.second + 1 < nums2.size()) {\\n                pq.push({idx.first, idx.second + 1}); // Push the next pair with the same index from nums1 but the next index from nums2\\n            }\\n        }\\n        \\n        return res; // Return the k smallest pairs\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> res; // Result vector to store the k smallest pairs\\n        \\n        if (nums1.empty() || nums2.empty() || k == 0) {\\n            return res; // If any of the input vectors is empty or k is zero, return an empty result\\n        }\\n        \\n        auto cmp = [&](const pair<int, int>& a, const pair<int, int>& b) {\\n            // Custom comparator function to determine the order in priority queue based on sum of pair values\\n            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\\n        };\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);\\n        // Priority queue to store pairs, with the smallest sum at the top\\n        \\n        for (int i = 0; i < min(k, static_cast<int>(nums1.size())); ++i) {\\n            pq.push({i, 0}); // Push the indices of the pairs with the smallest values of nums1 into the priority queue\\n        }\\n        \\n        while (k-- > 0 && !pq.empty()) {\\n            auto idx = pq.top(); // Get the pair with the smallest sum from the priority queue\\n            pq.pop(); // Remove the pair from the priority queue\\n            res.push_back({nums1[idx.first], nums2[idx.second]}); // Add the pair to the result vector\\n            \\n            if (idx.second + 1 < nums2.size()) {\\n                pq.push({idx.first, idx.second + 1}); // Push the next pair with the same index from nums1 but the next index from nums2\\n            }\\n        }\\n        \\n        return res; // Return the k smallest pairs\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687392,
                "title": "c-binary-search",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach**:\\n1. Applying binary search on \\'Range of Sum\\' , min_sum = sum of 1st two & max_sum = sum of last two (since a sum value for which we will be outputting our pairs will lie between this range)\\n2. \\'count()\\' will calculate  how many pairs are there for any target sum by applying binary search on 2nd array (b = target - a) and fixing value in array 1\\n3. Now we got what could be possible \\'max target sum\\' for which we have minimum \\'k\\' pairs\\n\\nThe solution barely passed with runtime of **2075 ms** and memory **303.9 MB** , but i found this a bit different approach so thought to share \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool compare(vector<int> v1, vector<int> v2){\\n        return (v1[0]+v1[1] < v2[0]+v2[1]);\\n    }\\n    \\n    // ceil index of element in array b such that sum a[i]+b[j]<=target\\n    int search(vector<int>& b, int k){\\n        int m=b.size();\\n        int l=0, r=m-1;\\n        while(l<r){\\n            int mid=l+(r-l+1)/2;\\n            if(b[mid]<=k){\\n                l=mid;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        return (b[l] <= k ? l:-1);\\n    }\\n    \\n    // count of pairs having sum <= target\\n    long long int count(vector<int>& a, vector<int>& b, int target){\\n        int n=a.size();\\n        long long int c=0;\\n        for(int i=0;i<n;i++){\\n            int x=target-a[i];\\n            int idx=search(b,x);\\n            if(idx!=-1) c+=(idx+1);\\n        }\\n        return c;\\n    } \\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& a, vector<int>& b, int k) {\\n        int n=a.size(), m=b.size();\\n        \\n        // minimum sum required so that we can have at least k pairs with smallest sum\\n        int l=a[0]+b[0], r=a[n-1]+b[m-1];\\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            if(count(a,b,mid)>=k){\\n                r=mid;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        int target=l;\\n        \\n        for(int i=0;i<n;i++){\\n            int x=target-a[i];\\n            int idx=search(b,x);\\n            if(idx!=-1){\\n                for(int j=0;j<=idx;j++){\\n                    ans.push_back({a[i],b[j]});\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end(),compare);\\n        if(ans.size()>k) ans.erase(ans.begin()+k,ans.end()); \\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool compare(vector<int> v1, vector<int> v2){\\n        return (v1[0]+v1[1] < v2[0]+v2[1]);\\n    }\\n    \\n    // ceil index of element in array b such that sum a[i]+b[j]<=target\\n    int search(vector<int>& b, int k){\\n        int m=b.size();\\n        int l=0, r=m-1;\\n        while(l<r){\\n            int mid=l+(r-l+1)/2;\\n            if(b[mid]<=k){\\n                l=mid;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        return (b[l] <= k ? l:-1);\\n    }\\n    \\n    // count of pairs having sum <= target\\n    long long int count(vector<int>& a, vector<int>& b, int target){\\n        int n=a.size();\\n        long long int c=0;\\n        for(int i=0;i<n;i++){\\n            int x=target-a[i];\\n            int idx=search(b,x);\\n            if(idx!=-1) c+=(idx+1);\\n        }\\n        return c;\\n    } \\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& a, vector<int>& b, int k) {\\n        int n=a.size(), m=b.size();\\n        \\n        // minimum sum required so that we can have at least k pairs with smallest sum\\n        int l=a[0]+b[0], r=a[n-1]+b[m-1];\\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            if(count(a,b,mid)>=k){\\n                r=mid;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        int target=l;\\n        \\n        for(int i=0;i<n;i++){\\n            int x=target-a[i];\\n            int idx=search(b,x);\\n            if(idx!=-1){\\n                for(int j=0;j<=idx;j++){\\n                    ans.push_back({a[i],b[j]});\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end(),compare);\\n        if(ans.size()>k) ans.erase(ans.begin()+k,ans.end()); \\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687284,
                "title": "easiest-c-solution-priority-queue-highly-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m*log(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    struct comp{\\n        char operator()(pair<int,int> &x,pair<int,int> &y){\\n        return y.first+y.second>x.first+x.second;\\n        }\\n    };\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>, comp> pq;\\n\\n        int i,j,c=0;\\n        for(i=0;i<nums1.size();i++)\\n        {\\n            for(j=0;j<nums2.size();j++)\\n            {\\n                if(pq.size() < k)          \\n    \\t\\t{\\n    \\t\\t\\tpq.push({nums1[i],nums2[j]});\\n\\t\\t\\t}\\n\\t\\t\\telse if(pq.size()==k and (nums1[i]+nums2[j]) < pq.top().first+pq.top().second)  \\n\\t\\t\\t{\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tpq.push({nums1[i],nums2[j]});\\n\\t\\t\\t}\\n\\t\\t\\telse if(pq.size()==k and (nums1[i]+nums2[j]) > pq.top().first+pq.top().second)   \\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n            }\\n        }\\n\\n        vector<vector<int>> v;\\n        \\n        while(!pq.empty())\\n        {\\n            v.push_back({pq.top().first,pq.top().second});\\n           \\n            pq.pop();\\n        }\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    struct comp{\\n        char operator()(pair<int,int> &x,pair<int,int> &y){\\n        return y.first+y.second>x.first+x.second;\\n        }\\n    };\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>>, comp> pq;\\n\\n        int i,j,c=0;\\n        for(i=0;i<nums1.size();i++)\\n        {\\n            for(j=0;j<nums2.size();j++)\\n            {\\n                if(pq.size() < k)          \\n    \\t\\t{\\n    \\t\\t\\tpq.push({nums1[i],nums2[j]});\\n\\t\\t\\t}\\n\\t\\t\\telse if(pq.size()==k and (nums1[i]+nums2[j]) < pq.top().first+pq.top().second)  \\n\\t\\t\\t{\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tpq.push({nums1[i],nums2[j]});\\n\\t\\t\\t}\\n\\t\\t\\telse if(pq.size()==k and (nums1[i]+nums2[j]) > pq.top().first+pq.top().second)   \\n\\t\\t\\t{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n            }\\n        }\\n\\n        vector<vector<int>> v;\\n        \\n        while(!pq.empty())\\n        {\\n            v.push_back({pq.top().first,pq.top().second});\\n           \\n            pq.pop();\\n        }\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522831,
                "title": "c-priority-queue",
                "content": "T.C= O(n * m * log(k)).\\nS.C= O(k).\\n\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n \\n        vector<vector<int>> res;\\n       \\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        \\n        for(auto x:nums1){\\n            for(auto y:nums2){\\n                int sum=x+y;\\n                if( pq.size()<k){\\n                     pq.push({sum,{x,y}});\\n                }\\n                else if(sum < pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({sum,{x,y}});\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        \\n        while(!pq.empty() ){\\n           auto p=pq.top().second;\\n            pq.pop();\\n            \\n            res.push_back({p.first,p.second});\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "T.C= O(n * m * log(k)).\\nS.C= O(k).\\n\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n \\n        vector<vector<int>> res;\\n       \\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        \\n        for(auto x:nums1){\\n            for(auto y:nums2){\\n                int sum=x+y;\\n                if( pq.size()<k){\\n                     pq.push({sum,{x,y}});\\n                }\\n                else if(sum < pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({sum,{x,y}});\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        \\n        while(!pq.empty() ){\\n           auto p=pq.top().second;\\n            pq.pop();\\n            \\n            res.push_back({p.first,p.second});\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1100152,
                "title": "finding-k-smallest-pairs-using-maxheap-with-comments-72ms",
                "content": "```py\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        # we use maxHeap so that we can pop largest number among k+1 numbers in maxHeap first\\n        maxHeap = []\\n\\n        \"\"\"\\n        instead of iterating over all the numbers of both array, we can iterate only\\n        the first \\'K\\' numbers from both array.\\n\\n        Since they are sorted in ascending order, the pairs with the minimum sum will\\n        be just the first \\'K\\' numbers from those two arrays.\\n        \"\"\"\\n        for i in range(0, min(k, len(nums1))):\\n            for j in range(0, min(k, len(nums2))):\\n                x = nums1[i]\\n                y = nums2[j]\\n                \\n                # sum of two number\\n                total = x + y\\n                \\n                if len(maxHeap) < k:\\n                    heapq.heappush(maxHeap, [-total, x, y])\\n                else:\\n                    # if the sum of x and y is larger than the largest (among the k smallests)\\n                    # sum, we can \\'break\\' here. Since the arrays are sorted in the ascending order,\\n                    # we will not be able to find a pair with smaller sum moving forward.\\n                    if total > -maxHeap[0][0]:\\n                        break\\n                    \\n                    # push new numbers to the heap\\n                    heapq.heappush(maxHeap, [-total, x, y])\\n\\n                    # pop the largest number among k+1 numbers in maxHeap, so that only\\n                    # k smallest numbers are in maxHeap\\n                    heapq.heappop(maxHeap)\\n\\n        result = []\\n        while maxHeap:\\n            popped = heapq.heappop(maxHeap)\\n            result.append([popped[1], popped[2]])\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```py\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        # we use maxHeap so that we can pop largest number among k+1 numbers in maxHeap first\\n        maxHeap = []\\n\\n        \"\"\"\\n        instead of iterating over all the numbers of both array, we can iterate only\\n        the first \\'K\\' numbers from both array.\\n\\n        Since they are sorted in ascending order, the pairs with the minimum sum will\\n        be just the first \\'K\\' numbers from those two arrays.\\n        \"\"\"\\n        for i in range(0, min(k, len(nums1))):\\n            for j in range(0, min(k, len(nums2))):\\n                x = nums1[i]\\n                y = nums2[j]\\n                \\n                # sum of two number\\n                total = x + y\\n                \\n                if len(maxHeap) < k:\\n                    heapq.heappush(maxHeap, [-total, x, y])\\n                else:\\n                    # if the sum of x and y is larger than the largest (among the k smallests)\\n                    # sum, we can \\'break\\' here. Since the arrays are sorted in the ascending order,\\n                    # we will not be able to find a pair with smaller sum moving forward.\\n                    if total > -maxHeap[0][0]:\\n                        break\\n                    \\n                    # push new numbers to the heap\\n                    heapq.heappush(maxHeap, [-total, x, y])\\n\\n                    # pop the largest number among k+1 numbers in maxHeap, so that only\\n                    # k smallest numbers are in maxHeap\\n                    heapq.heappop(maxHeap)\\n\\n        result = []\\n        while maxHeap:\\n            popped = heapq.heappop(maxHeap)\\n            result.append([popped[1], popped[2]])\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187490,
                "title": "c-100-k-way-merge-sort-easy-to-explain-and-impl-in-10mins-cheers",
                "content": "```\\n#include <vector>\\n#include <utility>\\n#include <queue>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> res;\\n        if (nums1.empty() || nums2.empty()) {\\n            return res;\\n        }\\n        \\n        auto comp = [&](auto& pr1, auto& pr2) {\\n            int sum1 = nums1[pr1.first] + nums2[pr1.second];\\n            int sum2 = nums1[pr2.first] + nums2[pr2.second];\\n            \\n            return sum2 < sum1;\\n        };\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);\\n        \\n        int n1 = nums1.size();\\n        for (int i = 0; i < n1; ++i) {\\n            pq.push({i, 0});\\n        }\\n        \\n        int n2 = nums2.size();\\n        while (!pq.empty() && res.size() < (size_t)k) {\\n            auto pr = pq.top();\\n            pq.pop();\\n            \\n            res.push_back({nums1[pr.first], nums2[pr.second]});\\n            \\n            if (pr.second + 1 < n2) {\\n                pq.push({pr.first, pr.second + 1});\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <utility>\\n#include <queue>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<pair<int, int>> res;\\n        if (nums1.empty() || nums2.empty()) {\\n            return res;\\n        }\\n        \\n        auto comp = [&](auto& pr1, auto& pr2) {\\n            int sum1 = nums1[pr1.first] + nums2[pr1.second];\\n            int sum2 = nums1[pr2.first] + nums2[pr2.second];\\n            \\n            return sum2 < sum1;\\n        };\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(comp)> pq(comp);\\n        \\n        int n1 = nums1.size();\\n        for (int i = 0; i < n1; ++i) {\\n            pq.push({i, 0});\\n        }\\n        \\n        int n2 = nums2.size();\\n        while (!pq.empty() && res.size() < (size_t)k) {\\n            auto pr = pq.top();\\n            pq.pop();\\n            \\n            res.push_back({nums1[pr.first], nums2[pr.second]});\\n            \\n            if (pr.second + 1 < n2) {\\n                pq.push({pr.first, pr.second + 1});\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1768494,
                "title": "easy-java-solution-using-priorityqueue",
                "content": "**//Please upvote if you find this helpful**\\n\\n\\nclass Solution {\\n\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<pair>pq = new PriorityQueue<>();\\n        for(int i=0; i<nums1.length; i++){\\n            pq.add(new pair(nums1[i],nums2[0],nums1[i]+nums2[0],0));\\n        }\\n        List<List<Integer>>ans = new ArrayList<>();\\n        while(k>0 && pq.size()>0){\\n            pair a = pq.remove();\\n            List<Integer>aa = new ArrayList<>();\\n            aa.add(a.d1);\\n            aa.add(a.d2);\\n            ans.add(aa);\\n            int index = a.idx;\\n\\t\\t\\t//if the element which is removed has more elements after itself(from nums2 array) than add //that element into the priority queue\\n            if(index < nums2.length-1){\\n                pq.add(new pair(a.d1,nums2[index+1],a.d1+nums2[index+1],index+1));\\n            }\\n            k--;\\n        }\\n        return ans;\\n    }\\n    \\n\\t//comparing according to the sum of elements and returning the min sum from priority queue\\n    public class pair implements Comparable<pair>{\\n        int d1;\\n        int d2;\\n        int sum;\\n        int idx;\\n        pair(int d1,int d2,int s,int idx){\\n            this.d1 = d1;\\n            this.d2 = d2;\\n            this.sum = s;\\n            this.idx = idx;\\n        }\\n        public int compareTo(pair other){\\n            return this.sum-other.sum;\\n        }\\n    }\\n}\\n\\n\\n**//please upvote if you find this helpful**",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<pair>pq = new PriorityQueue<>();\\n        for(int i=0; i<nums1.length; i++){\\n            pq.add(new pair(nums1[i],nums2[0],nums1[i]+nums2[0],0));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1475228,
                "title": "javascript-solution-priority-queue",
                "content": "```\\nvar kSmallestPairs = function(nums1, nums2, k) {\\n    const minHeap = new MinPriorityQueue({ priority: x => x[0] });\\n    \\n    for (let i = 0; i < nums1.length; i++) {\\n        const num1 = nums1[i];\\n        const num2 = nums2[0];\\n        \\n        minHeap.enqueue([num1 + num2, i, 0]);\\n    }\\n    \\n    const n = nums2.length;\\n    const res = [];\\n    \\n    while (k > 0 && !minHeap.isEmpty()) {\\n        const [sum, idx1, idx2] = minHeap.dequeue().element;\\n        \\n        res.push([nums1[idx1], nums2[idx2]]);\\n        \\n        if (res.length === k) return res;\\n        \\n        if (idx2 < n - 1) {\\n            minHeap.enqueue([nums1[idx1] + nums2[idx2 + 1], idx1, idx2 + 1]);\\n        } \\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar kSmallestPairs = function(nums1, nums2, k) {\\n    const minHeap = new MinPriorityQueue({ priority: x => x[0] });\\n    \\n    for (let i = 0; i < nums1.length; i++) {\\n        const num1 = nums1[i];\\n        const num2 = nums2[0];\\n        \\n        minHeap.enqueue([num1 + num2, i, 0]);\\n    }\\n    \\n    const n = nums2.length;\\n    const res = [];\\n    \\n    while (k > 0 && !minHeap.isEmpty()) {\\n        const [sum, idx1, idx2] = minHeap.dequeue().element;\\n        \\n        res.push([nums1[idx1], nums2[idx2]]);\\n        \\n        if (res.length === k) return res;\\n        \\n        if (idx2 < n - 1) {\\n            minHeap.enqueue([nums1[idx1] + nums2[idx2 + 1], idx1, idx2 + 1]);\\n        } \\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453522,
                "title": "c-easy-and-neat",
                "content": "```\\ntypedef pair<int, pair<int, int>> pip;\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n            // make sure the array should is sorted as need smallest first\\n        \\n            int n1 = nums1.size(), n2 = nums2.size();  vector<vector<int>> ans;\\n        \\n            priority_queue<pip, vector<pip>, greater<pip>> minheap;\\n        \\n            for(int i=0; i<n1; i++)\\n                minheap.push({nums1[i] + nums2[0], {i,0}});\\n        \\n            while(ans.size() < k && !minheap.empty()){\\n                \\n                pair<int, pair<int, int>> p = minheap.top();\\n                minheap.pop();\\n                \\n                int i = p.second.first, j = p.second.second;\\n                ans.push_back({nums1[i],nums2[j]});\\n               // ans.push_back(p.first);  // if sum is asked instead of pairs\\n                         \\n                if(j+1 < n2){\\n                    minheap.push({nums1[i]+nums2[j+1], {i, j+1}});\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n/*  Find K Pairs with largest Sums/Maximum Sum Combinations\\n    use a    priority_queue<pip> maxheap\\n    we need largest first \\n    sort(nums1.rbegin(), nums1.rend());\\n    sort(nums2.rbegin(), nums2.rend());\\n    rest is same\\n*/\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n            // make sure the array should is sorted as need smallest first\\n        \\n            int n1 = nums1.size(), n2 = nums2.size();  vector<vector<int>> ans;\\n        \\n            priority_queue<pip, vector<pip>, greater<pip>> minheap;\\n        \\n            for(int i=0; i<n1; i++)\\n                minheap.push({nums1[i] + nums2[0], {i,0}",
                "codeTag": "Java"
            },
            {
                "id": 1139152,
                "title": "java-priorityqueue-same-way-of-question-378",
                "content": "Before we start this question, we should know how to solve question 378.\\nBefore we start question 378, we should know how to work on question 23: merge two sorted Lists\\nFor this question, we can translate it into matrix\\ne.g.: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\\n```\\n\\t\\t\\t\\t\\t   1        7         11\\n             2        1,2      7,2       11,2\\n\\t\\t     4        1,4      7,4       11,4\\n\\t\\t     6        1,6      7,6       11,6\\n```\\nEach row is sorted by sum and each column is sorted by sum. That\\'s the same question of 378.\\n\\nWe use the same way of question 23 (which is also the same way of question 378):\\n1. PriorityQueue to save the first column.\\n2. poll one value, then push this value into result list. \\n3. Then, push the next value of that row into PriorityQueue. \\n\\n```\\n\\tpublic List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int cols = nums1.length, rows = nums2.length;\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n\\n        for(int row = 0; row < rows; row++) q.add(new int[]{nums2[row] + nums1[0], row, 0}); // {value, row, col}\\n\\n        while(!q.isEmpty()) {\\n            int[] val = q.poll();\\n            ans.add(new ArrayList<>(Arrays.asList(nums1[val[2]], nums2[val[1]])));\\n            k--;\\n            if(k == 0) return ans;\\n\\n            val[2]++;\\n            if(val[2] == cols) continue;\\n            val[0] = nums1[val[2]] + nums2[val[1]];\\n            q.add(val);\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t   1        7         11\\n             2        1,2      7,2       11,2\\n\\t\\t     4        1,4      7,4       11,4\\n\\t\\t     6        1,6      7,6       11,6\\n```\n```\\n\\tpublic List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int cols = nums1.length, rows = nums2.length;\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n\\n        for(int row = 0; row < rows; row++) q.add(new int[]{nums2[row] + nums1[0], row, 0}); // {value, row, col}\\n\\n        while(!q.isEmpty()) {\\n            int[] val = q.poll();\\n            ans.add(new ArrayList<>(Arrays.asList(nums1[val[2]], nums2[val[1]])));\\n            k--;\\n            if(k == 0) return ans;\\n\\n            val[2]++;\\n            if(val[2] == cols) continue;\\n            val[0] = nums1[val[2]] + nums2[val[1]];\\n            q.add(val);\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 861173,
                "title": "javascript-solution-array-of-objects-with-comments-beat-90-68",
                "content": "Here\\'s my solution below.  I\\'m no expert, so there could very well be something non-ideal about the approach.  But it works well!\\n\\nRuntime: 108 ms (beat 90.68% of JavaScript solutions)\\nMemory Usage: 40.4 MB (beat 99.15% of JavaScript solutions)\\n\\nSee the comments in the code for the explanation.  I hope this helps someone.  Cheers!\\n\\n```\\n// Commented Version\\nvar kSmallestPairsCommented = function(nums1, nums2, k) {\\n    \\n  // Return an empty array if we are given an empty array\\n  if (nums1.length === 0 || nums2.length === 0) return []\\n  \\n  // Initialize variables\\n  let arr = []; // arr will be an array holding a series of objects\\n  let max = -Infinity; // max will track the largest sum currently in arr\\n  \\n  // Loop through nums1\\n  for (let i = 0; i < nums1.length; i++) {\\n      // Loop through nums2\\n      for (let j = 0; j < nums2.length; j++) {\\n          \\n          // Before the conditional statements, create an object based on nums1[i] and nums2[j]\\n          let obj = {\\n              sum: nums1[i] + nums2[j], // holds the value of the numbers\\' sum\\n              nums: [nums1[i], nums2[j]] // holds array of the corresponding numbers\\n          }\\n          \\n          // If obj.sum is greater than max AND arr already has k values...\\n          if (obj.sum >= max && arr.length >= k) {\\n              break; // break.  This is to save time.\\n          } \\n          \\n          // Else, if obj.sum is less than or equal to max and our array has fewer than k elements...\\n          else if (obj.sum <= max && arr.length < k) {\\n              arr.push(obj); // ...push obj into arr.\\n          } \\n          \\n          // Else, if obj.sum is greater than max and our array has fewer than k elements... \\n          else if (obj.sum > max && arr.length < k) {\\n              max = obj.sum; // ...set the new max to obj.sum... \\n              arr.push(obj); // ...and push obj into arr.\\n          } \\n          \\n          // Else, if obj.sum is less than max AND arr has k or more elements...\\n          else if (obj.sum < max && arr.length >= k) {\\n              // We need to: \\n                  // (1) remove one element where sum equals max\\n                  // (2) replace that element with obj\\n                  // (3) Set max to the new highest value sum in our array.\\n              \\n              let newMax = -Infinity;  // Holds the value to be set to max.\\n              let replaced = false;   // Tracks if we have completed steps (1) and (2).\\n              \\n              for (let n = 0; n < arr.length; n++) {\\n                  // This if statement takes care of steps (1) and (2)\\n                  if (!replaced && arr[n].sum === max) {\\n                      arr[n] = obj;\\n                      replaced = true;\\n                  }\\n                  // This if statement takes care of step (3)\\n                  if (arr[n].sum > newMax) newMax = arr[n].sum\\n              }\\n              // After we have iterated through all elements in arr, sets the highest value sum as our new max.\\n              max = newMax;\\n          } \\n      }\\n  }\\n  \\n  // Converts arr into the form we need to return it in.\\n  // ... Since arr is currently an array of objects, this changes arr to hold just the needed pairs.\\n  return arr.map(obj => obj.nums);\\n  \\n};\\n```\\n\\n...and if it\\'s helpful to see it without comments, here that is:\\n```\\nvar kSmallestPairs = function(nums1, nums2, k) {\\n    \\n    if (nums1.length === 0 || nums2.length === 0) return []\\n    \\n    let arr = [];\\n    let max = -Infinity;\\n    \\n    for (let i = 0; i < nums1.length; i++) {\\n        for (let j = 0; j < nums2.length; j++) {\\n\\n            let obj = {\\n                sum: nums1[i] + nums2[j],\\n                nums: [nums1[i], nums2[j]]\\n            }\\n            \\n            if (obj.sum >= max && arr.length >= k) {\\n                break;\\n            } else if (obj.sum <= max && arr.length < k) {\\n                arr.push(obj);\\n            } else if (obj.sum > max && arr.length < k) {\\n                max = obj.sum; \\n                arr.push(obj);\\n            } else if (obj.sum < max && arr.length >= k) {\\n                let newMax = -Infinity;\\n                let replaced = false;\\n                for (let n = 0; n < arr.length; n++) {\\n                    if (!replaced && arr[n].sum === max) {\\n                        arr[n] = obj;\\n                        replaced = true;\\n                    }\\n                    if (arr[n].sum > newMax) newMax = arr[n].sum\\n                }\\n                max = newMax;\\n            } \\n        }\\n    }\\n    \\n    return arr.map(obj => obj.nums);\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Commented Version\\nvar kSmallestPairsCommented = function(nums1, nums2, k) {\\n    \\n  // Return an empty array if we are given an empty array\\n  if (nums1.length === 0 || nums2.length === 0) return []\\n  \\n  // Initialize variables\\n  let arr = []; // arr will be an array holding a series of objects\\n  let max = -Infinity; // max will track the largest sum currently in arr\\n  \\n  // Loop through nums1\\n  for (let i = 0; i < nums1.length; i++) {\\n      // Loop through nums2\\n      for (let j = 0; j < nums2.length; j++) {\\n          \\n          // Before the conditional statements, create an object based on nums1[i] and nums2[j]\\n          let obj = {\\n              sum: nums1[i] + nums2[j], // holds the value of the numbers\\' sum\\n              nums: [nums1[i], nums2[j]] // holds array of the corresponding numbers\\n          }\\n          \\n          // If obj.sum is greater than max AND arr already has k values...\\n          if (obj.sum >= max && arr.length >= k) {\\n              break; // break.  This is to save time.\\n          } \\n          \\n          // Else, if obj.sum is less than or equal to max and our array has fewer than k elements...\\n          else if (obj.sum <= max && arr.length < k) {\\n              arr.push(obj); // ...push obj into arr.\\n          } \\n          \\n          // Else, if obj.sum is greater than max and our array has fewer than k elements... \\n          else if (obj.sum > max && arr.length < k) {\\n              max = obj.sum; // ...set the new max to obj.sum... \\n              arr.push(obj); // ...and push obj into arr.\\n          } \\n          \\n          // Else, if obj.sum is less than max AND arr has k or more elements...\\n          else if (obj.sum < max && arr.length >= k) {\\n              // We need to: \\n                  // (1) remove one element where sum equals max\\n                  // (2) replace that element with obj\\n                  // (3) Set max to the new highest value sum in our array.\\n              \\n              let newMax = -Infinity;  // Holds the value to be set to max.\\n              let replaced = false;   // Tracks if we have completed steps (1) and (2).\\n              \\n              for (let n = 0; n < arr.length; n++) {\\n                  // This if statement takes care of steps (1) and (2)\\n                  if (!replaced && arr[n].sum === max) {\\n                      arr[n] = obj;\\n                      replaced = true;\\n                  }\\n                  // This if statement takes care of step (3)\\n                  if (arr[n].sum > newMax) newMax = arr[n].sum\\n              }\\n              // After we have iterated through all elements in arr, sets the highest value sum as our new max.\\n              max = newMax;\\n          } \\n      }\\n  }\\n  \\n  // Converts arr into the form we need to return it in.\\n  // ... Since arr is currently an array of objects, this changes arr to hold just the needed pairs.\\n  return arr.map(obj => obj.nums);\\n  \\n};\\n```\n```\\nvar kSmallestPairs = function(nums1, nums2, k) {\\n    \\n    if (nums1.length === 0 || nums2.length === 0) return []\\n    \\n    let arr = [];\\n    let max = -Infinity;\\n    \\n    for (let i = 0; i < nums1.length; i++) {\\n        for (let j = 0; j < nums2.length; j++) {\\n\\n            let obj = {\\n                sum: nums1[i] + nums2[j],\\n                nums: [nums1[i], nums2[j]]\\n            }\\n            \\n            if (obj.sum >= max && arr.length >= k) {\\n                break;\\n            } else if (obj.sum <= max && arr.length < k) {\\n                arr.push(obj);\\n            } else if (obj.sum > max && arr.length < k) {\\n                max = obj.sum; \\n                arr.push(obj);\\n            } else if (obj.sum < max && arr.length >= k) {\\n                let newMax = -Infinity;\\n                let replaced = false;\\n                for (let n = 0; n < arr.length; n++) {\\n                    if (!replaced && arr[n].sum === max) {\\n                        arr[n] = obj;\\n                        replaced = true;\\n                    }\\n                    if (arr[n].sum > newMax) newMax = arr[n].sum\\n                }\\n                max = newMax;\\n            } \\n        }\\n    }\\n    \\n    return arr.map(obj => obj.nums);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 586235,
                "title": "python-heap-with-explanation",
                "content": "Obviously, nums1[0]+nums2[0] is the smallest.\\nThe next smallest could be nums1[1]+nums2[0] or nums1[0]+nums[2], so we add both to the heap.\\nHeap pop gives us the current smallest with nums1[left] and nums2[right] \\nAnd then heappush nums1[left+1]+nums2[right] and nums1[left]+nums2[right+1], if left+1 and right+1 are valid.\\n\\nAnother important observation is that nums1[left]+nums2[right] may be pushed twice.\\nBecause both nums1[left-1]+nums2[right] and nums1[left]+nums2[right-1] will try to heappush nums1[left]+nums2[right]\\nSo we need a set to marked used left, right pairs.\\nThe size of heap is increasing, because every heappop tries to heappush two numbers.\\nSo k heappop will left a heap size of k at most.\\nTime: KlogK\\nSpace: O(K)\\n```\\nimport heapq\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        if not nums1 or not nums2:\\n            return []\\n        res = []\\n        len_nums1, len_nums2 = len(nums1), len(nums2)\\n        my_hp = [[nums1[0]+nums2[0], 0, 0]] # the index of both nums1 and nums2 are also included in heap item.\\n        seen = {(0,0)}\\n        while k > 0 and my_hp:\\n            _, left, right = heappop(my_hp)\\n            res.append([nums1[left], nums2[right]])\\n            k -= 1\\n            if left < len_nums1-1 and (left+1, right) not in seen:\\n                heappush(my_hp, [nums1[left+1]+nums2[right], left+1, right])\\n                seen.add((left+1, right))\\n            if right < len_nums2-1 and (left, right+1) not in seen:\\n                heappush(my_hp, [nums1[left]+nums2[right+1], left, right+1])\\n                seen.add((left, right+1))\\n        return res\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        if not nums1 or not nums2:\\n            return []\\n        res = []\\n        len_nums1, len_nums2 = len(nums1), len(nums2)\\n        my_hp = [[nums1[0]+nums2[0], 0, 0]] # the index of both nums1 and nums2 are also included in heap item.\\n        seen = {(0,0)}\\n        while k > 0 and my_hp:\\n            _, left, right = heappop(my_hp)\\n            res.append([nums1[left], nums2[right]])\\n            k -= 1\\n            if left < len_nums1-1 and (left+1, right) not in seen:\\n                heappush(my_hp, [nums1[left+1]+nums2[right], left+1, right])\\n                seen.add((left+1, right))\\n            if right < len_nums2-1 and (left, right+1) not in seen:\\n                heappush(my_hp, [nums1[left]+nums2[right+1], left, right+1])\\n                seen.add((left, right+1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688349,
                "title": "c-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    \\ttypedef pair<int, pair<int, int>> pi;\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& n1, vector<int>& n2, int k) {\\n        int n=n1.size();\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        for(int i=0;i<n && i<k;i++){\\n            pq.push({n1[i]+n2[0],{i,0}});\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=0;i<k && pq.size();i++){\\n            auto x = pq.top();\\n            pq.pop();\\n            int in_i = x.second.first;\\n            int in_j = x.second.second;\\n            ans.push_back({n1[in_i],n2[in_j]});\\n            if(in_j+1<n2.size()){\\n                pq.push({n1[in_i]+n2[in_j+1],{in_i,in_j+1}});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/5e406f93-1122-41dc-9016-3007939d6227_1687857825.9100075.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\ttypedef pair<int, pair<int, int>> pi;\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& n1, vector<int>& n2, int k) {\\n        int n=n1.size();\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        for(int i=0;i<n && i<k;i++){\\n            pq.push({n1[i]+n2[0],{i,0}});\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=0;i<k && pq.size();i++){\\n            auto x = pq.top();\\n            pq.pop();\\n            int in_i = x.second.first;\\n            int in_j = x.second.second;\\n            ans.push_back({n1[in_i],n2[in_j]});\\n            if(in_j+1<n2.size()){\\n                pq.push({n1[in_i]+n2[in_j+1],{in_i,in_j+1}});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687209,
                "title": "easy-heap-solution-beats-93-python3-java-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe needed to find the K smallest pairs of numbers from two different sorted arrays. What better way than to use a heap (priority queue) to maintain the sorted order(to find the minimum) while also constantly changing the data structure.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe know that the two arrays are sorted, i.e, the smallest sum would for sure be nums1[0] + nums2[0], so we start with that. The next smallest sum would either be formed by the pair (nums1[1], nums2[0]) or (nums1[0], nums2[1]), so we keep adding these 2 possible pairs to the heap and every time we pop from the heap, the smallest sum would pop and we add that to our answer till either we find k pairs or our heap becomes empty.\\nTo avoid the case of adding a pair of indices twice, we maintain a set named visited wherein everytime we visit(use in the answer) a pair of indices, we add it to the set so as to not add it again.\\n\\n# Python3 Code\\n```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        ans = []\\n        n1, n2 = len(nums1), len(nums2)\\n        visited = set()\\n        hp = []\\n        hp.append((nums1[0]+nums2[0],(0,0)))\\n        visited.add((0,0))\\n        count = 0\\n        while k and hp:\\n            val, (i,j) = heappop(hp)\\n            ans.append([nums1[i],nums2[j]])\\n\\n            if i+1<n1 and (i+1,j) not in visited:\\n                heappush(hp, (nums1[i+1]+nums2[j],(i+1,j)))\\n                visited.add((i+1,j))\\n\\n            if j+1<n2 and (i, j+1) not in visited:\\n                heappush(hp,(nums1[i]+nums2[j+1], (i,j+1)))\\n                visited.add((i,j+1))\\n\\n            k -= 1\\n\\n        return ans\\n\\n```\\n# Java Code\\n```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int m = nums1.length;\\n        int n = nums2.length;\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<Pair<Integer, Integer>> visited = new HashSet<>();\\n\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        minHeap.offer(new int[]{nums1[0] + nums2[0], 0, 0});\\n        visited.add(new Pair<Integer, Integer>(0, 0));\\n\\n        while (k-- > 0 && !minHeap.isEmpty()) {\\n            int[] top = minHeap.poll();\\n            int i = top[1];\\n            int j = top[2];\\n\\n            ans.add(List.of(nums1[i], nums2[j]));\\n\\n            if (i + 1 < m && !visited.contains(new Pair<Integer, Integer>(i + 1, j))) {\\n                minHeap.offer(new int[]{nums1[i + 1] + nums2[j], i + 1, j});\\n                visited.add(new Pair<Integer, Integer>(i + 1, j));\\n            }\\n\\n            if (j + 1 < n && !visited.contains(new Pair<Integer, Integer>(i, j + 1))) {\\n                minHeap.offer(new int[]{nums1[i] + nums2[j + 1], i, j + 1});\\n                visited.add(new Pair<Integer, Integer>(i, j + 1));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n\\n        vector<vector<int>> ans;\\n        set<pair<int, int>> visited;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>,\\n                       greater<pair<int, pair<int, int>>>> minHeap;\\n        minHeap.push({nums1[0] + nums2[0], {0, 0}});\\n        visited.insert({0, 0});\\n\\n        while (k-- && !minHeap.empty()) {\\n            auto top = minHeap.top();\\n            minHeap.pop();\\n            int i = top.second.first;\\n            int j = top.second.second;\\n\\n            ans.push_back({nums1[i], nums2[j]});\\n\\n            if (i + 1 < m && visited.find({i + 1, j}) == visited.end()) {\\n                minHeap.push({nums1[i + 1] + nums2[j], {i + 1, j}});\\n                visited.insert({i + 1, j});\\n            }\\n\\n            if (j + 1 < n && visited.find({i, j + 1}) == visited.end()) {\\n                minHeap.push({nums1[i] + nums2[j + 1], {i, j + 1}});\\n                visited.insert({i, j + 1});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        ans = []\\n        n1, n2 = len(nums1), len(nums2)\\n        visited = set()\\n        hp = []\\n        hp.append((nums1[0]+nums2[0],(0,0)))\\n        visited.add((0,0))\\n        count = 0\\n        while k and hp:\\n            val, (i,j) = heappop(hp)\\n            ans.append([nums1[i],nums2[j]])\\n\\n            if i+1<n1 and (i+1,j) not in visited:\\n                heappush(hp, (nums1[i+1]+nums2[j],(i+1,j)))\\n                visited.add((i+1,j))\\n\\n            if j+1<n2 and (i, j+1) not in visited:\\n                heappush(hp,(nums1[i]+nums2[j+1], (i,j+1)))\\n                visited.add((i,j+1))\\n\\n            k -= 1\\n\\n        return ans\\n\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int m = nums1.length;\\n        int n = nums2.length;\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<Pair<Integer, Integer>> visited = new HashSet<>();\\n\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        minHeap.offer(new int[]{nums1[0] + nums2[0], 0, 0});\\n        visited.add(new Pair<Integer, Integer>(0, 0));\\n\\n        while (k-- > 0 && !minHeap.isEmpty()) {\\n            int[] top = minHeap.poll();\\n            int i = top[1];\\n            int j = top[2];\\n\\n            ans.add(List.of(nums1[i], nums2[j]));\\n\\n            if (i + 1 < m && !visited.contains(new Pair<Integer, Integer>(i + 1, j))) {\\n                minHeap.offer(new int[]{nums1[i + 1] + nums2[j], i + 1, j});\\n                visited.add(new Pair<Integer, Integer>(i + 1, j));\\n            }\\n\\n            if (j + 1 < n && !visited.contains(new Pair<Integer, Integer>(i, j + 1))) {\\n                minHeap.offer(new int[]{nums1[i] + nums2[j + 1], i, j + 1});\\n                visited.add(new Pair<Integer, Integer>(i, j + 1));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n\\n        vector<vector<int>> ans;\\n        set<pair<int, int>> visited;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>,\\n                       greater<pair<int, pair<int, int>>>> minHeap;\\n        minHeap.push({nums1[0] + nums2[0], {0, 0}});\\n        visited.insert({0, 0});\\n\\n        while (k-- && !minHeap.empty()) {\\n            auto top = minHeap.top();\\n            minHeap.pop();\\n            int i = top.second.first;\\n            int j = top.second.second;\\n\\n            ans.push_back({nums1[i], nums2[j]});\\n\\n            if (i + 1 < m && visited.find({i + 1, j}) == visited.end()) {\\n                minHeap.push({nums1[i + 1] + nums2[j], {i + 1, j}});\\n                visited.insert({i + 1, j});\\n            }\\n\\n            if (j + 1 < n && visited.find({i, j + 1}) == visited.end()) {\\n                minHeap.push({nums1[i] + nums2[j + 1], {i, j + 1}});\\n                visited.insert({i, j + 1});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250461,
                "title": "373-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem asks to find the k pairs of numbers, one from nums1 and one from nums2, that have the smallest sum. The arrays nums1 and nums2 are sorted in ascending order.\\n\\nThe algorithm uses a heap to keep track of the smallest sums of pairs that haven\\'t been added to the result list yet. The heap contains tuples of the form (sum, num1, num2, i, j), where sum is the sum of num1 and num2, i and j are the indices of num1 and num2 in their respective arrays, and num1 and num2 are the actual numbers in the pairs.\\n\\nThe algorithm starts by initializing the heap with the first pair, (nums1[0]+nums2[0], nums1[0], nums2[0], 0, 0), and marking (0, 0) as visited in a set.\\n\\nThen, the algorithm enters a loop that continues until either the heap is empty or k pairs have been added to the result list. In each iteration, the algorithm pops the smallest sum pair from the heap and adds it to the result list.\\n\\nThen, the algorithm checks if it can generate new pairs by incrementing either i or j. If i can be incremented (i.e. i < len(nums1)-1) and (i+1, j) hasn\\'t been visited yet, then the algorithm generates a new pair with num1=nums1[i+1] and num2=nums2[j], adds it to the heap with the corresponding sum, and marks (i+1, j) as visited. If j can be incremented (i.e. j < len(nums2)-1) and (i, j+1) hasn\\'t been visited yet, then the algorithm generates a new pair with num1=nums1[i] and num2=nums2[j+1], adds it to the heap with the corresponding sum, and marks (i, j+1) as visited.\\n\\nFinally, the algorithm returns the result list containing the k smallest sum pairs.\\n\\n# Complexity\\n- Time complexity:\\n81.2%\\n\\n- Space complexity:\\n73.43%\\n\\n# Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        heap = [(nums1[0] + nums2[0], nums1[0], nums2[0], 0, 0)]\\n        visited = set((0, 0))\\n        result = []\\n        \\n        while heap and len(result) < k:\\n            _, num1, num2, i, j = heapq.heappop(heap)\\n            result.append([num1, num2])\\n            \\n            if i < len(nums1) - 1 and (i+1, j) not in visited:\\n                heapq.heappush(heap, (nums1[i+1] + nums2[j], nums1[i+1], nums2[j], i+1, j))\\n                visited.add((i+1, j))\\n                \\n            if j < len(nums2) - 1 and (i, j+1) not in visited:\\n                heapq.heappush(heap, (nums1[i] + nums2[j+1], nums1[i], nums2[j+1], i, j+1))\\n                visited.add((i, j+1))\\n                \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        heap = [(nums1[0] + nums2[0], nums1[0], nums2[0], 0, 0)]\\n        visited = set((0, 0))\\n        result = []\\n        \\n        while heap and len(result) < k:\\n            _, num1, num2, i, j = heapq.heappop(heap)\\n            result.append([num1, num2])\\n            \\n            if i < len(nums1) - 1 and (i+1, j) not in visited:\\n                heapq.heappush(heap, (nums1[i+1] + nums2[j], nums1[i+1], nums2[j], i+1, j))\\n                visited.add((i+1, j))\\n                \\n            if j < len(nums2) - 1 and (i, j+1) not in visited:\\n                heapq.heappush(heap, (nums1[i] + nums2[j+1], nums1[i], nums2[j+1], i, j+1))\\n                visited.add((i, j+1))\\n                \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951510,
                "title": "intuitive-python-explanation-with-drawn-example-similar-to-merge-k-lists",
                "content": "![image](https://assets.leetcode.com/users/images/43ce161b-0fae-46ff-8496-0f68a60a1641_1650076397.02167.jpeg)\\n\\nVery similar to \"Merge K Lists\", but we stop after the Kth pair, or the list is exhausted.\\n\\n\\n```\\n        m = len(nums1)\\n        n = len(nums2)\\n\\t\\t# i.e. competition producing smallest sum\\n        comp = []\\n        result = []\\n        \\n        def addToComp(i,j):\\n            if i < m and j < n:\\n                heapq.heappush(comp, (nums1[i] + nums2[j], i, j))\\n        \\n        for i in range(m):\\n            heapq.heappush(comp, (nums1[i] + nums2[0], i, 0))\\n            \\n        while len(result) < k and comp:\\n            _, i, j = heapq.heappop(comp)\\n            result.append([nums1[i], nums2[j]])\\n            addToComp(i, j+1)\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        m = len(nums1)\\n        n = len(nums2)\\n\\t\\t# i.e. competition producing smallest sum\\n        comp = []\\n        result = []\\n        \\n        def addToComp(i,j):\\n            if i < m and j < n:\\n                heapq.heappush(comp, (nums1[i] + nums2[j], i, j))\\n        \\n        for i in range(m):\\n            heapq.heappush(comp, (nums1[i] + nums2[0], i, 0))\\n            \\n        while len(result) < k and comp:\\n            _, i, j = heapq.heappop(comp)\\n            result.append([nums1[i], nums2[j]])\\n            addToComp(i, j+1)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1296815,
                "title": "c-priority-queue",
                "content": "Runtime: 4 ms, faster than 98.84% of C++ online submissions for Find K Pairs with Smallest Sums.\\nMemory Usage: 9.1 MB, less than 87.66% of C++ online submissions for Find K Pairs with Smallest Sums.\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> ppii;\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> result;\\n        priority_queue<ppii,vector<ppii>, greater<ppii>> pq;\\n\\t\\t//sum , indices\\n        for(int i=0;i<nums1.size();i++) {\\n            pq.push({nums1[i]+nums2[0], {i,0}});\\n        }        \\n        while(!pq.empty() && k--){\\n            int i = pq.top().second.first;\\n            int j = pq.top().second.second;\\n            pq.pop();\\n            result.push_back({nums1[i],nums2[j]});\\n            if(j+1==nums2.size())\\n                continue;\\n            pq.push({nums1[i]+nums2[j+1] , {i,j+1}});\\n        }\\n        return result;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> ppii;\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> result;\\n        priority_queue<ppii,vector<ppii>, greater<ppii>> pq;\\n\\t\\t//sum , indices\\n        for(int i=0;i<nums1.size();i++) {\\n            pq.push({nums1[i]+nums2[0], {i,0}});\\n        }        \\n        while(!pq.empty() && k--){\\n            int i = pq.top().second.first;\\n            int j = pq.top().second.second;\\n            pq.pop();\\n            result.push_back({nums1[i],nums2[j]});\\n            if(j+1==nums2.size())\\n                continue;\\n            pq.push({nums1[i]+nums2[j+1] , {i,j+1}});\\n        }\\n        return result;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103290,
                "title": "python-7-line-simple-heap-36-ms",
                "content": "* create a **heap** to store (sum, num1, num2)\\n* only for loop the first k numbers in **nums1**, also shrink **nums2** depending on the index of num1\\n```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        if not nums2 or not nums1: return []\\n        heap = []\\n        heapq.heapify(heap)\\n        for i, num1 in enumerate(nums1[:k]):\\n            for num2 in nums2[:k//(i+1)]:\\n                heapq.heappush(heap, [num1+num2, num1, num2])\\n        return [x[1:] for x in heapq.nsmallest(k, heap)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        if not nums2 or not nums1: return []\\n        heap = []\\n        heapq.heapify(heap)\\n        for i, num1 in enumerate(nums1[:k]):\\n            for num2 in nums2[:k//(i+1)]:\\n                heapq.heappush(heap, [num1+num2, num1, num2])\\n        return [x[1:] for x in heapq.nsmallest(k, heap)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128291,
                "title": "java-heap-with-explanations",
                "content": "**Logical Thinking**\\n```\\nFor example,\\n1 2 3\\n4 5 6\\n\\n[1, 4] = i++ => [2, 4]  = i++ => [3, 4] \\n                        = j++ => [2, 5] duplicated\\n       = j++ => [1, 5] = j++ => [1, 6] \\n\\t                   = i++ => [2, 5] duplicated\\n\\ni++ only if j = 0 can avoid duplicates\\nj++ only if i == 0 can also avoid duplicates\\n```\\n\\n****\\n```\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> kPairs = new ArrayList<>();\\n        int len1 = nums1.length, len2 = nums2.length;\\n        if (len1 == 0 || len2 == 0)\\n            return kPairs;\\n        \\n        // Min heap of indices of u, v.\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) ->                                             Integer.compare(nums1[a[0]] + nums2[a[1]], nums1[b[0]] + nums2[b[1]]));\\n        minHeap.add(new int[]{0, 0});\\n        \\n        while (k-- > 0 && !minHeap.isEmpty()) {\\n            int[] pair = minHeap.poll();\\n            kPairs.add(new int[]{nums1[pair[0]], nums2[pair[1]]});\\n            if (pair[0] + 1 < len1)\\n                minHeap.add(new int[]{pair[0] + 1, pair[1]});\\n            if (pair[0] == 0 && pair[1] + 1 < len2)\\n                minHeap.add(new int[]{pair[0], pair[1] + 1});\\n        }\\n        \\n        return kPairs;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nFor example,\\n1 2 3\\n4 5 6\\n\\n[1, 4] = i++ => [2, 4]  = i++ => [3, 4] \\n                        = j++ => [2, 5] duplicated\\n       = j++ => [1, 5] = j++ => [1, 6] \\n\\t                   = i++ => [2, 5] duplicated\\n\\ni++ only if j = 0 can avoid duplicates\\nj++ only if i == 0 can also avoid duplicates\\n```\n```\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> kPairs = new ArrayList<>();\\n        int len1 = nums1.length, len2 = nums2.length;\\n        if (len1 == 0 || len2 == 0)\\n            return kPairs;\\n        \\n        // Min heap of indices of u, v.\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) ->                                             Integer.compare(nums1[a[0]] + nums2[a[1]], nums1[b[0]] + nums2[b[1]]));\\n        minHeap.add(new int[]{0, 0});\\n        \\n        while (k-- > 0 && !minHeap.isEmpty()) {\\n            int[] pair = minHeap.poll();\\n            kPairs.add(new int[]{nums1[pair[0]], nums2[pair[1]]});\\n            if (pair[0] + 1 < len1)\\n                minHeap.add(new int[]{pair[0] + 1, pair[1]});\\n            if (pair[0] == 0 && pair[1] + 1 < len2)\\n                minHeap.add(new int[]{pair[0], pair[1] + 1});\\n        }\\n        \\n        return kPairs;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3689234,
                "title": "easy-java-python-c",
                "content": "# *Code*\\n```java []\\nclass Pair{\\n    int idx1 = 0;\\n    int idx2 = 0;\\n    int sum = 0;\\n    Pair(int idx1,int idx2,int sum)\\n    {\\n        this.idx1 = idx1;\\n        this.idx2 = idx2;\\n        this.sum = sum;\\n    }\\n}\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n       List<List<Integer>> result = new ArrayList<>();\\n       PriorityQueue<Pair> pq = new PriorityQueue<>((a,b)->a.sum-b.sum);\\n       for(int i = 0;i<nums1.length;i++)\\n       {\\n           pq.offer(new Pair(i,0,nums1[i]+nums2[0]));\\n       }\\n       while(pq.size() > 0 && result.size() < k)\\n       {\\n           int i = pq.peek().idx1;\\n           int j = pq.peek().idx2;\\n           pq.remove();\\n           result.add(Arrays.asList(nums1[i],nums2[j]));\\n           if(j < nums2.length-1)\\n                pq.offer(new Pair(i,j+1,nums1[i]+nums2[j+1]));\\n       }\\n       return result; \\n    }\\n}\\n```\\n```python []\\nimport heapq\\n\\nclass Pair:\\n    def __init__(self, idx1, idx2, sum):\\n        self.idx1 = idx1\\n        self.idx2 = idx2\\n        self.sum = sum\\n\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        result = []\\n        pq = []\\n        heapq.heapify(pq)\\n        for i in range(len(nums1)):\\n            heapq.heappush(pq, Pair(i, 0, nums1[i]+nums2[0]))\\n        while pq and len(result) < k:\\n            p = heapq.heappop(pq)\\n            i = p.idx1\\n            j = p.idx2\\n            result.append([nums1[i], nums2[j]])\\n            if j < len(nums2)-1:\\n                heapq.heappush(pq, Pair(i, j+1, nums1[i]+nums2[j+1]))\\n        return result\\n\\n\\n```\\n```C++ []\\nclass Pair{\\n    int idx1 = 0;\\n    int idx2 = 0;\\n    int sum = 0;\\n    Pair(int idx1,int idx2,int sum)\\n    {\\n        this->idx1 = idx1;\\n        this->idx2 = idx2;\\n        this->sum = sum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n       vector<vector<int>> result;\\n       priority_queue<Pair, vector<Pair>, function<bool(Pair, Pair)>> pq([](Pair a, Pair b){return a.sum > b.sum;});\\n       for(int i = 0;i<nums1.size();i++)\\n       {\\n           pq.push(Pair(i,0,nums1[i]+nums2[0]));\\n       }\\n       while(pq.size() > 0 && result.size() < k)\\n       {\\n           int i = pq.top().idx1;\\n           int j = pq.top().idx2;\\n           pq.pop();\\n           result.push_back({nums1[i],nums2[j]});\\n           if(j < nums2.size()-1)\\n                pq.push(Pair(i,j+1,nums1[i]+nums2[j+1]));\\n       }\\n       return result; \\n    }\\n};\\n\\n```\\n---\\n### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```java []\\nclass Pair{\\n    int idx1 = 0;\\n    int idx2 = 0;\\n    int sum = 0;\\n    Pair(int idx1,int idx2,int sum)\\n    {\\n        this.idx1 = idx1;\\n        this.idx2 = idx2;\\n        this.sum = sum;\\n    }\\n}\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n       List<List<Integer>> result = new ArrayList<>();\\n       PriorityQueue<Pair> pq = new PriorityQueue<>((a,b)->a.sum-b.sum);\\n       for(int i = 0;i<nums1.length;i++)\\n       {\\n           pq.offer(new Pair(i,0,nums1[i]+nums2[0]));\\n       }\\n       while(pq.size() > 0 && result.size() < k)\\n       {\\n           int i = pq.peek().idx1;\\n           int j = pq.peek().idx2;\\n           pq.remove();\\n           result.add(Arrays.asList(nums1[i],nums2[j]));\\n           if(j < nums2.length-1)\\n                pq.offer(new Pair(i,j+1,nums1[i]+nums2[j+1]));\\n       }\\n       return result; \\n    }\\n}\\n```\n```python []\\nimport heapq\\n\\nclass Pair:\\n    def __init__(self, idx1, idx2, sum):\\n        self.idx1 = idx1\\n        self.idx2 = idx2\\n        self.sum = sum\\n\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        result = []\\n        pq = []\\n        heapq.heapify(pq)\\n        for i in range(len(nums1)):\\n            heapq.heappush(pq, Pair(i, 0, nums1[i]+nums2[0]))\\n        while pq and len(result) < k:\\n            p = heapq.heappop(pq)\\n            i = p.idx1\\n            j = p.idx2\\n            result.append([nums1[i], nums2[j]])\\n            if j < len(nums2)-1:\\n                heapq.heappush(pq, Pair(i, j+1, nums1[i]+nums2[j+1]))\\n        return result\\n\\n\\n```\n```C++ []\\nclass Pair{\\n    int idx1 = 0;\\n    int idx2 = 0;\\n    int sum = 0;\\n    Pair(int idx1,int idx2,int sum)\\n    {\\n        this->idx1 = idx1;\\n        this->idx2 = idx2;\\n        this->sum = sum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n       vector<vector<int>> result;\\n       priority_queue<Pair, vector<Pair>, function<bool(Pair, Pair)>> pq([](Pair a, Pair b){return a.sum > b.sum;});\\n       for(int i = 0;i<nums1.size();i++)\\n       {\\n           pq.push(Pair(i,0,nums1[i]+nums2[0]));\\n       }\\n       while(pq.size() > 0 && result.size() < k)\\n       {\\n           int i = pq.top().idx1;\\n           int j = pq.top().idx2;\\n           pq.pop();\\n           result.push_back({nums1[i],nums2[j]});\\n           if(j < nums2.size()-1)\\n                pq.push(Pair(i,j+1,nums1[i]+nums2[j+1]));\\n       }\\n       return result; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687922,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nIn the problem, we need to return the k pairs with the smallest sums. Whenever we need to return a specific amount of numbers in any order (ascending or descending), we use priority queue.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe given approach is as follows:\\n\\n1) First, we initialize an empty priority queue (pq) to store the pairs based on their sums.\\n2) Next, we iterate through each element in nums1 and nums2 to generate all possible pairs.\\n3) Then, we calculate the sum of each pair and insert it along with the pair itself into the priority queue pq.\\n4) But if the size of pq is greater than k, we remove the pair with the largest sum from pq.\\n5) Atlast, when the iteration is complete, we extract the pairs from pq in descending order and store them in the ans vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m* n*log(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ans;\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                int sum=nums1[i]+nums2[j];\\n                if(pq.size()<k) pq.push({sum,{nums1[i],nums2[j]}});\\n                else if(sum<pq.top().first){\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                } else break;\\n            }\\n        }\\n        while(!pq.empty()){\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ans;\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                int sum=nums1[i]+nums2[j];\\n                if(pq.size()<k) pq.push({sum,{nums1[i],nums2[j]}});\\n                else if(sum<pq.top().first){\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                } else break;\\n            }\\n        }\\n        while(!pq.empty()){\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506937,
                "title": "c-solution-with-priority-queue",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k)\\n    {\\n        var r = new List<IList<int>>(k);\\n\\n        var pq = new PriorityQueue<(int, int), int>(\\n            k + 1, Comparer<int>.Create((x, y) => y - x));\\n\\n        int maxPriority = int.MaxValue;\\n\\n        foreach (var n1 in nums1)\\n        {\\n            foreach (var n2 in nums2)\\n            {\\n                var pr = n1 + n2;\\n\\n                if (pr < maxPriority)\\n                {\\n                    pq.Enqueue((n1, n2), pr);\\n\\n                    if (pq.Count > k)\\n                        pq.TryDequeue(out _, out maxPriority);\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        while (pq.Count > 0)\\n        {\\n            var (a, b) = pq.Dequeue();\\n\\n            r.Add(new[] { a, b });\\n        }\\n\\n        return r;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k)\\n    {\\n        var r = new List<IList<int>>(k);\\n\\n        var pq = new PriorityQueue<(int, int), int>(\\n            k + 1, Comparer<int>.Create((x, y) => y - x));\\n\\n        int maxPriority = int.MaxValue;\\n\\n        foreach (var n1 in nums1)\\n        {\\n            foreach (var n2 in nums2)\\n            {\\n                var pr = n1 + n2;\\n\\n                if (pr < maxPriority)\\n                {\\n                    pq.Enqueue((n1, n2), pr);\\n\\n                    if (pq.Count > k)\\n                        pq.TryDequeue(out _, out maxPriority);\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        while (pq.Count > 0)\\n        {\\n            var (a, b) = pq.Dequeue();\\n\\n            r.Add(new[] { a, b });\\n        }\\n\\n        return r;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154065,
                "title": "c-100-simple-solution-heap",
                "content": "```\\nclass solve\\n{\\n    public:\\n    int val,i,j;\\n    \\n    solve(int va,int ii,int jj)\\n    {\\n        val=va;\\n        i=ii;\\n        j=jj;\\n    }\\n    \\n};\\n\\nstruct cmp{\\n    bool operator()(solve s1,solve s2)\\n    {\\n        return s1.val>s2.val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    // bool cmp()(solve s1,solve s2)\\n    // {\\n    //     return s1.val<s2.val;\\n    // }\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n=nums1.size(),m=nums2.size();\\n        priority_queue<solve,vector<solve>,cmp> q;\\n        \\n        q.push(solve(nums1[0]+nums2[0],0,0));\\n        \\n        set<pair<int,int>> s;\\n        \\n        s.insert({0,0});\\n        \\n        vector<vector<int>> ans;\\n        while(ans.size()!=k&&!q.empty())\\n        {\\n            solve top=q.top();\\n            q.pop();\\n            \\n            int i=top.i,j=top.j;\\n            ans.push_back({nums1[i],nums2[j]});\\n            \\n            if(i<n-1&&s.count({i+1,j})==0)\\n            {\\n                q.push(solve(nums1[i+1]+nums2[j],i+1,j)); \\n                s.insert({i+1,j});\\n            }\\n            if(j<m-1&&s.count({i,j+1})==0)\\n            {\\n                q.push(solve(nums1[i]+nums2[j+1],i,j+1));\\n                s.insert({i,j+1});\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass solve\\n{\\n    public:\\n    int val,i,j;\\n    \\n    solve(int va,int ii,int jj)\\n    {\\n        val=va;\\n        i=ii;\\n        j=jj;\\n    }\\n    \\n};\\n\\nstruct cmp{\\n    bool operator()(solve s1,solve s2)\\n    {\\n        return s1.val>s2.val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    // bool cmp()(solve s1,solve s2)\\n    // {\\n    //     return s1.val<s2.val;\\n    // }\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n=nums1.size(),m=nums2.size();\\n        priority_queue<solve,vector<solve>,cmp> q;\\n        \\n        q.push(solve(nums1[0]+nums2[0],0,0));\\n        \\n        set<pair<int,int>> s;\\n        \\n        s.insert({0,0});\\n        \\n        vector<vector<int>> ans;\\n        while(ans.size()!=k&&!q.empty())\\n        {\\n            solve top=q.top();\\n            q.pop();\\n            \\n            int i=top.i,j=top.j;\\n            ans.push_back({nums1[i],nums2[j]});\\n            \\n            if(i<n-1&&s.count({i+1,j})==0)\\n            {\\n                q.push(solve(nums1[i+1]+nums2[j],i+1,j)); \\n                s.insert({i+1,j});\\n            }\\n            if(j<m-1&&s.count({i,j+1})==0)\\n            {\\n                q.push(solve(nums1[i]+nums2[j+1],i,j+1));\\n                s.insert({i,j+1});\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017151,
                "title": "c-priority-queue-solution",
                "content": "**Approach 1**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        vector<vector<int>> ans;\\n        \\n        for(auto num1 :nums1)\\n        {\\n            for(auto num2:nums2)\\n            {\\n                int sum = num1 + num2;\\n                \\n                if(pq.size() < k)\\n                    pq.push({sum , {num1 , num2}});\\n                else if(sum < pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({sum , {num1 , num2}});\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        \\n        while(pq.size())\\n        {\\n            ans.push_back({pq.top().second.first , pq.top().second.second});\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\nTC : O(n1 * n2 * logK)\\nSC : O(K)\\n\\n**Approach 2**\\n```\\nclass Solution {\\npublic:\\n    \\n#define ppi pair<int,pair<int,int>> \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<ppi , vector<ppi> , greater<ppi> > pq;\\n        vector<vector<int>> ans;\\n        int n1 = nums1.size() , n2 = nums2.size();\\n        \\n        set<pair<int,int>> vis;\\n        \\n        pq.push({nums1[0] + nums2[0] , {0,0}});\\n        \\n        while(pq.size() && k--)\\n        {\\n            int i = pq.top().second.first;\\n            int j = pq.top().second.second;\\n            pq.pop();\\n            \\n            ans.push_back({nums1[i] , nums2[j]});\\n            \\n            if(i+1 < n1 && vis.find({i+1 , j}) == vis.end())\\n            {\\n                int sum = nums1[i+1] + nums2[j];\\n                pq.push({sum , {i+1 , j}});\\n                vis.insert({i+1 , j});\\n            }\\n            \\n            if(j+1 < n2 && vis.find({i , j+1}) == vis.end())\\n            {\\n                int sum = nums1[i] + nums2[j+1];\\n                pq.push({sum , {i , j+1}});\\n                vis.insert({i ,j+1});\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\nTC : O(K * logK)\\nSC :O(K) + O(N) (for set)\\n\\n**Approach 3**\\n```\\nclass Solution {\\npublic:\\n    \\n#define ppi pair<int,pair<int,int>> \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<ppi , vector<ppi> , greater<ppi> > pq;\\n        vector<vector<int>> ans;\\n        int n1 = nums1.size() , n2 = nums2.size();\\n        \\n        \\n        pq.push({nums1[0] + nums2[0] , {0,0}});\\n        \\n        while(pq.size() && k--)\\n        {\\n            int i = pq.top().second.first;\\n            int j = pq.top().second.second;\\n            pq.pop();\\n            \\n            ans.push_back({nums1[i] , nums2[j]});\\n            \\n            if(i+1 < n1 )\\n            {\\n                int sum = nums1[i+1] + nums2[j];\\n                pq.push({sum , {i+1 , j}});\\n            }\\n            \\n            if(i==0 && j+1 < n2)\\n            {\\n                int sum = nums1[i] + nums2[j+1];\\n                pq.push({sum , {i , j+1}});\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nTC : O(K * logK)\\nSC : O(K)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        vector<vector<int>> ans;\\n        \\n        for(auto num1 :nums1)\\n        {\\n            for(auto num2:nums2)\\n            {\\n                int sum = num1 + num2;\\n                \\n                if(pq.size() < k)\\n                    pq.push({sum , {num1 , num2}});\\n                else if(sum < pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({sum , {num1 , num2}});\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        \\n        while(pq.size())\\n        {\\n            ans.push_back({pq.top().second.first , pq.top().second.second});\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n#define ppi pair<int,pair<int,int>> \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<ppi , vector<ppi> , greater<ppi> > pq;\\n        vector<vector<int>> ans;\\n        int n1 = nums1.size() , n2 = nums2.size();\\n        \\n        set<pair<int,int>> vis;\\n        \\n        pq.push({nums1[0] + nums2[0] , {0,0}});\\n        \\n        while(pq.size() && k--)\\n        {\\n            int i = pq.top().second.first;\\n            int j = pq.top().second.second;\\n            pq.pop();\\n            \\n            ans.push_back({nums1[i] , nums2[j]});\\n            \\n            if(i+1 < n1 && vis.find({i+1 , j}) == vis.end())\\n            {\\n                int sum = nums1[i+1] + nums2[j];\\n                pq.push({sum , {i+1 , j}});\\n                vis.insert({i+1 , j});\\n            }\\n            \\n            if(j+1 < n2 && vis.find({i , j+1}) == vis.end())\\n            {\\n                int sum = nums1[i] + nums2[j+1];\\n                pq.push({sum , {i , j+1}});\\n                vis.insert({i ,j+1});\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n#define ppi pair<int,pair<int,int>> \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<ppi , vector<ppi> , greater<ppi> > pq;\\n        vector<vector<int>> ans;\\n        int n1 = nums1.size() , n2 = nums2.size();\\n        \\n        \\n        pq.push({nums1[0] + nums2[0] , {0,0}});\\n        \\n        while(pq.size() && k--)\\n        {\\n            int i = pq.top().second.first;\\n            int j = pq.top().second.second;\\n            pq.pop();\\n            \\n            ans.push_back({nums1[i] , nums2[j]});\\n            \\n            if(i+1 < n1 )\\n            {\\n                int sum = nums1[i+1] + nums2[j];\\n                pq.push({sum , {i+1 , j}});\\n            }\\n            \\n            if(i==0 && j+1 < n2)\\n            {\\n                int sum = nums1[i] + nums2[j+1];\\n                pq.push({sum , {i , j+1}});\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949745,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Min Heap***\\n\\n* ***Time Complexity : O(KlogK)***\\n* ***Space Complexity : O(K)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        vector<vector<int>> res;\\n        \\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        \\n        for(int i = 0; i < k && i < n1; i++)\\n        {\\n            pq.push({nums1[i] + nums2[0], {i, 0}});\\n        }\\n        \\n        while(!pq.empty() && k--)\\n        {\\n            auto curr = pq.top();\\n            \\n            pq.pop();\\n            \\n            int i = curr.second.first;\\n            \\n            int j = curr.second.second;\\n            \\n            res.push_back({nums1[i], nums2[j]});\\n            \\n            if(j + 1 < n2)\\n            {\\n                pq.push({nums1[i] + nums2[j + 1], {i, j + 1}});\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n1 = nums1.size();\\n        \\n        int n2 = nums2.size();\\n        \\n        vector<vector<int>> res;\\n        \\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        \\n        for(int i = 0; i < k && i < n1; i++)\\n        {\\n            pq.push({nums1[i] + nums2[0], {i, 0}});\\n        }\\n        \\n        while(!pq.empty() && k--)\\n        {\\n            auto curr = pq.top();\\n            \\n            pq.pop();\\n            \\n            int i = curr.second.first;\\n            \\n            int j = curr.second.second;\\n            \\n            res.push_back({nums1[i], nums2[j]});\\n            \\n            if(j + 1 < n2)\\n            {\\n                pq.push({nums1[i] + nums2[j + 1], {i, j + 1}});\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461356,
                "title": "just-include-a-break-statement-and-bazzinga",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        int i,j,n1=nums1.size(),n2=nums2.size();\\n        for(i=0;i<n1;i++)\\n        {\\n            for(j=0;j<n2;j++)\\n            {\\n                if(pq.size()<k)\\n                {\\n                   pq.push(make_pair(nums1[i]+nums2[j],make_pair(nums1[i],nums2[j])));\\n                    \\n                }\\n                else{\\n                    if((nums1[i]+nums2[j])<pq.top().first)\\n                    {\\n                        pq.pop();\\n                        pq.push(make_pair(nums1[i]+nums2[j],make_pair(nums1[i],nums2[j])));\\n                    }\\n                    else\\n                        break;//*_*See here if you not add break then sure TLE!,please upvote*_*\\n                }\\n            }\\n        }\\n        vector<vector<int>> v;\\n        while(!pq.empty())\\n        {\\n            v.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        reverse(v.begin(),v.end());\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        int i,j,n1=nums1.size(),n2=nums2.size();\\n        for(i=0;i<n1;i++)\\n        {\\n            for(j=0;j<n2;j++)\\n            {\\n                if(pq.size()<k)\\n                {\\n                   pq.push(make_pair(nums1[i]+nums2[j],make_pair(nums1[i],nums2[j])));\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1307125,
                "title": "python-priority-queue-with-visited-set-complexity-explained",
                "content": "Time complexity: O(KlgK)\\nSpace complexity: O(k)\\n\\nExplanation: We loop over K times each time adding a max of 2 items in each iteration --> hence total number of items added = 2k. The max time of each addition to heap is log(size of heap) which has a theoratical max of 2k number of items. Hence time complexity is O(klgk). \\n\\nSpace complexity is the space of the heap --> O(K)\\n~~~\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        ans = []\\n        heap = []\\n        heappush(heap,(0,0,0))\\n        visited = set([(0,0)])\\n        for _ in range(k):\\n            if heap:\\n                _ , ix1, ix2 = heappop(heap)\\n                ans.append([nums1[ix1],nums2[ix2]])\\n\\n                for new_ix1 , new_ix2 in [[ix1+1,ix2],[ix1,ix2+1]]:\\n                    if 0<=new_ix1 < len(nums1) and 0<=new_ix2<len(nums2)  and (new_ix1,new_ix2) not in visited:\\n                        total_sum = nums1[new_ix1] + nums2[new_ix2]\\n                        heappush(heap,(total_sum,new_ix1,new_ix2) )\\n                        visited.add((new_ix1,new_ix2))\\n        return ans\\n~~~",
                "solutionTags": [
                    "Python"
                ],
                "code": "Time complexity: O(KlgK)\\nSpace complexity: O(k)\\n\\nExplanation: We loop over K times each time adding a max of 2 items in each iteration --> hence total number of items added = 2k. The max time of each addition to heap is log(size of heap) which has a theoratical max of 2k number of items. Hence time complexity is O(klgk). \\n\\nSpace complexity is the space of the heap --> O(K)\\n~~~\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        ans = []\\n        heap = []\\n        heappush(heap,(0,0,0))\\n        visited = set([(0,0)])\\n        for _ in range(k):\\n            if heap:\\n                _ , ix1, ix2 = heappop(heap)\\n                ans.append([nums1[ix1],nums2[ix2]])\\n\\n                for new_ix1 , new_ix2 in [[ix1+1,ix2],[ix1,ix2+1]]:\\n                    if 0<=new_ix1 < len(nums1) and 0<=new_ix2<len(nums2)  and (new_ix1,new_ix2) not in visited:\\n                        total_sum = nums1[new_ix1] + nums2[new_ix2]\\n                        heappush(heap,(total_sum,new_ix1,new_ix2) )\\n                        visited.add((new_ix1,new_ix2))\\n        return ans\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 1177688,
                "title": "python-java-solution-using-heap-94",
                "content": "# Using Heap. \\nSize of nums1 - l1\\nSize of nums2 - l2\\nn = max(l1, l2)\\n\\n* Time Complexity - O(k*logn)\\n* Space Complexity - O(n)\\n\\n1. Create a list of entry pair tuple \"(sum , (index of nums1, index of nums2))\" from all the elements of nums1 with the first element of nums2.\\n2. Heapify the list in linear time. Size will be O(n).\\n3. Pop, append to answer, and push the pair (index of nums1, index of nums2 +1) to heap. We don\\'t push if the pointer of nums2 exceeds the length of list.\\n4. Repeat step 3 for k times.\\n\\n# Python\\ndef fun(self, nums1, nums2, k):\\n\\n\\t\\theap = [(nums1[i]+nums2[0], (i, 0)) for i in range(len(nums1)) ]        \\n        heapq.heapify(heap)\\n\\t\\tans = []\\n\\t\\t\\n\\t\\twhile k>0 and len(heap)>0:\\n            t = heapq.heappop(heap)            \\n            ti, tj = t[1][0], t[1][1]\\n            ans.append([nums1[ti], nums2[tj]])\\n            if tj<len(nums2)-1:\\n                heapq.heappush(heap, (nums1[ti]+nums2[tj+1], (ti,tj+1)))\\n            k-=1\\n        return ans\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n# Java\\n\\nclass Solution {\\n    \\n\\tclass Node{\\n        int sum, i, j;\\n        Node(int sum, int i, int j){\\n            this.sum = sum;\\n            this.i = i;\\n            this.j = j;\\n        }        \\n    }\\n    \\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<Node> q = new PriorityQueue<>((n1, n2)->n1.sum-n2.sum);\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            q.offer(new Node(nums1[i]+nums2[0], i, 0));        \\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        while(k>0 && !q.isEmpty()){\\n            Node val = q.poll();\\n            List<Integer> list = new ArrayList<>();\\n            list.add(nums1[val.i]);\\n            list.add(nums2[val.j]);\\n            ans.add(list);\\n            if(val.j<nums2.length-1){\\n                q.offer(new Node(nums1[val.i]+nums2[val.j+1], val.i, val.j+1));                \\n            }\\n            k-=1;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    \\n\\tclass Node{\\n        int sum, i, j;\\n        Node(int sum, int i, int j){\\n            this.sum = sum;\\n            this.i = i;\\n            this.j = j;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1177409,
                "title": "trick-to-solve-any-heap-problem-easily",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // THERE IS A FORMULA TO SOLVE ALL HEAPS QUESTION,IF THE QUES ASKED TO FIND SMALLEST, USE MAX HEAP OR IF ASKED LARGEST/BIGGEST, USE MIN HEAP AND THAT\\'S IT\\n\\n         // make heap of pairs, push values, pop it when size > k\\n        // in the end, pop all values and psh it in a vector\\n        \\n        // notice the pair carefully, it\\'s a pair within a pair, it\\'s like pair<totalSum,<nums1,num2>>\\n        priority_queue<pair<int,pair<int,int>>> maxHeap; \\n\\n        \\n        \\n        // run double for loop to create all pairs,and push values based on the sum values\\n        for(int i=0;i<nums1.size();i++) {\\n            for(int j=0;j<nums2.size();j++) {\\n                int sum=nums1[i]+nums2[j]; // find totalsum\\n                maxHeap.push({sum,{nums1[i],nums2[j]}}); // ALWAYS PUSH BEFORE POPPING\\n                if(maxHeap.size()>k) { // once the size > k, since it\\'s a maxheap, the biggest sum pair will be popped of, since we are popping the top value, the maxheap always acts on the first data structure by default, our first value in the heap was an int, which was the sum of nums1 and nums2, so if a sum is high, it will come on top of heap and will get popped\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n        \\n        // once we are out of this loop, we are only left with k elements,whch u can simply push it in a vector\\n        vector<vector<int>> res;\\n        while(!maxHeap.empty()) {\\n            res.push_back({maxHeap.top().second.first,maxHeap.top().second.second}); // this is the way to push pairs into a vector, notice the {}, vectors are pushed in that way, just enclose nuumbers in {} in the push_back function\\n            // maxHeap.top().second.first means, pair\\'s top\\'s value\\'s second\\'s part\\'s first value\\n            // pair<totalSum,<nums1,num2>> got teh idea?.\\n            maxHeap.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // THERE IS A FORMULA TO SOLVE ALL HEAPS QUESTION,IF THE QUES ASKED TO FIND SMALLEST, USE MAX HEAP OR IF ASKED LARGEST/BIGGEST, USE MIN HEAP AND THAT\\'S IT\\n\\n         // make heap of pairs, push values, pop it when size > k\\n        // in the end, pop all values and psh it in a vector\\n        \\n        // notice the pair carefully, it\\'s a pair within a pair, it\\'s like pair<totalSum,<nums1,num2>>\\n        priority_queue<pair<int,pair<int,int>>> maxHeap; \\n\\n        \\n        \\n        // run double for loop to create all pairs,and push values based on the sum values\\n        for(int i=0;i<nums1.size();i++) {\\n            for(int j=0;j<nums2.size();j++) {\\n                int sum=nums1[i]+nums2[j]; // find totalsum\\n                maxHeap.push({sum,{nums1[i],nums2[j]}}); // ALWAYS PUSH BEFORE POPPING\\n                if(maxHeap.size()>k) { // once the size > k, since it\\'s a maxheap, the biggest sum pair will be popped of, since we are popping the top value, the maxheap always acts on the first data structure by default, our first value in the heap was an int, which was the sum of nums1 and nums2, so if a sum is high, it will come on top of heap and will get popped\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n        \\n        // once we are out of this loop, we are only left with k elements,whch u can simply push it in a vector\\n        vector<vector<int>> res;\\n        while(!maxHeap.empty()) {\\n            res.push_back({maxHeap.top().second.first,maxHeap.top().second.second}); // this is the way to push pairs into a vector, notice the {}, vectors are pushed in that way, just enclose nuumbers in {} in the push_back function\\n            // maxHeap.top().second.first means, pair\\'s top\\'s value\\'s second\\'s part\\'s first value\\n            // pair<totalSum,<nums1,num2>> got teh idea?.\\n            maxHeap.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022030,
                "title": "python-3-using-minimum-heap-with-description-and-comments",
                "content": "Below is an explanation of how the min heap approach works for this problem. Please note that while this answer is not the fastest,\\nit\\'s pretty optimal (faster than 86%), but mainly easy to understand. For even more faster (not easy to understand), you may refer\\nto [Stefan Pochmann]( https://leetcode.com/StefanPochmann/)\\'s solutions, which are brilliant. \\n\\n```\\n       2   4   6       -- > nums1[i]\\n    +------------\\n  1 |  3   5   7\\n  7 |  9  11  13\\n 11 | 13  15  17\\n ^\\n |\\nnums2[j]\\n```\\n1. Add the first row to the heap (3,5,7)\\n ---> heappop returns the minimum sum (3) - [nums1[0] + nums2[0], 0, 0] => [3, 1, 2]\\n2. Add the second row to the heap (9,11,13), also remember 5 & 7 are still in the heap from the previous iteration\\n ---> heappop returns the minimum sum (5) - [nums1[0] + nums2[1], 0, 1] => [5, 1, 4]\\n3. Add the third row to the heap (13,15,17), also remember 7, 9, 11,13 are still in the heap from the previous iteration\\n ---> heappop returns the minimum sum (7) - [nums1[0] + nums2[2], 0, 2] => [7, 1, 6]\\nThat is it! at this point k = 0, because we decreamented it 3 times in the while loop, hence return the result.\\n\\nTime = O(m) + O(n*logk) = O(nlogk)\\nSpace = O(m)\\n```\\ndef kSmallestPairs(nums1, nums2, k):\\n        min_heap = []\\n        # If either of the arrays are empty then return empty list\\n        if not nums1 or not nums2:\\n            return []\\n        # Add the first row of the sum matrix to the heap [fix i = 0 and move j, which is adds 3,5,7]\\n        for j in range(len(nums1)):\\n            heapq.heappush(min_heap, [nums1[0] + nums2[j], 0, j])\\n        pairs = []\\n\\n        while min_heap and k > 0:\\n            # pop from heap, NB the heap uses the first value (nums1[0] + nums2[j]) to validate heap property.\\n            min_sum, i, j = heapq.heappop(min_heap)\\n            # Now append the pairs that just popped out of the heap\\n            pairs.append([nums1[i], nums2[j]])\\n\\n            # Now move to the next row (9,11,13) by increamenting the i by 1\\n            if i+1 < len(nums1):\\n                heapq.heappush(min_heap, [nums1[i+1] + nums2[j], i+1, j] )\\n            k-=1\\n        return pairs\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n       2   4   6       -- > nums1[i]\\n    +------------\\n  1 |  3   5   7\\n  7 |  9  11  13\\n 11 | 13  15  17\\n ^\\n |\\nnums2[j]\\n```\n```\\ndef kSmallestPairs(nums1, nums2, k):\\n        min_heap = []\\n        # If either of the arrays are empty then return empty list\\n        if not nums1 or not nums2:\\n            return []\\n        # Add the first row of the sum matrix to the heap [fix i = 0 and move j, which is adds 3,5,7]\\n        for j in range(len(nums1)):\\n            heapq.heappush(min_heap, [nums1[0] + nums2[j], 0, j])\\n        pairs = []\\n\\n        while min_heap and k > 0:\\n            # pop from heap, NB the heap uses the first value (nums1[0] + nums2[j]) to validate heap property.\\n            min_sum, i, j = heapq.heappop(min_heap)\\n            # Now append the pairs that just popped out of the heap\\n            pairs.append([nums1[i], nums2[j]])\\n\\n            # Now move to the next row (9,11,13) by increamenting the i by 1\\n            if i+1 < len(nums1):\\n                heapq.heappush(min_heap, [nums1[i+1] + nums2[j], i+1, j] )\\n            k-=1\\n        return pairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 929015,
                "title": "o-k-logk-approach-with-detailed-explanation-python-code",
                "content": "When first looking at the problem, the very first approach that springs to mind is to enumerate every possible combination of sums. Let\\'s call length(nums1) = n, length(nums2) = m. Then the enumeration itself will take O(nm). We can create a hash table where each key is a sum that points to all the combos of two elements that make it. Sort the keys, and iterate k times. Sorting takes O(nmlog(nm)). With this approach, however, we can see that we did not take advantage of the fact that both lists come **pre-sorted** for us. \\n\\nWhen you see the \"top k\" of something, this sets off alarm bells for a **heap** of some sort. At first, I was stumped because building a heap out of nm elements take O(nmlog(nm)), which is the same runtime as the sorting method described. However, with more thinking, realize that you never have to deal with a heap of **size nm**. \\n\\nWe know for sure that the smallest sum is made by indices (0,0). For sure, the next smallest is the smaller of (0,1) and (1,0). But what comes next? This is where a bit of recursive intution comes in handy. Note that for whatever elements you are considering, there has to be a smallest sum made by indices (i,j). Since both lists are sorted, for that sum, the next smallest after it must be either (i+1, j) or (i, j+1). How does this fact help us?\\n\\nInitialize a heap with (0,0). Pop the top - in this case (0,0) - and add its two nearest children, (1,0) and (0,1) to the heap. Pop the smaller of the two, and add its two nearest children - (i+1, j) and (i, j+1). \\n\\nAt this point, you may be saying, \"Well isn\\'t this still O(nmlog(nm))?\" No! Each time we pop the smallest, we are adding 1 element to our final k pairs. Therefore, we pop exactly k times. At each step, note we pop **exactly** one element, and add **at most** 2 elements. (\"At most\" is important, we\\'ll get back to that). Therefore, at most, we are adding one element at every step. At its very largest, our heap will only contain k elements. And in a proper heap, adding an element and popping the root are O(logn) operations, where n is the number of elements in the heap at the time. Therefore, we can see our runtime is O(klogk). \\n\\nGetting back to the phrase \"at most,\" we should realize that when adding (i+1, j) and (i, j+1) to the heap, we have to avoid adding a duplicate. It is possible to add duplicates if we are not checking. For instance, suppose we pop (0,2). We should add (0,3) and (1,2). Next let\\'s say we pop (1,1). We should add (1,2) and (2,1). The duplicates would obviously mess us up. Therefore, we should also maintain a set of (i,j) that have been added to the heap, and each time we consider the two \"children\" nodes to add, check if it exists in that set. This is an expected O(1) operation and does not affect our Big-O runtime.\\n\\nI wrote code to build my own min heap. However, if your interviewer allows, definitely go with one of the built-in libraries. Here it is: \\n\\n```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        if k == 0 or not nums1 or not nums2: return []\\n        \\n        len1, len2 = len(nums1), len(nums2)\\n        k = min(k, len1*len2)\\n        added = set()\\n        ls_final = []\\n        justPop = None\\n        firstNode = Solution.Node([0,0], [nums1[0], nums2[0]])\\n        myheap = Solution.Heap()\\n        myheap.addNode(firstNode)\\n        \\n        for n in range(k): #pop the top, add its pop\\'s children\\n            justPop = myheap.removeRoot()\\n            ls_final.append(justPop.vals)\\n            ind1, ind2 = justPop.ind[0], justPop.ind[1]\\n            if ind1 + 1 < len1 and (ind1+1, ind2) not in added: #make sure same node is not added twice\\n                n1 = Solution.Node([ind1+1, ind2], [nums1[ind1+1], nums2[ind2]])\\n                added.add((ind1+1, ind2))\\n                myheap.addNode(n1)\\n            if ind2 + 1 < len2 and (ind1, ind2+1) not in added:\\n                n2 = Solution.Node([ind1, ind2+1], [nums1[ind1], nums2[ind2+1]])\\n                added.add((ind1, ind2+1))\\n                myheap.addNode(n2)\\n        \\n        return ls_final\\n            \\n    class Heap:\\n        def __init__(self):\\n            self.heap = []\\n            self.length = 0\\n            \\n        def addNode(self, node): #log(length) operation\\n            self.heap.append(node)\\n            self.length += 1\\n            self.siftUp(self.length-1)\\n        \\n        def removeRoot(self): #log(length) operation\\n            self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]\\n            ans = self.heap.pop()\\n            self.length -= 1\\n            self.siftDown(0)\\n            return ans\\n            \\n        def siftUp(self, ind):\\n            if ind != 0:\\n                if ind % 2 == 0: parent = (ind-2)//2\\n                else: parent = (ind-1)//2\\n                \\n                if self.heap[ind].sum < self.heap[parent].sum:\\n                    self.heap[ind], self.heap[parent] = self.heap[parent], self.heap[ind]\\n                    self.siftUp(parent)\\n        \\n        def siftDown(self, ind):\\n            smallest = ind\\n            left, right = 2*ind+1, 2*ind+2\\n            if right < self.length: #two children\\n                if self.heap[left].sum < self.heap[right].sum: smaller, bigger = left, right\\n                else: smaller, bigger = right, left\\n                    \\n                if self.heap[ind].sum > self.heap[smaller].sum:\\n                    self.heap[ind], self.heap[smaller] = self.heap[smaller], self.heap[ind]\\n                    smallest = smaller\\n                    \\n            elif left < self.length: #one child\\n                if self.heap[ind].sum > self.heap[left].sum:\\n                    self.heap[ind], self.heap[left] = self.heap[left], self.heap[ind]\\n                    smallest = left\\n            \\n            if smallest != ind:\\n                self.siftDown(smallest)\\n            \\n    class Node: \\n        def __init__(self, ind, vals):\\n            self.ind = ind\\n            self.vals = vals\\n            self.sum = vals[0] + vals[1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        if k == 0 or not nums1 or not nums2: return []\\n        \\n        len1, len2 = len(nums1), len(nums2)\\n        k = min(k, len1*len2)\\n        added = set()\\n        ls_final = []\\n        justPop = None\\n        firstNode = Solution.Node([0,0], [nums1[0], nums2[0]])\\n        myheap = Solution.Heap()\\n        myheap.addNode(firstNode)\\n        \\n        for n in range(k): #pop the top, add its pop\\'s children\\n            justPop = myheap.removeRoot()\\n            ls_final.append(justPop.vals)\\n            ind1, ind2 = justPop.ind[0], justPop.ind[1]\\n            if ind1 + 1 < len1 and (ind1+1, ind2) not in added: #make sure same node is not added twice\\n                n1 = Solution.Node([ind1+1, ind2], [nums1[ind1+1], nums2[ind2]])\\n                added.add((ind1+1, ind2))\\n                myheap.addNode(n1)\\n            if ind2 + 1 < len2 and (ind1, ind2+1) not in added:\\n                n2 = Solution.Node([ind1, ind2+1], [nums1[ind1], nums2[ind2+1]])\\n                added.add((ind1, ind2+1))\\n                myheap.addNode(n2)\\n        \\n        return ls_final\\n            \\n    class Heap:\\n        def __init__(self):\\n            self.heap = []\\n            self.length = 0\\n            \\n        def addNode(self, node): #log(length) operation\\n            self.heap.append(node)\\n            self.length += 1\\n            self.siftUp(self.length-1)\\n        \\n        def removeRoot(self): #log(length) operation\\n            self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]\\n            ans = self.heap.pop()\\n            self.length -= 1\\n            self.siftDown(0)\\n            return ans\\n            \\n        def siftUp(self, ind):\\n            if ind != 0:\\n                if ind % 2 == 0: parent = (ind-2)//2\\n                else: parent = (ind-1)//2\\n                \\n                if self.heap[ind].sum < self.heap[parent].sum:\\n                    self.heap[ind], self.heap[parent] = self.heap[parent], self.heap[ind]\\n                    self.siftUp(parent)\\n        \\n        def siftDown(self, ind):\\n            smallest = ind\\n            left, right = 2*ind+1, 2*ind+2\\n            if right < self.length: #two children\\n                if self.heap[left].sum < self.heap[right].sum: smaller, bigger = left, right\\n                else: smaller, bigger = right, left\\n                    \\n                if self.heap[ind].sum > self.heap[smaller].sum:\\n                    self.heap[ind], self.heap[smaller] = self.heap[smaller], self.heap[ind]\\n                    smallest = smaller\\n                    \\n            elif left < self.length: #one child\\n                if self.heap[ind].sum > self.heap[left].sum:\\n                    self.heap[ind], self.heap[left] = self.heap[left], self.heap[ind]\\n                    smallest = left\\n            \\n            if smallest != ind:\\n                self.siftDown(smallest)\\n            \\n    class Node: \\n        def __init__(self, ind, vals):\\n            self.ind = ind\\n            self.vals = vals\\n            self.sum = vals[0] + vals[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597299,
                "title": "python-binary-search-beats-94",
                "content": "**Idea**\\n\\nNaive solution would cost `O(MNlgMN)` time and `O(MN)` space.\\n\\nSimilar to find k-th smallest element, use a `count(n)` to find the number of pairs whose sums are smaller or equal to `n`. Then the k-th smallest element would be the smallest `n` such that `count(n) >= k`.This way, it costs `O((M+N)logD + logK)` where `D` is the range of possible sums.\\n\\nWe can search the range of values instead since we don\\'t have a sorted index to search from. The idea is the same to \"719. Find K-th Smallest Pair Distance\".\\n\\nExplanation here: [Approach the problem using the \"trial and error\" algorithm](https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-%22trial-and-error%22-algorithm).\\n\\n**Steps**\\n\\n1. Use binary search to find a value `val` in the range `[lo, hi]` where `lo = nums1[0] + nums2[0]` and `hi = nums1[-1] + nums[-2]` such that the number of pairs whose sums are smaller than `val` is `k`.\\n2. Use this `val` to find all pairs whose sums are smaller or equal to `val`. Notice that we should add smaller pairs first, then fill the rest with pairs whose sums are equal to `val`.\\n\\n```python\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        if not nums1 or not nums2: return []\\n        \\n        hi, lo = nums1[-1] + nums2[-1], nums1[0] + nums2[0]\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n\\t\\t\\t\\n            # find count(mid), can be done in O(M+N) time using two pointers\\n            j = len(nums2) - 1\\n            count = 0\\n            for i in range(len(nums1)):\\n                while j >= 0 and nums1[i] + nums2[j] > mid:\\n                    j -= 1\\n                count += j + 1\\n            \\n\\t\\t\\t# search for smallest val such that count(val) >= k\\n            if cnt < k:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        val = lo\\n\\t\\t\\n        res = []\\n\\t\\t\\n\\t\\t# get all pairs whose sum smaller than val\\n        j = len(nums2) - 1\\n        for i in range(len(nums1)):\\n            while j >= 0 and nums1[i] + nums2[j] >= val: j -= 1\\n            for h in range(j + 1): res.append([nums1[i], nums2[h]])\\n        \\n\\t\\t# fill the res to size k with pairs whose sums equal val\\n        j = len(nums2) - 1\\n        remaining = k - len(res)\\n        for i in range(len(nums1)):\\n            while j >= 0 and nums1[i] + nums2[j] > val: j -= 1\\n            h = j\\n            while h >= 0 and nums1[i] + nums2[h] == lo:\\n                res.append([nums1[i], nums2[h]])\\n                remaining -= 1\\n                if remaining == 0: return res\\n                h -= 1\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        if not nums1 or not nums2: return []\\n        \\n        hi, lo = nums1[-1] + nums2[-1], nums1[0] + nums2[0]\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n\\t\\t\\t\\n            # find count(mid), can be done in O(M+N) time using two pointers\\n            j = len(nums2) - 1\\n            count = 0\\n            for i in range(len(nums1)):\\n                while j >= 0 and nums1[i] + nums2[j] > mid:\\n                    j -= 1\\n                count += j + 1\\n            \\n\\t\\t\\t# search for smallest val such that count(val) >= k\\n            if cnt < k:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        val = lo\\n\\t\\t\\n        res = []\\n\\t\\t\\n\\t\\t# get all pairs whose sum smaller than val\\n        j = len(nums2) - 1\\n        for i in range(len(nums1)):\\n            while j >= 0 and nums1[i] + nums2[j] >= val: j -= 1\\n            for h in range(j + 1): res.append([nums1[i], nums2[h]])\\n        \\n\\t\\t# fill the res to size k with pairs whose sums equal val\\n        j = len(nums2) - 1\\n        remaining = k - len(res)\\n        for i in range(len(nums1)):\\n            while j >= 0 and nums1[i] + nums2[j] > val: j -= 1\\n            h = j\\n            while h >= 0 and nums1[i] + nums2[h] == lo:\\n                res.append([nums1[i], nums2[h]])\\n                remaining -= 1\\n                if remaining == 0: return res\\n                h -= 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542733,
                "title": "simple-c-priority-queue-k-lg-min-n1-n2-complexity-ac-beats-98-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& v1, vector<int>& v2, int k) {\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        n1 = v1.size(), n2 = v2.size();\\n        if (!n1 || !n2) return res;\\n        \\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\\n        for (int i = 0; i < n1; i++) {\\n            pq.emplace(v1[i]+v2[0], i, 0);\\n        }\\n        int v = 0, i = 0, j = 0, cnt = 0;\\n        while (cnt < k && pq.size()) {\\n            auto t = pq.top();\\n            pq.pop();\\n            v = get<0>(t), i = get<1>(t), j = get<2>(t);\\n            if (j+1 < n2)\\n                pq.emplace(v1[i]+v2[j+1], i, j+1);       \\n            res.emplace_back(vector<int>{v1[i], v2[j]});\\n            cnt++;\\n        }\\n        return res;\\n    }    \\n    int n1, n2;\\n    vector<vector<int>> res;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& v1, vector<int>& v2, int k) {\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        n1 = v1.size(), n2 = v2.size();\\n        if (!n1 || !n2) return res;\\n        \\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\\n        for (int i = 0; i < n1; i++) {\\n            pq.emplace(v1[i]+v2[0], i, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 521487,
                "title": "c-max-heap-easy-solution",
                "content": "```\\nvector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums2.empty() || nums1.empty()) return {};\\n        priority_queue<pair<int, vector<int>>> maxheap;\\n        vector<vector<int>> result;\\n        for(int i=0; i<nums1.size(); i++) {\\n            for(int j=0; j<nums2.size(); j++) {\\n                if(maxheap.size() < k)\\n                    maxheap.push({nums1[i]+nums2[j], vector<int>({nums1[i],nums2[j]})});\\n                else if(maxheap.size() == k && maxheap.top().first > nums1[i]+nums2[j]) {\\n                    maxheap.pop();\\n                    maxheap.push({nums1[i]+nums2[j], vector<int>({nums1[i],nums2[j]})});\\n                }\\n           }\\n        }\\n        while(!maxheap.empty()) {\\n            result.push_back(maxheap.top().second);\\n            maxheap.pop();\\n        }\\n        return result;\\n    }\\n```\\nnums1:  m nums2: n\\nTime Complexity: O(m * n logk)\\nSpace Complexity O(k)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums2.empty() || nums1.empty()) return {};\\n        priority_queue<pair<int, vector<int>>> maxheap;\\n        vector<vector<int>> result;\\n        for(int i=0; i<nums1.size(); i++) {\\n            for(int j=0; j<nums2.size(); j++) {\\n                if(maxheap.size() < k)\\n                    maxheap.push({nums1[i]+nums2[j], vector<int>({nums1[i],nums2[j]})});\\n                else if(maxheap.size() == k && maxheap.top().first > nums1[i]+nums2[j]) {\\n                    maxheap.pop();\\n                    maxheap.push({nums1[i]+nums2[j], vector<int>({nums1[i],nums2[j]})});\\n                }\\n           }\\n        }\\n        while(!maxheap.empty()) {\\n            result.push_back(maxheap.top().second);\\n            maxheap.pop();\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3688032,
                "title": "simple-cpp-solution-using-min-heap",
                "content": "# Intuition\\n1] make a class to store value of pairs, ind1(index of nums1 which is involves in pair sum) and ind2(next index of nums2 which is involved in pair sum)\\n2] make pair of index 0 from nums2 and every index of nums1 and put into priorityQueue(min heap)\\n3] min heap will run on value of pair sum\\n\\n# Approach\\nexample:\\nnums1 = [1,2,3]\\nnums2 = [2,4,6]\\nk = 3\\n\\npq = [3,0,1],[4,1,1],[5,2,1]\\n\\npairs[pair sum, index from nums1 involved in sum, next index frpm nums2 of index which is involved in pair sum]\\n\\npop out top from pq -> [3,0,1]  push to ans vector({nums1[0],nums2[1-1]})\\nnow replace this [nums1[0]+nums2[1],0,2] => [5,0,2]\\n\\nrepeat this process for k time or untill queue becomes empty\\n\\npq = [5,0,2], [4,1,1], [5,2,1]\\ntop = [4,1,1] and pop top element\\npush to ans vector {nums1[1],nums2[0]}\\nnow replace [nums1[1]+nums2[1],1,2]\\n\\npq = [5,0,2], [6,1,2], [5,2,1]\\ntop = [5,2,1]and pop \\nans push(5,2,2)\\n\\nans vector = [[1,2],[2,2],[3,2]]\\n\\n# Complexity\\n- Time complexity:\\n    O(log(N)*K)\\n    #k = nums1.size()\\n\\n- Space complexity:\\n    O(k)\\n    for k triplets val, ind1, ind2\\n\\n# Code\\n```\\nclass Triplet{\\n    public:\\n    int val, ind1, ind2;\\n\\n    Triplet(int val, int ind1, int ind2){\\n        this->val = val;\\n        this->ind1 = ind1;\\n        this->ind2 = ind2;\\n    }\\n};\\n\\nclass myCmp{\\n    public:\\n    bool operator()(Triplet& a, Triplet& b){\\n        return a.val > b.val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<Triplet, vector<Triplet>, myCmp> pq;\\n\\n        for(int i=0;i<nums1.size();i++){\\n            Triplet t(nums1[i]+nums2[0],i,1);\\n            pq.push(t);\\n        }\\n\\n        vector<vector<int>> ans;\\n        while(k-- and !pq.empty()){\\n            Triplet t = pq.top();\\n            pq.pop();\\n\\n            ans.push_back({nums1[t.ind1],nums2[t.ind2-1]});\\n            if(t.ind2 < nums2.size()){\\n                Triplet y(nums1[t.ind1]+nums2[t.ind2],t.ind1,t.ind2+1);\\n                pq.push(y);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Triplet{\\n    public:\\n    int val, ind1, ind2;\\n\\n    Triplet(int val, int ind1, int ind2){\\n        this->val = val;\\n        this->ind1 = ind1;\\n        this->ind2 = ind2;\\n    }\\n};\\n\\nclass myCmp{\\n    public:\\n    bool operator()(Triplet& a, Triplet& b){\\n        return a.val > b.val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<Triplet, vector<Triplet>, myCmp> pq;\\n\\n        for(int i=0;i<nums1.size();i++){\\n            Triplet t(nums1[i]+nums2[0],i,1);\\n            pq.push(t);\\n        }\\n\\n        vector<vector<int>> ans;\\n        while(k-- and !pq.empty()){\\n            Triplet t = pq.top();\\n            pq.pop();\\n\\n            ans.push_back({nums1[t.ind1],nums2[t.ind2-1]});\\n            if(t.ind2 < nums2.size()){\\n                Triplet y(nums1[t.ind1]+nums2[t.ind2],t.ind1,t.ind2+1);\\n                pq.push(y);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687417,
                "title": "c-simple-max-heap-solution",
                "content": "# Intuition\\n- Maintaining a k size max heap and updating when found sum less than already stored.\\n- By doing this, at last we have only k smallest sum stored in max heap.\\n\\n# Approach\\n- Maintain a max heap of size k only.\\n- Update max heap, when got sum less than stored on top of max heap.\\n- Copy the pairs to a 2D vector and reverse it.\\n\\n# Complexity\\n- Time complexity: `O(n^2)`\\n\\n- Space complexity: `O(k)`\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k){\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // populating maxHeap with k {sum, pair}\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int sum = nums1[i] + nums2[j];\\n                if(maxHeap.size() < k){\\n                    maxHeap.push({sum, {nums1[i], nums2[j]}});\\n                }else if(sum < maxHeap.top().first){\\n                    maxHeap.pop();\\n                    maxHeap.push({sum, {nums1[i], nums2[j]}});\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // putting k pairs with sum k into a 2D vector \\n        vector<vector<int>> ans;\\n        while(!maxHeap.empty()){\\n            ans.push_back({maxHeap.top().second.first, maxHeap.top().second.second});\\n            maxHeap.pop();\\n        }\\n\\n        // reverse it as maxHeap stored it in max first fashion\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n**Thank You :)**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k){\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // populating maxHeap with k {sum, pair}\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int sum = nums1[i] + nums2[j];\\n                if(maxHeap.size() < k){\\n                    maxHeap.push({sum, {nums1[i], nums2[j]}});\\n                }else if(sum < maxHeap.top().first){\\n                    maxHeap.pop();\\n                    maxHeap.push({sum, {nums1[i], nums2[j]}});\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // putting k pairs with sum k into a 2D vector \\n        vector<vector<int>> ans;\\n        while(!maxHeap.empty()){\\n            ans.push_back({maxHeap.top().second.first, maxHeap.top().second.second});\\n            maxHeap.pop();\\n        }\\n\\n        // reverse it as maxHeap stored it in max first fashion\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687294,
                "title": "day-453-java-20-features-c-pyhton-1-liner-explained",
                "content": "# PLEASE UPVOTE \\n\\n# Algorithm:\\n\\n1. Create a priority queue `pq` to store the smallest pair sums.\\n2. Add pairs with the smallest sums of A[0] + B[0], A[1] + B[0], ..., A[n-1] + B[0] to the priority queue.\\n3. While we have not found k pairs or the priority queue is not empty, do the following:\\n  - Extract the pair with the smallest sum from the priority queue.\\n  - Add it to the output list `ans`.\\n  - If there are indices i and j+1 such that i < A.length and j+1 < B.length and (i, j+1) has not been visited yet, add the pair (A[i] + B[j+1], i, j+1) into the priority queue.\\n  - If there are indices i+1 and j such that i+1 < A.length and j < B.length and  (i+1, j) has not been visited yet, add the pair (A[i+1] + B[j], i+1, j) into the priority queue.\\n  - Mark (i+1, j) and (i, j+1) as visited.\\n4. Return `ans` as the list of k smallest pairs.\\n\\n\\n\\n# Code\\n```JAVA []\\nrecord Heap(int sum,int i,int j){}  \\npublic List<List<Integer>> kSmallestPairs(int[] A, int[] B, int k) {\\n    var ans = new ArrayList<List<Integer>>();\\n    var pq = new PriorityQueue<Heap>(Comparator.comparingInt(Heap::sum));\\n    int m=A.length,n=B.length;\\n    var set = new HashSet<String>();\\n    pq.add(new Heap(A[0]+B[0],0,0));\\n    set.add(0+\",\"+0);\\n    while(k-->0 && !pq.isEmpty()){\\n        var pre=pq.poll();\\n        int i=pre.i(),j=pre.j(),p=j+1;\\n        ans.add(List.of(A[i],B[j]));\\n        if(i+1<m && !set.contains(i+1+\",\"+j)) pq.add(new Heap(A[i+1]+B[j],i+1,j)); \\n        if(j+1<n && !set.contains(i+\",\"+p)) pq.add(new Heap(A[i]+B[j+1],i,j+1)); \\n        set.add(i+1+\",\"+j); \\n        set.add(i+\",\"+p); \\n    }return ans;\\n}\\n```\\n```python []\\nimport heapq\\nclass Heap:\\n    def __init__(self, sum, i, j):\\n        self.sum, self.i, self.j = sum, i, j\\n    def __lt__(self, other):\\n        return self.sum < other.sum\\ndef kSmallestPairs(A: List[int], B: List[int], k: int) -> List[List[int]]:\\n    ans, pq, m, n = [], [], len(A), len(B)\\n    s = set()\\n    heapq.heappush(pq, Heap(A[0]+B[0], 0, 0))\\n    s.add((0, 0))\\n    while k > 0 and pq:\\n        pre = heapq.heappop(pq)\\n        i, j, p = pre.i, pre.j, j+1\\n        ans.append([A[i], B[j]])\\n        if i+1 < m and (i+1, j) not in s:\\n            heapq.heappush(pq, Heap(A[i+1]+B[j], i+1, j))\\n            s.add((i+1, j))\\n        if j+1 < n and (i, j+1) not in s:\\n            heapq.heappush(pq, Heap(A[i]+B[j+1], i, j+1))\\n            s.add((i, j+1))\\n        k -= 1    \\n    return ans\\n```\\n```c++ []\\nclass Heap {\\npublic:\\n    int sum, i, j;\\n    Heap(int _sum, int _i, int _j) : sum(_sum), i(_i), j(_j) {}\\n    bool operator< (const Heap& other) const {\\n        return sum > other.sum;\\n    }\\n};\\nvector<vector<int>> kSmallestPairs(vector<int>& A, vector<int>& B, int k) {\\n    vector<vector<int>> ans;\\n    priority_queue<Heap> pq;\\n    int m = A.size(), n = B.size();\\n    unordered_set<string> s;\\n    pq.emplace(A[0] + B[0], 0, 0);\\n    s.insert(\"0,0\");\\n    while (k-- > 0 && !pq.empty()) {\\n        auto pre = pq.top(); pq.pop();\\n        int i = pre.i, j = pre.j, p = j+1;\\n        ans.emplace_back(vector<int>{A[i], B[j]});\\n        if (i+1 < m && !s.count(to_string(i+1)+\",\"+to_string(j))) {\\n            pq.emplace(A[i+1] + B[j], i+1, j);\\n            s.insert(to_string(i+1)+\",\"+to_string(j));\\n        }\\n        if (j+1 < n && !s.count(to_string(i)+\",\"+to_string(p))) {\\n            pq.emplace(A[i] + B[j+1], i, j+1);\\n            s.insert(to_string(i)+\",\"+to_string(p));\\n        }\\n    }\\n    return ans;\\n}\\n```\\n\\n\\n# Time complexity:\\n\\n- Adding the smallest pairs in step 2 takes O(N log N) time, where N is the length of the input arrays.\\n- In each iteration of the while loop in step 3, we extract a pair with the smallest sum from the priority queue, which takes O(log N) time.\\n- Within the while loop, we add two new pairs to the priority queue at most once, and we mark each pair as visited at most once. Therefore, we perform a constant amount of work for each iteration that doesn\\'t extract from the priority queue, so the number of iterations of the while loop is at most k.\\n- Therefore, the total time complexity is O(k log N), where N is the length of the input arrays.\\n\\n# Space complexity:\\n\\n- We use a priority queue of size N to store the smallest pairs, so the space complexity is O(N), where N is the length of the input arrays.\\n- We use a set to keep track of the pairs that have already been visited, which has a maximum size of N if all pairs are unique.\\n- We create an output list of size k to store the k smallest pairs.\\n- Therefore, the total space complexity is O(N + k), where N is the length of the input arrays and k is the number of smallest pairs to be returned.\\n\\n# ONE LINER \\n\\n```PYTHON []\\ndef kSmallestPairs(self, nums1, nums2, k):\\n    return heapq.nsmallest(k, ([u, v] for u in nums1 for v in nums2), key=sum)\\n```\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d588f492-3f95-45f6-8e4a-10d6069002a5_1680054021.7117147.png)\\n\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n\\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```JAVA []\\nrecord Heap(int sum,int i,int j){}  \\npublic List<List<Integer>> kSmallestPairs(int[] A, int[] B, int k) {\\n    var ans = new ArrayList<List<Integer>>();\\n    var pq = new PriorityQueue<Heap>(Comparator.comparingInt(Heap::sum));\\n    int m=A.length,n=B.length;\\n    var set = new HashSet<String>();\\n    pq.add(new Heap(A[0]+B[0],0,0));\\n    set.add(0+\",\"+0);\\n    while(k-->0 && !pq.isEmpty()){\\n        var pre=pq.poll();\\n        int i=pre.i(),j=pre.j(),p=j+1;\\n        ans.add(List.of(A[i],B[j]));\\n        if(i+1<m && !set.contains(i+1+\",\"+j)) pq.add(new Heap(A[i+1]+B[j],i+1,j)); \\n        if(j+1<n && !set.contains(i+\",\"+p)) pq.add(new Heap(A[i]+B[j+1],i,j+1)); \\n        set.add(i+1+\",\"+j); \\n        set.add(i+\",\"+p); \\n    }return ans;\\n}\\n```\n```python []\\nimport heapq\\nclass Heap:\\n    def __init__(self, sum, i, j):\\n        self.sum, self.i, self.j = sum, i, j\\n    def __lt__(self, other):\\n        return self.sum < other.sum\\ndef kSmallestPairs(A: List[int], B: List[int], k: int) -> List[List[int]]:\\n    ans, pq, m, n = [], [], len(A), len(B)\\n    s = set()\\n    heapq.heappush(pq, Heap(A[0]+B[0], 0, 0))\\n    s.add((0, 0))\\n    while k > 0 and pq:\\n        pre = heapq.heappop(pq)\\n        i, j, p = pre.i, pre.j, j+1\\n        ans.append([A[i], B[j]])\\n        if i+1 < m and (i+1, j) not in s:\\n            heapq.heappush(pq, Heap(A[i+1]+B[j], i+1, j))\\n            s.add((i+1, j))\\n        if j+1 < n and (i, j+1) not in s:\\n            heapq.heappush(pq, Heap(A[i]+B[j+1], i, j+1))\\n            s.add((i, j+1))\\n        k -= 1    \\n    return ans\\n```\n```c++ []\\nclass Heap {\\npublic:\\n    int sum, i, j;\\n    Heap(int _sum, int _i, int _j) : sum(_sum), i(_i), j(_j) {}\\n    bool operator< (const Heap& other) const {\\n        return sum > other.sum;\\n    }\\n};\\nvector<vector<int>> kSmallestPairs(vector<int>& A, vector<int>& B, int k) {\\n    vector<vector<int>> ans;\\n    priority_queue<Heap> pq;\\n    int m = A.size(), n = B.size();\\n    unordered_set<string> s;\\n    pq.emplace(A[0] + B[0], 0, 0);\\n    s.insert(\"0,0\");\\n    while (k-- > 0 && !pq.empty()) {\\n        auto pre = pq.top(); pq.pop();\\n        int i = pre.i, j = pre.j, p = j+1;\\n        ans.emplace_back(vector<int>{A[i], B[j]});\\n        if (i+1 < m && !s.count(to_string(i+1)+\",\"+to_string(j))) {\\n            pq.emplace(A[i+1] + B[j], i+1, j);\\n            s.insert(to_string(i+1)+\",\"+to_string(j));\\n        }\\n        if (j+1 < n && !s.count(to_string(i)+\",\"+to_string(p))) {\\n            pq.emplace(A[i] + B[j+1], i, j+1);\\n            s.insert(to_string(i)+\",\"+to_string(p));\\n        }\\n    }\\n    return ans;\\n}\\n```\n```PYTHON []\\ndef kSmallestPairs(self, nums1, nums2, k):\\n    return heapq.nsmallest(k, ([u, v] for u in nums1 for v in nums2), key=sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686917,
                "title": "w-explanation-c-prior-queue-unordered-set-on-pairs-from-slow-to-beating-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe programming structure is similar to BSF, but using prior queue instead of queue for the usual BFS. The pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1).\\n\\nunordered_set is used for visited recording the visiting status for the pair (i,j) which needs a custom hash on pair<int, int>; the performance is like using set<int, int>.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Define a type alias for convenience\\n    using int2 = pair<int, int>;\\n    \\n    // Custom hash function for the int2 pair\\n    struct PairHash {\\n        size_t operator () (const int2& p) const {\\n            // Use XOR (^) operation to combine the hash of the first element and the second element\\n            return hash<int>{}(p.first) ^ p.second;\\n        }\\n    };\\n\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        // Get the sizes of the input vectors\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        \\n        // Define a lambda function to compare two vectors based on their sums\\n        function<bool(vector<int>&, vector<int>&)> cmp = [](vector<int>& x, vector<int>& y) -> bool\\n        { \\n            return (x[0] + x[1]) > (y[0] + y[1]); \\n        };\\n        \\n        // Create a priority queue to store the k smallest pairs, using the custom comparison function\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);\\n        \\n        // Create a vector to store the resulting pairs\\n        vector<vector<int>> ans;\\n        ans.reserve(k);\\n        \\n        // Create an unordered set to keep track of visited pairs using custom hash function\\n        unordered_set<int2, PairHash> visited;\\n        \\n        // Push the initial pair into the priority queue and mark it as visited\\n        pq.push({nums1[0], nums2[0], 0, 0});\\n        visited.insert({0, 0});\\n        \\n        // Main loop to find the k smallest pairs\\n        while (!pq.empty()) {\\n            // Extract the top pair from the priority queue\\n            vector<int> x = pq.top();\\n            pq.pop();\\n            \\n            // Extract the elements and indices from the pair\\n            int p0 = x[0], p1 = x[1], i = x[2], j = x[3];\\n            \\n            // Decrement k and add the pair to the result vector\\n            k--;\\n            ans.push_back({p0, p1});\\n            \\n            // Check if we have found k pairs, if yes, return the result vector\\n            if (k == 0) return ans;\\n            \\n            // Check the adjacent pairs and push them into the priority queue if they are valid and not visited\\n            if (i + 1 < n1 && visited.count({i + 1, j}) == 0) {\\n                pq.push({nums1[i + 1], nums2[j], i + 1, j});\\n                visited.insert({i + 1, j});\\n            } \\n            if (j + 1 < n2 && visited.count({i, j + 1}) == 0) {\\n                pq.push({nums1[i], nums2[j + 1], i, j + 1});\\n                visited.insert({i, j + 1});\\n            } \\n        }\\n        \\n        // Return the resulting pairs\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# 2nd solution using set and priority_queue on tuples\\n```\\nclass Solution {\\npublic:\\n    using int2 = pair<int, int>;\\n    using int3 = tuple<int, int, int>;\\n   \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        priority_queue<int3, vector<int3>, greater<int3>> pq;\\n        vector<vector<int>> ans;\\n        ans.reserve(k);\\n        set<int2> visited;\\n        pq.push({nums1[0]+nums2[0], 0, 0});\\n        visited.insert({0, 0});\\n        while (!pq.empty()) {\\n            auto [sum, i, j] = pq.top();\\n            pq.pop();\\n            k--;\\n            ans.push_back({nums1[i], nums2[j]});\\n            if (k == 0) return ans;\\n            \\n            if (i + 1 < n1 && visited.count({i + 1, j}) == 0) {\\n                pq.push({nums1[i + 1]+nums2[j], i + 1, j});\\n                visited.insert({i + 1, j});\\n            } \\n            if (j + 1 < n2 && visited.count({i, j + 1}) == 0) {\\n                pq.push({nums1[i]+nums2[j + 1], i, j + 1});\\n                visited.insert({i, j + 1});\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n# 3rd solution optimized code Runtime 252 ms Beats 96%\\n```\\nclass Solution {\\npublic:\\n    using int3 = tuple<int, int, int>;\\n   \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        priority_queue<int3, vector<int3>, greater<int3>> pq;\\n        vector<vector<int>> ans;\\n        ans.reserve(k);\\n\\n        int y0 = nums2[0];  \\n        int k1=min(n1, k);\\n        for (int i = 0; i < k1; i++) \\n            pq.push({y0 + nums1[i], i, 0});\\n\\n        while (!pq.empty()) {\\n            auto [sum, i, j] = pq.top();\\n            pq.pop();\\n            k--;\\n            ans.push_back({nums1[i], nums2[j]});\\n            if (k == 0) return ans;\\n        \\n            if (j + 1 < n2) {\\n                pq.push({nums1[i]+nums2[j+1], i, j+1});\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Define a type alias for convenience\\n    using int2 = pair<int, int>;\\n    \\n    // Custom hash function for the int2 pair\\n    struct PairHash {\\n        size_t operator () (const int2& p) const {\\n            // Use XOR (^) operation to combine the hash of the first element and the second element\\n            return hash<int>{}(p.first) ^ p.second;\\n        }\\n    };\\n\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        // Get the sizes of the input vectors\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        \\n        // Define a lambda function to compare two vectors based on their sums\\n        function<bool(vector<int>&, vector<int>&)> cmp = [](vector<int>& x, vector<int>& y) -> bool\\n        { \\n            return (x[0] + x[1]) > (y[0] + y[1]); \\n        };\\n        \\n        // Create a priority queue to store the k smallest pairs, using the custom comparison function\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);\\n        \\n        // Create a vector to store the resulting pairs\\n        vector<vector<int>> ans;\\n        ans.reserve(k);\\n        \\n        // Create an unordered set to keep track of visited pairs using custom hash function\\n        unordered_set<int2, PairHash> visited;\\n        \\n        // Push the initial pair into the priority queue and mark it as visited\\n        pq.push({nums1[0], nums2[0], 0, 0});\\n        visited.insert({0, 0});\\n        \\n        // Main loop to find the k smallest pairs\\n        while (!pq.empty()) {\\n            // Extract the top pair from the priority queue\\n            vector<int> x = pq.top();\\n            pq.pop();\\n            \\n            // Extract the elements and indices from the pair\\n            int p0 = x[0], p1 = x[1], i = x[2], j = x[3];\\n            \\n            // Decrement k and add the pair to the result vector\\n            k--;\\n            ans.push_back({p0, p1});\\n            \\n            // Check if we have found k pairs, if yes, return the result vector\\n            if (k == 0) return ans;\\n            \\n            // Check the adjacent pairs and push them into the priority queue if they are valid and not visited\\n            if (i + 1 < n1 && visited.count({i + 1, j}) == 0) {\\n                pq.push({nums1[i + 1], nums2[j], i + 1, j});\\n                visited.insert({i + 1, j});\\n            } \\n            if (j + 1 < n2 && visited.count({i, j + 1}) == 0) {\\n                pq.push({nums1[i], nums2[j + 1], i, j + 1});\\n                visited.insert({i, j + 1});\\n            } \\n        }\\n        \\n        // Return the resulting pairs\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    using int2 = pair<int, int>;\\n    using int3 = tuple<int, int, int>;\\n   \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        priority_queue<int3, vector<int3>, greater<int3>> pq;\\n        vector<vector<int>> ans;\\n        ans.reserve(k);\\n        set<int2> visited;\\n        pq.push({nums1[0]+nums2[0], 0, 0});\\n        visited.insert({0, 0});\\n        while (!pq.empty()) {\\n            auto [sum, i, j] = pq.top();\\n            pq.pop();\\n            k--;\\n            ans.push_back({nums1[i], nums2[j]});\\n            if (k == 0) return ans;\\n            \\n            if (i + 1 < n1 && visited.count({i + 1, j}) == 0) {\\n                pq.push({nums1[i + 1]+nums2[j], i + 1, j});\\n                visited.insert({i + 1, j});\\n            } \\n            if (j + 1 < n2 && visited.count({i, j + 1}) == 0) {\\n                pq.push({nums1[i]+nums2[j + 1], i, j + 1});\\n                visited.insert({i, j + 1});\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    using int3 = tuple<int, int, int>;\\n   \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) \\n    {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        priority_queue<int3, vector<int3>, greater<int3>> pq;\\n        vector<vector<int>> ans;\\n        ans.reserve(k);\\n\\n        int y0 = nums2[0];  \\n        int k1=min(n1, k);\\n        for (int i = 0; i < k1; i++) \\n            pq.push({y0 + nums1[i], i, 0});\\n\\n        while (!pq.empty()) {\\n            auto [sum, i, j] = pq.top();\\n            pq.pop();\\n            k--;\\n            ans.push_back({nums1[i], nums2[j]});\\n            if (k == 0) return ans;\\n        \\n            if (j + 1 < n2) {\\n                pq.push({nums1[i]+nums2[j+1], i, j+1});\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804078,
                "title": "solution-easy-to-understand-80-faster",
                "content": "\\n\\nstruct myComp \\n{\\n    \\nconstexpr bool operator()(pair<pair<int,int>, int> const& a, pair<pair<int,int>, int> const& b) const noexcept\\n    {\\n        \\n    \\n    return a.second < b.second;\\n    \\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    \\n \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k)\\n    {\\n        \\n        int n=nums1.size();\\n        int m=nums2.size();\\n        \\n        priority_queue<pair< pair<int,int> ,int >,vector<pair< pair<int,int>   ,int>>,myComp>pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                 if(pq.size()<k)\\n                 {\\n                    pq.push({{nums1[i],nums2[j]},nums1[i]+nums2[j]});\\n                 }\\n                 else if((nums1[i]+nums2[j]) < pq.top().second) \\n                 {\\n                    pq.pop();\\n                    pq.push({{nums1[i],nums2[j]},nums1[i]+nums2[j]});\\n                 } \\n                 else \\n                 {\\n                    break; \\n                 }\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>>hp;\\n        \\n    \\n        for(int i=0;i<k;i++)\\n        {\\n            if(pq.empty()==true)\\n            {\\n                break;\\n            }\\n            \\n            int x=pq.top().first.first;\\n            int y=pq.top().first.second;\\n            pq.pop();\\n            hp.push_back({x,y});\\n            \\n           \\n            \\n        }\\n        \\n        return hp;\\n        \\n        \\n        \\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    \\n \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k)\\n    {\\n        \\n        int n=nums1.size();\\n        int m=nums2.size();\\n        \\n        priority_queue<pair< pair<int,int> ,int >,vector<pair< pair<int,int>   ,int>>,myComp>pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                 if(pq.size()<k)\\n                 {\\n                    pq.push({{nums1[i],nums2[j]}",
                "codeTag": "Java"
            },
            {
                "id": 1690643,
                "title": "python-heap-priority-queue",
                "content": "```\\nclass Solution:\\n    def kSmallestPairs(self, n1: List[int], n2: List[int], k: int) -> List[List[int]]:\\n        if not n1 or not n2: return []\\n        \\n        heap = []\\n        for i in range(len(n1)):                                  \\n            heapq.heappush(heap, (n1[i] + n2[0], i, 0))           #Step 1\\n            \\n        result = []\\n        while heap and k > 0:                                     \\n            _, i, j = heapq.heappop(heap)                         #Step 2\\n            result.append([n1[i],n2[j]])                          #Step 3\\n            \\n            if j+1 < len(n2):                                     #Step 4\\n                heapq.heappush(heap, (n1[i]+n2[j+1],i, j+1))      #Step 5\\n            k-=1\\n        return result\\n```\\nI learned  this from other brilliant post and just wanted to expand upon it. \\n* `Step 1:` We are building a heap using tuples. That tuple will contain `(sum of both list indices, indices of list1, and first index of list2)` Our heap ordering will be base off the sum. We will need the next two elements in the tuple later.\\n* `Step 2:` After building our heap, We can now do a tuple unpacking using `heappop()`. This will pop the lowest value. *(Which is the sum in the tuple)* We won\\'t be needing the sum value any more so it is just assigned to a underscore  `_`.\\n* `Step 3:` Since we know that `heappop()` unpacked the lowest pair values for us. we can append those pair values to our result array.\\n* `Step 4:` We now should update our heap with the sums of list2 values.\\n* `Step 5:` Since we upacked the index of list2 to` j.` We can use this to update the heap by doing the same process *Step1* but instead incrementing j by +1. The heap will automatically sort that tuple in the correct order and our while loop will append the lowest value pair to our result array.\\n\\nI\\'d Like to Thank [cenkay](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/discuss/155676/Python-heapq-solution-beats-96) My code is base upon. I think lot of people post answers on the discussion doesn\\'t seem to credit who or where they learned it from. I just like to give credit where credit is due. Hope this helps\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, n1: List[int], n2: List[int], k: int) -> List[List[int]]:\\n        if not n1 or not n2: return []\\n        \\n        heap = []\\n        for i in range(len(n1)):                                  \\n            heapq.heappush(heap, (n1[i] + n2[0], i, 0))           #Step 1\\n            \\n        result = []\\n        while heap and k > 0:                                     \\n            _, i, j = heapq.heappop(heap)                         #Step 2\\n            result.append([n1[i],n2[j]])                          #Step 3\\n            \\n            if j+1 < len(n2):                                     #Step 4\\n                heapq.heappush(heap, (n1[i]+n2[j+1],i, j+1))      #Step 5\\n            k-=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533075,
                "title": "time-complexity-o-k-log-k-space-complexity-o-k",
                "content": "Motivational example:\\n\\nnums1 = [1,2,3]\\nnums2 = [6,7,8]\\n\\nIf k = 2: pairs = (1, 6), (1, 7).\\n\\nnums1 = [**1**,2,3]\\nnums2 = [**6**,**7**,8]\\n\\nCool, no problem. Every thing matches with our intuition.\\n\\nIf k = 3: We realize (1, 8) has larger sum than (2, 6). How can we construct a heap that let us know we should \"switch\" to pair (2, 6) instead?\\n\\nFirst we initialize the min heap following the format `(priority_value = nums[i] + nums[j], i, j)`:\\n\\nheap = [(7, 0, 0), (8, 1, 0), (9, 2, 0)]\\n\\nNow, let\\'s run our algorithm mentally:\\n\\n-------------\\n\\nWe pop the top of the heap out:\\n\\nnums[i] + nums[j], i, j = heappop(heap) = 7, 0, 0\\n\\nNow: heap = [(8, 1, 0), (9, 2, 0)]\\n\\nLet us keep increasing `j` while keeping `i` fixed:\\n\\nnums1 = [**1**,2,3]\\nnums2 = [**6**,**7**,8]\\n\\nuntil we realize pair (1, 8) has larger sum than pair (1, 0) stored at the top of the heap.\\n\\nWe push pair (1, 8) to the heap:\\n\\nNow:\\n* heap = [(8, 1, 0), **(1 + 8, 0, 2)**, (9, 2, 0)]\\n* ans = [(1, 6), (1, 7)]\\n\\n-------------\\n\\nWe pop the top of the heap out:\\n\\nnums[i] + nums[j], i, j = heappop(heap) = 8, 1, 0\\n\\nNow: heap = [(9, 0, 2), (9, 2, 0)]\\n\\nLet us keep increasing `j` while keeping `i` fixed:\\n\\nnums1 = [1,**2**,3]\\nnums2 = [**6**,**7**,8]\\n\\nuntil we realize pair (2, 8) has larger sum than pair (0, 2) stored at the top of the heap.\\n\\nWe push pair (2, 8) to the heap:\\n\\nNow:\\n* heap =  [(9, 0, 2), (9, 2, 0), **(2 + 8, 1, 2)**]\\n* ans = [(1, 6), (1, 7), (2, 6), (2, 7)]\\n\\n---------\\n\\nBasically, our heap keeps track of the last invalid state `j` of index `i` (`i < k`). A state `j` of index `i` is invalid when `nums[i] + nums[j]` is not the currently n-th smallest sum where n is the current length of the list `ans` (but it might be the (n+1)-th smallest sum in the future, who knows).\\n\\n```python\\nfrom heapq import heappush, heappop\\n\\nclass Solution(object):\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        heap = []\\n        for i in range(min(len(nums1), k)):\\n            heappush(heap, (nums1[i] + nums2[0], i, 0))\\n        ans = []\\n        i = j = 0\\n        while heap:\\n            _, i, j = heappop(heap)\\n            smallest_sum = heap[0][0] if heap else float(\\'inf\\')\\n            while j < len(nums2) and nums1[i] + nums2[j] <= smallest_sum:\\n                ans.append([nums1[i], nums2[j]])\\n                j += 1\\n                k -= 1\\n                if k == 0:\\n                    return ans\\n            if j < len(nums2):\\n                heappush(heap, (nums1[i] + nums2[j], i, j))\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom heapq import heappush, heappop\\n\\nclass Solution(object):\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        heap = []\\n        for i in range(min(len(nums1), k)):\\n            heappush(heap, (nums1[i] + nums2[0], i, 0))\\n        ans = []\\n        i = j = 0\\n        while heap:\\n            _, i, j = heappop(heap)\\n            smallest_sum = heap[0][0] if heap else float(\\'inf\\')\\n            while j < len(nums2) and nums1[i] + nums2[j] <= smallest_sum:\\n                ans.append([nums1[i], nums2[j]])\\n                j += 1\\n                k -= 1\\n                if k == 0:\\n                    return ans\\n            if j < len(nums2):\\n                heappush(heap, (nums1[i] + nums2[j], i, j))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525130,
                "title": "easy-code-priority-queue-choose-minimum-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ans;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int >>, greater<tuple<int, int, int>>> pq;\\n        for(int i = 0; i < n; i++) {\\n            pq.push({nums1[i] + nums2[0], i, 0});\\n        }\\n        while(k-- and pq.size()) {\\n            auto [sum, i, j] = pq.top(); pq.pop();\\n            ans.push_back({nums1[i], nums2[j]});\\n            if(j < m - 1)\\n                pq.push({nums1[i] + nums2[j + 1], i, j + 1});\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/aad4380d-a38e-4315-bbe5-060c02a2f192_1634442475.8551962.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ans;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int >>, greater<tuple<int, int, int>>> pq;\\n        for(int i = 0; i < n; i++) {\\n            pq.push({nums1[i] + nums2[0], i, 0});\\n        }\\n        while(k-- and pq.size()) {\\n            auto [sum, i, j] = pq.top(); pq.pop();\\n            ans.push_back({nums1[i], nums2[j]});\\n            if(j < m - 1)\\n                pq.push({nums1[i] + nums2[j + 1], i, j + 1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337704,
                "title": "min-heap-c-solution",
                "content": "**ANSWER :** \\nWe know that we need only k values. We will map each index of nums1 to nums2 and we need to find the first k smallest sum pairs....so we can find the first k ans while mapping it. In this way it will be faster.\\nHow will we do that? \\nlet us first map each i with 0 and push it in the min heap according to its sum ----> pq.push(nums[i]+nums[0]) . Now we have minmium sum pair at the top.\\nNow we can iterate k-times and then take out the top sum and then increase the mapped index of i e.g earlier it was (i,0) now it will be (i,1) and then update its sum and push it in the heap. \\nThere will be one validation that if we have (i, j) and if we increase j++ then we check if j<num2.size() or not if yes then only we can push it in the queue else we will not push it.\\n\\n\\n**Code :**\\n```\\ntypedef pair<int, pair<int, int>> pii;\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<pii, vector<pii>, greater<pii>>pq;\\n        vector<vector<int>>ans;\\n        vector<int>temp;\\n        for(int i=0;i<nums1.size();i++){\\n            pq.push({nums1[i]+nums2[0], {i, 0}});\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            if(pq.empty())break;\\n            int i1=pq.top().second.first,i2=pq.top().second.second;\\n            temp.push_back(nums1[i1]);\\n            temp.push_back(nums2[i2]);\\n            ans.push_back(temp);\\n            pq.pop();\\n            i2++;\\n            if(i2<nums2.size()){\\n                pq.push({nums1[i1]+nums2[i2], {i1, i2}});\\n            }\\n            temp.pop_back();\\n            temp.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime complexity = O(KlogN)\\nspace = O(N)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int, pair<int, int>> pii;\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<pii, vector<pii>, greater<pii>>pq;\\n        vector<vector<int>>ans;\\n        vector<int>temp;\\n        for(int i=0;i<nums1.size();i++){\\n            pq.push({nums1[i]+nums2[0], {i, 0}});\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            if(pq.empty())break;\\n            int i1=pq.top().second.first,i2=pq.top().second.second;\\n            temp.push_back(nums1[i1]);\\n            temp.push_back(nums2[i2]);\\n            ans.push_back(temp);\\n            pq.pop();\\n            i2++;\\n            if(i2<nums2.size()){\\n                pq.push({nums1[i1]+nums2[i2], {i1, i2}});\\n            }\\n            temp.pop_back();\\n            temp.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134626,
                "title": "java-simple-and-easy-to-understand-solution-using-maxheap-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n\\t\\t//max heap\\n        PriorityQueue<List<Integer>> maxHeap = new PriorityQueue<List<Integer>>((b, a) -> ((a.get(0) + a.get(1)) - (b.get(0) + b.get(1))));\\n        \\n        for(int num1 : nums1){\\n            for(int num2 : nums2){\\n                maxHeap.add(List.of(num1, num2));\\n                \\n\\t\\t\\t\\t//remove the list, whose elemet sum is maximum\\n                if(maxHeap.size() > k) maxHeap.remove();\\n            }\\n        }\\n        \\n        List<List<Integer>> result = new ArrayList();\\n        \\n        while(!maxHeap.isEmpty()){\\n            result.add(maxHeap.remove());\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n\\t\\t//max heap\\n        PriorityQueue<List<Integer>> maxHeap = new PriorityQueue<List<Integer>>((b, a) -> ((a.get(0) + a.get(1)) - (b.get(0) + b.get(1))));\\n        \\n        for(int num1 : nums1){\\n            for(int num2 : nums2){\\n                maxHeap.add(List.of(num1, num2));\\n                \\n\\t\\t\\t\\t//remove the list, whose elemet sum is maximum\\n                if(maxHeap.size() > k) maxHeap.remove();\\n            }\\n        }\\n        \\n        List<List<Integer>> result = new ArrayList();\\n        \\n        while(!maxHeap.isEmpty()){\\n            result.add(maxHeap.remove());\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076854,
                "title": "python-3-super-straightforward-brute-force-with-heaps",
                "content": "**Idea**:\\nput everything into a heap, and take out ```k``` elements out of it. \\n\\n```\\ndef kSmallestPairs_alt(nums1, nums2, k):  # O(logn * logm) and O(mn), where m and n are lengths of lists \\n    h, res = [], []\\n    for i in range(len(nums1)):\\n        for j in range(len(nums2)):\\n            heapq.heappush(h, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\\n    for _ in range(min(k, len(h))):  # handling an edge case when we have fewer than k elements inside the heap\\n        _, pair = heapq.heappop(h)\\n        res.append(pair)\\n    return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```k```\n```\\ndef kSmallestPairs_alt(nums1, nums2, k):  # O(logn * logm) and O(mn), where m and n are lengths of lists \\n    h, res = [], []\\n    for i in range(len(nums1)):\\n        for j in range(len(nums2)):\\n            heapq.heappush(h, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\\n    for _ in range(min(k, len(h))):  # handling an edge case when we have fewer than k elements inside the heap\\n        _, pair = heapq.heappop(h)\\n        res.append(pair)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 835525,
                "title": "golang-4ms-heap-solution",
                "content": "```go\\ntype Heap [][3]int\\n\\nfunc (p Heap) Len() int            { return len(p) }\\nfunc (p Heap) Less(i, j int) bool  { return p[i][0] < p[j][0] }\\nfunc (p Heap) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }\\nfunc (p *Heap) Push(i interface{}) { *p = append(*p, i.([3]int)) }\\nfunc (p *Heap) Pop() interface{}   { v := (*p)[len(*p)-1]; *p = (*p)[:len(*p)-1]; return v }\\n\\nfunc kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {\\n\\t// valid check\\n\\tif len(nums1) == 0 || len(nums2) == 0 || k <= 0 {\\n\\t\\treturn nil\\n\\t}\\n\\tminHeap := Heap{}\\n\\tfor i, v := range nums1 {\\n\\t\\tminHeap = append(minHeap, [...]int{v+nums2[0], i, 0})\\n\\t}\\n\\theap.Init(&minHeap)\\n\\t// fix k\\n\\tif k > len(nums1) * len(nums2) {\\n\\t\\tk = len(nums1) * len(nums2)\\n\\t}\\n\\tpairs := make([][]int, 0, k)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\ttop := heap.Pop(&minHeap).([3]int)\\n\\t\\tpairs = append(pairs, []int{nums1[top[1]], nums2[top[2]]})\\n\\t\\tif top[2] < len(nums2) - 1 {\\n\\t\\t\\ttop[2]++\\n\\t\\t\\ttop[0] = nums1[top[1]]+nums2[top[2]]\\n\\t\\t\\theap.Push(&minHeap, top)\\n\\t\\t}\\n\\t}\\n\\treturn pairs\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\ntype Heap [][3]int\\n\\nfunc (p Heap) Len() int            { return len(p) }\\nfunc (p Heap) Less(i, j int) bool  { return p[i][0] < p[j][0] }\\nfunc (p Heap) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }\\nfunc (p *Heap) Push(i interface{}) { *p = append(*p, i.([3]int)) }\\nfunc (p *Heap) Pop() interface{}   { v := (*p)[len(*p)-1]; *p = (*p)[:len(*p)-1]; return v }\\n\\nfunc kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {\\n\\t// valid check\\n\\tif len(nums1) == 0 || len(nums2) == 0 || k <= 0 {\\n\\t\\treturn nil\\n\\t}\\n\\tminHeap := Heap{}\\n\\tfor i, v := range nums1 {\\n\\t\\tminHeap = append(minHeap, [...]int{v+nums2[0], i, 0})\\n\\t}\\n\\theap.Init(&minHeap)\\n\\t// fix k\\n\\tif k > len(nums1) * len(nums2) {\\n\\t\\tk = len(nums1) * len(nums2)\\n\\t}\\n\\tpairs := make([][]int, 0, k)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\ttop := heap.Pop(&minHeap).([3]int)\\n\\t\\tpairs = append(pairs, []int{nums1[top[1]], nums2[top[2]]})\\n\\t\\tif top[2] < len(nums2) - 1 {\\n\\t\\t\\ttop[2]++\\n\\t\\t\\ttop[0] = nums1[top[1]]+nums2[top[2]]\\n\\t\\t\\theap.Push(&minHeap, top)\\n\\t\\t}\\n\\t}\\n\\treturn pairs\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535867,
                "title": "javascript-heap",
                "content": "```javascript\\nvar kSmallestPairs = function(nums1, nums2, k) {\\n    if (nums1.length * nums2.length === 0) return [];\\n    const heap = new MinHeap(nums1, nums2);\\n    heap.push([0,0]);\\n    const result = [];\\n    while (!heap.isEmpty() && result.length < k) {\\n        const [i, j] = heap.pop();\\n        result.push([nums1[i], nums2[j]]);\\n        if (i + 1 < nums1.length) heap.push([i + 1, j])\\n        if (j + 1 < nums2.length) heap.push([i, j + 1])\\n    }\\n    return result;\\n};\\n\\nclass MinHeap {\\n    constructor(nums1, nums2) {\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        this.store = [];\\n        this.seen = new Set();\\n    }\\n    \\n    isEmpty() {\\n        return this.store.length === 0;\\n    }\\n    \\n    push(value)  {\\n        const str = value.join(\\'-\\');\\n        if (this.seen.has(str)) return;\\n        this.seen.add(str);\\n        this.store.push(value);\\n        this.heapifyUp(this.store.length - 1);\\n    }\\n    \\n    pop() {\\n        if (this.store.length < 2) return this.store.pop();\\n        const value = this.store[0];\\n        this.store[0] = this.store.pop();\\n        this.heapifyDown(0);\\n        return value;\\n    }\\n    \\n    heapifyUp(child) {\\n        while (child) {\\n            const parent = Math.floor((child - 1) / 2);\\n            if (this.value(child) < this.value(parent)) {\\n                this.swap(child, parent);\\n                child = parent;\\n            } else {\\n                return child;\\n            }\\n        }\\n    }\\n    \\n    heapifyDown(parent) {\\n        while (true) {\\n            const [child1, child2] = [1,2].map((n) => parent * 2 + n).filter((n) => n < this.store.length);\\n            let child = child1;\\n            if (child2 && this.value(child2) < this.value(child1)) {\\n                child = child2;\\n            }\\n            if (child && this.value(child) < this.value(parent)) {\\n                this.swap(child, parent);\\n                parent = child;\\n            } else {\\n                return parent;\\n            }\\n        }\\n    }\\n    \\n    value(idx) {\\n        const [i, j] = this.store[idx];\\n        return this.nums1[i] + this.nums2[j];\\n    }\\n    \\n    swap(idx1, idx2) {\\n        [this.store[idx1], this.store[idx2]] = [this.store[idx2], this.store[idx1]]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar kSmallestPairs = function(nums1, nums2, k) {\\n    if (nums1.length * nums2.length === 0) return [];\\n    const heap = new MinHeap(nums1, nums2);\\n    heap.push([0,0]);\\n    const result = [];\\n    while (!heap.isEmpty() && result.length < k) {\\n        const [i, j] = heap.pop();\\n        result.push([nums1[i], nums2[j]]);\\n        if (i + 1 < nums1.length) heap.push([i + 1, j])\\n        if (j + 1 < nums2.length) heap.push([i, j + 1])\\n    }\\n    return result;\\n};\\n\\nclass MinHeap {\\n    constructor(nums1, nums2) {\\n        this.nums1 = nums1;\\n        this.nums2 = nums2;\\n        this.store = [];\\n        this.seen = new Set();\\n    }\\n    \\n    isEmpty() {\\n        return this.store.length === 0;\\n    }\\n    \\n    push(value)  {\\n        const str = value.join(\\'-\\');\\n        if (this.seen.has(str)) return;\\n        this.seen.add(str);\\n        this.store.push(value);\\n        this.heapifyUp(this.store.length - 1);\\n    }\\n    \\n    pop() {\\n        if (this.store.length < 2) return this.store.pop();\\n        const value = this.store[0];\\n        this.store[0] = this.store.pop();\\n        this.heapifyDown(0);\\n        return value;\\n    }\\n    \\n    heapifyUp(child) {\\n        while (child) {\\n            const parent = Math.floor((child - 1) / 2);\\n            if (this.value(child) < this.value(parent)) {\\n                this.swap(child, parent);\\n                child = parent;\\n            } else {\\n                return child;\\n            }\\n        }\\n    }\\n    \\n    heapifyDown(parent) {\\n        while (true) {\\n            const [child1, child2] = [1,2].map((n) => parent * 2 + n).filter((n) => n < this.store.length);\\n            let child = child1;\\n            if (child2 && this.value(child2) < this.value(child1)) {\\n                child = child2;\\n            }\\n            if (child && this.value(child) < this.value(parent)) {\\n                this.swap(child, parent);\\n                parent = child;\\n            } else {\\n                return parent;\\n            }\\n        }\\n    }\\n    \\n    value(idx) {\\n        const [i, j] = this.store[idx];\\n        return this.nums1[i] + this.nums2[j];\\n    }\\n    \\n    swap(idx1, idx2) {\\n        [this.store[idx1], this.store[idx2]] = [this.store[idx2], this.store[idx1]]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492422,
                "title": "python-min-heap",
                "content": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        \\n        if not nums1 or not nums2 or not k: return []\\n        i = j = 0\\n        minHeap = []\\n        \\n        for _ in range(k):\\n            if i < len(nums1) and j < len(nums2):\\n                if nums1[i] <= nums2[j]:\\n                    for x in nums2[j:]: heapq.heappush(minHeap, (nums1[i], x))\\n                    i += 1\\n                else:\\n                    for x in nums1[i:]: heapq.heappush(minHeap, (x, nums2[j]))\\n                    j += 1\\n                    \\n        return heapq.nsmallest(k, minHeap, key = sum)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        \\n        if not nums1 or not nums2 or not k: return []\\n        i = j = 0\\n        minHeap = []\\n        \\n        for _ in range(k):\\n            if i < len(nums1) and j < len(nums2):\\n                if nums1[i] <= nums2[j]:\\n                    for x in nums2[j:]: heapq.heappush(minHeap, (nums1[i], x))\\n                    i += 1\\n                else:\\n                    for x in nums1[i:]: heapq.heappush(minHeap, (x, nums2[j]))\\n                    j += 1\\n                    \\n        return heapq.nsmallest(k, minHeap, key = sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482361,
                "title": "python-dumb-solution",
                "content": "the easiest way I\\'m thinking is paried all of the numbers and then choose the K smallest ones.\\n\\nclass Solution:\\n\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        result = []\\n        for i in nums1:\\n            for x in nums2:\\n                result.append([i,x])\\n        return sorted(result,key = sum)[0:k]",
                "solutionTags": [
                    "Python"
                ],
                "code": "the easiest way I\\'m thinking is paried all of the numbers and then choose the K smallest ones.\\n\\nclass Solution:\\n\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        result = []\\n        for i in nums1:\\n            for x in nums2:\\n                result.append([i,x])\\n        return sorted(result,key = sum)[0:k]",
                "codeTag": "Java"
            },
            {
                "id": 429509,
                "title": "javascript-with-max-heap",
                "content": "\\n\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar kSmallestPairs = function(nums1, nums2, k) {\\n    if (!nums1.length || !nums2.length) return [];\\n    \\n    let heap = new MaxBinaryHeap();\\n    \\n    for (let i = 0; i < nums1.length; i++) {\\n        for (let j = 0; j < nums2.length; j++) {\\n            let elem = {\\n                index: [nums1[i], nums2[j]],\\n                val: nums1[i] + nums2[j]\\n            }\\n            \\n            if (heap.size < k) {\\n                heap.insert(elem);\\n            } else if (elem.val < heap.values[0].val) {\\n                heap.extract();\\n                heap.insert(elem);\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return heap.values.map(n => n.index);\\n};\\n\\nclass MaxBinaryHeap {\\n    get size() {\\n        return this.values.length;\\n    }\\n    \\n    constructor() {\\n        this.values = [];\\n    }\\n    \\n    insert(elem) {\\n        this.values.push(elem);\\n        let index = this.size - 1;\\n        if (index === 0) return;\\n        \\n        let parentIndex = Math.floor((index - 1) / 2);\\n        \\n        while (this.values[parentIndex] && this.values[parentIndex].val < this.values[index].val) {\\n            [this.values[parentIndex], this.values[index]] = [this.values[index], this.values[parentIndex]];\\n            index = parentIndex;\\n            parentIndex = Math.floor((index - 1) / 2);\\n        }\\n    }\\n    \\n    extract() {\\n        let parentIndex = 0;\\n        let lastIndex = this.size - 1;\\n        [this.values[parentIndex], this.values[lastIndex]] = [this.values[lastIndex], this.values[parentIndex]];\\n        let result = this.values.pop();\\n        \\n        let leftChildIndex = 2 * parentIndex + 1;\\n        let rightChildIndex = 2 * parentIndex + 2;\\n        \\n        while ((this.values[leftChildIndex] !== undefined && this.values[leftChildIndex].val > this.values[parentIndex].val) ||\\n              (this.values[rightChildIndex] !== undefined && this.values[rightChildIndex].val > this.values[parentIndex].val)) {\\n            let highestChildIndex;\\n            if (this.values[leftChildIndex] === undefined || this.values[rightChildIndex] === undefined) {\\n                highestChildIndex = leftChildIndex || rightChildIndex;\\n            } else {\\n                highestChildIndex = this.values[leftChildIndex].val > this.values[rightChildIndex].val ? leftChildIndex : rightChildIndex;\\n            }\\n            [this.values[parentIndex], this.values[highestChildIndex]] = [this.values[highestChildIndex], this.values[parentIndex]];\\n            parentIndex = highestChildIndex;\\n            leftChildIndex = 2 * parentIndex + 1;\\n            rightChildIndex = 2 * parentIndex + 2;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar kSmallestPairs = function(nums1, nums2, k) {\\n    if (!nums1.length || !nums2.length) return [];\\n    \\n    let heap = new MaxBinaryHeap();\\n    \\n    for (let i = 0; i < nums1.length; i++) {\\n        for (let j = 0; j < nums2.length; j++) {\\n            let elem = {\\n                index: [nums1[i], nums2[j]],\\n                val: nums1[i] + nums2[j]\\n            }\\n            \\n            if (heap.size < k) {\\n                heap.insert(elem);\\n            } else if (elem.val < heap.values[0].val) {\\n                heap.extract();\\n                heap.insert(elem);\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return heap.values.map(n => n.index);\\n};\\n\\nclass MaxBinaryHeap {\\n    get size() {\\n        return this.values.length;\\n    }\\n    \\n    constructor() {\\n        this.values = [];\\n    }\\n    \\n    insert(elem) {\\n        this.values.push(elem);\\n        let index = this.size - 1;\\n        if (index === 0) return;\\n        \\n        let parentIndex = Math.floor((index - 1) / 2);\\n        \\n        while (this.values[parentIndex] && this.values[parentIndex].val < this.values[index].val) {\\n            [this.values[parentIndex], this.values[index]] = [this.values[index], this.values[parentIndex]];\\n            index = parentIndex;\\n            parentIndex = Math.floor((index - 1) / 2);\\n        }\\n    }\\n    \\n    extract() {\\n        let parentIndex = 0;\\n        let lastIndex = this.size - 1;\\n        [this.values[parentIndex], this.values[lastIndex]] = [this.values[lastIndex], this.values[parentIndex]];\\n        let result = this.values.pop();\\n        \\n        let leftChildIndex = 2 * parentIndex + 1;\\n        let rightChildIndex = 2 * parentIndex + 2;\\n        \\n        while ((this.values[leftChildIndex] !== undefined && this.values[leftChildIndex].val > this.values[parentIndex].val) ||\\n              (this.values[rightChildIndex] !== undefined && this.values[rightChildIndex].val > this.values[parentIndex].val)) {\\n            let highestChildIndex;\\n            if (this.values[leftChildIndex] === undefined || this.values[rightChildIndex] === undefined) {\\n                highestChildIndex = leftChildIndex || rightChildIndex;\\n            } else {\\n                highestChildIndex = this.values[leftChildIndex].val > this.values[rightChildIndex].val ? leftChildIndex : rightChildIndex;\\n            }\\n            [this.values[parentIndex], this.values[highestChildIndex]] = [this.values[highestChildIndex], this.values[parentIndex]];\\n            parentIndex = highestChildIndex;\\n            leftChildIndex = 2 * parentIndex + 1;\\n            rightChildIndex = 2 * parentIndex + 2;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423953,
                "title": "three-solutions",
                "content": "### Solution 1 Time:(k^2)*Log(K^2) Space:K^2  beats 12.39 % \\n```\\n     // Solution 1 Time:(k^2)*Log(K^2) Space:K^2  beats 12.39 %\\n     public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int len1 = nums1 == null ? 0 : nums1.length;\\n        int len2 = nums2 == null ? 0 : nums2.length;\\n        PriorityQueue<List<Integer>> minHeap = new PriorityQueue<>(((o1, o2) -> o1.get(0) + o1.get(1) - o2.get(0) - o2.get(1)));\\n        for (int i = 0; i < Math.min(len1, k); i++) {\\n            for (int j = 0; j < Math.min(len2, k); j++) {\\n                minHeap.add(Arrays.asList(nums1[i], nums2[j]));\\n            }\\n        }\\n        while(!minHeap.isEmpty() && k-->0){\\n            ans.add(minHeap.poll());\\n        }\\n        return ans;\\n    }\\n```\\n\\n### solution 2 Time:(K)*Log(K) Space:K Beats 89%\\n```\\n    // solution 2 Time:(K)*Log(K) Space:K\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int len1 = nums1 == null ? 0 : nums1.length;\\n        int len2 = nums2 == null ? 0 : nums2.length;\\n        if (len1 == 0 || len2 == 0 || k == 0)  return ans;\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((o1, o2) -> nums1[o1[0]] + nums2[o1[1]] - nums1[o2[0]] - nums2[o2[1]]);\\n        for (int i = 0; i < Math.min(len1, k); i++)  minHeap.add(new int[] {i, 0});\\n        while (k-- > 0 && !minHeap.isEmpty()) {\\n            int[] cur = minHeap.poll();\\n            ans.add(Arrays.asList(nums1[cur[0]], nums2[cur[1]]));\\n            if (cur[1] + 1 < len2) {\\n                minHeap.add(new int[] {cur[0], cur[1] + 1});\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n### solution 3 Time: k*m(where m is the length of nums1)  Space: O(m) beats 79.17 %\\n```\\n//solution 3 Time: k*m(where m is the length of nums1)  Space: O(m)\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int len1 = nums1 == null ? 0 : nums1.length;\\n        int len2 = nums2 == null ? 0 : nums2.length;\\n        if (len1 == 0 || len2 == 0 || k == 0)  return ans;\\n        int[] idx = new int[nums1.length];\\n        while(k-->0){\\n            int min = Integer.MAX_VALUE, in = -1;\\n            for(int i=0;i<nums1.length;i++){\\n                if(idx[i]>=len2) continue;\\n                if(nums1[i]+nums2[idx[i]]<min){\\n                    min = nums1[i]+nums2[idx[i]];\\n                    in = i;\\n                }\\n            }\\n            if(in==-1) continue;\\n            ans.add(Arrays.asList(nums1[in],nums2[idx[in]]));\\n            idx[in]++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     // Solution 1 Time:(k^2)*Log(K^2) Space:K^2  beats 12.39 %\\n     public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int len1 = nums1 == null ? 0 : nums1.length;\\n        int len2 = nums2 == null ? 0 : nums2.length;\\n        PriorityQueue<List<Integer>> minHeap = new PriorityQueue<>(((o1, o2) -> o1.get(0) + o1.get(1) - o2.get(0) - o2.get(1)));\\n        for (int i = 0; i < Math.min(len1, k); i++) {\\n            for (int j = 0; j < Math.min(len2, k); j++) {\\n                minHeap.add(Arrays.asList(nums1[i], nums2[j]));\\n            }\\n        }\\n        while(!minHeap.isEmpty() && k-->0){\\n            ans.add(minHeap.poll());\\n        }\\n        return ans;\\n    }\\n```\n```\\n    // solution 2 Time:(K)*Log(K) Space:K\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int len1 = nums1 == null ? 0 : nums1.length;\\n        int len2 = nums2 == null ? 0 : nums2.length;\\n        if (len1 == 0 || len2 == 0 || k == 0)  return ans;\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((o1, o2) -> nums1[o1[0]] + nums2[o1[1]] - nums1[o2[0]] - nums2[o2[1]]);\\n        for (int i = 0; i < Math.min(len1, k); i++)  minHeap.add(new int[] {i, 0});\\n        while (k-- > 0 && !minHeap.isEmpty()) {\\n            int[] cur = minHeap.poll();\\n            ans.add(Arrays.asList(nums1[cur[0]], nums2[cur[1]]));\\n            if (cur[1] + 1 < len2) {\\n                minHeap.add(new int[] {cur[0], cur[1] + 1});\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n//solution 3 Time: k*m(where m is the length of nums1)  Space: O(m)\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int len1 = nums1 == null ? 0 : nums1.length;\\n        int len2 = nums2 == null ? 0 : nums2.length;\\n        if (len1 == 0 || len2 == 0 || k == 0)  return ans;\\n        int[] idx = new int[nums1.length];\\n        while(k-->0){\\n            int min = Integer.MAX_VALUE, in = -1;\\n            for(int i=0;i<nums1.length;i++){\\n                if(idx[i]>=len2) continue;\\n                if(nums1[i]+nums2[idx[i]]<min){\\n                    min = nums1[i]+nums2[idx[i]];\\n                    in = i;\\n                }\\n            }\\n            if(in==-1) continue;\\n            ans.add(Arrays.asList(nums1[in],nums2[idx[in]]));\\n            idx[in]++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 395721,
                "title": "java-solution-using-priorityqueue-with-list-list-integer",
                "content": "\\tpublic List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n\\t\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\t\\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\\n\\t\\t\\t// Using lambda function to pass list as element to pq, while maintaining as minHeap\\n\\t\\t\\tPriorityQueue<List<Integer>> pq = new PriorityQueue<>((a,b) -> (a.get(0) + a.get(1) - b.get(0) - b.get(1)));\\n\\t\\t\\tfor (int i = 0; i < nums1.length && i < k; i++) {\\n\\t\\t\\t\\t// initialize new list to add element, with the third element as nums2\\'s index  \\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(nums1[i]);\\n\\t\\t\\t\\tlist.add(nums2[0]);\\n\\t\\t\\t\\tlist.add(0);\\n\\t\\t\\t\\tpq.offer(list);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!pq.isEmpty() && k-- > 0) {\\n\\t\\t\\t\\tList<Integer> cur = pq.poll(); \\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(cur.get(0));\\n\\t\\t\\t\\tlist.add(cur.get(1));\\n\\t\\t\\t\\tres.add(list);\\n\\n\\t\\t\\t\\tif (cur.get(2) + 1 == nums2.length) continue;\\n\\t\\t\\t\\tList<Integer> tmp = new ArrayList<>();\\n\\t\\t\\t\\ttmp.add(cur.get(0));\\n\\t\\t\\t\\ttmp.add(nums2[cur.get(2) + 1]);\\n\\t\\t\\t\\ttmp.add(cur.get(2) + 1);\\n\\t\\t\\t\\tpq.offer(tmp);\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "\\tpublic List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n\\t\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\t\\tif (nums1.length == 0 || nums2.length == 0 || k == 0) return res;\\n\\t\\t\\t// Using lambda function to pass list as element to pq, while maintaining as minHeap\\n\\t\\t\\tPriorityQueue<List<Integer>> pq = new PriorityQueue<>((a,b) -> (a.get(0) + a.get(1) - b.get(0) - b.get(1)));\\n\\t\\t\\tfor (int i = 0; i < nums1.length && i < k; i++) {\\n\\t\\t\\t\\t// initialize new list to add element, with the third element as nums2\\'s index  \\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(nums1[i]);\\n\\t\\t\\t\\tlist.add(nums2[0]);\\n\\t\\t\\t\\tlist.add(0);\\n\\t\\t\\t\\tpq.offer(list);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!pq.isEmpty() && k-- > 0) {\\n\\t\\t\\t\\tList<Integer> cur = pq.poll(); \\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(cur.get(0));\\n\\t\\t\\t\\tlist.add(cur.get(1));\\n\\t\\t\\t\\tres.add(list);\\n\\n\\t\\t\\t\\tif (cur.get(2) + 1 == nums2.length) continue;\\n\\t\\t\\t\\tList<Integer> tmp = new ArrayList<>();\\n\\t\\t\\t\\ttmp.add(cur.get(0));\\n\\t\\t\\t\\ttmp.add(nums2[cur.get(2) + 1]);\\n\\t\\t\\t\\ttmp.add(cur.get(2) + 1);\\n\\t\\t\\t\\tpq.offer(tmp);\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3713055,
                "title": "tle-on-every-solutions",
                "content": "UPD. Now this problem fixed, same solution recieve Accepted status, thanks\\n\\nI try old solution for this task, and it gave me TLE \\nAlso this solution with button \"Run Test Case\" work about 9-12ms on TLE test\\nTLE test \\n[1,1,1...,1] - len 10^5\\n[1,1,1...,1] - len 10^5\\n10000\\n\\nI try some solutions from discuss (cpp/java) and every solution gave TLE. \\nIs it ok?\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> sol = new ArrayList<List<Integer>>();\\n        PriorityQueue<Element> pq= new PriorityQueue<Element>();\\n        for (int i=0;i<nums1.length;i++) pq.add(new Element(0,i,nums2[0]+nums1[i]));\\n        for (int i=0;i<k;i++){\\n            if (pq.peek()==null) break;\\n            Element e = pq.poll();\\n            List<Integer> in = List.of(nums1[e.y], nums2[e.x]);\\n            sol.add(in);\\n            if (e.x==nums2.length-1) continue;\\n            pq.add(new Element(e.x+1,e.y,nums2[e.x+1]+nums1[e.y]));\\n        }\\n        return sol;\\n    }\\n\\n    public class Element implements Comparable<Element>{\\n        public int x;\\n        public int y;\\n        public int val;\\n        public Element(int x,int y,int val){\\n            this.x=x;\\n            this.y=y;\\n            this.val=val;\\n        }\\n        @Override\\n        public int compareTo(Element other){\\n            return this.val-other.val; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> sol = new ArrayList<List<Integer>>();\\n        PriorityQueue<Element> pq= new PriorityQueue<Element>();\\n        for (int i=0;i<nums1.length;i++) pq.add(new Element(0,i,nums2[0]+nums1[i]));\\n        for (int i=0;i<k;i++){\\n            if (pq.peek()==null) break;\\n            Element e = pq.poll();\\n            List<Integer> in = List.of(nums1[e.y], nums2[e.x]);\\n            sol.add(in);\\n            if (e.x==nums2.length-1) continue;\\n            pq.add(new Element(e.x+1,e.y,nums2[e.x+1]+nums1[e.y]));\\n        }\\n        return sol;\\n    }\\n\\n    public class Element implements Comparable<Element>{\\n        public int x;\\n        public int y;\\n        public int val;\\n        public Element(int x,int y,int val){\\n            this.x=x;\\n            this.y=y;\\n            this.val=val;\\n        }\\n        @Override\\n        public int compareTo(Element other){\\n            return this.val-other.val; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702055,
                "title": "simple-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct compare{\\n    bool operator()(vector<int>& v1, vector<int>& v2){\\n        return v1[0]>v2[0];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>res;\\n        priority_queue<vector<int>,vector<vector<int>>,compare>pq;\\n        map<pair<int,int>,int>visited;\\n        if(0<nums1.size() and 0<nums2.size()){\\n            pq.push({nums1[0]+nums2[0],0,0});\\n            visited[make_pair(0,0)]=1;\\n        }\\n        int count=0;\\n        while(!pq.empty()){\\n            vector<int>f=pq.top();\\n            pq.pop();\\n            res.push_back({nums1[f[1]],nums2[f[2]]});\\n            count++;\\n            if(count==k){\\n                break;\\n            }\\n            if(f[1]<nums1.size() and f[2]+1<nums2.size() and visited.count(make_pair(f[1],f[2]+1))==0){\\n                pq.push({nums1[f[1]]+nums2[f[2]+1],f[1],f[2]+1});\\n                visited[make_pair(f[1],f[2]+1)]=1;\\n            }\\n            if(f[1]+1<nums1.size() and f[2]<nums2.size() and visited.count(make_pair(f[1]+1,f[2]))==0){\\n                pq.push({nums1[f[1]+1]+nums2[f[2]],f[1]+1,f[2]});\\n                visited[make_pair(f[1]+1,f[2])]=1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct compare{\\n    bool operator()(vector<int>& v1, vector<int>& v2){\\n        return v1[0]>v2[0];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>res;\\n        priority_queue<vector<int>,vector<vector<int>>,compare>pq;\\n        map<pair<int,int>,int>visited;\\n        if(0<nums1.size() and 0<nums2.size()){\\n            pq.push({nums1[0]+nums2[0],0,0});\\n            visited[make_pair(0,0)]=1;\\n        }\\n        int count=0;\\n        while(!pq.empty()){\\n            vector<int>f=pq.top();\\n            pq.pop();\\n            res.push_back({nums1[f[1]],nums2[f[2]]});\\n            count++;\\n            if(count==k){\\n                break;\\n            }\\n            if(f[1]<nums1.size() and f[2]+1<nums2.size() and visited.count(make_pair(f[1],f[2]+1))==0){\\n                pq.push({nums1[f[1]]+nums2[f[2]+1],f[1],f[2]+1});\\n                visited[make_pair(f[1],f[2]+1)]=1;\\n            }\\n            if(f[1]+1<nums1.size() and f[2]<nums2.size() and visited.count(make_pair(f[1]+1,f[2]))==0){\\n                pq.push({nums1[f[1]+1]+nums2[f[2]],f[1]+1,f[2]});\\n                visited[make_pair(f[1]+1,f[2])]=1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690191,
                "title": "k-sized-max-heap-priority-queue-solution-well-commented",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<pair<int,pair<int,int>>> pq; //inserting the pair of sum and pair of u and v in a pq \\n        for(int &x: nums1){\\n            for(int &y: nums2){\\n                int sum = x+y; // calculate the sum\\n\\n                if(pq.size()<k) pq.push({sum,{x,y}});   //we need a k sized max-pq so insert untill size is < k\\n\\n                else if(sum < pq.top().first)       //if sum of the top element in pq is greater than the next sum in line pop and insert new one\\n                {   \\n                    pq.pop();\\n                    pq.push({sum,{x,y}});\\n                }\\n                \\n                else break;         // if sum > pq.top().first as it is in ascending order it means the sums to come will be greater than curr sum\\n            }\\n        }\\n\\n        while(!pq.empty())\\n        {\\n            res.push_back({pq.top().second.first,pq.top().second.second});      // storing the nums1,nums2 element pairs in vector of vector and popping\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> res;\\n        priority_queue<pair<int,pair<int,int>>> pq; //inserting the pair of sum and pair of u and v in a pq \\n        for(int &x: nums1){\\n            for(int &y: nums2){\\n                int sum = x+y; // calculate the sum\\n\\n                if(pq.size()<k) pq.push({sum,{x,y}});   //we need a k sized max-pq so insert untill size is < k\\n\\n                else if(sum < pq.top().first)       //if sum of the top element in pq is greater than the next sum in line pop and insert new one\\n                {   \\n                    pq.pop();\\n                    pq.push({sum,{x,y}});\\n                }\\n                \\n                else break;         // if sum > pq.top().first as it is in ascending order it means the sums to come will be greater than curr sum\\n            }\\n        }\\n\\n        while(!pq.empty())\\n        {\\n            res.push_back({pq.top().second.first,pq.top().second.second});      // storing the nums1,nums2 element pairs in vector of vector and popping\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689934,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\nvector<vector<int>> ans;\\npriority_queue<pair<int, pair<int, int>>> pq; // max-heap to store the k smallest pairs\\n    for (int i = 0; i < nums1.size(); i++) {\\n        for (int j = 0; j < nums2.size(); j++) {\\n            int sum = nums1[i] + nums2[j];\\n\\n            // If the priority queue size is less than k, add the pair\\n            if (pq.size() < k)\\n                pq.push({sum, {nums1[i], nums2[j]}});\\n            else if (sum < pq.top().first) {\\n                // If the current sum is smaller than the largest sum in the priority queue,\\n                // remove the largest sum and add the current sum\\n                pq.pop();\\n                pq.push({sum, {nums1[i], nums2[j]}});\\n            } else if (sum > pq.top().first) {\\n                // If the current sum is larger than the largest sum in the priority queue,\\n                // break the inner loop since sums will only increase from this point onwards\\n                break;\\n            }\\n        }\\n    }\\n\\n    // Retrieve the k smallest pairs from the priority queue and store them in the answer vector\\n    while (!pq.empty()) {\\n        ans.push_back({pq.top().second.first, pq.top().second.second});\\n        pq.pop();\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\nvector<vector<int>> ans;\\npriority_queue<pair<int, pair<int, int>>> pq; // max-heap to store the k smallest pairs\\n    for (int i = 0; i < nums1.size(); i++) {\\n        for (int j = 0; j < nums2.size(); j++) {\\n            int sum = nums1[i] + nums2[j];\\n\\n            // If the priority queue size is less than k, add the pair\\n            if (pq.size() < k)\\n                pq.push({sum, {nums1[i], nums2[j]}});\\n            else if (sum < pq.top().first) {\\n                // If the current sum is smaller than the largest sum in the priority queue,\\n                // remove the largest sum and add the current sum\\n                pq.pop();\\n                pq.push({sum, {nums1[i], nums2[j]}});\\n            } else if (sum > pq.top().first) {\\n                // If the current sum is larger than the largest sum in the priority queue,\\n                // break the inner loop since sums will only increase from this point onwards\\n                break;\\n            }\\n        }\\n    }\\n\\n    // Retrieve the k smallest pairs from the priority queue and store them in the answer vector\\n    while (!pq.empty()) {\\n        ans.push_back({pq.top().second.first, pq.top().second.second});\\n        pq.pop();\\n    }\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689905,
                "title": "strange-mle-error",
                "content": "Why creating a comparator with vector properties is giving me MLE?\\n```\\nclass Compare\\n{\\nprivate:\\n    vector<int> nums1;\\n    vector<int> nums2;\\n\\npublic:\\n    Compare(const vector<int> &nums1, const vector<int> &nums2)\\n    {\\n        this->nums1 = nums1;\\n        this->nums2 = nums2;\\n    }\\n    \\n    bool operator()(const pair<int, int> &left, const pair<int, int> &right)\\n    {\\n        return nums1[left.first] + nums2[left.second] > nums1[right.first] + nums2[right.second];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        unordered_set<long long int> visited;\\n        vector<vector<int>> answer;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> minh(Compare(nums1, nums2));\\n        minh.emplace(0, 0);\\n        visited.insert(0);\\n        \\n        for (int i = 0; i < k && !minh.empty(); i++)\\n        {\\n            auto [x, y] = minh.top();\\n            minh.pop();\\n\\n            answer.push_back({nums1[x], nums2[y]});\\n            \\n            long long int forNum1 = (x + 1) * 100000000000LL + y;\\n            \\n            if (x + 1 < n1 && !visited.count(forNum1))\\n                minh.emplace(x + 1, y), visited.insert(forNum1);\\n            \\n            long long int forNum2 = x * 100000000000LL + y + 1;\\n            if (y + 1 < n2 && !visited.count(forNum2))\\n                minh.emplace(x, y + 1), visited.insert(forNum2);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n\\nBut making the properties a reference works.\\n```\\nconst char fastio = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Compare\\n{\\nprivate:\\n    vector<int> &nums1;\\n    vector<int> &nums2;\\n\\npublic:\\n    Compare(vector<int> &nums1, vector<int> &nums2) : nums1(nums1), nums2(nums2) {}\\n    \\n    bool operator()(const pair<int, int> &left, const pair<int, int> &right)\\n    {\\n        return nums1[left.first] + nums2[left.second] > nums1[right.first] + nums2[right.second];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        unordered_set<long long int> visited;\\n        vector<vector<int>> answer;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> minh(Compare(nums1, nums2));\\n        minh.emplace(0, 0);\\n        visited.insert(0);\\n        \\n        for (int i = 0; i < k && !minh.empty(); i++)\\n        {\\n            auto [x, y] = minh.top();\\n            minh.pop();\\n\\n            answer.push_back({nums1[x], nums2[y]});\\n            \\n            long long int forNum1 = (x + 1) * 100000000000LL + y;\\n            \\n            if (x + 1 < n1 && !visited.count(forNum1))\\n                minh.emplace(x + 1, y), visited.insert(forNum1);\\n            \\n            long long int forNum2 = x * 100000000000LL + y + 1;\\n            if (y + 1 < n2 && !visited.count(forNum2))\\n                minh.emplace(x, y + 1), visited.insert(forNum2);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n\\nCan you tell me why the first code gave MLE.\\nAnd by only changing the ```vector<int>``` property to a reference type solves the issue.\\nIs this a LeetCode issue? Or Comparator objects are created for each element inserted in the heap? Or the issue is something else?\\nPlease help me understanding that how it is working?",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Compare\\n{\\nprivate:\\n    vector<int> nums1;\\n    vector<int> nums2;\\n\\npublic:\\n    Compare(const vector<int> &nums1, const vector<int> &nums2)\\n    {\\n        this->nums1 = nums1;\\n        this->nums2 = nums2;\\n    }\\n    \\n    bool operator()(const pair<int, int> &left, const pair<int, int> &right)\\n    {\\n        return nums1[left.first] + nums2[left.second] > nums1[right.first] + nums2[right.second];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        unordered_set<long long int> visited;\\n        vector<vector<int>> answer;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> minh(Compare(nums1, nums2));\\n        minh.emplace(0, 0);\\n        visited.insert(0);\\n        \\n        for (int i = 0; i < k && !minh.empty(); i++)\\n        {\\n            auto [x, y] = minh.top();\\n            minh.pop();\\n\\n            answer.push_back({nums1[x], nums2[y]});\\n            \\n            long long int forNum1 = (x + 1) * 100000000000LL + y;\\n            \\n            if (x + 1 < n1 && !visited.count(forNum1))\\n                minh.emplace(x + 1, y), visited.insert(forNum1);\\n            \\n            long long int forNum2 = x * 100000000000LL + y + 1;\\n            if (y + 1 < n2 && !visited.count(forNum2))\\n                minh.emplace(x, y + 1), visited.insert(forNum2);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\n```\\nconst char fastio = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Compare\\n{\\nprivate:\\n    vector<int> &nums1;\\n    vector<int> &nums2;\\n\\npublic:\\n    Compare(vector<int> &nums1, vector<int> &nums2) : nums1(nums1), nums2(nums2) {}\\n    \\n    bool operator()(const pair<int, int> &left, const pair<int, int> &right)\\n    {\\n        return nums1[left.first] + nums2[left.second] > nums1[right.first] + nums2[right.second];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        unordered_set<long long int> visited;\\n        vector<vector<int>> answer;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> minh(Compare(nums1, nums2));\\n        minh.emplace(0, 0);\\n        visited.insert(0);\\n        \\n        for (int i = 0; i < k && !minh.empty(); i++)\\n        {\\n            auto [x, y] = minh.top();\\n            minh.pop();\\n\\n            answer.push_back({nums1[x], nums2[y]});\\n            \\n            long long int forNum1 = (x + 1) * 100000000000LL + y;\\n            \\n            if (x + 1 < n1 && !visited.count(forNum1))\\n                minh.emplace(x + 1, y), visited.insert(forNum1);\\n            \\n            long long int forNum2 = x * 100000000000LL + y + 1;\\n            if (y + 1 < n2 && !visited.count(forNum2))\\n                minh.emplace(x, y + 1), visited.insert(forNum2);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\n```vector<int>```",
                "codeTag": "C++"
            },
            {
                "id": 3689882,
                "title": "easy-c-priority-queue-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n          priority_queue<pair<int,pair<int,int>>> pq;\\n          int n = nums1.size();\\n          int m = nums2.size();\\n\\n          for(int i=0;i<n;i++){\\n              for(int j=0; j<m ;j++){\\n\\n                  int sum = nums1[i] + nums2[j];\\n\\n                  if(pq.size() < k)\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n\\n                   else if(sum < pq.top().first){\\n\\n                        pq.pop();\\n                        pq.push({sum,{nums1[i],nums2[j]}});\\n                   }\\n\\n                    else\\n                     break; \\n              }\\n          }\\n\\n          vector<vector<int>> ans;\\n\\n           while(!pq.empty()){\\n\\n               ans.push_back({pq.top().second.first,pq.top().second.second});\\n               pq.pop();\\n           }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n          priority_queue<pair<int,pair<int,int>>> pq;\\n          int n = nums1.size();\\n          int m = nums2.size();\\n\\n          for(int i=0;i<n;i++){\\n              for(int j=0; j<m ;j++){\\n\\n                  int sum = nums1[i] + nums2[j];\\n\\n                  if(pq.size() < k)\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n\\n                   else if(sum < pq.top().first){\\n\\n                        pq.pop();\\n                        pq.push({sum,{nums1[i],nums2[j]}});\\n                   }\\n\\n                    else\\n                     break; \\n              }\\n          }\\n\\n          vector<vector<int>> ans;\\n\\n           while(!pq.empty()){\\n\\n               ans.push_back({pq.top().second.first,pq.top().second.second});\\n               pq.pop();\\n           }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688806,
                "title": "you-re-my-priority-really-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < n; i++)\\n            pq.push({nums1[i]+nums2[0],{i,0}});\\n        while(!pq.empty() && k--)\\n        {\\n            pair<int,pair<int,int>> tp = pq.top();\\n            int x = tp.second.first, y = tp.second.second;\\n            pq.pop();\\n            ans.push_back({nums1[x], nums2[y]});\\n            if(y != m-1)\\n                pq.push({nums1[x]+nums2[y+1],{x, y+1}});\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < n; i++)\\n            pq.push({nums1[i]+nums2[0],{i,0}});\\n        while(!pq.empty() && k--)\\n        {\\n            pair<int,pair<int,int>> tp = pq.top();\\n            int x = tp.second.first, y = tp.second.second;\\n            pq.pop();\\n            ans.push_back({nums1[x], nums2[y]});\\n            if(y != m-1)\\n                pq.push({nums1[x]+nums2[y+1],{x, y+1}});\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688696,
                "title": "my-kotlin-solution-with-time-o-klogk-and-space-o-k",
                "content": "The idea is to view all possible pair sums in a matrix form. Let\\'s draw a matrix that has a size of nums1.size * nums2.size, where the value at each cell (index1, index2) equals nums1[index1] + nums2[index2].\\n\\nThe most straightforward approach is to sort all pair sums and pick the first k pairs. However, this approach does not take advantage of the fact that both nums1 and nums2 are sorted, and it will result in a TLE error.\\n\\nSince nums2 is sorted, we know that the pair sum at cell (index1, index2+1) will be at least as large as the pair sum at cell (index1, index2). This means that until we pick the pair at cell (index1, index2), we can ignore the pair at cell (index1, index2+1) and so on. In other words, we need to consider the next column of a row only when we have picked the current column of that row.\\n\\nSince nums1 is sorted, we know that the pair sum at cell (index1+1, 0) will be at least as large as the pair sum at cell (index1, 0). This means that until we pick the pair at cell (index1, 0), we can ignore the pair at cell (index1+1, 0) and so on. In other words, we need to consider the next row only when we have picked the first column of the current row.\\n\\nBased on the above idea, below is my solution in kotlin,\\n```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(kLogk) and Space O(k);\\n     */\\n    fun kSmallestPairs(nums1: IntArray, nums2: IntArray, k: Int): List<List<Int>> {\\n        // pq of pair(index1, index2) where the pairs are compared by nums1[index1] + nums2[index2]\\n        val pq = PriorityQueue<Pair<Int, Int>>(compareBy { nums1[it.first] + nums2[it.second] })\\n        val result = mutableListOf<List<Int>>()\\n        pq.offer(Pair(0, 0))\\n        while (result.size < k && pq.isNotEmpty()) {\\n            val (index1, index2) = pq.poll()\\n            result.add(listOf(nums1[index1], nums2[index2]))\\n            if (index2 + 1 < nums2.size) {\\n                pq.offer(Pair(index1, index2 + 1))\\n            }\\n            if (index2 == 0 && index1 + 1 < nums1.size) {\\n                pq.offer(Pair(index1 + 1, 0))\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(kLogk) and Space O(k);\\n     */\\n    fun kSmallestPairs(nums1: IntArray, nums2: IntArray, k: Int): List<List<Int>> {\\n        // pq of pair(index1, index2) where the pairs are compared by nums1[index1] + nums2[index2]\\n        val pq = PriorityQueue<Pair<Int, Int>>(compareBy { nums1[it.first] + nums2[it.second] })\\n        val result = mutableListOf<List<Int>>()\\n        pq.offer(Pair(0, 0))\\n        while (result.size < k && pq.isNotEmpty()) {\\n            val (index1, index2) = pq.poll()\\n            result.add(listOf(nums1[index1], nums2[index2]))\\n            if (index2 + 1 < nums2.size) {\\n                pq.offer(Pair(index1, index2 + 1))\\n            }\\n            if (index2 == 0 && index1 + 1 < nums1.size) {\\n                pq.offer(Pair(index1 + 1, 0))\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688543,
                "title": "c-min-heap-linked-list-intuition-explained",
                "content": "# Intuition\\nThis Problem Can be thinked of a solution like Merging Linked Lists.\\nFor Example: **Consider the first example Given in the problem.**\\n```\\nnums1 = [1,7,11], nums2 = [2,4,6], k = 3\\nOutput: [[1,2],[1,4],[1,6]]\\n```\\nIn order to get the smallest sum we need to map the pairs to indexes as low as possible.\\nSince the given array is sorted in the ascending order the lowest numbers will be at the starting.\\n\\nSo What we are going to do is that make the pairs in form of a linked list. \\n**Didn\\'t Understand?** No worries,Lets see with the help of an example below.\\n```\\nStep1: Map Every number of nums1 array to the number of nums2 array.\\n       The result looks like this:\\n       (1,2)->(1,4)->(1,6) //for first num of nums1 to nums2\\n       (7,2)->(7,4)->(7,6) // second num of nums1 to nums2\\n       (11,2)->(11,4)->(11,6) // third num of nums1 to nums2.\\n    We have represented this in the form of a Linked List\\n\\nStep2: Store the head of every Linked List into the Min heap.\\n       Min heap gives us the minimum value and that will be stored at the top.\\n\\n       The Min Heap looks Like:\\n                        |(1,2) |\\n                        |(7,2) |\\n                        |(11,2)|\\n\\nStep3: Take out the top Most element from the min heap as this \\n       will contain the lowest sum.\\n\\n       The top Most element is (1,2) with the sum 1+2 = 3\\n\\nStep4: Next push the node into min heap which is next to the current\\n       node(1,2) i.e (1,4)\\n\\n       The Min Heap looks Like:\\n                        |(1,4) |\\n                        |(7,2) |\\n                        |(11,2)|\\n\\nStep5: Take out the top Most element from the min heap as this \\n       will contain the lowest sum.\\n\\n       The top Most element is (1,4) with the sum 1+4 = 8\\n\\nStep6: Next push the node into min heap which is next to the current\\n       node(1,4) i.e (1,6)\\n\\n       The Min Heap looks Like:\\n                        |(1,6) |\\n                        |(7,2) |\\n                        |(11,2)|\\n\\nStep7: Take out the top Most element from the min heap as this \\n       will contain the lowest sum.\\n\\n       The top Most element is (1,6) with the sum 1+6 = 7\\n\\nAs the the number of K Pairs Have been reached we can stop this Process.\\n\\n\\n```\\n\\n# Approach\\nDeclare a **priority_queue** which is min heap to store the minimum sum and a pair of indices of the **nums1** array and **nums2** array.\\nThat is it stores **pair<int, pair<int,int>>**\\n\\n- Firstly store all the heads of linked list into the min heap by just iterating over the **nums1 array** to store the pair with **\\'0\\'** th index of the **nums2 array**.\\n- After that take out the minimum sum from the **min heap** and store the next node of that linkedlist into the min heap just by incrementing the index of **nums2 array**.\\n- Make sure to check the out of bounds condition before pushing into min heap or else it will result into runtime Error.\\n\\n# Complexity\\n- Time complexity:\\n**O(Klog(N))**\\n\\n- Space complexity:\\n**O(Nums1.size( ))**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int,pair<int,int>> p;\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<p,vector<p>,greater<p>> minh;\\n        vector<vector<int>> ans;\\n        \\n        for(int i = 0;i < nums1.size();i++)\\n        {\\n            minh.push({nums1[i]+nums2[0],{i,0}});\\n        }\\n        \\n        while(!minh.empty() && k--)\\n        {\\n            int topF = minh.top().second.first;\\n            int topS = minh.top().second.second;\\n            minh.pop();\\n            \\n            ans.push_back({nums1[topF],nums2[topS]});\\n            \\n            if(topS+1<nums2.size())\\n            {\\n                minh.push({nums1[topF]+nums2[topS+1],{topF,topS+1}});   \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nnums1 = [1,7,11], nums2 = [2,4,6], k = 3\\nOutput: [[1,2],[1,4],[1,6]]\\n```\n```\\nStep1: Map Every number of nums1 array to the number of nums2 array.\\n       The result looks like this:\\n       (1,2)->(1,4)->(1,6) //for first num of nums1 to nums2\\n       (7,2)->(7,4)->(7,6) // second num of nums1 to nums2\\n       (11,2)->(11,4)->(11,6) // third num of nums1 to nums2.\\n    We have represented this in the form of a Linked List\\n\\nStep2: Store the head of every Linked List into the Min heap.\\n       Min heap gives us the minimum value and that will be stored at the top.\\n\\n       The Min Heap looks Like:\\n                        |(1,2) |\\n                        |(7,2) |\\n                        |(11,2)|\\n\\nStep3: Take out the top Most element from the min heap as this \\n       will contain the lowest sum.\\n\\n       The top Most element is (1,2) with the sum 1+2 = 3\\n\\nStep4: Next push the node into min heap which is next to the current\\n       node(1,2) i.e (1,4)\\n\\n       The Min Heap looks Like:\\n                        |(1,4) |\\n                        |(7,2) |\\n                        |(11,2)|\\n\\nStep5: Take out the top Most element from the min heap as this \\n       will contain the lowest sum.\\n\\n       The top Most element is (1,4) with the sum 1+4 = 8\\n\\nStep6: Next push the node into min heap which is next to the current\\n       node(1,4) i.e (1,6)\\n\\n       The Min Heap looks Like:\\n                        |(1,6) |\\n                        |(7,2) |\\n                        |(11,2)|\\n\\nStep7: Take out the top Most element from the min heap as this \\n       will contain the lowest sum.\\n\\n       The top Most element is (1,6) with the sum 1+6 = 7\\n\\nAs the the number of K Pairs Have been reached we can stop this Process.\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    typedef pair<int,pair<int,int>> p;\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<p,vector<p>,greater<p>> minh;\\n        vector<vector<int>> ans;\\n        \\n        for(int i = 0;i < nums1.size();i++)\\n        {\\n            minh.push({nums1[i]+nums2[0],{i,0}});\\n        }\\n        \\n        while(!minh.empty() && k--)\\n        {\\n            int topF = minh.top().second.first;\\n            int topS = minh.top().second.second;\\n            minh.pop();\\n            \\n            ans.push_back({nums1[topF],nums2[topS]});\\n            \\n            if(topS+1<nums2.size())\\n            {\\n                minh.push({nums1[topF]+nums2[topS+1],{topF,topS+1}});   \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687752,
                "title": "solution-using-heap-and-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n          PriorityQueue<Pair<Integer, Pair<Integer, Integer>>> pq = new PriorityQueue<>((a, b) -> b.getKey() - a.getKey());\\n        int n = nums1.length;\\n        int m = nums2.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n\\n                int sum = nums1[i] + nums2[j];\\n\\n                if (pq.size() < k) {\\n                    pq.offer(new Pair<>(sum, new Pair<>(nums1[i], nums2[j])));\\n                } else if (sum < pq.peek().getKey()) {\\n\\n                    pq.poll();\\n                    pq.offer(new Pair<>(sum, new Pair<>(nums1[i], nums2[j])));\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        while (!pq.isEmpty()) {\\n            Pair<Integer, Integer> pair = pq.poll().getValue();\\n            List<Integer> pairList = new ArrayList<>();\\n            pairList.add(pair.getKey());\\n            pairList.add(pair.getValue());\\n            ans.add(pairList);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n          PriorityQueue<Pair<Integer, Pair<Integer, Integer>>> pq = new PriorityQueue<>((a, b) -> b.getKey() - a.getKey());\\n        int n = nums1.length;\\n        int m = nums2.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n\\n                int sum = nums1[i] + nums2[j];\\n\\n                if (pq.size() < k) {\\n                    pq.offer(new Pair<>(sum, new Pair<>(nums1[i], nums2[j])));\\n                } else if (sum < pq.peek().getKey()) {\\n\\n                    pq.poll();\\n                    pq.offer(new Pair<>(sum, new Pair<>(nums1[i], nums2[j])));\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        while (!pq.isEmpty()) {\\n            Pair<Integer, Integer> pair = pq.poll().getValue();\\n            List<Integer> pairList = new ArrayList<>();\\n            pairList.add(pair.getKey());\\n            pairList.add(pair.getValue());\\n            ans.add(pairList);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687691,
                "title": "optimal-implementation-c-using-priority-queue",
                "content": "# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) { \\n        priority_queue<pair<int,pair<int,int>>> pq;\\n\\n        for(int i=0;i<nums1.size();i++) {\\n            for(int j=0;j<nums2.size();j++) {\\n                int sum=nums1[i]+nums2[j];\\n                if (pq.size()<k) {\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                else if (sum<pq.top().first) {\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                } else break;\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty()) {\\n            ans.push_back({pq.top().second.first, pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) { \\n        priority_queue<pair<int,pair<int,int>>> pq;\\n\\n        for(int i=0;i<nums1.size();i++) {\\n            for(int j=0;j<nums2.size();j++) {\\n                int sum=nums1[i]+nums2[j];\\n                if (pq.size()<k) {\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                else if (sum<pq.top().first) {\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                } else break;\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty()) {\\n            ans.push_back({pq.top().second.first, pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686996,
                "title": "c-beginner-friendly-solution-using-priority-queue",
                "content": "# Intuition\\nSimilar problem to finding kth smallest/largest number in array\\n\\n# Approach\\n\\n1) Declare a priority queue (max heap) of type \\npriority_queue<pair<int,pair<int,int>>> to store \\n    { sum , {nums[i] ,nums [j]}}\\n\\n        vector<vector<int>> ans;\\n        //max heap creation\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        //calculating sum\\n\\n2) Run 2 loops to calculate sum whaich will be the potentail canidate to be pushed in the heap \\n\\n        for(int i=0;i<nums1.size();i++)\\n            {   \\n              for(int j=0;j<nums2.size();j++)\\n                {\\n                    int sum=nums1[i]+nums2[j];\\n\\n3) Now there are 3 cases \\n - if size of pq is less than k (just push sum in pq)\\n - if size of pq ==k but incomming sum<k (then pop the pq.top() and push new sum)\\n - else is sum>pq.top just break from inner loop as it not a potentail candidate to be pushed\\n\\n                if(pq.size()<k)\\n                {\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                //if size is reached the limit if k but incomming sum is less than pq.top\\n                //pop the current item of pq and push new potential sum\\n                else if(sum<pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                //not a potential candidate as we have already lower sum answer so we ignore\\n                else if(sum>pq.top().first)\\n                {\\n                    break;\\n                }\\n\\n4) Finally we have pq of size k just pop the elements from top and push it into the answer\\n\\n        while(k!=0 and !pq.empty())\\n        {\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n            k--;\\n        }\\n        return ans;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ans;\\n        //max heap creation\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        //calculating sum\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                int sum=nums1[i]+nums2[j];\\n                //checking for pq size if less than k just keep on inserting in pq\\n                if(pq.size()<k)\\n                {\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                //if size is reached the limit if k but incomming sum is less than pq.top\\n                //pop the current item of pq and push new potential sum\\n                else if(sum<pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                //not a potential candidate as we have already lower sum answer so we ignore\\n                else if(sum>pq.top().first)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        //store the ans\\n        //just copy the pq into vector as we have created the pq of size k itself\\n        // pq has size k just copy it to ans and return \\n        while(k!=0 and !pq.empty())\\n        {\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ans;\\n        //max heap creation\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        //calculating sum\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                int sum=nums1[i]+nums2[j];\\n                //checking for pq size if less than k just keep on inserting in pq\\n                if(pq.size()<k)\\n                {\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                //if size is reached the limit if k but incomming sum is less than pq.top\\n                //pop the current item of pq and push new potential sum\\n                else if(sum<pq.top().first)\\n                {\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                //not a potential candidate as we have already lower sum answer so we ignore\\n                else if(sum>pq.top().first)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        //store the ans\\n        //just copy the pq into vector as we have created the pq of size k itself\\n        // pq has size k just copy it to ans and return \\n        while(k!=0 and !pq.empty())\\n        {\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634903,
                "title": "c-easy-solution-using-priority-queue",
                "content": "# Approach\\n- Create a priority queue to store pairs of the form (sum, (i, j)), where sum represents the sum of two elements from nums1 and nums2, and (i, j) represents the indices of those elements in nums1 and nums2 respectively.\\n- Iterate over the elements of nums1 and add the pairs (nums1[i] + nums2[0], (i, 0)) to the priority queue. This initializes the priority queue with pairs which include the first element from nums2.\\n- Perform the following steps while the priority queue is not empty and k is greater than zero:\\n\\n  1) Get the top element from the priority queue. it will have the smallest sum among the remaining pairs in the queue. Extract it\\'s index as x and y. Insert the numbers at those indexes in the ans vector as a pair. Pop the top element from the queue.\\n\\n  2. If the index y is not at the last element of nums2, add the pair (nums1[x] + nums2[y+1], (x, y+1)) to the priority queue. This ensures that we consider the next element from nums2 with the same element from nums1 to find the next smallest sum.\\n\\n  3. Decrement k by 1 to keep track of the number of pairs added to the ans vector.\\n- Return ans vector\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(klogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(max(n,k))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>> ans;\\n\\n        for(int i=0;i<n;i++){\\n            pq.push({nums1[i]+nums2[0],{i,0}});\\n        }\\n        while(pq.size() && k--){\\n            auto it=pq.top();\\n            int x=it.second.first,y=it.second.second;\\n            ans.push_back({nums1[x],nums2[y]});\\n            pq.pop();\\n            if(y+1<m) pq.push({nums1[x]+nums2[y+1],{x,y+1}});\\n        }          \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        int n = nums1.size(), m = nums2.size();\\n        vector<vector<int>> ans;\\n\\n        for(int i=0;i<n;i++){\\n            pq.push({nums1[i]+nums2[0],{i,0}});\\n        }\\n        while(pq.size() && k--){\\n            auto it=pq.top();\\n            int x=it.second.first,y=it.second.second;\\n            ans.push_back({nums1[x],nums2[y]});\\n            pq.pop();\\n            if(y+1<m) pq.push({nums1[x]+nums2[y+1],{x,y+1}});\\n        }          \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139090,
                "title": "c",
                "content": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nlong long countLessEqualItems(int val, int* nums1, int n1, int* nums2, int n2){\\n    long long ans = 0 ;\\n    for(int i = 0; i < n1; i++){\\n        int k = val - nums1[i] ;\\n        int l = 0, r = n2-1 ;\\n        if(nums2[0] > k)\\n            break ;\\n        while(l < r){\\n            int mid = r - (r-l)/2 ;\\n            if(nums2[mid] > k)\\n                r = mid - 1 ;\\n            else\\n                l = mid ;\\n        }\\n        ans += (l + 1) ;\\n    }\\n    return ans ;\\n}\\nint** kSmallestPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize, int** returnColumnSizes){\\n    int n1 = nums1Size ;\\n    int n2 = nums2Size ;\\n    int lower = nums1[0] + nums2[0] ;\\n    int upper = nums1[n1-1] + nums2[n2-1] ;\\n\\n    while(lower < upper){\\n        int mid = lower + (upper - lower) / 2 ;\\n        long long t = countLessEqualItems(mid, nums1, n1, nums2, n2) ;\\n        if(t >= k)\\n            upper = mid ;\\n        else\\n            lower = mid + 1 ;\\n    }\\n\\n    int** ans = malloc(k * sizeof(int*)) ;\\n    for(int i = 0; i < k; i++){\\n        ans[i] = malloc(2 * sizeof(int) );\\n    }\\n    int** tmp = malloc(k * sizeof(int*)) ;\\n    int a_idx = 0, t_idx = 0 ;\\n    for(int i = 0; i < n1; i++){\\n        for(int j = 0;  j < n2; j++){\\n            int sum = nums1[i] + nums2[j] ;\\n            if(sum < lower){\\n                ans[a_idx][0] = nums1[i] ;\\n                ans[a_idx][1] = nums2[j] ;\\n                a_idx++ ;\\n            }\\n            else if(sum == lower){\\n                if(t_idx == k)\\n                    break ;\\n                tmp[t_idx] = malloc(2 * sizeof(int)) ;\\n                tmp[t_idx][0] = nums1[i] ;\\n                tmp[t_idx][1] = nums2[j] ;\\n                t_idx++ ;\\n            }\\n            else \\n                break ;\\n        }\\n    }\\n\\n    int a = 0 ;\\n\\n    if(a_idx < k){\\n        for(int i = a_idx; i < k; i++){\\n            if(a == t_idx)\\n                break ;\\n            ans[a_idx][0] = tmp[a][0] ;\\n            ans[a_idx][1] = tmp[a][1] ;\\n            a++ ;\\n            a_idx++ ;\\n        }\\n    }\\n\\n    *returnSize = a_idx ;\\n    *returnColumnSizes = malloc(a_idx * sizeof(int)) ;\\n    \\n    for(int i = 0; i < a_idx; i++){\\n        returnColumnSizes[0][i] = 2 ;\\n    }\\n    for(int i = 0; i < t_idx; i++){\\n        free(tmp[i]) ;\\n    }\\n    free(tmp) ;\\n    return ans ;\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nlong long countLessEqualItems(int val, int* nums1, int n1, int* nums2, int n2){\\n    long long ans = 0 ;\\n    for(int i = 0; i < n1; i++){\\n        int k = val - nums1[i] ;\\n        int l = 0, r = n2-1 ;\\n        if(nums2[0] > k)\\n            break ;\\n        while(l < r){\\n            int mid = r - (r-l)/2 ;\\n            if(nums2[mid] > k)\\n                r = mid - 1 ;\\n            else\\n                l = mid ;\\n        }\\n        ans += (l + 1) ;\\n    }\\n    return ans ;\\n}\\nint** kSmallestPairs(int* nums1, int nums1Size, int* nums2, int nums2Size, int k, int* returnSize, int** returnColumnSizes){\\n    int n1 = nums1Size ;\\n    int n2 = nums2Size ;\\n    int lower = nums1[0] + nums2[0] ;\\n    int upper = nums1[n1-1] + nums2[n2-1] ;\\n\\n    while(lower < upper){\\n        int mid = lower + (upper - lower) / 2 ;\\n        long long t = countLessEqualItems(mid, nums1, n1, nums2, n2) ;\\n        if(t >= k)\\n            upper = mid ;\\n        else\\n            lower = mid + 1 ;\\n    }\\n\\n    int** ans = malloc(k * sizeof(int*)) ;\\n    for(int i = 0; i < k; i++){\\n        ans[i] = malloc(2 * sizeof(int) );\\n    }\\n    int** tmp = malloc(k * sizeof(int*)) ;\\n    int a_idx = 0, t_idx = 0 ;\\n    for(int i = 0; i < n1; i++){\\n        for(int j = 0;  j < n2; j++){\\n            int sum = nums1[i] + nums2[j] ;\\n            if(sum < lower){\\n                ans[a_idx][0] = nums1[i] ;\\n                ans[a_idx][1] = nums2[j] ;\\n                a_idx++ ;\\n            }\\n            else if(sum == lower){\\n                if(t_idx == k)\\n                    break ;\\n                tmp[t_idx] = malloc(2 * sizeof(int)) ;\\n                tmp[t_idx][0] = nums1[i] ;\\n                tmp[t_idx][1] = nums2[j] ;\\n                t_idx++ ;\\n            }\\n            else \\n                break ;\\n        }\\n    }\\n\\n    int a = 0 ;\\n\\n    if(a_idx < k){\\n        for(int i = a_idx; i < k; i++){\\n            if(a == t_idx)\\n                break ;\\n            ans[a_idx][0] = tmp[a][0] ;\\n            ans[a_idx][1] = tmp[a][1] ;\\n            a++ ;\\n            a_idx++ ;\\n        }\\n    }\\n\\n    *returnSize = a_idx ;\\n    *returnColumnSizes = malloc(a_idx * sizeof(int)) ;\\n    \\n    for(int i = 0; i < a_idx; i++){\\n        returnColumnSizes[0][i] = 2 ;\\n    }\\n    for(int i = 0; i < t_idx; i++){\\n        free(tmp[i]) ;\\n    }\\n    free(tmp) ;\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3124119,
                "title": "golang-one-minheap-solution",
                "content": "# Code\\n```\\nfunc kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {\\n    result := make([][]int, 0)\\n    minHeap := &SetHeap{}\\n    heap.Init(minHeap)\\n    for i, v1 := range nums1 {\\n        heap.Push(minHeap, Set{sum: v1 + nums2[0], i: i, j: 0})\\n    }\\n\\n    for !minHeap.Empty() && k > 0 {\\n        currentMin := heap.Pop(minHeap).(Set)\\n        i, j := currentMin.i, currentMin.j\\n        result = append(result, []int{nums1[i], nums2[j]})\\n\\n        nextElement := j + 1\\n        if nextElement < len(nums2) {\\n            heap.Push(minHeap, Set{sum: nums1[i] + nums2[nextElement], i: i, j: nextElement})\\n        }\\n        k--\\n    } \\n\\n    return result\\n}\\n\\ntype Set struct {\\n    sum int\\n    i int\\n    j int\\n}\\n\\ntype SetHeap []Set\\n\\nfunc (h SetHeap) Len() int           { return len(h) }\\nfunc (h SetHeap) Less(i, j int) bool { return h[i].sum < h[j].sum }\\nfunc (h SetHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\nfunc (h SetHeap) Empty() bool        { return len(h) == 0 }\\n\\nfunc (h *SetHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(Set))\\n}\\n\\nfunc (h *SetHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunc kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {\\n    result := make([][]int, 0)\\n    minHeap := &SetHeap{}\\n    heap.Init(minHeap)\\n    for i, v1 := range nums1 {\\n        heap.Push(minHeap, Set{sum: v1 + nums2[0], i: i, j: 0})\\n    }\\n\\n    for !minHeap.Empty() && k > 0 {\\n        currentMin := heap.Pop(minHeap).(Set)\\n        i, j := currentMin.i, currentMin.j\\n        result = append(result, []int{nums1[i], nums2[j]})\\n\\n        nextElement := j + 1\\n        if nextElement < len(nums2) {\\n            heap.Push(minHeap, Set{sum: nums1[i] + nums2[nextElement], i: i, j: nextElement})\\n        }\\n        k--\\n    } \\n\\n    return result\\n}\\n\\ntype Set struct {\\n    sum int\\n    i int\\n    j int\\n}\\n\\ntype SetHeap []Set\\n\\nfunc (h SetHeap) Len() int           { return len(h) }\\nfunc (h SetHeap) Less(i, j int) bool { return h[i].sum < h[j].sum }\\nfunc (h SetHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\nfunc (h SetHeap) Empty() bool        { return len(h) == 0 }\\n\\nfunc (h *SetHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(Set))\\n}\\n\\nfunc (h *SetHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798444,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n    vector<vector<int>> res;\\n   \\n    priority_queue<pair<int,pair<int,int>>> pq;\\n    \\n    for(auto x:nums1){\\n        for(auto y:nums2){\\n            int sum=x+y;\\n            if( pq.size()<k){\\n                 pq.push({sum,{x,y}});\\n            }\\n            else if(sum < pq.top().first)\\n            {\\n                pq.pop();\\n                pq.push({sum,{x,y}});\\n            }\\n            else\\n                break;\\n        }\\n    }\\n    \\n    while(!pq.empty() ){\\n       auto p=pq.top().second;\\n        pq.pop();\\n        \\n        res.push_back({p.first,p.second});\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n\\n    vector<vector<int>> res;\\n   \\n    priority_queue<pair<int,pair<int,int>>> pq;\\n    \\n    for(auto x:nums1){\\n        for(auto y:nums2){\\n            int sum=x+y;\\n            if( pq.size()<k){\\n                 pq.push({sum,{x,y}});\\n            }\\n            else if(sum < pq.top().first)\\n            {\\n                pq.pop();\\n                pq.push({sum,{x,y}});\\n            }\\n            else\\n                break;\\n        }\\n    }\\n    \\n    while(!pq.empty() ){\\n       auto p=pq.top().second;\\n        pq.pop();\\n        \\n        res.push_back({p.first,p.second});\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682614,
                "title": "c-priority-queue-simple-code",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<pair<int,pair<int,int>>> pq; \\n        for(int i=0;i<nums1.size();i++) {\\n            for(int j=0;j<nums2.size();j++) {\\n                int sum=nums1[i]+nums2[j];\\n                if (pq.size()<k) {\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                else if (sum<pq.top().first) {\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                } else {\\n                    break; \\n                }\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        while(!pq.empty()) {\\n            ans.push_back({pq.top().second.first, pq.top().second.second});\\n            pq.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        priority_queue<pair<int,pair<int,int>>> pq; \\n        for(int i=0;i<nums1.size();i++) {\\n            for(int j=0;j<nums2.size();j++) {\\n                int sum=nums1[i]+nums2[j];\\n                if (pq.size()<k) {\\n                    pq.push({sum,{nums1[i],nums2[j]}",
                "codeTag": "Java"
            },
            {
                "id": 2658576,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    \\n\\t\\n\\t\\n\\tclass pair implements Comparable<pair>{\\n        int num1;\\n        int num2;\\n        int sum;\\n        int idx;\\n        pair(int num1,int num2,int sum,int idx){\\n            this.num1=num1;\\n            this.num2=num2;\\n            this.sum=sum;\\n            this.idx=idx;\\n        }\\n        public int compareTo(pair p){\\n            return this.sum-p.sum;\\n        }\\n    }\\n    \\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<pair>pq=new PriorityQueue<>();\\n        for(int i=0;i<Math.min(k,nums1.length);i++){\\n                pq.add(new pair(nums1[i],nums2[0],nums1[i]+nums2[0],0));\\n        }\\n        \\n        List<List<Integer>>list=new ArrayList<>();\\n        while(k-->0 && pq.size()>0){\\n            List<Integer>l=new ArrayList<>();\\n            pair p=pq.remove();\\n            l.add(p.num1);\\n            l.add(p.num2);\\n            list.add(l);\\n            int idx=p.idx;\\n            if(idx<nums2.length-1){\\n                pq.add(new pair(p.num1,nums2[idx+1],p.num1+nums2[idx+1],p.idx+1));\\n            }\\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    \\n\\t\\n\\t\\n\\tclass pair implements Comparable<pair>{\\n        int num1;\\n        int num2;\\n        int sum;\\n        int idx;\\n        pair(int num1,int num2,int sum,int idx){\\n            this.num1=num1;\\n            this.num2=num2;\\n            this.sum=sum;\\n            this.idx=idx;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2336297,
                "title": "java-soln-tc-o-klogk-with-explanation-and-proof-of-algo",
                "content": "The explanation of algo:\\n1. There are (nm) number of valid pairs to choose from. \\n2. Since both arrays are sorted we can map the two arrays onto a matrix of dim: nxm s.t matrix[i][j]==nums1[i]+nums2[j];\\n3. Now once this matrix is created we simply need to report the k smallest elements. And from fact that the arrays were sorted, the matrix created is also row-wise and col-wise sorted\\n4. This problem converts to k smallest elements in a sorted matrix.\\n\\n**Important points:**\\nTaken from this amazing post: https://leetcode.com/problems/k-th-smallest-prime-fraction/discuss/115819/Summary-of-solutions-for-problems-%22reducible%22-to-LeetCode-378\\n1. We consider the first column of the matrix namely analysing all <i,0> pairs since these pairs will surely give us the 1st min element. Now whenever a pair <i,j> is taken as a min, put it in the resultant array and replace it with <i, j+1> and put inside the pq( Take care of the index out of bounds error). Although <i+1, j> and <i, j+1> are the best candidates for the next smallest, the reason we add only <i, j+1> is beacuse <i+1,j> is already present in the Heap.\\n2. We dont necessarily need to add <i,0> for i=0 to n-1, rather it will suffice to only add indices upto min(n-1,k). and proof of correctness for this statement is as follows:\\n\\n*(Proof by contradiction)*\\n\\n**Assumption**: Let us assume that <k+1, j> was indeed an element that was one of the k smallest elements.\\n\\nSo if this is the case that means <i,j> for i=0 to k will all have values less that <i+1, j> since the ip arrays are sorted, which means even considering these k+1 elements, <i+1,j> will never be inside the k smallest elements.\\nBut this contradicts the fact that <i+1,j> was indeed one of the k smallest elements. \\nHence by contradiction our assumption was wrong and hence proved that to take k smallest pairs, we dont need elements beyond k in both the arrays.\\n\\nHere is the code:\\n```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        int n=nums1.length, m=nums2.length;\\n        PriorityQueue<Pair> pq=new PriorityQueue<Pair>((a,b)->((nums1[a.arr[0]]+nums2[a.arr[1]])-(nums2[b.arr[1]]+nums1[b.arr[0]])));\\n        for(int i=0;i<n && i<k;i++)\\n            pq.add(new Pair(i, 0));\\n        while(k-->0 && !pq.isEmpty()){\\n            Pair x=pq.poll();\\n            List<Integer> arr=new ArrayList<>();\\n            arr.add(nums1[x.arr[0]]);arr.add(nums2[x.arr[1]]);\\n            res.add(arr);\\n            x.arr[1]+=1;\\n            if(x.arr[1]<m)\\n                pq.add(new Pair(x.arr[0], x.arr[1]));\\n        }\\n        return res;\\n    }\\n}\\nclass Pair{\\n    int[] arr;\\n    public Pair(int i, int j){\\n        arr=new int[2];\\n        arr[0]=i;\\n        arr[1]=j;\\n    }\\n}\\n```\\nTime complexity-> O(KlogK) (We only have K elements in the heap and we heapify at max K times)\\nSpace complexity->O(K) (To store k possible pairs)\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        int n=nums1.length, m=nums2.length;\\n        PriorityQueue<Pair> pq=new PriorityQueue<Pair>((a,b)->((nums1[a.arr[0]]+nums2[a.arr[1]])-(nums2[b.arr[1]]+nums1[b.arr[0]])));\\n        for(int i=0;i<n && i<k;i++)\\n            pq.add(new Pair(i, 0));\\n        while(k-->0 && !pq.isEmpty()){\\n            Pair x=pq.poll();\\n            List<Integer> arr=new ArrayList<>();\\n            arr.add(nums1[x.arr[0]]);arr.add(nums2[x.arr[1]]);\\n            res.add(arr);\\n            x.arr[1]+=1;\\n            if(x.arr[1]<m)\\n                pq.add(new Pair(x.arr[0], x.arr[1]));\\n        }\\n        return res;\\n    }\\n}\\nclass Pair{\\n    int[] arr;\\n    public Pair(int i, int j){\\n        arr=new int[2];\\n        arr[0]=i;\\n        arr[1]=j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281179,
                "title": "c-solution-easy",
                "content": "```\\n vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        //we will have two loops here to make all possible pairs\\n        //we will have a max heap of pair with first as sum and second as that pair.\\n        //we will push k smallest in ans vector.\\n        priority_queue<pair<int,pair<int,int>>>mh;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int sum = nums1[i]+nums2[j];\\n                //how to treat TLE\\n                if(mh.size()<k){\\n                    mh.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                else if (sum<mh.top().first) {\\n                    mh.pop();\\n                    mh.push({sum,{nums1[i],nums2[j]}});\\n                } else {\\n                    break;  // since it is sorted so we can say that rest of vector 2 should have greater sum than this ,so we break inner loop, so it took less time.\\n                }\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        while(!mh.empty()){\\n            ans.push_back({mh.top().second.first,mh.top().second.second});\\n            mh.pop();\\n        }\\n        return ans;\\n        //TC  = O(n*mlogk)\\n        //SC = O(k)\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        //we will have two loops here to make all possible pairs\\n        //we will have a max heap of pair with first as sum and second as that pair.\\n        //we will push k smallest in ans vector.\\n        priority_queue<pair<int,pair<int,int>>>mh;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int sum = nums1[i]+nums2[j];\\n                //how to treat TLE\\n                if(mh.size()<k){\\n                    mh.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                else if (sum<mh.top().first) {\\n                    mh.pop();\\n                    mh.push({sum,{nums1[i],nums2[j]}});\\n                } else {\\n                    break;  // since it is sorted so we can say that rest of vector 2 should have greater sum than this ,so we break inner loop, so it took less time.\\n                }\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        while(!mh.empty()){\\n            ans.push_back({mh.top().second.first,mh.top().second.second});\\n            mh.pop();\\n        }\\n        return ans;\\n        //TC  = O(n*mlogk)\\n        //SC = O(k)\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2150972,
                "title": "c-easy-solution-using-heap-with-explanation",
                "content": "At first we traverse in nums1 and nums2 simultaneously, and find the sum and then insert it in priority queue \"pq\".\\nTerminating conditions:-\\n\\t1. Priority queue.size()>=\"k\".\\n\\t2. If The sum exceeds or is equal the top value when heap size is equal to\"k\".\\nThen just enter the pairs in vector \"v\".\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>v;\\n        priority_queue<pair<int,pair<int,int>>>pq;\\n        for(auto x:nums1){\\n            if(pq.size()==k&&x+nums2[0]>=pq.top().first)\\n                break;\\n            for(auto y:nums2){\\n                pq.push({(x+y),{x,y}});\\n                while(pq.size()>k)\\n                    pq.pop();\\n                if(pq.size()==k&&(x+y)>=pq.top().first)\\n                    break;\\n            }\\n        }\\n        while(pq.size()){\\n            v.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>v;\\n        priority_queue<pair<int,pair<int,int>>>pq;\\n        for(auto x:nums1){\\n            if(pq.size()==k&&x+nums2[0]>=pq.top().first)\\n                break;\\n            for(auto y:nums2){\\n                pq.push({(x+y),{x,y}});\\n                while(pq.size()>k)\\n                    pq.pop();\\n                if(pq.size()==k&&(x+y)>=pq.top().first)\\n                    break;\\n            }\\n        }\\n        while(pq.size()){\\n            v.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021509,
                "title": "clean-concise-java-solution-o-klogk-time",
                "content": "### Brute force insights\\nPick K elements from nums1 and nums2 each.\\nNext, using K^2 pairs, pick the \"K\" smallest pairs using a min heap. \\nHowever, this approach is K^2 Log(K^2) -> K^2 Log(K).\\nCan this be improved?\\n\\n### KLog(K) Explanation using example\\n```text\\nnums1 = [1,7,11], nums2 = [2,4,6], k = 3\\n\\nIf you consider every (i, j) pair from nums1 and nums2, you get:-\\n(1, 2),  (1, 4),  (1, 6)         -  row1\\n(7, 2),  (7, 4),  (7, 6)         -  row2\\n(11, 2), (11, 4), (11, 6)        -  row3\\n```\\nNotice how the sum of pairs in each row is sorted. \\nThus, \"Given k rows consisting of pairs sorted by sums, find k smallest pairs\". In other words, this boils down to merge k sorted lists. \\nIn this problem, you can terminate early when you find \"k\" smallest pairs. This early termination reduces complexity to O(KLogK)\\n\\n### Code\\n```java\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        // Min Heap of int array. Smallest sum pair will be at top.\\n        // array[0] - item in nums1, array[1] - item in nums2, array[2] - index of item in nums2 \\n        var pq = new PriorityQueue<int[]>(\\n            k, (arr1, arr2) -> (arr1[0] + arr1[1]) - (arr2[0] + arr2[1]));\\n        \\n        var result = new ArrayList<List<Integer>>(k);\\n        \\n        final int N1 = nums1.length, N2 = nums2.length;\\n        for (int i = 0; i < Math.min(k, N1); i++) {\\n            pq.add(new int[]{ nums1[i], nums2[0], 0 });\\n        }\\n        \\n        while (result.size() < k && !pq.isEmpty()) {\\n            var top = pq.poll();\\n            result.add(Arrays.asList(top[0], top[1]));\\n            \\n            var nextIndex = top[2] + 1;\\n            if (nextIndex < N2) {\\n                pq.add(new int[] { top[0], nums2[nextIndex], nextIndex });\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```text\\nnums1 = [1,7,11], nums2 = [2,4,6], k = 3\\n\\nIf you consider every (i, j) pair from nums1 and nums2, you get:-\\n(1, 2),  (1, 4),  (1, 6)         -  row1\\n(7, 2),  (7, 4),  (7, 6)         -  row2\\n(11, 2), (11, 4), (11, 6)        -  row3\\n```\n```java\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        // Min Heap of int array. Smallest sum pair will be at top.\\n        // array[0] - item in nums1, array[1] - item in nums2, array[2] - index of item in nums2 \\n        var pq = new PriorityQueue<int[]>(\\n            k, (arr1, arr2) -> (arr1[0] + arr1[1]) - (arr2[0] + arr2[1]));\\n        \\n        var result = new ArrayList<List<Integer>>(k);\\n        \\n        final int N1 = nums1.length, N2 = nums2.length;\\n        for (int i = 0; i < Math.min(k, N1); i++) {\\n            pq.add(new int[]{ nums1[i], nums2[0], 0 });\\n        }\\n        \\n        while (result.size() < k && !pq.isEmpty()) {\\n            var top = pq.poll();\\n            result.add(Arrays.asList(top[0], top[1]));\\n            \\n            var nextIndex = top[2] + 1;\\n            if (nextIndex < N2) {\\n                pq.add(new int[] { top[0], nums2[nextIndex], nextIndex });\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980834,
                "title": "python3-min-heap-o-klogk-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        h=[(nums1[0]+nums2[0],0,0)]\\n        seen=set((0,0))\\n        res=[]\\n        while h and len(res)<k:\\n            total,i,j=heapq.heappop(h)\\n            res.append([nums1[i],nums2[j]])\\n            if i<len(nums1)-1 and (i+1,j) not in seen: \\n                heapq.heappush(h,(nums1[i+1]+nums2[j],i+1,j))\\n                seen.add((i+1,j))\\n            if j<len(nums2)-1 and (i,j+1) not in seen: \\n                heapq.heappush(h,(nums1[i]+nums2[j+1],i,j+1))\\n                seen.add((i,j+1))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        h=[(nums1[0]+nums2[0],0,0)]\\n        seen=set((0,0))\\n        res=[]\\n        while h and len(res)<k:\\n            total,i,j=heapq.heappop(h)\\n            res.append([nums1[i],nums2[j]])\\n            if i<len(nums1)-1 and (i+1,j) not in seen: \\n                heapq.heappush(h,(nums1[i+1]+nums2[j],i+1,j))\\n                seen.add((i+1,j))\\n            if j<len(nums2)-1 and (i,j+1) not in seen: \\n                heapq.heappush(h,(nums1[i]+nums2[j+1],i,j+1))\\n                seen.add((i,j+1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839878,
                "title": "a-little-optimized-java-solution",
                "content": "```class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<Pair> heap = new PriorityQueue<>((p1, p2) -> p2.getSum() - p1.getSum());\\n        for (int i = 0; i < Math.min(nums1.length, k); ++i) {\\n            for (int j = 0; j < Math.min(nums2.length, k); ++j) {\\n                Pair cur = new Pair(nums1[i], nums2[j]);\\n                if (heap.size() == k) {\\n                    if (heap.peek().getSum() > cur.getSum()) {\\n                        heap.poll();\\n                        heap.offer(cur);   \\n                    } else {\\n                        break;\\n                    }\\n                } else {\\n                    heap.offer(cur);\\n                }\\n            }\\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (Pair p: heap) {\\n            res.add(Arrays.asList(p.x, p.y));\\n        }\\n        return res;\\n    }\\n    \\n    class Pair {\\n        int x;\\n        int y;\\n\\n        public Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public int getSum() {\\n            return x + y;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<Pair> heap = new PriorityQueue<>((p1, p2) -> p2.getSum() - p1.getSum());\\n        for (int i = 0; i < Math.min(nums1.length, k); ++i) {\\n            for (int j = 0; j < Math.min(nums2.length, k); ++j) {\\n                Pair cur = new Pair(nums1[i], nums2[j]);\\n                if (heap.size() == k) {\\n                    if (heap.peek().getSum() > cur.getSum()) {\\n                        heap.poll();\\n                        heap.offer(cur);   \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1778605,
                "title": "java-priority-queue",
                "content": "**Intuition**\\n\\n    1. What will be the answer if nums2 is null? What will be the answer if nums2 had only one value?\\n    2. The first k pairs would be the, each num in nums1 paired with nums2[0]\\n    3. If nums2[1] exits the smallest sum would be num1[0]+nums2[1]\\n    4. Let minHeap handle the ordering of sum.\\n    5. TC - O(Nlog(N)) - N = len(nums1)+len(nums2);\\n    6. Optimization - Build Heap of size k && remove the peek before inserting a new value\\n\\n\\n```\\n\\tpublic List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<int[]> que = new PriorityQueue<>((a,b)->a[2]-b[2]);\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(nums1.length==0 || nums2.length==0 || k==0) return res;\\n        for(int i=0; i<nums1.length && i<k; i++) \\n            que.offer(new int[]{i, 0, nums1[i] + nums2[0]});\\n        while(k-- > 0 && !que.isEmpty()){\\n            int[] curr = que.poll();\\n            int i = curr[0], j = curr[1];\\n            res.add(Arrays.asList(nums1[i], nums2[j]));\\n            if(j+1 == nums2.length) continue;\\n            que.offer(new int[]{i, j+1, nums1[i] + nums2[j+1]});\\n        }\\n        return res;\\n     }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\tpublic List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<int[]> que = new PriorityQueue<>((a,b)->a[2]-b[2]);\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(nums1.length==0 || nums2.length==0 || k==0) return res;\\n        for(int i=0; i<nums1.length && i<k; i++) \\n            que.offer(new int[]{i, 0, nums1[i] + nums2[0]});\\n        while(k-- > 0 && !que.isEmpty()){\\n            int[] curr = que.poll();\\n            int i = curr[0], j = curr[1];\\n            res.add(Arrays.asList(nums1[i], nums2[j]));\\n            if(j+1 == nums2.length) continue;\\n            que.offer(new int[]{i, j+1, nums1[i] + nums2[j+1]});\\n        }\\n        return res;\\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729452,
                "title": "o-klogk-heap-proof-and-explanation-with-python-read-if-confused",
                "content": "**BASE CASE**\\nIt\\'s obvious that indices of the 1st smallest-sum pair is going to be [0, 0].\\n\\n**INDUCTION STEP**\\nLet\\'s assume we have the INDICES (not the array VALUES, but rather the indices themselves; we can find the values later) of the first N pairs with the smallest sums:\\n\\n[a, b]\\n[c, d]\\n[e, f]\\n...\\n\\nI\\'m going to make the key observation of the proof:\\n\\nThe next smallest-sum pair will have indices ONE away from one pair in our answer set. Meaning: if [x, y] are indices of the next smallest-sum pair, [x - 1, y] OR [x, y - 1] is in our answer set already.\\n\\n\\n**PROOF OF THAT OBSERVATION**\\nWe\\'ll prove that claim via contradiction. Let\\'s assume that [x, y] are the indices of the next smallest-sum pair, and neither [x - 1, y] nor [x, y - 1] is in the index set of our answers so far.\\n\\nBut... both [x - 1, y] and [x, y - 1] are going to have a smaller sum than [x, y] because the array is sorted. \\n\\nThen [x, y] CAN\\'T be the next smallest-sum pair. Contradiction!\\n\\nTherefore, we proved by contradiction: if [x, y] is the next smallest-sum pair, then we already found either [x - 1, y] or [x, y - 1]\\n\\n**SO LET\\'S WRITE AN ALGORITHM TO DO THAT**\\n\\nEach time we find an answer, let\\'s add [x + 1, y] and [x, y + 1] to our index set, and store it in a heap. This way, we\\'re checking the one-away indices of ALL the answers we\\'ve seen so far. This gets us klogk complexity.\\n\\n**BUT WE CAN HAVE DUPLICATES**\\n\\nYou can have duplicates, because there\\'s 2 ways to get to the indices [1, 1]: [0 + 1, 1] or [1, 0 +1]. So we have to keep a set of what we\\'ve seen so far.\\n\\n**PYTHON3 CODE**\\n\\n```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        heap = [[nums1[0] + nums2[0], 0, 0]] #[sum, nums1_index, nums2_index]\\n        seen = set()\\n        ans = []\\n\\n        while len(ans) < min(len(nums1) * len(nums2), k):\\n            lastAns = heapq.heappop(heap)\\n            while (str(lastAns) in seen):\\n                lastAns = heapq.heappop(heap)\\n            \\n            seen.add(str(lastAns))\\n            ans.append([nums1[lastAns[1]], nums2[lastAns[2]]])\\n\\n            if (lastAns[1] + 1 < len(nums1)):\\n                sum = nums1[lastAns[1] + 1] + nums2[lastAns[2]]\\n                heapq.heappush(heap, [sum, lastAns[1] + 1, lastAns[2]])\\n            if (lastAns[2] + 1 < len(nums2)):\\n                sum = nums1[lastAns[1]] + nums2[lastAns[2] + 1]\\n                heapq.heappush(heap, [sum, lastAns[1], lastAns[2] + 1])\\n                \\n        return ans\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        heap = [[nums1[0] + nums2[0], 0, 0]] #[sum, nums1_index, nums2_index]\\n        seen = set()\\n        ans = []\\n\\n        while len(ans) < min(len(nums1) * len(nums2), k):\\n            lastAns = heapq.heappop(heap)\\n            while (str(lastAns) in seen):\\n                lastAns = heapq.heappop(heap)\\n            \\n            seen.add(str(lastAns))\\n            ans.append([nums1[lastAns[1]], nums2[lastAns[2]]])\\n\\n            if (lastAns[1] + 1 < len(nums1)):\\n                sum = nums1[lastAns[1] + 1] + nums2[lastAns[2]]\\n                heapq.heappush(heap, [sum, lastAns[1] + 1, lastAns[2]])\\n            if (lastAns[2] + 1 < len(nums2)):\\n                sum = nums1[lastAns[1]] + nums2[lastAns[2] + 1]\\n                heapq.heappush(heap, [sum, lastAns[1], lastAns[2] + 1])\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447091,
                "title": "clean-python-solution-explained-heap-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\nTime: O(kLogk)\\nSpace: O(N)\\n\\n[0]\\nDeclare a min-heap. Which stores the (sum, index in nums1, index in nums2) for each combination.\\n\\n[1]\\nEach iteration, we get a min sum (i, j) from the heap and add it to the `ans`.\\nThe next possible smallest combination will be either (i+1, j) or (j+1, i) or other combination previously added.\\nAdd combination (i+1, j) and (j+1, i) to the heap.\\n\\n[2]\\nUse a set `seen` to avoid adding the same element to the heap.\\nFor example (i+1, j) and (j+1, i) can both lead to (i+1, j+1).\\n\"\"\"\\n\\nclass Solution(object):\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        if not nums1 or not nums2: return []\\n        if k>len(nums1)*len(nums2): k = len(nums1)*len(nums2)\\n            \\n        ans = []\\n        h = [(nums1[0]+nums2[0], 0, 0)] #[0]\\n        seen = set([(0,0)]) #[2]\\n        \\n        while len(ans)<k: #[1]\\n            s, i, j = heapq.heappop(h)\\n            ans.append((nums1[i], nums2[j]))\\n\\t\\t\\t\\n            if i+1<len(nums1) and (i+1, j) not in seen:\\n                heapq.heappush(h, (nums1[i+1]+nums2[j], i+1, j))\\n                seen.add((i+1, j))\\n\\t\\t\\t\\t\\n            if j+1<len(nums2) and (i, j+1) not in seen:\\n                heapq.heappush(h, (nums1[i]+nums2[j+1], i, j+1))\\n                seen.add((i, j+1))\\n\\t\\t\\t\\t\\n        return ans\\n\\t\\t\\n\"\"\"\\nRelated Problems:\\nUgly Number, Ugly Number II\\nSuper Ugly Number\\nFind K Pairs with Smallest Sums from two arrays\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(kLogk)\\nSpace: O(N)\\n\\n[0]\\nDeclare a min-heap. Which stores the (sum, index in nums1, index in nums2) for each combination.\\n\\n[1]\\nEach iteration, we get a min sum (i, j) from the heap and add it to the `ans`.\\nThe next possible smallest combination will be either (i+1, j) or (j+1, i) or other combination previously added.\\nAdd combination (i+1, j) and (j+1, i) to the heap.\\n\\n[2]\\nUse a set `seen` to avoid adding the same element to the heap.\\nFor example (i+1, j) and (j+1, i) can both lead to (i+1, j+1).\\n\"\"\"\\n\\nclass Solution(object):\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        if not nums1 or not nums2: return []\\n        if k>len(nums1)*len(nums2): k = len(nums1)*len(nums2)\\n            \\n        ans = []\\n        h = [(nums1[0]+nums2[0], 0, 0)] #[0]\\n        seen = set([(0,0)]) #[2]\\n        \\n        while len(ans)<k: #[1]\\n            s, i, j = heapq.heappop(h)\\n            ans.append((nums1[i], nums2[j]))\\n\\t\\t\\t\\n            if i+1<len(nums1) and (i+1, j) not in seen:\\n                heapq.heappush(h, (nums1[i+1]+nums2[j], i+1, j))\\n                seen.add((i+1, j))\\n\\t\\t\\t\\t\\n            if j+1<len(nums2) and (i, j+1) not in seen:\\n                heapq.heappush(h, (nums1[i]+nums2[j+1], i, j+1))\\n                seen.add((i, j+1))\\n\\t\\t\\t\\t\\n        return ans\\n\\t\\t\\n\"\"\"\\nRelated Problems:\\nUgly Number, Ugly Number II\\nSuper Ugly Number\\nFind K Pairs with Smallest Sums from two arrays\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296962,
                "title": "c-simple-solution-o-klogk",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> ppi;\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n = nums1.size(); \\n        int m = nums2.size();\\n        \\n        priority_queue<ppi, vector<ppi>, greater<ppi>> q;\\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < k && i < n; i++)\\n            q.push({nums1[i]+nums2[0], {i, 0}});\\n        \\n        while(!q.empty() && k--){\\n            auto [i, j] = q.top().second;\\n            q.pop();\\n            res.push_back({nums1[i], nums2[j]});\\n            \\n            if(j < m-1)\\n                q.push({nums1[i]+nums2[j+1], {i, j+1}});\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> ppi;\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        \\n        int n = nums1.size(); \\n        int m = nums2.size();\\n        \\n        priority_queue<ppi, vector<ppi>, greater<ppi>> q;\\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < k && i < n; i++)\\n            q.push({nums1[i]+nums2[0], {i, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1158191,
                "title": "python3-explanation-runtime-and-space-analysis-o-log-nm-time-o-nm-space",
                "content": "**Explanation**\\nThe idea is to loop through each number in `nums1` and for each such number to loop through each number in `nums2` and to manage the currently `k` smallest pair sums in a priority queue. The highest sum will be on the first position of the priority queue. Considering this fact, we can skip a given number in `nums1` if the sum of this number and the given number in `nums2` is greater than the highest sum in the priority queue because every following pair with the given number in `nums1` is going to have a higher sum and is not going to affect the current result.\\n________________________\\n**Definitions**\\n`n`: Length of `nums1`\\n`m`: Length of `nums2`\\n________________________\\n**Runtime Complexity**\\n`O(log(1) + log(2) + ... + log(n * m)) = O(log((n * m)!))` if `k >= n * m`.\\n_______________________\\n**Space Complexity**\\n`O(n * m)`\\n_______________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        pq = []\\n        \\n        for i in range(len(nums1)):\\n            for j in range(len(nums2)):\\n                sum_ = (nums1[i] + nums2[j])\\n                \\n                if len(pq) != k:\\n                    heapq.heappush(pq, (-sum_, (nums1[i], nums2[j],),))\\n                elif sum_ >= -pq[0][0]:\\n                    break\\n                elif sum_ < -pq[0][0]:\\n                    heapq.heappushpop(pq, (-sum_, (nums1[i], nums2[j],),))\\n                else:\\n                    pass\\n                        \\n        return [pair for sum_, pair in pq]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        pq = []\\n        \\n        for i in range(len(nums1)):\\n            for j in range(len(nums2)):\\n                sum_ = (nums1[i] + nums2[j])\\n                \\n                if len(pq) != k:\\n                    heapq.heappush(pq, (-sum_, (nums1[i], nums2[j],),))\\n                elif sum_ >= -pq[0][0]:\\n                    break\\n                elif sum_ < -pq[0][0]:\\n                    heapq.heappushpop(pq, (-sum_, (nums1[i], nums2[j],),))\\n                else:\\n                    pass\\n                        \\n        return [pair for sum_, pair in pq]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067099,
                "title": "7-line-java-simplest-solution",
                "content": "All you have to do, is to use a max heap and preserve the required values and return them at the end!\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {        \\n        PriorityQueue<List<Integer>> pQueue = new PriorityQueue<>((num1, num2) -> Integer.compare(num2.get(0) + num2.get(1), num1.get(0) + num1.get(1)));\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = 0; j < nums2.length; j++) {\\n                pQueue.add(Arrays.asList(nums1[i], nums2[j]));\\n                if (pQueue.size() > k) pQueue.poll();\\n            }\\n        }\\n        \\n        return new ArrayList<>(pQueue);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {        \\n        PriorityQueue<List<Integer>> pQueue = new PriorityQueue<>((num1, num2) -> Integer.compare(num2.get(0) + num2.get(1), num1.get(0) + num1.get(1)));\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = 0; j < nums2.length; j++) {\\n                pQueue.add(Arrays.asList(nums1[i], nums2[j]));\\n                if (pQueue.size() > k) pQueue.poll();\\n            }\\n        }\\n        \\n        return new ArrayList<>(pQueue);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888259,
                "title": "easy-solution-java-priority-queue",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n\\t\\n        List<List<Integer>> lists = new ArrayList<>();\\n        PriorityQueue<List<Integer>> pq = new PriorityQueue<>((l1,l2)->l1.get(0) + l1.get(1) - l2.get(0) - l2.get(1));\\n\\t\\t\\n            for(int n1 : nums1){\\n\\t\\t\\t\\tfor(int n2 : nums2){\\n\\t\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\t\\tlist.add(n1);\\n\\t\\t\\t\\t\\tlist.add(n2);\\n\\t\\t\\t\\t\\tpq.add(list);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0 ;i < k && (!pq.isEmpty()) ; i++){\\n\\t\\t\\t\\tlists.add(pq.poll());\\n\\t\\t\\t}\\n        return lists;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n\\t\\n        List<List<Integer>> lists = new ArrayList<>();\\n        PriorityQueue<List<Integer>> pq = new PriorityQueue<>((l1,l2)->l1.get(0) + l1.get(1) - l2.get(0) - l2.get(1));\\n\\t\\t\\n            for(int n1 : nums1){\\n\\t\\t\\t\\tfor(int n2 : nums2){\\n\\t\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\t\\tlist.add(n1);\\n\\t\\t\\t\\t\\tlist.add(n2);\\n\\t\\t\\t\\t\\tpq.add(list);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 813678,
                "title": "c-straightforward-code-using-a-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums1.size()==0 || nums2.size()==0){\\n            return {};\\n        }\\n        if(k>nums1.size()*nums2.size()){\\n            k = nums1.size()*nums2.size();\\n        }\\n        priority_queue<vector<int>> q;\\n        for(int i=0; i<nums1.size(); i++){\\n            for(int j=0; j<nums2.size(); j++){\\n                vector<int> sum;\\n                sum.push_back(nums1[i]+nums2[j]);\\n                sum.push_back(nums1[i]);\\n                sum.push_back(nums2[j]);\\n                if(q.size()<k){\\n                    q.push(sum);\\n                }\\n                else if(q.size()==k && q.top()[0]>nums1[i]+nums2[j]){\\n                    q.pop();\\n                    q.push(sum);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> res(k);\\n        for(int i=k-1; i>=0; i--){\\n            res[i].push_back(q.top()[1]);\\n            res[i].push_back(q.top()[2]);\\n            q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        if(nums1.size()==0 || nums2.size()==0){\\n            return {};\\n        }\\n        if(k>nums1.size()*nums2.size()){\\n            k = nums1.size()*nums2.size();\\n        }\\n        priority_queue<vector<int>> q;\\n        for(int i=0; i<nums1.size(); i++){\\n            for(int j=0; j<nums2.size(); j++){\\n                vector<int> sum;\\n                sum.push_back(nums1[i]+nums2[j]);\\n                sum.push_back(nums1[i]);\\n                sum.push_back(nums2[j]);\\n                if(q.size()<k){\\n                    q.push(sum);\\n                }\\n                else if(q.size()==k && q.top()[0]>nums1[i]+nums2[j]){\\n                    q.pop();\\n                    q.push(sum);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> res(k);\\n        for(int i=k-1; i>=0; i--){\\n            res[i].push_back(q.top()[1]);\\n            res[i].push_back(q.top()[2]);\\n            q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748693,
                "title": "java-heap",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        ArrayList<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\n        PriorityQueue<int[]> heap = new PriorityQueue<int[]>(\\n            (p,q) ->  q[0] + q[1] - p[0] - p[1]\\n        );\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        if (n == 0 || m == 0)\\n        {\\n            return result;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                heap.add(new int[] {nums1[i], nums2[j]});\\n                if (heap.size() > k) {\\n                    heap.poll();\\n                }\\n            }\\n        }\\n        \\n        while (!heap.isEmpty()) {\\n            int[] top = heap.poll();\\n            ArrayList<Integer> tmp = new ArrayList<Integer>();\\n            tmp.add(top[0]);\\n            tmp.add(top[1]);\\n            result.add(tmp);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        ArrayList<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\n        PriorityQueue<int[]> heap = new PriorityQueue<int[]>(\\n            (p,q) ->  q[0] + q[1] - p[0] - p[1]\\n        );\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        if (n == 0 || m == 0)\\n        {\\n            return result;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                heap.add(new int[] {nums1[i], nums2[j]});\\n                if (heap.size() > k) {\\n                    heap.poll();\\n                }\\n            }\\n        }\\n        \\n        while (!heap.isEmpty()) {\\n            int[] top = heap.poll();\\n            ArrayList<Integer> tmp = new ArrayList<Integer>();\\n            tmp.add(top[0]);\\n            tmp.add(top[1]);\\n            result.add(tmp);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542795,
                "title": "java-heap-o-k-log-k-easy-to-understand-with-iterator",
                "content": "```\\nclass Solution {\\n    \\n    //    iter1 iter2 iter3\\n    //     (1)   (1)   (2)\\n    // (1) 1+1   1+1   1+2\\n    // (2) 1+2   1+2   2+2\\n    // (3) 1+3   1+3   2+3\\n    // \\n    // If k = 2 then the answer must be in the left top 2x2 square\\n    \\n    // Iterator for one column\\n    private class Iterator implements Comparable<Iterator> {\\n        \\n        private final int[] nums;\\n        private final int other;\\n        private int current = 0;\\n        \\n        public Iterator(int[] nums, int other) {\\n            this.nums = nums;\\n            this.other = other;\\n        }\\n        \\n        public boolean hasNext() {\\n            return current + 1 < nums.length;\\n        }\\n        \\n        public void next() {\\n            current++;\\n        }\\n        \\n        public List<Integer> getPair() {\\n            final List<Integer> pair = new ArrayList<>();\\n            pair.add(other);\\n            pair.add(nums[current]);\\n            return pair;\\n        }\\n        \\n        public int getSum() {\\n            return nums[current] + other;\\n        }\\n        \\n        public int compareTo(Iterator other) {\\n            return Integer.compare(this.getSum(), other.getSum());\\n        }\\n    }\\n    \\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        final List<List<Integer>> result = new ArrayList<>();\\n        \\n        if (nums1.length == 0 || nums2.length == 0) return result;\\n        \\n        final PriorityQueue<Iterator> queue = new PriorityQueue<>();\\n        for (int i = 0; i < Math.min(k, nums1.length); i++) {\\n            queue.offer(new Iterator(nums2, nums1[i]));\\n        }\\n        \\n        while (result.size() < k && !queue.isEmpty()) {\\n            final Iterator iterator = queue.poll();\\n            result.add(iterator.getPair());\\n            \\n            if (iterator.hasNext()) {\\n                iterator.next();\\n                queue.offer(iterator);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    //    iter1 iter2 iter3\\n    //     (1)   (1)   (2)\\n    // (1) 1+1   1+1   1+2\\n    // (2) 1+2   1+2   2+2\\n    // (3) 1+3   1+3   2+3\\n    // \\n    // If k = 2 then the answer must be in the left top 2x2 square\\n    \\n    // Iterator for one column\\n    private class Iterator implements Comparable<Iterator> {\\n        \\n        private final int[] nums;\\n        private final int other;\\n        private int current = 0;\\n        \\n        public Iterator(int[] nums, int other) {\\n            this.nums = nums;\\n            this.other = other;\\n        }\\n        \\n        public boolean hasNext() {\\n            return current + 1 < nums.length;\\n        }\\n        \\n        public void next() {\\n            current++;\\n        }\\n        \\n        public List<Integer> getPair() {\\n            final List<Integer> pair = new ArrayList<>();\\n            pair.add(other);\\n            pair.add(nums[current]);\\n            return pair;\\n        }\\n        \\n        public int getSum() {\\n            return nums[current] + other;\\n        }\\n        \\n        public int compareTo(Iterator other) {\\n            return Integer.compare(this.getSum(), other.getSum());\\n        }\\n    }\\n    \\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        final List<List<Integer>> result = new ArrayList<>();\\n        \\n        if (nums1.length == 0 || nums2.length == 0) return result;\\n        \\n        final PriorityQueue<Iterator> queue = new PriorityQueue<>();\\n        for (int i = 0; i < Math.min(k, nums1.length); i++) {\\n            queue.offer(new Iterator(nums2, nums1[i]));\\n        }\\n        \\n        while (result.size() < k && !queue.isEmpty()) {\\n            final Iterator iterator = queue.poll();\\n            result.add(iterator.getPair());\\n            \\n            if (iterator.hasNext()) {\\n                iterator.next();\\n                queue.offer(iterator);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482055,
                "title": "golang-solution",
                "content": "```go\\nimport \"container/heap\"\\n\\ntype point struct {\\n    index int\\n    x, y int\\n}\\n\\ntype minHeap []point\\n\\nfunc (m minHeap) Len() int {\\n    return len(m)\\n}\\n\\nfunc (m minHeap) Less(i, j int) bool {\\n    return m[i].x + m[i].y < m[j].x + m[j].y\\n}\\n\\nfunc (m minHeap) Swap(i, j int) {\\n    m[i], m[j] = m[j], m[i]\\n}\\n\\nfunc (m *minHeap) Push(x interface{}) {\\n    *m = append(*m, x.(point))\\n}\\n\\nfunc (m *minHeap) Pop() interface{} {\\n    values := *m\\n    length := len(values)\\n    result := values[length-1]\\n    *m = values[:length-1]\\n    return result\\n}\\n\\nfunc kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {\\n    if len(nums1) == 0 || len(nums2) == 0 {\\n        return nil\\n    }\\n    h := minHeap{}\\n    var result [][]int\\n    var count int\\n    \\n    for i := 0; i<len(nums1) && i<k; i++ {\\n        heap.Push(&h, point{0, nums1[i], nums2[0]})\\n    }\\n    \\n    for len(h) > 0 {\\n        p := heap.Pop(&h).(point)\\n        result = append(result, []int{p.x, p.y})\\n        count++\\n        if count == k {\\n            break\\n        }\\n        if p.index+1 < len(nums2) {\\n            heap.Push(&h, point{p.index+1, p.x, nums2[p.index+1]})\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nimport \"container/heap\"\\n\\ntype point struct {\\n    index int\\n    x, y int\\n}\\n\\ntype minHeap []point\\n\\nfunc (m minHeap) Len() int {\\n    return len(m)\\n}\\n\\nfunc (m minHeap) Less(i, j int) bool {\\n    return m[i].x + m[i].y < m[j].x + m[j].y\\n}\\n\\nfunc (m minHeap) Swap(i, j int) {\\n    m[i], m[j] = m[j], m[i]\\n}\\n\\nfunc (m *minHeap) Push(x interface{}) {\\n    *m = append(*m, x.(point))\\n}\\n\\nfunc (m *minHeap) Pop() interface{} {\\n    values := *m\\n    length := len(values)\\n    result := values[length-1]\\n    *m = values[:length-1]\\n    return result\\n}\\n\\nfunc kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {\\n    if len(nums1) == 0 || len(nums2) == 0 {\\n        return nil\\n    }\\n    h := minHeap{}\\n    var result [][]int\\n    var count int\\n    \\n    for i := 0; i<len(nums1) && i<k; i++ {\\n        heap.Push(&h, point{0, nums1[i], nums2[0]})\\n    }\\n    \\n    for len(h) > 0 {\\n        p := heap.Pop(&h).(point)\\n        result = append(result, []int{p.x, p.y})\\n        count++\\n        if count == k {\\n            break\\n        }\\n        if p.index+1 < len(nums2) {\\n            heap.Push(&h, point{p.index+1, p.x, nums2[p.index+1]})\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 388209,
                "title": "easy-peasy-python-o-klogk-solution",
                "content": "#idea taken from https://leetcode.com/problems/find-k-pairs-with-smallest-sums/discuss/84551/simple-Java-O(KlogK)-solution-with-explanation)\\n\\n\\n\\tdef kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        # similar to merge K sorted list\\n        if k == 0 or len(nums1) == 0 or len(nums2) == 0:\\n            return []\\n        \\n        nums1.sort()\\n        nums2.sort()\\n        heap = []\\n        \\n        for i in range(min(len(nums1), k)):\\n            # here zero is the index of nums2\\n            heap.append((nums1[i] + nums2[0], nums1[i], nums2[0], 0))\\n            \\n        heapq.heapify(heap)\\n        \\n        output = []\\n        while k > 0 and len(heap) > 0:\\n            _, n1, n2, idx = heapq.heappop(heap)\\n            output.append((n1, n2))\\n            if idx + 1 < len(nums2):\\n                n2 = nums2[idx+1]\\n                heapq.heappush(heap, (n1 + n2, n1, n2, idx + 1))\\n        \\n            k -= 1\\n          \\n        return output",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "#idea taken from https://leetcode.com/problems/find-k-pairs-with-smallest-sums/discuss/84551/simple-Java-O(KlogK)-solution-with-explanation)\\n\\n\\n\\tdef kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        # similar to merge K sorted list\\n        if k == 0 or len(nums1) == 0 or len(nums2) == 0:\\n            return []\\n        \\n        nums1.sort()\\n        nums2.sort()\\n        heap = []\\n        \\n        for i in range(min(len(nums1), k)):\\n            # here zero is the index of nums2\\n            heap.append((nums1[i] + nums2[0], nums1[i], nums2[0], 0))\\n            \\n        heapq.heapify(heap)\\n        \\n        output = []\\n        while k > 0 and len(heap) > 0:\\n            _, n1, n2, idx = heapq.heappop(heap)\\n            output.append((n1, n2))\\n            if idx + 1 < len(nums2):\\n                n2 = nums2[idx+1]\\n                heapq.heappush(heap, (n1 + n2, n1, n2, idx + 1))\\n        \\n            k -= 1\\n          \\n        return output",
                "codeTag": "Python3"
            },
            {
                "id": 376162,
                "title": "c-o-kn-beating-100",
                "content": "```\\npublic class Solution\\n{\\n    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k)\\n    {\\n        var result = new List<IList<int>>();\\n        var index = new int[nums1.Length];\\n        int count = 0, min = 0, minIndex = 0;\\n        while (count < k && count < nums1.Length * nums2.Length)\\n        {\\n            min = int.MaxValue;\\n            for (int j = 0; j < index.Length; j++)\\n            {\\n                if (index[j] >= nums2.Length) continue;\\n                if (nums1[j] + nums2[index[j]] <= min)\\n                {\\n                    min = nums1[j] + nums2[index[j]];\\n                    minIndex = j;\\n                }\\n            }\\n            result.Add(new List<int> { nums1[minIndex], nums2[index[minIndex]] });\\n            index[minIndex]++;            \\n            count++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k)\\n    {\\n        var result = new List<IList<int>>();\\n        var index = new int[nums1.Length];\\n        int count = 0, min = 0, minIndex = 0;\\n        while (count < k && count < nums1.Length * nums2.Length)\\n        {\\n            min = int.MaxValue;\\n            for (int j = 0; j < index.Length; j++)\\n            {\\n                if (index[j] >= nums2.Length) continue;\\n                if (nums1[j] + nums2[index[j]] <= min)\\n                {\\n                    min = nums1[j] + nums2[index[j]];\\n                    minIndex = j;\\n                }\\n            }\\n            result.Add(new List<int> { nums1[minIndex], nums2[index[minIndex]] });\\n            index[minIndex]++;            \\n            count++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352047,
                "title": "javascript-beats-both-100-simple-and-clean",
                "content": "```\\n\\n```var kSmallestPairs = function(nums1, nums2, k) {\\n    let len1=nums1.length, len2 =nums2.length;\\n    let arr= new Array(len1).fill(0), resList=[];\\n    while(k-- >0){\\n        let min=+Infinity;\\n        let index=-1;\\n        for(let i=0; i<len1; i++){\\n            if(arr[i]>= len2){\\n                continue;\\n            }\\n            if(nums1[i] + nums2[arr[i]] < min){\\n                min=nums1[i] + nums2[arr[i]];\\n                index=i;\\n            }\\n        }\\n        if(index== -1){\\n            break;\\n        }\\n        resList.push([nums1[index], nums2[arr[index]]]);\\n        arr[index]++;\\n    }\\n    return resList\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 223343,
                "title": "python-52ms",
                "content": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        len1 = len(nums1)\\n        len2 = len(nums2)\\n        result = []\\n        \\n        if len1 == 0 or len2 == 0:\\n            return result\\n        # smallest item is guaranteed to be in this subset of combinations\\n        heap = [(nums1[i1] + nums2[0], i1, 0) for i1 in range(len1)]\\n        heapq.heapify(heap)\\n        # print(heap)\\n        while len(result) < k and len(heap) > 0:\\n            # this is the next smallest item\\n            s, i1, i2 = heapq.heappop(heap)\\n            result.append((nums1[i1], nums2[i2]))\\n\\t\\t\\t\\n            # move pointer i2 to next in the list, and add it to the heap\\n            i2 += 1\\n            if i2 < len2:\\n                heapq.heappush(heap, (nums1[i1] + nums2[i2], i1, i2))\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1, nums2, k):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :type k: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        len1 = len(nums1)\\n        len2 = len(nums2)\\n        result = []\\n        \\n        if len1 == 0 or len2 == 0:\\n            return result\\n        # smallest item is guaranteed to be in this subset of combinations\\n        heap = [(nums1[i1] + nums2[0], i1, 0) for i1 in range(len1)]\\n        heapq.heapify(heap)\\n        # print(heap)\\n        while len(result) < k and len(heap) > 0:\\n            # this is the next smallest item\\n            s, i1, i2 = heapq.heappop(heap)\\n            result.append((nums1[i1], nums2[i2]))\\n\\t\\t\\t\\n            # move pointer i2 to next in the list, and add it to the heap\\n            i2 += 1\\n            if i2 < len2:\\n                heapq.heappush(heap, (nums1[i1] + nums2[i2], i1, i2))\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84556,
                "title": "java-priorityqueue-9ms-without-helper-class",
                "content": "```\\npublic class Solution {\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> res = new LinkedList<>();\\n        if(nums1==null || nums1.length==0 || nums2==null || nums2.length==0) {\\n            return res;\\n        }\\n        \\n        // index pair\\n        PriorityQueue<int[]> minQ = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] pair1, int[] pair2) {\\n                return (nums1[pair1[0]]+nums2[pair1[1]])-(nums1[pair2[0]]+nums2[pair2[1]]);\\n            }\\n            \\n        });\\n        \\n        \\n        minQ.offer(new int[]{0, 0});\\n        \\n        while (k>0 && !minQ.isEmpty()) {\\n            int[] pair=minQ.poll();\\n            int i = pair[0];\\n            int j = pair[1];\\n            res.add(new int[]{nums1[i], nums2[j]});\\n            k--;\\n            \\n            if(j+1<nums2.length) {\\n                minQ.offer(new int[]{i, j+1});\\n            }\\n            \\n            if(j==0 && i+1<nums1.length){ \\n                minQ.offer(new int[] {i+1, 0});\\n            }\\n\\n        }\\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<int[]> res = new LinkedList<>();\\n        if(nums1==null || nums1.length==0 || nums2==null || nums2.length==0) {\\n            return res;\\n        }\\n        \\n        // index pair\\n        PriorityQueue<int[]> minQ = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] pair1, int[] pair2) {\\n                return (nums1[pair1[0]]+nums2[pair1[1]])-(nums1[pair2[0]]+nums2[pair2[1]]);\\n            }\\n            \\n        });\\n        \\n        \\n        minQ.offer(new int[]{0, 0});\\n        \\n        while (k>0 && !minQ.isEmpty()) {\\n            int[] pair=minQ.poll();\\n            int i = pair[0];\\n            int j = pair[1];\\n            res.add(new int[]{nums1[i], nums2[j]});\\n            k--;\\n            \\n            if(j+1<nums2.length) {\\n                minQ.offer(new int[]{i, j+1});\\n            }\\n            \\n            if(j==0 && i+1<nums1.length){ \\n                minQ.offer(new int[] {i+1, 0});\\n            }\\n\\n        }\\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84649,
                "title": "heap-based-java-solution-similar-to-merging-k-sorted-list",
                "content": "The idea lying behind this problem is the same as merging K sorted lists:\\nList 1: a1+b1, a1+b2, a1+b3,a1+b4,a1+b5,...........\\nList 2: a2+b1, a2+b2, a2+b3,a2+b4,a2+b5,...........\\nList 3: a3+b1, a3+b2, a3+b3,a3+b4,a3+b5,...........\\n......\\nSo, first we need to add the first element in every list to the heap. Then, we keep popping out the top of the heap and adding the next element in the list which the currently popped out element comes from, until we get k smallest pairs or all the pairs are used up. The time complexity is: O(max(length1, k) * log(length1)), where length1 is the length of the first ascending array.\\n```\\npublic class Solution {\\n    public List<int[]> kSmallestPairs(final int[] nums1, final int[] nums2, int k) {\\n        ArrayList<int[]> topKInts = new ArrayList<>();\\n        PriorityQueue<int[]> pq;\\n        \\n        if(nums1.length==0 || nums2.length==0) {\\n            return topKInts;\\n        }\\n        \\n        pq = new PriorityQueue(nums1.length, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] indices1, int[] indices2) {\\n                if(nums1[ indices1[ 0 ] ]+nums2[ indices1[ 1 ] ] < nums1[ indices2[ 0 ] ]+nums2[ indices2[ 1 ] ]) {\\n                    return -1;\\n                } else if(nums1[ indices1[ 0 ] ]+nums2[ indices1[ 1 ] ] > nums1[ indices2[ 0 ] ]+nums2[ indices2[ 1 ] ]) {\\n                    return 1;\\n                } else {\\n                    return 0;\\n                }\\n            }\\n        });\\n        \\n        for(int cnt = 0; cnt < nums1.length; cnt++) {\\n            pq.offer(new int[]{cnt, 0});\\n        }\\n        \\n        while(!pq.isEmpty() && topKInts.size()<k) {\\n            int[] indices = pq.poll();\\n            topKInts.add(new int[]{nums1[ indices[ 0 ] ], nums2[ indices[ 1 ] ]});\\n            indices[ 1 ]++;\\n            if(indices[ 1 ] < nums2.length) {\\n                pq.offer(indices);\\n            }\\n        }\\n        \\n        return topKInts;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<int[]> kSmallestPairs(final int[] nums1, final int[] nums2, int k) {\\n        ArrayList<int[]> topKInts = new ArrayList<>();\\n        PriorityQueue<int[]> pq;\\n        \\n        if(nums1.length==0 || nums2.length==0) {\\n            return topKInts;\\n        }\\n        \\n        pq = new PriorityQueue(nums1.length, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] indices1, int[] indices2) {\\n                if(nums1[ indices1[ 0 ] ]+nums2[ indices1[ 1 ] ] < nums1[ indices2[ 0 ] ]+nums2[ indices2[ 1 ] ]) {\\n                    return -1;\\n                } else if(nums1[ indices1[ 0 ] ]+nums2[ indices1[ 1 ] ] > nums1[ indices2[ 0 ] ]+nums2[ indices2[ 1 ] ]) {\\n                    return 1;\\n                } else {\\n                    return 0;\\n                }\\n            }\\n        });\\n        \\n        for(int cnt = 0; cnt < nums1.length; cnt++) {\\n            pq.offer(new int[]{cnt, 0});\\n        }\\n        \\n        while(!pq.isEmpty() && topKInts.size()<k) {\\n            int[] indices = pq.poll();\\n            topKInts.add(new int[]{nums1[ indices[ 0 ] ], nums2[ indices[ 1 ] ]});\\n            indices[ 1 ]++;\\n            if(indices[ 1 ] < nums2.length) {\\n                pq.offer(indices);\\n            }\\n        }\\n        \\n        return topKInts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84656,
                "title": "dijkstra-like-solution-in-java",
                "content": "\\tpublic List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n\\t\\tList<int[]> result = new ArrayList<int[]>();\\n\\t\\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>(){\\n\\t\\t\\tpublic int compare(int[] pair1, int[] pair2){\\n\\t\\t\\t\\treturn (nums1[pair1[0]] + nums2[pair1[1]]) - (nums1[pair2[0]] + nums2[pair2[1]]);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tint length1 = nums1.length;\\n\\t\\tint length2 = nums2.length;\\n\\t\\tboolean[][] visited = new boolean[length1][length2];\\n\\n\\t\\tadd(pq, visited, nums1, nums2, 0, 0);\\n\\t\\twhile(pq.size() > 0 && result.size() < k){\\n\\t\\t\\tint[] next = pq.poll();\\n\\t\\t\\tresult.add(new int[]{nums1[next[0]], nums2[next[1]]});\\n\\t\\t\\tadd(pq, visited, nums1, nums2, next[0] + 1, next[1]);\\n\\t\\t\\tadd(pq, visited, nums1, nums2, next[0], next[1] + 1);\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\tprivate void add(PriorityQueue<int[]> pq, boolean[][] visited, int[] nums1, int[] nums2, int n1, int n2){\\n\\t\\tif(n1 < nums1.length && n2 < nums2.length && !visited[n1][n2]){\\n\\t\\t\\tpq.add(new int[]{n1, n2});\\n\\t\\t\\tvisited[n1][n2] = true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "\\tpublic List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n\\t\\tList<int[]> result = new ArrayList<int[]>();\\n\\t\\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>(){\\n\\t\\t\\tpublic int compare(int[] pair1, int[] pair2){\\n\\t\\t\\t\\treturn (nums1[pair1[0]] + nums2[pair1[1]]) - (nums1[pair2[0]] + nums2[pair2[1]]);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tint length1 = nums1.length;\\n\\t\\tint length2 = nums2.length;\\n\\t\\tboolean[][] visited = new boolean[length1][length2];\\n\\n\\t\\tadd(pq, visited, nums1, nums2, 0, 0);\\n\\t\\twhile(pq.size() > 0 && result.size() < k){\\n\\t\\t\\tint[] next = pq.poll();\\n\\t\\t\\tresult.add(new int[]{nums1[next[0]], nums2[next[1]]});\\n\\t\\t\\tadd(pq, visited, nums1, nums2, next[0] + 1, next[1]);\\n\\t\\t\\tadd(pq, visited, nums1, nums2, next[0], next[1] + 1);\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\tprivate void add(PriorityQueue<int[]> pq, boolean[][] visited, int[] nums1, int[] nums2, int n1, int n2){\\n\\t\\tif(n1 < nums1.length && n2 < nums2.length && !visited[n1][n2]){\\n\\t\\t\\tpq.add(new int[]{n1, n2});\\n\\t\\t\\tvisited[n1][n2] = true;\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3827185,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Priority Queue\\n\\n\\n# Code\\n```\\n#define piii pair <int, pair <int, int>>\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<piii> pq;\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < nums1.size(); i++) {\\n            for (int j = 0; j < nums2.size(); j++) {\\n                int sum = nums1[i] + nums2[j];\\n                if (pq.size() < k) pq.push({sum, {nums1[i], nums2[j]}});\\n                else if (sum < pq.top().first) {\\n                    pq.pop();\\n                    pq.push({sum, {nums1[i], nums2[j]}});\\n                }\\n                else break;\\n            }\\n        }\\n        while (!pq.empty()) {\\n            ans.push_back({pq.top().second.first, pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define piii pair <int, pair <int, int>>\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<piii> pq;\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < nums1.size(); i++) {\\n            for (int j = 0; j < nums2.size(); j++) {\\n                int sum = nums1[i] + nums2[j];\\n                if (pq.size() < k) pq.push({sum, {nums1[i], nums2[j]}});\\n                else if (sum < pq.top().first) {\\n                    pq.pop();\\n                    pq.push({sum, {nums1[i], nums2[j]}});\\n                }\\n                else break;\\n            }\\n        }\\n        while (!pq.empty()) {\\n            ans.push_back({pq.top().second.first, pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690384,
                "title": "python-3-solution-with-explanation",
                "content": "# Approach\\nTo solve this problem, we can utilize the concept of a priority queue or a min-heap. Here\\'s a step-by-step explanation of the approach:\\n\\n- Create a min-heap or priority queue to store the pairs based on their sums.\\n\\n- Add elements of nums1 and add pairs (nums1[i], nums2[0]) to the min-heap, along with the indices i and 0.\\n\\n- While the min-heap is not empty and k is greater than 0:\\na. Pop the pair with the smallest sum from the min-heap. Let\\'s say the pair is (u, v) with indices i and j.\\nb. Add the pair (u, v) to the result list.\\nc. If j+1 is less than the length of nums2, add the pair (nums1[i], nums2[j+1]) to the min-heap with indices i and j+1.\\nd. If i+1 is less than the length of nums1 and j is 0, add the pair (nums1[i+1], nums2[j]) to the min-heap with indices i+1 and j.\\n\\n- Return the result list containing the k pairs with the smallest sums.\\n\\n# Complexity\\n- Time complexity:\\nO min(k log k,nm log nm)\\n\\n- Space complexity:\\nO min(k,nm)\\n\\n# Video Explanation\\nhttps://www.youtube.com/watch?v=mP1e0aG7MOY\\n\\n# Code\\n```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        from heapq import heappush, heappop\\n        m = len(nums1)\\n        n = len(nums2)\\n        ans = []\\n        visited = set()\\n        minHeap = [(nums1[0] + nums2[0], (0,0))]\\n        visited.add((0,0))\\n        while k > 0 and minHeap:\\n            val, (i,j) = heappop(minHeap)\\n            ans.append([nums1[i],nums2[j]])\\n            if i+1 < m and (i+1,j) not in visited:\\n                heappush(minHeap, (nums1[i+1]+nums2[j],(i+1,j)))\\n                visited.add((i+1,j))\\n            if j+1 < n and (i,j+1) not in visited:\\n                heappush(minHeap, (nums1[i]+nums2[j+1],(i,j+1)))\\n                visited.add((i,j+1))\\n            k -= 1\\n        return ans\\n```\\n### If this Solution was helpful then, Upvote \\uD83D\\uDE00\\uD83D\\uDC4D\\uD83C\\uDFFB",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        from heapq import heappush, heappop\\n        m = len(nums1)\\n        n = len(nums2)\\n        ans = []\\n        visited = set()\\n        minHeap = [(nums1[0] + nums2[0], (0,0))]\\n        visited.add((0,0))\\n        while k > 0 and minHeap:\\n            val, (i,j) = heappop(minHeap)\\n            ans.append([nums1[i],nums2[j]])\\n            if i+1 < m and (i+1,j) not in visited:\\n                heappush(minHeap, (nums1[i+1]+nums2[j],(i+1,j)))\\n                visited.add((i+1,j))\\n            if j+1 < n and (i,j+1) not in visited:\\n                heappush(minHeap, (nums1[i]+nums2[j+1],(i,j+1)))\\n                visited.add((i,j+1))\\n            k -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689985,
                "title": "easy-java-code-using-priority-queue",
                "content": "# Intuition\\nSlightly Optimized code using a max heap (priority queue) based on the comparator \\n(a, b) -> (b[0] + b[1]) - (a[0] + a[1]). \\n\\n# Approach\\n It uses a priority queue (pq) to keep track of the k smallest pairs based on their sum. It iterates over the elements of nums1 and nums2 and compares the sum of the current pair with the largest sum in the priority queue. If the current pair has a smaller sum, it replaces the largest sum in the priority queue. Finally, it returns a list of the k smallest pairs from the priority queue.\\n\\n\\n# Code\\n```\\nimport java.util.*;\\n\\n\\npublic class Solution {\\n\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (b[0] + b[1])-(a[0]+a[1]));\\n        \\n        for (int i = 0; i < Math.min(nums1.length, k); i++) {\\n            for (int j = 0; j < Math.min(nums2.length, k); j++) {\\n                int[] cur={nums1[i], nums2[j]};\\n                if (pq.size() == k) {\\n                    int[] pk=pq.peek();\\n                    if(pk[0]+pk[1]>cur[0]+cur[1]){\\n                        pq.poll();\\n                        pq.offer(cur);\\n                    }\\n                    else break;\\n                }\\n                else pq.offer(cur);\\n            }\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        while (!pq.isEmpty()) {\\n            int[] pair = pq.poll();\\n            result.add(Arrays.asList(pair[0], pair[1]));\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport java.util.*;\\n\\n\\npublic class Solution {\\n\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (b[0] + b[1])-(a[0]+a[1]));\\n        \\n        for (int i = 0; i < Math.min(nums1.length, k); i++) {\\n            for (int j = 0; j < Math.min(nums2.length, k); j++) {\\n                int[] cur={nums1[i], nums2[j]};\\n                if (pq.size() == k) {\\n                    int[] pk=pq.peek();\\n                    if(pk[0]+pk[1]>cur[0]+cur[1]){\\n                        pq.poll();\\n                        pq.offer(cur);\\n                    }\\n                    else break;\\n                }\\n                else pq.offer(cur);\\n            }\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        while (!pq.isEmpty()) {\\n            int[] pair = pq.poll();\\n            result.add(Arrays.asList(pair[0], pair[1]));\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689727,
                "title": "c-solution-for-find-k-pairs-with-smallest-sums-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution uses a min heap (implemented as a SortedSet) to store pairs of elements from nums1 and nums2 based on their sums. It starts by adding the first pair (nums1[0], nums2[0]) to the min heap.\\n\\nThe algorithm then iteratively extracts the pair with the smallest sum from the min heap, adds it to the result list, and explores the next pair options by moving the indices. Specifically, it considers the pair (nums1[index1 + 1], nums2[index2]) and (nums1[index1], nums2[index2 + 1]) if the indices are within the array bounds.\\n\\nThe process continues until k smallest pairs have been added to the result list or the min heap becomes empty.  \\n\\nBy using a min heap, the algorithm ensures that it always explores pairs with the smallest sum first. This approach allows us to find the k smallest pairs efficiently.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a min heap (SortedSet) to store pairs of elements from nums1 and nums2 based on their sums.\\n1. Add the first pair (nums1[0], nums2[0]) to the min heap.\\n1. While k is greater than zero and the min heap is not empty:\\n- Extract the pair with the smallest sum from the min heap.\\n- Add the pair to the result list.\\n- Explore the next pair options by moving the indices.\\n- Add the new pairs to the min heap.\\n- Decrement k by one.\\n1. Return the result list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(k log k), where k is the input parameter. In the worst case, all k smallest pairs need to be extracted and added to the result list, and each operation takes O(log k) time due to the min heap operations.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution is O(k) because the result list can contain at most k pairs, and the min heap can also contain at most k elements.\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<IList<int>> result = new List<IList<int>>();\\n        if (nums1 == null || nums1.Length == 0 || nums2 == null || nums2.Length == 0)\\n            return result;\\n\\n        // Create a min heap to store pairs based on their sums\\n        SortedSet<(int sum, int index1, int index2)> minHeap = new SortedSet<(int, int, int)>(Comparer<(int, int, int)>.Create((a, b) =>\\n        {\\n            int compare = a.Item1.CompareTo(b.Item1);\\n            if (compare == 0)\\n                compare = a.Item2.CompareTo(b.Item2);\\n            if (compare == 0)\\n                compare = a.Item3.CompareTo(b.Item3);\\n            return compare;\\n        }));\\n\\n        // Add the first pair (nums1[0], nums2[0]) to the min heap\\n        minHeap.Add((nums1[0] + nums2[0], 0, 0));\\n\\n        while (k > 0 && minHeap.Count > 0)\\n        {\\n            // Get the pair with the smallest sum from the min heap\\n            var (sum, index1, index2) = minHeap.Min;\\n            minHeap.Remove(minHeap.Min);\\n\\n            // Add the pair to the result\\n            result.Add(new List<int> { nums1[index1], nums2[index2] });\\n\\n            // Explore the next pair options by moving the indices\\n            if (index1 < nums1.Length - 1)\\n                minHeap.Add((nums1[index1 + 1] + nums2[index2], index1 + 1, index2));\\n\\n            if (index1 == 0 && index2 < nums2.Length - 1)\\n                minHeap.Add((nums1[index1] + nums2[index2 + 1], index1, index2 + 1));\\n\\n            k--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<IList<int>> result = new List<IList<int>>();\\n        if (nums1 == null || nums1.Length == 0 || nums2 == null || nums2.Length == 0)\\n            return result;\\n\\n        // Create a min heap to store pairs based on their sums\\n        SortedSet<(int sum, int index1, int index2)> minHeap = new SortedSet<(int, int, int)>(Comparer<(int, int, int)>.Create((a, b) =>\\n        {\\n            int compare = a.Item1.CompareTo(b.Item1);\\n            if (compare == 0)\\n                compare = a.Item2.CompareTo(b.Item2);\\n            if (compare == 0)\\n                compare = a.Item3.CompareTo(b.Item3);\\n            return compare;\\n        }));\\n\\n        // Add the first pair (nums1[0], nums2[0]) to the min heap\\n        minHeap.Add((nums1[0] + nums2[0], 0, 0));\\n\\n        while (k > 0 && minHeap.Count > 0)\\n        {\\n            // Get the pair with the smallest sum from the min heap\\n            var (sum, index1, index2) = minHeap.Min;\\n            minHeap.Remove(minHeap.Min);\\n\\n            // Add the pair to the result\\n            result.Add(new List<int> { nums1[index1], nums2[index2] });\\n\\n            // Explore the next pair options by moving the indices\\n            if (index1 < nums1.Length - 1)\\n                minHeap.Add((nums1[index1 + 1] + nums2[index2], index1 + 1, index2));\\n\\n            if (index1 == 0 && index2 < nums2.Length - 1)\\n                minHeap.Add((nums1[index1] + nums2[index2 + 1], index1, index2 + 1));\\n\\n            k--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688771,
                "title": "accepted-brute-force-optimal-c-codestorywithmik",
                "content": "YouTube Video Link BRUTE FORCE : [Find K Pairs with Smallest Sums](https://www.youtube.com/watch?v=eptC4nUL_2A)\\nYouTube Video Link OPTIMAL : [Find K Pairs with Smallest Sums](https://www.youtube.com/watch?v=PiGYS7BbV_Q)\\nGithub Treasure : [Find K Pairs with Smallest Sums](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Heap/Find%20K%20Pairs%20with%20Smallest%20Sums.cpp)\\n\\n\\n```\\n//Complete Brute Force using MinHeap - TIME COMPLEXITY = O(m*n*log(k)) - TLE\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> P;\\n    \\n    struct lambda {\\n        bool operator()(P &p1, P &p2){\\n            return p1.first < p2.first; //Max heap\\n        }\\n    };\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<P, vector<P>, lambda> pq;\\n        \\n        int m = nums1.size();\\n        int n = nums2.size();\\n        \\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                \\n                int sum = nums1[i] + nums2[j];\\n\\n                if(pq.size() < k) {\\n                    pq.push({sum, {i, j}});\\n                } else if(pq.top().first > sum) {\\n                    pq.pop();\\n                    pq.push({sum, {i, j}});\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> result;\\n        \\n        while(!pq.empty()) {\\n            auto temp = pq.top(); \\n            pq.pop();\\n            \\n            int i = temp.second.first;\\n            int j = temp.second.second;\\n            result.push_back({nums1[i], nums2[j]});\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Improved BRUTE FORCE) \\n//Complete Brute Force using MinHeap - TIME COMPLEXITY < O(m*n*log(k)) - ACCEPTED\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> P;\\n    \\n    struct lambda {\\n        bool operator()(P &p1, P &p2){\\n            return p1.first < p2.first; //Max heap\\n        }\\n    };\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<P, vector<P>, lambda> pq;\\n        \\n        int m = nums1.size();\\n        int n = nums2.size();\\n        \\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                \\n                int sum = nums1[i] + nums2[j];\\n\\n                if(pq.size() < k) {\\n                    pq.push({sum, {i, j}});\\n                } else if(pq.top().first > sum) {\\n                    pq.pop();\\n                    pq.push({sum, {i, j}});\\n                } else {\\n                    break; //Breaking from here (slight improvement)\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> result;\\n        \\n        while(!pq.empty()) {\\n            auto temp = pq.top(); \\n            pq.pop();\\n            \\n            int i = temp.second.first;\\n            int j = temp.second.second;\\n            result.push_back({nums1[i], nums2[j]});\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (Slight Better approach) - O(klog(k))\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> P;\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        priority_queue<P, vector<P>, greater<P>> pq; //min-heap\\n        \\n        set<pair<int, int>> visited;\\n        visited.insert({0, 0});\\n        \\n        int sum = nums1[0] + nums2[0];\\n        \\n        pq.push({sum, {0, 0}});\\n        \\n        vector<vector<int>> result;\\n        while(k-- && !pq.empty()) {\\n            \\n            auto temp = pq.top(); \\n            pq.pop();\\n            \\n            int i = temp.second.first;\\n            int j = temp.second.second;\\n            result.push_back({nums1[i], nums2[j]});\\n            \\n            //Push (i, j+1) if possible\\n             if (j + 1 < n && visited.find({i, j + 1}) == visited.end()) {\\n                pq.push({nums1[i] + nums2[j + 1], {i, j + 1}});\\n                visited.insert({i, j + 1});\\n            }\\n\\n            //Push (i+1, j) if possible\\n            if (i + 1 < m && visited.find({i + 1, j}) == visited.end()) {\\n                pq.push({nums1[i + 1] + nums2[j], {i + 1, j}});\\n                visited.insert({i + 1, j});\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//Complete Brute Force using MinHeap - TIME COMPLEXITY = O(m*n*log(k)) - TLE\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> P;\\n    \\n    struct lambda {\\n        bool operator()(P &p1, P &p2){\\n            return p1.first < p2.first; //Max heap\\n        }\\n    };\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<P, vector<P>, lambda> pq;\\n        \\n        int m = nums1.size();\\n        int n = nums2.size();\\n        \\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                \\n                int sum = nums1[i] + nums2[j];\\n\\n                if(pq.size() < k) {\\n                    pq.push({sum, {i, j}});\\n                } else if(pq.top().first > sum) {\\n                    pq.pop();\\n                    pq.push({sum, {i, j}});\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> result;\\n        \\n        while(!pq.empty()) {\\n            auto temp = pq.top(); \\n            pq.pop();\\n            \\n            int i = temp.second.first;\\n            int j = temp.second.second;\\n            result.push_back({nums1[i], nums2[j]});\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Improved BRUTE FORCE) \\n//Complete Brute Force using MinHeap - TIME COMPLEXITY < O(m*n*log(k)) - ACCEPTED\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> P;\\n    \\n    struct lambda {\\n        bool operator()(P &p1, P &p2){\\n            return p1.first < p2.first; //Max heap\\n        }\\n    };\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<P, vector<P>, lambda> pq;\\n        \\n        int m = nums1.size();\\n        int n = nums2.size();\\n        \\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                \\n                int sum = nums1[i] + nums2[j];\\n\\n                if(pq.size() < k) {\\n                    pq.push({sum, {i, j}});\\n                } else if(pq.top().first > sum) {\\n                    pq.pop();\\n                    pq.push({sum, {i, j}});\\n                } else {\\n                    break; //Breaking from here (slight improvement)\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> result;\\n        \\n        while(!pq.empty()) {\\n            auto temp = pq.top(); \\n            pq.pop();\\n            \\n            int i = temp.second.first;\\n            int j = temp.second.second;\\n            result.push_back({nums1[i], nums2[j]});\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-3 (Slight Better approach) - O(klog(k))\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> P;\\n    \\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        priority_queue<P, vector<P>, greater<P>> pq; //min-heap\\n        \\n        set<pair<int, int>> visited;\\n        visited.insert({0, 0});\\n        \\n        int sum = nums1[0] + nums2[0];\\n        \\n        pq.push({sum, {0, 0}});\\n        \\n        vector<vector<int>> result;\\n        while(k-- && !pq.empty()) {\\n            \\n            auto temp = pq.top(); \\n            pq.pop();\\n            \\n            int i = temp.second.first;\\n            int j = temp.second.second;\\n            result.push_back({nums1[i], nums2[j]});\\n            \\n            //Push (i, j+1) if possible\\n             if (j + 1 < n && visited.find({i, j + 1}) == visited.end()) {\\n                pq.push({nums1[i] + nums2[j + 1], {i, j + 1}});\\n                visited.insert({i, j + 1});\\n            }\\n\\n            //Push (i+1, j) if possible\\n            if (i + 1 < m && visited.find({i + 1, j}) == visited.end()) {\\n                pq.push({nums1[i + 1] + nums2[j], {i + 1, j}});\\n                visited.insert({i + 1, j});\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688751,
                "title": "java-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\n## we can use a min heap to store the pairs and then pop the top k elements from the heap\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## we will create a min heap and add all the pairs to the heap. we will also keep track of the index of the second element in the pair we will then pop the top element from the heap and add it to the result list. we will also check if the index of the second element is less than the length of the second array if it is, we will add the next pair to the heap. we will repeat this process until k becomes 0 or the heap becomes empty\\n\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        // 1. Create a min heap\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> (a[0] + a[1]) - (b[0] + b[1]));\\n        \\n        // 2. Add all the pairs to the min heap\\n        for (int i = 0; i < nums1.length && i < k; i++) {\\n            minHeap.offer(new int[]{nums1[i], nums2[0], 0});\\n        }\\n        \\n        // 3. Create a result list\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        // 4. Iterate until k\\n        while (k-- > 0 && !minHeap.isEmpty()) {\\n            // 5. Get the top element from the min heap\\n            int[] current = minHeap.poll();\\n            \\n            // 6. Add the pair to the result list\\n            result.add(Arrays.asList(current[0], current[1]));\\n            \\n            // 7. If the index of the second element is less than the length of the second array\\n            if (current[2] < nums2.length - 1) {\\n                // 8. Add the next pair to the min heap\\n                minHeap.offer(new int[]{current[0], nums2[current[2] + 1], current[2] + 1});\\n            }\\n        }\\n        \\n        // 9. Return the result list\\n        return result;\\n        \\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        // 1. Create a min heap\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> (a[0] + a[1]) - (b[0] + b[1]));\\n        \\n        // 2. Add all the pairs to the min heap\\n        for (int i = 0; i < nums1.length && i < k; i++) {\\n            minHeap.offer(new int[]{nums1[i], nums2[0], 0});\\n        }\\n        \\n        // 3. Create a result list\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        // 4. Iterate until k\\n        while (k-- > 0 && !minHeap.isEmpty()) {\\n            // 5. Get the top element from the min heap\\n            int[] current = minHeap.poll();\\n            \\n            // 6. Add the pair to the result list\\n            result.add(Arrays.asList(current[0], current[1]));\\n            \\n            // 7. If the index of the second element is less than the length of the second array\\n            if (current[2] < nums2.length - 1) {\\n                // 8. Add the next pair to the min heap\\n                minHeap.offer(new int[]{current[0], nums2[current[2] + 1], current[2] + 1});\\n            }\\n        }\\n        \\n        // 9. Return the result list\\n        return result;\\n        \\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688676,
                "title": "lightning-fast-solution-k-pairs-with-smallest-sums-python-coding-with-vanamsen",
                "content": "# Intuition\\nWhen first encountering this problem, we might consider brute force - calculating the sum of all pairs, sorting them, and choosing the smallest k sums. However, this solution is not efficient and will exceed the time limit for large inputs. Observing that the arrays are sorted, we can leverage this property and use a heap data structure to optimize our solution. We can intelligently select and compare potential pairs rather than calculating all possible pairs, which will significantly increase the efficiency.\\n\\nhttps://youtu.be/ilK09wC4PQM\\n\\n# Approach\\nOur approach involves using a min-heap data structure. Initially, we push the pair with the smallest sum (nums1[0], nums2[0]) into the heap. The heap will automatically arrange it based on the sum, which is the first element in the pair. To avoid processing duplicate pairs, we also maintain a visited set. Then, we start a while loop, continuing until we get k pairs or the heap is empty. In each iteration, we pop a pair from the heap, add it to the result list, and push the next potential pairs (nums1[i+1], nums2[j]) and (nums1[i], nums2[j+1]) into the heap. The heap and the visited set help us always pick the unvisited pair with the smallest sum. The process continues until we\\'ve found our k pairs or exhausted all possible pairs.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(k log k) since we perform a heap push and pop operation up to k times, each operation has a log k complexity due to heap restructure.\\n\\n- Space complexity:\\nThe space complexity of this solution is O(k) as we need to store the heap elements and visited pairs, the maximum of which can be k.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        # Heap initialization \\n        queue = [] \\n        def push(i, j): \\n            # In Python heap is a min-heap \\n            # Therefore, we use a tuple, first element is a sum (the priority), then pair itself \\n            if i < len(nums1) and j < len(nums2): \\n                heapq.heappush(queue, [nums1[i] + nums2[j], i, j])     \\n        push(0, 0) \\n        # Set to keep track of pairs we have already pushed into the heap \\n        # It\\'s needed because we are doing \"push(i+1, j)\" and \"push(i, j+1)\" separately \\n        # If not using this visited set, we will end up pushing many duplicate pairs into the heap \\n        visited = set() \\n        visited.add((0, 0)) \\n        result = [] \\n        while queue and len(result) < k: \\n            _, i, j = heapq.heappop(queue) \\n            result.append([nums1[i], nums2[j]]) \\n            if i+1 < len(nums1) and (i+1, j) not in visited:  \\n                push(i+1, j) \\n                visited.add((i+1, j)) \\n            if j+1 < len(nums2) and (i, j+1) not in visited:  \\n                push(i, j+1) \\n                visited.add((i, j+1)) \\n        return result \\n                                                                                                                                                                                                                                                                        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        # Heap initialization \\n        queue = [] \\n        def push(i, j): \\n            # In Python heap is a min-heap \\n            # Therefore, we use a tuple, first element is a sum (the priority), then pair itself \\n            if i < len(nums1) and j < len(nums2): \\n                heapq.heappush(queue, [nums1[i] + nums2[j], i, j])     \\n        push(0, 0) \\n        # Set to keep track of pairs we have already pushed into the heap \\n        # It\\'s needed because we are doing \"push(i+1, j)\" and \"push(i, j+1)\" separately \\n        # If not using this visited set, we will end up pushing many duplicate pairs into the heap \\n        visited = set() \\n        visited.add((0, 0)) \\n        result = [] \\n        while queue and len(result) < k: \\n            _, i, j = heapq.heappop(queue) \\n            result.append([nums1[i], nums2[j]]) \\n            if i+1 < len(nums1) and (i+1, j) not in visited:  \\n                push(i+1, j) \\n                visited.add((i+1, j)) \\n            if j+1 < len(nums2) and (i, j+1) not in visited:  \\n                push(i, j+1) \\n                visited.add((i, j+1)) \\n        return result \\n                                                                                                                                                                                                                                                                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687933,
                "title": "c-made-simple-optimal-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        \\n        int n = nums1.Length;\\n        int m = nums2.Length;\\n\\n        var prio = new PriorityQueue<(int, int), int>();\\n        prio.Enqueue((0, 0), nums1[0] + nums2[0]);\\n\\n        var visited = new HashSet<(int, int)>();\\n        var retList = new List<IList<int>>();\\n\\n        while (prio.Count > 0 && retList.Count < k){\\n            var cur = prio.Dequeue();\\n\\n            int x = cur.Item1;\\n            int y = cur.Item2;\\n\\n            retList.Add(new List<int>{nums1[x], nums2[y]});\\n            visited.Add((x, y));\\n\\n            if (x + 1 < n && y < m && !visited.Contains((x + 1, y))){\\n                prio.Enqueue((x + 1, y), nums1[x + 1] + nums2[y]);\\n                visited.Add((x + 1, y));\\n            }   \\n\\n            if (x < n && y + 1 < m && !visited.Contains((x, y + 1))){\\n                prio.Enqueue((x, y + 1), nums1[x] + nums2[y + 1]);\\n                visited.Add((x, y + 1));\\n            } \\n        }\\n\\n        return retList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        \\n        int n = nums1.Length;\\n        int m = nums2.Length;\\n\\n        var prio = new PriorityQueue<(int, int), int>();\\n        prio.Enqueue((0, 0), nums1[0] + nums2[0]);\\n\\n        var visited = new HashSet<(int, int)>();\\n        var retList = new List<IList<int>>();\\n\\n        while (prio.Count > 0 && retList.Count < k){\\n            var cur = prio.Dequeue();\\n\\n            int x = cur.Item1;\\n            int y = cur.Item2;\\n\\n            retList.Add(new List<int>{nums1[x], nums2[y]});\\n            visited.Add((x, y));\\n\\n            if (x + 1 < n && y < m && !visited.Contains((x + 1, y))){\\n                prio.Enqueue((x + 1, y), nums1[x + 1] + nums2[y]);\\n                visited.Add((x + 1, y));\\n            }   \\n\\n            if (x < n && y + 1 < m && !visited.Contains((x, y + 1))){\\n                prio.Enqueue((x, y + 1), nums1[x] + nums2[y + 1]);\\n                visited.Add((x, y + 1));\\n            } \\n        }\\n\\n        return retList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687915,
                "title": "rust-heap-solution",
                "content": "\\n```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn k_smallest_pairs(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<Vec<i32>> {\\n        let mut heap = BinaryHeap::new();\\n        let mut k = k as usize;\\n        let (m, n) = (nums1.len(), nums2.len());\\n        let mut res = vec![];\\n\\n        for i in 0..m {\\n            heap.push(Reverse((nums1[i] + nums2[0], i, 0 as usize)));\\n        }\\n\\n        while k > 0 {\\n            if let Some(Reverse((_sum, i, j))) = heap.pop() {\\n                res.push(vec![nums1[i], nums2[j]]);\\n\\n                if j + 1 < n {\\n                    heap.push(Reverse((nums1[i] + nums2[j + 1], i, j + 1)));\\n                }\\n            }\\n\\n            k -= 1;\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn k_smallest_pairs(nums1: Vec<i32>, nums2: Vec<i32>, k: i32) -> Vec<Vec<i32>> {\\n        let mut heap = BinaryHeap::new();\\n        let mut k = k as usize;\\n        let (m, n) = (nums1.len(), nums2.len());\\n        let mut res = vec![];\\n\\n        for i in 0..m {\\n            heap.push(Reverse((nums1[i] + nums2[0], i, 0 as usize)));\\n        }\\n\\n        while k > 0 {\\n            if let Some(Reverse((_sum, i, j))) = heap.pop() {\\n                res.push(vec![nums1[i], nums2[j]]);\\n\\n                if j + 1 < n {\\n                    heap.push(Reverse((nums1[i] + nums2[j + 1], i, j + 1)));\\n                }\\n            }\\n\\n            k -= 1;\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3687865,
                "title": "k-smallest-pairs-with-smallest-sums-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find the k smallest pairs with the smallest sums, we can use a priority queue to keep track of the pairs with the smallest sum. I start by adding the first k pairs formed by taking the first element from nums1 and the first element from nums2. I store each pair as an array with three elements: the value from nums1, the value from nums2, and the index of the current element in nums2. I initialize the priority queue with a custom comparator that compares the sums of the pairs.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an empty result list to store the k smallest pairs.\\n2. If either nums1 or nums2 is empty or k is zero, return the empty result list.\\n3. Create a priority queue, **`pq`**, with the custom comparator **`Comaparator.comparingInt(a ->[0] + a[1])`**. This ensures that the pairs with smallest sums are at the front of the queue.\\n4. Iterate over the elements of nums1 up to the minimum of its length and k.\\n    - For each element **`nums[i]`**, add a pair **`[nums1[i], nums2[0], 0]`** to the priority queue. The third element 0 represents the index of the current element in nums2.\\n5. While k is greate than 0 and **`pq`** is not empty, do the following:\\n    - Poll the pair with the smallest sum from **`pq`** and store it in **`pair`**.\\n    - Retrieve the values from **`pair`** and store them in **`num1`**, **`num2`**, and **`index2`**.\\n    - Create a new list **`currentPair`** and add **`num1`** and **`num2`** to it.\\n    - Add the **`currentPair`** to the result list.\\n    - If **`index2 + 1`** is less than the length of nums2, add the pair **`[num1, nums2[index2 + 1], index2 + 1]`** to **`pq`**.\\n    - Decrement k.\\n6. Return the result list.\\n\\n# Complexity\\n- Time complexity: O(k log k), where k is the given parameter.\\n    - Constructing the initial priority queue takes O(k log k) time.\\n    - The while loop iterates k times, and each iteration takes O(log k) time to poll from **`pq`** and offer new pairs to **`pq`**.\\n    - Therefore, the overall time complexity is dominated by the priority queue operations, resulting in O(k log k).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n    - The space used by the priority queue is O(k) to store the k smallest pairs.\\n    - The result list also requires O(k) space to store the k pairs.\\n    - Therefore, the overall space complexity is O(k).\\n\\n\\nThe provided code implements the described approach to solve the problem effeciently.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums1.length == 0 || nums2.length == 0 || k == 0) {\\n            return result;\\n        }\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0] + a[1]));\\n\\n        for (int i = 0; i < nums1.length && i < k; i++) {\\n            pq.offer(new int[]{nums1[i], nums2[0], 0});\\n        }\\n\\n        while (k > 0 && !pq.isEmpty()) {\\n            int[] pair = pq.poll();\\n            int num1 = pair[0];\\n            int num2 = pair[1];\\n            int index2 = pair[2];\\n\\n            List<Integer> currentPair = new ArrayList<>();\\n            currentPair.add(num1);\\n            currentPair.add(num2);\\n            result.add(currentPair);\\n\\n            if (index2 + 1 < nums2.length) {\\n                pq.offer(new int[]{num1, nums2[index2 + 1], index2 + 1});\\n            }\\n\\n            k--;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums1.length == 0 || nums2.length == 0 || k == 0) {\\n            return result;\\n        }\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0] + a[1]));\\n\\n        for (int i = 0; i < nums1.length && i < k; i++) {\\n            pq.offer(new int[]{nums1[i], nums2[0], 0});\\n        }\\n\\n        while (k > 0 && !pq.isEmpty()) {\\n            int[] pair = pq.poll();\\n            int num1 = pair[0];\\n            int num2 = pair[1];\\n            int index2 = pair[2];\\n\\n            List<Integer> currentPair = new ArrayList<>();\\n            currentPair.add(num1);\\n            currentPair.add(num2);\\n            result.add(currentPair);\\n\\n            if (index2 + 1 < nums2.length) {\\n                pq.offer(new int[]{num1, nums2[index2 + 1], index2 + 1});\\n            }\\n\\n            k--;\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687437,
                "title": "python-short-and-clean-heap-priority-queue",
                "content": "# Approach\\nTL;DR, Similar to [Editorial solution](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/editorial/) but instead of using `visited`, push pairs `(i, 0)` for every `i` in `[0, len(nums1)]`. Whenever a pair `(i, j)` is popped, add `(i, j + 1)` as the next pair into the heap.\\n\\n# Complexity\\n- Time complexity: $$O(min(k \\\\cdot log(k), n1 \\\\cdot n2 \\\\cdot log(n1 \\\\cdot n2)))$$\\n\\n- Space complexity: $$O(min(k, n1 \\\\cdot n2))$$\\n\\nwhere, `n1 and n2 are lengths of nums1 and nums2 respectively`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def kSmallestPairs(self, nums1: list[int], nums2: list[int], k: int) -> list[list[int]]:\\n        n1, n2 = len(nums1), len(nums2)\\n        sumsq = [(nums1[i] + nums2[0], i, 0) for i in range(n1)]\\n        heapify(sumsq)\\n        \\n        smallest = []\\n        for _ in range(min(k, n1 * n2)):\\n            sum_, i, j = heappop(sumsq)\\n            smallest.append([nums1[i], nums2[j]])\\n            if j + 1 < n2: heappush(sumsq, (nums1[i] + nums2[j + 1], i, j + 1))\\n        \\n        return smallest\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def kSmallestPairs(self, nums1: list[int], nums2: list[int], k: int) -> list[list[int]]:\\n        n1, n2 = len(nums1), len(nums2)\\n        sumsq = [(nums1[i] + nums2[0], i, 0) for i in range(n1)]\\n        heapify(sumsq)\\n        \\n        smallest = []\\n        for _ in range(min(k, n1 * n2)):\\n            sum_, i, j = heappop(sumsq)\\n            smallest.append([nums1[i], nums2[j]])\\n            if j + 1 < n2: heappush(sumsq, (nums1[i] + nums2[j + 1], i, j + 1))\\n        \\n        return smallest\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687042,
                "title": "27-06-23-c-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ret;\\n        auto comp = [&nums1, &nums2](const pair<int, int>  &a, const pair<int, int> &b) {\\n            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\\n        };\\n        priority_queue< pair<int, int>, vector<pair<int, int>>, decltype(comp) >pq(comp);\\n        pq.push({0, 0});\\n        while(pq.size() && k--) {\\n            auto idx = pq.top();\\n            pq.pop();\\n            int i = idx.first, j = idx.second;\\n            ret.push_back(vector<int>({nums1[i], nums2[j]}));\\n            if(i == 0 && j+1 < nums2.size())pq.push({i, j+1});\\n            if(i+1 < nums1.size())pq.push({i+1, j});\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>> ret;\\n        auto comp = [&nums1, &nums2](const pair<int, int>  &a, const pair<int, int> &b) {\\n            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\\n        };\\n        priority_queue< pair<int, int>, vector<pair<int, int>>, decltype(comp) >pq(comp);\\n        pq.push({0, 0});\\n        while(pq.size() && k--) {\\n            auto idx = pq.top();\\n            pq.pop();\\n            int i = idx.first, j = idx.second;\\n            ret.push_back(vector<int>({nums1[i], nums2[j]}));\\n            if(i == 0 && j+1 < nums2.size())pq.push({i, j+1});\\n            if(i+1 < nums1.size())pq.push({i+1, j});\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687040,
                "title": "kotlin-explanation-code-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that the smallest first element is [0, 0] so the next smallest will be [1, 0] or [0, 1], we should consider both cases for all candidates\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHeap, priority queue will help you to get the right candidate while having just \"nlogn\" time complexity\\nAlso track and exclude repeating combinations, example \\n[0, 0] -> [0, 1], [1, 0]\\n[0, 1] -> [0, 2], [1, 1]\\n[1, 0] -> [2, 0], ***[1, 1]***\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun kSmallestPairs(nums1: IntArray, nums2: IntArray, k: Int): List<List<Int>> {\\n        val n = nums1.size\\n        val m = nums2.size\\n        val visited = mutableSetOf<String>()\\n        var queue = PriorityQueue<IntArray>() { arr1, arr2 ->\\n            (nums1[arr1[0]] + nums2[arr1[1]]).compareTo(nums1[arr2[0]] + nums2[arr2[1]])\\n        }\\n        queue.add(intArrayOf(0, 0))\\n\\n        val ans = mutableListOf<List<Int>>()\\n        repeat(k){\\n            if(queue.isEmpty()) return ans\\n            val (i, j) = queue.poll()\\n            ans.add(listOf(nums1[i], nums2[j]))\\n\\n            val k1 = \"${i + 1}, $j\"\\n            if(i + 1 < n && !visited.contains(k1)){\\n                queue.add(intArrayOf(i + 1, j))\\n                visited.add(k1)\\n            }\\n\\n            val k2 = \"${i}, ${j + 1}\"\\n            if(j + 1 < m && !visited.contains(k2)){\\n                queue.add(intArrayOf(i, j + 1))\\n                visited.add(k2)\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    fun kSmallestPairs(nums1: IntArray, nums2: IntArray, k: Int): List<List<Int>> {\\n        val n = nums1.size\\n        val m = nums2.size\\n        val visited = mutableSetOf<String>()\\n        var queue = PriorityQueue<IntArray>() { arr1, arr2 ->\\n            (nums1[arr1[0]] + nums2[arr1[1]]).compareTo(nums1[arr2[0]] + nums2[arr2[1]])\\n        }\\n        queue.add(intArrayOf(0, 0))\\n\\n        val ans = mutableListOf<List<Int>>()\\n        repeat(k){\\n            if(queue.isEmpty()) return ans\\n            val (i, j) = queue.poll()\\n            ans.add(listOf(nums1[i], nums2[j]))\\n\\n            val k1 = \"${i + 1}, $j\"\\n            if(i + 1 < n && !visited.contains(k1)){\\n                queue.add(intArrayOf(i + 1, j))\\n                visited.add(k1)\\n            }\\n\\n            val k2 = \"${i}, ${j + 1}\"\\n            if(j + 1 < m && !visited.contains(k2)){\\n                queue.add(intArrayOf(i, j + 1))\\n                visited.add(k2)\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686987,
                "title": "min-heap-python-js-solution",
                "content": "Hello Tenno Leetcoders, \\n\\nFor this problem, we  are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.\\n\\nDefine a pair `(u, v)` which consists of one element from the first array and one element from the second array.\\n\\nReturn the k pairs `(u1, v1), (u2, v2), ..., (uk, vk)` with the smallest sums.\\n\\n### Explanation\\n\\nWe are asked to find the `k` pairs with the smallest sums from the two sorted arrays, `nums1` and `nums2`. A pair consists of one element from nums1 and one element from nums2. The pairs should be returned in ascending order based on their sums.\\n\\nSince we want to find the smallest sum in the two sorted arrays combined, we can use min-heap approach. The min-heap appraoch is based on the idea of maintaining a min-heap to track the pairs based on their sum, so that, we can easily retrieve the pair with the smallest sum efficiently. \\n\\n- If either `nums1` or `nums2` is empty. We return an empty list as there are no such valid pairs to consider\\n\\n- Create a min-heap to store our smallest pairs and `result` list to store the `k` smallest pairs that we will find\\n\\n- First, we push the pairs from `nums1[i]` adding `nums2[0]` for all `i` in `nums1` to ensure that we start with the pairs that have the smallest sum. This will help us find the smallest pairs efficiently.\\n\\n- Traverse until we find the `k` pairs or min-heap becomes empty\\n\\n- During each iteration, pop the pair with the smallest sum from the min-heap. This pairs will have the minimum sum among all the pairs in the min-heap and append it to `result`\\n\\n    - If there are more elements in `nums2` for the same elements in `nums1`, push the next pairs into min-heap, ensuring that we will consider the next element from `nums2` for the same element in `nums1` while finding the smallest pairs\\n        \\n    \\n- return result\\n\\n\\n# Code\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        if not nums1 or not nums2:\\n            return []\\n\\n        min_heap = []\\n        result = []\\n\\n        for i in range(len(nums1)):\\n            heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))\\n\\n        while k > 0 and min_heap:\\n            # Pop the pair with the smallest sum\\n            _, i, j = heapq.heappop(min_heap)  \\n            result.append([nums1[i], nums2[j]])\\n\\n            if j + 1 < len(nums2):\\n                # Push the next pair into the min-heap\\n                heapq.heappush(min_heap, (nums1[i] + nums2[j+1], i, j+1))\\n\\n            k -= 1\\n\\n        return result\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar kSmallestPairs = function(nums1, nums2, k) {\\n   if (!nums1.length || !nums2.length) return [];\\n  \\n    const minHeap = new MinPriorityQueue({ priority: ([sum]) => sum });\\n    const result = [];\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        minHeap.enqueue([nums1[i] + nums2[0], i, 0]);\\n    }\\n\\n    while (k > 0 && !minHeap.isEmpty()) {\\n        const { element: [_, i, j] } = minHeap.dequeue(); \\n        result.push([nums1[i], nums2[j]]);\\n\\n        if (j + 1 < nums2.length) {\\n        minHeap.enqueue([nums1[i] + nums2[j+1], i, j+1]);\\n        }\\n\\n        k--;\\n    }\\n\\n    return result;\\n}\\n```\\n\\n### Time Complexity: O(k * log(min(N, M, k)))\\n### Space Complexity: O(k)\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)\\n",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\\n        if not nums1 or not nums2:\\n            return []\\n\\n        min_heap = []\\n        result = []\\n\\n        for i in range(len(nums1)):\\n            heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))\\n\\n        while k > 0 and min_heap:\\n            # Pop the pair with the smallest sum\\n            _, i, j = heapq.heappop(min_heap)  \\n            result.append([nums1[i], nums2[j]])\\n\\n            if j + 1 < len(nums2):\\n                # Push the next pair into the min-heap\\n                heapq.heappush(min_heap, (nums1[i] + nums2[j+1], i, j+1))\\n\\n            k -= 1\\n\\n        return result\\n```\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar kSmallestPairs = function(nums1, nums2, k) {\\n   if (!nums1.length || !nums2.length) return [];\\n  \\n    const minHeap = new MinPriorityQueue({ priority: ([sum]) => sum });\\n    const result = [];\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        minHeap.enqueue([nums1[i] + nums2[0], i, 0]);\\n    }\\n\\n    while (k > 0 && !minHeap.isEmpty()) {\\n        const { element: [_, i, j] } = minHeap.dequeue(); \\n        result.push([nums1[i], nums2[j]]);\\n\\n        if (j + 1 < nums2.length) {\\n        minHeap.enqueue([nums1[i] + nums2[j+1], i, j+1]);\\n        }\\n\\n        k--;\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686981,
                "title": "c-easy-to-understand-optimized-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe take max heap and the priority will be the sum ,\\nMax sum will be at top of the heap according to max heap\\nWe push the element till the size of pq < k\\nthen compare the other sums with the top of the heap\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMax Heap\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>ans;\\n        priority_queue<pair<int,pair<int,int>>>pq;     //Max Heap\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n               int sum=nums1[i]+nums2[j];\\n                 //only for first iteration until size is k\\n                if(pq.size() < k){\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                 // here compare sum with the top of pq \\n                else if(pq.top().first > sum){\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        while(!pq.empty()){\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>ans;\\n        priority_queue<pair<int,pair<int,int>>>pq;     //Max Heap\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n               int sum=nums1[i]+nums2[j];\\n                 //only for first iteration until size is k\\n                if(pq.size() < k){\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                 // here compare sum with the top of pq \\n                else if(pq.top().first > sum){\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        while(!pq.empty()){\\n            ans.push_back({pq.top().second.first,pq.top().second.second});\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686903,
                "title": "daily-leetcoding-challenge-june-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Heap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3676890,
                "title": "c-easy-optimized-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>ans;\\n        priority_queue<pair<int,pair<int,int>>>pq;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++ ){\\n                int sum=nums1[i]+nums2[j];\\n                //only for first iteration until size is k\\n                if(pq.size()<k)\\n                pq.push({sum,{nums1[i],nums2[j]}});\\n                // here comes the main parameter\\n               else if(sum<pq.top().first){\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                else if(sum>pq.top().first) {\\n                    break;\\n                }\\n                 \\n            }\\n        }\\n        while( !pq.empty()){\\n        ans.push_back({pq.top().second.first,pq.top().second.second});\\n        pq.pop();\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int>>ans;\\n        priority_queue<pair<int,pair<int,int>>>pq;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++ ){\\n                int sum=nums1[i]+nums2[j];\\n                //only for first iteration until size is k\\n                if(pq.size()<k)\\n                pq.push({sum,{nums1[i],nums2[j]}});\\n                // here comes the main parameter\\n               else if(sum<pq.top().first){\\n                    pq.pop();\\n                    pq.push({sum,{nums1[i],nums2[j]}});\\n                }\\n                else if(sum>pq.top().first) {\\n                    break;\\n                }\\n                 \\n            }\\n        }\\n        while( !pq.empty()){\\n        ans.push_back({pq.top().second.first,pq.top().second.second});\\n        pq.pop();\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235766,
                "title": "c-priority-queue-simple-code-pairs-with-smallest-sums",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int> > ans;\\n        priority_queue< pair < int , pair<int,int> > > p;\\n        for(int i=0; i<nums1.size(); i++){\\n            for(int j=0; j<nums2.size(); j++){\\n                int sum=nums1[i]+nums2[j];\\n                \\n                if(p.size()<k) p.push( {sum , {nums1[i] , nums2[j]} } );\\n                \\n                else if(sum<p.top().first){\\n                    p.pop();\\n                    p.push( {sum , {nums1[i] , nums2[j]} } );\\n                }\\n                else break;    // save time...we need not to iterate over unnecessary (remaining) elements of the array...else TLE\\n            }\\n        }\\n        \\n        while(!p.empty()){\\n            ans.push_back({p.top().second.first , p.top().second.second});\\n            p.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<vector<int> > ans;\\n        priority_queue< pair < int , pair<int,int> > > p;\\n        for(int i=0; i<nums1.size(); i++){\\n            for(int j=0; j<nums2.size(); j++){\\n                int sum=nums1[i]+nums2[j];\\n                \\n                if(p.size()<k) p.push( {sum , {nums1[i] , nums2[j]} } );\\n                \\n                else if(sum<p.top().first){\\n                    p.pop();\\n                    p.push( {sum , {nums1[i] , nums2[j]} } );\\n                }\\n                else break;    // save time...we need not to iterate over unnecessary (remaining) elements of the array...else TLE\\n            }\\n        }\\n        \\n        while(!p.empty()){\\n            ans.push_back({p.top().second.first , p.top().second.second});\\n            p.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226019,
                "title": "priority-queue-c-cinch-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    typedef tuple<int, int, int> t;\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<vector<int>> ans;\\n        priority_queue<t, vector<t>, greater<t>> pq;\\n        for(int i=0; i<n; i++){\\n            pq.push({nums1[i]+nums2[0], i, 0});\\n        }\\n        while(k-- && !pq.empty()){\\n            auto [a,b,c] = pq.top();\\n            pq.pop();\\n            ans.push_back({nums1[b], nums2[c]});\\n            if(c+1 == nums2.size())\\n                continue;\\n            pq.push({nums1[b] + nums2[c+1], b, c+1});\\n        }\\n        return ans;\\n    }\\n};\\n      \\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef tuple<int, int, int> t;\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        int n = nums1.size();\\n        vector<vector<int>> ans;\\n        priority_queue<t, vector<t>, greater<t>> pq;\\n        for(int i=0; i<n; i++){\\n            pq.push({nums1[i]+nums2[0], i, 0});\\n        }\\n        while(k-- && !pq.empty()){\\n            auto [a,b,c] = pq.top();\\n            pq.pop();\\n            ans.push_back({nums1[b], nums2[c]});\\n            if(c+1 == nums2.size())\\n                continue;\\n            pq.push({nums1[b] + nums2[c+1], b, c+1});\\n        }\\n        return ans;\\n    }\\n};\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045654,
                "title": "java-priorityqueue-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        \\n        \\n        List<List<Integer>> ans = new ArrayList<List<Integer>>(); \\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new customComparator());// sorted in ascending order on sum\\n        \\n        HashSet <String> set = new HashSet <String>(); // HashSet will help to check if indexs is visited or not.\\n        \\n        int[] tem = new int[3];\\n        \\n        int sum = nums1[0] + nums2[0];\\n        \\n        tem[0] = sum; // sum of i index for nums1 & j index from nums2.\\n        tem[1] = 0; // tem[1] will alway store the index of nums1 element\\n        tem[2] = 0; // tem[2] will alway store the index of nums2 element\\n        \\n        set.add(\"0$0\"); // In set we will stor the i th index and j th index like this \"i\" + \"&\" + \"j\".\\n        \\n        pq.add(tem); // storing tem array in priority queue\\n        \\n        while(pq.size() > 0 && k > 0)\\n        {\\n            int[] tem2 = pq.poll(); // taking out minimum sum entry from priority queue\\n            \\n            int data = tem2[0];\\n            int i = tem2[1];\\n            int j = tem2[2];\\n            \\n            List<Integer> ls = new ArrayList<Integer>();\\n            \\n            ls.add(nums1[i]); // adding minimum removed sum operands of i th index from nums1\\n            ls.add(nums2[j]); // adding minimum removed sum operands of j th index from nums2\\n            \\n            ans.add(ls);\\n            \\n            String s1 = i + \"$\" + (j + 1); \\n            String s2 = (i + 1) + \"$\" + j;\\n            \\n            if(j + 1 < nums2.length && set.contains(s1) == false)\\n            {\\n                int[] tem1 = new int[3];\\n                \\n                sum = nums1[i] + nums2[j + 1];\\n        \\n                tem1[0] = sum;\\n                tem1[1] = i;\\n                tem1[2] = j + 1;\\n                \\n                pq.add(tem1);\\n                set.add(s1);\\n            }\\n            \\n            if(i + 1 < nums1.length && set.contains(s2) == false)\\n            {\\n                int[] tem1 = new int[3];\\n                \\n                sum = nums1[i + 1] + nums2[j];\\n        \\n                tem1[0] = sum;\\n                tem1[1] = i + 1;\\n                tem1[2] = j;\\n                \\n                pq.add(tem1);\\n                \\n                set.add(s2);\\n            }\\n            k--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// sort the data in ascending order based on sum of nums1[i] + nums2[j]\\n\\nclass customComparator implements Comparator <int[]> { \\n\\n    public int compare(int[] a, int[] b)\\n    {\\n        return a[0] - b[0];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        \\n        \\n        List<List<Integer>> ans = new ArrayList<List<Integer>>(); \\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new customComparator());// sorted in ascending order on sum\\n        \\n        HashSet <String> set = new HashSet <String>(); // HashSet will help to check if indexs is visited or not.\\n        \\n        int[] tem = new int[3];\\n        \\n        int sum = nums1[0] + nums2[0];\\n        \\n        tem[0] = sum; // sum of i index for nums1 & j index from nums2.\\n        tem[1] = 0; // tem[1] will alway store the index of nums1 element\\n        tem[2] = 0; // tem[2] will alway store the index of nums2 element\\n        \\n        set.add(\"0$0\"); // In set we will stor the i th index and j th index like this \"i\" + \"&\" + \"j\".\\n        \\n        pq.add(tem); // storing tem array in priority queue\\n        \\n        while(pq.size() > 0 && k > 0)\\n        {\\n            int[] tem2 = pq.poll(); // taking out minimum sum entry from priority queue\\n            \\n            int data = tem2[0];\\n            int i = tem2[1];\\n            int j = tem2[2];\\n            \\n            List<Integer> ls = new ArrayList<Integer>();\\n            \\n            ls.add(nums1[i]); // adding minimum removed sum operands of i th index from nums1\\n            ls.add(nums2[j]); // adding minimum removed sum operands of j th index from nums2\\n            \\n            ans.add(ls);\\n            \\n            String s1 = i + \"$\" + (j + 1); \\n            String s2 = (i + 1) + \"$\" + j;\\n            \\n            if(j + 1 < nums2.length && set.contains(s1) == false)\\n            {\\n                int[] tem1 = new int[3];\\n                \\n                sum = nums1[i] + nums2[j + 1];\\n        \\n                tem1[0] = sum;\\n                tem1[1] = i;\\n                tem1[2] = j + 1;\\n                \\n                pq.add(tem1);\\n                set.add(s1);\\n            }\\n            \\n            if(i + 1 < nums1.length && set.contains(s2) == false)\\n            {\\n                int[] tem1 = new int[3];\\n                \\n                sum = nums1[i + 1] + nums2[j];\\n        \\n                tem1[0] = sum;\\n                tem1[1] = i + 1;\\n                tem1[2] = j;\\n                \\n                pq.add(tem1);\\n                \\n                set.add(s2);\\n            }\\n            k--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// sort the data in ascending order based on sum of nums1[i] + nums2[j]\\n\\nclass customComparator implements Comparator <int[]> { \\n\\n    public int compare(int[] a, int[] b)\\n    {\\n        return a[0] - b[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890575,
                "title": "c-priority-queue-simple",
                "content": "**If Helpful Please Like or Upvoke**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq; \\n        for(int i=0;i<nums1.size(); i++){\\n            for(int j=0; j<nums2.size(); j++){\\n                \\n                int sum=nums1[i]+nums2[j];\\n                \\n                if (pq.size()<k) {\\n                pq.push({sum,{nums1[i],nums2[j]}});\\n            }\\n                \\n            else if (pq.size()==k and sum<pq.top().first) {\\n                pq.pop();\\n                pq.push({sum,{nums1[i],nums2[j]}});\\n            }\\n                else  break;\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        while(!pq.empty()){\\n            int a=pq.top().second.first;\\n            int b=pq.top().second.second;\\n            ans.push_back({a, b});\\n            pq.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int,pair<int,int>>> pq; \\n        for(int i=0;i<nums1.size(); i++){\\n            for(int j=0; j<nums2.size(); j++){\\n                \\n                int sum=nums1[i]+nums2[j];\\n                \\n                if (pq.size()<k) {\\n                pq.push({sum,{nums1[i],nums2[j]}});\\n            }\\n                \\n            else if (pq.size()==k and sum<pq.top().first) {\\n                pq.pop();\\n                pq.push({sum,{nums1[i],nums2[j]}});\\n            }\\n                else  break;\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        while(!pq.empty()){\\n            int a=pq.top().second.first;\\n            int b=pq.top().second.second;\\n            ans.push_back({a, b});\\n            pq.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568638,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1946251,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1898821,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1946307,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1571645,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1571644,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1946859,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1953455,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1946011,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1802604,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1568638,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1946251,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1898821,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1946307,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1571645,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1571644,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1946859,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1953455,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1946011,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1802604,
                "content": [
                    {
                        "username": "onebigsalmon",
                        "content": "I read the popular solutions using a priority queue and understand how it works. However, intuitively, doesn\\'t this problem seem like it can be done with 2 pointers? One pointer for each array, advance them in a certain way. I can\\'t get it to work and I guess it cannot be done. Can anyone explain why?"
                    },
                    {
                        "username": "srv96",
                        "content": "yes its seems intuitive so I tried with two pointer , but after solving i got to knwo it will not work  \\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\noutput = [[1,1],[1,1],[1,2],[2,1],[2,2],[2,3]]\\nexpected = [[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nsee here its skiping the previous possible result  because at sometime they are bigger then the counterpart , and code return result after 2 loops complete ,so no way to add them again ."
                    },
                    {
                        "username": "santanusen",
                        "content": "I wasted an hour trying to solve with 2 pointers; in kind of a merge routine manner. Then realized that it only produces O(m + n) pairs whereas the answer requires O(m*n) pairs."
                    },
                    {
                        "username": "devatraj",
                        "content": "There will be many variables, two pointer wont work that way. If i,j in num1,num2: Once we move forward we have to maintain additional pointers for i+1,j-1 combination, and moving ahead,i+2,j-2,j-1 and i+1,j,j+1 and so on. Things will get more tricky if sum1==sum2.  But It can be implemented,if anyone does, please update"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "I'll try to put this in a simple way. If we keep 2 pointers both pointers at 0th index for each array. Now if we advance the pointer at 2nd array, we lost all the possible pairs that can be made with the other elements present in the 1st array and the element present in the 0th index of the 2nd array that could be a smaller pair."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@ayushanand18](/ayushanand18) If k>n^2 return n^2 pairs."
                    },
                    {
                        "username": "parag776",
                        "content": "[1, 2, 2, 4]\\n[1, 2, 2, 4]\\n\\npq solution is like a two pointer one, suppose we are doing 2pointer l = 0, r = 3 now we see l = 1, r = 0 is better (smaller)\\nthen we have to save the state of l=0,r=3 we might need it again, now suppose we reach at l=1,r=1 but though being better than l=0,r=3, not better than l=2,r=0 now we have to manage the which state occupies which position we can do binary search and add at the relevant position or just use pq.\\n\\npq seems less implementation heavy.\\n\\n(my explanation is very bad and i am lazy.)\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I though the same way. The idea is to place one pointer on nums1 and another on nums2, you advance nums2 pointer as long as the sum of both pointers is less than pointer1+nums2[0], that is sum after advancing nums1 pointer and the start of nums2. I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "user7478F",
                        "content": "it will give a Memory Limit Exceeded error"
                    },
                    {
                        "username": "jorgophool",
                        "content": "Turns out it is possible to solve it using 2-pointers (technically, multiple pointers) approach. If we maintain an array of length n (where n is the length of nums1), where arr[i] tells us that \"the pair (nums1[i], nums2[arr[i]]) has already been formed so if we want to make pair with nums1[i], we should try that with nums2[arr[i] + 1]. Initially, it will be -1 indicating pair is not formed yet\". \\n\\nYou can check out my solution - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/980491446/.\\n\\nWhile the time complexity is O(kn) (and I for sure thought it would TLE in the large test cases), there are few optimizations and short circuits which makes it pass all the cases (and manages to beat 70% of other solutions in runtime)."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "It\\'s not directly possible to solve this problem efficiently using a two-pointer approach, because the problem doesn\\'t involve finding a target sum, difference, or product. Usually, two-pointer techniques work well when the array is sorted and we are looking for a certain condition that involves the relationship between two numbers (like their sum or difference)."
                    },
                    {
                        "username": "vishwasrajbatham151",
                        "content": "Try ur thinking with a = 1, 2, 2 and b = 1, 2, 3;\\nu will see ans = {(1, 1), (1, 1), (2, 1) }\\nnow i = 2 and j=0 but this way u are leaving a pair at indices (1, 1) which is also (1, 2) with sum = 3. So i think this way it fails all cases having same sum with different integers;"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "In case anyone else started down the same wrong path I did - I thought I could use two pointers and compare the values of the next numbers in each list to find the smaller value. But this will not work because it will not search all possible pairs - need to think of a new approach"
                    },
                    {
                        "username": "devansh9011",
                        "content": "[@breathermachine](/breathermachine) Although I understood why two pointers won\\'t work, but can you explain how its related to directed acyclic graph."
                    },
                    {
                        "username": "emlitke",
                        "content": "[@kbbhatt04](/kbbhatt04) That\\'s the exact testcase that I\\'m failing with. Good to know 2 pointer doesn\\'t work. I was going to keep trying to brute force it :/"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Yes, it will not work because sorting by sum turns the indices into a directed acyclic graph."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "[@kbbhatt04](/kbbhatt04) can you explain me this has 3 elements in each vector, mathematically you can form atmost 9 pairs. How can you suffice k==10 here?"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "Consider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "yeah,I was also thinking but it coundnt return me all answer."
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "This problem is so easy yet so frustrating :(((("
                    },
                    {
                        "username": "santanusen",
                        "content": "It is deceptive."
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "Correction in the question: Return Minimum(k , availablePairs)."
                    },
                    {
                        "username": "singku",
                        "content": "the example gave:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nwhat about:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3] ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Both of your sequences are valid and correctly ordered, but they represent different sequences of choices for pairs. Let me explain:\\n\\nThe sequence you gave:\\n[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,3]\\n\\nThis sequence starts by choosing both [1,1] pairs, then choosing both pairs with sum 3 (i.e., [1,2]), then choosing [2,1], then choosing both pairs with sum 4 (i.e., [1,3]), then choosing [2,2], and finally choosing [2,3].\\n\\nThe sequence from the example:\\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\\n\\nThis sequence also starts by choosing both [1,1] pairs, but then it alternates between choosing the pairs with sum 3 (i.e., [1,2] and [2,1]), then it alternates between the pairs with sum 4 (i.e., [1,3] and [2,2]), and finally it chooses [2,3].\\n\\nBoth sequences are correct in the sense that they contain the same pairs and the sums of the pairs are non-decreasing. However, the order in which the pairs are chosen may differ depending on the specifics of the implementation. Different valid implementations may produce either sequence."
                    },
                    {
                        "username": "Timbuk2",
                        "content": "Question says: \"Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\"\\n\\nOne of the test case\\nInput:\\n[1,1,2]\\n[1,2,3]\\n10\\n\\nExpected solution:\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]\\n\\nHere k =10, but the solution have 9 pairs. \\n\\nK should not be greater than nums1.length * nums2.length. \\nIf its greater, then expected answer should be null or empty list.\\n\\nPlease fix it."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Me trying to solve DP and Graph questions but nowadays these simple question also fuck me!!!!!!!!!!!!!!!!!!! "
                    },
                    {
                        "username": "tejasX",
                        "content": "True :/ "
                    },
                    {
                        "username": "ironblade",
                        "content": "Why is there no output on my console? and my answer was previously acceptable but is no longer accepted"
                    },
                    {
                        "username": "khrome",
                        "content": "This is literally the one question I need to make up to get last months badge. Looks like im never getting it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "[@Jeetaksh](/Jeetaksh) thanks vroo"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "You all don\\'t worry, it\\'s a bug and I have reported it."
                    },
                    {
                        "username": "DAKSHTECHIE1",
                        "content": "expected fields are coming empty and right answer is coming in my output which is being shown as wrong ans . "
                    },
                    {
                        "username": "keekkenen",
                        "content": "I think it\\'s a platform trouble with this concrete case. If run empty code with return null value also code runner doesnt return normal error with somthing expected - now expeted form fields is empty and it\\'s not normal platform behavour."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I solved some problems about  heap and hit this one!\nA hit: the pair (i, j) has possible 2 adjacent vertices (i+1,j ) and (i, j+1)."
                    },
                    {
                        "username": "spookie886",
                        "content": "wow i understand it now, thank you!"
                    },
                    {
                        "username": "NoobyNoob",
                        "content": "Thanks for the hint."
                    },
                    {
                        "username": "qingqianq",
                        "content": "Memory Limit Exceeded, for those who check (k >= len1 * len2) , the 32nd test case will overflow and get k > -162470356. \\nk / len1 > len2.\\n"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "Thank you [@Guangqi](/qingqianq). I was wrecking my brain as to what is wrong!"
                    }
                ]
            },
            {
                "id": 1570269,
                "content": [
                    {
                        "username": "Chaitanya333",
                        "content": "n is length of 1st arr\\nm is length of 2nd arr\\nIf I use the heap solution.. Then is it  n*m log (n*m)\\nbecause I have to put all the pairs into heap and then pop all"
                    },
                    {
                        "username": "Raj_Amrit",
                        "content": "[@pkorobov](/pkorobov) If there are a possible of nm pairs you cannot keep a heap size of only n (or m). Also k in worst case can be equal to nm. So OP\\'s reasoning is valid imo."
                    },
                    {
                        "username": "pkorobov",
                        "content": "Actually, no.\n\nMost solutions keep heap size of n (or m, doesn't matter). And you have k <= mn operations during the loop.\n\nSo that is O(n + k * log(n)), where the first term is from heap construction based on [nums1[i] + nums2[0] for i in range(len(nums1))], and the second is from k pop and insert operations."
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Why does order within the pairs matter for this?  \n\nWith this code:\n ```python\n        res = []\n        while nums1 and nums2:\n            a, b = nums1, nums2\n            if a[0] > b[0]:\n                b, a = a, b\n            for i in range(len(b)):\n                res.append([a[0], b[i]])\n            \n            for i in range(1, len(a)):\n                res.append([a[i], b[0]])\n            \n            nums1 = nums1[1:]\n            nums2 = nums2[1:]\n        res.sort(key=sum)\n        return res[:min(k, len(res))]\n```\nFails:\n`nums1 = [1,2,4]`\n`nums2 = [-1,1,2]`\n`k = 100`\n\n```\n[[-1,1],[-1,2],[1,1],[-1,4],[2,1],[1,2],[2,2],[1,4],[2,4]] # Output\n[[1,-1],[2,-1],[1,1],[4,-1],[2,1],[1,2],[2,2],[4,1],[4,2]] # Expected\n```\n\nAttempting to add a max/min ordering fails other test cases, it really looks like they're heavily funneling for a priority queue solution here."
                    },
                    {
                        "username": "scottjohn",
                        "content": "running into the same thing with a different test case"
                    },
                    {
                        "username": "tejasX",
                        "content": "Man. It was Hard!"
                    },
                    {
                        "username": "hughloganellis",
                        "content": "If you're stuck mentally thinking about two pointers and can't figure out how to get to the answer- here'a a hint:\n\nEach time you can either take a step down nums1 or nums2, a bit like traversing a binary tree\nWhat's the best type of search to traverse a tree without going to the end of each branch?\nRemember to make sure you don't visit the same node twice!"
                    },
                    {
                        "username": "psionl0",
                        "content": "What appeared to be a relatively easy problem turned out to need a priority queue to keep track of the minimum sums AND a hash table to avoid duplicating results.\\nNot overly difficult but you won\\'t solve it if you are unfamiliar with priority queues and hash tables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "did it using binary search , sigh"
                    },
                    {
                        "username": "parasmn4",
                        "content": "First thought that it can be solved using two pointers but realized that it will not consider all the pairs.\\n\\nThen solved it using Max heap taking in all pairs in O(N*M*LogK) but got TLE.\\n\\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Strict way to solve:\\n\\n1. We need function F to find how many pairs with sum less than given value. Use two pointers and there will be O(n+m) time complexity.\\n\\n2. You should find the exact Value. Condition: F(Value) <= k < F(Value+1). For this you will use binary search. It needs maximum log(4 * 1e9) = 34 iterations. So, it is just huge constant value and does not depend on input size.\\n\\n3. With two pointers collect all pairs with sum less than Value. And add some pairs with sum equal to Value if it is needed. Time complexity O(k + n + m).\\n\\nSo, overall time complexity is O(k + n + m);\\nAs result: this solution beats 99% other solutions by time and 95% by memory."
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Priority queue & heap on back-to-back days \\uD83D\\uDD25"
                    },
                    {
                        "username": "srekhi",
                        "content": "Let's take two arrays:\\n[1,7,11] and [2,4,30]. What's wrong with having a pointer at 1 and 2, then at each iteration comparing, for example, (1,4) vs. (7,2). If 1,4 greater than 7,2, we can them compare (1,30) vs 7,2 and continue like this k times?"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "I tried this approach at first but the problem is once you\\'ve chosen to increment the pointers you can\\'t go back. You won\\'t iterate through all possible pairs, only a subset. But I only tried with one pointer for each array, not two like you suggested. So maybe there\\'s a way to make that work?"
                    }
                ]
            },
            {
                "id": 1677012,
                "content": [
                    {
                        "username": "Chaitanya333",
                        "content": "n is length of 1st arr\\nm is length of 2nd arr\\nIf I use the heap solution.. Then is it  n*m log (n*m)\\nbecause I have to put all the pairs into heap and then pop all"
                    },
                    {
                        "username": "Raj_Amrit",
                        "content": "[@pkorobov](/pkorobov) If there are a possible of nm pairs you cannot keep a heap size of only n (or m). Also k in worst case can be equal to nm. So OP\\'s reasoning is valid imo."
                    },
                    {
                        "username": "pkorobov",
                        "content": "Actually, no.\n\nMost solutions keep heap size of n (or m, doesn't matter). And you have k <= mn operations during the loop.\n\nSo that is O(n + k * log(n)), where the first term is from heap construction based on [nums1[i] + nums2[0] for i in range(len(nums1))], and the second is from k pop and insert operations."
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Why does order within the pairs matter for this?  \n\nWith this code:\n ```python\n        res = []\n        while nums1 and nums2:\n            a, b = nums1, nums2\n            if a[0] > b[0]:\n                b, a = a, b\n            for i in range(len(b)):\n                res.append([a[0], b[i]])\n            \n            for i in range(1, len(a)):\n                res.append([a[i], b[0]])\n            \n            nums1 = nums1[1:]\n            nums2 = nums2[1:]\n        res.sort(key=sum)\n        return res[:min(k, len(res))]\n```\nFails:\n`nums1 = [1,2,4]`\n`nums2 = [-1,1,2]`\n`k = 100`\n\n```\n[[-1,1],[-1,2],[1,1],[-1,4],[2,1],[1,2],[2,2],[1,4],[2,4]] # Output\n[[1,-1],[2,-1],[1,1],[4,-1],[2,1],[1,2],[2,2],[4,1],[4,2]] # Expected\n```\n\nAttempting to add a max/min ordering fails other test cases, it really looks like they're heavily funneling for a priority queue solution here."
                    },
                    {
                        "username": "scottjohn",
                        "content": "running into the same thing with a different test case"
                    },
                    {
                        "username": "tejasX",
                        "content": "Man. It was Hard!"
                    },
                    {
                        "username": "hughloganellis",
                        "content": "If you're stuck mentally thinking about two pointers and can't figure out how to get to the answer- here'a a hint:\n\nEach time you can either take a step down nums1 or nums2, a bit like traversing a binary tree\nWhat's the best type of search to traverse a tree without going to the end of each branch?\nRemember to make sure you don't visit the same node twice!"
                    },
                    {
                        "username": "psionl0",
                        "content": "What appeared to be a relatively easy problem turned out to need a priority queue to keep track of the minimum sums AND a hash table to avoid duplicating results.\\nNot overly difficult but you won\\'t solve it if you are unfamiliar with priority queues and hash tables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "did it using binary search , sigh"
                    },
                    {
                        "username": "parasmn4",
                        "content": "First thought that it can be solved using two pointers but realized that it will not consider all the pairs.\\n\\nThen solved it using Max heap taking in all pairs in O(N*M*LogK) but got TLE.\\n\\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Strict way to solve:\\n\\n1. We need function F to find how many pairs with sum less than given value. Use two pointers and there will be O(n+m) time complexity.\\n\\n2. You should find the exact Value. Condition: F(Value) <= k < F(Value+1). For this you will use binary search. It needs maximum log(4 * 1e9) = 34 iterations. So, it is just huge constant value and does not depend on input size.\\n\\n3. With two pointers collect all pairs with sum less than Value. And add some pairs with sum equal to Value if it is needed. Time complexity O(k + n + m).\\n\\nSo, overall time complexity is O(k + n + m);\\nAs result: this solution beats 99% other solutions by time and 95% by memory."
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Priority queue & heap on back-to-back days \\uD83D\\uDD25"
                    },
                    {
                        "username": "srekhi",
                        "content": "Let's take two arrays:\\n[1,7,11] and [2,4,30]. What's wrong with having a pointer at 1 and 2, then at each iteration comparing, for example, (1,4) vs. (7,2). If 1,4 greater than 7,2, we can them compare (1,30) vs 7,2 and continue like this k times?"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "I tried this approach at first but the problem is once you\\'ve chosen to increment the pointers you can\\'t go back. You won\\'t iterate through all possible pairs, only a subset. But I only tried with one pointer for each array, not two like you suggested. So maybe there\\'s a way to make that work?"
                    }
                ]
            },
            {
                "id": 1946888,
                "content": [
                    {
                        "username": "Chaitanya333",
                        "content": "n is length of 1st arr\\nm is length of 2nd arr\\nIf I use the heap solution.. Then is it  n*m log (n*m)\\nbecause I have to put all the pairs into heap and then pop all"
                    },
                    {
                        "username": "Raj_Amrit",
                        "content": "[@pkorobov](/pkorobov) If there are a possible of nm pairs you cannot keep a heap size of only n (or m). Also k in worst case can be equal to nm. So OP\\'s reasoning is valid imo."
                    },
                    {
                        "username": "pkorobov",
                        "content": "Actually, no.\n\nMost solutions keep heap size of n (or m, doesn't matter). And you have k <= mn operations during the loop.\n\nSo that is O(n + k * log(n)), where the first term is from heap construction based on [nums1[i] + nums2[0] for i in range(len(nums1))], and the second is from k pop and insert operations."
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Why does order within the pairs matter for this?  \n\nWith this code:\n ```python\n        res = []\n        while nums1 and nums2:\n            a, b = nums1, nums2\n            if a[0] > b[0]:\n                b, a = a, b\n            for i in range(len(b)):\n                res.append([a[0], b[i]])\n            \n            for i in range(1, len(a)):\n                res.append([a[i], b[0]])\n            \n            nums1 = nums1[1:]\n            nums2 = nums2[1:]\n        res.sort(key=sum)\n        return res[:min(k, len(res))]\n```\nFails:\n`nums1 = [1,2,4]`\n`nums2 = [-1,1,2]`\n`k = 100`\n\n```\n[[-1,1],[-1,2],[1,1],[-1,4],[2,1],[1,2],[2,2],[1,4],[2,4]] # Output\n[[1,-1],[2,-1],[1,1],[4,-1],[2,1],[1,2],[2,2],[4,1],[4,2]] # Expected\n```\n\nAttempting to add a max/min ordering fails other test cases, it really looks like they're heavily funneling for a priority queue solution here."
                    },
                    {
                        "username": "scottjohn",
                        "content": "running into the same thing with a different test case"
                    },
                    {
                        "username": "tejasX",
                        "content": "Man. It was Hard!"
                    },
                    {
                        "username": "hughloganellis",
                        "content": "If you're stuck mentally thinking about two pointers and can't figure out how to get to the answer- here'a a hint:\n\nEach time you can either take a step down nums1 or nums2, a bit like traversing a binary tree\nWhat's the best type of search to traverse a tree without going to the end of each branch?\nRemember to make sure you don't visit the same node twice!"
                    },
                    {
                        "username": "psionl0",
                        "content": "What appeared to be a relatively easy problem turned out to need a priority queue to keep track of the minimum sums AND a hash table to avoid duplicating results.\\nNot overly difficult but you won\\'t solve it if you are unfamiliar with priority queues and hash tables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "did it using binary search , sigh"
                    },
                    {
                        "username": "parasmn4",
                        "content": "First thought that it can be solved using two pointers but realized that it will not consider all the pairs.\\n\\nThen solved it using Max heap taking in all pairs in O(N*M*LogK) but got TLE.\\n\\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Strict way to solve:\\n\\n1. We need function F to find how many pairs with sum less than given value. Use two pointers and there will be O(n+m) time complexity.\\n\\n2. You should find the exact Value. Condition: F(Value) <= k < F(Value+1). For this you will use binary search. It needs maximum log(4 * 1e9) = 34 iterations. So, it is just huge constant value and does not depend on input size.\\n\\n3. With two pointers collect all pairs with sum less than Value. And add some pairs with sum equal to Value if it is needed. Time complexity O(k + n + m).\\n\\nSo, overall time complexity is O(k + n + m);\\nAs result: this solution beats 99% other solutions by time and 95% by memory."
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Priority queue & heap on back-to-back days \\uD83D\\uDD25"
                    },
                    {
                        "username": "srekhi",
                        "content": "Let's take two arrays:\\n[1,7,11] and [2,4,30]. What's wrong with having a pointer at 1 and 2, then at each iteration comparing, for example, (1,4) vs. (7,2). If 1,4 greater than 7,2, we can them compare (1,30) vs 7,2 and continue like this k times?"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "I tried this approach at first but the problem is once you\\'ve chosen to increment the pointers you can\\'t go back. You won\\'t iterate through all possible pairs, only a subset. But I only tried with one pointer for each array, not two like you suggested. So maybe there\\'s a way to make that work?"
                    }
                ]
            },
            {
                "id": 1946639,
                "content": [
                    {
                        "username": "Chaitanya333",
                        "content": "n is length of 1st arr\\nm is length of 2nd arr\\nIf I use the heap solution.. Then is it  n*m log (n*m)\\nbecause I have to put all the pairs into heap and then pop all"
                    },
                    {
                        "username": "Raj_Amrit",
                        "content": "[@pkorobov](/pkorobov) If there are a possible of nm pairs you cannot keep a heap size of only n (or m). Also k in worst case can be equal to nm. So OP\\'s reasoning is valid imo."
                    },
                    {
                        "username": "pkorobov",
                        "content": "Actually, no.\n\nMost solutions keep heap size of n (or m, doesn't matter). And you have k <= mn operations during the loop.\n\nSo that is O(n + k * log(n)), where the first term is from heap construction based on [nums1[i] + nums2[0] for i in range(len(nums1))], and the second is from k pop and insert operations."
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Why does order within the pairs matter for this?  \n\nWith this code:\n ```python\n        res = []\n        while nums1 and nums2:\n            a, b = nums1, nums2\n            if a[0] > b[0]:\n                b, a = a, b\n            for i in range(len(b)):\n                res.append([a[0], b[i]])\n            \n            for i in range(1, len(a)):\n                res.append([a[i], b[0]])\n            \n            nums1 = nums1[1:]\n            nums2 = nums2[1:]\n        res.sort(key=sum)\n        return res[:min(k, len(res))]\n```\nFails:\n`nums1 = [1,2,4]`\n`nums2 = [-1,1,2]`\n`k = 100`\n\n```\n[[-1,1],[-1,2],[1,1],[-1,4],[2,1],[1,2],[2,2],[1,4],[2,4]] # Output\n[[1,-1],[2,-1],[1,1],[4,-1],[2,1],[1,2],[2,2],[4,1],[4,2]] # Expected\n```\n\nAttempting to add a max/min ordering fails other test cases, it really looks like they're heavily funneling for a priority queue solution here."
                    },
                    {
                        "username": "scottjohn",
                        "content": "running into the same thing with a different test case"
                    },
                    {
                        "username": "tejasX",
                        "content": "Man. It was Hard!"
                    },
                    {
                        "username": "hughloganellis",
                        "content": "If you're stuck mentally thinking about two pointers and can't figure out how to get to the answer- here'a a hint:\n\nEach time you can either take a step down nums1 or nums2, a bit like traversing a binary tree\nWhat's the best type of search to traverse a tree without going to the end of each branch?\nRemember to make sure you don't visit the same node twice!"
                    },
                    {
                        "username": "psionl0",
                        "content": "What appeared to be a relatively easy problem turned out to need a priority queue to keep track of the minimum sums AND a hash table to avoid duplicating results.\\nNot overly difficult but you won\\'t solve it if you are unfamiliar with priority queues and hash tables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "did it using binary search , sigh"
                    },
                    {
                        "username": "parasmn4",
                        "content": "First thought that it can be solved using two pointers but realized that it will not consider all the pairs.\\n\\nThen solved it using Max heap taking in all pairs in O(N*M*LogK) but got TLE.\\n\\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Strict way to solve:\\n\\n1. We need function F to find how many pairs with sum less than given value. Use two pointers and there will be O(n+m) time complexity.\\n\\n2. You should find the exact Value. Condition: F(Value) <= k < F(Value+1). For this you will use binary search. It needs maximum log(4 * 1e9) = 34 iterations. So, it is just huge constant value and does not depend on input size.\\n\\n3. With two pointers collect all pairs with sum less than Value. And add some pairs with sum equal to Value if it is needed. Time complexity O(k + n + m).\\n\\nSo, overall time complexity is O(k + n + m);\\nAs result: this solution beats 99% other solutions by time and 95% by memory."
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Priority queue & heap on back-to-back days \\uD83D\\uDD25"
                    },
                    {
                        "username": "srekhi",
                        "content": "Let's take two arrays:\\n[1,7,11] and [2,4,30]. What's wrong with having a pointer at 1 and 2, then at each iteration comparing, for example, (1,4) vs. (7,2). If 1,4 greater than 7,2, we can them compare (1,30) vs 7,2 and continue like this k times?"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "I tried this approach at first but the problem is once you\\'ve chosen to increment the pointers you can\\'t go back. You won\\'t iterate through all possible pairs, only a subset. But I only tried with one pointer for each array, not two like you suggested. So maybe there\\'s a way to make that work?"
                    }
                ]
            },
            {
                "id": 1946430,
                "content": [
                    {
                        "username": "Chaitanya333",
                        "content": "n is length of 1st arr\\nm is length of 2nd arr\\nIf I use the heap solution.. Then is it  n*m log (n*m)\\nbecause I have to put all the pairs into heap and then pop all"
                    },
                    {
                        "username": "Raj_Amrit",
                        "content": "[@pkorobov](/pkorobov) If there are a possible of nm pairs you cannot keep a heap size of only n (or m). Also k in worst case can be equal to nm. So OP\\'s reasoning is valid imo."
                    },
                    {
                        "username": "pkorobov",
                        "content": "Actually, no.\n\nMost solutions keep heap size of n (or m, doesn't matter). And you have k <= mn operations during the loop.\n\nSo that is O(n + k * log(n)), where the first term is from heap construction based on [nums1[i] + nums2[0] for i in range(len(nums1))], and the second is from k pop and insert operations."
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Why does order within the pairs matter for this?  \n\nWith this code:\n ```python\n        res = []\n        while nums1 and nums2:\n            a, b = nums1, nums2\n            if a[0] > b[0]:\n                b, a = a, b\n            for i in range(len(b)):\n                res.append([a[0], b[i]])\n            \n            for i in range(1, len(a)):\n                res.append([a[i], b[0]])\n            \n            nums1 = nums1[1:]\n            nums2 = nums2[1:]\n        res.sort(key=sum)\n        return res[:min(k, len(res))]\n```\nFails:\n`nums1 = [1,2,4]`\n`nums2 = [-1,1,2]`\n`k = 100`\n\n```\n[[-1,1],[-1,2],[1,1],[-1,4],[2,1],[1,2],[2,2],[1,4],[2,4]] # Output\n[[1,-1],[2,-1],[1,1],[4,-1],[2,1],[1,2],[2,2],[4,1],[4,2]] # Expected\n```\n\nAttempting to add a max/min ordering fails other test cases, it really looks like they're heavily funneling for a priority queue solution here."
                    },
                    {
                        "username": "scottjohn",
                        "content": "running into the same thing with a different test case"
                    },
                    {
                        "username": "tejasX",
                        "content": "Man. It was Hard!"
                    },
                    {
                        "username": "hughloganellis",
                        "content": "If you're stuck mentally thinking about two pointers and can't figure out how to get to the answer- here'a a hint:\n\nEach time you can either take a step down nums1 or nums2, a bit like traversing a binary tree\nWhat's the best type of search to traverse a tree without going to the end of each branch?\nRemember to make sure you don't visit the same node twice!"
                    },
                    {
                        "username": "psionl0",
                        "content": "What appeared to be a relatively easy problem turned out to need a priority queue to keep track of the minimum sums AND a hash table to avoid duplicating results.\\nNot overly difficult but you won\\'t solve it if you are unfamiliar with priority queues and hash tables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "did it using binary search , sigh"
                    },
                    {
                        "username": "parasmn4",
                        "content": "First thought that it can be solved using two pointers but realized that it will not consider all the pairs.\\n\\nThen solved it using Max heap taking in all pairs in O(N*M*LogK) but got TLE.\\n\\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Strict way to solve:\\n\\n1. We need function F to find how many pairs with sum less than given value. Use two pointers and there will be O(n+m) time complexity.\\n\\n2. You should find the exact Value. Condition: F(Value) <= k < F(Value+1). For this you will use binary search. It needs maximum log(4 * 1e9) = 34 iterations. So, it is just huge constant value and does not depend on input size.\\n\\n3. With two pointers collect all pairs with sum less than Value. And add some pairs with sum equal to Value if it is needed. Time complexity O(k + n + m).\\n\\nSo, overall time complexity is O(k + n + m);\\nAs result: this solution beats 99% other solutions by time and 95% by memory."
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Priority queue & heap on back-to-back days \\uD83D\\uDD25"
                    },
                    {
                        "username": "srekhi",
                        "content": "Let's take two arrays:\\n[1,7,11] and [2,4,30]. What's wrong with having a pointer at 1 and 2, then at each iteration comparing, for example, (1,4) vs. (7,2). If 1,4 greater than 7,2, we can them compare (1,30) vs 7,2 and continue like this k times?"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "I tried this approach at first but the problem is once you\\'ve chosen to increment the pointers you can\\'t go back. You won\\'t iterate through all possible pairs, only a subset. But I only tried with one pointer for each array, not two like you suggested. So maybe there\\'s a way to make that work?"
                    }
                ]
            },
            {
                "id": 1946375,
                "content": [
                    {
                        "username": "Chaitanya333",
                        "content": "n is length of 1st arr\\nm is length of 2nd arr\\nIf I use the heap solution.. Then is it  n*m log (n*m)\\nbecause I have to put all the pairs into heap and then pop all"
                    },
                    {
                        "username": "Raj_Amrit",
                        "content": "[@pkorobov](/pkorobov) If there are a possible of nm pairs you cannot keep a heap size of only n (or m). Also k in worst case can be equal to nm. So OP\\'s reasoning is valid imo."
                    },
                    {
                        "username": "pkorobov",
                        "content": "Actually, no.\n\nMost solutions keep heap size of n (or m, doesn't matter). And you have k <= mn operations during the loop.\n\nSo that is O(n + k * log(n)), where the first term is from heap construction based on [nums1[i] + nums2[0] for i in range(len(nums1))], and the second is from k pop and insert operations."
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Why does order within the pairs matter for this?  \n\nWith this code:\n ```python\n        res = []\n        while nums1 and nums2:\n            a, b = nums1, nums2\n            if a[0] > b[0]:\n                b, a = a, b\n            for i in range(len(b)):\n                res.append([a[0], b[i]])\n            \n            for i in range(1, len(a)):\n                res.append([a[i], b[0]])\n            \n            nums1 = nums1[1:]\n            nums2 = nums2[1:]\n        res.sort(key=sum)\n        return res[:min(k, len(res))]\n```\nFails:\n`nums1 = [1,2,4]`\n`nums2 = [-1,1,2]`\n`k = 100`\n\n```\n[[-1,1],[-1,2],[1,1],[-1,4],[2,1],[1,2],[2,2],[1,4],[2,4]] # Output\n[[1,-1],[2,-1],[1,1],[4,-1],[2,1],[1,2],[2,2],[4,1],[4,2]] # Expected\n```\n\nAttempting to add a max/min ordering fails other test cases, it really looks like they're heavily funneling for a priority queue solution here."
                    },
                    {
                        "username": "scottjohn",
                        "content": "running into the same thing with a different test case"
                    },
                    {
                        "username": "tejasX",
                        "content": "Man. It was Hard!"
                    },
                    {
                        "username": "hughloganellis",
                        "content": "If you're stuck mentally thinking about two pointers and can't figure out how to get to the answer- here'a a hint:\n\nEach time you can either take a step down nums1 or nums2, a bit like traversing a binary tree\nWhat's the best type of search to traverse a tree without going to the end of each branch?\nRemember to make sure you don't visit the same node twice!"
                    },
                    {
                        "username": "psionl0",
                        "content": "What appeared to be a relatively easy problem turned out to need a priority queue to keep track of the minimum sums AND a hash table to avoid duplicating results.\\nNot overly difficult but you won\\'t solve it if you are unfamiliar with priority queues and hash tables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "did it using binary search , sigh"
                    },
                    {
                        "username": "parasmn4",
                        "content": "First thought that it can be solved using two pointers but realized that it will not consider all the pairs.\\n\\nThen solved it using Max heap taking in all pairs in O(N*M*LogK) but got TLE.\\n\\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Strict way to solve:\\n\\n1. We need function F to find how many pairs with sum less than given value. Use two pointers and there will be O(n+m) time complexity.\\n\\n2. You should find the exact Value. Condition: F(Value) <= k < F(Value+1). For this you will use binary search. It needs maximum log(4 * 1e9) = 34 iterations. So, it is just huge constant value and does not depend on input size.\\n\\n3. With two pointers collect all pairs with sum less than Value. And add some pairs with sum equal to Value if it is needed. Time complexity O(k + n + m).\\n\\nSo, overall time complexity is O(k + n + m);\\nAs result: this solution beats 99% other solutions by time and 95% by memory."
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Priority queue & heap on back-to-back days \\uD83D\\uDD25"
                    },
                    {
                        "username": "srekhi",
                        "content": "Let's take two arrays:\\n[1,7,11] and [2,4,30]. What's wrong with having a pointer at 1 and 2, then at each iteration comparing, for example, (1,4) vs. (7,2). If 1,4 greater than 7,2, we can them compare (1,30) vs 7,2 and continue like this k times?"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "I tried this approach at first but the problem is once you\\'ve chosen to increment the pointers you can\\'t go back. You won\\'t iterate through all possible pairs, only a subset. But I only tried with one pointer for each array, not two like you suggested. So maybe there\\'s a way to make that work?"
                    }
                ]
            },
            {
                "id": 1946263,
                "content": [
                    {
                        "username": "Chaitanya333",
                        "content": "n is length of 1st arr\\nm is length of 2nd arr\\nIf I use the heap solution.. Then is it  n*m log (n*m)\\nbecause I have to put all the pairs into heap and then pop all"
                    },
                    {
                        "username": "Raj_Amrit",
                        "content": "[@pkorobov](/pkorobov) If there are a possible of nm pairs you cannot keep a heap size of only n (or m). Also k in worst case can be equal to nm. So OP\\'s reasoning is valid imo."
                    },
                    {
                        "username": "pkorobov",
                        "content": "Actually, no.\n\nMost solutions keep heap size of n (or m, doesn't matter). And you have k <= mn operations during the loop.\n\nSo that is O(n + k * log(n)), where the first term is from heap construction based on [nums1[i] + nums2[0] for i in range(len(nums1))], and the second is from k pop and insert operations."
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Why does order within the pairs matter for this?  \n\nWith this code:\n ```python\n        res = []\n        while nums1 and nums2:\n            a, b = nums1, nums2\n            if a[0] > b[0]:\n                b, a = a, b\n            for i in range(len(b)):\n                res.append([a[0], b[i]])\n            \n            for i in range(1, len(a)):\n                res.append([a[i], b[0]])\n            \n            nums1 = nums1[1:]\n            nums2 = nums2[1:]\n        res.sort(key=sum)\n        return res[:min(k, len(res))]\n```\nFails:\n`nums1 = [1,2,4]`\n`nums2 = [-1,1,2]`\n`k = 100`\n\n```\n[[-1,1],[-1,2],[1,1],[-1,4],[2,1],[1,2],[2,2],[1,4],[2,4]] # Output\n[[1,-1],[2,-1],[1,1],[4,-1],[2,1],[1,2],[2,2],[4,1],[4,2]] # Expected\n```\n\nAttempting to add a max/min ordering fails other test cases, it really looks like they're heavily funneling for a priority queue solution here."
                    },
                    {
                        "username": "scottjohn",
                        "content": "running into the same thing with a different test case"
                    },
                    {
                        "username": "tejasX",
                        "content": "Man. It was Hard!"
                    },
                    {
                        "username": "hughloganellis",
                        "content": "If you're stuck mentally thinking about two pointers and can't figure out how to get to the answer- here'a a hint:\n\nEach time you can either take a step down nums1 or nums2, a bit like traversing a binary tree\nWhat's the best type of search to traverse a tree without going to the end of each branch?\nRemember to make sure you don't visit the same node twice!"
                    },
                    {
                        "username": "psionl0",
                        "content": "What appeared to be a relatively easy problem turned out to need a priority queue to keep track of the minimum sums AND a hash table to avoid duplicating results.\\nNot overly difficult but you won\\'t solve it if you are unfamiliar with priority queues and hash tables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "did it using binary search , sigh"
                    },
                    {
                        "username": "parasmn4",
                        "content": "First thought that it can be solved using two pointers but realized that it will not consider all the pairs.\\n\\nThen solved it using Max heap taking in all pairs in O(N*M*LogK) but got TLE.\\n\\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Strict way to solve:\\n\\n1. We need function F to find how many pairs with sum less than given value. Use two pointers and there will be O(n+m) time complexity.\\n\\n2. You should find the exact Value. Condition: F(Value) <= k < F(Value+1). For this you will use binary search. It needs maximum log(4 * 1e9) = 34 iterations. So, it is just huge constant value and does not depend on input size.\\n\\n3. With two pointers collect all pairs with sum less than Value. And add some pairs with sum equal to Value if it is needed. Time complexity O(k + n + m).\\n\\nSo, overall time complexity is O(k + n + m);\\nAs result: this solution beats 99% other solutions by time and 95% by memory."
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Priority queue & heap on back-to-back days \\uD83D\\uDD25"
                    },
                    {
                        "username": "srekhi",
                        "content": "Let's take two arrays:\\n[1,7,11] and [2,4,30]. What's wrong with having a pointer at 1 and 2, then at each iteration comparing, for example, (1,4) vs. (7,2). If 1,4 greater than 7,2, we can them compare (1,30) vs 7,2 and continue like this k times?"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "I tried this approach at first but the problem is once you\\'ve chosen to increment the pointers you can\\'t go back. You won\\'t iterate through all possible pairs, only a subset. But I only tried with one pointer for each array, not two like you suggested. So maybe there\\'s a way to make that work?"
                    }
                ]
            },
            {
                "id": 1921108,
                "content": [
                    {
                        "username": "Chaitanya333",
                        "content": "n is length of 1st arr\\nm is length of 2nd arr\\nIf I use the heap solution.. Then is it  n*m log (n*m)\\nbecause I have to put all the pairs into heap and then pop all"
                    },
                    {
                        "username": "Raj_Amrit",
                        "content": "[@pkorobov](/pkorobov) If there are a possible of nm pairs you cannot keep a heap size of only n (or m). Also k in worst case can be equal to nm. So OP\\'s reasoning is valid imo."
                    },
                    {
                        "username": "pkorobov",
                        "content": "Actually, no.\n\nMost solutions keep heap size of n (or m, doesn't matter). And you have k <= mn operations during the loop.\n\nSo that is O(n + k * log(n)), where the first term is from heap construction based on [nums1[i] + nums2[0] for i in range(len(nums1))], and the second is from k pop and insert operations."
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Why does order within the pairs matter for this?  \n\nWith this code:\n ```python\n        res = []\n        while nums1 and nums2:\n            a, b = nums1, nums2\n            if a[0] > b[0]:\n                b, a = a, b\n            for i in range(len(b)):\n                res.append([a[0], b[i]])\n            \n            for i in range(1, len(a)):\n                res.append([a[i], b[0]])\n            \n            nums1 = nums1[1:]\n            nums2 = nums2[1:]\n        res.sort(key=sum)\n        return res[:min(k, len(res))]\n```\nFails:\n`nums1 = [1,2,4]`\n`nums2 = [-1,1,2]`\n`k = 100`\n\n```\n[[-1,1],[-1,2],[1,1],[-1,4],[2,1],[1,2],[2,2],[1,4],[2,4]] # Output\n[[1,-1],[2,-1],[1,1],[4,-1],[2,1],[1,2],[2,2],[4,1],[4,2]] # Expected\n```\n\nAttempting to add a max/min ordering fails other test cases, it really looks like they're heavily funneling for a priority queue solution here."
                    },
                    {
                        "username": "scottjohn",
                        "content": "running into the same thing with a different test case"
                    },
                    {
                        "username": "tejasX",
                        "content": "Man. It was Hard!"
                    },
                    {
                        "username": "hughloganellis",
                        "content": "If you're stuck mentally thinking about two pointers and can't figure out how to get to the answer- here'a a hint:\n\nEach time you can either take a step down nums1 or nums2, a bit like traversing a binary tree\nWhat's the best type of search to traverse a tree without going to the end of each branch?\nRemember to make sure you don't visit the same node twice!"
                    },
                    {
                        "username": "psionl0",
                        "content": "What appeared to be a relatively easy problem turned out to need a priority queue to keep track of the minimum sums AND a hash table to avoid duplicating results.\\nNot overly difficult but you won\\'t solve it if you are unfamiliar with priority queues and hash tables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "did it using binary search , sigh"
                    },
                    {
                        "username": "parasmn4",
                        "content": "First thought that it can be solved using two pointers but realized that it will not consider all the pairs.\\n\\nThen solved it using Max heap taking in all pairs in O(N*M*LogK) but got TLE.\\n\\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Strict way to solve:\\n\\n1. We need function F to find how many pairs with sum less than given value. Use two pointers and there will be O(n+m) time complexity.\\n\\n2. You should find the exact Value. Condition: F(Value) <= k < F(Value+1). For this you will use binary search. It needs maximum log(4 * 1e9) = 34 iterations. So, it is just huge constant value and does not depend on input size.\\n\\n3. With two pointers collect all pairs with sum less than Value. And add some pairs with sum equal to Value if it is needed. Time complexity O(k + n + m).\\n\\nSo, overall time complexity is O(k + n + m);\\nAs result: this solution beats 99% other solutions by time and 95% by memory."
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Priority queue & heap on back-to-back days \\uD83D\\uDD25"
                    },
                    {
                        "username": "srekhi",
                        "content": "Let's take two arrays:\\n[1,7,11] and [2,4,30]. What's wrong with having a pointer at 1 and 2, then at each iteration comparing, for example, (1,4) vs. (7,2). If 1,4 greater than 7,2, we can them compare (1,30) vs 7,2 and continue like this k times?"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "I tried this approach at first but the problem is once you\\'ve chosen to increment the pointers you can\\'t go back. You won\\'t iterate through all possible pairs, only a subset. But I only tried with one pointer for each array, not two like you suggested. So maybe there\\'s a way to make that work?"
                    }
                ]
            },
            {
                "id": 1946012,
                "content": [
                    {
                        "username": "Chaitanya333",
                        "content": "n is length of 1st arr\\nm is length of 2nd arr\\nIf I use the heap solution.. Then is it  n*m log (n*m)\\nbecause I have to put all the pairs into heap and then pop all"
                    },
                    {
                        "username": "Raj_Amrit",
                        "content": "[@pkorobov](/pkorobov) If there are a possible of nm pairs you cannot keep a heap size of only n (or m). Also k in worst case can be equal to nm. So OP\\'s reasoning is valid imo."
                    },
                    {
                        "username": "pkorobov",
                        "content": "Actually, no.\n\nMost solutions keep heap size of n (or m, doesn't matter). And you have k <= mn operations during the loop.\n\nSo that is O(n + k * log(n)), where the first term is from heap construction based on [nums1[i] + nums2[0] for i in range(len(nums1))], and the second is from k pop and insert operations."
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Why does order within the pairs matter for this?  \n\nWith this code:\n ```python\n        res = []\n        while nums1 and nums2:\n            a, b = nums1, nums2\n            if a[0] > b[0]:\n                b, a = a, b\n            for i in range(len(b)):\n                res.append([a[0], b[i]])\n            \n            for i in range(1, len(a)):\n                res.append([a[i], b[0]])\n            \n            nums1 = nums1[1:]\n            nums2 = nums2[1:]\n        res.sort(key=sum)\n        return res[:min(k, len(res))]\n```\nFails:\n`nums1 = [1,2,4]`\n`nums2 = [-1,1,2]`\n`k = 100`\n\n```\n[[-1,1],[-1,2],[1,1],[-1,4],[2,1],[1,2],[2,2],[1,4],[2,4]] # Output\n[[1,-1],[2,-1],[1,1],[4,-1],[2,1],[1,2],[2,2],[4,1],[4,2]] # Expected\n```\n\nAttempting to add a max/min ordering fails other test cases, it really looks like they're heavily funneling for a priority queue solution here."
                    },
                    {
                        "username": "scottjohn",
                        "content": "running into the same thing with a different test case"
                    },
                    {
                        "username": "tejasX",
                        "content": "Man. It was Hard!"
                    },
                    {
                        "username": "hughloganellis",
                        "content": "If you're stuck mentally thinking about two pointers and can't figure out how to get to the answer- here'a a hint:\n\nEach time you can either take a step down nums1 or nums2, a bit like traversing a binary tree\nWhat's the best type of search to traverse a tree without going to the end of each branch?\nRemember to make sure you don't visit the same node twice!"
                    },
                    {
                        "username": "psionl0",
                        "content": "What appeared to be a relatively easy problem turned out to need a priority queue to keep track of the minimum sums AND a hash table to avoid duplicating results.\\nNot overly difficult but you won\\'t solve it if you are unfamiliar with priority queues and hash tables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "did it using binary search , sigh"
                    },
                    {
                        "username": "parasmn4",
                        "content": "First thought that it can be solved using two pointers but realized that it will not consider all the pairs.\\n\\nThen solved it using Max heap taking in all pairs in O(N*M*LogK) but got TLE.\\n\\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Strict way to solve:\\n\\n1. We need function F to find how many pairs with sum less than given value. Use two pointers and there will be O(n+m) time complexity.\\n\\n2. You should find the exact Value. Condition: F(Value) <= k < F(Value+1). For this you will use binary search. It needs maximum log(4 * 1e9) = 34 iterations. So, it is just huge constant value and does not depend on input size.\\n\\n3. With two pointers collect all pairs with sum less than Value. And add some pairs with sum equal to Value if it is needed. Time complexity O(k + n + m).\\n\\nSo, overall time complexity is O(k + n + m);\\nAs result: this solution beats 99% other solutions by time and 95% by memory."
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Priority queue & heap on back-to-back days \\uD83D\\uDD25"
                    },
                    {
                        "username": "srekhi",
                        "content": "Let's take two arrays:\\n[1,7,11] and [2,4,30]. What's wrong with having a pointer at 1 and 2, then at each iteration comparing, for example, (1,4) vs. (7,2). If 1,4 greater than 7,2, we can them compare (1,30) vs 7,2 and continue like this k times?"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "I tried this approach at first but the problem is once you\\'ve chosen to increment the pointers you can\\'t go back. You won\\'t iterate through all possible pairs, only a subset. But I only tried with one pointer for each array, not two like you suggested. So maybe there\\'s a way to make that work?"
                    }
                ]
            },
            {
                "id": 1571643,
                "content": [
                    {
                        "username": "Chaitanya333",
                        "content": "n is length of 1st arr\\nm is length of 2nd arr\\nIf I use the heap solution.. Then is it  n*m log (n*m)\\nbecause I have to put all the pairs into heap and then pop all"
                    },
                    {
                        "username": "Raj_Amrit",
                        "content": "[@pkorobov](/pkorobov) If there are a possible of nm pairs you cannot keep a heap size of only n (or m). Also k in worst case can be equal to nm. So OP\\'s reasoning is valid imo."
                    },
                    {
                        "username": "pkorobov",
                        "content": "Actually, no.\n\nMost solutions keep heap size of n (or m, doesn't matter). And you have k <= mn operations during the loop.\n\nSo that is O(n + k * log(n)), where the first term is from heap construction based on [nums1[i] + nums2[0] for i in range(len(nums1))], and the second is from k pop and insert operations."
                    },
                    {
                        "username": "matthewjf1",
                        "content": "Why does order within the pairs matter for this?  \n\nWith this code:\n ```python\n        res = []\n        while nums1 and nums2:\n            a, b = nums1, nums2\n            if a[0] > b[0]:\n                b, a = a, b\n            for i in range(len(b)):\n                res.append([a[0], b[i]])\n            \n            for i in range(1, len(a)):\n                res.append([a[i], b[0]])\n            \n            nums1 = nums1[1:]\n            nums2 = nums2[1:]\n        res.sort(key=sum)\n        return res[:min(k, len(res))]\n```\nFails:\n`nums1 = [1,2,4]`\n`nums2 = [-1,1,2]`\n`k = 100`\n\n```\n[[-1,1],[-1,2],[1,1],[-1,4],[2,1],[1,2],[2,2],[1,4],[2,4]] # Output\n[[1,-1],[2,-1],[1,1],[4,-1],[2,1],[1,2],[2,2],[4,1],[4,2]] # Expected\n```\n\nAttempting to add a max/min ordering fails other test cases, it really looks like they're heavily funneling for a priority queue solution here."
                    },
                    {
                        "username": "scottjohn",
                        "content": "running into the same thing with a different test case"
                    },
                    {
                        "username": "tejasX",
                        "content": "Man. It was Hard!"
                    },
                    {
                        "username": "hughloganellis",
                        "content": "If you're stuck mentally thinking about two pointers and can't figure out how to get to the answer- here'a a hint:\n\nEach time you can either take a step down nums1 or nums2, a bit like traversing a binary tree\nWhat's the best type of search to traverse a tree without going to the end of each branch?\nRemember to make sure you don't visit the same node twice!"
                    },
                    {
                        "username": "psionl0",
                        "content": "What appeared to be a relatively easy problem turned out to need a priority queue to keep track of the minimum sums AND a hash table to avoid duplicating results.\\nNot overly difficult but you won\\'t solve it if you are unfamiliar with priority queues and hash tables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "did it using binary search , sigh"
                    },
                    {
                        "username": "parasmn4",
                        "content": "First thought that it can be solved using two pointers but realized that it will not consider all the pairs.\\n\\nThen solved it using Max heap taking in all pairs in O(N*M*LogK) but got TLE.\\n\\n"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "Strict way to solve:\\n\\n1. We need function F to find how many pairs with sum less than given value. Use two pointers and there will be O(n+m) time complexity.\\n\\n2. You should find the exact Value. Condition: F(Value) <= k < F(Value+1). For this you will use binary search. It needs maximum log(4 * 1e9) = 34 iterations. So, it is just huge constant value and does not depend on input size.\\n\\n3. With two pointers collect all pairs with sum less than Value. And add some pairs with sum equal to Value if it is needed. Time complexity O(k + n + m).\\n\\nSo, overall time complexity is O(k + n + m);\\nAs result: this solution beats 99% other solutions by time and 95% by memory."
                    },
                    {
                        "username": "JerExplosion",
                        "content": "Priority queue & heap on back-to-back days \\uD83D\\uDD25"
                    },
                    {
                        "username": "srekhi",
                        "content": "Let's take two arrays:\\n[1,7,11] and [2,4,30]. What's wrong with having a pointer at 1 and 2, then at each iteration comparing, for example, (1,4) vs. (7,2). If 1,4 greater than 7,2, we can them compare (1,30) vs 7,2 and continue like this k times?"
                    },
                    {
                        "username": "acrenwelge",
                        "content": "I tried this approach at first but the problem is once you\\'ve chosen to increment the pointers you can\\'t go back. You won\\'t iterate through all possible pairs, only a subset. But I only tried with one pointer for each array, not two like you suggested. So maybe there\\'s a way to make that work?"
                    }
                ]
            },
            {
                "id": 1947296,
                "content": [
                    {
                        "username": "Zefick",
                        "content": "This is the first problem that made me think that the code for checking a solution\\'s output must be much more complicated than the code for the solution itself."
                    },
                    {
                        "username": "xxossoo96",
                        "content": "woo... what happened this week"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem was hard for me to understand."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++,priority_queue(MIN HEAP) + SET.\\n\\n=====================\\n# Approach\\n\\n1. Create a min-heap priority queue named `pq` to store pairs. Each pair consists of the sum of two elements and the indices of those elements in `nums1` and `nums2`.\\n2. Create a set named `st` to keep track of visited pairs.\\n3. Push the first pair into the priority queue `pq`. The sum is calculated by adding the first elements from `nums1` and `nums2`, and the indices are set to (0, 0).\\n4. Create a 2D vector named `ans` to store the resulting pairs.\\n5. Get the sizes of `nums1` and `nums2` and assign them to `n1` and `n2`, respectively.\\n6. While `k` is greater than 0 and `pq` is not empty, do the following:\\n   - Extract the top pair from the priority queue `pq`.\\n   - Add a new pair to the `ans` vector, consisting of the elements from `nums1` and `nums2` at the corresponding indices.\\n   - If the next element from `nums1` (x1+1) is within the bounds of `nums1`, the next element from `nums2` (x2) is within the bounds of `nums2`, and the pair (x1+1, x2) has not been visited before, then:\\n     - Add the pair (x1+1, x2) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1+1, x2).\\n     - Push this new pair into the priority queue `pq`.\\n   - If the next element from `nums1` (x1) is within the bounds of `nums1`, the next element from `nums2` (x2+1) is within the bounds of `nums2`, and the pair (x1, x2+1) has not been visited before, then:\\n     - Add the pair (x1, x2+1) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1, x2+1).\\n     - Push this new pair into the priority queue `pq`.\\n   - Decrement `k` by 1.\\n7. Return the resulting vector `ans` containing the k smallest pairs.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(nlogn) \\n\\n- Space complexity:\\nO(n) in worst case.\\n-------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3687853/c-priority-queue-min-heap-set/\\n"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "why you post in discussion\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "these combinations problems always suck"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Are you calling this 'medium'? I spent 2 hours like hitting a brick wall, N-queens solved yesterday was just nothing in comparison to this."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "It\\'s preety obvious seems that Priority Queue will be used, but how ???\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "the priority queue using for manage the object which contains from sum two elements (from arrays nums1 and nums2) and it indexes.. queue ordered by min sum.."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "Correction in the question: Return Minimum(k , possible pairs)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "_if (`k` > `nums1.size` * `nums2.size`)_\\ni.e. `k` > no of possible pairs :\\nsimply return all the possible pairs (as suggested by example 3)."
                    },
                    {
                        "username": "philip0000000",
                        "content": "Hint:\nif you are going to use pq, do not use js. js pq is bad"
                    }
                ]
            },
            {
                "id": 1946680,
                "content": [
                    {
                        "username": "Zefick",
                        "content": "This is the first problem that made me think that the code for checking a solution\\'s output must be much more complicated than the code for the solution itself."
                    },
                    {
                        "username": "xxossoo96",
                        "content": "woo... what happened this week"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem was hard for me to understand."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++,priority_queue(MIN HEAP) + SET.\\n\\n=====================\\n# Approach\\n\\n1. Create a min-heap priority queue named `pq` to store pairs. Each pair consists of the sum of two elements and the indices of those elements in `nums1` and `nums2`.\\n2. Create a set named `st` to keep track of visited pairs.\\n3. Push the first pair into the priority queue `pq`. The sum is calculated by adding the first elements from `nums1` and `nums2`, and the indices are set to (0, 0).\\n4. Create a 2D vector named `ans` to store the resulting pairs.\\n5. Get the sizes of `nums1` and `nums2` and assign them to `n1` and `n2`, respectively.\\n6. While `k` is greater than 0 and `pq` is not empty, do the following:\\n   - Extract the top pair from the priority queue `pq`.\\n   - Add a new pair to the `ans` vector, consisting of the elements from `nums1` and `nums2` at the corresponding indices.\\n   - If the next element from `nums1` (x1+1) is within the bounds of `nums1`, the next element from `nums2` (x2) is within the bounds of `nums2`, and the pair (x1+1, x2) has not been visited before, then:\\n     - Add the pair (x1+1, x2) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1+1, x2).\\n     - Push this new pair into the priority queue `pq`.\\n   - If the next element from `nums1` (x1) is within the bounds of `nums1`, the next element from `nums2` (x2+1) is within the bounds of `nums2`, and the pair (x1, x2+1) has not been visited before, then:\\n     - Add the pair (x1, x2+1) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1, x2+1).\\n     - Push this new pair into the priority queue `pq`.\\n   - Decrement `k` by 1.\\n7. Return the resulting vector `ans` containing the k smallest pairs.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(nlogn) \\n\\n- Space complexity:\\nO(n) in worst case.\\n-------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3687853/c-priority-queue-min-heap-set/\\n"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "why you post in discussion\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "these combinations problems always suck"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Are you calling this 'medium'? I spent 2 hours like hitting a brick wall, N-queens solved yesterday was just nothing in comparison to this."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "It\\'s preety obvious seems that Priority Queue will be used, but how ???\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "the priority queue using for manage the object which contains from sum two elements (from arrays nums1 and nums2) and it indexes.. queue ordered by min sum.."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "Correction in the question: Return Minimum(k , possible pairs)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "_if (`k` > `nums1.size` * `nums2.size`)_\\ni.e. `k` > no of possible pairs :\\nsimply return all the possible pairs (as suggested by example 3)."
                    },
                    {
                        "username": "philip0000000",
                        "content": "Hint:\nif you are going to use pq, do not use js. js pq is bad"
                    }
                ]
            },
            {
                "id": 1946478,
                "content": [
                    {
                        "username": "Zefick",
                        "content": "This is the first problem that made me think that the code for checking a solution\\'s output must be much more complicated than the code for the solution itself."
                    },
                    {
                        "username": "xxossoo96",
                        "content": "woo... what happened this week"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem was hard for me to understand."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++,priority_queue(MIN HEAP) + SET.\\n\\n=====================\\n# Approach\\n\\n1. Create a min-heap priority queue named `pq` to store pairs. Each pair consists of the sum of two elements and the indices of those elements in `nums1` and `nums2`.\\n2. Create a set named `st` to keep track of visited pairs.\\n3. Push the first pair into the priority queue `pq`. The sum is calculated by adding the first elements from `nums1` and `nums2`, and the indices are set to (0, 0).\\n4. Create a 2D vector named `ans` to store the resulting pairs.\\n5. Get the sizes of `nums1` and `nums2` and assign them to `n1` and `n2`, respectively.\\n6. While `k` is greater than 0 and `pq` is not empty, do the following:\\n   - Extract the top pair from the priority queue `pq`.\\n   - Add a new pair to the `ans` vector, consisting of the elements from `nums1` and `nums2` at the corresponding indices.\\n   - If the next element from `nums1` (x1+1) is within the bounds of `nums1`, the next element from `nums2` (x2) is within the bounds of `nums2`, and the pair (x1+1, x2) has not been visited before, then:\\n     - Add the pair (x1+1, x2) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1+1, x2).\\n     - Push this new pair into the priority queue `pq`.\\n   - If the next element from `nums1` (x1) is within the bounds of `nums1`, the next element from `nums2` (x2+1) is within the bounds of `nums2`, and the pair (x1, x2+1) has not been visited before, then:\\n     - Add the pair (x1, x2+1) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1, x2+1).\\n     - Push this new pair into the priority queue `pq`.\\n   - Decrement `k` by 1.\\n7. Return the resulting vector `ans` containing the k smallest pairs.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(nlogn) \\n\\n- Space complexity:\\nO(n) in worst case.\\n-------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3687853/c-priority-queue-min-heap-set/\\n"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "why you post in discussion\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "these combinations problems always suck"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Are you calling this 'medium'? I spent 2 hours like hitting a brick wall, N-queens solved yesterday was just nothing in comparison to this."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "It\\'s preety obvious seems that Priority Queue will be used, but how ???\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "the priority queue using for manage the object which contains from sum two elements (from arrays nums1 and nums2) and it indexes.. queue ordered by min sum.."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "Correction in the question: Return Minimum(k , possible pairs)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "_if (`k` > `nums1.size` * `nums2.size`)_\\ni.e. `k` > no of possible pairs :\\nsimply return all the possible pairs (as suggested by example 3)."
                    },
                    {
                        "username": "philip0000000",
                        "content": "Hint:\nif you are going to use pq, do not use js. js pq is bad"
                    }
                ]
            },
            {
                "id": 1946386,
                "content": [
                    {
                        "username": "Zefick",
                        "content": "This is the first problem that made me think that the code for checking a solution\\'s output must be much more complicated than the code for the solution itself."
                    },
                    {
                        "username": "xxossoo96",
                        "content": "woo... what happened this week"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem was hard for me to understand."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++,priority_queue(MIN HEAP) + SET.\\n\\n=====================\\n# Approach\\n\\n1. Create a min-heap priority queue named `pq` to store pairs. Each pair consists of the sum of two elements and the indices of those elements in `nums1` and `nums2`.\\n2. Create a set named `st` to keep track of visited pairs.\\n3. Push the first pair into the priority queue `pq`. The sum is calculated by adding the first elements from `nums1` and `nums2`, and the indices are set to (0, 0).\\n4. Create a 2D vector named `ans` to store the resulting pairs.\\n5. Get the sizes of `nums1` and `nums2` and assign them to `n1` and `n2`, respectively.\\n6. While `k` is greater than 0 and `pq` is not empty, do the following:\\n   - Extract the top pair from the priority queue `pq`.\\n   - Add a new pair to the `ans` vector, consisting of the elements from `nums1` and `nums2` at the corresponding indices.\\n   - If the next element from `nums1` (x1+1) is within the bounds of `nums1`, the next element from `nums2` (x2) is within the bounds of `nums2`, and the pair (x1+1, x2) has not been visited before, then:\\n     - Add the pair (x1+1, x2) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1+1, x2).\\n     - Push this new pair into the priority queue `pq`.\\n   - If the next element from `nums1` (x1) is within the bounds of `nums1`, the next element from `nums2` (x2+1) is within the bounds of `nums2`, and the pair (x1, x2+1) has not been visited before, then:\\n     - Add the pair (x1, x2+1) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1, x2+1).\\n     - Push this new pair into the priority queue `pq`.\\n   - Decrement `k` by 1.\\n7. Return the resulting vector `ans` containing the k smallest pairs.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(nlogn) \\n\\n- Space complexity:\\nO(n) in worst case.\\n-------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3687853/c-priority-queue-min-heap-set/\\n"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "why you post in discussion\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "these combinations problems always suck"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Are you calling this 'medium'? I spent 2 hours like hitting a brick wall, N-queens solved yesterday was just nothing in comparison to this."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "It\\'s preety obvious seems that Priority Queue will be used, but how ???\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "the priority queue using for manage the object which contains from sum two elements (from arrays nums1 and nums2) and it indexes.. queue ordered by min sum.."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "Correction in the question: Return Minimum(k , possible pairs)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "_if (`k` > `nums1.size` * `nums2.size`)_\\ni.e. `k` > no of possible pairs :\\nsimply return all the possible pairs (as suggested by example 3)."
                    },
                    {
                        "username": "philip0000000",
                        "content": "Hint:\nif you are going to use pq, do not use js. js pq is bad"
                    }
                ]
            },
            {
                "id": 1946550,
                "content": [
                    {
                        "username": "Zefick",
                        "content": "This is the first problem that made me think that the code for checking a solution\\'s output must be much more complicated than the code for the solution itself."
                    },
                    {
                        "username": "xxossoo96",
                        "content": "woo... what happened this week"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem was hard for me to understand."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++,priority_queue(MIN HEAP) + SET.\\n\\n=====================\\n# Approach\\n\\n1. Create a min-heap priority queue named `pq` to store pairs. Each pair consists of the sum of two elements and the indices of those elements in `nums1` and `nums2`.\\n2. Create a set named `st` to keep track of visited pairs.\\n3. Push the first pair into the priority queue `pq`. The sum is calculated by adding the first elements from `nums1` and `nums2`, and the indices are set to (0, 0).\\n4. Create a 2D vector named `ans` to store the resulting pairs.\\n5. Get the sizes of `nums1` and `nums2` and assign them to `n1` and `n2`, respectively.\\n6. While `k` is greater than 0 and `pq` is not empty, do the following:\\n   - Extract the top pair from the priority queue `pq`.\\n   - Add a new pair to the `ans` vector, consisting of the elements from `nums1` and `nums2` at the corresponding indices.\\n   - If the next element from `nums1` (x1+1) is within the bounds of `nums1`, the next element from `nums2` (x2) is within the bounds of `nums2`, and the pair (x1+1, x2) has not been visited before, then:\\n     - Add the pair (x1+1, x2) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1+1, x2).\\n     - Push this new pair into the priority queue `pq`.\\n   - If the next element from `nums1` (x1) is within the bounds of `nums1`, the next element from `nums2` (x2+1) is within the bounds of `nums2`, and the pair (x1, x2+1) has not been visited before, then:\\n     - Add the pair (x1, x2+1) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1, x2+1).\\n     - Push this new pair into the priority queue `pq`.\\n   - Decrement `k` by 1.\\n7. Return the resulting vector `ans` containing the k smallest pairs.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(nlogn) \\n\\n- Space complexity:\\nO(n) in worst case.\\n-------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3687853/c-priority-queue-min-heap-set/\\n"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "why you post in discussion\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "these combinations problems always suck"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Are you calling this 'medium'? I spent 2 hours like hitting a brick wall, N-queens solved yesterday was just nothing in comparison to this."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "It\\'s preety obvious seems that Priority Queue will be used, but how ???\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "the priority queue using for manage the object which contains from sum two elements (from arrays nums1 and nums2) and it indexes.. queue ordered by min sum.."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "Correction in the question: Return Minimum(k , possible pairs)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "_if (`k` > `nums1.size` * `nums2.size`)_\\ni.e. `k` > no of possible pairs :\\nsimply return all the possible pairs (as suggested by example 3)."
                    },
                    {
                        "username": "philip0000000",
                        "content": "Hint:\nif you are going to use pq, do not use js. js pq is bad"
                    }
                ]
            },
            {
                "id": 2059109,
                "content": [
                    {
                        "username": "Zefick",
                        "content": "This is the first problem that made me think that the code for checking a solution\\'s output must be much more complicated than the code for the solution itself."
                    },
                    {
                        "username": "xxossoo96",
                        "content": "woo... what happened this week"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem was hard for me to understand."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++,priority_queue(MIN HEAP) + SET.\\n\\n=====================\\n# Approach\\n\\n1. Create a min-heap priority queue named `pq` to store pairs. Each pair consists of the sum of two elements and the indices of those elements in `nums1` and `nums2`.\\n2. Create a set named `st` to keep track of visited pairs.\\n3. Push the first pair into the priority queue `pq`. The sum is calculated by adding the first elements from `nums1` and `nums2`, and the indices are set to (0, 0).\\n4. Create a 2D vector named `ans` to store the resulting pairs.\\n5. Get the sizes of `nums1` and `nums2` and assign them to `n1` and `n2`, respectively.\\n6. While `k` is greater than 0 and `pq` is not empty, do the following:\\n   - Extract the top pair from the priority queue `pq`.\\n   - Add a new pair to the `ans` vector, consisting of the elements from `nums1` and `nums2` at the corresponding indices.\\n   - If the next element from `nums1` (x1+1) is within the bounds of `nums1`, the next element from `nums2` (x2) is within the bounds of `nums2`, and the pair (x1+1, x2) has not been visited before, then:\\n     - Add the pair (x1+1, x2) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1+1, x2).\\n     - Push this new pair into the priority queue `pq`.\\n   - If the next element from `nums1` (x1) is within the bounds of `nums1`, the next element from `nums2` (x2+1) is within the bounds of `nums2`, and the pair (x1, x2+1) has not been visited before, then:\\n     - Add the pair (x1, x2+1) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1, x2+1).\\n     - Push this new pair into the priority queue `pq`.\\n   - Decrement `k` by 1.\\n7. Return the resulting vector `ans` containing the k smallest pairs.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(nlogn) \\n\\n- Space complexity:\\nO(n) in worst case.\\n-------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3687853/c-priority-queue-min-heap-set/\\n"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "why you post in discussion\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "these combinations problems always suck"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Are you calling this 'medium'? I spent 2 hours like hitting a brick wall, N-queens solved yesterday was just nothing in comparison to this."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "It\\'s preety obvious seems that Priority Queue will be used, but how ???\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "the priority queue using for manage the object which contains from sum two elements (from arrays nums1 and nums2) and it indexes.. queue ordered by min sum.."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "Correction in the question: Return Minimum(k , possible pairs)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "_if (`k` > `nums1.size` * `nums2.size`)_\\ni.e. `k` > no of possible pairs :\\nsimply return all the possible pairs (as suggested by example 3)."
                    },
                    {
                        "username": "philip0000000",
                        "content": "Hint:\nif you are going to use pq, do not use js. js pq is bad"
                    }
                ]
            },
            {
                "id": 2037501,
                "content": [
                    {
                        "username": "Zefick",
                        "content": "This is the first problem that made me think that the code for checking a solution\\'s output must be much more complicated than the code for the solution itself."
                    },
                    {
                        "username": "xxossoo96",
                        "content": "woo... what happened this week"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem was hard for me to understand."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++,priority_queue(MIN HEAP) + SET.\\n\\n=====================\\n# Approach\\n\\n1. Create a min-heap priority queue named `pq` to store pairs. Each pair consists of the sum of two elements and the indices of those elements in `nums1` and `nums2`.\\n2. Create a set named `st` to keep track of visited pairs.\\n3. Push the first pair into the priority queue `pq`. The sum is calculated by adding the first elements from `nums1` and `nums2`, and the indices are set to (0, 0).\\n4. Create a 2D vector named `ans` to store the resulting pairs.\\n5. Get the sizes of `nums1` and `nums2` and assign them to `n1` and `n2`, respectively.\\n6. While `k` is greater than 0 and `pq` is not empty, do the following:\\n   - Extract the top pair from the priority queue `pq`.\\n   - Add a new pair to the `ans` vector, consisting of the elements from `nums1` and `nums2` at the corresponding indices.\\n   - If the next element from `nums1` (x1+1) is within the bounds of `nums1`, the next element from `nums2` (x2) is within the bounds of `nums2`, and the pair (x1+1, x2) has not been visited before, then:\\n     - Add the pair (x1+1, x2) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1+1, x2).\\n     - Push this new pair into the priority queue `pq`.\\n   - If the next element from `nums1` (x1) is within the bounds of `nums1`, the next element from `nums2` (x2+1) is within the bounds of `nums2`, and the pair (x1, x2+1) has not been visited before, then:\\n     - Add the pair (x1, x2+1) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1, x2+1).\\n     - Push this new pair into the priority queue `pq`.\\n   - Decrement `k` by 1.\\n7. Return the resulting vector `ans` containing the k smallest pairs.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(nlogn) \\n\\n- Space complexity:\\nO(n) in worst case.\\n-------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3687853/c-priority-queue-min-heap-set/\\n"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "why you post in discussion\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "these combinations problems always suck"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Are you calling this 'medium'? I spent 2 hours like hitting a brick wall, N-queens solved yesterday was just nothing in comparison to this."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "It\\'s preety obvious seems that Priority Queue will be used, but how ???\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "the priority queue using for manage the object which contains from sum two elements (from arrays nums1 and nums2) and it indexes.. queue ordered by min sum.."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "Correction in the question: Return Minimum(k , possible pairs)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "_if (`k` > `nums1.size` * `nums2.size`)_\\ni.e. `k` > no of possible pairs :\\nsimply return all the possible pairs (as suggested by example 3)."
                    },
                    {
                        "username": "philip0000000",
                        "content": "Hint:\nif you are going to use pq, do not use js. js pq is bad"
                    }
                ]
            },
            {
                "id": 2037498,
                "content": [
                    {
                        "username": "Zefick",
                        "content": "This is the first problem that made me think that the code for checking a solution\\'s output must be much more complicated than the code for the solution itself."
                    },
                    {
                        "username": "xxossoo96",
                        "content": "woo... what happened this week"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem was hard for me to understand."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++,priority_queue(MIN HEAP) + SET.\\n\\n=====================\\n# Approach\\n\\n1. Create a min-heap priority queue named `pq` to store pairs. Each pair consists of the sum of two elements and the indices of those elements in `nums1` and `nums2`.\\n2. Create a set named `st` to keep track of visited pairs.\\n3. Push the first pair into the priority queue `pq`. The sum is calculated by adding the first elements from `nums1` and `nums2`, and the indices are set to (0, 0).\\n4. Create a 2D vector named `ans` to store the resulting pairs.\\n5. Get the sizes of `nums1` and `nums2` and assign them to `n1` and `n2`, respectively.\\n6. While `k` is greater than 0 and `pq` is not empty, do the following:\\n   - Extract the top pair from the priority queue `pq`.\\n   - Add a new pair to the `ans` vector, consisting of the elements from `nums1` and `nums2` at the corresponding indices.\\n   - If the next element from `nums1` (x1+1) is within the bounds of `nums1`, the next element from `nums2` (x2) is within the bounds of `nums2`, and the pair (x1+1, x2) has not been visited before, then:\\n     - Add the pair (x1+1, x2) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1+1, x2).\\n     - Push this new pair into the priority queue `pq`.\\n   - If the next element from `nums1` (x1) is within the bounds of `nums1`, the next element from `nums2` (x2+1) is within the bounds of `nums2`, and the pair (x1, x2+1) has not been visited before, then:\\n     - Add the pair (x1, x2+1) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1, x2+1).\\n     - Push this new pair into the priority queue `pq`.\\n   - Decrement `k` by 1.\\n7. Return the resulting vector `ans` containing the k smallest pairs.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(nlogn) \\n\\n- Space complexity:\\nO(n) in worst case.\\n-------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3687853/c-priority-queue-min-heap-set/\\n"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "why you post in discussion\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "these combinations problems always suck"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Are you calling this 'medium'? I spent 2 hours like hitting a brick wall, N-queens solved yesterday was just nothing in comparison to this."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "It\\'s preety obvious seems that Priority Queue will be used, but how ???\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "the priority queue using for manage the object which contains from sum two elements (from arrays nums1 and nums2) and it indexes.. queue ordered by min sum.."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "Correction in the question: Return Minimum(k , possible pairs)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "_if (`k` > `nums1.size` * `nums2.size`)_\\ni.e. `k` > no of possible pairs :\\nsimply return all the possible pairs (as suggested by example 3)."
                    },
                    {
                        "username": "philip0000000",
                        "content": "Hint:\nif you are going to use pq, do not use js. js pq is bad"
                    }
                ]
            },
            {
                "id": 2007401,
                "content": [
                    {
                        "username": "Zefick",
                        "content": "This is the first problem that made me think that the code for checking a solution\\'s output must be much more complicated than the code for the solution itself."
                    },
                    {
                        "username": "xxossoo96",
                        "content": "woo... what happened this week"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem was hard for me to understand."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++,priority_queue(MIN HEAP) + SET.\\n\\n=====================\\n# Approach\\n\\n1. Create a min-heap priority queue named `pq` to store pairs. Each pair consists of the sum of two elements and the indices of those elements in `nums1` and `nums2`.\\n2. Create a set named `st` to keep track of visited pairs.\\n3. Push the first pair into the priority queue `pq`. The sum is calculated by adding the first elements from `nums1` and `nums2`, and the indices are set to (0, 0).\\n4. Create a 2D vector named `ans` to store the resulting pairs.\\n5. Get the sizes of `nums1` and `nums2` and assign them to `n1` and `n2`, respectively.\\n6. While `k` is greater than 0 and `pq` is not empty, do the following:\\n   - Extract the top pair from the priority queue `pq`.\\n   - Add a new pair to the `ans` vector, consisting of the elements from `nums1` and `nums2` at the corresponding indices.\\n   - If the next element from `nums1` (x1+1) is within the bounds of `nums1`, the next element from `nums2` (x2) is within the bounds of `nums2`, and the pair (x1+1, x2) has not been visited before, then:\\n     - Add the pair (x1+1, x2) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1+1, x2).\\n     - Push this new pair into the priority queue `pq`.\\n   - If the next element from `nums1` (x1) is within the bounds of `nums1`, the next element from `nums2` (x2+1) is within the bounds of `nums2`, and the pair (x1, x2+1) has not been visited before, then:\\n     - Add the pair (x1, x2+1) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1, x2+1).\\n     - Push this new pair into the priority queue `pq`.\\n   - Decrement `k` by 1.\\n7. Return the resulting vector `ans` containing the k smallest pairs.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(nlogn) \\n\\n- Space complexity:\\nO(n) in worst case.\\n-------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3687853/c-priority-queue-min-heap-set/\\n"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "why you post in discussion\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "these combinations problems always suck"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Are you calling this 'medium'? I spent 2 hours like hitting a brick wall, N-queens solved yesterday was just nothing in comparison to this."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "It\\'s preety obvious seems that Priority Queue will be used, but how ???\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "the priority queue using for manage the object which contains from sum two elements (from arrays nums1 and nums2) and it indexes.. queue ordered by min sum.."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "Correction in the question: Return Minimum(k , possible pairs)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "_if (`k` > `nums1.size` * `nums2.size`)_\\ni.e. `k` > no of possible pairs :\\nsimply return all the possible pairs (as suggested by example 3)."
                    },
                    {
                        "username": "philip0000000",
                        "content": "Hint:\nif you are going to use pq, do not use js. js pq is bad"
                    }
                ]
            },
            {
                "id": 1998599,
                "content": [
                    {
                        "username": "Zefick",
                        "content": "This is the first problem that made me think that the code for checking a solution\\'s output must be much more complicated than the code for the solution itself."
                    },
                    {
                        "username": "xxossoo96",
                        "content": "woo... what happened this week"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem was hard for me to understand."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++,priority_queue(MIN HEAP) + SET.\\n\\n=====================\\n# Approach\\n\\n1. Create a min-heap priority queue named `pq` to store pairs. Each pair consists of the sum of two elements and the indices of those elements in `nums1` and `nums2`.\\n2. Create a set named `st` to keep track of visited pairs.\\n3. Push the first pair into the priority queue `pq`. The sum is calculated by adding the first elements from `nums1` and `nums2`, and the indices are set to (0, 0).\\n4. Create a 2D vector named `ans` to store the resulting pairs.\\n5. Get the sizes of `nums1` and `nums2` and assign them to `n1` and `n2`, respectively.\\n6. While `k` is greater than 0 and `pq` is not empty, do the following:\\n   - Extract the top pair from the priority queue `pq`.\\n   - Add a new pair to the `ans` vector, consisting of the elements from `nums1` and `nums2` at the corresponding indices.\\n   - If the next element from `nums1` (x1+1) is within the bounds of `nums1`, the next element from `nums2` (x2) is within the bounds of `nums2`, and the pair (x1+1, x2) has not been visited before, then:\\n     - Add the pair (x1+1, x2) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1+1, x2).\\n     - Push this new pair into the priority queue `pq`.\\n   - If the next element from `nums1` (x1) is within the bounds of `nums1`, the next element from `nums2` (x2+1) is within the bounds of `nums2`, and the pair (x1, x2+1) has not been visited before, then:\\n     - Add the pair (x1, x2+1) to the set `st`.\\n     - Calculate the sum by adding the elements from `nums1` and `nums2` at indices (x1, x2+1).\\n     - Push this new pair into the priority queue `pq`.\\n   - Decrement `k` by 1.\\n7. Return the resulting vector `ans` containing the k smallest pairs.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(nlogn) \\n\\n- Space complexity:\\nO(n) in worst case.\\n-------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3687853/c-priority-queue-min-heap-set/\\n"
                    },
                    {
                        "username": "koushikjavvaji2004",
                        "content": "why you post in discussion\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "these combinations problems always suck"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Are you calling this 'medium'? I spent 2 hours like hitting a brick wall, N-queens solved yesterday was just nothing in comparison to this."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "It\\'s preety obvious seems that Priority Queue will be used, but how ???\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "the priority queue using for manage the object which contains from sum two elements (from arrays nums1 and nums2) and it indexes.. queue ordered by min sum.."
                    },
                    {
                        "username": "HimanshuShekhar18",
                        "content": "Correction in the question: Return Minimum(k , possible pairs)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "_if (`k` > `nums1.size` * `nums2.size`)_\\ni.e. `k` > no of possible pairs :\\nsimply return all the possible pairs (as suggested by example 3)."
                    },
                    {
                        "username": "philip0000000",
                        "content": "Hint:\nif you are going to use pq, do not use js. js pq is bad"
                    }
                ]
            },
            {
                "id": 1976901,
                "content": [
                    {
                        "username": "harmonicfunc",
                        "content": "is it bfs with priority queue??\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "I made my solution on priority queue, it\\'s simple way but not quick."
                    },
                    {
                        "username": "gajss",
                        "content": "For those wondering how it can be solved using a max heap(or pq), the output pairs don't need to be ordered by sum. So if sum(u2, v2) > sum(u1, v1), output can be [{u2, v2}, {u1, v1}], i.e. it need not be [{u1,v1}, {u2,v2}]."
                    },
                    {
                        "username": "seeker_747",
                        "content": "my first intiution was using two pointers.........then solved it using heap \\n"
                    },
                    {
                        "username": "rudoy",
                        "content": "I almost give up my June strike with this problem, but found a solution without Heap. However I have to learn how to use Heap properly. I\\'m sure that my solution can be significantly speed up if I\\'ll use insertion in sorted array instead of append new element as the last and sorting after. Will revise June\\'s problems for solving them more optimal"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "1) The smallest sum will be formed by index 0 of nums1 and index 0 of nums2. \n2) The next smaller sum will be either from {index 0 of nums1 and index1 of nums2} or {index 1 of nums1 and index 0 of nums2}. \n\n\n\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i would probably fail this in an interview ... the O(klgk) is tricky, but O(N^2lgk) is not "
                    },
                    {
                        "username": "kumawatashok1815",
                        "content": "can anyone tell me the what wrong with this solution .\\n\\n\\n\\n//MY OUTPUT :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[-4,7],[0,3],[0,3]]\\n//Expected :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[0,3],[0,3]]\\n\\n\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n\\n        Map<Integer,List<Integer> > map = new TreeMap<>();\\n        List<List<Integer>>finalResult = new ArrayList<>();\\n\\n        for(int i=0;i<num1.length;i++)\\n        { \\n            for(int j=0;j<num2.length;j++)\\n            {\\n                int sum = num1[i]+num2[j];\\n                List<Integer> l1 = new ArrayList<>();\\n                l1.add(num1[i]);\\n                l1.add(num2[j]);\\n                if(map.containsKey(sum))\\n                {\\n                    List<Integer> l2 = map.get(sum);\\n                    l2.addAll(l1);\\n                    map.put(sum,l2);\\n\\n                }\\n                else\\n                {\\n                   map.put(sum,l1);\\n                }\\n               \\n\\n            }\\n        }\\n\\n        int counter=0;\\n\\n        for(Integer key : map.keySet())\\n        {\\n            if(counter<k)\\n            {\\n               \\n                List<Integer> l1 = map.get(key);\\n                for(int i=0;i<l1.size();i+=2)\\n                {\\n                    List<Integer> l2 = new ArrayList<>();\\n                    l2.add(l1.get(i));\\n                    l2.add(l1.get(i+1));\\n                    finalResult.add(l2);    \\n                    counter++;\\n                    \\n                }\\n             \\n                \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return finalResult;\\n        \\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The logic of your code is almost correct, but you need to consider that in your case you\\'re creating one pair every two numbers, but the map does not have a limit per key. This means that for each sum, you\\'re trying to put as many pairs as there are in the cross product of the two input arrays that sum to that key. \\n\\nThis can cause issues if, for instance, there are many pairs that have the same sum. In your case, the `counter` could increment more than once within the inner `for` loop because the `if(counter<k)` condition is checked only at the beginning of each key in your map. As a result, you might end up adding more than `k` pairs to your `finalResult`.\\n\\nTo fix this, you should check if you\\'ve added `k` pairs after adding each pair, not after adding all pairs of a specific sum. If `counter` is equal to `k`, you should break from both loops.\\n\\nHere\\'s a corrected version of your code:\\n\\n```java\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n    Map<Integer,List<Integer>> map = new TreeMap<>();\\n    List<List<Integer>>finalResult = new ArrayList<>();\\n\\n    for(int i=0;i<num1.length;i++) {\\n        for(int j=0;j<num2.length;j++) {\\n            int sum = num1[i]+num2[j];\\n            List<Integer> l1 = new ArrayList<>();\\n            l1.add(num1[i]);\\n            l1.add(num2[j]);\\n            map.putIfAbsent(sum, new ArrayList<>());\\n            map.get(sum).addAll(l1);\\n        }\\n    }\\n\\n    int counter=0;\\n    outer: \\n    for(Integer key : map.keySet()) {\\n        List<Integer> l1 = map.get(key);\\n        for(int i=0;i<l1.size();i+=2) {\\n            List<Integer> l2 = new ArrayList<>();\\n            l2.add(l1.get(i));\\n            l2.add(l1.get(i+1));\\n            finalResult.add(l2);\\n            counter++;\\n            if(counter==k)\\n                break outer;\\n        }\\n    }\\n\\n    return finalResult;\\n}\\n```\\n\\nIn the corrected code, I added the `outer:` label and the `break outer;` statement to exit both loops once `k` pairs have been added to `finalResult`.\\n\\nThis solution can solve the problem, but it might not be the most efficient one. There\\'s an alternative way to solve this problem by using a priority queue, which can have a better time complexity. This approach avoids storing all pairs and only maintains the smallest pairs, which is a more efficient use of memory."
                    },
                    {
                        "username": "sikora92",
                        "content": "Isn\\'t there some bug in test case 35? It tells my solution returns empty List, but I cannot reproduce it in my IDE."
                    },
                    {
                        "username": "sikora92",
                        "content": "Just nums1.length*nums2.length is bigger than integer range. Remember to use long. "
                    },
                    {
                        "username": "loloksEth",
                        "content": "2 ptr working there"
                    },
                    {
                        "username": "Nayanthara_P",
                        "content": "What is the 14th test case? For me, the test cases 13/35 pass without errors, but for the 14th one I don\\'t understand why I get the following error:\\n\\nnums1 =\\n[1,1,2]\\nnums2 =\\n[1,2,3]\\nk =\\n10\\nUse Testcase\\nOutput\\n[[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,2],[2,3]]\\nExpected\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy between your output and the expected output can be seen at the 5th pair. In the expected output, the 5th pair is [1,2], but in your output, the 5th pair is [2,1]. This is likely due to a difference in the order in which your program is processing the pairs. In this problem, the order of the pairs matters - [2,1] is not equivalent to [1,2] because 2 from nums1 and 1 from nums2 would be a greater sum than 1 from nums1 and 2 from nums2.\\n\\nYou might want to review your implementation to ensure that it is processing the pairs in the correct order"
                    },
                    {
                        "username": "xmmmir",
                        "content": "You\\'re somehow getting 10 pairs out of 3x3 matrix. [2,2] is duplicated."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "share the code please"
                    }
                ]
            },
            {
                "id": 1960593,
                "content": [
                    {
                        "username": "harmonicfunc",
                        "content": "is it bfs with priority queue??\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "I made my solution on priority queue, it\\'s simple way but not quick."
                    },
                    {
                        "username": "gajss",
                        "content": "For those wondering how it can be solved using a max heap(or pq), the output pairs don't need to be ordered by sum. So if sum(u2, v2) > sum(u1, v1), output can be [{u2, v2}, {u1, v1}], i.e. it need not be [{u1,v1}, {u2,v2}]."
                    },
                    {
                        "username": "seeker_747",
                        "content": "my first intiution was using two pointers.........then solved it using heap \\n"
                    },
                    {
                        "username": "rudoy",
                        "content": "I almost give up my June strike with this problem, but found a solution without Heap. However I have to learn how to use Heap properly. I\\'m sure that my solution can be significantly speed up if I\\'ll use insertion in sorted array instead of append new element as the last and sorting after. Will revise June\\'s problems for solving them more optimal"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "1) The smallest sum will be formed by index 0 of nums1 and index 0 of nums2. \n2) The next smaller sum will be either from {index 0 of nums1 and index1 of nums2} or {index 1 of nums1 and index 0 of nums2}. \n\n\n\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i would probably fail this in an interview ... the O(klgk) is tricky, but O(N^2lgk) is not "
                    },
                    {
                        "username": "kumawatashok1815",
                        "content": "can anyone tell me the what wrong with this solution .\\n\\n\\n\\n//MY OUTPUT :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[-4,7],[0,3],[0,3]]\\n//Expected :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[0,3],[0,3]]\\n\\n\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n\\n        Map<Integer,List<Integer> > map = new TreeMap<>();\\n        List<List<Integer>>finalResult = new ArrayList<>();\\n\\n        for(int i=0;i<num1.length;i++)\\n        { \\n            for(int j=0;j<num2.length;j++)\\n            {\\n                int sum = num1[i]+num2[j];\\n                List<Integer> l1 = new ArrayList<>();\\n                l1.add(num1[i]);\\n                l1.add(num2[j]);\\n                if(map.containsKey(sum))\\n                {\\n                    List<Integer> l2 = map.get(sum);\\n                    l2.addAll(l1);\\n                    map.put(sum,l2);\\n\\n                }\\n                else\\n                {\\n                   map.put(sum,l1);\\n                }\\n               \\n\\n            }\\n        }\\n\\n        int counter=0;\\n\\n        for(Integer key : map.keySet())\\n        {\\n            if(counter<k)\\n            {\\n               \\n                List<Integer> l1 = map.get(key);\\n                for(int i=0;i<l1.size();i+=2)\\n                {\\n                    List<Integer> l2 = new ArrayList<>();\\n                    l2.add(l1.get(i));\\n                    l2.add(l1.get(i+1));\\n                    finalResult.add(l2);    \\n                    counter++;\\n                    \\n                }\\n             \\n                \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return finalResult;\\n        \\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The logic of your code is almost correct, but you need to consider that in your case you\\'re creating one pair every two numbers, but the map does not have a limit per key. This means that for each sum, you\\'re trying to put as many pairs as there are in the cross product of the two input arrays that sum to that key. \\n\\nThis can cause issues if, for instance, there are many pairs that have the same sum. In your case, the `counter` could increment more than once within the inner `for` loop because the `if(counter<k)` condition is checked only at the beginning of each key in your map. As a result, you might end up adding more than `k` pairs to your `finalResult`.\\n\\nTo fix this, you should check if you\\'ve added `k` pairs after adding each pair, not after adding all pairs of a specific sum. If `counter` is equal to `k`, you should break from both loops.\\n\\nHere\\'s a corrected version of your code:\\n\\n```java\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n    Map<Integer,List<Integer>> map = new TreeMap<>();\\n    List<List<Integer>>finalResult = new ArrayList<>();\\n\\n    for(int i=0;i<num1.length;i++) {\\n        for(int j=0;j<num2.length;j++) {\\n            int sum = num1[i]+num2[j];\\n            List<Integer> l1 = new ArrayList<>();\\n            l1.add(num1[i]);\\n            l1.add(num2[j]);\\n            map.putIfAbsent(sum, new ArrayList<>());\\n            map.get(sum).addAll(l1);\\n        }\\n    }\\n\\n    int counter=0;\\n    outer: \\n    for(Integer key : map.keySet()) {\\n        List<Integer> l1 = map.get(key);\\n        for(int i=0;i<l1.size();i+=2) {\\n            List<Integer> l2 = new ArrayList<>();\\n            l2.add(l1.get(i));\\n            l2.add(l1.get(i+1));\\n            finalResult.add(l2);\\n            counter++;\\n            if(counter==k)\\n                break outer;\\n        }\\n    }\\n\\n    return finalResult;\\n}\\n```\\n\\nIn the corrected code, I added the `outer:` label and the `break outer;` statement to exit both loops once `k` pairs have been added to `finalResult`.\\n\\nThis solution can solve the problem, but it might not be the most efficient one. There\\'s an alternative way to solve this problem by using a priority queue, which can have a better time complexity. This approach avoids storing all pairs and only maintains the smallest pairs, which is a more efficient use of memory."
                    },
                    {
                        "username": "sikora92",
                        "content": "Isn\\'t there some bug in test case 35? It tells my solution returns empty List, but I cannot reproduce it in my IDE."
                    },
                    {
                        "username": "sikora92",
                        "content": "Just nums1.length*nums2.length is bigger than integer range. Remember to use long. "
                    },
                    {
                        "username": "loloksEth",
                        "content": "2 ptr working there"
                    },
                    {
                        "username": "Nayanthara_P",
                        "content": "What is the 14th test case? For me, the test cases 13/35 pass without errors, but for the 14th one I don\\'t understand why I get the following error:\\n\\nnums1 =\\n[1,1,2]\\nnums2 =\\n[1,2,3]\\nk =\\n10\\nUse Testcase\\nOutput\\n[[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,2],[2,3]]\\nExpected\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy between your output and the expected output can be seen at the 5th pair. In the expected output, the 5th pair is [1,2], but in your output, the 5th pair is [2,1]. This is likely due to a difference in the order in which your program is processing the pairs. In this problem, the order of the pairs matters - [2,1] is not equivalent to [1,2] because 2 from nums1 and 1 from nums2 would be a greater sum than 1 from nums1 and 2 from nums2.\\n\\nYou might want to review your implementation to ensure that it is processing the pairs in the correct order"
                    },
                    {
                        "username": "xmmmir",
                        "content": "You\\'re somehow getting 10 pairs out of 3x3 matrix. [2,2] is duplicated."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "share the code please"
                    }
                ]
            },
            {
                "id": 1947265,
                "content": [
                    {
                        "username": "harmonicfunc",
                        "content": "is it bfs with priority queue??\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "I made my solution on priority queue, it\\'s simple way but not quick."
                    },
                    {
                        "username": "gajss",
                        "content": "For those wondering how it can be solved using a max heap(or pq), the output pairs don't need to be ordered by sum. So if sum(u2, v2) > sum(u1, v1), output can be [{u2, v2}, {u1, v1}], i.e. it need not be [{u1,v1}, {u2,v2}]."
                    },
                    {
                        "username": "seeker_747",
                        "content": "my first intiution was using two pointers.........then solved it using heap \\n"
                    },
                    {
                        "username": "rudoy",
                        "content": "I almost give up my June strike with this problem, but found a solution without Heap. However I have to learn how to use Heap properly. I\\'m sure that my solution can be significantly speed up if I\\'ll use insertion in sorted array instead of append new element as the last and sorting after. Will revise June\\'s problems for solving them more optimal"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "1) The smallest sum will be formed by index 0 of nums1 and index 0 of nums2. \n2) The next smaller sum will be either from {index 0 of nums1 and index1 of nums2} or {index 1 of nums1 and index 0 of nums2}. \n\n\n\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i would probably fail this in an interview ... the O(klgk) is tricky, but O(N^2lgk) is not "
                    },
                    {
                        "username": "kumawatashok1815",
                        "content": "can anyone tell me the what wrong with this solution .\\n\\n\\n\\n//MY OUTPUT :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[-4,7],[0,3],[0,3]]\\n//Expected :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[0,3],[0,3]]\\n\\n\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n\\n        Map<Integer,List<Integer> > map = new TreeMap<>();\\n        List<List<Integer>>finalResult = new ArrayList<>();\\n\\n        for(int i=0;i<num1.length;i++)\\n        { \\n            for(int j=0;j<num2.length;j++)\\n            {\\n                int sum = num1[i]+num2[j];\\n                List<Integer> l1 = new ArrayList<>();\\n                l1.add(num1[i]);\\n                l1.add(num2[j]);\\n                if(map.containsKey(sum))\\n                {\\n                    List<Integer> l2 = map.get(sum);\\n                    l2.addAll(l1);\\n                    map.put(sum,l2);\\n\\n                }\\n                else\\n                {\\n                   map.put(sum,l1);\\n                }\\n               \\n\\n            }\\n        }\\n\\n        int counter=0;\\n\\n        for(Integer key : map.keySet())\\n        {\\n            if(counter<k)\\n            {\\n               \\n                List<Integer> l1 = map.get(key);\\n                for(int i=0;i<l1.size();i+=2)\\n                {\\n                    List<Integer> l2 = new ArrayList<>();\\n                    l2.add(l1.get(i));\\n                    l2.add(l1.get(i+1));\\n                    finalResult.add(l2);    \\n                    counter++;\\n                    \\n                }\\n             \\n                \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return finalResult;\\n        \\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The logic of your code is almost correct, but you need to consider that in your case you\\'re creating one pair every two numbers, but the map does not have a limit per key. This means that for each sum, you\\'re trying to put as many pairs as there are in the cross product of the two input arrays that sum to that key. \\n\\nThis can cause issues if, for instance, there are many pairs that have the same sum. In your case, the `counter` could increment more than once within the inner `for` loop because the `if(counter<k)` condition is checked only at the beginning of each key in your map. As a result, you might end up adding more than `k` pairs to your `finalResult`.\\n\\nTo fix this, you should check if you\\'ve added `k` pairs after adding each pair, not after adding all pairs of a specific sum. If `counter` is equal to `k`, you should break from both loops.\\n\\nHere\\'s a corrected version of your code:\\n\\n```java\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n    Map<Integer,List<Integer>> map = new TreeMap<>();\\n    List<List<Integer>>finalResult = new ArrayList<>();\\n\\n    for(int i=0;i<num1.length;i++) {\\n        for(int j=0;j<num2.length;j++) {\\n            int sum = num1[i]+num2[j];\\n            List<Integer> l1 = new ArrayList<>();\\n            l1.add(num1[i]);\\n            l1.add(num2[j]);\\n            map.putIfAbsent(sum, new ArrayList<>());\\n            map.get(sum).addAll(l1);\\n        }\\n    }\\n\\n    int counter=0;\\n    outer: \\n    for(Integer key : map.keySet()) {\\n        List<Integer> l1 = map.get(key);\\n        for(int i=0;i<l1.size();i+=2) {\\n            List<Integer> l2 = new ArrayList<>();\\n            l2.add(l1.get(i));\\n            l2.add(l1.get(i+1));\\n            finalResult.add(l2);\\n            counter++;\\n            if(counter==k)\\n                break outer;\\n        }\\n    }\\n\\n    return finalResult;\\n}\\n```\\n\\nIn the corrected code, I added the `outer:` label and the `break outer;` statement to exit both loops once `k` pairs have been added to `finalResult`.\\n\\nThis solution can solve the problem, but it might not be the most efficient one. There\\'s an alternative way to solve this problem by using a priority queue, which can have a better time complexity. This approach avoids storing all pairs and only maintains the smallest pairs, which is a more efficient use of memory."
                    },
                    {
                        "username": "sikora92",
                        "content": "Isn\\'t there some bug in test case 35? It tells my solution returns empty List, but I cannot reproduce it in my IDE."
                    },
                    {
                        "username": "sikora92",
                        "content": "Just nums1.length*nums2.length is bigger than integer range. Remember to use long. "
                    },
                    {
                        "username": "loloksEth",
                        "content": "2 ptr working there"
                    },
                    {
                        "username": "Nayanthara_P",
                        "content": "What is the 14th test case? For me, the test cases 13/35 pass without errors, but for the 14th one I don\\'t understand why I get the following error:\\n\\nnums1 =\\n[1,1,2]\\nnums2 =\\n[1,2,3]\\nk =\\n10\\nUse Testcase\\nOutput\\n[[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,2],[2,3]]\\nExpected\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy between your output and the expected output can be seen at the 5th pair. In the expected output, the 5th pair is [1,2], but in your output, the 5th pair is [2,1]. This is likely due to a difference in the order in which your program is processing the pairs. In this problem, the order of the pairs matters - [2,1] is not equivalent to [1,2] because 2 from nums1 and 1 from nums2 would be a greater sum than 1 from nums1 and 2 from nums2.\\n\\nYou might want to review your implementation to ensure that it is processing the pairs in the correct order"
                    },
                    {
                        "username": "xmmmir",
                        "content": "You\\'re somehow getting 10 pairs out of 3x3 matrix. [2,2] is duplicated."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "share the code please"
                    }
                ]
            },
            {
                "id": 1947191,
                "content": [
                    {
                        "username": "harmonicfunc",
                        "content": "is it bfs with priority queue??\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "I made my solution on priority queue, it\\'s simple way but not quick."
                    },
                    {
                        "username": "gajss",
                        "content": "For those wondering how it can be solved using a max heap(or pq), the output pairs don't need to be ordered by sum. So if sum(u2, v2) > sum(u1, v1), output can be [{u2, v2}, {u1, v1}], i.e. it need not be [{u1,v1}, {u2,v2}]."
                    },
                    {
                        "username": "seeker_747",
                        "content": "my first intiution was using two pointers.........then solved it using heap \\n"
                    },
                    {
                        "username": "rudoy",
                        "content": "I almost give up my June strike with this problem, but found a solution without Heap. However I have to learn how to use Heap properly. I\\'m sure that my solution can be significantly speed up if I\\'ll use insertion in sorted array instead of append new element as the last and sorting after. Will revise June\\'s problems for solving them more optimal"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "1) The smallest sum will be formed by index 0 of nums1 and index 0 of nums2. \n2) The next smaller sum will be either from {index 0 of nums1 and index1 of nums2} or {index 1 of nums1 and index 0 of nums2}. \n\n\n\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i would probably fail this in an interview ... the O(klgk) is tricky, but O(N^2lgk) is not "
                    },
                    {
                        "username": "kumawatashok1815",
                        "content": "can anyone tell me the what wrong with this solution .\\n\\n\\n\\n//MY OUTPUT :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[-4,7],[0,3],[0,3]]\\n//Expected :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[0,3],[0,3]]\\n\\n\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n\\n        Map<Integer,List<Integer> > map = new TreeMap<>();\\n        List<List<Integer>>finalResult = new ArrayList<>();\\n\\n        for(int i=0;i<num1.length;i++)\\n        { \\n            for(int j=0;j<num2.length;j++)\\n            {\\n                int sum = num1[i]+num2[j];\\n                List<Integer> l1 = new ArrayList<>();\\n                l1.add(num1[i]);\\n                l1.add(num2[j]);\\n                if(map.containsKey(sum))\\n                {\\n                    List<Integer> l2 = map.get(sum);\\n                    l2.addAll(l1);\\n                    map.put(sum,l2);\\n\\n                }\\n                else\\n                {\\n                   map.put(sum,l1);\\n                }\\n               \\n\\n            }\\n        }\\n\\n        int counter=0;\\n\\n        for(Integer key : map.keySet())\\n        {\\n            if(counter<k)\\n            {\\n               \\n                List<Integer> l1 = map.get(key);\\n                for(int i=0;i<l1.size();i+=2)\\n                {\\n                    List<Integer> l2 = new ArrayList<>();\\n                    l2.add(l1.get(i));\\n                    l2.add(l1.get(i+1));\\n                    finalResult.add(l2);    \\n                    counter++;\\n                    \\n                }\\n             \\n                \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return finalResult;\\n        \\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The logic of your code is almost correct, but you need to consider that in your case you\\'re creating one pair every two numbers, but the map does not have a limit per key. This means that for each sum, you\\'re trying to put as many pairs as there are in the cross product of the two input arrays that sum to that key. \\n\\nThis can cause issues if, for instance, there are many pairs that have the same sum. In your case, the `counter` could increment more than once within the inner `for` loop because the `if(counter<k)` condition is checked only at the beginning of each key in your map. As a result, you might end up adding more than `k` pairs to your `finalResult`.\\n\\nTo fix this, you should check if you\\'ve added `k` pairs after adding each pair, not after adding all pairs of a specific sum. If `counter` is equal to `k`, you should break from both loops.\\n\\nHere\\'s a corrected version of your code:\\n\\n```java\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n    Map<Integer,List<Integer>> map = new TreeMap<>();\\n    List<List<Integer>>finalResult = new ArrayList<>();\\n\\n    for(int i=0;i<num1.length;i++) {\\n        for(int j=0;j<num2.length;j++) {\\n            int sum = num1[i]+num2[j];\\n            List<Integer> l1 = new ArrayList<>();\\n            l1.add(num1[i]);\\n            l1.add(num2[j]);\\n            map.putIfAbsent(sum, new ArrayList<>());\\n            map.get(sum).addAll(l1);\\n        }\\n    }\\n\\n    int counter=0;\\n    outer: \\n    for(Integer key : map.keySet()) {\\n        List<Integer> l1 = map.get(key);\\n        for(int i=0;i<l1.size();i+=2) {\\n            List<Integer> l2 = new ArrayList<>();\\n            l2.add(l1.get(i));\\n            l2.add(l1.get(i+1));\\n            finalResult.add(l2);\\n            counter++;\\n            if(counter==k)\\n                break outer;\\n        }\\n    }\\n\\n    return finalResult;\\n}\\n```\\n\\nIn the corrected code, I added the `outer:` label and the `break outer;` statement to exit both loops once `k` pairs have been added to `finalResult`.\\n\\nThis solution can solve the problem, but it might not be the most efficient one. There\\'s an alternative way to solve this problem by using a priority queue, which can have a better time complexity. This approach avoids storing all pairs and only maintains the smallest pairs, which is a more efficient use of memory."
                    },
                    {
                        "username": "sikora92",
                        "content": "Isn\\'t there some bug in test case 35? It tells my solution returns empty List, but I cannot reproduce it in my IDE."
                    },
                    {
                        "username": "sikora92",
                        "content": "Just nums1.length*nums2.length is bigger than integer range. Remember to use long. "
                    },
                    {
                        "username": "loloksEth",
                        "content": "2 ptr working there"
                    },
                    {
                        "username": "Nayanthara_P",
                        "content": "What is the 14th test case? For me, the test cases 13/35 pass without errors, but for the 14th one I don\\'t understand why I get the following error:\\n\\nnums1 =\\n[1,1,2]\\nnums2 =\\n[1,2,3]\\nk =\\n10\\nUse Testcase\\nOutput\\n[[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,2],[2,3]]\\nExpected\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy between your output and the expected output can be seen at the 5th pair. In the expected output, the 5th pair is [1,2], but in your output, the 5th pair is [2,1]. This is likely due to a difference in the order in which your program is processing the pairs. In this problem, the order of the pairs matters - [2,1] is not equivalent to [1,2] because 2 from nums1 and 1 from nums2 would be a greater sum than 1 from nums1 and 2 from nums2.\\n\\nYou might want to review your implementation to ensure that it is processing the pairs in the correct order"
                    },
                    {
                        "username": "xmmmir",
                        "content": "You\\'re somehow getting 10 pairs out of 3x3 matrix. [2,2] is duplicated."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "share the code please"
                    }
                ]
            },
            {
                "id": 1947118,
                "content": [
                    {
                        "username": "harmonicfunc",
                        "content": "is it bfs with priority queue??\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "I made my solution on priority queue, it\\'s simple way but not quick."
                    },
                    {
                        "username": "gajss",
                        "content": "For those wondering how it can be solved using a max heap(or pq), the output pairs don't need to be ordered by sum. So if sum(u2, v2) > sum(u1, v1), output can be [{u2, v2}, {u1, v1}], i.e. it need not be [{u1,v1}, {u2,v2}]."
                    },
                    {
                        "username": "seeker_747",
                        "content": "my first intiution was using two pointers.........then solved it using heap \\n"
                    },
                    {
                        "username": "rudoy",
                        "content": "I almost give up my June strike with this problem, but found a solution without Heap. However I have to learn how to use Heap properly. I\\'m sure that my solution can be significantly speed up if I\\'ll use insertion in sorted array instead of append new element as the last and sorting after. Will revise June\\'s problems for solving them more optimal"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "1) The smallest sum will be formed by index 0 of nums1 and index 0 of nums2. \n2) The next smaller sum will be either from {index 0 of nums1 and index1 of nums2} or {index 1 of nums1 and index 0 of nums2}. \n\n\n\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i would probably fail this in an interview ... the O(klgk) is tricky, but O(N^2lgk) is not "
                    },
                    {
                        "username": "kumawatashok1815",
                        "content": "can anyone tell me the what wrong with this solution .\\n\\n\\n\\n//MY OUTPUT :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[-4,7],[0,3],[0,3]]\\n//Expected :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[0,3],[0,3]]\\n\\n\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n\\n        Map<Integer,List<Integer> > map = new TreeMap<>();\\n        List<List<Integer>>finalResult = new ArrayList<>();\\n\\n        for(int i=0;i<num1.length;i++)\\n        { \\n            for(int j=0;j<num2.length;j++)\\n            {\\n                int sum = num1[i]+num2[j];\\n                List<Integer> l1 = new ArrayList<>();\\n                l1.add(num1[i]);\\n                l1.add(num2[j]);\\n                if(map.containsKey(sum))\\n                {\\n                    List<Integer> l2 = map.get(sum);\\n                    l2.addAll(l1);\\n                    map.put(sum,l2);\\n\\n                }\\n                else\\n                {\\n                   map.put(sum,l1);\\n                }\\n               \\n\\n            }\\n        }\\n\\n        int counter=0;\\n\\n        for(Integer key : map.keySet())\\n        {\\n            if(counter<k)\\n            {\\n               \\n                List<Integer> l1 = map.get(key);\\n                for(int i=0;i<l1.size();i+=2)\\n                {\\n                    List<Integer> l2 = new ArrayList<>();\\n                    l2.add(l1.get(i));\\n                    l2.add(l1.get(i+1));\\n                    finalResult.add(l2);    \\n                    counter++;\\n                    \\n                }\\n             \\n                \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return finalResult;\\n        \\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The logic of your code is almost correct, but you need to consider that in your case you\\'re creating one pair every two numbers, but the map does not have a limit per key. This means that for each sum, you\\'re trying to put as many pairs as there are in the cross product of the two input arrays that sum to that key. \\n\\nThis can cause issues if, for instance, there are many pairs that have the same sum. In your case, the `counter` could increment more than once within the inner `for` loop because the `if(counter<k)` condition is checked only at the beginning of each key in your map. As a result, you might end up adding more than `k` pairs to your `finalResult`.\\n\\nTo fix this, you should check if you\\'ve added `k` pairs after adding each pair, not after adding all pairs of a specific sum. If `counter` is equal to `k`, you should break from both loops.\\n\\nHere\\'s a corrected version of your code:\\n\\n```java\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n    Map<Integer,List<Integer>> map = new TreeMap<>();\\n    List<List<Integer>>finalResult = new ArrayList<>();\\n\\n    for(int i=0;i<num1.length;i++) {\\n        for(int j=0;j<num2.length;j++) {\\n            int sum = num1[i]+num2[j];\\n            List<Integer> l1 = new ArrayList<>();\\n            l1.add(num1[i]);\\n            l1.add(num2[j]);\\n            map.putIfAbsent(sum, new ArrayList<>());\\n            map.get(sum).addAll(l1);\\n        }\\n    }\\n\\n    int counter=0;\\n    outer: \\n    for(Integer key : map.keySet()) {\\n        List<Integer> l1 = map.get(key);\\n        for(int i=0;i<l1.size();i+=2) {\\n            List<Integer> l2 = new ArrayList<>();\\n            l2.add(l1.get(i));\\n            l2.add(l1.get(i+1));\\n            finalResult.add(l2);\\n            counter++;\\n            if(counter==k)\\n                break outer;\\n        }\\n    }\\n\\n    return finalResult;\\n}\\n```\\n\\nIn the corrected code, I added the `outer:` label and the `break outer;` statement to exit both loops once `k` pairs have been added to `finalResult`.\\n\\nThis solution can solve the problem, but it might not be the most efficient one. There\\'s an alternative way to solve this problem by using a priority queue, which can have a better time complexity. This approach avoids storing all pairs and only maintains the smallest pairs, which is a more efficient use of memory."
                    },
                    {
                        "username": "sikora92",
                        "content": "Isn\\'t there some bug in test case 35? It tells my solution returns empty List, but I cannot reproduce it in my IDE."
                    },
                    {
                        "username": "sikora92",
                        "content": "Just nums1.length*nums2.length is bigger than integer range. Remember to use long. "
                    },
                    {
                        "username": "loloksEth",
                        "content": "2 ptr working there"
                    },
                    {
                        "username": "Nayanthara_P",
                        "content": "What is the 14th test case? For me, the test cases 13/35 pass without errors, but for the 14th one I don\\'t understand why I get the following error:\\n\\nnums1 =\\n[1,1,2]\\nnums2 =\\n[1,2,3]\\nk =\\n10\\nUse Testcase\\nOutput\\n[[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,2],[2,3]]\\nExpected\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy between your output and the expected output can be seen at the 5th pair. In the expected output, the 5th pair is [1,2], but in your output, the 5th pair is [2,1]. This is likely due to a difference in the order in which your program is processing the pairs. In this problem, the order of the pairs matters - [2,1] is not equivalent to [1,2] because 2 from nums1 and 1 from nums2 would be a greater sum than 1 from nums1 and 2 from nums2.\\n\\nYou might want to review your implementation to ensure that it is processing the pairs in the correct order"
                    },
                    {
                        "username": "xmmmir",
                        "content": "You\\'re somehow getting 10 pairs out of 3x3 matrix. [2,2] is duplicated."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "share the code please"
                    }
                ]
            },
            {
                "id": 1946925,
                "content": [
                    {
                        "username": "harmonicfunc",
                        "content": "is it bfs with priority queue??\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "I made my solution on priority queue, it\\'s simple way but not quick."
                    },
                    {
                        "username": "gajss",
                        "content": "For those wondering how it can be solved using a max heap(or pq), the output pairs don't need to be ordered by sum. So if sum(u2, v2) > sum(u1, v1), output can be [{u2, v2}, {u1, v1}], i.e. it need not be [{u1,v1}, {u2,v2}]."
                    },
                    {
                        "username": "seeker_747",
                        "content": "my first intiution was using two pointers.........then solved it using heap \\n"
                    },
                    {
                        "username": "rudoy",
                        "content": "I almost give up my June strike with this problem, but found a solution without Heap. However I have to learn how to use Heap properly. I\\'m sure that my solution can be significantly speed up if I\\'ll use insertion in sorted array instead of append new element as the last and sorting after. Will revise June\\'s problems for solving them more optimal"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "1) The smallest sum will be formed by index 0 of nums1 and index 0 of nums2. \n2) The next smaller sum will be either from {index 0 of nums1 and index1 of nums2} or {index 1 of nums1 and index 0 of nums2}. \n\n\n\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i would probably fail this in an interview ... the O(klgk) is tricky, but O(N^2lgk) is not "
                    },
                    {
                        "username": "kumawatashok1815",
                        "content": "can anyone tell me the what wrong with this solution .\\n\\n\\n\\n//MY OUTPUT :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[-4,7],[0,3],[0,3]]\\n//Expected :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[0,3],[0,3]]\\n\\n\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n\\n        Map<Integer,List<Integer> > map = new TreeMap<>();\\n        List<List<Integer>>finalResult = new ArrayList<>();\\n\\n        for(int i=0;i<num1.length;i++)\\n        { \\n            for(int j=0;j<num2.length;j++)\\n            {\\n                int sum = num1[i]+num2[j];\\n                List<Integer> l1 = new ArrayList<>();\\n                l1.add(num1[i]);\\n                l1.add(num2[j]);\\n                if(map.containsKey(sum))\\n                {\\n                    List<Integer> l2 = map.get(sum);\\n                    l2.addAll(l1);\\n                    map.put(sum,l2);\\n\\n                }\\n                else\\n                {\\n                   map.put(sum,l1);\\n                }\\n               \\n\\n            }\\n        }\\n\\n        int counter=0;\\n\\n        for(Integer key : map.keySet())\\n        {\\n            if(counter<k)\\n            {\\n               \\n                List<Integer> l1 = map.get(key);\\n                for(int i=0;i<l1.size();i+=2)\\n                {\\n                    List<Integer> l2 = new ArrayList<>();\\n                    l2.add(l1.get(i));\\n                    l2.add(l1.get(i+1));\\n                    finalResult.add(l2);    \\n                    counter++;\\n                    \\n                }\\n             \\n                \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return finalResult;\\n        \\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The logic of your code is almost correct, but you need to consider that in your case you\\'re creating one pair every two numbers, but the map does not have a limit per key. This means that for each sum, you\\'re trying to put as many pairs as there are in the cross product of the two input arrays that sum to that key. \\n\\nThis can cause issues if, for instance, there are many pairs that have the same sum. In your case, the `counter` could increment more than once within the inner `for` loop because the `if(counter<k)` condition is checked only at the beginning of each key in your map. As a result, you might end up adding more than `k` pairs to your `finalResult`.\\n\\nTo fix this, you should check if you\\'ve added `k` pairs after adding each pair, not after adding all pairs of a specific sum. If `counter` is equal to `k`, you should break from both loops.\\n\\nHere\\'s a corrected version of your code:\\n\\n```java\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n    Map<Integer,List<Integer>> map = new TreeMap<>();\\n    List<List<Integer>>finalResult = new ArrayList<>();\\n\\n    for(int i=0;i<num1.length;i++) {\\n        for(int j=0;j<num2.length;j++) {\\n            int sum = num1[i]+num2[j];\\n            List<Integer> l1 = new ArrayList<>();\\n            l1.add(num1[i]);\\n            l1.add(num2[j]);\\n            map.putIfAbsent(sum, new ArrayList<>());\\n            map.get(sum).addAll(l1);\\n        }\\n    }\\n\\n    int counter=0;\\n    outer: \\n    for(Integer key : map.keySet()) {\\n        List<Integer> l1 = map.get(key);\\n        for(int i=0;i<l1.size();i+=2) {\\n            List<Integer> l2 = new ArrayList<>();\\n            l2.add(l1.get(i));\\n            l2.add(l1.get(i+1));\\n            finalResult.add(l2);\\n            counter++;\\n            if(counter==k)\\n                break outer;\\n        }\\n    }\\n\\n    return finalResult;\\n}\\n```\\n\\nIn the corrected code, I added the `outer:` label and the `break outer;` statement to exit both loops once `k` pairs have been added to `finalResult`.\\n\\nThis solution can solve the problem, but it might not be the most efficient one. There\\'s an alternative way to solve this problem by using a priority queue, which can have a better time complexity. This approach avoids storing all pairs and only maintains the smallest pairs, which is a more efficient use of memory."
                    },
                    {
                        "username": "sikora92",
                        "content": "Isn\\'t there some bug in test case 35? It tells my solution returns empty List, but I cannot reproduce it in my IDE."
                    },
                    {
                        "username": "sikora92",
                        "content": "Just nums1.length*nums2.length is bigger than integer range. Remember to use long. "
                    },
                    {
                        "username": "loloksEth",
                        "content": "2 ptr working there"
                    },
                    {
                        "username": "Nayanthara_P",
                        "content": "What is the 14th test case? For me, the test cases 13/35 pass without errors, but for the 14th one I don\\'t understand why I get the following error:\\n\\nnums1 =\\n[1,1,2]\\nnums2 =\\n[1,2,3]\\nk =\\n10\\nUse Testcase\\nOutput\\n[[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,2],[2,3]]\\nExpected\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy between your output and the expected output can be seen at the 5th pair. In the expected output, the 5th pair is [1,2], but in your output, the 5th pair is [2,1]. This is likely due to a difference in the order in which your program is processing the pairs. In this problem, the order of the pairs matters - [2,1] is not equivalent to [1,2] because 2 from nums1 and 1 from nums2 would be a greater sum than 1 from nums1 and 2 from nums2.\\n\\nYou might want to review your implementation to ensure that it is processing the pairs in the correct order"
                    },
                    {
                        "username": "xmmmir",
                        "content": "You\\'re somehow getting 10 pairs out of 3x3 matrix. [2,2] is duplicated."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "share the code please"
                    }
                ]
            },
            {
                "id": 1946764,
                "content": [
                    {
                        "username": "harmonicfunc",
                        "content": "is it bfs with priority queue??\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "I made my solution on priority queue, it\\'s simple way but not quick."
                    },
                    {
                        "username": "gajss",
                        "content": "For those wondering how it can be solved using a max heap(or pq), the output pairs don't need to be ordered by sum. So if sum(u2, v2) > sum(u1, v1), output can be [{u2, v2}, {u1, v1}], i.e. it need not be [{u1,v1}, {u2,v2}]."
                    },
                    {
                        "username": "seeker_747",
                        "content": "my first intiution was using two pointers.........then solved it using heap \\n"
                    },
                    {
                        "username": "rudoy",
                        "content": "I almost give up my June strike with this problem, but found a solution without Heap. However I have to learn how to use Heap properly. I\\'m sure that my solution can be significantly speed up if I\\'ll use insertion in sorted array instead of append new element as the last and sorting after. Will revise June\\'s problems for solving them more optimal"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "1) The smallest sum will be formed by index 0 of nums1 and index 0 of nums2. \n2) The next smaller sum will be either from {index 0 of nums1 and index1 of nums2} or {index 1 of nums1 and index 0 of nums2}. \n\n\n\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i would probably fail this in an interview ... the O(klgk) is tricky, but O(N^2lgk) is not "
                    },
                    {
                        "username": "kumawatashok1815",
                        "content": "can anyone tell me the what wrong with this solution .\\n\\n\\n\\n//MY OUTPUT :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[-4,7],[0,3],[0,3]]\\n//Expected :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[0,3],[0,3]]\\n\\n\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n\\n        Map<Integer,List<Integer> > map = new TreeMap<>();\\n        List<List<Integer>>finalResult = new ArrayList<>();\\n\\n        for(int i=0;i<num1.length;i++)\\n        { \\n            for(int j=0;j<num2.length;j++)\\n            {\\n                int sum = num1[i]+num2[j];\\n                List<Integer> l1 = new ArrayList<>();\\n                l1.add(num1[i]);\\n                l1.add(num2[j]);\\n                if(map.containsKey(sum))\\n                {\\n                    List<Integer> l2 = map.get(sum);\\n                    l2.addAll(l1);\\n                    map.put(sum,l2);\\n\\n                }\\n                else\\n                {\\n                   map.put(sum,l1);\\n                }\\n               \\n\\n            }\\n        }\\n\\n        int counter=0;\\n\\n        for(Integer key : map.keySet())\\n        {\\n            if(counter<k)\\n            {\\n               \\n                List<Integer> l1 = map.get(key);\\n                for(int i=0;i<l1.size();i+=2)\\n                {\\n                    List<Integer> l2 = new ArrayList<>();\\n                    l2.add(l1.get(i));\\n                    l2.add(l1.get(i+1));\\n                    finalResult.add(l2);    \\n                    counter++;\\n                    \\n                }\\n             \\n                \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return finalResult;\\n        \\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The logic of your code is almost correct, but you need to consider that in your case you\\'re creating one pair every two numbers, but the map does not have a limit per key. This means that for each sum, you\\'re trying to put as many pairs as there are in the cross product of the two input arrays that sum to that key. \\n\\nThis can cause issues if, for instance, there are many pairs that have the same sum. In your case, the `counter` could increment more than once within the inner `for` loop because the `if(counter<k)` condition is checked only at the beginning of each key in your map. As a result, you might end up adding more than `k` pairs to your `finalResult`.\\n\\nTo fix this, you should check if you\\'ve added `k` pairs after adding each pair, not after adding all pairs of a specific sum. If `counter` is equal to `k`, you should break from both loops.\\n\\nHere\\'s a corrected version of your code:\\n\\n```java\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n    Map<Integer,List<Integer>> map = new TreeMap<>();\\n    List<List<Integer>>finalResult = new ArrayList<>();\\n\\n    for(int i=0;i<num1.length;i++) {\\n        for(int j=0;j<num2.length;j++) {\\n            int sum = num1[i]+num2[j];\\n            List<Integer> l1 = new ArrayList<>();\\n            l1.add(num1[i]);\\n            l1.add(num2[j]);\\n            map.putIfAbsent(sum, new ArrayList<>());\\n            map.get(sum).addAll(l1);\\n        }\\n    }\\n\\n    int counter=0;\\n    outer: \\n    for(Integer key : map.keySet()) {\\n        List<Integer> l1 = map.get(key);\\n        for(int i=0;i<l1.size();i+=2) {\\n            List<Integer> l2 = new ArrayList<>();\\n            l2.add(l1.get(i));\\n            l2.add(l1.get(i+1));\\n            finalResult.add(l2);\\n            counter++;\\n            if(counter==k)\\n                break outer;\\n        }\\n    }\\n\\n    return finalResult;\\n}\\n```\\n\\nIn the corrected code, I added the `outer:` label and the `break outer;` statement to exit both loops once `k` pairs have been added to `finalResult`.\\n\\nThis solution can solve the problem, but it might not be the most efficient one. There\\'s an alternative way to solve this problem by using a priority queue, which can have a better time complexity. This approach avoids storing all pairs and only maintains the smallest pairs, which is a more efficient use of memory."
                    },
                    {
                        "username": "sikora92",
                        "content": "Isn\\'t there some bug in test case 35? It tells my solution returns empty List, but I cannot reproduce it in my IDE."
                    },
                    {
                        "username": "sikora92",
                        "content": "Just nums1.length*nums2.length is bigger than integer range. Remember to use long. "
                    },
                    {
                        "username": "loloksEth",
                        "content": "2 ptr working there"
                    },
                    {
                        "username": "Nayanthara_P",
                        "content": "What is the 14th test case? For me, the test cases 13/35 pass without errors, but for the 14th one I don\\'t understand why I get the following error:\\n\\nnums1 =\\n[1,1,2]\\nnums2 =\\n[1,2,3]\\nk =\\n10\\nUse Testcase\\nOutput\\n[[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,2],[2,3]]\\nExpected\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy between your output and the expected output can be seen at the 5th pair. In the expected output, the 5th pair is [1,2], but in your output, the 5th pair is [2,1]. This is likely due to a difference in the order in which your program is processing the pairs. In this problem, the order of the pairs matters - [2,1] is not equivalent to [1,2] because 2 from nums1 and 1 from nums2 would be a greater sum than 1 from nums1 and 2 from nums2.\\n\\nYou might want to review your implementation to ensure that it is processing the pairs in the correct order"
                    },
                    {
                        "username": "xmmmir",
                        "content": "You\\'re somehow getting 10 pairs out of 3x3 matrix. [2,2] is duplicated."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "share the code please"
                    }
                ]
            },
            {
                "id": 1946700,
                "content": [
                    {
                        "username": "harmonicfunc",
                        "content": "is it bfs with priority queue??\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "I made my solution on priority queue, it\\'s simple way but not quick."
                    },
                    {
                        "username": "gajss",
                        "content": "For those wondering how it can be solved using a max heap(or pq), the output pairs don't need to be ordered by sum. So if sum(u2, v2) > sum(u1, v1), output can be [{u2, v2}, {u1, v1}], i.e. it need not be [{u1,v1}, {u2,v2}]."
                    },
                    {
                        "username": "seeker_747",
                        "content": "my first intiution was using two pointers.........then solved it using heap \\n"
                    },
                    {
                        "username": "rudoy",
                        "content": "I almost give up my June strike with this problem, but found a solution without Heap. However I have to learn how to use Heap properly. I\\'m sure that my solution can be significantly speed up if I\\'ll use insertion in sorted array instead of append new element as the last and sorting after. Will revise June\\'s problems for solving them more optimal"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "1) The smallest sum will be formed by index 0 of nums1 and index 0 of nums2. \n2) The next smaller sum will be either from {index 0 of nums1 and index1 of nums2} or {index 1 of nums1 and index 0 of nums2}. \n\n\n\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i would probably fail this in an interview ... the O(klgk) is tricky, but O(N^2lgk) is not "
                    },
                    {
                        "username": "kumawatashok1815",
                        "content": "can anyone tell me the what wrong with this solution .\\n\\n\\n\\n//MY OUTPUT :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[-4,7],[0,3],[0,3]]\\n//Expected :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[0,3],[0,3]]\\n\\n\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n\\n        Map<Integer,List<Integer> > map = new TreeMap<>();\\n        List<List<Integer>>finalResult = new ArrayList<>();\\n\\n        for(int i=0;i<num1.length;i++)\\n        { \\n            for(int j=0;j<num2.length;j++)\\n            {\\n                int sum = num1[i]+num2[j];\\n                List<Integer> l1 = new ArrayList<>();\\n                l1.add(num1[i]);\\n                l1.add(num2[j]);\\n                if(map.containsKey(sum))\\n                {\\n                    List<Integer> l2 = map.get(sum);\\n                    l2.addAll(l1);\\n                    map.put(sum,l2);\\n\\n                }\\n                else\\n                {\\n                   map.put(sum,l1);\\n                }\\n               \\n\\n            }\\n        }\\n\\n        int counter=0;\\n\\n        for(Integer key : map.keySet())\\n        {\\n            if(counter<k)\\n            {\\n               \\n                List<Integer> l1 = map.get(key);\\n                for(int i=0;i<l1.size();i+=2)\\n                {\\n                    List<Integer> l2 = new ArrayList<>();\\n                    l2.add(l1.get(i));\\n                    l2.add(l1.get(i+1));\\n                    finalResult.add(l2);    \\n                    counter++;\\n                    \\n                }\\n             \\n                \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return finalResult;\\n        \\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The logic of your code is almost correct, but you need to consider that in your case you\\'re creating one pair every two numbers, but the map does not have a limit per key. This means that for each sum, you\\'re trying to put as many pairs as there are in the cross product of the two input arrays that sum to that key. \\n\\nThis can cause issues if, for instance, there are many pairs that have the same sum. In your case, the `counter` could increment more than once within the inner `for` loop because the `if(counter<k)` condition is checked only at the beginning of each key in your map. As a result, you might end up adding more than `k` pairs to your `finalResult`.\\n\\nTo fix this, you should check if you\\'ve added `k` pairs after adding each pair, not after adding all pairs of a specific sum. If `counter` is equal to `k`, you should break from both loops.\\n\\nHere\\'s a corrected version of your code:\\n\\n```java\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n    Map<Integer,List<Integer>> map = new TreeMap<>();\\n    List<List<Integer>>finalResult = new ArrayList<>();\\n\\n    for(int i=0;i<num1.length;i++) {\\n        for(int j=0;j<num2.length;j++) {\\n            int sum = num1[i]+num2[j];\\n            List<Integer> l1 = new ArrayList<>();\\n            l1.add(num1[i]);\\n            l1.add(num2[j]);\\n            map.putIfAbsent(sum, new ArrayList<>());\\n            map.get(sum).addAll(l1);\\n        }\\n    }\\n\\n    int counter=0;\\n    outer: \\n    for(Integer key : map.keySet()) {\\n        List<Integer> l1 = map.get(key);\\n        for(int i=0;i<l1.size();i+=2) {\\n            List<Integer> l2 = new ArrayList<>();\\n            l2.add(l1.get(i));\\n            l2.add(l1.get(i+1));\\n            finalResult.add(l2);\\n            counter++;\\n            if(counter==k)\\n                break outer;\\n        }\\n    }\\n\\n    return finalResult;\\n}\\n```\\n\\nIn the corrected code, I added the `outer:` label and the `break outer;` statement to exit both loops once `k` pairs have been added to `finalResult`.\\n\\nThis solution can solve the problem, but it might not be the most efficient one. There\\'s an alternative way to solve this problem by using a priority queue, which can have a better time complexity. This approach avoids storing all pairs and only maintains the smallest pairs, which is a more efficient use of memory."
                    },
                    {
                        "username": "sikora92",
                        "content": "Isn\\'t there some bug in test case 35? It tells my solution returns empty List, but I cannot reproduce it in my IDE."
                    },
                    {
                        "username": "sikora92",
                        "content": "Just nums1.length*nums2.length is bigger than integer range. Remember to use long. "
                    },
                    {
                        "username": "loloksEth",
                        "content": "2 ptr working there"
                    },
                    {
                        "username": "Nayanthara_P",
                        "content": "What is the 14th test case? For me, the test cases 13/35 pass without errors, but for the 14th one I don\\'t understand why I get the following error:\\n\\nnums1 =\\n[1,1,2]\\nnums2 =\\n[1,2,3]\\nk =\\n10\\nUse Testcase\\nOutput\\n[[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,2],[2,3]]\\nExpected\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy between your output and the expected output can be seen at the 5th pair. In the expected output, the 5th pair is [1,2], but in your output, the 5th pair is [2,1]. This is likely due to a difference in the order in which your program is processing the pairs. In this problem, the order of the pairs matters - [2,1] is not equivalent to [1,2] because 2 from nums1 and 1 from nums2 would be a greater sum than 1 from nums1 and 2 from nums2.\\n\\nYou might want to review your implementation to ensure that it is processing the pairs in the correct order"
                    },
                    {
                        "username": "xmmmir",
                        "content": "You\\'re somehow getting 10 pairs out of 3x3 matrix. [2,2] is duplicated."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "share the code please"
                    }
                ]
            },
            {
                "id": 1946635,
                "content": [
                    {
                        "username": "harmonicfunc",
                        "content": "is it bfs with priority queue??\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "I made my solution on priority queue, it\\'s simple way but not quick."
                    },
                    {
                        "username": "gajss",
                        "content": "For those wondering how it can be solved using a max heap(or pq), the output pairs don't need to be ordered by sum. So if sum(u2, v2) > sum(u1, v1), output can be [{u2, v2}, {u1, v1}], i.e. it need not be [{u1,v1}, {u2,v2}]."
                    },
                    {
                        "username": "seeker_747",
                        "content": "my first intiution was using two pointers.........then solved it using heap \\n"
                    },
                    {
                        "username": "rudoy",
                        "content": "I almost give up my June strike with this problem, but found a solution without Heap. However I have to learn how to use Heap properly. I\\'m sure that my solution can be significantly speed up if I\\'ll use insertion in sorted array instead of append new element as the last and sorting after. Will revise June\\'s problems for solving them more optimal"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "1) The smallest sum will be formed by index 0 of nums1 and index 0 of nums2. \n2) The next smaller sum will be either from {index 0 of nums1 and index1 of nums2} or {index 1 of nums1 and index 0 of nums2}. \n\n\n\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i would probably fail this in an interview ... the O(klgk) is tricky, but O(N^2lgk) is not "
                    },
                    {
                        "username": "kumawatashok1815",
                        "content": "can anyone tell me the what wrong with this solution .\\n\\n\\n\\n//MY OUTPUT :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[-4,7],[0,3],[0,3]]\\n//Expected :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[0,3],[0,3]]\\n\\n\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n\\n        Map<Integer,List<Integer> > map = new TreeMap<>();\\n        List<List<Integer>>finalResult = new ArrayList<>();\\n\\n        for(int i=0;i<num1.length;i++)\\n        { \\n            for(int j=0;j<num2.length;j++)\\n            {\\n                int sum = num1[i]+num2[j];\\n                List<Integer> l1 = new ArrayList<>();\\n                l1.add(num1[i]);\\n                l1.add(num2[j]);\\n                if(map.containsKey(sum))\\n                {\\n                    List<Integer> l2 = map.get(sum);\\n                    l2.addAll(l1);\\n                    map.put(sum,l2);\\n\\n                }\\n                else\\n                {\\n                   map.put(sum,l1);\\n                }\\n               \\n\\n            }\\n        }\\n\\n        int counter=0;\\n\\n        for(Integer key : map.keySet())\\n        {\\n            if(counter<k)\\n            {\\n               \\n                List<Integer> l1 = map.get(key);\\n                for(int i=0;i<l1.size();i+=2)\\n                {\\n                    List<Integer> l2 = new ArrayList<>();\\n                    l2.add(l1.get(i));\\n                    l2.add(l1.get(i+1));\\n                    finalResult.add(l2);    \\n                    counter++;\\n                    \\n                }\\n             \\n                \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return finalResult;\\n        \\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The logic of your code is almost correct, but you need to consider that in your case you\\'re creating one pair every two numbers, but the map does not have a limit per key. This means that for each sum, you\\'re trying to put as many pairs as there are in the cross product of the two input arrays that sum to that key. \\n\\nThis can cause issues if, for instance, there are many pairs that have the same sum. In your case, the `counter` could increment more than once within the inner `for` loop because the `if(counter<k)` condition is checked only at the beginning of each key in your map. As a result, you might end up adding more than `k` pairs to your `finalResult`.\\n\\nTo fix this, you should check if you\\'ve added `k` pairs after adding each pair, not after adding all pairs of a specific sum. If `counter` is equal to `k`, you should break from both loops.\\n\\nHere\\'s a corrected version of your code:\\n\\n```java\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n    Map<Integer,List<Integer>> map = new TreeMap<>();\\n    List<List<Integer>>finalResult = new ArrayList<>();\\n\\n    for(int i=0;i<num1.length;i++) {\\n        for(int j=0;j<num2.length;j++) {\\n            int sum = num1[i]+num2[j];\\n            List<Integer> l1 = new ArrayList<>();\\n            l1.add(num1[i]);\\n            l1.add(num2[j]);\\n            map.putIfAbsent(sum, new ArrayList<>());\\n            map.get(sum).addAll(l1);\\n        }\\n    }\\n\\n    int counter=0;\\n    outer: \\n    for(Integer key : map.keySet()) {\\n        List<Integer> l1 = map.get(key);\\n        for(int i=0;i<l1.size();i+=2) {\\n            List<Integer> l2 = new ArrayList<>();\\n            l2.add(l1.get(i));\\n            l2.add(l1.get(i+1));\\n            finalResult.add(l2);\\n            counter++;\\n            if(counter==k)\\n                break outer;\\n        }\\n    }\\n\\n    return finalResult;\\n}\\n```\\n\\nIn the corrected code, I added the `outer:` label and the `break outer;` statement to exit both loops once `k` pairs have been added to `finalResult`.\\n\\nThis solution can solve the problem, but it might not be the most efficient one. There\\'s an alternative way to solve this problem by using a priority queue, which can have a better time complexity. This approach avoids storing all pairs and only maintains the smallest pairs, which is a more efficient use of memory."
                    },
                    {
                        "username": "sikora92",
                        "content": "Isn\\'t there some bug in test case 35? It tells my solution returns empty List, but I cannot reproduce it in my IDE."
                    },
                    {
                        "username": "sikora92",
                        "content": "Just nums1.length*nums2.length is bigger than integer range. Remember to use long. "
                    },
                    {
                        "username": "loloksEth",
                        "content": "2 ptr working there"
                    },
                    {
                        "username": "Nayanthara_P",
                        "content": "What is the 14th test case? For me, the test cases 13/35 pass without errors, but for the 14th one I don\\'t understand why I get the following error:\\n\\nnums1 =\\n[1,1,2]\\nnums2 =\\n[1,2,3]\\nk =\\n10\\nUse Testcase\\nOutput\\n[[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,2],[2,3]]\\nExpected\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy between your output and the expected output can be seen at the 5th pair. In the expected output, the 5th pair is [1,2], but in your output, the 5th pair is [2,1]. This is likely due to a difference in the order in which your program is processing the pairs. In this problem, the order of the pairs matters - [2,1] is not equivalent to [1,2] because 2 from nums1 and 1 from nums2 would be a greater sum than 1 from nums1 and 2 from nums2.\\n\\nYou might want to review your implementation to ensure that it is processing the pairs in the correct order"
                    },
                    {
                        "username": "xmmmir",
                        "content": "You\\'re somehow getting 10 pairs out of 3x3 matrix. [2,2] is duplicated."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "share the code please"
                    }
                ]
            },
            {
                "id": 1946498,
                "content": [
                    {
                        "username": "harmonicfunc",
                        "content": "is it bfs with priority queue??\\n"
                    },
                    {
                        "username": "keekkenen",
                        "content": "I made my solution on priority queue, it\\'s simple way but not quick."
                    },
                    {
                        "username": "gajss",
                        "content": "For those wondering how it can be solved using a max heap(or pq), the output pairs don't need to be ordered by sum. So if sum(u2, v2) > sum(u1, v1), output can be [{u2, v2}, {u1, v1}], i.e. it need not be [{u1,v1}, {u2,v2}]."
                    },
                    {
                        "username": "seeker_747",
                        "content": "my first intiution was using two pointers.........then solved it using heap \\n"
                    },
                    {
                        "username": "rudoy",
                        "content": "I almost give up my June strike with this problem, but found a solution without Heap. However I have to learn how to use Heap properly. I\\'m sure that my solution can be significantly speed up if I\\'ll use insertion in sorted array instead of append new element as the last and sorting after. Will revise June\\'s problems for solving them more optimal"
                    },
                    {
                        "username": "Lawliet4733",
                        "content": "1) The smallest sum will be formed by index 0 of nums1 and index 0 of nums2. \n2) The next smaller sum will be either from {index 0 of nums1 and index1 of nums2} or {index 1 of nums1 and index 0 of nums2}. \n\n\n\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "i would probably fail this in an interview ... the O(klgk) is tricky, but O(N^2lgk) is not "
                    },
                    {
                        "username": "kumawatashok1815",
                        "content": "can anyone tell me the what wrong with this solution .\\n\\n\\n\\n//MY OUTPUT :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[-4,7],[0,3],[0,3]]\\n//Expected :[[-10,3],[-10,5],[-10,6],[-10,7],[-10,8],[-4,3],[-4,5],[-4,6],[0,3],[0,3]]\\n\\n\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n\\n        Map<Integer,List<Integer> > map = new TreeMap<>();\\n        List<List<Integer>>finalResult = new ArrayList<>();\\n\\n        for(int i=0;i<num1.length;i++)\\n        { \\n            for(int j=0;j<num2.length;j++)\\n            {\\n                int sum = num1[i]+num2[j];\\n                List<Integer> l1 = new ArrayList<>();\\n                l1.add(num1[i]);\\n                l1.add(num2[j]);\\n                if(map.containsKey(sum))\\n                {\\n                    List<Integer> l2 = map.get(sum);\\n                    l2.addAll(l1);\\n                    map.put(sum,l2);\\n\\n                }\\n                else\\n                {\\n                   map.put(sum,l1);\\n                }\\n               \\n\\n            }\\n        }\\n\\n        int counter=0;\\n\\n        for(Integer key : map.keySet())\\n        {\\n            if(counter<k)\\n            {\\n               \\n                List<Integer> l1 = map.get(key);\\n                for(int i=0;i<l1.size();i+=2)\\n                {\\n                    List<Integer> l2 = new ArrayList<>();\\n                    l2.add(l1.get(i));\\n                    l2.add(l1.get(i+1));\\n                    finalResult.add(l2);    \\n                    counter++;\\n                    \\n                }\\n             \\n                \\n               \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return finalResult;\\n        \\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The logic of your code is almost correct, but you need to consider that in your case you\\'re creating one pair every two numbers, but the map does not have a limit per key. This means that for each sum, you\\'re trying to put as many pairs as there are in the cross product of the two input arrays that sum to that key. \\n\\nThis can cause issues if, for instance, there are many pairs that have the same sum. In your case, the `counter` could increment more than once within the inner `for` loop because the `if(counter<k)` condition is checked only at the beginning of each key in your map. As a result, you might end up adding more than `k` pairs to your `finalResult`.\\n\\nTo fix this, you should check if you\\'ve added `k` pairs after adding each pair, not after adding all pairs of a specific sum. If `counter` is equal to `k`, you should break from both loops.\\n\\nHere\\'s a corrected version of your code:\\n\\n```java\\npublic List<List<Integer>> kSmallestPairs(int[] num1, int[] num2, int k) {\\n    Map<Integer,List<Integer>> map = new TreeMap<>();\\n    List<List<Integer>>finalResult = new ArrayList<>();\\n\\n    for(int i=0;i<num1.length;i++) {\\n        for(int j=0;j<num2.length;j++) {\\n            int sum = num1[i]+num2[j];\\n            List<Integer> l1 = new ArrayList<>();\\n            l1.add(num1[i]);\\n            l1.add(num2[j]);\\n            map.putIfAbsent(sum, new ArrayList<>());\\n            map.get(sum).addAll(l1);\\n        }\\n    }\\n\\n    int counter=0;\\n    outer: \\n    for(Integer key : map.keySet()) {\\n        List<Integer> l1 = map.get(key);\\n        for(int i=0;i<l1.size();i+=2) {\\n            List<Integer> l2 = new ArrayList<>();\\n            l2.add(l1.get(i));\\n            l2.add(l1.get(i+1));\\n            finalResult.add(l2);\\n            counter++;\\n            if(counter==k)\\n                break outer;\\n        }\\n    }\\n\\n    return finalResult;\\n}\\n```\\n\\nIn the corrected code, I added the `outer:` label and the `break outer;` statement to exit both loops once `k` pairs have been added to `finalResult`.\\n\\nThis solution can solve the problem, but it might not be the most efficient one. There\\'s an alternative way to solve this problem by using a priority queue, which can have a better time complexity. This approach avoids storing all pairs and only maintains the smallest pairs, which is a more efficient use of memory."
                    },
                    {
                        "username": "sikora92",
                        "content": "Isn\\'t there some bug in test case 35? It tells my solution returns empty List, but I cannot reproduce it in my IDE."
                    },
                    {
                        "username": "sikora92",
                        "content": "Just nums1.length*nums2.length is bigger than integer range. Remember to use long. "
                    },
                    {
                        "username": "loloksEth",
                        "content": "2 ptr working there"
                    },
                    {
                        "username": "Nayanthara_P",
                        "content": "What is the 14th test case? For me, the test cases 13/35 pass without errors, but for the 14th one I don\\'t understand why I get the following error:\\n\\nnums1 =\\n[1,1,2]\\nnums2 =\\n[1,2,3]\\nk =\\n10\\nUse Testcase\\nOutput\\n[[1,1],[1,1],[1,2],[1,2],[2,1],[1,3],[1,3],[2,2],[2,2],[2,3]]\\nExpected\\n[[1,1],[1,1],[2,1],[1,2],[1,2],[2,2],[1,3],[1,3],[2,3]]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The discrepancy between your output and the expected output can be seen at the 5th pair. In the expected output, the 5th pair is [1,2], but in your output, the 5th pair is [2,1]. This is likely due to a difference in the order in which your program is processing the pairs. In this problem, the order of the pairs matters - [2,1] is not equivalent to [1,2] because 2 from nums1 and 1 from nums2 would be a greater sum than 1 from nums1 and 2 from nums2.\\n\\nYou might want to review your implementation to ensure that it is processing the pairs in the correct order"
                    },
                    {
                        "username": "xmmmir",
                        "content": "You\\'re somehow getting 10 pairs out of 3x3 matrix. [2,2] is duplicated."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "share the code please"
                    }
                ]
            },
            {
                "id": 1946450,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // Define a max-heap using the default greater comparator\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // Iterate over each pair (num1, num2)\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                // Calculate the sum of the pair (num1, num2)\\n                int sum = num1 + num2;\\n\\n                // Add pair (sum, num1, num2) to the max-heap\\n                maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                // If the size of max-heap exceeds K, remove the pair with the largest sum\\n                if (maxHeap.size() > k) {\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n\\n        // Extract the pairs from max-heap in the reverse order to get the final result\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());  // Reverse to get the pairs in ascending order of sum\\n\\n        return result;\\n    }\\n};\\n`\\n\\nIts showing TLE for a testcase, can someone help please :("
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is running into a time limit exceeded (TLE) error because it iterates over all possible pairs in `nums1` and `nums2` which has a time complexity of O(n^2) where `n` is the size of the arrays. \\n\\nAlso, for each pair, it is doing a push operation and a pop operation on the heap (when the heap size exceeds `k`). The time complexity of these operations is O(log(k)), so in total the time complexity will be O(n^2*log(k)). For large inputs of `n` and `k`, this could be too slow and result in a TLE.\\n\\nInstead of iterating over all pairs and maintaining a heap of size `k`, a more efficient approach is to use a min heap and only consider potential candidates for smallest pair. A pair `(i, j)` is a potential candidate if at least one of its adjacent pair `(i-1, j)` or `(i, j-1)` is already in the heap. \\n"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Leaderboard](/Leaderboard)  hi, i found a solution, so \\n\\n\\n`\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                int sum = num1 + num2;\\n\\n                if (maxHeap.size() < k || sum < maxHeap.top().first) {\\n                    maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                    if (maxHeap.size() > k) {\\n                        maxHeap.pop();\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n`  \\nThis updated code optimizes the inner loop by breaking early when the sum of the current smallest pair with the smallest element in nums2 exceeds the sum of the current pair being considered. This helps avoid unnecessary iterations and improves the performance of the solution.\\n"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "That\\'s $O(mn \\\\log{mn})$, which won\\'t work. "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "tried two pointers approach. understood it wont work, and checked the editorial to see the logic of acc soln. then tried on my own. but still, took some time to figure out the use of set/visited matrix.\\n\\na good problem, but frustrated me a lot lol"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "## Two Pointer approach fails\\nConsider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "after reading question statement it seems easy but not actually. "
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "In case someone else did the same, I started with two pointer approach as I thought it would be similar to the procedure followed during merging in merge sort, but after many trials I couldn\\'t get it work, although the heap approach is quite intuitive"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Should the k pairs be in ascending order in the output nested vector"
                    },
                    {
                        "username": "letrung",
                        "content": "This question is good for practicing heap, but I just wonder if my language is JS, then in a real interview how could we handle it. Should we prepare another language that supports built-in heap ds?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I would have thought that JS has both priority queues AND heap ds libraries but these are not difficult to code. Since I use C, I have to write all of these from scratch but I am getting good at it. If you had to write a ds library during your interview then that would be a valuable skill."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "This problem seems easy but too FRUSTRATING .\nI was thinking two pointer appraoch for nums1 and nums2 but it didn't worked for me.\n\nvector<vector<int>>ans;\n        int i=0,j=0;\n        while(k--){\n            while(i+1< nums1.size() && j+1<nums2.size()){\n               if(ans.size()==0)\n                ans.push_back({nums1[i],nums2[j]});\n                if(nums1[i]+nums2[j]>nums1[i+1]+nums2[j]){\n                    i=i+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n                if(nums1[i]+nums2[j]>nums1[i]+nums2[j+1]){\n                    j=j+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n\n                ++i,++j;\n            }\n        }\n        return ans;"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "Is there a unique answer in all cases? what if there are k+1 pairs with the lowest possible sum??"
                    }
                ]
            },
            {
                "id": 1946446,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // Define a max-heap using the default greater comparator\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // Iterate over each pair (num1, num2)\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                // Calculate the sum of the pair (num1, num2)\\n                int sum = num1 + num2;\\n\\n                // Add pair (sum, num1, num2) to the max-heap\\n                maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                // If the size of max-heap exceeds K, remove the pair with the largest sum\\n                if (maxHeap.size() > k) {\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n\\n        // Extract the pairs from max-heap in the reverse order to get the final result\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());  // Reverse to get the pairs in ascending order of sum\\n\\n        return result;\\n    }\\n};\\n`\\n\\nIts showing TLE for a testcase, can someone help please :("
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is running into a time limit exceeded (TLE) error because it iterates over all possible pairs in `nums1` and `nums2` which has a time complexity of O(n^2) where `n` is the size of the arrays. \\n\\nAlso, for each pair, it is doing a push operation and a pop operation on the heap (when the heap size exceeds `k`). The time complexity of these operations is O(log(k)), so in total the time complexity will be O(n^2*log(k)). For large inputs of `n` and `k`, this could be too slow and result in a TLE.\\n\\nInstead of iterating over all pairs and maintaining a heap of size `k`, a more efficient approach is to use a min heap and only consider potential candidates for smallest pair. A pair `(i, j)` is a potential candidate if at least one of its adjacent pair `(i-1, j)` or `(i, j-1)` is already in the heap. \\n"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Leaderboard](/Leaderboard)  hi, i found a solution, so \\n\\n\\n`\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                int sum = num1 + num2;\\n\\n                if (maxHeap.size() < k || sum < maxHeap.top().first) {\\n                    maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                    if (maxHeap.size() > k) {\\n                        maxHeap.pop();\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n`  \\nThis updated code optimizes the inner loop by breaking early when the sum of the current smallest pair with the smallest element in nums2 exceeds the sum of the current pair being considered. This helps avoid unnecessary iterations and improves the performance of the solution.\\n"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "That\\'s $O(mn \\\\log{mn})$, which won\\'t work. "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "tried two pointers approach. understood it wont work, and checked the editorial to see the logic of acc soln. then tried on my own. but still, took some time to figure out the use of set/visited matrix.\\n\\na good problem, but frustrated me a lot lol"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "## Two Pointer approach fails\\nConsider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "after reading question statement it seems easy but not actually. "
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "In case someone else did the same, I started with two pointer approach as I thought it would be similar to the procedure followed during merging in merge sort, but after many trials I couldn\\'t get it work, although the heap approach is quite intuitive"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Should the k pairs be in ascending order in the output nested vector"
                    },
                    {
                        "username": "letrung",
                        "content": "This question is good for practicing heap, but I just wonder if my language is JS, then in a real interview how could we handle it. Should we prepare another language that supports built-in heap ds?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I would have thought that JS has both priority queues AND heap ds libraries but these are not difficult to code. Since I use C, I have to write all of these from scratch but I am getting good at it. If you had to write a ds library during your interview then that would be a valuable skill."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "This problem seems easy but too FRUSTRATING .\nI was thinking two pointer appraoch for nums1 and nums2 but it didn't worked for me.\n\nvector<vector<int>>ans;\n        int i=0,j=0;\n        while(k--){\n            while(i+1< nums1.size() && j+1<nums2.size()){\n               if(ans.size()==0)\n                ans.push_back({nums1[i],nums2[j]});\n                if(nums1[i]+nums2[j]>nums1[i+1]+nums2[j]){\n                    i=i+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n                if(nums1[i]+nums2[j]>nums1[i]+nums2[j+1]){\n                    j=j+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n\n                ++i,++j;\n            }\n        }\n        return ans;"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "Is there a unique answer in all cases? what if there are k+1 pairs with the lowest possible sum??"
                    }
                ]
            },
            {
                "id": 1946412,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // Define a max-heap using the default greater comparator\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // Iterate over each pair (num1, num2)\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                // Calculate the sum of the pair (num1, num2)\\n                int sum = num1 + num2;\\n\\n                // Add pair (sum, num1, num2) to the max-heap\\n                maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                // If the size of max-heap exceeds K, remove the pair with the largest sum\\n                if (maxHeap.size() > k) {\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n\\n        // Extract the pairs from max-heap in the reverse order to get the final result\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());  // Reverse to get the pairs in ascending order of sum\\n\\n        return result;\\n    }\\n};\\n`\\n\\nIts showing TLE for a testcase, can someone help please :("
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is running into a time limit exceeded (TLE) error because it iterates over all possible pairs in `nums1` and `nums2` which has a time complexity of O(n^2) where `n` is the size of the arrays. \\n\\nAlso, for each pair, it is doing a push operation and a pop operation on the heap (when the heap size exceeds `k`). The time complexity of these operations is O(log(k)), so in total the time complexity will be O(n^2*log(k)). For large inputs of `n` and `k`, this could be too slow and result in a TLE.\\n\\nInstead of iterating over all pairs and maintaining a heap of size `k`, a more efficient approach is to use a min heap and only consider potential candidates for smallest pair. A pair `(i, j)` is a potential candidate if at least one of its adjacent pair `(i-1, j)` or `(i, j-1)` is already in the heap. \\n"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Leaderboard](/Leaderboard)  hi, i found a solution, so \\n\\n\\n`\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                int sum = num1 + num2;\\n\\n                if (maxHeap.size() < k || sum < maxHeap.top().first) {\\n                    maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                    if (maxHeap.size() > k) {\\n                        maxHeap.pop();\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n`  \\nThis updated code optimizes the inner loop by breaking early when the sum of the current smallest pair with the smallest element in nums2 exceeds the sum of the current pair being considered. This helps avoid unnecessary iterations and improves the performance of the solution.\\n"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "That\\'s $O(mn \\\\log{mn})$, which won\\'t work. "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "tried two pointers approach. understood it wont work, and checked the editorial to see the logic of acc soln. then tried on my own. but still, took some time to figure out the use of set/visited matrix.\\n\\na good problem, but frustrated me a lot lol"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "## Two Pointer approach fails\\nConsider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "after reading question statement it seems easy but not actually. "
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "In case someone else did the same, I started with two pointer approach as I thought it would be similar to the procedure followed during merging in merge sort, but after many trials I couldn\\'t get it work, although the heap approach is quite intuitive"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Should the k pairs be in ascending order in the output nested vector"
                    },
                    {
                        "username": "letrung",
                        "content": "This question is good for practicing heap, but I just wonder if my language is JS, then in a real interview how could we handle it. Should we prepare another language that supports built-in heap ds?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I would have thought that JS has both priority queues AND heap ds libraries but these are not difficult to code. Since I use C, I have to write all of these from scratch but I am getting good at it. If you had to write a ds library during your interview then that would be a valuable skill."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "This problem seems easy but too FRUSTRATING .\nI was thinking two pointer appraoch for nums1 and nums2 but it didn't worked for me.\n\nvector<vector<int>>ans;\n        int i=0,j=0;\n        while(k--){\n            while(i+1< nums1.size() && j+1<nums2.size()){\n               if(ans.size()==0)\n                ans.push_back({nums1[i],nums2[j]});\n                if(nums1[i]+nums2[j]>nums1[i+1]+nums2[j]){\n                    i=i+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n                if(nums1[i]+nums2[j]>nums1[i]+nums2[j+1]){\n                    j=j+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n\n                ++i,++j;\n            }\n        }\n        return ans;"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "Is there a unique answer in all cases? what if there are k+1 pairs with the lowest possible sum??"
                    }
                ]
            },
            {
                "id": 1946389,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // Define a max-heap using the default greater comparator\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // Iterate over each pair (num1, num2)\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                // Calculate the sum of the pair (num1, num2)\\n                int sum = num1 + num2;\\n\\n                // Add pair (sum, num1, num2) to the max-heap\\n                maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                // If the size of max-heap exceeds K, remove the pair with the largest sum\\n                if (maxHeap.size() > k) {\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n\\n        // Extract the pairs from max-heap in the reverse order to get the final result\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());  // Reverse to get the pairs in ascending order of sum\\n\\n        return result;\\n    }\\n};\\n`\\n\\nIts showing TLE for a testcase, can someone help please :("
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is running into a time limit exceeded (TLE) error because it iterates over all possible pairs in `nums1` and `nums2` which has a time complexity of O(n^2) where `n` is the size of the arrays. \\n\\nAlso, for each pair, it is doing a push operation and a pop operation on the heap (when the heap size exceeds `k`). The time complexity of these operations is O(log(k)), so in total the time complexity will be O(n^2*log(k)). For large inputs of `n` and `k`, this could be too slow and result in a TLE.\\n\\nInstead of iterating over all pairs and maintaining a heap of size `k`, a more efficient approach is to use a min heap and only consider potential candidates for smallest pair. A pair `(i, j)` is a potential candidate if at least one of its adjacent pair `(i-1, j)` or `(i, j-1)` is already in the heap. \\n"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Leaderboard](/Leaderboard)  hi, i found a solution, so \\n\\n\\n`\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                int sum = num1 + num2;\\n\\n                if (maxHeap.size() < k || sum < maxHeap.top().first) {\\n                    maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                    if (maxHeap.size() > k) {\\n                        maxHeap.pop();\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n`  \\nThis updated code optimizes the inner loop by breaking early when the sum of the current smallest pair with the smallest element in nums2 exceeds the sum of the current pair being considered. This helps avoid unnecessary iterations and improves the performance of the solution.\\n"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "That\\'s $O(mn \\\\log{mn})$, which won\\'t work. "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "tried two pointers approach. understood it wont work, and checked the editorial to see the logic of acc soln. then tried on my own. but still, took some time to figure out the use of set/visited matrix.\\n\\na good problem, but frustrated me a lot lol"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "## Two Pointer approach fails\\nConsider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "after reading question statement it seems easy but not actually. "
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "In case someone else did the same, I started with two pointer approach as I thought it would be similar to the procedure followed during merging in merge sort, but after many trials I couldn\\'t get it work, although the heap approach is quite intuitive"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Should the k pairs be in ascending order in the output nested vector"
                    },
                    {
                        "username": "letrung",
                        "content": "This question is good for practicing heap, but I just wonder if my language is JS, then in a real interview how could we handle it. Should we prepare another language that supports built-in heap ds?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I would have thought that JS has both priority queues AND heap ds libraries but these are not difficult to code. Since I use C, I have to write all of these from scratch but I am getting good at it. If you had to write a ds library during your interview then that would be a valuable skill."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "This problem seems easy but too FRUSTRATING .\nI was thinking two pointer appraoch for nums1 and nums2 but it didn't worked for me.\n\nvector<vector<int>>ans;\n        int i=0,j=0;\n        while(k--){\n            while(i+1< nums1.size() && j+1<nums2.size()){\n               if(ans.size()==0)\n                ans.push_back({nums1[i],nums2[j]});\n                if(nums1[i]+nums2[j]>nums1[i+1]+nums2[j]){\n                    i=i+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n                if(nums1[i]+nums2[j]>nums1[i]+nums2[j+1]){\n                    j=j+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n\n                ++i,++j;\n            }\n        }\n        return ans;"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "Is there a unique answer in all cases? what if there are k+1 pairs with the lowest possible sum??"
                    }
                ]
            },
            {
                "id": 1946381,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // Define a max-heap using the default greater comparator\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // Iterate over each pair (num1, num2)\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                // Calculate the sum of the pair (num1, num2)\\n                int sum = num1 + num2;\\n\\n                // Add pair (sum, num1, num2) to the max-heap\\n                maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                // If the size of max-heap exceeds K, remove the pair with the largest sum\\n                if (maxHeap.size() > k) {\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n\\n        // Extract the pairs from max-heap in the reverse order to get the final result\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());  // Reverse to get the pairs in ascending order of sum\\n\\n        return result;\\n    }\\n};\\n`\\n\\nIts showing TLE for a testcase, can someone help please :("
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is running into a time limit exceeded (TLE) error because it iterates over all possible pairs in `nums1` and `nums2` which has a time complexity of O(n^2) where `n` is the size of the arrays. \\n\\nAlso, for each pair, it is doing a push operation and a pop operation on the heap (when the heap size exceeds `k`). The time complexity of these operations is O(log(k)), so in total the time complexity will be O(n^2*log(k)). For large inputs of `n` and `k`, this could be too slow and result in a TLE.\\n\\nInstead of iterating over all pairs and maintaining a heap of size `k`, a more efficient approach is to use a min heap and only consider potential candidates for smallest pair. A pair `(i, j)` is a potential candidate if at least one of its adjacent pair `(i-1, j)` or `(i, j-1)` is already in the heap. \\n"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Leaderboard](/Leaderboard)  hi, i found a solution, so \\n\\n\\n`\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                int sum = num1 + num2;\\n\\n                if (maxHeap.size() < k || sum < maxHeap.top().first) {\\n                    maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                    if (maxHeap.size() > k) {\\n                        maxHeap.pop();\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n`  \\nThis updated code optimizes the inner loop by breaking early when the sum of the current smallest pair with the smallest element in nums2 exceeds the sum of the current pair being considered. This helps avoid unnecessary iterations and improves the performance of the solution.\\n"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "That\\'s $O(mn \\\\log{mn})$, which won\\'t work. "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "tried two pointers approach. understood it wont work, and checked the editorial to see the logic of acc soln. then tried on my own. but still, took some time to figure out the use of set/visited matrix.\\n\\na good problem, but frustrated me a lot lol"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "## Two Pointer approach fails\\nConsider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "after reading question statement it seems easy but not actually. "
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "In case someone else did the same, I started with two pointer approach as I thought it would be similar to the procedure followed during merging in merge sort, but after many trials I couldn\\'t get it work, although the heap approach is quite intuitive"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Should the k pairs be in ascending order in the output nested vector"
                    },
                    {
                        "username": "letrung",
                        "content": "This question is good for practicing heap, but I just wonder if my language is JS, then in a real interview how could we handle it. Should we prepare another language that supports built-in heap ds?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I would have thought that JS has both priority queues AND heap ds libraries but these are not difficult to code. Since I use C, I have to write all of these from scratch but I am getting good at it. If you had to write a ds library during your interview then that would be a valuable skill."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "This problem seems easy but too FRUSTRATING .\nI was thinking two pointer appraoch for nums1 and nums2 but it didn't worked for me.\n\nvector<vector<int>>ans;\n        int i=0,j=0;\n        while(k--){\n            while(i+1< nums1.size() && j+1<nums2.size()){\n               if(ans.size()==0)\n                ans.push_back({nums1[i],nums2[j]});\n                if(nums1[i]+nums2[j]>nums1[i+1]+nums2[j]){\n                    i=i+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n                if(nums1[i]+nums2[j]>nums1[i]+nums2[j+1]){\n                    j=j+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n\n                ++i,++j;\n            }\n        }\n        return ans;"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "Is there a unique answer in all cases? what if there are k+1 pairs with the lowest possible sum??"
                    }
                ]
            },
            {
                "id": 1946366,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // Define a max-heap using the default greater comparator\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // Iterate over each pair (num1, num2)\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                // Calculate the sum of the pair (num1, num2)\\n                int sum = num1 + num2;\\n\\n                // Add pair (sum, num1, num2) to the max-heap\\n                maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                // If the size of max-heap exceeds K, remove the pair with the largest sum\\n                if (maxHeap.size() > k) {\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n\\n        // Extract the pairs from max-heap in the reverse order to get the final result\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());  // Reverse to get the pairs in ascending order of sum\\n\\n        return result;\\n    }\\n};\\n`\\n\\nIts showing TLE for a testcase, can someone help please :("
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is running into a time limit exceeded (TLE) error because it iterates over all possible pairs in `nums1` and `nums2` which has a time complexity of O(n^2) where `n` is the size of the arrays. \\n\\nAlso, for each pair, it is doing a push operation and a pop operation on the heap (when the heap size exceeds `k`). The time complexity of these operations is O(log(k)), so in total the time complexity will be O(n^2*log(k)). For large inputs of `n` and `k`, this could be too slow and result in a TLE.\\n\\nInstead of iterating over all pairs and maintaining a heap of size `k`, a more efficient approach is to use a min heap and only consider potential candidates for smallest pair. A pair `(i, j)` is a potential candidate if at least one of its adjacent pair `(i-1, j)` or `(i, j-1)` is already in the heap. \\n"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Leaderboard](/Leaderboard)  hi, i found a solution, so \\n\\n\\n`\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                int sum = num1 + num2;\\n\\n                if (maxHeap.size() < k || sum < maxHeap.top().first) {\\n                    maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                    if (maxHeap.size() > k) {\\n                        maxHeap.pop();\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n`  \\nThis updated code optimizes the inner loop by breaking early when the sum of the current smallest pair with the smallest element in nums2 exceeds the sum of the current pair being considered. This helps avoid unnecessary iterations and improves the performance of the solution.\\n"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "That\\'s $O(mn \\\\log{mn})$, which won\\'t work. "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "tried two pointers approach. understood it wont work, and checked the editorial to see the logic of acc soln. then tried on my own. but still, took some time to figure out the use of set/visited matrix.\\n\\na good problem, but frustrated me a lot lol"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "## Two Pointer approach fails\\nConsider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "after reading question statement it seems easy but not actually. "
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "In case someone else did the same, I started with two pointer approach as I thought it would be similar to the procedure followed during merging in merge sort, but after many trials I couldn\\'t get it work, although the heap approach is quite intuitive"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Should the k pairs be in ascending order in the output nested vector"
                    },
                    {
                        "username": "letrung",
                        "content": "This question is good for practicing heap, but I just wonder if my language is JS, then in a real interview how could we handle it. Should we prepare another language that supports built-in heap ds?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I would have thought that JS has both priority queues AND heap ds libraries but these are not difficult to code. Since I use C, I have to write all of these from scratch but I am getting good at it. If you had to write a ds library during your interview then that would be a valuable skill."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "This problem seems easy but too FRUSTRATING .\nI was thinking two pointer appraoch for nums1 and nums2 but it didn't worked for me.\n\nvector<vector<int>>ans;\n        int i=0,j=0;\n        while(k--){\n            while(i+1< nums1.size() && j+1<nums2.size()){\n               if(ans.size()==0)\n                ans.push_back({nums1[i],nums2[j]});\n                if(nums1[i]+nums2[j]>nums1[i+1]+nums2[j]){\n                    i=i+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n                if(nums1[i]+nums2[j]>nums1[i]+nums2[j+1]){\n                    j=j+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n\n                ++i,++j;\n            }\n        }\n        return ans;"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "Is there a unique answer in all cases? what if there are k+1 pairs with the lowest possible sum??"
                    }
                ]
            },
            {
                "id": 1946358,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // Define a max-heap using the default greater comparator\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // Iterate over each pair (num1, num2)\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                // Calculate the sum of the pair (num1, num2)\\n                int sum = num1 + num2;\\n\\n                // Add pair (sum, num1, num2) to the max-heap\\n                maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                // If the size of max-heap exceeds K, remove the pair with the largest sum\\n                if (maxHeap.size() > k) {\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n\\n        // Extract the pairs from max-heap in the reverse order to get the final result\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());  // Reverse to get the pairs in ascending order of sum\\n\\n        return result;\\n    }\\n};\\n`\\n\\nIts showing TLE for a testcase, can someone help please :("
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is running into a time limit exceeded (TLE) error because it iterates over all possible pairs in `nums1` and `nums2` which has a time complexity of O(n^2) where `n` is the size of the arrays. \\n\\nAlso, for each pair, it is doing a push operation and a pop operation on the heap (when the heap size exceeds `k`). The time complexity of these operations is O(log(k)), so in total the time complexity will be O(n^2*log(k)). For large inputs of `n` and `k`, this could be too slow and result in a TLE.\\n\\nInstead of iterating over all pairs and maintaining a heap of size `k`, a more efficient approach is to use a min heap and only consider potential candidates for smallest pair. A pair `(i, j)` is a potential candidate if at least one of its adjacent pair `(i-1, j)` or `(i, j-1)` is already in the heap. \\n"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Leaderboard](/Leaderboard)  hi, i found a solution, so \\n\\n\\n`\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                int sum = num1 + num2;\\n\\n                if (maxHeap.size() < k || sum < maxHeap.top().first) {\\n                    maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                    if (maxHeap.size() > k) {\\n                        maxHeap.pop();\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n`  \\nThis updated code optimizes the inner loop by breaking early when the sum of the current smallest pair with the smallest element in nums2 exceeds the sum of the current pair being considered. This helps avoid unnecessary iterations and improves the performance of the solution.\\n"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "That\\'s $O(mn \\\\log{mn})$, which won\\'t work. "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "tried two pointers approach. understood it wont work, and checked the editorial to see the logic of acc soln. then tried on my own. but still, took some time to figure out the use of set/visited matrix.\\n\\na good problem, but frustrated me a lot lol"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "## Two Pointer approach fails\\nConsider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "after reading question statement it seems easy but not actually. "
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "In case someone else did the same, I started with two pointer approach as I thought it would be similar to the procedure followed during merging in merge sort, but after many trials I couldn\\'t get it work, although the heap approach is quite intuitive"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Should the k pairs be in ascending order in the output nested vector"
                    },
                    {
                        "username": "letrung",
                        "content": "This question is good for practicing heap, but I just wonder if my language is JS, then in a real interview how could we handle it. Should we prepare another language that supports built-in heap ds?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I would have thought that JS has both priority queues AND heap ds libraries but these are not difficult to code. Since I use C, I have to write all of these from scratch but I am getting good at it. If you had to write a ds library during your interview then that would be a valuable skill."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "This problem seems easy but too FRUSTRATING .\nI was thinking two pointer appraoch for nums1 and nums2 but it didn't worked for me.\n\nvector<vector<int>>ans;\n        int i=0,j=0;\n        while(k--){\n            while(i+1< nums1.size() && j+1<nums2.size()){\n               if(ans.size()==0)\n                ans.push_back({nums1[i],nums2[j]});\n                if(nums1[i]+nums2[j]>nums1[i+1]+nums2[j]){\n                    i=i+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n                if(nums1[i]+nums2[j]>nums1[i]+nums2[j+1]){\n                    j=j+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n\n                ++i,++j;\n            }\n        }\n        return ans;"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "Is there a unique answer in all cases? what if there are k+1 pairs with the lowest possible sum??"
                    }
                ]
            },
            {
                "id": 1946303,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // Define a max-heap using the default greater comparator\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // Iterate over each pair (num1, num2)\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                // Calculate the sum of the pair (num1, num2)\\n                int sum = num1 + num2;\\n\\n                // Add pair (sum, num1, num2) to the max-heap\\n                maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                // If the size of max-heap exceeds K, remove the pair with the largest sum\\n                if (maxHeap.size() > k) {\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n\\n        // Extract the pairs from max-heap in the reverse order to get the final result\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());  // Reverse to get the pairs in ascending order of sum\\n\\n        return result;\\n    }\\n};\\n`\\n\\nIts showing TLE for a testcase, can someone help please :("
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is running into a time limit exceeded (TLE) error because it iterates over all possible pairs in `nums1` and `nums2` which has a time complexity of O(n^2) where `n` is the size of the arrays. \\n\\nAlso, for each pair, it is doing a push operation and a pop operation on the heap (when the heap size exceeds `k`). The time complexity of these operations is O(log(k)), so in total the time complexity will be O(n^2*log(k)). For large inputs of `n` and `k`, this could be too slow and result in a TLE.\\n\\nInstead of iterating over all pairs and maintaining a heap of size `k`, a more efficient approach is to use a min heap and only consider potential candidates for smallest pair. A pair `(i, j)` is a potential candidate if at least one of its adjacent pair `(i-1, j)` or `(i, j-1)` is already in the heap. \\n"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Leaderboard](/Leaderboard)  hi, i found a solution, so \\n\\n\\n`\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                int sum = num1 + num2;\\n\\n                if (maxHeap.size() < k || sum < maxHeap.top().first) {\\n                    maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                    if (maxHeap.size() > k) {\\n                        maxHeap.pop();\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n`  \\nThis updated code optimizes the inner loop by breaking early when the sum of the current smallest pair with the smallest element in nums2 exceeds the sum of the current pair being considered. This helps avoid unnecessary iterations and improves the performance of the solution.\\n"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "That\\'s $O(mn \\\\log{mn})$, which won\\'t work. "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "tried two pointers approach. understood it wont work, and checked the editorial to see the logic of acc soln. then tried on my own. but still, took some time to figure out the use of set/visited matrix.\\n\\na good problem, but frustrated me a lot lol"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "## Two Pointer approach fails\\nConsider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "after reading question statement it seems easy but not actually. "
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "In case someone else did the same, I started with two pointer approach as I thought it would be similar to the procedure followed during merging in merge sort, but after many trials I couldn\\'t get it work, although the heap approach is quite intuitive"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Should the k pairs be in ascending order in the output nested vector"
                    },
                    {
                        "username": "letrung",
                        "content": "This question is good for practicing heap, but I just wonder if my language is JS, then in a real interview how could we handle it. Should we prepare another language that supports built-in heap ds?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I would have thought that JS has both priority queues AND heap ds libraries but these are not difficult to code. Since I use C, I have to write all of these from scratch but I am getting good at it. If you had to write a ds library during your interview then that would be a valuable skill."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "This problem seems easy but too FRUSTRATING .\nI was thinking two pointer appraoch for nums1 and nums2 but it didn't worked for me.\n\nvector<vector<int>>ans;\n        int i=0,j=0;\n        while(k--){\n            while(i+1< nums1.size() && j+1<nums2.size()){\n               if(ans.size()==0)\n                ans.push_back({nums1[i],nums2[j]});\n                if(nums1[i]+nums2[j]>nums1[i+1]+nums2[j]){\n                    i=i+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n                if(nums1[i]+nums2[j]>nums1[i]+nums2[j+1]){\n                    j=j+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n\n                ++i,++j;\n            }\n        }\n        return ans;"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "Is there a unique answer in all cases? what if there are k+1 pairs with the lowest possible sum??"
                    }
                ]
            },
            {
                "id": 1946291,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // Define a max-heap using the default greater comparator\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // Iterate over each pair (num1, num2)\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                // Calculate the sum of the pair (num1, num2)\\n                int sum = num1 + num2;\\n\\n                // Add pair (sum, num1, num2) to the max-heap\\n                maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                // If the size of max-heap exceeds K, remove the pair with the largest sum\\n                if (maxHeap.size() > k) {\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n\\n        // Extract the pairs from max-heap in the reverse order to get the final result\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());  // Reverse to get the pairs in ascending order of sum\\n\\n        return result;\\n    }\\n};\\n`\\n\\nIts showing TLE for a testcase, can someone help please :("
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is running into a time limit exceeded (TLE) error because it iterates over all possible pairs in `nums1` and `nums2` which has a time complexity of O(n^2) where `n` is the size of the arrays. \\n\\nAlso, for each pair, it is doing a push operation and a pop operation on the heap (when the heap size exceeds `k`). The time complexity of these operations is O(log(k)), so in total the time complexity will be O(n^2*log(k)). For large inputs of `n` and `k`, this could be too slow and result in a TLE.\\n\\nInstead of iterating over all pairs and maintaining a heap of size `k`, a more efficient approach is to use a min heap and only consider potential candidates for smallest pair. A pair `(i, j)` is a potential candidate if at least one of its adjacent pair `(i-1, j)` or `(i, j-1)` is already in the heap. \\n"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Leaderboard](/Leaderboard)  hi, i found a solution, so \\n\\n\\n`\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                int sum = num1 + num2;\\n\\n                if (maxHeap.size() < k || sum < maxHeap.top().first) {\\n                    maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                    if (maxHeap.size() > k) {\\n                        maxHeap.pop();\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n`  \\nThis updated code optimizes the inner loop by breaking early when the sum of the current smallest pair with the smallest element in nums2 exceeds the sum of the current pair being considered. This helps avoid unnecessary iterations and improves the performance of the solution.\\n"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "That\\'s $O(mn \\\\log{mn})$, which won\\'t work. "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "tried two pointers approach. understood it wont work, and checked the editorial to see the logic of acc soln. then tried on my own. but still, took some time to figure out the use of set/visited matrix.\\n\\na good problem, but frustrated me a lot lol"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "## Two Pointer approach fails\\nConsider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "after reading question statement it seems easy but not actually. "
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "In case someone else did the same, I started with two pointer approach as I thought it would be similar to the procedure followed during merging in merge sort, but after many trials I couldn\\'t get it work, although the heap approach is quite intuitive"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Should the k pairs be in ascending order in the output nested vector"
                    },
                    {
                        "username": "letrung",
                        "content": "This question is good for practicing heap, but I just wonder if my language is JS, then in a real interview how could we handle it. Should we prepare another language that supports built-in heap ds?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I would have thought that JS has both priority queues AND heap ds libraries but these are not difficult to code. Since I use C, I have to write all of these from scratch but I am getting good at it. If you had to write a ds library during your interview then that would be a valuable skill."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "This problem seems easy but too FRUSTRATING .\nI was thinking two pointer appraoch for nums1 and nums2 but it didn't worked for me.\n\nvector<vector<int>>ans;\n        int i=0,j=0;\n        while(k--){\n            while(i+1< nums1.size() && j+1<nums2.size()){\n               if(ans.size()==0)\n                ans.push_back({nums1[i],nums2[j]});\n                if(nums1[i]+nums2[j]>nums1[i+1]+nums2[j]){\n                    i=i+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n                if(nums1[i]+nums2[j]>nums1[i]+nums2[j+1]){\n                    j=j+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n\n                ++i,++j;\n            }\n        }\n        return ans;"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "Is there a unique answer in all cases? what if there are k+1 pairs with the lowest possible sum??"
                    }
                ]
            },
            {
                "id": 1946271,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "I am also curious for some test cases, k>n^2. How come that be possible? You can only form n^2 pairs from vectors of size n, this is insane."
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        // Define a max-heap using the default greater comparator\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        // Iterate over each pair (num1, num2)\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                // Calculate the sum of the pair (num1, num2)\\n                int sum = num1 + num2;\\n\\n                // Add pair (sum, num1, num2) to the max-heap\\n                maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                // If the size of max-heap exceeds K, remove the pair with the largest sum\\n                if (maxHeap.size() > k) {\\n                    maxHeap.pop();\\n                }\\n            }\\n        }\\n\\n        // Extract the pairs from max-heap in the reverse order to get the final result\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());  // Reverse to get the pairs in ascending order of sum\\n\\n        return result;\\n    }\\n};\\n`\\n\\nIts showing TLE for a testcase, can someone help please :("
                    },
                    {
                        "username": "bparanj",
                        "content": "This solution is running into a time limit exceeded (TLE) error because it iterates over all possible pairs in `nums1` and `nums2` which has a time complexity of O(n^2) where `n` is the size of the arrays. \\n\\nAlso, for each pair, it is doing a push operation and a pop operation on the heap (when the heap size exceeds `k`). The time complexity of these operations is O(log(k)), so in total the time complexity will be O(n^2*log(k)). For large inputs of `n` and `k`, this could be too slow and result in a TLE.\\n\\nInstead of iterating over all pairs and maintaining a heap of size `k`, a more efficient approach is to use a min heap and only consider potential candidates for smallest pair. A pair `(i, j)` is a potential candidate if at least one of its adjacent pair `(i-1, j)` or `(i, j-1)` is already in the heap. \\n"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Leaderboard](/Leaderboard)  hi, i found a solution, so \\n\\n\\n`\\nclass Solution {\\npublic:\\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\\n        priority_queue<pair<int, pair<int, int>>> maxHeap;\\n\\n        for (int num1 : nums1) {\\n            for (int num2 : nums2) {\\n                int sum = num1 + num2;\\n\\n                if (maxHeap.size() < k || sum < maxHeap.top().first) {\\n                    maxHeap.push(make_pair(sum, make_pair(num1, num2)));\\n\\n                    if (maxHeap.size() > k) {\\n                        maxHeap.pop();\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!maxHeap.empty()) {\\n            vector<int> pair = {maxHeap.top().second.first, maxHeap.top().second.second};\\n            result.push_back(pair);\\n            maxHeap.pop();\\n        }\\n        reverse(result.begin(), result.end());\\n\\n        return result;\\n    }\\n};\\n`  \\nThis updated code optimizes the inner loop by breaking early when the sum of the current smallest pair with the smallest element in nums2 exceeds the sum of the current pair being considered. This helps avoid unnecessary iterations and improves the performance of the solution.\\n"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "That\\'s $O(mn \\\\log{mn})$, which won\\'t work. "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "tried two pointers approach. understood it wont work, and checked the editorial to see the logic of acc soln. then tried on my own. but still, took some time to figure out the use of set/visited matrix.\\n\\na good problem, but frustrated me a lot lol"
                    },
                    {
                        "username": "kbbhatt04",
                        "content": "## Two Pointer approach fails\\nConsider this testcase:\\nnums1 = [1,1,2]\\nnums2 = [1,2,3]\\nk = 10\\n\\nIn this when you maintain two pointers (i and j), and say you reach i = 2 and j = 0. So you will add the pair [nums1[i], nums2[j]] to the answer vector and then increment j.\\n\\nNow i = 2 and j = 1. But before [nums1[i], nums2[j]] can make pair of [2, 2], you also need pairs of [nums1[0], nums2[1]], [nums1[1], nums2[1]] i.e. [1,2] and [1,2]. \\n\\nBy maintaining two pointer such as i and j, you will miss out on these pairs. Thus this approach fails."
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "after reading question statement it seems easy but not actually. "
                    },
                    {
                        "username": "abhinavshukla693",
                        "content": "In case someone else did the same, I started with two pointer approach as I thought it would be similar to the procedure followed during merging in merge sort, but after many trials I couldn\\'t get it work, although the heap approach is quite intuitive"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Should the k pairs be in ascending order in the output nested vector"
                    },
                    {
                        "username": "letrung",
                        "content": "This question is good for practicing heap, but I just wonder if my language is JS, then in a real interview how could we handle it. Should we prepare another language that supports built-in heap ds?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I would have thought that JS has both priority queues AND heap ds libraries but these are not difficult to code. Since I use C, I have to write all of these from scratch but I am getting good at it. If you had to write a ds library during your interview then that would be a valuable skill."
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "This problem seems easy but too FRUSTRATING .\nI was thinking two pointer appraoch for nums1 and nums2 but it didn't worked for me.\n\nvector<vector<int>>ans;\n        int i=0,j=0;\n        while(k--){\n            while(i+1< nums1.size() && j+1<nums2.size()){\n               if(ans.size()==0)\n                ans.push_back({nums1[i],nums2[j]});\n                if(nums1[i]+nums2[j]>nums1[i+1]+nums2[j]){\n                    i=i+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n                if(nums1[i]+nums2[j]>nums1[i]+nums2[j+1]){\n                    j=j+1;\n                    ans.push_back({nums1[i],nums2[j]});\n                }\n\n                ++i,++j;\n            }\n        }\n        return ans;"
                    },
                    {
                        "username": "joshuamahadevan1",
                        "content": "Is there a unique answer in all cases? what if there are k+1 pairs with the lowest possible sum??"
                    }
                ]
            },
            {
                "id": 1946262,
                "content": [
                    {
                        "username": "Isha307",
                        "content": "Non-Stop priority queue "
                    },
                    {
                        "username": "SouravGoyal8",
                        "content": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        PriorityQueue<Pair>queue = new PriorityQueue<>((a,b) -> a.val - b.val);\\n        HashSet<String>set = new HashSet<>();\\n        List<List<Integer>>arr = new ArrayList<>();\\n        queue.add(new Pair(nums1[0] + nums2[0],0,0));\\n        while(k > 0 && !queue.isEmpty()){\\n            Pair p = queue.poll();\\n            int x = p.x;\\n            int y = p.y;\\n            arr.add(new ArrayList<>(Arrays.asList(nums1[x],nums2[y])));\\n            if(x+1 < n && set.add((x+1) + \"\" + y)){\\n                queue.add(new Pair(nums1[x+1] + nums2[y],x+1,y));\\n            }\\n            if(y+1 < m && set.add((x) + \"\" + (y+1))){\\n                queue.add(new Pair(nums1[x] + nums2[y+1],x,y+1));\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n\\nclass Pair{\\n    int val;\\n    int x;\\n    int y;\\n    public Pair(int val,int x,int y){\\n        this.val = val;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nthis code gives wrong answer, can anyone explain why this happen?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not until you format the code."
                    },
                    {
                        "username": "Akashsb",
                        "content": "A great question .\\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "used a MIN heap at first go but needed to alter my thinking."
                    },
                    {
                        "username": "kartikey_999",
                        "content": "why to use terms like \"non-decreasing\" when you cant use it properly, here the arrays are non-decreasing and not increasing."
                    },
                    {
                        "username": "dongmingli-Ben",
                        "content": "For anyone who gets a TLE using heap/priority queue, you need to store the sum into the heap besides the indices. It works though I have no idea why I should do it."
                    },
                    {
                        "username": "psionl0",
                        "content": "Not necessary for me."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "HEAP DAYS"
                    },
                    {
                        "username": "031_harsh",
                        "content": "Now onwards leetcode will mad on heap xD"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "This is a much much better question than I initially expected. "
                    },
                    {
                        "username": "marco_seven",
                        "content": "question is not easy but the descriptions made questions easy,,\\nif anyone can understand the description then they can solve it, else noo............"
                    }
                ]
            },
            {
                "id": 1946228,
                "content": [
                    {
                        "username": "Isha307",
                        "content": "Non-Stop priority queue "
                    },
                    {
                        "username": "SouravGoyal8",
                        "content": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        PriorityQueue<Pair>queue = new PriorityQueue<>((a,b) -> a.val - b.val);\\n        HashSet<String>set = new HashSet<>();\\n        List<List<Integer>>arr = new ArrayList<>();\\n        queue.add(new Pair(nums1[0] + nums2[0],0,0));\\n        while(k > 0 && !queue.isEmpty()){\\n            Pair p = queue.poll();\\n            int x = p.x;\\n            int y = p.y;\\n            arr.add(new ArrayList<>(Arrays.asList(nums1[x],nums2[y])));\\n            if(x+1 < n && set.add((x+1) + \"\" + y)){\\n                queue.add(new Pair(nums1[x+1] + nums2[y],x+1,y));\\n            }\\n            if(y+1 < m && set.add((x) + \"\" + (y+1))){\\n                queue.add(new Pair(nums1[x] + nums2[y+1],x,y+1));\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n\\nclass Pair{\\n    int val;\\n    int x;\\n    int y;\\n    public Pair(int val,int x,int y){\\n        this.val = val;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nthis code gives wrong answer, can anyone explain why this happen?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not until you format the code."
                    },
                    {
                        "username": "Akashsb",
                        "content": "A great question .\\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "used a MIN heap at first go but needed to alter my thinking."
                    },
                    {
                        "username": "kartikey_999",
                        "content": "why to use terms like \"non-decreasing\" when you cant use it properly, here the arrays are non-decreasing and not increasing."
                    },
                    {
                        "username": "dongmingli-Ben",
                        "content": "For anyone who gets a TLE using heap/priority queue, you need to store the sum into the heap besides the indices. It works though I have no idea why I should do it."
                    },
                    {
                        "username": "psionl0",
                        "content": "Not necessary for me."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "HEAP DAYS"
                    },
                    {
                        "username": "031_harsh",
                        "content": "Now onwards leetcode will mad on heap xD"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "This is a much much better question than I initially expected. "
                    },
                    {
                        "username": "marco_seven",
                        "content": "question is not easy but the descriptions made questions easy,,\\nif anyone can understand the description then they can solve it, else noo............"
                    }
                ]
            },
            {
                "id": 1946195,
                "content": [
                    {
                        "username": "Isha307",
                        "content": "Non-Stop priority queue "
                    },
                    {
                        "username": "SouravGoyal8",
                        "content": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        PriorityQueue<Pair>queue = new PriorityQueue<>((a,b) -> a.val - b.val);\\n        HashSet<String>set = new HashSet<>();\\n        List<List<Integer>>arr = new ArrayList<>();\\n        queue.add(new Pair(nums1[0] + nums2[0],0,0));\\n        while(k > 0 && !queue.isEmpty()){\\n            Pair p = queue.poll();\\n            int x = p.x;\\n            int y = p.y;\\n            arr.add(new ArrayList<>(Arrays.asList(nums1[x],nums2[y])));\\n            if(x+1 < n && set.add((x+1) + \"\" + y)){\\n                queue.add(new Pair(nums1[x+1] + nums2[y],x+1,y));\\n            }\\n            if(y+1 < m && set.add((x) + \"\" + (y+1))){\\n                queue.add(new Pair(nums1[x] + nums2[y+1],x,y+1));\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n\\nclass Pair{\\n    int val;\\n    int x;\\n    int y;\\n    public Pair(int val,int x,int y){\\n        this.val = val;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nthis code gives wrong answer, can anyone explain why this happen?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not until you format the code."
                    },
                    {
                        "username": "Akashsb",
                        "content": "A great question .\\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "used a MIN heap at first go but needed to alter my thinking."
                    },
                    {
                        "username": "kartikey_999",
                        "content": "why to use terms like \"non-decreasing\" when you cant use it properly, here the arrays are non-decreasing and not increasing."
                    },
                    {
                        "username": "dongmingli-Ben",
                        "content": "For anyone who gets a TLE using heap/priority queue, you need to store the sum into the heap besides the indices. It works though I have no idea why I should do it."
                    },
                    {
                        "username": "psionl0",
                        "content": "Not necessary for me."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "HEAP DAYS"
                    },
                    {
                        "username": "031_harsh",
                        "content": "Now onwards leetcode will mad on heap xD"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "This is a much much better question than I initially expected. "
                    },
                    {
                        "username": "marco_seven",
                        "content": "question is not easy but the descriptions made questions easy,,\\nif anyone can understand the description then they can solve it, else noo............"
                    }
                ]
            },
            {
                "id": 1946115,
                "content": [
                    {
                        "username": "Isha307",
                        "content": "Non-Stop priority queue "
                    },
                    {
                        "username": "SouravGoyal8",
                        "content": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        PriorityQueue<Pair>queue = new PriorityQueue<>((a,b) -> a.val - b.val);\\n        HashSet<String>set = new HashSet<>();\\n        List<List<Integer>>arr = new ArrayList<>();\\n        queue.add(new Pair(nums1[0] + nums2[0],0,0));\\n        while(k > 0 && !queue.isEmpty()){\\n            Pair p = queue.poll();\\n            int x = p.x;\\n            int y = p.y;\\n            arr.add(new ArrayList<>(Arrays.asList(nums1[x],nums2[y])));\\n            if(x+1 < n && set.add((x+1) + \"\" + y)){\\n                queue.add(new Pair(nums1[x+1] + nums2[y],x+1,y));\\n            }\\n            if(y+1 < m && set.add((x) + \"\" + (y+1))){\\n                queue.add(new Pair(nums1[x] + nums2[y+1],x,y+1));\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n\\nclass Pair{\\n    int val;\\n    int x;\\n    int y;\\n    public Pair(int val,int x,int y){\\n        this.val = val;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nthis code gives wrong answer, can anyone explain why this happen?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not until you format the code."
                    },
                    {
                        "username": "Akashsb",
                        "content": "A great question .\\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "used a MIN heap at first go but needed to alter my thinking."
                    },
                    {
                        "username": "kartikey_999",
                        "content": "why to use terms like \"non-decreasing\" when you cant use it properly, here the arrays are non-decreasing and not increasing."
                    },
                    {
                        "username": "dongmingli-Ben",
                        "content": "For anyone who gets a TLE using heap/priority queue, you need to store the sum into the heap besides the indices. It works though I have no idea why I should do it."
                    },
                    {
                        "username": "psionl0",
                        "content": "Not necessary for me."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "HEAP DAYS"
                    },
                    {
                        "username": "031_harsh",
                        "content": "Now onwards leetcode will mad on heap xD"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "This is a much much better question than I initially expected. "
                    },
                    {
                        "username": "marco_seven",
                        "content": "question is not easy but the descriptions made questions easy,,\\nif anyone can understand the description then they can solve it, else noo............"
                    }
                ]
            },
            {
                "id": 1946102,
                "content": [
                    {
                        "username": "Isha307",
                        "content": "Non-Stop priority queue "
                    },
                    {
                        "username": "SouravGoyal8",
                        "content": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        PriorityQueue<Pair>queue = new PriorityQueue<>((a,b) -> a.val - b.val);\\n        HashSet<String>set = new HashSet<>();\\n        List<List<Integer>>arr = new ArrayList<>();\\n        queue.add(new Pair(nums1[0] + nums2[0],0,0));\\n        while(k > 0 && !queue.isEmpty()){\\n            Pair p = queue.poll();\\n            int x = p.x;\\n            int y = p.y;\\n            arr.add(new ArrayList<>(Arrays.asList(nums1[x],nums2[y])));\\n            if(x+1 < n && set.add((x+1) + \"\" + y)){\\n                queue.add(new Pair(nums1[x+1] + nums2[y],x+1,y));\\n            }\\n            if(y+1 < m && set.add((x) + \"\" + (y+1))){\\n                queue.add(new Pair(nums1[x] + nums2[y+1],x,y+1));\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n\\nclass Pair{\\n    int val;\\n    int x;\\n    int y;\\n    public Pair(int val,int x,int y){\\n        this.val = val;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nthis code gives wrong answer, can anyone explain why this happen?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not until you format the code."
                    },
                    {
                        "username": "Akashsb",
                        "content": "A great question .\\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "used a MIN heap at first go but needed to alter my thinking."
                    },
                    {
                        "username": "kartikey_999",
                        "content": "why to use terms like \"non-decreasing\" when you cant use it properly, here the arrays are non-decreasing and not increasing."
                    },
                    {
                        "username": "dongmingli-Ben",
                        "content": "For anyone who gets a TLE using heap/priority queue, you need to store the sum into the heap besides the indices. It works though I have no idea why I should do it."
                    },
                    {
                        "username": "psionl0",
                        "content": "Not necessary for me."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "HEAP DAYS"
                    },
                    {
                        "username": "031_harsh",
                        "content": "Now onwards leetcode will mad on heap xD"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "This is a much much better question than I initially expected. "
                    },
                    {
                        "username": "marco_seven",
                        "content": "question is not easy but the descriptions made questions easy,,\\nif anyone can understand the description then they can solve it, else noo............"
                    }
                ]
            },
            {
                "id": 1946091,
                "content": [
                    {
                        "username": "Isha307",
                        "content": "Non-Stop priority queue "
                    },
                    {
                        "username": "SouravGoyal8",
                        "content": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        PriorityQueue<Pair>queue = new PriorityQueue<>((a,b) -> a.val - b.val);\\n        HashSet<String>set = new HashSet<>();\\n        List<List<Integer>>arr = new ArrayList<>();\\n        queue.add(new Pair(nums1[0] + nums2[0],0,0));\\n        while(k > 0 && !queue.isEmpty()){\\n            Pair p = queue.poll();\\n            int x = p.x;\\n            int y = p.y;\\n            arr.add(new ArrayList<>(Arrays.asList(nums1[x],nums2[y])));\\n            if(x+1 < n && set.add((x+1) + \"\" + y)){\\n                queue.add(new Pair(nums1[x+1] + nums2[y],x+1,y));\\n            }\\n            if(y+1 < m && set.add((x) + \"\" + (y+1))){\\n                queue.add(new Pair(nums1[x] + nums2[y+1],x,y+1));\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n\\nclass Pair{\\n    int val;\\n    int x;\\n    int y;\\n    public Pair(int val,int x,int y){\\n        this.val = val;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nthis code gives wrong answer, can anyone explain why this happen?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not until you format the code."
                    },
                    {
                        "username": "Akashsb",
                        "content": "A great question .\\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "used a MIN heap at first go but needed to alter my thinking."
                    },
                    {
                        "username": "kartikey_999",
                        "content": "why to use terms like \"non-decreasing\" when you cant use it properly, here the arrays are non-decreasing and not increasing."
                    },
                    {
                        "username": "dongmingli-Ben",
                        "content": "For anyone who gets a TLE using heap/priority queue, you need to store the sum into the heap besides the indices. It works though I have no idea why I should do it."
                    },
                    {
                        "username": "psionl0",
                        "content": "Not necessary for me."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "HEAP DAYS"
                    },
                    {
                        "username": "031_harsh",
                        "content": "Now onwards leetcode will mad on heap xD"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "This is a much much better question than I initially expected. "
                    },
                    {
                        "username": "marco_seven",
                        "content": "question is not easy but the descriptions made questions easy,,\\nif anyone can understand the description then they can solve it, else noo............"
                    }
                ]
            },
            {
                "id": 1946086,
                "content": [
                    {
                        "username": "Isha307",
                        "content": "Non-Stop priority queue "
                    },
                    {
                        "username": "SouravGoyal8",
                        "content": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        PriorityQueue<Pair>queue = new PriorityQueue<>((a,b) -> a.val - b.val);\\n        HashSet<String>set = new HashSet<>();\\n        List<List<Integer>>arr = new ArrayList<>();\\n        queue.add(new Pair(nums1[0] + nums2[0],0,0));\\n        while(k > 0 && !queue.isEmpty()){\\n            Pair p = queue.poll();\\n            int x = p.x;\\n            int y = p.y;\\n            arr.add(new ArrayList<>(Arrays.asList(nums1[x],nums2[y])));\\n            if(x+1 < n && set.add((x+1) + \"\" + y)){\\n                queue.add(new Pair(nums1[x+1] + nums2[y],x+1,y));\\n            }\\n            if(y+1 < m && set.add((x) + \"\" + (y+1))){\\n                queue.add(new Pair(nums1[x] + nums2[y+1],x,y+1));\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n\\nclass Pair{\\n    int val;\\n    int x;\\n    int y;\\n    public Pair(int val,int x,int y){\\n        this.val = val;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nthis code gives wrong answer, can anyone explain why this happen?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not until you format the code."
                    },
                    {
                        "username": "Akashsb",
                        "content": "A great question .\\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "used a MIN heap at first go but needed to alter my thinking."
                    },
                    {
                        "username": "kartikey_999",
                        "content": "why to use terms like \"non-decreasing\" when you cant use it properly, here the arrays are non-decreasing and not increasing."
                    },
                    {
                        "username": "dongmingli-Ben",
                        "content": "For anyone who gets a TLE using heap/priority queue, you need to store the sum into the heap besides the indices. It works though I have no idea why I should do it."
                    },
                    {
                        "username": "psionl0",
                        "content": "Not necessary for me."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "HEAP DAYS"
                    },
                    {
                        "username": "031_harsh",
                        "content": "Now onwards leetcode will mad on heap xD"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "This is a much much better question than I initially expected. "
                    },
                    {
                        "username": "marco_seven",
                        "content": "question is not easy but the descriptions made questions easy,,\\nif anyone can understand the description then they can solve it, else noo............"
                    }
                ]
            },
            {
                "id": 1946064,
                "content": [
                    {
                        "username": "Isha307",
                        "content": "Non-Stop priority queue "
                    },
                    {
                        "username": "SouravGoyal8",
                        "content": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        PriorityQueue<Pair>queue = new PriorityQueue<>((a,b) -> a.val - b.val);\\n        HashSet<String>set = new HashSet<>();\\n        List<List<Integer>>arr = new ArrayList<>();\\n        queue.add(new Pair(nums1[0] + nums2[0],0,0));\\n        while(k > 0 && !queue.isEmpty()){\\n            Pair p = queue.poll();\\n            int x = p.x;\\n            int y = p.y;\\n            arr.add(new ArrayList<>(Arrays.asList(nums1[x],nums2[y])));\\n            if(x+1 < n && set.add((x+1) + \"\" + y)){\\n                queue.add(new Pair(nums1[x+1] + nums2[y],x+1,y));\\n            }\\n            if(y+1 < m && set.add((x) + \"\" + (y+1))){\\n                queue.add(new Pair(nums1[x] + nums2[y+1],x,y+1));\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n\\nclass Pair{\\n    int val;\\n    int x;\\n    int y;\\n    public Pair(int val,int x,int y){\\n        this.val = val;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nthis code gives wrong answer, can anyone explain why this happen?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not until you format the code."
                    },
                    {
                        "username": "Akashsb",
                        "content": "A great question .\\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "used a MIN heap at first go but needed to alter my thinking."
                    },
                    {
                        "username": "kartikey_999",
                        "content": "why to use terms like \"non-decreasing\" when you cant use it properly, here the arrays are non-decreasing and not increasing."
                    },
                    {
                        "username": "dongmingli-Ben",
                        "content": "For anyone who gets a TLE using heap/priority queue, you need to store the sum into the heap besides the indices. It works though I have no idea why I should do it."
                    },
                    {
                        "username": "psionl0",
                        "content": "Not necessary for me."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "HEAP DAYS"
                    },
                    {
                        "username": "031_harsh",
                        "content": "Now onwards leetcode will mad on heap xD"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "This is a much much better question than I initially expected. "
                    },
                    {
                        "username": "marco_seven",
                        "content": "question is not easy but the descriptions made questions easy,,\\nif anyone can understand the description then they can solve it, else noo............"
                    }
                ]
            },
            {
                "id": 1946040,
                "content": [
                    {
                        "username": "Isha307",
                        "content": "Non-Stop priority queue "
                    },
                    {
                        "username": "SouravGoyal8",
                        "content": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        PriorityQueue<Pair>queue = new PriorityQueue<>((a,b) -> a.val - b.val);\\n        HashSet<String>set = new HashSet<>();\\n        List<List<Integer>>arr = new ArrayList<>();\\n        queue.add(new Pair(nums1[0] + nums2[0],0,0));\\n        while(k > 0 && !queue.isEmpty()){\\n            Pair p = queue.poll();\\n            int x = p.x;\\n            int y = p.y;\\n            arr.add(new ArrayList<>(Arrays.asList(nums1[x],nums2[y])));\\n            if(x+1 < n && set.add((x+1) + \"\" + y)){\\n                queue.add(new Pair(nums1[x+1] + nums2[y],x+1,y));\\n            }\\n            if(y+1 < m && set.add((x) + \"\" + (y+1))){\\n                queue.add(new Pair(nums1[x] + nums2[y+1],x,y+1));\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n\\nclass Pair{\\n    int val;\\n    int x;\\n    int y;\\n    public Pair(int val,int x,int y){\\n        this.val = val;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nthis code gives wrong answer, can anyone explain why this happen?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not until you format the code."
                    },
                    {
                        "username": "Akashsb",
                        "content": "A great question .\\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "used a MIN heap at first go but needed to alter my thinking."
                    },
                    {
                        "username": "kartikey_999",
                        "content": "why to use terms like \"non-decreasing\" when you cant use it properly, here the arrays are non-decreasing and not increasing."
                    },
                    {
                        "username": "dongmingli-Ben",
                        "content": "For anyone who gets a TLE using heap/priority queue, you need to store the sum into the heap besides the indices. It works though I have no idea why I should do it."
                    },
                    {
                        "username": "psionl0",
                        "content": "Not necessary for me."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "HEAP DAYS"
                    },
                    {
                        "username": "031_harsh",
                        "content": "Now onwards leetcode will mad on heap xD"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "This is a much much better question than I initially expected. "
                    },
                    {
                        "username": "marco_seven",
                        "content": "question is not easy but the descriptions made questions easy,,\\nif anyone can understand the description then they can solve it, else noo............"
                    }
                ]
            },
            {
                "id": 1946039,
                "content": [
                    {
                        "username": "Isha307",
                        "content": "Non-Stop priority queue "
                    },
                    {
                        "username": "SouravGoyal8",
                        "content": "class Solution {\\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        PriorityQueue<Pair>queue = new PriorityQueue<>((a,b) -> a.val - b.val);\\n        HashSet<String>set = new HashSet<>();\\n        List<List<Integer>>arr = new ArrayList<>();\\n        queue.add(new Pair(nums1[0] + nums2[0],0,0));\\n        while(k > 0 && !queue.isEmpty()){\\n            Pair p = queue.poll();\\n            int x = p.x;\\n            int y = p.y;\\n            arr.add(new ArrayList<>(Arrays.asList(nums1[x],nums2[y])));\\n            if(x+1 < n && set.add((x+1) + \"\" + y)){\\n                queue.add(new Pair(nums1[x+1] + nums2[y],x+1,y));\\n            }\\n            if(y+1 < m && set.add((x) + \"\" + (y+1))){\\n                queue.add(new Pair(nums1[x] + nums2[y+1],x,y+1));\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n\\nclass Pair{\\n    int val;\\n    int x;\\n    int y;\\n    public Pair(int val,int x,int y){\\n        this.val = val;\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n\\nthis code gives wrong answer, can anyone explain why this happen?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not until you format the code."
                    },
                    {
                        "username": "Akashsb",
                        "content": "A great question .\\n"
                    },
                    {
                        "username": "divy_kant",
                        "content": "used a MIN heap at first go but needed to alter my thinking."
                    },
                    {
                        "username": "kartikey_999",
                        "content": "why to use terms like \"non-decreasing\" when you cant use it properly, here the arrays are non-decreasing and not increasing."
                    },
                    {
                        "username": "dongmingli-Ben",
                        "content": "For anyone who gets a TLE using heap/priority queue, you need to store the sum into the heap besides the indices. It works though I have no idea why I should do it."
                    },
                    {
                        "username": "psionl0",
                        "content": "Not necessary for me."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "HEAP DAYS"
                    },
                    {
                        "username": "031_harsh",
                        "content": "Now onwards leetcode will mad on heap xD"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "This is a much much better question than I initially expected. "
                    },
                    {
                        "username": "marco_seven",
                        "content": "question is not easy but the descriptions made questions easy,,\\nif anyone can understand the description then they can solve it, else noo............"
                    }
                ]
            }
        ]
    }
]