[
    {
        "title": "Subsequence With the Minimum Score",
        "question_content": "You are given two strings s and t.\nYou are allowed to remove any number of characters from the string t.\nThe score of the string is 0 if no characters are removed from the string t, otherwise:\n\n\tLet left be the minimum index among all removed characters.\n\tLet right be the maximum index among all removed characters.\n\nThen the score of the string is right - left + 1.\nReturn the minimum possible score to make t&nbsp;a subsequence of s.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\n&nbsp;\nExample 1:\n\nInput: s = \"abacaba\", t = \"bzaa\"\nOutput: 1\nExplanation: In this example, we remove the character \"z\" at index 1 (0-indexed).\nThe string t becomes \"baa\" which is a subsequence of the string \"abacaba\" and the score is 1 - 1 + 1 = 1.\nIt can be proven that 1 is the minimum score that we can achieve.\n\nExample 2:\n\nInput: s = \"cde\", t = \"xyz\"\nOutput: 3\nExplanation: In this example, we remove characters \"x\", \"y\" and \"z\" at indices 0, 1, and 2 (0-indexed).\nThe string t becomes \"\" which is a subsequence of the string \"cde\" and the score is 2 - 0 + 1 = 3.\nIt can be proven that 3 is the minimum score that we can achieve.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length, t.length <= 105\n\ts and t consist of only lowercase English letters.",
        "solutions": [
            {
                "id": 3174041,
                "title": "right-and-left-o-n",
                "content": "Based on the problem description, we need to find the longest prefix + suffix of `t` that is a subsequence of `s`.\\n\\nWe first match `t` starting from the right.\\n\\nFor each matched character in `t`, we remember the corresponding point in `s` in the `dp` array. This is our suffix.\\n\\nThen we go left-to-right building our prefix. For each prefix, we determine the longest suffix using `dp`.\\n\\n![image](https://assets.leetcode.com/users/images/927960ab-f214-4294-88bb-1891c4adafe9_1676178007.1489158.png)\\n\\n**C++**\\n```cpp\\nint minimumScore(string s, string t) {\\n    int ss = s.size(), st = t.size(), k = st - 1;\\n    vector<int> dp(st, -1);\\n    for (int i = ss - 1; i >= 0 && k >= 0; --i)\\n        if (s[i] == t[k])\\n            dp[k--] = i;\\n    int res = k + 1;\\n    for (int i = 0, j = 0; i < ss && j < st && res > 0; ++i)\\n        if (s[i] == t[j]) {\\n            for (; k < t.size() && dp[k] <= i; ++k);\\n            res = min(res, k - (++j));\\n        }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int minimumScore(String s, String t) {\\n    int ss = s.length(), st = t.length(), k = st - 1;\\n    int[] dp = new int[st];\\n    Arrays.fill(dp, -1);\\n    for (int i = ss - 1; i >= 0 && k >= 0; --i)\\n        if (s.charAt(i) == t.charAt(k))\\n            dp[k--] = i;\\n    int res = k + 1;\\n    for (int i = 0, j = 0; i < ss && j < st && res > 0; ++i)\\n        if (s.charAt(i) == t.charAt(j)) {\\n            for (; k < st && dp[k] <= i; ++k);\\n            res = Math.min(res, k - (++j));\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint minimumScore(string s, string t) {\\n    int ss = s.size(), st = t.size(), k = st - 1;\\n    vector<int> dp(st, -1);\\n    for (int i = ss - 1; i >= 0 && k >= 0; --i)\\n        if (s[i] == t[k])\\n            dp[k--] = i;\\n    int res = k + 1;\\n    for (int i = 0, j = 0; i < ss && j < st && res > 0; ++i)\\n        if (s[i] == t[j]) {\\n            for (; k < t.size() && dp[k] <= i; ++k);\\n            res = min(res, k - (++j));\\n        }\\n    return res;\\n}\\n```\n```java\\npublic int minimumScore(String s, String t) {\\n    int ss = s.length(), st = t.length(), k = st - 1;\\n    int[] dp = new int[st];\\n    Arrays.fill(dp, -1);\\n    for (int i = ss - 1; i >= 0 && k >= 0; --i)\\n        if (s.charAt(i) == t.charAt(k))\\n            dp[k--] = i;\\n    int res = k + 1;\\n    for (int i = 0, j = 0; i < ss && j < st && res > 0; ++i)\\n        if (s.charAt(i) == t.charAt(j)) {\\n            for (; k < st && dp[k] <= i; ++k);\\n            res = Math.min(res, k - (++j));\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174018,
                "title": "binary-search-sliding-window",
                "content": "We need to minimize something, so we naturally think of 3 possible methods\\n1. Dp\\n2. Greedy\\n3. Binary Search the answer\\n\\nTrying the first 2 options I couldn\\'t figure a way to solve this problem,  So tried binary search search the answer (the length of deleted subarray of t string).\\n\\nCreate a function `check(int len)` which will return true if a subarray of len is deleted from t and t becomes a subsequence of s. false otherwise\\n\\nWe can use sliding window to solve create this function\\n\\n1. Lets assume we delete subarray of len from right hand side of t. Let int[] pos store the greedily matched positions of t from index 0 to t.length()-len.\\n2. Now, keep on increasing the right subarray length till the deleted subarray becomes 0 to len-1. The transition of windows is same as previous, just greedily match the characters of s and t.\\n\\n\\n```\\npublic class Solution {\\n    public int minimumScore(String S, String T) {\\n        char[] s = S.toCharArray(), t = T.toCharArray();\\n        int lo=0,hi=T.length();\\n        while(lo<=hi){\\n            int m = (lo+hi)>>1;\\n            if(check(s,t,m)) hi = m-1;\\n            else lo = m+1;\\n        }\\n        return hi+1;\\n    }\\n    private boolean check(char[] s, char[] t,int len){\\n        int t_length = t.length,n=s.length;\\n        if(len>=t_length) return true; //delete whole t array\\n        int[] pos = new int[t_length]; //Greedy left matching\\n        Arrays.fill(pos,1_000_000_0);\\n        int t_left_index = 0;\\n        for(int i=0;i<n;i++){\\n            if(t_left_index == t_length) break;\\n            if(t[t_left_index] == s[i]){\\n                pos[t_left_index] = i;\\n                t_left_index++;\\n            }\\n        }\\n        if(t_left_index >=t_length-len) return true; //we can delete right subarray of length len\\n        int right_index_of_s =n-1;\\n        for(int rp=t_length-1;rp>=len;rp--){\\n            while(right_index_of_s >=0 && s[right_index_of_s]!=t[rp]) right_index_of_s--;\\n            if(right_index_of_s == -1) return false;\\n            int lp = rp-len-1;\\n            if(lp == -1 || pos[lp]< right_index_of_s) return true;\\n            right_index_of_s--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int minimumScore(String S, String T) {\\n        char[] s = S.toCharArray(), t = T.toCharArray();\\n        int lo=0,hi=T.length();\\n        while(lo<=hi){\\n            int m = (lo+hi)>>1;\\n            if(check(s,t,m)) hi = m-1;\\n            else lo = m+1;\\n        }\\n        return hi+1;\\n    }\\n    private boolean check(char[] s, char[] t,int len){\\n        int t_length = t.length,n=s.length;\\n        if(len>=t_length) return true; //delete whole t array\\n        int[] pos = new int[t_length]; //Greedy left matching\\n        Arrays.fill(pos,1_000_000_0);\\n        int t_left_index = 0;\\n        for(int i=0;i<n;i++){\\n            if(t_left_index == t_length) break;\\n            if(t[t_left_index] == s[i]){\\n                pos[t_left_index] = i;\\n                t_left_index++;\\n            }\\n        }\\n        if(t_left_index >=t_length-len) return true; //we can delete right subarray of length len\\n        int right_index_of_s =n-1;\\n        for(int rp=t_length-1;rp>=len;rp--){\\n            while(right_index_of_s >=0 && s[right_index_of_s]!=t[rp]) right_index_of_s--;\\n            if(right_index_of_s == -1) return false;\\n            int lp = rp-len-1;\\n            if(lp == -1 || pos[lp]< right_index_of_s) return true;\\n            right_index_of_s--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174392,
                "title": "python3-greedy-with-comments",
                "content": "**Observation**: Everything in between ```left``` and ```right``` can be removed.\\n\\n```python\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        # Take care of the case where t is already a substring of s, return 0 in this case.\\n        j = 0\\n        for i in range(len(s)):\\n            if s[i]==t[j]: j+=1\\n            if j==len(t): return 0\\n        \\n        # Moving forward, store the first letter\\'s index in t that needs to be removed if s ends at i.\\n        firstRemovedIndexFromLeft = [0]*len(s)\\n        left = 0\\n        for i in range(len(s)):\\n            if s[i]==t[left]:\\n                left += 1\\n            firstRemovedIndexFromLeft[i] = left\\n\\n        # Worest case, we remove the first and last letter in t.\\n        res = len(t)\\n        \\n        # Moving backward, at each position i in s, there are two cases:\\n        # (1) the firstRemovedIndexFromLeft[i] <= first removed index from right,\\n        #       This is a valid case in the sense that we can \\n        #       basically, remove everything in between these two indices, including these two indices.\\n        #       i.e.,\\n        #       s = \\'aabbbaa\\'\\n        #       t = \\'aazzzaa\\'\\n        #       firstRemovedIndexFromLeft  = [1, 2, 2, 2, 2, 2, 2]\\n        #       firstRemovedIndexFromRight = [4, 4, 4, 4 ,4, 5, 6] (We don\\'t actually put the right in arr like this, but just for easy understanding here)\\n        #       when i=3, firstRemovedIndexFromLeft[i] = 2 and right = 4, \\n        #       so we try to update res, if the score (right-left+1) is smaller.\\n        #\\n        # (2) left > right, this is an invalid case to consider both indices.\\n        #       In this case, we basically just remove everything from 0 to index right, \\n        #       score is (right - 0 + 1), where 0 is the left index. Update res if score is smaller.\\n        right = len(t) -1 \\n        for i in reversed(range(len(s))):\\n            if right>=firstRemovedIndexFromLeft[i]:\\n                res = min(right-firstRemovedIndexFromLeft[i]+1,res)\\n            if s[i] == t[right]:\\n                right -= 1\\n            res = min(res, right+1)\\n            \\n        return res\\n```\\nIs this called greedy approach or dp? Or it has an other name? Plesse leave a comment if you know the answer, thanks.",
                "solutionTags": [],
                "code": "```left```\n```right```\n```python\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        # Take care of the case where t is already a substring of s, return 0 in this case.\\n        j = 0\\n        for i in range(len(s)):\\n            if s[i]==t[j]: j+=1\\n            if j==len(t): return 0\\n        \\n        # Moving forward, store the first letter\\'s index in t that needs to be removed if s ends at i.\\n        firstRemovedIndexFromLeft = [0]*len(s)\\n        left = 0\\n        for i in range(len(s)):\\n            if s[i]==t[left]:\\n                left += 1\\n            firstRemovedIndexFromLeft[i] = left\\n\\n        # Worest case, we remove the first and last letter in t.\\n        res = len(t)\\n        \\n        # Moving backward, at each position i in s, there are two cases:\\n        # (1) the firstRemovedIndexFromLeft[i] <= first removed index from right,\\n        #       This is a valid case in the sense that we can \\n        #       basically, remove everything in between these two indices, including these two indices.\\n        #       i.e.,\\n        #       s = \\'aabbbaa\\'\\n        #       t = \\'aazzzaa\\'\\n        #       firstRemovedIndexFromLeft  = [1, 2, 2, 2, 2, 2, 2]\\n        #       firstRemovedIndexFromRight = [4, 4, 4, 4 ,4, 5, 6] (We don\\'t actually put the right in arr like this, but just for easy understanding here)\\n        #       when i=3, firstRemovedIndexFromLeft[i] = 2 and right = 4, \\n        #       so we try to update res, if the score (right-left+1) is smaller.\\n        #\\n        # (2) left > right, this is an invalid case to consider both indices.\\n        #       In this case, we basically just remove everything from 0 to index right, \\n        #       score is (right - 0 + 1), where 0 is the left index. Update res if score is smaller.\\n        right = len(t) -1 \\n        for i in reversed(range(len(s))):\\n            if right>=firstRemovedIndexFromLeft[i]:\\n                res = min(right-firstRemovedIndexFromLeft[i]+1,res)\\n            if s[i] == t[right]:\\n                right -= 1\\n            res = min(res, right+1)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174593,
                "title": "python3-forward-backward",
                "content": "\\n```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        suffix = [-1]*len(s)\\n        j = len(t)-1\\n        for i in reversed(range(len(s))): \\n            if 0 <= j and s[i] == t[j]: j -= 1\\n            suffix[i] = j \\n        ans = j + 1\\n        j = 0 \\n        for i, ch in enumerate(s): \\n            ans = min(ans, max(0, suffix[i] - j + 1))\\n            if j < len(t) and s[i] == t[j]: j += 1\\n        return min(ans, len(t)-j)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        suffix = [-1]*len(s)\\n        j = len(t)-1\\n        for i in reversed(range(len(s))): \\n            if 0 <= j and s[i] == t[j]: j -= 1\\n            suffix[i] = j \\n        ans = j + 1\\n        j = 0 \\n        for i, ch in enumerate(s): \\n            ans = min(ans, max(0, suffix[i] - j + 1))\\n            if j < len(t) and s[i] == t[j]: j += 1\\n        return min(ans, len(t)-j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174009,
                "title": "c-clean-explained",
                "content": "# Solution \\n\\nIf we remove some substring of $t$, we are left with a prefix (possibly empty), and a suffix (possibly empty), of $t$. This prompts us to precalculate for each prefix/suffix, what is the minimum prefix/suffix of $s$ that we need for the prefix/suffix of $t$ to be a subsequence of. \\n\\nFirstly, finding the longest prefix of a string $t$ that is a subsequence of $s$ can be done in $O(|s|+|t|)$. This is done by using two pointers, one for each string. \\n\\nLet $i$ be the pointer for $s$, and $j$ be the pointer for $t$. \\n\\nNote that as we are incrementing  $j$, the pointer $i$ is the rightmost position in the \\n\\n\\nin $s$ of the prefix of $t$ up to $j$. Thus, we are able to find, for each prefix of $t$, what is the minimal size of the prefix of $s$ (the maximum index) such that $t$ is a subsequence of that prefix. In my implementation, I use an array $left$, and store $i$ in $left_j$. Conversely, this logic can also be applied to find the minimal suffix of $s$ such that it contains a subsequence of a suffix of $t$. I store the minimum index $i$ in $right_j$ (the smallest suffix of s such that the suffix from $t$ is a subsequence of it). \\n\\nNow that we have $left$ and $right$, we can fix the prefix (we will call $a$ the last index of the prefix) of $t$ that we will keep, and binary search for the leftmost suffix of $t$ such that there is no overlap in $s$. (We want a prefix and a maximal suffix to minimize r-l+1, but we do not want them to overlap in letters in $s$, or else we will not have a subsequence). Thus, we can binary search for the biggest suffix (we will call $b$ the first index of the suffix) of $t$ that satisfies the following conditions: \\n\\n$a$ < $b$\\n$left_a$ $<$ $right_b$\\n\\nSee my implentation below for details. \\n\\nThe time complexity is $O(NlogN)$, \\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = s.size(), m = t.size(); \\n        vector<int> l(m, -1), r(m, -1); //left, right arrays. \\n        int j = 0; \\n        for (int i = 0; i < n; ++i) {\\n            if (j >= m) break; \\n            if (s[i] == t[j]) {\\n                l[j] = i; //for a prefix of t from 0...j, i is the greatest \\n                //index in s such that it is a subsequence\\n                j++; \\n            }\\n        }\\n        j = m-1; \\n        for (int i = n-1; i >= 0; --i) {\\n            if (j < 0) break; \\n            if (s[i] == t[j]) {\\n                r[j] = i; \\n                //for a suffix of t from j...n-1, i is the smallest \\n                //index in s such that it is a subsequence\\n                j--; \\n            }\\n        }\\n\\n        int ans = m; \\n        for (int i = 0; i < m; ++i) { \\n            //update answer for prefix/suffix is removed \\n            //only (new t is a prefix or suffix of t)\\n            if (l[i] != -1) ans = min(ans, m-i-1); \\n            if (r[i] != -1) ans = min(ans, i); \\n        }\\n\\n        //if the smallest suffix is invalid, we return our answer\\n        //in order to avoid annoying casework in our binary search\\n        if (r[m-1] == -1) return ans; \\n        \\n        for (int i = 0; i < m-1; ++i) {\\n            if (l[i] != -1) {\\n                if (l[i] >= r[m-1]) break; \\n                \\n                int lo = i + 1, hi = m - 1; \\n                while (lo < hi) {\\n                    int md = lo + (hi - lo)/2; \\n                    //check if left index in s is less than right \\n                    //index of the suffix (a < b as said in solution)\\n                    if (l[i] < r[md]) hi = md; \\n                    else lo = md + 1; \\n                }\\n                //lo is the smallest index in the biggest \\n                //suffix that satisfies the condition \\n                ans = min(ans, lo - i - 1); \\n                //lo - i - 1 is the size if the deleted substring\\n            }\\n        }\\n        return ans; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = s.size(), m = t.size(); \\n        vector<int> l(m, -1), r(m, -1); //left, right arrays. \\n        int j = 0; \\n        for (int i = 0; i < n; ++i) {\\n            if (j >= m) break; \\n            if (s[i] == t[j]) {\\n                l[j] = i; //for a prefix of t from 0...j, i is the greatest \\n                //index in s such that it is a subsequence\\n                j++; \\n            }\\n        }\\n        j = m-1; \\n        for (int i = n-1; i >= 0; --i) {\\n            if (j < 0) break; \\n            if (s[i] == t[j]) {\\n                r[j] = i; \\n                //for a suffix of t from j...n-1, i is the smallest \\n                //index in s such that it is a subsequence\\n                j--; \\n            }\\n        }\\n\\n        int ans = m; \\n        for (int i = 0; i < m; ++i) { \\n            //update answer for prefix/suffix is removed \\n            //only (new t is a prefix or suffix of t)\\n            if (l[i] != -1) ans = min(ans, m-i-1); \\n            if (r[i] != -1) ans = min(ans, i); \\n        }\\n\\n        //if the smallest suffix is invalid, we return our answer\\n        //in order to avoid annoying casework in our binary search\\n        if (r[m-1] == -1) return ans; \\n        \\n        for (int i = 0; i < m-1; ++i) {\\n            if (l[i] != -1) {\\n                if (l[i] >= r[m-1]) break; \\n                \\n                int lo = i + 1, hi = m - 1; \\n                while (lo < hi) {\\n                    int md = lo + (hi - lo)/2; \\n                    //check if left index in s is less than right \\n                    //index of the suffix (a < b as said in solution)\\n                    if (l[i] < r[md]) hi = md; \\n                    else lo = md + 1; \\n                }\\n                //lo is the smallest index in the biggest \\n                //suffix that satisfies the condition \\n                ans = min(ans, lo - i - 1); \\n                //lo - i - 1 is the size if the deleted substring\\n            }\\n        }\\n        return ans; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185048,
                "title": "comments-video-solution-prefix-suffix-o-n-complexity-c-solution",
                "content": "\\n\\n# Approach\\nJust construct the prefix and suffix array based on no of subsequence matching characters and then just see how many characters are matching from left and how many are matching from right. Then take the unmatched part for every index and return the minimum\\n\\nLink : https://www.youtube.com/watch?v=eVAeTG5VjVM\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minimumScore(string s, string t) \\n    {\\n        int m = s.size();\\n        int n = t.size();\\n\\n        int mini = 1e9;\\n        vector<int>pref(m, 0), suff(m, 0);\\n\\n        int j = 0;\\n        for(int i=0; i<m && j<n; i++)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                pref[i]++;\\n                j++;\\n            }\\n\\n            if(i>0) pref[i] += pref[i-1];\\n        }\\n\\n        j=n-1;\\n        for(int i=m-1; i>=0 && j>=0; i--)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                suff[i]++;\\n                j--;\\n            }\\n\\n            if(i<m-1) suff[i] += suff[i+1];\\n        }\\n\\n        for(int i=0; i<m-1; i++)\\n        {\\n            mini = min(mini, n-(pref[i]+suff[i+1]));\\n        }\\n\\n        mini = min(mini, n-(pref[m-1]));\\n        mini = min(mini, n-(suff[0]));\\n\\n        return max(mini, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumScore(string s, string t) \\n    {\\n        int m = s.size();\\n        int n = t.size();\\n\\n        int mini = 1e9;\\n        vector<int>pref(m, 0), suff(m, 0);\\n\\n        int j = 0;\\n        for(int i=0; i<m && j<n; i++)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                pref[i]++;\\n                j++;\\n            }\\n\\n            if(i>0) pref[i] += pref[i-1];\\n        }\\n\\n        j=n-1;\\n        for(int i=m-1; i>=0 && j>=0; i--)\\n        {\\n            if(s[i] == t[j])\\n            {\\n                suff[i]++;\\n                j--;\\n            }\\n\\n            if(i<m-1) suff[i] += suff[i+1];\\n        }\\n\\n        for(int i=0; i<m-1; i++)\\n        {\\n            mini = min(mini, n-(pref[i]+suff[i+1]));\\n        }\\n\\n        mini = min(mini, n-(pref[m-1]));\\n        mini = min(mini, n-(suff[0]));\\n\\n        return max(mini, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176194,
                "title": "c-binary-search-sliding-window-prefix-array-o-n-log-n",
                "content": "**Hint:** Let `left` and `right` be the minimum and maximum index among all removed characters. If we remove all characters from left to right ( remove sustring t[left:right] from string `t`), it will not change the result. Find the min length of the substring to be removed.\\n`Note: right-left+1 is the length of substring t[left:right]`\\n## Approach: \\n* With the help of Binary search, we can find the lenght of the smallest substring to be removed.\\n* Now, once we have a lenght (say **k**) to be removed, we can make use of prefix & suffix array and sliding window to find out whether it\\'s possible to remove any substring of length **k** to make `t` a subsequence of `s` or not.\\n* Make a prefix array `left` where **left[i]** is the min index of `s` such that substring t[0:i] is a subsequence of substring s[0:left[i]]\\n* Make a suffix array `right` where **right[i]** is the max index of `s` such that substring t[i:] is a subsequence of substring s[left[i]:]\\n* Now apply the Sliding window. See the implementation for more understanding\\n```\\nclass Solution {\\npublic:\\n    void makeprefix(vector<int>& left,vector<int>& right,string &s,string &t){\\n        for(int i = 0,j = 0; i<s.size() && j<t.size();++i){\\n            if(s[i]==t[j]){\\n                left[j] = i; j++;\\n            }\\n        }\\n        for(int i = s.size()-1,j = t.size()-1;i>=0 && j>=0;--i){\\n            if(s[i]==t[j]){\\n                right[j] = i; j--;\\n            }\\n        }\\n    }\\n    bool find(vector<int>& left,vector<int>& right,int m,int n){\\n        if(m==n) return 1;\\n        if(right[m]!=-1 || left[n-m-1]!=-1) return 1;\\n        for(int i = 0,j = m+1; j<n ;++i,++j){\\n            if(left[i]!=-1 && right[j]!=-1 && left[i]<right[j]) return 1;\\n        }\\n        return 0;\\n    }\\n    int minimumScore(string s, string t) {\\n        vector<int> left(t.size(),-1),right(t.size(),-1);\\n        makeprefix(left,right,s,t);\\n        int l = 0,h = t.size(),re = -1;\\n        while(l<=h){\\n            int m = (l+h)/2;\\n            if(find(left,right,m,t.size())) { re = m; h = m-1; }\\n            else l = m+1;\\n        }\\n        return re;\\n    }\\n};\\n```\\n**Upvote** if it helps",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void makeprefix(vector<int>& left,vector<int>& right,string &s,string &t){\\n        for(int i = 0,j = 0; i<s.size() && j<t.size();++i){\\n            if(s[i]==t[j]){\\n                left[j] = i; j++;\\n            }\\n        }\\n        for(int i = s.size()-1,j = t.size()-1;i>=0 && j>=0;--i){\\n            if(s[i]==t[j]){\\n                right[j] = i; j--;\\n            }\\n        }\\n    }\\n    bool find(vector<int>& left,vector<int>& right,int m,int n){\\n        if(m==n) return 1;\\n        if(right[m]!=-1 || left[n-m-1]!=-1) return 1;\\n        for(int i = 0,j = m+1; j<n ;++i,++j){\\n            if(left[i]!=-1 && right[j]!=-1 && left[i]<right[j]) return 1;\\n        }\\n        return 0;\\n    }\\n    int minimumScore(string s, string t) {\\n        vector<int> left(t.size(),-1),right(t.size(),-1);\\n        makeprefix(left,right,s,t);\\n        int l = 0,h = t.size(),re = -1;\\n        while(l<=h){\\n            int m = (l+h)/2;\\n            if(find(left,right,m,t.size())) { re = m; h = m-1; }\\n            else l = m+1;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174570,
                "title": "simple-prefix-and-suffix",
                "content": "\\n```java\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        int[] pre = new int[s.length()];\\n        for(int i=0, j=0; i<s.length() && j<t.length(); i++){\\n            if(i>0) pre[i] = pre[i-1];\\n            if(s.charAt(i) == t.charAt(j)){\\n                j++; pre[i]++;\\n            }\\n        }\\n        int c=0,ans = 0;\\n        for(int i=s.length()-1, j=t.length()-1; i>=0 && j>=0; i--){\\n            ans = Math.max(ans, c+pre[i]);\\n            if(s.charAt(i) == t.charAt(j)){\\n                j--; c++;\\n            }\\n        }\\n        ans = Math.max(ans, c);\\n        return Math.max(0, t.length()-ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        int[] pre = new int[s.length()];\\n        for(int i=0, j=0; i<s.length() && j<t.length(); i++){\\n            if(i>0) pre[i] = pre[i-1];\\n            if(s.charAt(i) == t.charAt(j)){\\n                j++; pre[i]++;\\n            }\\n        }\\n        int c=0,ans = 0;\\n        for(int i=s.length()-1, j=t.length()-1; i>=0 && j>=0; i--){\\n            ans = Math.max(ans, c+pre[i]);\\n            if(s.charAt(i) == t.charAt(j)){\\n                j--; c++;\\n            }\\n        }\\n        ans = Math.max(ans, c);\\n        return Math.max(0, t.length()-ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175288,
                "title": "get-left-for-right-with-video-o-n-time-and-space-c-code",
                "content": "# Intuition\\nIf right - left + 1 is the cost (this is similar to size of substring from left to right index),\\nthere is no sense in removing only some elements from left index to right index.\\nIt makes sense to remove entire substring.\\nBecause then we will be having a smaller string t to form a subsequence which is better.\\n\\nSo we will remove all characters from left index to right index.\\nWhich means we will will remove a substring from t.\\n\\nNow about right and left:\\n\\nI can build all possible left separately and then for a particular right, I can get a left(which I previously built) to form answer.\\n\\nVideo:\\n<iframe width=\"460\" height=\"250\" src=\"https://www.youtube.com/embed/c75mRQfNtxg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n# Approach\\nFirst we start to build all possible left.\\nHow?\\nWe keep two pointers ps(for s string) and pt(for t string)\\nWe initialize both to 0.\\nWe keep incrementing ps pointer until value at both pointers are not equal\\n\\nIn other words, until substring of t from 0 - pt doesn\\'t become a subsequence of (substring of s from 0 - ps).\\n\\nOnce this done we add {pt+1, ps} to our possible left vector.\\n\\nWhy pt+1?\\nBecuse that is the left\\n\\nWhy ps?\\nWe are storing s index for all possible left becuase it can happen that s index for right becomes <= the s index for left.\\nIn that case our answer will be wrong.\\n\\nThen we start our process to get right:\\n\\nIn the same way we build possible left from start of our array, we get possible rights from end of the array\\n\\nThere just two differences here:\\n1. We keep eliminating elements from back of the possible left array based on two conditions:\\n    i. left <= right\\n    ii. s index for left < s index for right\\n2. We calculate answer for substring left--right\\n\\nHave a look at code for better understanding.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(n)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n\\tint minimumScore(string s, string t) {\\n\\t\\tvector<pair<int, int>> psbLeft;// <left, s index for that left>\\n\\t\\tint ps = 0;//pointer for s string\\n\\t\\tint pt = 0;//pointer for t string\\n\\t\\tint ans = t.size();\\n\\n\\t\\t//Building Possible Left:\\n\\t\\tpsbLeft.push_back({0, -1});\\n\\t\\twhile (ps < s.size() && pt < t.size()) {\\n\\t\\t\\twhile (ps < s.size() && s[ps] != t[pt])\\n\\t\\t\\t\\tps++;\\n\\t\\t\\tif (ps == s.size())\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tpsbLeft.push_back({pt + 1, ps});\\n\\t\\t\\tpt++;\\n\\t\\t\\tps++;\\n\\t\\t}\\n\\n        //If t is subsequence of s then we return 0\\n        //If not we can get smallest substring from end of t we have to remove to make t substring of s\\n\\t\\tif (psbLeft.back().first == t.size())\\n\\t\\t\\treturn 0;\\n\\t\\telse\\n\\t\\t\\tans = min(ans, (int)t.size() - psbLeft.back().first);\\n\\n\\t\\tps = s.size() - 1;\\n\\t\\tpt = t.size() - 1;\\n\\n        //Getting Possible Right\\n\\t\\twhile (ps >= 0 && pt >= 0) {\\n\\t\\t\\twhile (ps >= 0 && s[ps] != t[pt])\\n\\t\\t\\t\\tps--;\\n\\t\\t\\tif (ps < 0)\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tint right = pt - 1;\\n\\n            //Two conditions checked in below code:\\n            //1. left <= right\\n            //2. s index for left < s index for right\\n\\t\\t\\twhile (psbLeft.size() && (psbLeft.back().first > right || psbLeft.back().second >= ps))\\n\\t\\t\\t\\tpsbLeft.pop_back();\\n\\n            //If substring from starting of t removed \\n\\t\\t\\tans = min(ans, pt);\\n\\n            //Left and right both used:\\n\\t\\t\\tif (psbLeft.size()) {\\n\\t\\t\\t\\tint left = psbLeft.back().first;\\n\\t\\t\\t\\tans = min(ans, right - left + 1);\\n\\t\\t\\t}\\n\\t\\t\\tpt--;\\n\\t\\t\\tps--;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n<b>Upvote if you found this helpful!</b>",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumScore(string s, string t) {\\n\\t\\tvector<pair<int, int>> psbLeft;// <left, s index for that left>\\n\\t\\tint ps = 0;//pointer for s string\\n\\t\\tint pt = 0;//pointer for t string\\n\\t\\tint ans = t.size();\\n\\n\\t\\t//Building Possible Left:\\n\\t\\tpsbLeft.push_back({0, -1});\\n\\t\\twhile (ps < s.size() && pt < t.size()) {\\n\\t\\t\\twhile (ps < s.size() && s[ps] != t[pt])\\n\\t\\t\\t\\tps++;\\n\\t\\t\\tif (ps == s.size())\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tpsbLeft.push_back({pt + 1, ps});\\n\\t\\t\\tpt++;\\n\\t\\t\\tps++;\\n\\t\\t}\\n\\n        //If t is subsequence of s then we return 0\\n        //If not we can get smallest substring from end of t we have to remove to make t substring of s\\n\\t\\tif (psbLeft.back().first == t.size())\\n\\t\\t\\treturn 0;\\n\\t\\telse\\n\\t\\t\\tans = min(ans, (int)t.size() - psbLeft.back().first);\\n\\n\\t\\tps = s.size() - 1;\\n\\t\\tpt = t.size() - 1;\\n\\n        //Getting Possible Right\\n\\t\\twhile (ps >= 0 && pt >= 0) {\\n\\t\\t\\twhile (ps >= 0 && s[ps] != t[pt])\\n\\t\\t\\t\\tps--;\\n\\t\\t\\tif (ps < 0)\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tint right = pt - 1;\\n\\n            //Two conditions checked in below code:\\n            //1. left <= right\\n            //2. s index for left < s index for right\\n\\t\\t\\twhile (psbLeft.size() && (psbLeft.back().first > right || psbLeft.back().second >= ps))\\n\\t\\t\\t\\tpsbLeft.pop_back();\\n\\n            //If substring from starting of t removed \\n\\t\\t\\tans = min(ans, pt);\\n\\n            //Left and right both used:\\n\\t\\t\\tif (psbLeft.size()) {\\n\\t\\t\\t\\tint left = psbLeft.back().first;\\n\\t\\t\\t\\tans = min(ans, right - left + 1);\\n\\t\\t\\t}\\n\\t\\t\\tpt--;\\n\\t\\t\\tps--;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177655,
                "title": "python-3-10-lines-two-passes-t-m-174-ms-18-mb",
                "content": "```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n\\n        m, n =  len(s), len(t)\\n        suff, j = [0]*m, n\\n\\n        for i in range(m)[::-1]:\\n\\n            if j > 0 and s[i] == t[j-1]: j -= 1\\n            suff[i] = j-1\\n\\n        ans, j = j, 0\\n\\n        for i in range(m):\\n\\n            ans = min(ans, max(0, suff[i] - j + 1))\\n            if j < n and s[i] == t[j]: j += 1\\n\\n        return min(ans, n-j)\\n```\\n[https://leetcode.com/problems/subsequence-with-the-minimum-score/submissions/896781999](http://)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n\\n        m, n =  len(s), len(t)\\n        suff, j = [0]*m, n\\n\\n        for i in range(m)[::-1]:\\n\\n            if j > 0 and s[i] == t[j-1]: j -= 1\\n            suff[i] = j-1\\n\\n        ans, j = j, 0\\n\\n        for i in range(m):\\n\\n            ans = min(ans, max(0, suff[i] - j + 1))\\n            if j < n and s[i] == t[j]: j += 1\\n\\n        return min(ans, n-j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181484,
                "title": "this-problem-drove-me-crazy-stayed-up-from-4-a-m-to-10-a-m-solving-this",
                "content": "I couldn\\'t solve the problem during the contest, but I didn\\'t want to read any solutions because it seemed solvable. But as the night progressed, I began to think it was impossible. Here are the ideas of my failed approaches:\\n\\n**Approach 1: Binary Search on Length of Optimal R-L**\\nThe idea was to use binary search to find the optimal length of R-L. Whenever I encountered a character that could not form a subsequence, I skipped the next [mid] elements. This is the approach I tried during the contest, which only passed ~30 test cases. I assumed this was due to bad implementation, so I continued this approach for 2 more hours.\\n**Why It Didn\\'t Work:**\\nI looked over the fact that sometimes it is not always optimal to start deleting at the first element that doesn\\'t fit. For example, for the case \"abcdef\" \"afbcde\", my program would go from a to f then delete b, c, d, and e. This is not optimal.\\n\\n**Approach 2: Sliding Window + Binary Search**\\nThe idea was basically the same as the first one but with a sliding window of length [mid]. I couldn\\'t figure out how to check if the sequence t was a subsequence of s with a sliding window in O(N) time however, so this approach died because it was O(N^2 log N) at best.\\n\\n**Approach 3: Binary Search on Right and Left Bound**\\nThis time, I tried to do two separate binary searches. The first one was to find the leftmost right index that I would have to delete up to to make t a subsequence of s. Then, I would find minimum distanced left index from right that would still allow the subsequence condition to be fulfilled. This would be found using a second binary search.\\n**Why It Didn\\'t Work:** \\nIt turns out finding the minimum right index was basically irrelevant. While I do find the minimum right bound, it doesn\\'t guarantee that the left bound created from it is optimal.\\n\\n**Approach 4: DP + Binary Search (Accepted!!)**\\nFinally! I had the idea to use DP and binary search to find the optimal right and left bound. Scan string t from the left and right and record the most characters you can use from the left and right. Then use binary search to find the maximum non-overlapping sum.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        map<int, int> m;\\n        int p1 = 0; // pointer for string s\\n        int ans = 0;\\n        for(int i = 0; i < t.length(); i++){\\n            while(p1<s.length() && t[i] != s[p1]) p1++;\\n            if(p1 == s.length()) break;\\n            m[p1] = i+1; // how many characters I can use up to this point\\n            p1++;\\n            ans = max(ans, i+1);\\n        }\\n        p1 = s.length()-1;\\n        for(int i = t.length()-1, k =1; i>=0; i--, k++){\\n            while(p1>=0 && t[i] != s[p1]) p1--;\\n            if(p1<0) break;\\n            auto it = m.lower_bound(p1);\\n            if(it != m.begin()){ // find the best non overlapping pointer behind this one and add it up\\n                it--;\\n                auto other = it->second;\\n                ans = max(ans, k+other);\\n            }\\n            p1--;\\n            ans = max(ans, k);\\n        }\\n        int len = t.length();\\n        if(len-ans<0) return 0;\\n        return len-ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        map<int, int> m;\\n        int p1 = 0; // pointer for string s\\n        int ans = 0;\\n        for(int i = 0; i < t.length(); i++){\\n            while(p1<s.length() && t[i] != s[p1]) p1++;\\n            if(p1 == s.length()) break;\\n            m[p1] = i+1; // how many characters I can use up to this point\\n            p1++;\\n            ans = max(ans, i+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3175514,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find(string &s,string &t,int mid)\\n    {\\n        int n=s.size();\\n        int m=t.size();\\n        vector<int>left(m,n),right(m,-1);\\n        for(int i=0,j=0;j<m&&i<n;i++)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                left[j]=i;\\n                j++;\\n            }\\n        }\\n        for(int i=n-1,j=m-1;j>=0&&i>=0;i--)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                right[j]=i;\\n                j--;\\n            }\\n        }\\n        if(left[m-1]!=n)\\n        {\\n            return true;\\n        }\\n        if(right[mid]!=-1||left[m-mid-1]!=n)\\n        {\\n            return true;\\n        }\\n        for(int i=1;i+mid<m;i++)\\n        {\\n            if(left[i-1]<right[i+mid])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int minimumScore(string s, string t) {\\n        int l=0;\\n        int r=t.size()-1;\\n        int ans=t.size();\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(find(s,t,mid))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find(string &s,string &t,int mid)\\n    {\\n        int n=s.size();\\n        int m=t.size();\\n        vector<int>left(m,n),right(m,-1);\\n        for(int i=0,j=0;j<m&&i<n;i++)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                left[j]=i;\\n                j++;\\n            }\\n        }\\n        for(int i=n-1,j=m-1;j>=0&&i>=0;i--)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                right[j]=i;\\n                j--;\\n            }\\n        }\\n        if(left[m-1]!=n)\\n        {\\n            return true;\\n        }\\n        if(right[mid]!=-1||left[m-mid-1]!=n)\\n        {\\n            return true;\\n        }\\n        for(int i=1;i+mid<m;i++)\\n        {\\n            if(left[i-1]<right[i+mid])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int minimumScore(string s, string t) {\\n        int l=0;\\n        int r=t.size()-1;\\n        int ans=t.size();\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(find(s,t,mid))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174604,
                "title": "simple-c-solution-using-two-pointers",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n=s.size();\\n        int m=t.size();\\n        vector<int> pref(m, n);\\n        vector<int> suff(m, -1);\\n        for(int i=0, j=0; i<s.size() && j<t.size(); i++)\\n        {\\n            if(s[i]==t[j])\\n                pref[j++]=i;\\n        }\\n\\n        for(int i=s.size()-1, j=t.size()-1; i>=0 && j>=0; i--)\\n        {\\n            if(s[i]==t[j])\\n                suff[j--]=i;\\n        }\\n        \\n        \\n        if(pref.back()!=n)\\n            return 0;\\n\\n        int tot=t.size();\\n        \\n        int pos=0;\\n        for(int i=0; i<m; i++)\\n        {\\n            if(pref[i]==n)\\n                break;\\n            \\n            while(pos<m && suff[pos]<=pref[i])\\n                pos++;\\n            \\n            tot=min(tot, pos-i-1);\\n        }\\n        for(int i=m-1; i>=0; i--)\\n        {\\n            if(suff[i]!=-1)\\n                tot=min(tot, i);\\n        }\\n        return tot;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n=s.size();\\n        int m=t.size();\\n        vector<int> pref(m, n);\\n        vector<int> suff(m, -1);\\n        for(int i=0, j=0; i<s.size() && j<t.size(); i++)\\n        {\\n            if(s[i]==t[j])\\n                pref[j++]=i;\\n        }\\n\\n        for(int i=s.size()-1, j=t.size()-1; i>=0 && j>=0; i--)\\n        {\\n            if(s[i]==t[j])\\n                suff[j--]=i;\\n        }\\n        \\n        \\n        if(pref.back()!=n)\\n            return 0;\\n\\n        int tot=t.size();\\n        \\n        int pos=0;\\n        for(int i=0; i<m; i++)\\n        {\\n            if(pref[i]==n)\\n                break;\\n            \\n            while(pos<m && suff[pos]<=pref[i])\\n                pos++;\\n            \\n            tot=min(tot, pos-i-1);\\n        }\\n        for(int i=m-1; i>=0; i--)\\n        {\\n            if(suff[i]!=-1)\\n                tot=min(tot, i);\\n        }\\n        return tot;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174442,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor a particular score , instead of removing just some elements b/w l and r. we can remove all the elements. that way we have to check for less number of elements of t for exactly the same score.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe binary search for a particular score and for all the values of l and r for this score. we check if t(0.........l-1) and t(r+1.......n-1) is a subsequence of s. if yes, then for this score, there exists a configuration where t is a subsequence of s. now we search for lower scores, otherwise we search for higher scores. to check for a paricular score, i used the prefix/suffix array and sliding window method.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>pref, suff;\\n    bool can(int mid, string &t, string &s){\\n        //cout<<mid<<endl;\\n        for(int i=0, j=mid-1; j<t.size(); i++,j++){\\n            int a= (i==0)?0:pref[i-1];\\n            int b=(j==t.size()-1)?0:suff[j+1];\\n            //cout<<i<<\"   \"<<j<<\"    \"<<a<<\"    \"<<b<<endl;\\n            if(a==-1 || b==-1)continue;\\n            if(a<b)return true;\\n            if(j==t.size()-1 && a>=0)return true;\\n            if(i==0 && b>=0)return true;\\n        }\\n        return false;\\n    }\\n    void precompute(string &s, string &t){\\n        pref.resize(t.size(), -1);\\n        suff.resize(t.size(), -1);\\n        int n=s.size();\\n        for(int i=0, j=0; i<n && j<t.size(); i++){\\n            if(s[i]==t[j]){\\n                pref[j]=i;\\n                j++;\\n            }\\n        }\\n        for(int i=n-1, j=t.size()-1; i>=0 && j>=0; i--){\\n            if(s[i]==t[j]){\\n                suff[j]=i;\\n                j--;\\n            }\\n        }\\n        // for(int i=0; i<t.size(); i++){\\n        //     cout<<pref[i]<<\"    \"<<suff[i]<<endl;\\n        // }\\n    }\\n    int minimumScore(string s, string t) {\\n        precompute(s, t);\\n        if(suff[0]!=-1)return 0;\\n        int n=t.size();\\n        int lo=1, hi=n;\\n        while(hi-lo>1){\\n            int mid=(hi+lo)/2;\\n            bool c=can(mid, t, s);\\n            if(c){\\n                hi=mid;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        if(can(lo, t, s))return lo;\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>pref, suff;\\n    bool can(int mid, string &t, string &s){\\n        //cout<<mid<<endl;\\n        for(int i=0, j=mid-1; j<t.size(); i++,j++){\\n            int a= (i==0)?0:pref[i-1];\\n            int b=(j==t.size()-1)?0:suff[j+1];\\n            //cout<<i<<\"   \"<<j<<\"    \"<<a<<\"    \"<<b<<endl;\\n            if(a==-1 || b==-1)continue;\\n            if(a<b)return true;\\n            if(j==t.size()-1 && a>=0)return true;\\n            if(i==0 && b>=0)return true;\\n        }\\n        return false;\\n    }\\n    void precompute(string &s, string &t){\\n        pref.resize(t.size(), -1);\\n        suff.resize(t.size(), -1);\\n        int n=s.size();\\n        for(int i=0, j=0; i<n && j<t.size(); i++){\\n            if(s[i]==t[j]){\\n                pref[j]=i;\\n                j++;\\n            }\\n        }\\n        for(int i=n-1, j=t.size()-1; i>=0 && j>=0; i--){\\n            if(s[i]==t[j]){\\n                suff[j]=i;\\n                j--;\\n            }\\n        }\\n        // for(int i=0; i<t.size(); i++){\\n        //     cout<<pref[i]<<\"    \"<<suff[i]<<endl;\\n        // }\\n    }\\n    int minimumScore(string s, string t) {\\n        precompute(s, t);\\n        if(suff[0]!=-1)return 0;\\n        int n=t.size();\\n        int lo=1, hi=n;\\n        while(hi-lo>1){\\n            int mid=(hi+lo)/2;\\n            bool c=can(mid, t, s);\\n            if(c){\\n                hi=mid;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        if(can(lo, t, s))return lo;\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3174256,
                "title": "java-clean-greedy-binary-search-solution",
                "content": "# Intuition\\n\\nDon\\'t be confused by the \"subsequence\". Here the score is defined as `right - left + 1`, meaning that all chars between `left` and `right` can be removed all together. Or, we can say - removing part of them doesn\\'t change anything.\\n\\nThen we can greedily check for prefix and suffix of t to get the max of `left` and min of `right`. We also need to make sure there is no overlap on s, binary search can help here.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        int leftT = 0;\\n        List<Integer> leftSs = new ArrayList<>();\\n\\n        for (int i = 0; i < s.length() && leftT < t.length(); i++) {\\n            if (s.charAt(i) == t.charAt(leftT)) {\\n                leftSs.add(i);\\n                leftT++;\\n            }\\n        }\\n\\n        int rightT = t.length() - 1;\\n        List<Integer> rightSs = new ArrayList<>();\\n        for (int i = s.length() - 1; i >= 0 && rightT >= 0; i--) {\\n            if (s.charAt(i) == t.charAt(rightT)) {\\n                rightSs.add(i);\\n                rightT--;\\n            }\\n        }\\n\\n        int result = Math.min(t.length() - leftT, rightT + 1);\\n        for (int i = 0; i < rightSs.size(); i++) {\\n            int ind = rightSs.get(i) - 1;\\n            int left = Collections.binarySearch(leftSs, ind);\\n            if (left < 0) {\\n                left = ~left;\\n            } else {\\n                left++;\\n            }\\n            result = Math.min(result, Math.max(0, t.length() - i - 1 - left));\\n            if (result == 0) {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        int leftT = 0;\\n        List<Integer> leftSs = new ArrayList<>();\\n\\n        for (int i = 0; i < s.length() && leftT < t.length(); i++) {\\n            if (s.charAt(i) == t.charAt(leftT)) {\\n                leftSs.add(i);\\n                leftT++;\\n            }\\n        }\\n\\n        int rightT = t.length() - 1;\\n        List<Integer> rightSs = new ArrayList<>();\\n        for (int i = s.length() - 1; i >= 0 && rightT >= 0; i--) {\\n            if (s.charAt(i) == t.charAt(rightT)) {\\n                rightSs.add(i);\\n                rightT--;\\n            }\\n        }\\n\\n        int result = Math.min(t.length() - leftT, rightT + 1);\\n        for (int i = 0; i < rightSs.size(); i++) {\\n            int ind = rightSs.get(i) - 1;\\n            int left = Collections.binarySearch(leftSs, ind);\\n            if (left < 0) {\\n                left = ~left;\\n            } else {\\n                left++;\\n            }\\n            result = Math.min(result, Math.max(0, t.length() - i - 1 - left));\\n            if (result == 0) {\\n                break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224682,
                "title": "prefix-suffix-time-n-space-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = s.length(),i=0,j=0,m = t.length();\\n        vector<int> p(n,0),su(n,0);\\n        for(i = 0; i < n&&j<m; i++){\\n            if(s[i]==t[j]){\\n                j++;\\n                p[i]++;\\n            }\\n            if(i){\\n                p[i] += p[i-1];\\n            }\\n        }\\n        j = m-1;\\n        for(i = n-1; i >=0&&j>=0; i--){\\n            if(s[i]==t[j]){\\n                j--;\\n                su[i]++;\\n            }\\n            if(i!=n-1){\\n                su[i] += su[i+1];\\n            }\\n        }\\n        int ans = n+10;\\n        // for(auto &i: p)cout<<i<<\" \";cout<<endl;\\n        // for(auto &i: su)cout<<i<<\" \";cout<<endl;\\n        // cout<<n-su[0]<<\" \";\\n        for(i = 0; i < n-1; i++){\\n            // cout<<n-p[i]-su[i+1]<<\" \";\\n            ans = min(ans,m-(p[i]+su[i+1]));\\n        }\\n        // cout<<n-p[n-1];\\n        ans = min(ans,m-p[n-1]);\\n        ans = min(ans,m-su[0]);\\n        return max(ans,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = s.length(),i=0,j=0,m = t.length();\\n        vector<int> p(n,0),su(n,0);\\n        for(i = 0; i < n&&j<m; i++){\\n            if(s[i]==t[j]){\\n                j++;\\n                p[i]++;\\n            }\\n            if(i){\\n                p[i] += p[i-1];\\n            }\\n        }\\n        j = m-1;\\n        for(i = n-1; i >=0&&j>=0; i--){\\n            if(s[i]==t[j]){\\n                j--;\\n                su[i]++;\\n            }\\n            if(i!=n-1){\\n                su[i] += su[i+1];\\n            }\\n        }\\n        int ans = n+10;\\n        // for(auto &i: p)cout<<i<<\" \";cout<<endl;\\n        // for(auto &i: su)cout<<i<<\" \";cout<<endl;\\n        // cout<<n-su[0]<<\" \";\\n        for(i = 0; i < n-1; i++){\\n            // cout<<n-p[i]-su[i+1]<<\" \";\\n            ans = min(ans,m-(p[i]+su[i+1]));\\n        }\\n        // cout<<n-p[n-1];\\n        ans = min(ans,m-p[n-1]);\\n        ans = min(ans,m-su[0]);\\n        return max(ans,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3179460,
                "title": "video-explanation-hindi-o-n-prefix-and-suffix-array-c",
                "content": "[Video Explanation ( Hindi )](https://www.youtube.com/watch?v=-BlFzx80flA&t=912s)\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you will carefully observe ,the score depends on the (**maximum and minium index** ) deleted and any **other index between** is **useless** ,  so its better to consider or delete all of them . Then (right - left)+1 = length of substring deleted .\\nAnd now you know the main **hidden** problem , **Find the minimum length of substring which when deleted makes t subsequency of s** .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere the string \\'s\\' does not change and after removing substring from \\'t\\' our t is divided into two parts suffix( part after delted substring to end) and prefix (part from start to just before delted substring) . \\nWe can form two disjoint parts from [0,i] and [i+1, n-1] for each index \\'i\\' , n = length of string \\'s\\' . And for [0,i] we want to find the max length of prefix that we can get from [0,i] characters of \\'s\\' and for [i+1,n-1] we want to find the length of max suffix of \\'t\\' that we can get .\\n\\nLet x = max_prefix_length (for [0,i])\\ny = max_suffix_length ( for [i+1,n-1])\\nm = intial length of string \\'t\\'\\nlen = length of string formed from prefix and sufix for \\'i\\' = (x+y)\\nLenth of substring deleted  = m - len \\nWe find len for each of the \\'i\\' and store the minmum .\\nEdge case when we derive just prefix or suffix from whole string s.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    int minimumScore(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n         int start = 0,end = m-1;\\n        vector<int>pref(n),suff(n);\\n        int i =0 ,j = 0;\\n\\n        //prefix[i] store the max lenght of prefix of array that can be derived\\n        //from characters of string \\'S\\' from [0,i]\\n        int c = 0;\\n        while(i<n && j<m){\\n            if(s[i] == t[j]){\\n                c++;\\n                j++;\\n            }\\n            pref[i] = c;\\n            i++;\\n        }\\n        while(i<n){\\n            pref[i] = c;\\n            i++;\\n        }\\n        // length of substring to remove if we derive prefix from [0,n-1] of \\n        //character of \\'S\\'\\n        int ans = m-c;\\n        i = n-1,j = m-1;\\n         c = 0;\\n\\n        //suffix[i] store the max lenght of prefix of array that can be derived\\n        //from characters of string \\'S\\' from [i,n-1]\\n        while(i>=0 && j>=0){\\n            if(s[i] == t[j]){\\n                c++;\\n                j--;\\n            }\\n            suff[i] = c;\\n            i--;\\n        }\\n        \\n        while(i>=0){\\n            suff[i] = c;\\n            i--;\\n        }\\n        if(c == m)return 0;\\n        \\n        // length of substring to remove if we derive suffix from [0,n-1] of \\n        //character of \\'S\\'\\n        ans = min(m-c,ans);\\n        for(int i=0;i<(n-1);++i){\\n            //m - inital length of string \\'t\\'\\n            // pref[i] + suff[i] = final length of string \\'t\\' after removing substring\\n            ans = min(ans,m - (pref[i]+suff[i+1]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    int minimumScore(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n         int start = 0,end = m-1;\\n        vector<int>pref(n),suff(n);\\n        int i =0 ,j = 0;\\n\\n        //prefix[i] store the max lenght of prefix of array that can be derived\\n        //from characters of string \\'S\\' from [0,i]\\n        int c = 0;\\n        while(i<n && j<m){\\n            if(s[i] == t[j]){\\n                c++;\\n                j++;\\n            }\\n            pref[i] = c;\\n            i++;\\n        }\\n        while(i<n){\\n            pref[i] = c;\\n            i++;\\n        }\\n        // length of substring to remove if we derive prefix from [0,n-1] of \\n        //character of \\'S\\'\\n        int ans = m-c;\\n        i = n-1,j = m-1;\\n         c = 0;\\n\\n        //suffix[i] store the max lenght of prefix of array that can be derived\\n        //from characters of string \\'S\\' from [i,n-1]\\n        while(i>=0 && j>=0){\\n            if(s[i] == t[j]){\\n                c++;\\n                j--;\\n            }\\n            suff[i] = c;\\n            i--;\\n        }\\n        \\n        while(i>=0){\\n            suff[i] = c;\\n            i--;\\n        }\\n        if(c == m)return 0;\\n        \\n        // length of substring to remove if we derive suffix from [0,n-1] of \\n        //character of \\'S\\'\\n        ans = min(m-c,ans);\\n        for(int i=0;i<(n-1);++i){\\n            //m - inital length of string \\'t\\'\\n            // pref[i] + suff[i] = final length of string \\'t\\' after removing substring\\n            ans = min(ans,m - (pref[i]+suff[i+1]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178279,
                "title": "solution-based-on-great-idea-from-java-programmer-cf",
                "content": "# Intuition\\nRefer Java_Programmer_CF solution:\\nhttps://leetcode.com/problems/subsequence-with-the-minimum-score/solutions/3174018/binary-search-sliding-window/?orderBy=most_votes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar minimumScore = function (SS, TT) {\\n  let s = SS.split(\"\"),\\n    t = TT.split(\"\");\\n  let lo = 0,\\n    hi = TT.length;\\n  while (lo <= hi) {\\n    let m = (lo + hi) >> 1;\\n    if (check(s, t, m)) hi = m - 1;\\n    else lo = m + 1;\\n  }\\n  return hi + 1;\\n};\\n\\nfunction check(s, t, len) {\\n  let t_length = t.length,\\n    n = s.length;\\n  if (len >= t_length) return true; //delete whole t array\\n  let pos = Array(t_length).fill(s.length + 1); //Greedy left matching\\n  // Arrays.fill(pos, 1_000_000_0);\\n  let t_left_index = 0;\\n  for (let i = 0; i < n; i++) {\\n    if (t_left_index === t_length) break;\\n    if (t[t_left_index] === s[i]) {\\n      pos[t_left_index] = i;\\n      t_left_index++;\\n    }\\n  }\\n  if (t_left_index >= t_length - len) return true; //we can delete right subarray of length len\\n  let right_index_of_s = n - 1;\\n  for (let rp = t_length - 1; rp >= len; rp--) {\\n    while (right_index_of_s >= 0 && s[right_index_of_s] != t[rp])\\n      right_index_of_s--;\\n    if (right_index_of_s === -1) return false;\\n    let lp = rp - len - 1;\\n    if (lp === -1 || pos[lp] < right_index_of_s) return true;\\n    right_index_of_s--;\\n  }\\n  return false;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar minimumScore = function (SS, TT) {\\n  let s = SS.split(\"\"),\\n    t = TT.split(\"\");\\n  let lo = 0,\\n    hi = TT.length;\\n  while (lo <= hi) {\\n    let m = (lo + hi) >> 1;\\n    if (check(s, t, m)) hi = m - 1;\\n    else lo = m + 1;\\n  }\\n  return hi + 1;\\n};\\n\\nfunction check(s, t, len) {\\n  let t_length = t.length,\\n    n = s.length;\\n  if (len >= t_length) return true; //delete whole t array\\n  let pos = Array(t_length).fill(s.length + 1); //Greedy left matching\\n  // Arrays.fill(pos, 1_000_000_0);\\n  let t_left_index = 0;\\n  for (let i = 0; i < n; i++) {\\n    if (t_left_index === t_length) break;\\n    if (t[t_left_index] === s[i]) {\\n      pos[t_left_index] = i;\\n      t_left_index++;\\n    }\\n  }\\n  if (t_left_index >= t_length - len) return true; //we can delete right subarray of length len\\n  let right_index_of_s = n - 1;\\n  for (let rp = t_length - 1; rp >= len; rp--) {\\n    while (right_index_of_s >= 0 && s[right_index_of_s] != t[rp])\\n      right_index_of_s--;\\n    if (right_index_of_s === -1) return false;\\n    let lp = rp - len - 1;\\n    if (lp === -1 || pos[lp] < right_index_of_s) return true;\\n    right_index_of_s--;\\n  }\\n  return false;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3175777,
                "title": "prefix-suffix-array-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nS: Source string \\nT: Target string (where we can do removal operation)\\n\\nWe have to find longest prefix and suffix of T that is a subsequence of S.\\nWe have to do some operation on them (prefix and suffix array) to figure what elements will remain at end. We can get the removal length by subtracting this present length from length of T\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nS: Source string \\nT: Target string (where we can do removal operation)\\n1. Find the longest prefix of T that is a subsequence of S\\n2. Find the longest suffix of T that is a subsequence of S\\n3. If the length of prefix = length of T, answer is 0 as no removal required\\n4. Find the minimum overlap that can be eliminated. This can be achieved by binary search. We can iterate prefix array and search in suffix array the value greater than current value.\\n5. We get present element length = length of prefix + length of suffix - overlap\\n6. Cost = length of T - present length \\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        vector<int> prefix, suffix;\\n        \\n        for(int i = 0, j = 0; i < s.length() and j < t.length(); i++) {\\n            if(s[i] == t[j]) {\\n                prefix.push_back(i);\\n                j++;\\n            }\\n        }\\n        \\n        for(int i = s.length() - 1, j = t.length() - 1; 0 <= i and 0 <= j; i--) {\\n            if(s[i] == t[j]) {\\n                suffix.push_back(i);\\n                j--;\\n            }\\n        }   \\n        reverse(suffix.begin(), suffix.end());\\n        \\n        if(prefix.size() == t.length()) { // already a subsequence\\n            return 0;\\n        }\\n        \\n        int overlap = prefix.size();\\n        for(int i = 0; i < prefix.size(); i++) {\\n            // eliminated from prefix\\n            int left = prefix.size() - i - 1;\\n            // eliminated from suffix\\n            int right = upper_bound(suffix.begin(), suffix.end(), prefix[i]) - suffix.begin();\\n            // minimum elimination required for prefix_end < suffix_start\\n            overlap = min(overlap, left + right);\\n        }\\n        \\n        // elements present at the end\\n        int present = prefix.size() + suffix.size() - overlap;\\n        // elements eleminated or the cost\\n        return t.length() - present;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        vector<int> prefix, suffix;\\n        \\n        for(int i = 0, j = 0; i < s.length() and j < t.length(); i++) {\\n            if(s[i] == t[j]) {\\n                prefix.push_back(i);\\n                j++;\\n            }\\n        }\\n        \\n        for(int i = s.length() - 1, j = t.length() - 1; 0 <= i and 0 <= j; i--) {\\n            if(s[i] == t[j]) {\\n                suffix.push_back(i);\\n                j--;\\n            }\\n        }   \\n        reverse(suffix.begin(), suffix.end());\\n        \\n        if(prefix.size() == t.length()) { // already a subsequence\\n            return 0;\\n        }\\n        \\n        int overlap = prefix.size();\\n        for(int i = 0; i < prefix.size(); i++) {\\n            // eliminated from prefix\\n            int left = prefix.size() - i - 1;\\n            // eliminated from suffix\\n            int right = upper_bound(suffix.begin(), suffix.end(), prefix[i]) - suffix.begin();\\n            // minimum elimination required for prefix_end < suffix_start\\n            overlap = min(overlap, left + right);\\n        }\\n        \\n        // elements present at the end\\n        int present = prefix.size() + suffix.size() - overlap;\\n        // elements eleminated or the cost\\n        return t.length() - present;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174195,
                "title": "o-n-left-match-and-right-match-easy-to-understand-c",
                "content": "The key idea is if we fix the min (left) idex to remove,  how to find the min right idex as the last characater to be removed.\\nWe can do this by the following step:\\n1 Calculate the left first match, and store the min match index in a deque (vector should be fine also).\\n2 Calculate the right first match, and store the max match index in a deque.\\n3 For each element in the left match deque, if we use it as last index on left,  then indices less or equal to it in the right match deque are invalid, should be pop out. And the rest in right deque is the max match on right side we can have.\\n4 When we iterate over left deque, we get all possible left and right. Notice that if the left or right match deque has a size same as t, the answer is 0.\\n\\nThe time and space complexity is O(N).\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumScore(string s, string t) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint m = t.size();\\n\\t\\t\\tdeque<int> rmatch;\\n\\t\\t\\tint si = n - 1;\\n\\t\\t\\tint ti = m - 1;\\n\\t\\t\\twhile(si >= 0 && ti >= 0){\\n\\t\\t\\t\\twhile(si >= 0 && ti >= 0 && s[si] == t[ti]){\\n\\t\\t\\t\\t\\trmatch.push_front(si);\\n\\t\\t\\t\\t\\tsi--;\\n\\t\\t\\t\\t\\tti--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsi--;\\n\\t\\t\\t}\\n\\t\\t\\tdeque<int> lmatch;\\n\\t\\t\\tsi = 0;\\n\\t\\t\\tti = 0;\\n\\t\\t\\twhile(si < n && ti < m){\\n\\t\\t\\t\\twhile(si < n && ti < m && s[si] == t[ti]){\\n\\t\\t\\t\\t\\tlmatch.push_back(si);\\n\\t\\t\\t\\t\\tsi++;\\n\\t\\t\\t\\t\\tti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsi++;\\n\\t\\t\\t}\\n\\t\\t\\tif(lmatch.size() == m) return 0;\\n\\t\\t\\tint ans = min(m, m - (int)rmatch.size());\\n\\t\\t\\tfor(int i = 0; i < lmatch.size(); i++){\\n\\t\\t\\t\\tint left = i + 1;\\n\\t\\t\\t\\twhile(!rmatch.empty() && rmatch.front() <= lmatch[i]){\\n\\t\\t\\t\\t\\trmatch.pop_front();\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tint right = m - 1 - rmatch.size();\\n\\t\\t\\t\\tans = min(ans, right - left + 1);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumScore(string s, string t) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint m = t.size();\\n\\t\\t\\tdeque<int> rmatch;\\n\\t\\t\\tint si = n - 1;\\n\\t\\t\\tint ti = m - 1;\\n\\t\\t\\twhile(si >= 0 && ti >= 0){\\n\\t\\t\\t\\twhile(si >= 0 && ti >= 0 && s[si] == t[ti]){\\n\\t\\t\\t\\t\\trmatch.push_front(si);\\n\\t\\t\\t\\t\\tsi--;\\n\\t\\t\\t\\t\\tti--;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3719786,
                "title": "o-n-time-and-space-solution-using-a-queue-and-a-stack",
                "content": "# Intuition\\n\\nMy initial thought was that this should be a dynamic programming problem as it superficially sounds related to the classic longest subsequence problem (e.g., see Cormen\\'s Algorithms Text, DP Chapter). However, upon closer inspection, the problem is asking for something much simpler: the minimum distance between the first index that must be removed and the last index that must be removed to make the second string a subsequence of the first.\\n\\nNote that this is actually not equivalent to the LCS problem. As an example:\\n\\nLeft: complain\\nRight: paning\\n\\nThe lonest common subsequence is \"pain\"; however, the subsequence that solves the problem is actually \"pan\" (\"ing\" get removed, which gives a minimum score of 3).\\n\\nThe correct way to think about it is to really focus on delaying the first character that should be removed while similtaneously considering its impact on the last character that should be removed.\\n\\nThe best way to explain the intuition behind my algorithm is with an example. Consider again:\\n\\nLeft: complain\\nRight: paningoman\\n\\nThe minimum score is the minimum value of (maxRemove - minRemove). To maximimize minRemove (which reduces the score), we need to maximize the length of the prefix of \"paning\" that occurs in \"complain\". Note that \\'p\\' occurs at index 3 in complain, \\'a\\' occurs at index 5 (must be at an index greater than 3 to preserve subsequence order), \\'n\\' occurs at index 7, and then \\'i\\' can not longer exist in the subsequence of \"comPlAiN\" (where capitical letters should how the prefix \"pan\" becomes a subsequence of \"complain\"). Note that if we select \"pan\" as our subsequence, it means that we must remove all character of the suffix \"ingoman\", which gives us a score of 7.\\n\\nWe could also work backwards to minimize maxRemove by considering how much of the suffix of \"paningoman\" we can turn into a subsequence of \"complain\". Note that the last \\'n\\' occurs at index 7 in \"complain\", \\'a\\' occurs at index 5, \\'m\\' occurs at index 2, and \\'o\\' occurs at index 1. If we select \"oman\" as our subsequence, then we would need to remove the prefix \"paning\", which results in a score of 6 (which is better than 7).\\n\\nWe can also consider a hybrid of what is described in the last two paragraphs. We can simultaneosly select a prefix and a suffix of \"paningoman\" that attempts to increase minRemove and decrease maxRemove in a way that minimizes the overall score.\\n\\nNote that the prefixes of \"paningoman\" that fit as a subsequence in \"complain\" occur at indices:\\n\\n3, 5, 7 (this will be a queue as we will read element FIFO)\\n\\nNow traversing backwards through the two input strings, we note that the suffixes of \"paningoman\" that fit as a subsequence in \"complain\" occur at indices:\\n\\n1, 2, 5, 7 (this will be a stack as we will read elements LIFO)\\n\\nWe will refer to the first queue as `leftCand` or candidates that we will incrementally add to a prefix of \"paningoman\" that will exist in our optimal subsequence. We will refer to the second stack as `rightUsed`, which reflects the suffix of \"paningoman\" that will exist in our optimal subsequence. We will incrementally remove elements from `rightUsed` as we add elements of `leftCand`.\\n\\nThe first subsequence we will consider will be the characters at indices\\n\\n1, 2, 5, 7\\n\\nwhich is exactly equal to `rightUsed`. This corresponds to \"oman\". The score is 6 since we must remove \"paning\".\\n\\nNext, we want to add the first 3 from `leftCand` into our subsequence. But to do this, we must remove the 1 and 2 (since they occur before 3 and we need to maintain the subsequence property). This gives us\\n\\n3, 5, 7\\n\\nThis corresponds to \"pan\", which removes the substring \"aningom\", which gives us a score of 7 (not minimal, so 6 is still the best).\\n\\nNext, we want to add the second 5 from `leftCand` into our subsequence. But to do this, we have to remove the existing 5, again, since we want to preserve the subsequence property. This gives us\\n\\n3, 5, 7\\n\\nwhich is identical to the previous case. It turns out we will also get 3, 5, 7 when we insert the last 7 from `leftCand` and remove the 7 from `rightUsed`.\\n\\nThe final answer is that the minimum score is 6.\\n\\n\\n# Approach\\n\\n1. Generate a queue `leftCand` consisting of the indices in `leftString` corresponding to the first n consecutive characters (i.e., prefix) of `rightString`. Note that this queue can be empty if the first character of `rightString` does not exist.\\n2. Generate a stack `rightUsed` consisting of the indices in `leftString` corresponding to the last n consecutive character (i.e., suffix) of `rightString`. Note that elements being removed from this stack should be ascending order. Also, note that this stack can be empty if the last chacter of `leftString` does not exist in `rightString`.\\n3. First calculate the score based on the subsequence implied by `rightUsed`. If there are no elements in `leftCand`, this this will be the minimum score.\\n4. While `leftCand` is non-empty, pop the next element from the queue. Remove any indices from `rightUsed` that are less than or equal to the element popped off of `leftCand`. The list of all elements popped off of `leftCand` so far and the remaining (non-popped) elements of `rightUsed` for the next candidate subsequence. Calculate its score and check if it is minimal.\\n5. Return the minimum score found.\\n\\n\\n# Complexity\\nAssume that the left string has length n and the right string has length m.\\n\\n**Time complexity:** \\nCreating the `leftCand` queue and `rightString` stack both require a single full pass of the left string, which requires O(n) steps.\\n\\nThe main loop requires `|leftCand| + |rightUsed|` steps which is maximally O(2 x min(n, m)) = O(n).\\n\\nThe overall time complexity is O(n).\\n\\n**Space complexity:**\\nThe only addition space created are from the queue `leftCand` and the stack `rightUsed`. This will be O(1) in the best case and O(n) in the worst case.\\n\\n# Code\\nThe following python3 code passed all test cases. It uses the `deque` class to create the necessary queue and stack.\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    \\n    def getLeftIndices(leftString, rightString):\\n        rightIdx = 0\\n        leftCand = deque()\\n        for idx, letter in enumerate(leftString):\\n            if letter == rightString[rightIdx]:\\n                leftCand.append(idx)\\n                rightIdx += 1\\n                if rightIdx >= len(rightString):\\n                    break\\n        return leftCand\\n\\n    def getRightIndices(leftString, rightString):\\n        rightIdx = len(rightString) - 1\\n        rightCand = deque()\\n        for idx, letter in enumerate(leftString[::-1]):\\n            if letter == rightString[rightIdx]:\\n                rightCand.appendleft(len(leftString) - 1 - idx)\\n                rightIdx -= 1\\n                if rightIdx < 0:\\n                    break\\n        return rightCand\\n\\n    def minimumScore(self, s: str, t: str) -> int:\\n        leftCand = Solution.getLeftIndices(s, t)\\n        rightUsed = Solution.getRightIndices(s, t)\\n\\n        minRemove = 0\\n        maxRemove = len(t) - 1 - len(rightUsed)\\n        minScore = maxRemove - minRemove + 1\\n\\n        score = minScore\\n        while minScore > 0 and len(leftCand) > 0: \\n            if len(rightUsed) == 0 or leftCand[0] < rightUsed[0]:\\n                minRemove += 1\\n                leftCand.popleft()\\n            else:\\n                maxRemove += 1\\n                rightUsed.popleft()\\n            score = maxRemove - minRemove + 1\\n            minScore = min(score, minScore)\\n\\n        return minScore\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    \\n    def getLeftIndices(leftString, rightString):\\n        rightIdx = 0\\n        leftCand = deque()\\n        for idx, letter in enumerate(leftString):\\n            if letter == rightString[rightIdx]:\\n                leftCand.append(idx)\\n                rightIdx += 1\\n                if rightIdx >= len(rightString):\\n                    break\\n        return leftCand\\n\\n    def getRightIndices(leftString, rightString):\\n        rightIdx = len(rightString) - 1\\n        rightCand = deque()\\n        for idx, letter in enumerate(leftString[::-1]):\\n            if letter == rightString[rightIdx]:\\n                rightCand.appendleft(len(leftString) - 1 - idx)\\n                rightIdx -= 1\\n                if rightIdx < 0:\\n                    break\\n        return rightCand\\n\\n    def minimumScore(self, s: str, t: str) -> int:\\n        leftCand = Solution.getLeftIndices(s, t)\\n        rightUsed = Solution.getRightIndices(s, t)\\n\\n        minRemove = 0\\n        maxRemove = len(t) - 1 - len(rightUsed)\\n        minScore = maxRemove - minRemove + 1\\n\\n        score = minScore\\n        while minScore > 0 and len(leftCand) > 0: \\n            if len(rightUsed) == 0 or leftCand[0] < rightUsed[0]:\\n                minRemove += 1\\n                leftCand.popleft()\\n            else:\\n                maxRemove += 1\\n                rightUsed.popleft()\\n            score = maxRemove - minRemove + 1\\n            minScore = min(score, minScore)\\n\\n        return minScore\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247392,
                "title": "java-left-right",
                "content": "```\\n// separate string s into two parts and match subsequence forward and backward separately\\n    class Solution {\\n        public int minimumScore(String s, String t) {\\n            int m = s.length(), n = t.length();\\n            int[] left = new int[m];\\n            for (int i = 0, j = 0; i < m; i++) {\\n                if (j < n && s.charAt(i) == t.charAt(j)) {\\n                    ++j;\\n                }\\n                left[i] = j;\\n            }\\n            int[] right = new int[m];\\n            for (int i = m - 1, j = n - 1; i >= 0 ; i--) {\\n                if (j >= 0 && s.charAt(i) == t.charAt(j)) {\\n                    --j;\\n                }\\n                right[i] = j;\\n            }\\n            int min = Math.min(n - left[m - 1], right[0] + 1);\\n            for (int i = 0; i + 1 < m; i++) {\\n                min = Math.min(min, Math.max(0, right[i + 1] - left[i] + 1));\\n            }\\n            return min;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int minimumScore(String s, String t) {\\n            int m = s.length(), n = t.length();\\n            int[] left = new int[m];\\n            for (int i = 0, j = 0; i < m; i++) {\\n                if (j < n && s.charAt(i) == t.charAt(j)) {\\n                    ++j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3181684,
                "title": "c-with-explanation-prefix-suffix",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        Question can be converted into find the minimum length of substring that can be deleted such that rest becomes a subsequence of s\\n    */\\n    \\n    int minimumScore(string s, string t) {\\n        vector<int>prefix, suffix;\\n        int i = 0, j = 0, n = s.size(), m = t.size(), count = 0;\\n        while(i < n && j < m){\\n            if(s[i] == t[j]){\\n                i++; j++; count++;\\n            }else i++;\\n            prefix.push_back(count);\\n        }\\n        i = n - 1, j = m - 1, count = 0;\\n        while(i >= 0 && j >= 0){\\n            if(s[i] == t[j]){\\n                i--; j--; count++;\\n            }else i--;\\n            suffix.push_back(count);\\n        }\\n        reverse(suffix.begin(), suffix.end());\\n        \\n        // Without taking any element\\n        int maxi = suffix[0];\\n        for(int i = 1 ; i < prefix.size() && i < suffix.size() ; i++){\\n            // Building the biggest possible subsequence\\n            maxi = max(maxi, prefix[i - 1] + suffix[i]);\\n            \\n            // Edge case : If we dont have to delete anything\\n            if(maxi >= m)return 0;\\n        }\\n        \\n        // Checking without taking any suffix part\\n        maxi = max(prefix[prefix.size() - 1], maxi);\\n        return m - maxi;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        Question can be converted into find the minimum length of substring that can be deleted such that rest becomes a subsequence of s\\n    */\\n    \\n    int minimumScore(string s, string t) {\\n        vector<int>prefix, suffix;\\n        int i = 0, j = 0, n = s.size(), m = t.size(), count = 0;\\n        while(i < n && j < m){\\n            if(s[i] == t[j]){\\n                i++; j++; count++;\\n            }else i++;\\n            prefix.push_back(count);\\n        }\\n        i = n - 1, j = m - 1, count = 0;\\n        while(i >= 0 && j >= 0){\\n            if(s[i] == t[j]){\\n                i--; j--; count++;\\n            }else i--;\\n            suffix.push_back(count);\\n        }\\n        reverse(suffix.begin(), suffix.end());\\n        \\n        // Without taking any element\\n        int maxi = suffix[0];\\n        for(int i = 1 ; i < prefix.size() && i < suffix.size() ; i++){\\n            // Building the biggest possible subsequence\\n            maxi = max(maxi, prefix[i - 1] + suffix[i]);\\n            \\n            // Edge case : If we dont have to delete anything\\n            if(maxi >= m)return 0;\\n        }\\n        \\n        // Checking without taking any suffix part\\n        maxi = max(prefix[prefix.size() - 1], maxi);\\n        return m - maxi;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179457,
                "title": "12ms-c-sliding-window-full-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First thing to notice is that if I\\'m chosing a score x where difference in leftmost deleted element and rightmost deleted element is x, why not delete this whole substring as it will reduce the no. of matches needed and also doesn\\'t affect the score.\\n2. Store prefix and suffix arrays which keeps the minimum index in s for a subsequence match of prefix and suffix of t.\\n    For ex - \\n    s: babacabca\\n    t: bbc\\n\\n    pre = {0, 2, 4}\\n    suf = {2, 6, 7}\\n3. Binary Search for a given score if it\\'s possible to get a score of x.\\n4. Checking if it is possible to remove x no. of elements in such a way that the prefix + suffix is a subsequence of the other string.\\n    012---678 (deleting indexes 3-5)\\n    using pre[2] < suf[6]\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\nCan be done in O(n) by using suffix on s and prefix on t.\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    \\n    bool pos_to_mch(int mid, vector<int> &pre, vector<int> &suf){\\n        if (mid == 0) return pre[m-1] < n;\\n        else if (mid == m) return true;\\n        \\n        // first #mid characters || last #mid characters\\n        if (suf[mid] >= 0 || pre[m-1-mid] < n) \\n            return true;\\n        \\n        // Deleting #mid character starting from index i\\n        for (int i=1; i+mid<m; i++){\\n            if (pre[i-1] < suf[i+mid]) \\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int minimumScore(string s, string t) {\\n        n = s.size();\\n        m = t.size();\\n        \\n        vector<int> pre_mch(m);\\n        vector<int> suf_mch(m);\\n        \\n        int cur = 0;\\n        for (int i=0; i<m; i++){\\n            while (cur < n && s[cur] != t[i]) \\n                cur++;\\n            pre_mch[i] = cur++;\\n        }\\n        \\n        cur = n-1;\\n        for (int i=m-1; i>=0; i--){\\n            while (cur >= 0 && s[cur] != t[i]) \\n                cur--;\\n            suf_mch[i] = cur--;\\n        }\\n        \\n        int low = 0, high = m;\\n        \\n        while(low <= high){\\n            int mid = (low+high)/2;\\n            if (pos_to_mch(mid, pre_mch, suf_mch))\\n                high = mid-1;\\n            else \\n                low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    \\n    bool pos_to_mch(int mid, vector<int> &pre, vector<int> &suf){\\n        if (mid == 0) return pre[m-1] < n;\\n        else if (mid == m) return true;\\n        \\n        // first #mid characters || last #mid characters\\n        if (suf[mid] >= 0 || pre[m-1-mid] < n) \\n            return true;\\n        \\n        // Deleting #mid character starting from index i\\n        for (int i=1; i+mid<m; i++){\\n            if (pre[i-1] < suf[i+mid]) \\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int minimumScore(string s, string t) {\\n        n = s.size();\\n        m = t.size();\\n        \\n        vector<int> pre_mch(m);\\n        vector<int> suf_mch(m);\\n        \\n        int cur = 0;\\n        for (int i=0; i<m; i++){\\n            while (cur < n && s[cur] != t[i]) \\n                cur++;\\n            pre_mch[i] = cur++;\\n        }\\n        \\n        cur = n-1;\\n        for (int i=m-1; i>=0; i--){\\n            while (cur >= 0 && s[cur] != t[i]) \\n                cur--;\\n            suf_mch[i] = cur--;\\n        }\\n        \\n        int low = 0, high = m;\\n        \\n        while(low <= high){\\n            int mid = (low+high)/2;\\n            if (pos_to_mch(mid, pre_mch, suf_mch))\\n                high = mid-1;\\n            else \\n                low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176665,
                "title": "prefix-array-suffix-array-binary-search-o-n-log-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you will visualise you will find that character between **right** and **left** of deleted charactes of \\'t\\' are useless ,it is better to consider them then as deleted as they will not effect the score .\\n\\nNow Problem statement changes **Find the smallest substring that can be deleted from t** such that **t become subsequence of s** . \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI created two arrays prefix which store the index of \\'s\\' which matches with jth prefix character of \\'t\\' , similarly a suffix array .\\n\\nNow I want ot find max length disjoint set of prefix and suffix which minimise my value /score.\\n\\nSo For each of **prefix value** I consider I find the **smallest index with value just greater than prefix[i]** in **suffix** array , this will give me length of suffix that is disjoint or from [pref[i]+1,m-1] . \\nm = length of t\\nThe score is ((index-1) - (pref[i]+1) )+ 1 . \\nIndex is the smallest value > than pref[i] , I delete all the elements from (prefix[i]+1 tot index-1) . I find score for each prefix \\'i\\' and store the minimum value.\\n\\n-- Consider the case when we don\\'t take any prefix value.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    /*\\n    I will delete a substring from t such that  prefix of of t before substring and suffix of t after substring\\n    is a subsequency of s\\n    */\\n    int search(vector<int>&A,int value){\\n        int start = 0,end = A.size()-1,mid = (start+end)/2;\\n        int ans = -1;\\n        while(start<=end){\\n            //find the smallest element greater than value  \\n            //I want to find max_suffix that is subsequence of \\'s\\' from [value+1 , t.size()-1]\\n            if(A[mid] > value){\\n                ans = mid;\\n                end = mid-1;\\n                mid = (start+end)/2;\\n            }\\n            else{\\n                start = mid+1;\\n                mid = (start+end)/2;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int minimumScore(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n         int start = 0,end = m-1;\\n        vector<int>pref,suff;\\n        int i =0 ,j = 0;\\n\\n        //find prefix array which store the index of \\'s\\'\\n        //which matches with jth prefix character of t\\n        while(i<n && j<m){\\n            if(s[i] == t[j]){\\n                pref.push_back(i);\\n                start = j;\\n                j++;\\n            }\\n            i++;\\n        }\\n        \\n        i = n-1,j = m-1;\\n        //similarly find suffix array which store the index of \\'s\\'\\n        //which matches jth character of t\\n        while(i>=0 && j>=0){\\n            if(s[i] == t[j]){\\n                suff.push_back(i);\\n                end = j;\\n                j--;\\n            }\\n            i--;\\n        }\\n        if(end == 0)return 0;\\n        reverse(suff.begin(),suff.end());\\n         //sort the suffix array in increasing order\\n        int ans = m;\\n\\n        //we find score in case we delete a prefix from 0 to suff[0]-1\\n        if(suff.size()){\\n            int len = suff.size();\\n            ans = min(ans,(m-len));\\n        }\\n        \\n        for(int i=0;i<pref.size();++i){\\n             //for each prefix character we consider\\n             //we want to find the size of matching suffix \\n             //from [pref[i+1] , m-1]\\n            int idx = search(suff,pref[i]);\\n            \\n            //we consider the case when we delete suffix from [pref[i],m-1]\\n            ans = min(ans,m-(i+1));\\n            if(idx != -1){\\n                int last = m - (suff.size() - idx);\\n                \\n                last--;\\n                \\n                ans = min(ans,(last - (i+1))+1);\\n            }\\n            \\n        }\\n        \\n        //cout<<\"\\\\n\";\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    /*\\n    I will delete a substring from t such that  prefix of of t before substring and suffix of t after substring\\n    is a subsequency of s\\n    */\\n    int search(vector<int>&A,int value){\\n        int start = 0,end = A.size()-1,mid = (start+end)/2;\\n        int ans = -1;\\n        while(start<=end){\\n            //find the smallest element greater than value  \\n            //I want to find max_suffix that is subsequence of \\'s\\' from [value+1 , t.size()-1]\\n            if(A[mid] > value){\\n                ans = mid;\\n                end = mid-1;\\n                mid = (start+end)/2;\\n            }\\n            else{\\n                start = mid+1;\\n                mid = (start+end)/2;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int minimumScore(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n         int start = 0,end = m-1;\\n        vector<int>pref,suff;\\n        int i =0 ,j = 0;\\n\\n        //find prefix array which store the index of \\'s\\'\\n        //which matches with jth prefix character of t\\n        while(i<n && j<m){\\n            if(s[i] == t[j]){\\n                pref.push_back(i);\\n                start = j;\\n                j++;\\n            }\\n            i++;\\n        }\\n        \\n        i = n-1,j = m-1;\\n        //similarly find suffix array which store the index of \\'s\\'\\n        //which matches jth character of t\\n        while(i>=0 && j>=0){\\n            if(s[i] == t[j]){\\n                suff.push_back(i);\\n                end = j;\\n                j--;\\n            }\\n            i--;\\n        }\\n        if(end == 0)return 0;\\n        reverse(suff.begin(),suff.end());\\n         //sort the suffix array in increasing order\\n        int ans = m;\\n\\n        //we find score in case we delete a prefix from 0 to suff[0]-1\\n        if(suff.size()){\\n            int len = suff.size();\\n            ans = min(ans,(m-len));\\n        }\\n        \\n        for(int i=0;i<pref.size();++i){\\n             //for each prefix character we consider\\n             //we want to find the size of matching suffix \\n             //from [pref[i+1] , m-1]\\n            int idx = search(suff,pref[i]);\\n            \\n            //we consider the case when we delete suffix from [pref[i],m-1]\\n            ans = min(ans,m-(i+1));\\n            if(idx != -1){\\n                int last = m - (suff.size() - idx);\\n                \\n                last--;\\n                \\n                ans = min(ans,(last - (i+1))+1);\\n            }\\n            \\n        }\\n        \\n        //cout<<\"\\\\n\";\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3174357,
                "title": "c-beginner-friendly-binary-search",
                "content": "# Intuition\\nUse binary search template to find a minimal window that can be ignored in `t`.\\n\\n# Approach\\nGiven a window size:\\n0. we need to match `t.size() - window` char.\\n1. greedy match `t` from `s`\\'s left to right, keep matched one in an array\\n2. greedy match `t` from `s`\\'s right to left by a window until all char in `t` are matched.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool criteria(string& s, string& t, int window) {\\n        // should match t.size() - window\\n        int n = t.size() - window;\\n        if (n == 0) return true;\\n        vector<int> collection(n, -1);\\n        int index = 0;\\n        int collectionIdx = 0;\\n        int validCnt = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == t[index] && collectionIdx < collection.size()) {\\n                collection[collectionIdx] = i;\\n                collectionIdx++;\\n                validCnt++;\\n                index++;\\n            }\\n        }\\n        if (validCnt == n) return true;\\n        \\n        index = t.size() - 1;\\n        collectionIdx = n - 1;\\n        for (int i = s.size() - 1; i >= 0; --i) {\\n            if (s[i] == t[index] && collectionIdx >= 0) {\\n                \\n                if (collection[collectionIdx] == -1) {\\n                    validCnt++;\\n                }\\n                collection[collectionIdx] = i;\\n                if (validCnt == n) {\\n                    if (collectionIdx == 0) return true;\\n                    if (collectionIdx > 0 && i > collection[collectionIdx - 1]) return true;\\n                }\\n                index--;\\n                collectionIdx--;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    int minimumScore(string s, string t) {\\n        int left = 0;\\n        int right = t.size();\\n        \\n        while (left < right) {\\n\\n            int mid = left + (right - left) / 2;\\n            if (criteria(s, t, mid)) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool criteria(string& s, string& t, int window) {\\n        // should match t.size() - window\\n        int n = t.size() - window;\\n        if (n == 0) return true;\\n        vector<int> collection(n, -1);\\n        int index = 0;\\n        int collectionIdx = 0;\\n        int validCnt = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == t[index] && collectionIdx < collection.size()) {\\n                collection[collectionIdx] = i;\\n                collectionIdx++;\\n                validCnt++;\\n                index++;\\n            }\\n        }\\n        if (validCnt == n) return true;\\n        \\n        index = t.size() - 1;\\n        collectionIdx = n - 1;\\n        for (int i = s.size() - 1; i >= 0; --i) {\\n            if (s[i] == t[index] && collectionIdx >= 0) {\\n                \\n                if (collection[collectionIdx] == -1) {\\n                    validCnt++;\\n                }\\n                collection[collectionIdx] = i;\\n                if (validCnt == n) {\\n                    if (collectionIdx == 0) return true;\\n                    if (collectionIdx > 0 && i > collection[collectionIdx - 1]) return true;\\n                }\\n                index--;\\n                collectionIdx--;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    int minimumScore(string s, string t) {\\n        int left = 0;\\n        int right = t.size();\\n        \\n        while (left < right) {\\n\\n            int mid = left + (right - left) / 2;\\n            if (criteria(s, t, mid)) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174178,
                "title": "c-java-python3-binary-search-in-value-range",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n---\\n\\n# Intuition\\n1. **Clearly, \"remove all\" is no worse than \"remove some\" for selected subsequences.**\\n2. Furthermore, if deleting a short string can make $t$ a subsequence of $s$, then it must also be true to expand on the basis of this short string.\\n3. Therefore, the answer is dichotomous in the value domain, and binary search can be considered.\\n4. In each sample, check whether each substring of length $x$ meets the requirements after deletion. If any one is found, the result of $x$ is true, otherwise it is false.\\n5. Note that when enumerating each substring, $t$ will be cut into two segments, so it is only necessary to check whether the $left + right$ is a subsequence of $s$.\\n6. For the left part, greedily match the left side of $s$, and record $t[0...i]$ that can become the smallest $j$ of a subsequence of $s[0...j]$. The same is true for the right part, the record $t[i...n]$ can become the largest $j$ of the subsequence of $s[j...m]$.\\n7. In this way, it is enough to scan one round and check whether there is a qualified substring.\\n\\n# Approach\\n1. \\n\\n# Complexity\\n- Time complexity: $O(m + n\\\\log{n})$\\n- Space complexity: $O(m+n)$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int m = s.size(), n = t.size();\\n        vector<int> left(n+2, -1), right(n+2, m);\\n        int p = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (p < m && s[p] != t[i]) p++;\\n            left[i+1] = p++;\\n        }\\n        p = m - 1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (p >= 0 && s[p] != t[i]) p--;\\n            right[i+1] = p--;\\n        }\\n        auto check = [&](int x) -> bool {\\n            for (int i = 0; i + x - 1 < n; ++i) {\\n                if (left[i] < right[i+x+1]) \\n                    return true;\\n            }\\n            return false;\\n        };\\n        int l = 0, r = n;\\n        while (l <= r) {\\n            int x = (l + r) / 2;\\n            if (check(x)) r = x - 1;\\n            else l = x + 1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        int m = s.length(), n = t.length();\\n        int []left = new int[n+2];\\n        int []right = new int[n+2];\\n        int p = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (p < m && s.charAt(p) != t.charAt(i)) p++;\\n            left[i+1] = p++;\\n        }\\n        left[0] = -1;\\n        p = m - 1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (p >= 0 && s.charAt(p) != t.charAt(i)) p--;\\n            right[i+1] = p--;\\n        }\\n        right[n+1] = m;\\n\\n        int l = 0, r = n;\\n        while (l <= r) {\\n            int x = (l + r) / 2;\\n            boolean flag = false;\\n            for (int i = 0; i + x - 1 < n; ++i) {\\n                if (left[i] < right[i+x+1]) \\n                    flag = true;\\n            }\\n            if (flag) r = x - 1;\\n            else l = x + 1;\\n        }\\n        return l;\\n    }\\n}\\n```\\n``` Python3 []\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        m, n = len(s), len(t)\\n        left, right = [-1] * (n+2), [m] * (n+2)\\n        p = 0\\n        for i in range(n):\\n            while p < m and s[p] != t[i]: p += 1\\n            left[i+1] = p\\n            p += 1\\n        p = m - 1\\n        for i in range(n-1, -1, -1):\\n            while p >= 0 and s[p] != t[i]: p -= 1\\n            right[i+1] = p\\n            p -= 1\\n\\n        def check(x): \\n            for i in range(n + 1 - x):\\n                if left[i] < right[i+x+1]:\\n                    return True\\n            return False\\n\\n        l, r = 0, n\\n        while l <= r:\\n            x = (l + r) // 2;\\n            if (check(x)): r = x - 1\\n            else: l = x + 1\\n        return l\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int m = s.size(), n = t.size();\\n        vector<int> left(n+2, -1), right(n+2, m);\\n        int p = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (p < m && s[p] != t[i]) p++;\\n            left[i+1] = p++;\\n        }\\n        p = m - 1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (p >= 0 && s[p] != t[i]) p--;\\n            right[i+1] = p--;\\n        }\\n        auto check = [&](int x) -> bool {\\n            for (int i = 0; i + x - 1 < n; ++i) {\\n                if (left[i] < right[i+x+1]) \\n                    return true;\\n            }\\n            return false;\\n        };\\n        int l = 0, r = n;\\n        while (l <= r) {\\n            int x = (l + r) / 2;\\n            if (check(x)) r = x - 1;\\n            else l = x + 1;\\n        }\\n        return l;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        int m = s.length(), n = t.length();\\n        int []left = new int[n+2];\\n        int []right = new int[n+2];\\n        int p = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (p < m && s.charAt(p) != t.charAt(i)) p++;\\n            left[i+1] = p++;\\n        }\\n        left[0] = -1;\\n        p = m - 1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (p >= 0 && s.charAt(p) != t.charAt(i)) p--;\\n            right[i+1] = p--;\\n        }\\n        right[n+1] = m;\\n\\n        int l = 0, r = n;\\n        while (l <= r) {\\n            int x = (l + r) / 2;\\n            boolean flag = false;\\n            for (int i = 0; i + x - 1 < n; ++i) {\\n                if (left[i] < right[i+x+1]) \\n                    flag = true;\\n            }\\n            if (flag) r = x - 1;\\n            else l = x + 1;\\n        }\\n        return l;\\n    }\\n}\\n```\n``` Python3 []\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        m, n = len(s), len(t)\\n        left, right = [-1] * (n+2), [m] * (n+2)\\n        p = 0\\n        for i in range(n):\\n            while p < m and s[p] != t[i]: p += 1\\n            left[i+1] = p\\n            p += 1\\n        p = m - 1\\n        for i in range(n-1, -1, -1):\\n            while p >= 0 and s[p] != t[i]: p -= 1\\n            right[i+1] = p\\n            p -= 1\\n\\n        def check(x): \\n            for i in range(n + 1 - x):\\n                if left[i] < right[i+x+1]:\\n                    return True\\n            return False\\n\\n        l, r = 0, n\\n        while l <= r:\\n            x = (l + r) // 2;\\n            if (check(x)): r = x - 1\\n            else: l = x + 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174069,
                "title": "python-iterate-from-both-sides-explanation-and-comment",
                "content": "First, we consider that given `left` that `t[:left]` is a substring of `s[:sleft]`, how can we find the best `right`?\\nOf course, `right` should be as small as possible. Even we delete a ton of character inside `t` but `t[len(t)-1]` is not deleted, the score is still `len(t) - left`.\\nThus, we should start with the last character of `t` to find if there\\'s a character equals to it in `s[sleft:]`. Every time we find, we should choose the rightest index and we can decrease `right`. Until we cannot decrease `right`, then we should decrease `left` by one to make `sleft` smaller for giving more characters for `t[right]` to match.\\n\\n\\n# Code\\n```Python[]\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        sl = 0\\n        sr = len(s) - 1\\n        tl = 0\\n        tr = len(t) - 1\\n        k = {}\\n        for tl in range(len(t)):\\n            while sl < len(s) and s[sl] != t[tl]:\\n                sl += 1\\n            if sl == len(s):\\n                tl -= 1\\n                break\\n            # save smallest sleft for all left\\n            k[tl] = sl\\n            sl += 1\\n            \\n        # we set left = -1, when we don\\'t use left\\n        k[-1] = -1\\n        ans = tr - tl\\n        # iterate every left by decreasing one\\n        # releave the limitation of s[sleft:]\\n        for ntl in range(tl, -2, -1):\\n            # every time we decrease left, check if right can be decreased\\n            while tr > ntl and sr > k[ntl]:\\n                if s[sr] != t[tr]:\\n                    sr -= 1\\n                elif s[sr] == t[tr]:\\n                    sr -= 1\\n                    tr -= 1\\n            ans = min(tr - ntl, ans)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python[]\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        sl = 0\\n        sr = len(s) - 1\\n        tl = 0\\n        tr = len(t) - 1\\n        k = {}\\n        for tl in range(len(t)):\\n            while sl < len(s) and s[sl] != t[tl]:\\n                sl += 1\\n            if sl == len(s):\\n                tl -= 1\\n                break\\n            # save smallest sleft for all left\\n            k[tl] = sl\\n            sl += 1\\n            \\n        # we set left = -1, when we don\\'t use left\\n        k[-1] = -1\\n        ans = tr - tl\\n        # iterate every left by decreasing one\\n        # releave the limitation of s[sleft:]\\n        for ntl in range(tl, -2, -1):\\n            # every time we decrease left, check if right can be decreased\\n            while tr > ntl and sr > k[ntl]:\\n                if s[sr] != t[tr]:\\n                    sr -= 1\\n                elif s[sr] == t[tr]:\\n                    sr -= 1\\n                    tr -= 1\\n            ans = min(tr - ntl, ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174046,
                "title": "c-o-nlogn-sliding-window-binary-search-intuition-approach",
                "content": "# Intuition\\n1. Say your answer is `x`.\\n2. You will have a window of size `x` inside the string `t`, within which you remove characters. Say this window is from $t_i$ to $t_{i+x-1}$\\n3. For `x` to be the answer, $t_0t_1...t_{i-1}$ and $t_{i+x}t_{i+x+1}...t_{n}$ should be subsequenses of $t$ and earliest index of $t_{i-1}$ < latest index of $t_{i+x}$\\n4. We can binary search for `x` over range `1` to `t.length()``\\n\\n# Approach\\n1. Build a prefix array that stores for an index `i` in `t`, the earliest index in `s`, for which $t_0t_1..t_i$ is a subsequence of `s`.\\n2. Build a suffix array that stores for an index `i` in `t`, the latest index in `s`, for which $t_it_{i+1}..t_n$ is a subsequence of `s`.\\n3. Binary search for window length `x`.\\n4. Slide a window of length `x` through `t`, if a subsquence is found before and after the window that satisfies the condition 3 in Intuition, we search for smaller windows\\n\\n# Complexity\\n- Time complexity:\\n`O(n*logn)`;\\nwhere `n = t.length()``\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = t.size();\\n        int m = s.size();\\n        int pre[n], suf[n];\\n        int i = 0, j = 0;\\n        while(i<n && j<m){\\n            if(t[i] == s[j]){\\n                pre[i] = j;\\n                i++;\\n                j++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        while(i<n){\\n            pre[i++] = INT_MAX;\\n        }\\n        i = n-1; j = m-1;\\n        while(i >= 0 && j >= 0){\\n            if(t[i] == s[j]){\\n                suf[i] = j;\\n                i--;\\n                j--;\\n            }else{\\n                j--;\\n            }\\n        }\\n        while(i>=0){\\n            suf[i--] = INT_MIN;\\n        }\\n        //checking if 0 is the answer\\n        if(pre[n-1] != INT_MAX) return 0;\\n        int low = 1, high = t.size();\\n        bool pos;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            pos = 0;\\n            for(int i = mid-1;i<n;i++){\\n                int ll = (i == mid-1 ? -1 : pre[i-mid]);\\n                int hh = (i == n-1 ? INT_MAX : suf[i+1]);\\n                if(ll < hh){\\n                    pos = 1;\\n                    break;\\n                }\\n            }\\n            if(pos){\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = t.size();\\n        int m = s.size();\\n        int pre[n], suf[n];\\n        int i = 0, j = 0;\\n        while(i<n && j<m){\\n            if(t[i] == s[j]){\\n                pre[i] = j;\\n                i++;\\n                j++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        while(i<n){\\n            pre[i++] = INT_MAX;\\n        }\\n        i = n-1; j = m-1;\\n        while(i >= 0 && j >= 0){\\n            if(t[i] == s[j]){\\n                suf[i] = j;\\n                i--;\\n                j--;\\n            }else{\\n                j--;\\n            }\\n        }\\n        while(i>=0){\\n            suf[i--] = INT_MIN;\\n        }\\n        //checking if 0 is the answer\\n        if(pre[n-1] != INT_MAX) return 0;\\n        int low = 1, high = t.size();\\n        bool pos;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            pos = 0;\\n            for(int i = mid-1;i<n;i++){\\n                int ll = (i == mid-1 ? -1 : pre[i-mid]);\\n                int hh = (i == n-1 ? INT_MAX : suf[i+1]);\\n                if(ll < hh){\\n                    pos = 1;\\n                    break;\\n                }\\n            }\\n            if(pos){\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987054,
                "title": "greedy-largest-prefix-and-suffix-11ms",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimumScore(String s, String t) {\\n    int[] greatestUnmatchedLeft = new int[s.length()];\\n\\n    int minScore = t.length();\\n    for (int i = 0; i < s.length(); i++) {\\n      if (i > 0 && greatestUnmatchedLeft[i - 1] == t.length()) {\\n        return 0;\\n      }\\n\\n      greatestUnmatchedLeft[i] = (i > 0 ? greatestUnmatchedLeft[i - 1] : 0)\\n          + (s.charAt(i) == t.charAt(i > 0 ? greatestUnmatchedLeft[i - 1] : 0) ? 1 : 0);\\n    }\\n\\n    if (greatestUnmatchedLeft[s.length() - 1] == t.length()) {\\n      return 0;\\n    }\\n\\n    int smallestUnmatchedRight = t.length() - 1;\\n    minScore = Math.min(minScore, t.length() - greatestUnmatchedLeft[s.length() - 1]);\\n    for (int j = s.length() - 1; j >= 0; j--) {\\n      if (s.charAt(j) == t.charAt(smallestUnmatchedRight)) {\\n        smallestUnmatchedRight--;\\n        if (smallestUnmatchedRight < 0) {\\n          return 0;\\n        }\\n      }\\n\\n      if (j > 0 && greatestUnmatchedLeft[j - 1] > smallestUnmatchedRight) {\\n        return 0;\\n      }\\n\\n      minScore = Math.min(minScore, smallestUnmatchedRight - (j > 0 ? greatestUnmatchedLeft[j - 1] : 0) + 1);\\n    }\\n\\n    return minScore;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n  public int minimumScore(String s, String t) {\\n    int[] greatestUnmatchedLeft = new int[s.length()];\\n\\n    int minScore = t.length();\\n    for (int i = 0; i < s.length(); i++) {\\n      if (i > 0 && greatestUnmatchedLeft[i - 1] == t.length()) {\\n        return 0;\\n      }\\n\\n      greatestUnmatchedLeft[i] = (i > 0 ? greatestUnmatchedLeft[i - 1] : 0)\\n          + (s.charAt(i) == t.charAt(i > 0 ? greatestUnmatchedLeft[i - 1] : 0) ? 1 : 0);\\n    }\\n\\n    if (greatestUnmatchedLeft[s.length() - 1] == t.length()) {\\n      return 0;\\n    }\\n\\n    int smallestUnmatchedRight = t.length() - 1;\\n    minScore = Math.min(minScore, t.length() - greatestUnmatchedLeft[s.length() - 1]);\\n    for (int j = s.length() - 1; j >= 0; j--) {\\n      if (s.charAt(j) == t.charAt(smallestUnmatchedRight)) {\\n        smallestUnmatchedRight--;\\n        if (smallestUnmatchedRight < 0) {\\n          return 0;\\n        }\\n      }\\n\\n      if (j > 0 && greatestUnmatchedLeft[j - 1] > smallestUnmatchedRight) {\\n        return 0;\\n      }\\n\\n      minScore = Math.min(minScore, smallestUnmatchedRight - (j > 0 ? greatestUnmatchedLeft[j - 1] : 0) + 1);\\n    }\\n\\n    return minScore;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969484,
                "title": "simple-binary-search-using-prefix-and-suffix-arrays-o-nlogn-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        s = \\'0\\'+s+\\'0\\'\\n        t = \\'0\\'+s+\\'0\\'\\n        prefix_arr = [-1 for _ in range(len(t))]\\n        suffix_arr = [-1 for _ in range(len(t))]\\n        \\n        cur_ind = 0\\n        for i in range(len(s)):\\n            if cur_ind >= len(t):\\n                break\\n            if s[i]==t[cur_ind]:\\n                prefix_arr[cur_ind] = i\\n                cur_ind += 1\\n\\n        cur_ind = len(suffix_arr)-1\\n        for i in reversed(range(len(s))):\\n            if cur_ind < 0:\\n                break\\n            if s[i] == t[cur_ind]:\\n                suffix_arr[cur_ind] = i\\n                cur_ind -= 1\\n        min_score = len(t)\\n        for i in range(len(prefix_arr)):\\n            if prefix_arr[i] == -1:\\n                break\\n            low = i+1\\n            high = len(suffix_arr)\\n            while low < high:\\n                mid = int((low+high)/2)\\n                if suffix_arr[mid] == -1 or suffix_arr[mid]<=prefix_arr[i]:\\n                    low = mid+1\\n                else:\\n                    min_score = min(min_score, mid-i-1)\\n                    high = mid  \\n        return min_score\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        s = \\'0\\'+s+\\'0\\'\\n        t = \\'0\\'+s+\\'0\\'\\n        prefix_arr = [-1 for _ in range(len(t))]\\n        suffix_arr = [-1 for _ in range(len(t))]\\n        \\n        cur_ind = 0\\n        for i in range(len(s)):\\n            if cur_ind >= len(t):\\n                break\\n            if s[i]==t[cur_ind]:\\n                prefix_arr[cur_ind] = i\\n                cur_ind += 1\\n\\n        cur_ind = len(suffix_arr)-1\\n        for i in reversed(range(len(s))):\\n            if cur_ind < 0:\\n                break\\n            if s[i] == t[cur_ind]:\\n                suffix_arr[cur_ind] = i\\n                cur_ind -= 1\\n        min_score = len(t)\\n        for i in range(len(prefix_arr)):\\n            if prefix_arr[i] == -1:\\n                break\\n            low = i+1\\n            high = len(suffix_arr)\\n            while low < high:\\n                mid = int((low+high)/2)\\n                if suffix_arr[mid] == -1 or suffix_arr[mid]<=prefix_arr[i]:\\n                    low = mid+1\\n                else:\\n                    min_score = min(min_score, mid-i-1)\\n                    high = mid  \\n        return min_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860216,
                "title": "using-binary-search-and-prefix-suffix",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int util(vector<int>&v, int prev) {\\n        int l = 0, r = v.size() - 1, id = -1;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(v[mid] > prev) {\\n                id = v[mid];\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return id;\\n    }\\n\\n    int util2(vector<int>&v, int prev) {\\n        int l = 0, r = v.size() - 1, id = -1;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(v[mid] < prev) {\\n                id = v[mid];\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return id;\\n    }\\n\\n    bool check(int x, vector<int>& pre, vector<int>& suff) {\\n        for(int i = 0 ; i <= pre.size() - x ; i++) {\\n            if(i > 0 ) {\\n                if(i + x < pre.size()) {\\n                    if(pre[i - 1] >= 0 && suff[i + x] >= 0 && pre[i - 1] < suff[i + x])\\n                        return true;\\n                }else {\\n                    if(pre[i - 1] >= 0)\\n                        return true;\\n                }\\n            }else if(i + x < suff.size() && suff[i + x] >= 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int minimumScore(string s, string t) {\\n        int n = s.length();\\n        map<int,int>mp;\\n        vector<vector<int>>v(26);\\n        for(int i = 0 ; i < n ; i++)\\n            v[s[i] - \\'a\\'].push_back(i);\\n        int l = t.length(), r = -1, prev = -1;\\n        vector<int>pre(l), suff(l);\\n        for(int i = 0 ; i < t.length() ; i++) {\\n            int x = util(v[t[i] - \\'a\\'],prev);\\n            if(x == -1) {\\n                pre[i] = -1;\\n                break;\\n            } else{\\n                pre[i] = x;\\n                prev = x;\\n            }\\n        }\\n        prev = n;\\n        for(int i = t.length() - 1 ; i >= 0 ; i--) {\\n            int x = util2(v[t[i] - \\'a\\'],prev);\\n            if(x == -1) {\\n                suff[i] = -1;\\n                break;\\n            } else {\\n                suff[i] = x;\\n                prev = x;\\n            }\\n        }\\n        for(int i = suff.size() - 2 ; i >= 0 ; i--) {\\n            if(suff[i + 1] == -1)\\n                suff[i] = -1;\\n        }\\n        for(int i = 1 ; i < pre.size() ; i++) {\\n            if(pre[i - 1] == -1)\\n                pre[i] = -1;\\n        }\\n        l = 0, r = t.length();\\n        int id = r;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(check(mid,pre,suff)) {\\n                id = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return id;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int util(vector<int>&v, int prev) {\\n        int l = 0, r = v.size() - 1, id = -1;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(v[mid] > prev) {\\n                id = v[mid];\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return id;\\n    }\\n\\n    int util2(vector<int>&v, int prev) {\\n        int l = 0, r = v.size() - 1, id = -1;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(v[mid] < prev) {\\n                id = v[mid];\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return id;\\n    }\\n\\n    bool check(int x, vector<int>& pre, vector<int>& suff) {\\n        for(int i = 0 ; i <= pre.size() - x ; i++) {\\n            if(i > 0 ) {\\n                if(i + x < pre.size()) {\\n                    if(pre[i - 1] >= 0 && suff[i + x] >= 0 && pre[i - 1] < suff[i + x])\\n                        return true;\\n                }else {\\n                    if(pre[i - 1] >= 0)\\n                        return true;\\n                }\\n            }else if(i + x < suff.size() && suff[i + x] >= 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int minimumScore(string s, string t) {\\n        int n = s.length();\\n        map<int,int>mp;\\n        vector<vector<int>>v(26);\\n        for(int i = 0 ; i < n ; i++)\\n            v[s[i] - \\'a\\'].push_back(i);\\n        int l = t.length(), r = -1, prev = -1;\\n        vector<int>pre(l), suff(l);\\n        for(int i = 0 ; i < t.length() ; i++) {\\n            int x = util(v[t[i] - \\'a\\'],prev);\\n            if(x == -1) {\\n                pre[i] = -1;\\n                break;\\n            } else{\\n                pre[i] = x;\\n                prev = x;\\n            }\\n        }\\n        prev = n;\\n        for(int i = t.length() - 1 ; i >= 0 ; i--) {\\n            int x = util2(v[t[i] - \\'a\\'],prev);\\n            if(x == -1) {\\n                suff[i] = -1;\\n                break;\\n            } else {\\n                suff[i] = x;\\n                prev = x;\\n            }\\n        }\\n        for(int i = suff.size() - 2 ; i >= 0 ; i--) {\\n            if(suff[i + 1] == -1)\\n                suff[i] = -1;\\n        }\\n        for(int i = 1 ; i < pre.size() ; i++) {\\n            if(pre[i - 1] == -1)\\n                pre[i] = -1;\\n        }\\n        l = 0, r = t.length();\\n        int id = r;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(check(mid,pre,suff)) {\\n                id = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739704,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int suffix[s.size()+1];\\n        suffix[s.size()]=t.size();\\n        for(int i = s.size()-1, j = t.size()-1;i>=0;i--){\\n            if(j>=0&&s[i]==t[j]){\\n                j--;\\n            }\\n            suffix[i]=j+1;\\n        }\\n        if(suffix[0]==0)\\n            return 0;\\n        int ans = suffix[0];\\n        for(int i=0, j=0;i<s.size();i++){\\n            if(s[i]==t[j]){\\n                j++;\\n            }\\n            ans = min(ans, suffix[i+1]-j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int suffix[s.size()+1];\\n        suffix[s.size()]=t.size();\\n        for(int i = s.size()-1, j = t.size()-1;i>=0;i--){\\n            if(j>=0&&s[i]==t[j]){\\n                j--;\\n            }\\n            suffix[i]=j+1;\\n        }\\n        if(suffix[0]==0)\\n            return 0;\\n        int ans = suffix[0];\\n        for(int i=0, j=0;i<s.size();i++){\\n            if(s[i]==t[j]){\\n                j++;\\n            }\\n            ans = min(ans, suffix[i+1]-j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694172,
                "title": "clean-o-nlogn-to-o-n",
                "content": "O(NlogN)\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int sl=s.size();\\n        int tl=t.size();\\n        vector<int> left(tl,sl), right(tl,-1);\\n        //s to unordered_map<c,<idx>>\\n        unordered_map<char,vector<int>> m;\\n        for(int x=0;x<sl;x++){\\n            m[s[x]].push_back(x);\\n        }\\n        int bl=tl,br=tl;\\n        //fill left\\n        //O(NlogN)\\n        int temp=-1;\\n        for(int x=0;x<tl;x++){\\n            vector<int> &v=m[t[x]];\\n            int idx=upper_bound(v.begin(),v.end(),temp)-v.begin();\\n            if(idx==v.size()){\\n                bl=x;\\n                break;}\\n            temp=v[idx];\\n            left[x]=temp;\\n        }\\n        //fill right\\n        //O(NlogN)\\n        temp=sl;\\n        for(int x=tl-1;x>=0;x--){\\n            vector<int> &v=m[t[x]];\\n            int idx=-1*(upper_bound(v.rbegin(),v.rend(),temp,greater<int>())\\n                -v.rend())-1;\\n            if(idx==-1){\\n                br=(tl-1)-x;\\n                break;}\\n            temp=v[idx];\\n            right[x]=temp;\\n        }\\n        //get result\\n        //O(NlogN)\\n        int res=tl-max(bl,br);\\n        if(res==0)\\n            return 0;\\n        for(int x=0;x<tl;x++){\\n            int a=left[x];\\n            if(a==sl)\\n                break;\\n            int idx=upper_bound(right.begin(),right.end(),a)-right.begin();\\n            if(idx==tl)\\n                break;\\n            res=min(idx-x-1,res);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nO(N)\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int sl=s.size();\\n        int tl=t.size();\\n        vector<int> left(tl,sl), right(tl,-1);\\n        \\n        int bl=0,br=0;\\n        //fill left\\n        //O(N)\\n        int temp=0;\\n        for(int x=0;x<sl;x++){\\n            if(s[x]==t[temp]){\\n                left[temp]=x;\\n                temp++;\\n                bl++;\\n            }\\n            if(temp==tl)\\n                break;\\n        }\\n        //fill right\\n        //O(N)\\n        temp=tl-1;\\n        for(int x=sl-1;x>=0;x--){\\n            if(s[x]==t[temp]){\\n                right[temp]=x;\\n                temp--;\\n                br++;\\n            }\\n            if(temp<0)\\n                break;\\n        }\\n        //get result\\n        //O(N)\\n        int res=tl-max(bl,br);\\n        if(res==0)\\n            return 0;\\n        temp=0;\\n        for(int x=0;x<tl;x++){\\n            if(left[x]==sl)\\n                break;\\n            while(right[temp]<=left[x]){\\n                temp++;\\n                if(temp==tl)\\n                    return res;\\n            }\\n            res=min(temp-x-1,res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int sl=s.size();\\n        int tl=t.size();\\n        vector<int> left(tl,sl), right(tl,-1);\\n        //s to unordered_map<c,<idx>>\\n        unordered_map<char,vector<int>> m;\\n        for(int x=0;x<sl;x++){\\n            m[s[x]].push_back(x);\\n        }\\n        int bl=tl,br=tl;\\n        //fill left\\n        //O(NlogN)\\n        int temp=-1;\\n        for(int x=0;x<tl;x++){\\n            vector<int> &v=m[t[x]];\\n            int idx=upper_bound(v.begin(),v.end(),temp)-v.begin();\\n            if(idx==v.size()){\\n                bl=x;\\n                break;}\\n            temp=v[idx];\\n            left[x]=temp;\\n        }\\n        //fill right\\n        //O(NlogN)\\n        temp=sl;\\n        for(int x=tl-1;x>=0;x--){\\n            vector<int> &v=m[t[x]];\\n            int idx=-1*(upper_bound(v.rbegin(),v.rend(),temp,greater<int>())\\n                -v.rend())-1;\\n            if(idx==-1){\\n                br=(tl-1)-x;\\n                break;}\\n            temp=v[idx];\\n            right[x]=temp;\\n        }\\n        //get result\\n        //O(NlogN)\\n        int res=tl-max(bl,br);\\n        if(res==0)\\n            return 0;\\n        for(int x=0;x<tl;x++){\\n            int a=left[x];\\n            if(a==sl)\\n                break;\\n            int idx=upper_bound(right.begin(),right.end(),a)-right.begin();\\n            if(idx==tl)\\n                break;\\n            res=min(idx-x-1,res);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int sl=s.size();\\n        int tl=t.size();\\n        vector<int> left(tl,sl), right(tl,-1);\\n        \\n        int bl=0,br=0;\\n        //fill left\\n        //O(N)\\n        int temp=0;\\n        for(int x=0;x<sl;x++){\\n            if(s[x]==t[temp]){\\n                left[temp]=x;\\n                temp++;\\n                bl++;\\n            }\\n            if(temp==tl)\\n                break;\\n        }\\n        //fill right\\n        //O(N)\\n        temp=tl-1;\\n        for(int x=sl-1;x>=0;x--){\\n            if(s[x]==t[temp]){\\n                right[temp]=x;\\n                temp--;\\n                br++;\\n            }\\n            if(temp<0)\\n                break;\\n        }\\n        //get result\\n        //O(N)\\n        int res=tl-max(bl,br);\\n        if(res==0)\\n            return 0;\\n        temp=0;\\n        for(int x=0;x<tl;x++){\\n            if(left[x]==sl)\\n                break;\\n            while(right[temp]<=left[x]){\\n                temp++;\\n                if(temp==tl)\\n                    return res;\\n            }\\n            res=min(temp-x-1,res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576169,
                "title": "left-and-right-o-n-python-version",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLeft pass once for each index i in t, find the smallest index j in s such that t[: i+1] is a subsequence of s[: j+1]. Store the answer in an array (leftArr).\\nIf such j does not exist for some i, then by default leftArr[i] = -1.\\n\\nSimilarly, right pass once for each i in t, find the largest index j in s such that t[i: ] is a subsequence of s[j: ]. Store the answer in an array (rightArr).\\nIf such j does not exist for some i, then by default rightArr[i] = -1.\\n\\nFinally, pass t from right to left, for each index $right$ satisfying $rightArr[right]!=-1$, look for the largest index $left$ of t, such that $leftArr[left]!=-1$ and $leftArr[left] < rightArr[right]$.\\nAbove can guarantee that t[ :left] + t[right: ] is a subsequence of s. \\nWe simply need to find the $(left, right)$ pair which minimizes (right-1-left).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        m = len(s)\\n        n = len(t)\\n        rightArr = [-1 for _ in range(n)]\\n        leftArr = [-1 for _ in range(n)]\\n\\n        j = 0 \\n        for i in range(n):\\n            if j >= m:\\n                break\\n            while j < m and s[j] != t[i]:\\n                j+=1\\n            if j < m:\\n                leftArr[i] = j\\n                j += 1\\n        \\n        j = m-1\\n        for i in reversed(range(n)):\\n            if j < 0:\\n                break\\n            while j >= 0 and s[j] != t[i]:\\n                j -= 1\\n            if j >= 0:\\n                rightArr[i] = j\\n                j -= 1\\n\\n        right = n\\n        left = -1\\n        for i in range(n):\\n            if leftArr[i] == -1:\\n                break\\n            left = i\\n        res = right-1-left\\n        right = n-1\\n        while right >= 0 and (rightArr[right]!= -1):\\n            boundary = rightArr[right]\\n            left = min(left, right-1)\\n            while left>=0 and leftArr[left] >= boundary:\\n                left -= 1\\n            res = min(res, right-1-left)\\n            right -= 1\\n        return res\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        m = len(s)\\n        n = len(t)\\n        rightArr = [-1 for _ in range(n)]\\n        leftArr = [-1 for _ in range(n)]\\n\\n        j = 0 \\n        for i in range(n):\\n            if j >= m:\\n                break\\n            while j < m and s[j] != t[i]:\\n                j+=1\\n            if j < m:\\n                leftArr[i] = j\\n                j += 1\\n        \\n        j = m-1\\n        for i in reversed(range(n)):\\n            if j < 0:\\n                break\\n            while j >= 0 and s[j] != t[i]:\\n                j -= 1\\n            if j >= 0:\\n                rightArr[i] = j\\n                j -= 1\\n\\n        right = n\\n        left = -1\\n        for i in range(n):\\n            if leftArr[i] == -1:\\n                break\\n            left = i\\n        res = right-1-left\\n        right = n-1\\n        while right >= 0 and (rightArr[right]!= -1):\\n            boundary = rightArr[right]\\n            left = min(left, right-1)\\n            while left>=0 and leftArr[left] >= boundary:\\n                left -= 1\\n            res = min(res, right-1-left)\\n            right -= 1\\n        return res\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458751,
                "title": "forward-and-backward-passes-in-python-faster-than-85",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis solution tries to find the best pivot for merging a prefix and a suffix so that the score is minimized. To do so, the forward scores are precomputed for prefixes, and the backward scores are also computed for suffixes. Finally, the answer is `min(forward[i]+backward[i+1]) for all i`. \\n\\nYou can also precompute one of forward or backward scores only, and compute the scores of the other direction in place. However, I find it is faster to precompute both directions of scores and find the answer with `min()`. \\n\\n# Complexity\\n- Time complexity: $$O(N)$$, where $$N$$ is the length of `s`. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: At least one of the forward and the backward scores should be precomputed and stored. The space complexity is $$O(N)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        j = 0\\n        forward = [0]\\n        for c in s:\\n            if t[j] == c:\\n                j += 1\\n            if j >= len(t):\\n                return 0\\n            forward.append(j)\\n            \\n        j = len(t) - 1\\n        backward = [j]\\n        for c in reversed(s):\\n            if t[j] == c:\\n                j -= 1\\n            backward.append(j)\\n        return min(b - a for a, b in zip(forward, reversed(backward))) + 1              \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        j = 0\\n        forward = [0]\\n        for c in s:\\n            if t[j] == c:\\n                j += 1\\n            if j >= len(t):\\n                return 0\\n            forward.append(j)\\n            \\n        j = len(t) - 1\\n        backward = [j]\\n        for c in reversed(s):\\n            if t[j] == c:\\n                j -= 1\\n            backward.append(j)\\n        return min(b - a for a, b in zip(forward, reversed(backward))) + 1              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441563,
                "title": "python-simple-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumScore(self, s, t):\\n        def scan(s,t):\\n            ans, i = [0], 0\\n\\n            for c in s:\\n                if i < len(t) and t[i] == c:\\n                    i += 1\\n                ans.append(i)\\n\\n            return ans\\n\\n        r1 = scan(s,t)\\n        r2 = reversed(scan(s[::-1],t[::-1]))\\n        max_val = max([i+j for i,j in zip(r1,r2)])\\n\\n        return max(0,len(t)-max_val)\\n\\n        \\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, s, t):\\n        def scan(s,t):\\n            ans, i = [0], 0\\n\\n            for c in s:\\n                if i < len(t) and t[i] == c:\\n                    i += 1\\n                ans.append(i)\\n\\n            return ans\\n\\n        r1 = scan(s,t)\\n        r2 = reversed(scan(s[::-1],t[::-1]))\\n        max_val = max([i+j for i,j in zip(r1,r2)])\\n\\n        return max(0,len(t)-max_val)\\n\\n        \\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329549,
                "title": "c-prefix-suffix-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n        vector<int> f(n,0),b(n,0);\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(j<m && s[i] == t[j]){\\n                j++;\\n            }\\n            f[i]=j;\\n        }\\n        j=m-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(j>=0 && s[i] == t[j]){\\n                j--;\\n            }\\n            b[i]=m-j-1;\\n        }\\n        int ans = min(m-f[n-1],m-b[0]);\\n        for(int i=1;i<n;i++){\\n            ans = min(ans,m-f[i-1]-b[i]);\\n        }\\n        return max(ans,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n        vector<int> f(n,0),b(n,0);\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(j<m && s[i] == t[j]){\\n                j++;\\n            }\\n            f[i]=j;\\n        }\\n        j=m-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(j>=0 && s[i] == t[j]){\\n                j--;\\n            }\\n            b[i]=m-j-1;\\n        }\\n        int ans = min(m-f[n-1],m-b[0]);\\n        for(int i=1;i<n;i++){\\n            ans = min(ans,m-f[i-1]-b[i]);\\n        }\\n        return max(ans,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263227,
                "title": "c-solution",
                "content": "# Intuition\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        vector<int> left(t.size(), 0);\\n        vector<int> right(t.size(), 0);\\n\\n        int res = t.size();\\n        int j = 0;\\n        int n = t.size();\\n        for(int i=0;i<s.size() && j<left.size();i++) {\\n            if(t[j] == s[i]) {\\n                left[j] = i;\\n                res = min(res, n-1 - (j+1) + 1);\\n                j++;\\n            }\\n        }\\n\\n        while(j < t.size()) {\\n            left[j] = INT_MAX;\\n            j++;\\n        }\\n\\n        j = t.size() - 1;\\n        for(int i=s.size()-1;i>=0 && j>=0;i--) {\\n           if(s[i] == t[j]) {\\n               right[j] = i;\\n               res = min(res, j-1+1);\\n               j--;\\n            }\\n        }\\n\\n        while(j>=0) {\\n            right[j] = -1;\\n            j--;\\n        }\\n\\n\\n        if(right[0]!=-1 || left[left.size()-1] != INT_MAX) {\\n            return 0;\\n        }\\n        \\n        j = 1;\\n        for(int i =0;i<t.size();i++) {\\n            if(left[i] == INT_MAX) {\\n                break;\\n            }\\n            int left_index = left[i];\\n            j = max(j, i+1);\\n            while(j<right.size() && left_index>=right[j]) {\\n                j++;\\n            }\\n\\n            res = min(res, j-1 - (i+1) + 1);\\n            \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        vector<int> left(t.size(), 0);\\n        vector<int> right(t.size(), 0);\\n\\n        int res = t.size();\\n        int j = 0;\\n        int n = t.size();\\n        for(int i=0;i<s.size() && j<left.size();i++) {\\n            if(t[j] == s[i]) {\\n                left[j] = i;\\n                res = min(res, n-1 - (j+1) + 1);\\n                j++;\\n            }\\n        }\\n\\n        while(j < t.size()) {\\n            left[j] = INT_MAX;\\n            j++;\\n        }\\n\\n        j = t.size() - 1;\\n        for(int i=s.size()-1;i>=0 && j>=0;i--) {\\n           if(s[i] == t[j]) {\\n               right[j] = i;\\n               res = min(res, j-1+1);\\n               j--;\\n            }\\n        }\\n\\n        while(j>=0) {\\n            right[j] = -1;\\n            j--;\\n        }\\n\\n\\n        if(right[0]!=-1 || left[left.size()-1] != INT_MAX) {\\n            return 0;\\n        }\\n        \\n        j = 1;\\n        for(int i =0;i<t.size();i++) {\\n            if(left[i] == INT_MAX) {\\n                break;\\n            }\\n            int left_index = left[i];\\n            j = max(j, i+1);\\n            while(j<right.size() && left_index>=right[j]) {\\n                j++;\\n            }\\n\\n            res = min(res, j-1 - (i+1) + 1);\\n            \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253982,
                "title": "great-explanation-with-intution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        // check if t can become a subsequence of s after some removal\\n        // only right and left is required so no need to consider remaining ones \\n        // in between\\n        // check for subsequence - if prefix does not overlap suffix\\n        int n=s.length(), m=t.length();\\n        vector<int> pref(m, n), suff(m, -1);\\n        int p1=0, p2=0;\\n        while(p2<m) // filling the prefix array\\n        {\\n            if(p1==n)\\n            break;\\n            if(s[p1] == t[p2])\\n            {\\n                pref[p2]=p1;\\n                p2++;\\n            }\\n            p1++;\\n        }\\n        p1=n-1, p2=m-1;\\n        while(p2>=0) // filling the suffix array\\n        {\\n            if(p1==-1)\\n            break;\\n            if(s[p1] == t[p2])\\n            {\\n                suff[p2]=p1;\\n                p2--;\\n            }\\n            p1--;\\n        }\\n        // binary search to find the left and right pointer that has to\\n        // be removed\\n        int ans=m; // since maximum answer is the length of t\\n        for(int l=0;l<m;l++) // fixing the left pointer\\n        {\\n            if(l>0 and pref[l-1]==n) // no need to check if we find a character we cannot form a subsequence with\\n            break;\\n            int ele=l==0?-1:pref[l-1]; // take the first valid suffix if left pointer is at index 0\\n            int r=upper_bound(suff.begin(), suff.end(), ele)-suff.begin(); // find the first element with value greater than that of pref[l-1]\\n            if(l==r) // it means whole string is subsequence of s\\n            return 0;\\n            ans=min(ans, r-l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        // check if t can become a subsequence of s after some removal\\n        // only right and left is required so no need to consider remaining ones \\n        // in between\\n        // check for subsequence - if prefix does not overlap suffix\\n        int n=s.length(), m=t.length();\\n        vector<int> pref(m, n), suff(m, -1);\\n        int p1=0, p2=0;\\n        while(p2<m) // filling the prefix array\\n        {\\n            if(p1==n)\\n            break;\\n            if(s[p1] == t[p2])\\n            {\\n                pref[p2]=p1;\\n                p2++;\\n            }\\n            p1++;\\n        }\\n        p1=n-1, p2=m-1;\\n        while(p2>=0) // filling the suffix array\\n        {\\n            if(p1==-1)\\n            break;\\n            if(s[p1] == t[p2])\\n            {\\n                suff[p2]=p1;\\n                p2--;\\n            }\\n            p1--;\\n        }\\n        // binary search to find the left and right pointer that has to\\n        // be removed\\n        int ans=m; // since maximum answer is the length of t\\n        for(int l=0;l<m;l++) // fixing the left pointer\\n        {\\n            if(l>0 and pref[l-1]==n) // no need to check if we find a character we cannot form a subsequence with\\n            break;\\n            int ele=l==0?-1:pref[l-1]; // take the first valid suffix if left pointer is at index 0\\n            int r=upper_bound(suff.begin(), suff.end(), ele)-suff.begin(); // find the first element with value greater than that of pref[l-1]\\n            if(l==r) // it means whole string is subsequence of s\\n            return 0;\\n            ans=min(ans, r-l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247270,
                "title": "what-other-solutions-are-missing",
                "content": "# Intuition\\nScore depends upon the left most index and right most index deleted.. so it doesn\\'t make any difference if you drop all the characters b/w left most index and right most index that you are going to delete(score stays the same).. why not delete them for simplicity..\\nNow the problem just reduces to the prefix and suffix..\\n\\n\\n\\n# Approach\\nyou can check others solution now, I just wrote what\\'s missing from them.\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\nScore depends upon the left most index and right most index deleted.. so it doesn\\'t make any difference if you drop all the characters b/w left most index and right most index that you are going to delete(score stays the same).. why not delete them for simplicity..\\nNow the problem just reduces to the prefix and suffix..\\n\\n\\n\\n# Approach\\nyou can check others solution now, I just wrote what\\'s missing from them.\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3238758,
                "title": "python-solution-using-binary-search",
                "content": "# Code\\n```\\nfrom bisect import bisect_right,bisect_left\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        d=[[] for _ in range(26)]\\n        for i in range(len(s)):\\n            d[ord(s[i])-97].append(i)\\n        j=len(s)\\n        dp=[-1 for _ in range(len(t))]\\n        for i in range(len(t)-1,-1,-1):\\n            arr=d[ord(t[i])-97]\\n            tem=bisect_left(arr,j)\\n            if(tem==0):\\n                break\\n            else:\\n                dp[i]=arr[tem-1]\\n                j=dp[i]\\n        else:\\n            return 0\\n        j=i\\n        i=0\\n        r=-1\\n        ans=len(t)\\n        while(i<len(t)):\\n            arr=d[ord(t[i])-97]\\n            tem=bisect_right(arr,r)\\n            if(tem>=len(arr)):\\n                ans=min(ans,j-i+1)\\n                break\\n            tem=arr[tem]\\n            if(j+1>=len(t) or dp[j+1]>tem):\\n                r=tem\\n                i+=1\\n            else:\\n                ans=min(ans,j-i+1)\\n                while(j<len(t)-1 and ( dp[j+1]<=tem)):\\n                    j+=1\\n                r=tem\\n                i+=1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_right,bisect_left\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        d=[[] for _ in range(26)]\\n        for i in range(len(s)):\\n            d[ord(s[i])-97].append(i)\\n        j=len(s)\\n        dp=[-1 for _ in range(len(t))]\\n        for i in range(len(t)-1,-1,-1):\\n            arr=d[ord(t[i])-97]\\n            tem=bisect_left(arr,j)\\n            if(tem==0):\\n                break\\n            else:\\n                dp[i]=arr[tem-1]\\n                j=dp[i]\\n        else:\\n            return 0\\n        j=i\\n        i=0\\n        r=-1\\n        ans=len(t)\\n        while(i<len(t)):\\n            arr=d[ord(t[i])-97]\\n            tem=bisect_right(arr,r)\\n            if(tem>=len(arr)):\\n                ans=min(ans,j-i+1)\\n                break\\n            tem=arr[tem]\\n            if(j+1>=len(t) or dp[j+1]>tem):\\n                r=tem\\n                i+=1\\n            else:\\n                ans=min(ans,j-i+1)\\n                while(j<len(t)-1 and ( dp[j+1]<=tem)):\\n                    j+=1\\n                r=tem\\n                i+=1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228339,
                "title": "2-pointer-left-right",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nlongest increasing prefix+suffix\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom copy import deepcopy\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        left=[-1]*len(t)\\n        right=[-1]*len(t)\\n        ind=defaultdict(deque)\\n        ind2=defaultdict(deque)\\n        for i in range(len(s)):\\n            ind[s[i]].append(i)\\n            ind2[s[i]].append(i)\\n        for i in range(len(t)):\\n            if ind[t[i]]:\\n                while i and  ind[t[i]] and ind[t[i]][0]<left[i-1]:\\n                    ind[t[i]].popleft()\\n                if ind[t[i]]:\\n                    left[i]=ind[t[i]].popleft()\\n        ind=ind2\\n        ans=len(t)\\n        cnt=0\\n        for i in range(len(t)-1,-1,-1):\\n            cnt+=1\\n            if ind2[t[i]]:\\n                while i+1<len(t) and ind[t[i]] and ind[t[i]][-1]>right[i+1]:\\n                    ind[t[i]].pop()\\n                if ind[t[i]]:\\n                    right[i]=ind[t[i]].pop()\\n                    ans=min(ans,len(t)-cnt)\\n            if i+1<len(t) and right[i+1]<right[i]:\\n                right[i]=-1\\n                break\\n        hi=len(left)-1\\n        for i in range(len(left)):\\n            if left[i]==-1:\\n                break\\n            l=i\\n            while  right[hi]<left[l]:\\n                if hi+1<len(left):\\n                    hi+=1\\n                else:\\n                    break\\n            while hi>l and right[hi]!=-1 and right[hi]>left[l]:\\n                th=hi-1\\n                hi=th\\n            ans=min(ans,hi-l)\\n                \\n        return max(ans,0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom copy import deepcopy\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        left=[-1]*len(t)\\n        right=[-1]*len(t)\\n        ind=defaultdict(deque)\\n        ind2=defaultdict(deque)\\n        for i in range(len(s)):\\n            ind[s[i]].append(i)\\n            ind2[s[i]].append(i)\\n        for i in range(len(t)):\\n            if ind[t[i]]:\\n                while i and  ind[t[i]] and ind[t[i]][0]<left[i-1]:\\n                    ind[t[i]].popleft()\\n                if ind[t[i]]:\\n                    left[i]=ind[t[i]].popleft()\\n        ind=ind2\\n        ans=len(t)\\n        cnt=0\\n        for i in range(len(t)-1,-1,-1):\\n            cnt+=1\\n            if ind2[t[i]]:\\n                while i+1<len(t) and ind[t[i]] and ind[t[i]][-1]>right[i+1]:\\n                    ind[t[i]].pop()\\n                if ind[t[i]]:\\n                    right[i]=ind[t[i]].pop()\\n                    ans=min(ans,len(t)-cnt)\\n            if i+1<len(t) and right[i+1]<right[i]:\\n                right[i]=-1\\n                break\\n        hi=len(left)-1\\n        for i in range(len(left)):\\n            if left[i]==-1:\\n                break\\n            l=i\\n            while  right[hi]<left[l]:\\n                if hi+1<len(left):\\n                    hi+=1\\n                else:\\n                    break\\n            while hi>l and right[hi]!=-1 and right[hi]>left[l]:\\n                th=hi-1\\n                hi=th\\n            ans=min(ans,hi-l)\\n                \\n        return max(ans,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216782,
                "title": "java-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        int n=s.length(); int m=t.length();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int sIdx=n-1;\\n        for(int i=m-1; i>=0; i--){\\n            while(sIdx>=0 && s.charAt(sIdx)!=t.charAt(i)) sIdx--;\\n            if(sIdx==-1) break;\\n            list.add(sIdx);\\n            sIdx--;\\n        }\\n        Collections.reverse(list);\\n        int ans = m-list.size();\\n        if(ans==0) return 0;\\n        \\n        sIdx=0;\\n        for(int i=0; i<m; i++){\\n            while(sIdx<n && s.charAt(sIdx)!=t.charAt(i)) sIdx++;            \\n            int idx = upperBound(list,sIdx);            \\n            if(idx==list.size()){\\n                if(sIdx==n) break;\\n                ans=Math.min(ans,m-i-1);\\n                sIdx++;\\n                continue;\\n            }\\n            int lastIncluded = list.size()-idx;\\n            ans = Math.min(ans,m-lastIncluded-i-1);\\n            sIdx++;\\n        }\\n        return ans;        \\n    }\\n\\n    int upperBound(ArrayList<Integer> list, int val){\\n        int low=0; int high=list.size()-1;\\n        int ans=list.size();\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(list.get(mid)>val){\\n                ans=mid;\\n                high=mid-1;\\n            }else low=mid+1;     \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n// \"abecdebe\"\\n// \"eaebceae\"\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        int n=s.length(); int m=t.length();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int sIdx=n-1;\\n        for(int i=m-1; i>=0; i--){\\n            while(sIdx>=0 && s.charAt(sIdx)!=t.charAt(i)) sIdx--;\\n            if(sIdx==-1) break;\\n            list.add(sIdx);\\n            sIdx--;\\n        }\\n        Collections.reverse(list);\\n        int ans = m-list.size();\\n        if(ans==0) return 0;\\n        \\n        sIdx=0;\\n        for(int i=0; i<m; i++){\\n            while(sIdx<n && s.charAt(sIdx)!=t.charAt(i)) sIdx++;            \\n            int idx = upperBound(list,sIdx);            \\n            if(idx==list.size()){\\n                if(sIdx==n) break;\\n                ans=Math.min(ans,m-i-1);\\n                sIdx++;\\n                continue;\\n            }\\n            int lastIncluded = list.size()-idx;\\n            ans = Math.min(ans,m-lastIncluded-i-1);\\n            sIdx++;\\n        }\\n        return ans;        \\n    }\\n\\n    int upperBound(ArrayList<Integer> list, int val){\\n        int low=0; int high=list.size()-1;\\n        int ans=list.size();\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(list.get(mid)>val){\\n                ans=mid;\\n                high=mid-1;\\n            }else low=mid+1;     \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n// \"abecdebe\"\\n// \"eaebceae\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200338,
                "title": "c-commented-code-find-longest-suffix-secured-for-each-prefix",
                "content": "# Complexity\\n- Time complexity: $$O(N log N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n=s.length(), m=t.length();\\n\\n        vector<int> l(m,-1),r(m,-1);\\n\\n        int j=0;\\n        //longes prefix available\\n        for(int i=0;i<n;i++){\\n            if(j>=m){\\n                break;\\n            }\\n            if(s[i]==t[j]){\\n                l[j]=i;\\n                j++;\\n            }\\n        }\\n\\n        j=m-1;\\n        //longest suffix available\\n        for(int i=n-1;i>=0;i--){\\n            if(j<0){\\n                break;\\n            }\\n            if(s[i]==t[j]){\\n                r[j]=i;\\n                j--;\\n            }\\n        }\\n\\n        int ans=m;\\n        //ans if suffix and prefix has to removed \\n         for (int i = 0; i < m; ++i) { \\n            if (l[i] != -1) ans = min(ans, m-i-1); \\n            if (r[i] != -1) ans = min(ans, i); \\n        }\\n\\n        //does\\'nt found any suffix return ans with respect to logest prefix found\\n        if (r[m-1] == -1) return ans; \\n\\n        for(int i=0;i<m-1;i++){\\n\\n            //calculate longest suffix we can able to secure with respect to current index i prefix \\n            if(l[i]!=-1){\\n                if(l[i]>=r[m-1]){\\n                    break;\\n                }\\n                int lo=i+1,hi=m-1;\\n                int temp;\\n                while(lo<=hi){\\n                    int mi=lo+(hi-lo)/2;\\n                    if(l[i]>=r[mi]){\\n                        lo=mi+1;\\n                    }\\n                    else{\\n                        temp=mi;\\n                        hi=mi-1;\\n                    }\\n                }\\n                ans=min(ans,temp-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n=s.length(), m=t.length();\\n\\n        vector<int> l(m,-1),r(m,-1);\\n\\n        int j=0;\\n        //longes prefix available\\n        for(int i=0;i<n;i++){\\n            if(j>=m){\\n                break;\\n            }\\n            if(s[i]==t[j]){\\n                l[j]=i;\\n                j++;\\n            }\\n        }\\n\\n        j=m-1;\\n        //longest suffix available\\n        for(int i=n-1;i>=0;i--){\\n            if(j<0){\\n                break;\\n            }\\n            if(s[i]==t[j]){\\n                r[j]=i;\\n                j--;\\n            }\\n        }\\n\\n        int ans=m;\\n        //ans if suffix and prefix has to removed \\n         for (int i = 0; i < m; ++i) { \\n            if (l[i] != -1) ans = min(ans, m-i-1); \\n            if (r[i] != -1) ans = min(ans, i); \\n        }\\n\\n        //does\\'nt found any suffix return ans with respect to logest prefix found\\n        if (r[m-1] == -1) return ans; \\n\\n        for(int i=0;i<m-1;i++){\\n\\n            //calculate longest suffix we can able to secure with respect to current index i prefix \\n            if(l[i]!=-1){\\n                if(l[i]>=r[m-1]){\\n                    break;\\n                }\\n                int lo=i+1,hi=m-1;\\n                int temp;\\n                while(lo<=hi){\\n                    int mi=lo+(hi-lo)/2;\\n                    if(l[i]>=r[mi]){\\n                        lo=mi+1;\\n                    }\\n                    else{\\n                        temp=mi;\\n                        hi=mi-1;\\n                    }\\n                }\\n                ans=min(ans,temp-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195169,
                "title": "java-o-n-o-n-2-passes",
                "content": "# Intuition\\nI added some notes and improved readability on top of one answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // First we want to convert the question to max length of prefix t matchable of prefix s[0..i] plus max length of suffix t matachable of suffix s[i+1..]\\n    // because the total length of t minus the max length above is the minimal score.\\n    // So we need 2 passes, first pass we can get the max length of prefix t, second pass we can get \\n    // the max length of suffix t.\\n    public int minimumScore(String s, String t) {\\n        // preMatchCount calculates at index i, how many characters in string t[0..j]\\n        // occurs in prefix of s[0..i]\\n        int[] preMatchCount = new int[s.length()];\\n        for (int i = 0, j = 0; i < s.length() && j <t.length(); i++) {\\n            if (i > 0) {\\n                // if s[i] has no match, then preMatchCount[i] is preMatchCount[i - 1]\\n                // by definition\\n                preMatchCount[i] = preMatchCount[i - 1];\\n            }\\n            // if there\\'s match then we need to move index j forward\\n            if (s.charAt(i) == t.charAt(j)) {\\n                j++;\\n                preMatchCount[i]++;\\n            }\\n        }\\n        // sufMatchCount calculates at index i, how many characters in string t[j..]\\n        // occurs in suffix of s[i..]\\n        int sufMatchCount = 0;\\n        // midMatchCount calculates at index i, how many characters in string t[0..j]\\n        // occurs in prefix of s[0..i] plus how many characters in t[j+1 ..] occurs in \\n        // suffix s[i+1..]\\n        // t.length - midMatchCount is the final result.\\n        int midMatchCount = 0;\\n        for (int i = s.length() - 1, j = t.length() - 1; i >= 0 && j >= 0; i--) {\\n            midMatchCount = Math.max(midMatchCount, sufMatchCount + preMatchCount[i]);\\n            // if there\\'s match then we need to move index j backward\\n            if (s.charAt(i) == t.charAt(j)) {\\n                j--;\\n                sufMatchCount++;\\n            }\\n\\n        }\\n        // why do we want to do a max again? because midMatchCount may not be updated (the whole suffix is a match)\\n        \\n        return Math.max(0, t.length() - Math.max(midMatchCount, sufMatchCount));\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // First we want to convert the question to max length of prefix t matchable of prefix s[0..i] plus max length of suffix t matachable of suffix s[i+1..]\\n    // because the total length of t minus the max length above is the minimal score.\\n    // So we need 2 passes, first pass we can get the max length of prefix t, second pass we can get \\n    // the max length of suffix t.\\n    public int minimumScore(String s, String t) {\\n        // preMatchCount calculates at index i, how many characters in string t[0..j]\\n        // occurs in prefix of s[0..i]\\n        int[] preMatchCount = new int[s.length()];\\n        for (int i = 0, j = 0; i < s.length() && j <t.length(); i++) {\\n            if (i > 0) {\\n                // if s[i] has no match, then preMatchCount[i] is preMatchCount[i - 1]\\n                // by definition\\n                preMatchCount[i] = preMatchCount[i - 1];\\n            }\\n            // if there\\'s match then we need to move index j forward\\n            if (s.charAt(i) == t.charAt(j)) {\\n                j++;\\n                preMatchCount[i]++;\\n            }\\n        }\\n        // sufMatchCount calculates at index i, how many characters in string t[j..]\\n        // occurs in suffix of s[i..]\\n        int sufMatchCount = 0;\\n        // midMatchCount calculates at index i, how many characters in string t[0..j]\\n        // occurs in prefix of s[0..i] plus how many characters in t[j+1 ..] occurs in \\n        // suffix s[i+1..]\\n        // t.length - midMatchCount is the final result.\\n        int midMatchCount = 0;\\n        for (int i = s.length() - 1, j = t.length() - 1; i >= 0 && j >= 0; i--) {\\n            midMatchCount = Math.max(midMatchCount, sufMatchCount + preMatchCount[i]);\\n            // if there\\'s match then we need to move index j backward\\n            if (s.charAt(i) == t.charAt(j)) {\\n                j--;\\n                sufMatchCount++;\\n            }\\n\\n        }\\n        // why do we want to do a max again? because midMatchCount may not be updated (the whole suffix is a match)\\n        \\n        return Math.max(0, t.length() - Math.max(midMatchCount, sufMatchCount));\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195115,
                "title": "two-pass-string-s-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor every letter in s, we can either use it to match prefix or suffix in t.\\n\\n(No need to worry about overlap of prefix and suffix in t, as long as every letter in s match either prefix or suffix, that won\\'t cause problem)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.go left to right in s , try match as many prefix of t as we can, for every character in s, \\nwe mark if it is used to match t prefix. \\n\\nWhat left in t is need to be remove.\\n\\n2.then go right to left in s, if a letter is used for prefix , now we no longer can use it for prefix becasue we are building suffix now, so we delete one character in prefix which means we need to increase the letter we remove(cur++). \\nif it match t suffix, we add one more letter to suffix and we decrase the letter we remove.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        boolean[] record = new boolean[s.length()];\\n        int ti = 0;\\n        for (int i = 0; i < s.length() && ti < t.length(); i++) {\\n            if (s.charAt(i) == t.charAt(ti)) {\\n                record[i] = true;\\n                ti++;\\n            }\\n        }\\n        int ans = t.length() - ti;\\n        if (ti == t.length()) return ans;\\n        int cur = ans;\\n        ti = t.length() - 1;\\n        for (int i = s.length() - 1; i >= 0 && ti >= 0; i--) {\\n            if (record[i]) cur++;\\n            if (s.charAt(i) == t.charAt(ti)) {\\n                cur--;\\n                ti--;\\n            }\\n            ans = Math.min(ans, cur);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        boolean[] record = new boolean[s.length()];\\n        int ti = 0;\\n        for (int i = 0; i < s.length() && ti < t.length(); i++) {\\n            if (s.charAt(i) == t.charAt(ti)) {\\n                record[i] = true;\\n                ti++;\\n            }\\n        }\\n        int ans = t.length() - ti;\\n        if (ti == t.length()) return ans;\\n        int cur = ans;\\n        ti = t.length() - 1;\\n        for (int i = s.length() - 1; i >= 0 && ti >= 0; i--) {\\n            if (record[i]) cur++;\\n            if (s.charAt(i) == t.charAt(ti)) {\\n                cur--;\\n                ti--;\\n            }\\n            ans = Math.min(ans, cur);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194993,
                "title": "15-lines-c-o-n",
                "content": "````\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n        vector<int> pre_mch(m);\\n        vector<int> suf_mch(n+1,2*m+1);\\n        \\n        int cur = 0;\\n        for (int i=0; i<m; i++){\\n            while (cur < n && s[cur] != t[i]) \\n                cur++;\\n            pre_mch[i] = cur++;\\n        }\\n        \\n        cur = n-1;\\n        for (int i=m-1; i>=0; i--){\\n            while (cur >= 0 && s[cur] != t[i]){ \\n                suf_mch[cur--] = i+1;}\\n            if(cur>=0) suf_mch[cur--] = i;\\n        }\\n\\n        int ans = min(m,suf_mch[0]);\\n        for (int i=0; i<m; i++){\\n            if (pre_mch[i] < n) ans = min(ans, m-i-1);\\n            ans = min(ans, max(0, suf_mch[min(n,pre_mch[i]+1)]-i-1));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n        vector<int> pre_mch(m);\\n        vector<int> suf_mch(n+1,2*m+1);\\n        \\n        int cur = 0;\\n        for (int i=0; i<m; i++){\\n            while (cur < n && s[cur] != t[i]) \\n                cur++;\\n            pre_mch[i] = cur++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3188494,
                "title": "simple-binary-search-and-prefix-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to find longest prefix subseq in s and also suffix subseq in s. And we now have to cross check for every value if we have non overlapping substring of t in both prefix and suffix then we will see right and left according to prefix and suffix and compare it with our answer .\\n# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int st = t.length();\\n        vector<int> r, l;\\n        for(int i=0, j = 0;i<t.length() && j < s.length();j++){\\n            if(s[j] == t[i]){ l.push_back(j); i++;}\\n        }\\n        for(int i=t.length()-1, j = s.length()-1;i>=0 && j>=0;j--){\\n            if(s[j] == t[i]){ r.push_back(j); i--;}\\n        }\\n        reverse(r.begin(),r.end());\\n        int ans = t.length();\\n        // if we do not have any prefix subseq then we have left = 0 and right equal to t len - rsize\\n        // see cdeaaaa , bzxcaaaa\\n        // aaaa is common so r size is 5 right here is 3 \\n        // so 8 - 4 = 4;\\n        int l0 =  t.length() - r.size(); // if left size is 0\\n        int r0 =  t.length() - l.size(); // if right size is 0\\n        // similarly\\n        // aaaabzxc\\n        // aaaa is common so l size is 4 and left is 4 and right is t.len - 1\\n        if(l.size() == t.length() || r.size() == t.length()) return 0;\\n        // if we have both side s = acdfgaaaa , t = cfghghgaaaa\\n        // l = cfg , r = gaaaa , here we can see we have used same g 2 times\\n        ans = min({ans,l0,r0});\\n        for(int i=0;i<l.size();i++){\\n            // Now we have to see for this index\\n            int ind = upper_bound(r.begin(),r.end(),l[i]) - r.begin();\\n            ind = r.size()-ind; // we got right side longest length\\n            ind = t.length()-ind-1; // now we need right value so we need to subtract t len to ind\\n            ans = min(ans,ind - i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int st = t.length();\\n        vector<int> r, l;\\n        for(int i=0, j = 0;i<t.length() && j < s.length();j++){\\n            if(s[j] == t[i]){ l.push_back(j); i++;}\\n        }\\n        for(int i=t.length()-1, j = s.length()-1;i>=0 && j>=0;j--){\\n            if(s[j] == t[i]){ r.push_back(j); i--;}\\n        }\\n        reverse(r.begin(),r.end());\\n        int ans = t.length();\\n        // if we do not have any prefix subseq then we have left = 0 and right equal to t len - rsize\\n        // see cdeaaaa , bzxcaaaa\\n        // aaaa is common so r size is 5 right here is 3 \\n        // so 8 - 4 = 4;\\n        int l0 =  t.length() - r.size(); // if left size is 0\\n        int r0 =  t.length() - l.size(); // if right size is 0\\n        // similarly\\n        // aaaabzxc\\n        // aaaa is common so l size is 4 and left is 4 and right is t.len - 1\\n        if(l.size() == t.length() || r.size() == t.length()) return 0;\\n        // if we have both side s = acdfgaaaa , t = cfghghgaaaa\\n        // l = cfg , r = gaaaa , here we can see we have used same g 2 times\\n        ans = min({ans,l0,r0});\\n        for(int i=0;i<l.size();i++){\\n            // Now we have to see for this index\\n            int ind = upper_bound(r.begin(),r.end(),l[i]) - r.begin();\\n            ind = r.size()-ind; // we got right side longest length\\n            ind = t.length()-ind-1; // now we need right value so we need to subtract t len to ind\\n            ans = min(ans,ind - i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188083,
                "title": "c-right-left-3-loops-o-n",
                "content": "got idea from votrubac (https://leetcode.com/problems/subsequence-with-the-minimum-score/discuss/3174041/Right-and-Left-O(n)) and qeetcode sol in weekly contest 332 (https://leetcode.com/qeetcode/).\\nIt can be done in only two for loops with O(n) time complexity but use three here because it is easier to understand.\\n\\nIn the problem hint, dp array based on t is recommended. However, it is complicated when determine whether prefix and surfix overlap in s.  Therefore, dp array based on s is chosen here.\\n\\nuse two array left[ns] and right[ns] with size of s string.\\nleft[i] stands for max prefix length of t that is a subsequence of substring from s[0] to s[i] (including s[i]);\\nright[i] stands for max surfix length of t that is a subsequence of substring from s[i] to s[ns-1] (including s[i]).\\n\\nthe minimum score is initialized as min(left[ns-1], right[0]), which is the prefix only and surfix only case.\\nminimum score = min of nt-left[i]-right[i+1].\\nif the minimum value is smaller than 0, return 0.\\n  \\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int ns=s.size(), nt=t.size();\\n        vector<int> left(ns), right(ns);\\n        for(int i=0, j=0; i<ns; i++) {\\n            if(j<nt && s[i]==t[j])\\n                j++;\\n            left[i]=j;\\n        }\\n        for(int i=ns-1, j=0; i>=0; i--) {\\n            if(j<nt && s[i]==t[nt-1-j])\\n                j++;\\n            right[i]=j;\\n        }\\n        int res=min(nt-left[ns-1], nt-right[0]);\\n        for(int i=0; i<ns-1; i++) {\\n            res=min(res, nt-left[i]-right[i+1]);\\n        }\\n        return max(res, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int ns=s.size(), nt=t.size();\\n        vector<int> left(ns), right(ns);\\n        for(int i=0, j=0; i<ns; i++) {\\n            if(j<nt && s[i]==t[j])\\n                j++;\\n            left[i]=j;\\n        }\\n        for(int i=ns-1, j=0; i>=0; i--) {\\n            if(j<nt && s[i]==t[nt-1-j])\\n                j++;\\n            right[i]=j;\\n        }\\n        int res=min(nt-left[ns-1], nt-right[0]);\\n        for(int i=0; i<ns-1; i++) {\\n            res=min(res, nt-left[i]-right[i+1]);\\n        }\\n        return max(res, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187566,
                "title": "easy-to-understand-c-o-n-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        vector<int> left, right;\\n        int idx = 0; int n = t.size();\\n        \\n        // Scan for left to right get the maxiumm matches\\n        for (int i = 0; (i < s.size()) && (idx < n); i++) {\\n            if (s[i] == t[idx]) {\\n                left.push_back(i);\\n                idx++;\\n            }\\n        }\\n        // initial result will be unmatached characters from the left\\n        int result = n-left.size();\\n        idx = n-1;\\n        \\n        // try matching characters from right to left\\n        for (int i = s.size()-1; (i >= 0) && (idx >= 0) && (result != 0); i--) {\\n            if (s[i] == t[idx]) {\\n                // in order to push to right, left wipe out the matches from left part\\n                // greater than equal to current index\\n                while (left.size() && (left.back() >= i)) {\\n                    // if moving from right to left we found this character earlier\\n                    // then we pop from left and let right proceed further \\n                    left.pop_back();\\n                }\\n                right.push_back(i);\\n                // compute the current state of the unmatched character \\n                int cur = (n - (left.size() + right.size()));\\n                result = min(result,cur);\\n                idx--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        vector<int> left, right;\\n        int idx = 0; int n = t.size();\\n        \\n        // Scan for left to right get the maxiumm matches\\n        for (int i = 0; (i < s.size()) && (idx < n); i++) {\\n            if (s[i] == t[idx]) {\\n                left.push_back(i);\\n                idx++;\\n            }\\n        }\\n        // initial result will be unmatached characters from the left\\n        int result = n-left.size();\\n        idx = n-1;\\n        \\n        // try matching characters from right to left\\n        for (int i = s.size()-1; (i >= 0) && (idx >= 0) && (result != 0); i--) {\\n            if (s[i] == t[idx]) {\\n                // in order to push to right, left wipe out the matches from left part\\n                // greater than equal to current index\\n                while (left.size() && (left.back() >= i)) {\\n                    // if moving from right to left we found this character earlier\\n                    // then we pop from left and let right proceed further \\n                    left.pop_back();\\n                }\\n                right.push_back(i);\\n                // compute the current state of the unmatched character \\n                int cur = (n - (left.size() + right.size()));\\n                result = min(result,cur);\\n                idx--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187133,
                "title": "2-scans-for-prefix-suffix-o-n",
                "content": "We need to find a combination of a prefix/suffix subsequence that has the longest combined length.  First scan left-to-right finding the offsets into s for every character in t that can be a part of a subsequence.  Then do the same scanning right-to-left and matching with the longest subsequence that ends before the current position.\\n```\\nint minimumScore(string s, string t) {\\n    int n=s.size();\\n    int l=0;   // index of char in t in a prefix subsequence.\\n    vector<int> pref(t.size()+1, 100001);\\n    pref[0]=-1;\\n    for (int pos=0; l<t.size(); l++, pos++) {\\n        while (pos<n && s[pos]!=t[l]) ++pos;\\n        if (pos==n) break;\\n        pref[l+1]=pos;         \\n    }\\n    if (l==t.size()) return 0;   // full string is a subsequence!\\n    int ans=t.size()-l;\\n    for (int i=t.size()-1, pos=s.size()-1; i>=0; i--, pos--) {\\n        while (pos>=0 && s[pos]!=t[i]) --pos;\\n        if (pos<0) break;\\n        while (l>=0 && (l>=i || pref[l]>=pos)) --l;\\n        ans=min(ans, i-l); \\n    }\\n    return ans;     \\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minimumScore(string s, string t) {\\n    int n=s.size();\\n    int l=0;   // index of char in t in a prefix subsequence.\\n    vector<int> pref(t.size()+1, 100001);\\n    pref[0]=-1;\\n    for (int pos=0; l<t.size(); l++, pos++) {\\n        while (pos<n && s[pos]!=t[l]) ++pos;\\n        if (pos==n) break;\\n        pref[l+1]=pos;         \\n    }\\n    if (l==t.size()) return 0;   // full string is a subsequence!\\n    int ans=t.size()-l;\\n    for (int i=t.size()-1, pos=s.size()-1; i>=0; i--, pos--) {\\n        while (pos>=0 && s[pos]!=t[i]) --pos;\\n        if (pos<0) break;\\n        while (l>=0 && (l>=i || pref[l]>=pos)) --l;\\n        ans=min(ans, i-l); \\n    }\\n    return ans;     \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3185769,
                "title": "c-binary-search-two-pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int ans = t.length();\\n        vector<int> l(t.length(), -1), r(t.length(), -1);\\n        int j = 0;\\n        for(int i = 0;i<s.length();i++)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                l[j] = i;\\n                j++;\\n            }\\n            if(j==t.length()) break;\\n        }\\n         j = t.length()-1;\\n         \\n        for(int i = s.length()-1;i>=0;i--)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                r[j] = i;\\n                j--;\\n            }\\n            if(j<0) break;\\n        }\\n\\n        for(int i = 0;i<t.length();i++)\\n        {\\n            if(l[i]!=-1) ans = min(ans,(int) t.length()-i-1);\\n            if(r[i]!=-1) ans = min(ans, i);\\n        }\\n\\n\\n        for(int i = 0;i<t.length();i++)\\n        {\\n            if(l[i] >= r[t.length()-1]) break;\\n            if(l[i]==-1) continue;\\n            auto it = upper_bound(r.begin()+i+1, r.end(), l[i]) - r.begin();\\n            ans = min(ans, (int)it-i-1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int ans = t.length();\\n        vector<int> l(t.length(), -1), r(t.length(), -1);\\n        int j = 0;\\n        for(int i = 0;i<s.length();i++)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                l[j] = i;\\n                j++;\\n            }\\n            if(j==t.length()) break;\\n        }\\n         j = t.length()-1;\\n         \\n        for(int i = s.length()-1;i>=0;i--)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                r[j] = i;\\n                j--;\\n            }\\n            if(j<0) break;\\n        }\\n\\n        for(int i = 0;i<t.length();i++)\\n        {\\n            if(l[i]!=-1) ans = min(ans,(int) t.length()-i-1);\\n            if(r[i]!=-1) ans = min(ans, i);\\n        }\\n\\n\\n        for(int i = 0;i<t.length();i++)\\n        {\\n            if(l[i] >= r[t.length()-1]) break;\\n            if(l[i]==-1) continue;\\n            auto it = upper_bound(r.begin()+i+1, r.end(), l[i]) - r.begin();\\n            ans = min(ans, (int)it-i-1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183334,
                "title": "antarnab-100-faster-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        //int minimumScore(string s, string t) {\\n    int ss = s.size(), st = t.size(), k = st - 1;\\n    vector<int> dp(st, -1);\\n    for (int i = ss - 1; i >= 0 && k >= 0; --i)\\n        if (s[i] == t[k])\\n            dp[k--] = i;\\n    int res = k + 1;\\n    for (int i = 0, j = 0; i < ss && j < st && res > 0; ++i)\\n        if (s[i] == t[j]) {\\n            for (; k < t.size() && dp[k] <= i; ++k);\\n            res = min(res, k - (++j));\\n        }\\n    return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        //int minimumScore(string s, string t) {\\n    int ss = s.size(), st = t.size(), k = st - 1;\\n    vector<int> dp(st, -1);\\n    for (int i = ss - 1; i >= 0 && k >= 0; --i)\\n        if (s[i] == t[k])\\n            dp[k--] = i;\\n    int res = k + 1;\\n    for (int i = 0, j = 0; i < ss && j < st && res > 0; ++i)\\n        if (s[i] == t[j]) {\\n            for (; k < t.size() && dp[k] <= i; ++k);\\n            res = min(res, k - (++j));\\n        }\\n    return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182774,
                "title": "python-left-to-right-and-right-to-left-traversal",
                "content": "\\n```\\n    def minimumScore(self, s: str, t: str) -> int:\\n        l = len(s)\\n\\n        right = [0]*(l)\\n        tlen = len(t)\\n        curr =0\\n           \\n        \\n        curr = 0\\n        for i in range(l-1,-1,-1):\\n            if curr<tlen and s[i]==t[tlen-curr-1]:\\n                curr+=1\\n            right[i]=curr\\n        \\n        ans =tlen-right[0]\\n        curr=0\\n        #print(f\"{left} {right} {l} {tlen}\")\\n        for i in range(l):\\n            #print(f\"{i} {left[i]} {right[i+1] if i+1<l else 0}\")\\n            if curr<tlen and s[i]==t[curr]:\\n                curr+=1\\n                \\n            ans = min(ans,tlen- min(curr+ (right[i+1] if i+1<l else 0),tlen))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minimumScore(self, s: str, t: str) -> int:\\n        l = len(s)\\n\\n        right = [0]*(l)\\n        tlen = len(t)\\n        curr =0\\n           \\n        \\n        curr = 0\\n        for i in range(l-1,-1,-1):\\n            if curr<tlen and s[i]==t[tlen-curr-1]:\\n                curr+=1\\n            right[i]=curr\\n        \\n        ans =tlen-right[0]\\n        curr=0\\n        #print(f\"{left} {right} {l} {tlen}\")\\n        for i in range(l):\\n            #print(f\"{i} {left[i]} {right[i+1] if i+1<l else 0}\")\\n            if curr<tlen and s[i]==t[curr]:\\n                curr+=1\\n                \\n            ans = min(ans,tlen- min(curr+ (right[i+1] if i+1<l else 0),tlen))\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3182481,
                "title": "rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) Intruce two vectors: left & right.\\n2) left[i] be the number of characters covered in t (starting from left end) by s[0 ..i - 1].\\n3) right[i] be the nuber of characters covered in t ( starting from right end) by s[i.. m-1].\\n4) Once left & right have been calculated, the final solution could derived with a loop.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_score(s: String, t: String) -> i32 {\\n        let (m, n) = (s.len(), t.len());\\n        let (s, t) = (s.chars().collect::<Vec<char>>(), t.chars().collect::<Vec<char>>());\\n        \\n        let (mut left, mut right) = (vec![0; m + 1], vec![0; m + 1]);\\n        let mut count = 0;\\n        \\n        for i in 0 .. m {\\n            if count < n && s[i] == t[count] { count += 1; }\\n            left[i + 1] = count;\\n        }\\n        \\n        count = 0;\\n        for i in (0 .. m).rev() {\\n            if count < n && s[i] == t[n - count - 1] { count += 1; }\\n            right[i] = count;\\n        }\\n        \\n        let mut ret = n as i32;\\n        for i in 0 ..= m {\\n            ret = ret.min(0.max(n as i32 - left[i] as i32 - right[i] as i32));\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_score(s: String, t: String) -> i32 {\\n        let (m, n) = (s.len(), t.len());\\n        let (s, t) = (s.chars().collect::<Vec<char>>(), t.chars().collect::<Vec<char>>());\\n        \\n        let (mut left, mut right) = (vec![0; m + 1], vec![0; m + 1]);\\n        let mut count = 0;\\n        \\n        for i in 0 .. m {\\n            if count < n && s[i] == t[count] { count += 1; }\\n            left[i + 1] = count;\\n        }\\n        \\n        count = 0;\\n        for i in (0 .. m).rev() {\\n            if count < n && s[i] == t[n - count - 1] { count += 1; }\\n            right[i] = count;\\n        }\\n        \\n        let mut ret = n as i32;\\n        for i in 0 ..= m {\\n            ret = ret.min(0.max(n as i32 - left[i] as i32 - right[i] as i32));\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3182021,
                "title": "c-binarysearch",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        vector<int> right(t.length(), -1);\\n        vector<int> left(t.length(), -1);\\n\\n        int i = 0; \\n\\n        for(int j = 0 ; j < s.length(); j++) {\\n            if ( i < t.length() && t[i] == s[j] ) {\\n                left[i] = j;\\n                i++;\\n            }\\n        }\\n\\n        i = t.size()-1;\\n        for(int j = s.length()-1 ; j >= 0; j--) {\\n            if ( i >= 0 && t[i] == s[j] ) {\\n                right[i] = j;\\n                i--;\\n            }\\n        }\\n\\n        int ans = t.size();\\n        int low = 0, high = t.size();\\n        while (low <= high) {\\n            int mid = (low + high)/2;\\n            if (isSubSequence(t, mid, left, right)) {\\n                ans = mid;\\n                high = mid -1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool isSubSequence(string &t, int val, vector<int> &left, vector<int> &right) {\\n        if(val == t.length()) {\\n            return true;\\n        }\\n\\n        for(int i=0; i<=t.length()-val; i++) {\\n            if (i-1>=0 && i+val < t.length()) {\\n                if(left[i-1] !=-1 && right[i+val] != -1 && right[i+val] > left[i-1]) {\\n                    return true;\\n                }\\n            } else if (i-1 >= 0) {\\n                if (left[i-1] != -1) {\\n                    return true;\\n                }\\n            } else if (i+val < t.length()) {\\n                if(right[i+val] != -1) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        vector<int> right(t.length(), -1);\\n        vector<int> left(t.length(), -1);\\n\\n        int i = 0; \\n\\n        for(int j = 0 ; j < s.length(); j++) {\\n            if ( i < t.length() && t[i] == s[j] ) {\\n                left[i] = j;\\n                i++;\\n            }\\n        }\\n\\n        i = t.size()-1;\\n        for(int j = s.length()-1 ; j >= 0; j--) {\\n            if ( i >= 0 && t[i] == s[j] ) {\\n                right[i] = j;\\n                i--;\\n            }\\n        }\\n\\n        int ans = t.size();\\n        int low = 0, high = t.size();\\n        while (low <= high) {\\n            int mid = (low + high)/2;\\n            if (isSubSequence(t, mid, left, right)) {\\n                ans = mid;\\n                high = mid -1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool isSubSequence(string &t, int val, vector<int> &left, vector<int> &right) {\\n        if(val == t.length()) {\\n            return true;\\n        }\\n\\n        for(int i=0; i<=t.length()-val; i++) {\\n            if (i-1>=0 && i+val < t.length()) {\\n                if(left[i-1] !=-1 && right[i+val] != -1 && right[i+val] > left[i-1]) {\\n                    return true;\\n                }\\n            } else if (i-1 >= 0) {\\n                if (left[i-1] != -1) {\\n                    return true;\\n                }\\n            } else if (i+val < t.length()) {\\n                if(right[i+val] != -1) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181855,
                "title": "c-easy-binary-search-prefix-sum-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n\\n        vector<int>pref(m, n);\\n        vector<int>suff(m, -1);\\n\\n        int p = 0, i = 0;\\n        while(p < m && i < n) {\\n            if(t[p] == s[i]) {\\n                pref[p] = i;\\n                p++; i++;\\n            }else {\\n                i++;\\n            }\\n        }\\n        // for(int i=0; i<pref.size(); i++) {\\n        //     cout << pref[i];\\n        // }\\n        int su = m-1, j = n-1;\\n        while(su >= 0 && j >= 0) {\\n            if(t[su] == s[j]) {\\n                suff[su] = j;\\n                su--; j--;\\n            }else {\\n                j--;\\n            }\\n        }\\n        int mini = INT_MAX;\\n\\n        for(int left = 0; left<m; left++) {\\n            int pos = (left > 0) ? pref[left-1] : -1;\\n            if(pos == n) break;\\n\\n            int right = upper_bound(suff.begin(), suff.end(), pos) - suff.begin();\\n\\n            if(left <= right) mini = min(mini, right-left);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = s.size();\\n        int m = t.size();\\n\\n        vector<int>pref(m, n);\\n        vector<int>suff(m, -1);\\n\\n        int p = 0, i = 0;\\n        while(p < m && i < n) {\\n            if(t[p] == s[i]) {\\n                pref[p] = i;\\n                p++; i++;\\n            }else {\\n                i++;\\n            }\\n        }\\n        // for(int i=0; i<pref.size(); i++) {\\n        //     cout << pref[i];\\n        // }\\n        int su = m-1, j = n-1;\\n        while(su >= 0 && j >= 0) {\\n            if(t[su] == s[j]) {\\n                suff[su] = j;\\n                su--; j--;\\n            }else {\\n                j--;\\n            }\\n        }\\n        int mini = INT_MAX;\\n\\n        for(int left = 0; left<m; left++) {\\n            int pos = (left > 0) ? pref[left-1] : -1;\\n            if(pos == n) break;\\n\\n            int right = upper_bound(suff.begin(), suff.end(), pos) - suff.begin();\\n\\n            if(left <= right) mini = min(mini, right-left);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3181462,
                "title": "java-easy-explained-votrubac-s-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBased on the problem description, we need to find the longest prefix + suffix of t that is a subsequence of s beacuse it was hte way we remove elements from middle. Thus the score would be minimum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each matched character in t, we remember the corresponding point in s in the dp array. This is our suffix.\\nThen we go left-to-right building our prefix. For each prefix, we determine the longest suffix using dp.\\n**Note 2** We use a loop to prevent overlapping and make it move till its not overlapped , then calculate minimum among the answer.\\n**Note 2** res condition is checked that if t as complete is a subsequence of s then no need to remove any thing from it.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumScore(String s, String t) \\n    {\\n        int ss = s.length(),st = t.length(),k = st-1;\\n        int dp[] = new int[st];\\n        Arrays.fill(dp,-1);\\n        for(int i= ss-1;i>=0 && k>=0;i--)\\n        {\\n            if(s.charAt(i) == t.charAt(k))\\n            {\\n                dp[k] = i;\\n                k--;\\n            }\\n        }\\n        int res = k+1;\\n        if(res == 0)\\n        return 0;\\n        for(int i = 0,j=0;i<ss && j<st;i++)\\n        {\\n            if(s.charAt(i) == t.charAt(j))\\n            {\\n                while(k<st && dp[k]<=i)\\n                {\\n                    k++;\\n                }\\n                j++;\\n                res = Math.min(res, k - (j));\\n            }\\n        }\\n        return res;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumScore(String s, String t) \\n    {\\n        int ss = s.length(),st = t.length(),k = st-1;\\n        int dp[] = new int[st];\\n        Arrays.fill(dp,-1);\\n        for(int i= ss-1;i>=0 && k>=0;i--)\\n        {\\n            if(s.charAt(i) == t.charAt(k))\\n            {\\n                dp[k] = i;\\n                k--;\\n            }\\n        }\\n        int res = k+1;\\n        if(res == 0)\\n        return 0;\\n        for(int i = 0,j=0;i<ss && j<st;i++)\\n        {\\n            if(s.charAt(i) == t.charAt(j))\\n            {\\n                while(k<st && dp[k]<=i)\\n                {\\n                    k++;\\n                }\\n                j++;\\n                res = Math.min(res, k - (j));\\n            }\\n        }\\n        return res;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180285,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_score(s: String, t: String) -> i32 {\\n        let (s, t) = (s.as_bytes(), t.as_bytes());\\n        let (ss, ts) = (s.len(), t.len());\\n        let (mut k, mut j) = (ts as i32 - 1, ts as i32 - 1);\\n        let mut dp = vec![-1; ts];\\n\\n        let mut i = ss as i32 - 1;\\n        while i >= 0 {\\n            if j >= 0 && t[j as usize] == s[i as usize] {\\n                dp[k as usize] = i;\\n                j -= 1;\\n                k -= 1;\\n            }\\n            i -= 1;\\n        }\\n\\n        let mut ans = k + 1;\\n        if ans == 0 {\\n            return 0;\\n        }\\n\\n        j = 0;\\n        for (i, &item) in s.iter().enumerate().take(ss) {\\n            if j < ts as i32 && t[j as usize] == item {\\n                while k < ts as i32 && dp[k as usize] <= i as i32 {\\n                    k += 1;\\n                }\\n                ans = ans.min(k - j - 1);\\n                j += 1;\\n            }\\n        }\\n        ans as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_score(s: String, t: String) -> i32 {\\n        let (s, t) = (s.as_bytes(), t.as_bytes());\\n        let (ss, ts) = (s.len(), t.len());\\n        let (mut k, mut j) = (ts as i32 - 1, ts as i32 - 1);\\n        let mut dp = vec![-1; ts];\\n\\n        let mut i = ss as i32 - 1;\\n        while i >= 0 {\\n            if j >= 0 && t[j as usize] == s[i as usize] {\\n                dp[k as usize] = i;\\n                j -= 1;\\n                k -= 1;\\n            }\\n            i -= 1;\\n        }\\n\\n        let mut ans = k + 1;\\n        if ans == 0 {\\n            return 0;\\n        }\\n\\n        j = 0;\\n        for (i, &item) in s.iter().enumerate().take(ss) {\\n            if j < ts as i32 && t[j as usize] == item {\\n                while k < ts as i32 && dp[k as usize] <= i as i32 {\\n                    k += 1;\\n                }\\n                ans = ans.min(k - j - 1);\\n                j += 1;\\n            }\\n        }\\n        ans as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3179193,
                "title": "python-o-n-solution-with-clear-logical-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n\\n        # 1. build prefix and suffix\\n        #   prefix[i]: index of t which has its left part a subsequence of s[:i]\\n        #              t[: prefix[i]] is a subsequence of s[: i]\\n        #   suffix[i]: index of t which has its right part a subsequence of s[i:]\\n        #               t[suffix[i] :] is a subsequence of s[i :]\\n        #   prefix is left-to-right scanning, while suffix is right-to-left scanning\\n        \\n        prefix = [-1] * len(s)\\n        i = j = 0\\n        while i < len(s):\\n            if j < len(t) and s[i] == t[j]:\\n                prefix[i] = j\\n                j += 1\\n            elif i > 0:\\n                prefix[i] = prefix[i - 1]\\n            i += 1\\n\\n        if prefix[-1] == len(t) - 1:    # t is subsequence of s\\n            return 0\\n\\n        suffix = [len(t)] * len(s)\\n        i, j = len(s) - 1, len(t) - 1\\n        while i >= 0:\\n            if j >= 0 and s[i] == t[j]:\\n                suffix[i] = j\\n                j -= 1\\n            elif i < len(s) - 1:\\n                suffix[i] = suffix[i + 1]\\n            i -= 1\\n\\n        # 2. scan s to find the longest subsequence based on prefix and suffix\\n        # since t is not a subsequence of s, so prefix[i] < suffix[i]\\n\\n        length = float(\\'Inf\\')\\n\\n        for idx in range(len(s)):\\n            # check if s[idx] is the first match for s[prefix[idx]] and s[suffix[idx]]\\n            # if so, need to remove one more chars\\n            if (prefix[idx] >= 0) and (idx == 0 or prefix[idx] > prefix[idx - 1]):\\n                pre_match = True    # s[idx] is the one to match t[prefix[idx]] for the first time\\n            else:\\n                pre_match = False\\n            if (suffix[idx] < len(t)) and (idx == len(s) - 1 or suffix[idx] < suffix[idx + 1]):\\n                suf_match = True    # s[idx] is the one to match t[suffix[idx]] for the first time\\n            else:\\n                suf_match = False\\n\\n            if  pre_match and suf_match:\\n                length = min(length, suffix[idx] - prefix[idx])\\n            else:\\n                length = min(length, suffix[idx] - prefix[idx] - 1)\\n\\n        return length\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n\\n        # 1. build prefix and suffix\\n        #   prefix[i]: index of t which has its left part a subsequence of s[:i]\\n        #              t[: prefix[i]] is a subsequence of s[: i]\\n        #   suffix[i]: index of t which has its right part a subsequence of s[i:]\\n        #               t[suffix[i] :] is a subsequence of s[i :]\\n        #   prefix is left-to-right scanning, while suffix is right-to-left scanning\\n        \\n        prefix = [-1] * len(s)\\n        i = j = 0\\n        while i < len(s):\\n            if j < len(t) and s[i] == t[j]:\\n                prefix[i] = j\\n                j += 1\\n            elif i > 0:\\n                prefix[i] = prefix[i - 1]\\n            i += 1\\n\\n        if prefix[-1] == len(t) - 1:    # t is subsequence of s\\n            return 0\\n\\n        suffix = [len(t)] * len(s)\\n        i, j = len(s) - 1, len(t) - 1\\n        while i >= 0:\\n            if j >= 0 and s[i] == t[j]:\\n                suffix[i] = j\\n                j -= 1\\n            elif i < len(s) - 1:\\n                suffix[i] = suffix[i + 1]\\n            i -= 1\\n\\n        # 2. scan s to find the longest subsequence based on prefix and suffix\\n        # since t is not a subsequence of s, so prefix[i] < suffix[i]\\n\\n        length = float(\\'Inf\\')\\n\\n        for idx in range(len(s)):\\n            # check if s[idx] is the first match for s[prefix[idx]] and s[suffix[idx]]\\n            # if so, need to remove one more chars\\n            if (prefix[idx] >= 0) and (idx == 0 or prefix[idx] > prefix[idx - 1]):\\n                pre_match = True    # s[idx] is the one to match t[prefix[idx]] for the first time\\n            else:\\n                pre_match = False\\n            if (suffix[idx] < len(t)) and (idx == len(s) - 1 or suffix[idx] < suffix[idx + 1]):\\n                suf_match = True    # s[idx] is the one to match t[suffix[idx]] for the first time\\n            else:\\n                suf_match = False\\n\\n            if  pre_match and suf_match:\\n                length = min(length, suffix[idx] - prefix[idx])\\n            else:\\n                length = min(length, suffix[idx] - prefix[idx] - 1)\\n\\n        return length\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177806,
                "title": "find-prefix-and-suffix-and-check-the-smallest-removal-score",
                "content": "\\n### Fact\\n> only the leftmost non-removal and rightmost non-removal positions affect the score, so we just need to find prefix and suffix.\\n\\n\\nWe have to look for all [prefix, suffix] pairs to get the most optimized score.\\n\\n\\n## Solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int m = s.size(), n = t.size();\\\\\\n        // get rightmost index in s that all t\\'s suffix sequence can be constructed\\n        vector<int> suffix(n, -1);\\n        int k = n - 1;\\n        for (int i = m - 1; i >= 0 && k >= 0; --i) {\\n            if (s[i] == t[k]) {\\n                suffix[k--] = i;\\n            }\\n        }\\n        // t can be formed by char sequence in s, no removal needed\\n        if (k < 0) {\\n            return 0;\\n        }\\n        \\n        // t[0...k] should be removed\\n        int minScore = k + 1;\\n        \\n        // get leftmost index in s that all t\\'s prefix sequence can be constructed\\n        vector<int> prefix(n, -1);\\n        k = 0;\\n        for (int i = 0; i < m && k < n; ++i) {\\n            if (s[i] == t[k]) {\\n                prefix[k++] = i;\\n            }\\n        }\\n\\n        // t can be formed by char sequence in s, no removal needed\\n        if (k >= n) {\\n            return 0;\\n        }\\n        // t[k...n-1] shoule be removed\\n        minScore = min(minScore, n - k);\\n        \\n\\n        // now, we check if there exist prefix and suffix \\n        // t[...i] and t[j...] to get the smaller score with  j - 1 - (i + 1) + 1\\n        for (int i = 0; i < n; i++) {\\n            // now, there exist prefix t[...i]\\n            if (prefix[i] != -1) {\\n                // s[0...leftMost]\\n                int leftMost = prefix[i];\\n                \\n                // find suffix t[j...]\\n                int j = n - 1;\\n                while(j >= 0 && suffix[j] > leftMost) {\\n                    j--;\\n                }\\n                // j is -1 or suffix[j] <= leftMost\\n                // j is -1 means all chars t[0..n-1] can be removed \\n                if (j == -1) {\\n                    minScore = min(minScore, n - 1 + 1);\\n                } else {\\n                    // now, we can know t[...i]  .... t[j + 1 ...]\\n                    int score = j - (i + 1) + 1;\\n                    minScore = min(minScore, score);\\n                }\\n            }\\n        }\\n        \\n        return minScore;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int m = s.size(), n = t.size();\\\\\\n        // get rightmost index in s that all t\\'s suffix sequence can be constructed\\n        vector<int> suffix(n, -1);\\n        int k = n - 1;\\n        for (int i = m - 1; i >= 0 && k >= 0; --i) {\\n            if (s[i] == t[k]) {\\n                suffix[k--] = i;\\n            }\\n        }\\n        // t can be formed by char sequence in s, no removal needed\\n        if (k < 0) {\\n            return 0;\\n        }\\n        \\n        // t[0...k] should be removed\\n        int minScore = k + 1;\\n        \\n        // get leftmost index in s that all t\\'s prefix sequence can be constructed\\n        vector<int> prefix(n, -1);\\n        k = 0;\\n        for (int i = 0; i < m && k < n; ++i) {\\n            if (s[i] == t[k]) {\\n                prefix[k++] = i;\\n            }\\n        }\\n\\n        // t can be formed by char sequence in s, no removal needed\\n        if (k >= n) {\\n            return 0;\\n        }\\n        // t[k...n-1] shoule be removed\\n        minScore = min(minScore, n - k);\\n        \\n\\n        // now, we check if there exist prefix and suffix \\n        // t[...i] and t[j...] to get the smaller score with  j - 1 - (i + 1) + 1\\n        for (int i = 0; i < n; i++) {\\n            // now, there exist prefix t[...i]\\n            if (prefix[i] != -1) {\\n                // s[0...leftMost]\\n                int leftMost = prefix[i];\\n                \\n                // find suffix t[j...]\\n                int j = n - 1;\\n                while(j >= 0 && suffix[j] > leftMost) {\\n                    j--;\\n                }\\n                // j is -1 or suffix[j] <= leftMost\\n                // j is -1 means all chars t[0..n-1] can be removed \\n                if (j == -1) {\\n                    minScore = min(minScore, n - 1 + 1);\\n                } else {\\n                    // now, we can know t[...i]  .... t[j + 1 ...]\\n                    int score = j - (i + 1) + 1;\\n                    minScore = min(minScore, score);\\n                }\\n            }\\n        }\\n        \\n        return minScore;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177574,
                "title": "bs-1-dp",
                "content": "\\n```\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        char[] array1 = s.toCharArray();\\n        char[] array2 = t.toCharArray();\\n        int n1 = array1.length, n2 = array2.length;\\n        int index = 0;\\n        int[] dp1 = new int[n2];\\n        Arrays.fill(dp1, -1);\\n        int[] dp2 = new int[n2];\\n        Arrays.fill(dp2, -1);\\n        for (int i = 0; i < n1 && index < n2; i++) {\\n            char ch = array1[i];\\n            if (array2[index] == ch) {\\n                dp1[index] = i;\\n                index++;\\n            }\\n        }\\n        if (dp1[n2-1] != -1) return 0;\\n        index = n2-1;\\n        for (int i = n1-1; i >= 0 && index >= 0; i--) {\\n            char ch = array1[i];\\n            if (array2[index] == ch) {\\n                dp2[index] = i;\\n                index--;\\n            }\\n        }\\n        int left = 1, right = n2;\\n        int res = n2;\\n        // bs? two pointer? -> bs\\n        while (left < right) {\\n            int mid = left + (right - left)/2;\\n            if (validate(mid, dp1, dp2)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return validate(left, dp1, dp2) ? left : right;\\n    }\\n    private boolean validate(int len, int[] dp1, int[] dp2) {\\n        int n = dp1.length;\\n        for (int i = 0; i <= n - len; i++) {\\n            int left = i;\\n            int right = i + len - 1;\\n            if (left - 1 >= 0 && right + 1 < n) {\\n                if (dp1[left-1] != -1 && dp2[right+1] != -1 && dp1[left-1] < dp2[right+1]) return true;\\n            } else if (left - 1 >= 0) {\\n                if (dp1[left-1] != -1) return true;\\n            } else if (right + 1 < n){\\n                if (dp2[right+1] != -1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        char[] array1 = s.toCharArray();\\n        char[] array2 = t.toCharArray();\\n        int n1 = array1.length, n2 = array2.length;\\n        int index = 0;\\n        int[] dp1 = new int[n2];\\n        Arrays.fill(dp1, -1);\\n        int[] dp2 = new int[n2];\\n        Arrays.fill(dp2, -1);\\n        for (int i = 0; i < n1 && index < n2; i++) {\\n            char ch = array1[i];\\n            if (array2[index] == ch) {\\n                dp1[index] = i;\\n                index++;\\n            }\\n        }\\n        if (dp1[n2-1] != -1) return 0;\\n        index = n2-1;\\n        for (int i = n1-1; i >= 0 && index >= 0; i--) {\\n            char ch = array1[i];\\n            if (array2[index] == ch) {\\n                dp2[index] = i;\\n                index--;\\n            }\\n        }\\n        int left = 1, right = n2;\\n        int res = n2;\\n        // bs? two pointer? -> bs\\n        while (left < right) {\\n            int mid = left + (right - left)/2;\\n            if (validate(mid, dp1, dp2)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return validate(left, dp1, dp2) ? left : right;\\n    }\\n    private boolean validate(int len, int[] dp1, int[] dp2) {\\n        int n = dp1.length;\\n        for (int i = 0; i <= n - len; i++) {\\n            int left = i;\\n            int right = i + len - 1;\\n            if (left - 1 >= 0 && right + 1 < n) {\\n                if (dp1[left-1] != -1 && dp2[right+1] != -1 && dp1[left-1] < dp2[right+1]) return true;\\n            } else if (left - 1 >= 0) {\\n                if (dp1[left-1] != -1) return true;\\n            } else if (right + 1 < n){\\n                if (dp2[right+1] != -1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177481,
                "title": "scala-scan-twice",
                "content": "```scala\\nobject Solution {\\n  def minimumScore(s: String, t: String): Int = {\\n    val leftMatch = s.scanLeft(0, t.zipWithIndex) {\\n      case ((_, (ct, i)+:ts), cs) => if (ct == cs) (i, ts) else (-1, (ct, i)+:ts)\\n      case _ => (-1, null)\\n    }.map(_._1).drop(1)\\n    val lastMatch = leftMatch.findLast(_ != -1).getOrElse(-1)\\n    val lastUnmatch = (t.size - lastMatch - 1)\\n    val res = s.zip(leftMatch).reverse.scanLeft(lastUnmatch, lastMatch, t.zipWithIndex.reverse) {\\n      case ((_, m, (ct, i)+:ts), (cs, j)) =>\\n        val nm = if (j == -1) m else j - 1\\n        if (ct == cs) (i - nm - 1, nm, ts) else (Int.MaxValue, nm, (ct, i)+:ts)\\n      case _ => (0, 0, null)\\n    }\\n    res.map(_._1).min max 0\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n  def minimumScore(s: String, t: String): Int = {\\n    val leftMatch = s.scanLeft(0, t.zipWithIndex) {\\n      case ((_, (ct, i)+:ts), cs) => if (ct == cs) (i, ts) else (-1, (ct, i)+:ts)\\n      case _ => (-1, null)\\n    }.map(_._1).drop(1)\\n    val lastMatch = leftMatch.findLast(_ != -1).getOrElse(-1)\\n    val lastUnmatch = (t.size - lastMatch - 1)\\n    val res = s.zip(leftMatch).reverse.scanLeft(lastUnmatch, lastMatch, t.zipWithIndex.reverse) {\\n      case ((_, m, (ct, i)+:ts), (cs, j)) =>\\n        val nm = if (j == -1) m else j - 1\\n        if (ct == cs) (i - nm - 1, nm, ts) else (Int.MaxValue, nm, (ct, i)+:ts)\\n      case _ => (0, 0, null)\\n    }\\n    res.map(_._1).min max 0\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3177132,
                "title": "sharing-my-o-nlogn-solution-100-faster-and-memory-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n=t.size();\\n        vector<int>first(n,-1),last(n,-1);\\n        int i=0,j=0;\\n        \\n        \\n        while(i<s.size()&&j<t.size()){\\n            if(s[i]==t[j]){\\n                first[j]=i;\\n                i++;\\n                j++;\\n            }\\n            else i++;\\n        }\\n        i=s.size()-1,j=t.size()-1;\\n        while(i>=0&&j>=0){\\n             if(s[i]==t[j]){\\n                last[j]=i;\\n                i--;\\n                j--;\\n            }\\n            else i--;\\n        }\\n        if(first.back()!=-1){\\n            return 0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(first[i]==-1){\\n                first[i]=s.size()+1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(last[i]==-1){\\n                last[i]=-1;\\n            }\\n        }\\n        \\n        \\n        if(first[0]==s.size()+1){\\n            return n;\\n        }    \\n        \\n        int ans=n;\\n        int l=0,r=n;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            bool b=false;\\n            for(int i=0;i<n-m-1;i++){\\n                if(last[i+m+1]>first[i]){\\n                    b=true;\\n                    break;\\n                }\\n            }\\n            if(b){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else l=m+1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(first[i]!=s.size()+1){\\n                ans=min(ans,n-i-1);\\n            }\\n            if(last[i]!=-1){\\n                ans=min(ans,i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n=t.size();\\n        vector<int>first(n,-1),last(n,-1);\\n        int i=0,j=0;\\n        \\n        \\n        while(i<s.size()&&j<t.size()){\\n            if(s[i]==t[j]){\\n                first[j]=i;\\n                i++;\\n                j++;\\n            }\\n            else i++;\\n        }\\n        i=s.size()-1,j=t.size()-1;\\n        while(i>=0&&j>=0){\\n             if(s[i]==t[j]){\\n                last[j]=i;\\n                i--;\\n                j--;\\n            }\\n            else i--;\\n        }\\n        if(first.back()!=-1){\\n            return 0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(first[i]==-1){\\n                first[i]=s.size()+1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(last[i]==-1){\\n                last[i]=-1;\\n            }\\n        }\\n        \\n        \\n        if(first[0]==s.size()+1){\\n            return n;\\n        }    \\n        \\n        int ans=n;\\n        int l=0,r=n;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            bool b=false;\\n            for(int i=0;i<n-m-1;i++){\\n                if(last[i+m+1]>first[i]){\\n                    b=true;\\n                    break;\\n                }\\n            }\\n            if(b){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else l=m+1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(first[i]!=s.size()+1){\\n                ans=min(ans,n-i-1);\\n            }\\n            if(last[i]!=-1){\\n                ans=min(ans,i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177084,
                "title": "easy-to-understand-o-n-space-o-n-time-well-commented-solution",
                "content": "Since only extreme ends have an impact on our solution, it makes sense to leave the left side block and right side block and delete the middle piece of string t.\\nWe define two arrays, one holding prefix data and the other suffix data, both of size n (n=size of string s).\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n=s.size(),j=0,res=1e9;\\n        //declare 2 arrays: v1=prefix array, v2=suffix array\\n        vector<int>v1(n),v2(n);\\n        //Case 1- current element is part of prefix\\n        for(int i=0;i<n;i++){\\n            if(j<t.size() && s[i]==t[j]){\\n                j++;\\n            }\\n            v1[i]=j;\\n        }\\n        j=t.size()-1;\\n        for(int i=n-1;i>=0;i--){\\n            v2[i]=j;\\n            if(j>=0 && s[i]==t[j]){\\n                j--;\\n            }\\n        }\\n        //check result\\n        for(int i=0;i<n;i++){\\n            res=min(res,max(0,v2[i]-v1[i]+1));\\n        }\\n        //Case 2- current element is part of suffix\\n        j=0;\\n        for(int i=0;i<n;i++){\\n            v1[i]=j;\\n            if(j<t.size() && s[i]==t[j]){\\n                j++;\\n            }\\n        }\\n        //check result\\n        j=t.size()-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(j>=0 && s[i]==t[j]){\\n                j--;\\n            }\\n            v2[i]=j;\\n        }\\n        for(int i=0;i<n;i++){\\n            res=min(res,max(0,v2[i]-v1[i]+1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n=s.size(),j=0,res=1e9;\\n        //declare 2 arrays: v1=prefix array, v2=suffix array\\n        vector<int>v1(n),v2(n);\\n        //Case 1- current element is part of prefix\\n        for(int i=0;i<n;i++){\\n            if(j<t.size() && s[i]==t[j]){\\n                j++;\\n            }\\n            v1[i]=j;\\n        }\\n        j=t.size()-1;\\n        for(int i=n-1;i>=0;i--){\\n            v2[i]=j;\\n            if(j>=0 && s[i]==t[j]){\\n                j--;\\n            }\\n        }\\n        //check result\\n        for(int i=0;i<n;i++){\\n            res=min(res,max(0,v2[i]-v1[i]+1));\\n        }\\n        //Case 2- current element is part of suffix\\n        j=0;\\n        for(int i=0;i<n;i++){\\n            v1[i]=j;\\n            if(j<t.size() && s[i]==t[j]){\\n                j++;\\n            }\\n        }\\n        //check result\\n        j=t.size()-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(j>=0 && s[i]==t[j]){\\n                j--;\\n            }\\n            v2[i]=j;\\n        }\\n        for(int i=0;i<n;i++){\\n            res=min(res,max(0,v2[i]-v1[i]+1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176965,
                "title": "two-pointers",
                "content": "Observations:\\n1. By the way we calculaute the score, it makes no difference to assume that any points in between [left, right] are removed. \\n2. Because we do not need to remove (right end inclusive) t[0, left - 1] and t[right + 1, t.size() - 1],  they have to be subsequences of s.\\n3. This means, we want to remove the shortest substring of t so that prefix and suffix strings of t are both subsequences of s. The score of the removal is the number of characters removed.\\n4. Finally, the idea of solving the question is: We first find the longest prefix substring of t which is also a subsequence of s. Then we gradually increase the length of the suffix string to get the maximal characters removed in each settings. Time and space complexity are both linear in the lengths\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int m = s.size(), n = t.size();\\n        vector<int> stk;\\n        for(int i = 0, j = 0; i < m; i++){\\n            if(s[i] != t[j]) continue;\\n            stk.push_back(i);\\n            j++;\\n        }\\n        \\n        int res = n - stk.size();\\n        if(res == 0) return res;\\n        \\n        for(int i = m - 1, j = n - 1; i >= 0; i--){\\n            if(s[i] != t[j]) continue;\\n            while(!stk.empty() && stk.back() >= i){\\n                stk.pop_back();\\n            }\\n            j--;\\n            res = min(res, j - (int)stk.size() + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int m = s.size(), n = t.size();\\n        vector<int> stk;\\n        for(int i = 0, j = 0; i < m; i++){\\n            if(s[i] != t[j]) continue;\\n            stk.push_back(i);\\n            j++;\\n        }\\n        \\n        int res = n - stk.size();\\n        if(res == 0) return res;\\n        \\n        for(int i = m - 1, j = n - 1; i >= 0; i--){\\n            if(s[i] != t[j]) continue;\\n            while(!stk.empty() && stk.back() >= i){\\n                stk.pop_back();\\n            }\\n            j--;\\n            res = min(res, j - (int)stk.size() + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176312,
                "title": "go-python-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc minimumScore(s string, t string) int {\\n    suffix :=make([]int,len(s))\\n    j := len(t)-1\\n    for i:=len(s)-1;i>=0;i--{\\n        if 0 <= j && s[i] == t[j]{\\n            j--\\n        }\\n        suffix[i] = j \\n    }\\n    answer := j + 1\\n    j = 0\\n    for i,_ := range(s){\\n        answer = min(answer, max(0, suffix[i] - j + 1))\\n        if j < len(t) && s[i] == t[j]{\\n            j++\\n        }\\n    }\\n    return min(answer, len(t)-j)\\n}\\n\\nfunc min(a,b int) int{\\n    if a<b{\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc max(a,b int) int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\n```\\n```python []\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        suffix = [0 for i in range(len(s))]\\n        j = len(t)-1\\n        for i in range(len(s)-1,-1,-1): \\n            if 0 <= j and s[i] == t[j]:\\n                j -= 1\\n            suffix[i] = j \\n        answer = j + 1\\n        j = 0 \\n        for i,_ in enumerate(s): \\n            answer = min(answer, max(0, suffix[i] - j + 1))\\n            if j < len(t) and s[i] == t[j]:\\n                j += 1\\n        return min(answer, len(t)-j)\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```golang []\\nfunc minimumScore(s string, t string) int {\\n    suffix :=make([]int,len(s))\\n    j := len(t)-1\\n    for i:=len(s)-1;i>=0;i--{\\n        if 0 <= j && s[i] == t[j]{\\n            j--\\n        }\\n        suffix[i] = j \\n    }\\n    answer := j + 1\\n    j = 0\\n    for i,_ := range(s){\\n        answer = min(answer, max(0, suffix[i] - j + 1))\\n        if j < len(t) && s[i] == t[j]{\\n            j++\\n        }\\n    }\\n    return min(answer, len(t)-j)\\n}\\n\\nfunc min(a,b int) int{\\n    if a<b{\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc max(a,b int) int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\n```\n```python []\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        suffix = [0 for i in range(len(s))]\\n        j = len(t)-1\\n        for i in range(len(s)-1,-1,-1): \\n            if 0 <= j and s[i] == t[j]:\\n                j -= 1\\n            suffix[i] = j \\n        answer = j + 1\\n        j = 0 \\n        for i,_ in enumerate(s): \\n            answer = min(answer, max(0, suffix[i] - j + 1))\\n            if j < len(t) and s[i] == t[j]:\\n                j += 1\\n        return min(answer, len(t)-j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176193,
                "title": "simple-binary-search-approach",
                "content": "\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int check(vector<int>& p,vector<int>& s,int m){\\n        int l=0,n=p.size()-1;\\n        for(int r=0;r<n;r++){\\n            while((r-l+1)>m)\\n                l++;\\n            if((r-l+1)==m){\\n                int left=-1;\\n                if(l)\\n                    left=p[l-1];\\n                int right=s[r+1];\\n                if(left<right)\\n                    return 1;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int minimumScore(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        vector<int> pr(m+1,n),sf(m+1,-1);\\n        sf[m]=n;\\n        \\n        int i=0,j=0;\\n        \\n        while(i<n and j<m){\\n            if(s[i]==t[j]){\\n                pr[j]=i;\\n                j++;\\n            }\\n            i++;\\n        }\\n        \\n        i=n-1;\\n        j=m-1;\\n        \\n        while(i>=0 and j>=0){\\n            if(s[i]==t[j]){\\n                sf[j]=i;\\n                --j;\\n            }\\n            --i;\\n        }\\n        \\n        \\n        \\n        ll l=0,ans=m,r=m;\\n        \\n        while(l<=r){\\n            ll mid=l+((r-l)>>1);\\n            \\n            if(check(pr,sf,mid)){\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int check(vector<int>& p,vector<int>& s,int m){\\n        int l=0,n=p.size()-1;\\n        for(int r=0;r<n;r++){\\n            while((r-l+1)>m)\\n                l++;\\n            if((r-l+1)==m){\\n                int left=-1;\\n                if(l)\\n                    left=p[l-1];\\n                int right=s[r+1];\\n                if(left<right)\\n                    return 1;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int minimumScore(string s, string t) {\\n        int n=s.length(),m=t.length();\\n        vector<int> pr(m+1,n),sf(m+1,-1);\\n        sf[m]=n;\\n        \\n        int i=0,j=0;\\n        \\n        while(i<n and j<m){\\n            if(s[i]==t[j]){\\n                pr[j]=i;\\n                j++;\\n            }\\n            i++;\\n        }\\n        \\n        i=n-1;\\n        j=m-1;\\n        \\n        while(i>=0 and j>=0){\\n            if(s[i]==t[j]){\\n                sf[j]=i;\\n                --j;\\n            }\\n            --i;\\n        }\\n        \\n        \\n        \\n        ll l=0,ans=m,r=m;\\n        \\n        while(l<=r){\\n            ll mid=l+((r-l)>>1);\\n            \\n            if(check(pr,sf,mid)){\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176109,
                "title": "java-prefix-suffix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to delete every possible window of size \\'k\\'. If we are able to delete window of size \\'k\\', then try to find a better minimum answer.\\n\\nLet\\'s say the window is i......j. Now check if prefix[0...i-1] and suffix[j+1...t.length()-1] are non-overlapping.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n\\n        int n=t.length();\\n\\n\\n        // prefix[i] is the min index in string \\'s\\' such that prefix[i] of string \\'t\\' is a subsequence of string \\'s\\'\\n        // suffix[i] is the min index in string \\'s\\' such that suffix[i] of string \\'t\\' is a subsequence of string \\'s\\'\\n        int[] prefix = new int[n];\\n        int[] suffix = new int[n];\\n        Arrays.fill(prefix, Integer.MAX_VALUE);\\n        Arrays.fill(suffix, -1);\\n        int j=0;\\n        for(int i=0;i<s.length();++i)\\n        {\\n            if(j<t.length() && s.charAt(i)==t.charAt(j))\\n            {\\n                prefix[j] = i; \\n                j++;\\n            }\\n        }   \\n        j=t.length()-1;\\n        for(int i=s.length()-1;i>=0;--i)\\n        {\\n            if(j>=0 && s.charAt(i)==t.charAt(j))\\n            {\\n                suffix[j] = i; \\n                j--;\\n            }\\n        }   \\n        \\n        int low=0, high=n;\\n        int ans=n;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(poss(s, t, mid, prefix, suffix))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n    public boolean poss(String s, String t, int k, int[] prefix, int[] suffix)\\n    {\\n        int start=0, end=k-1;\\n        int n=t.length();\\n\\n        if(k>n)\\n            return true;\\n\\n        while(end<n)\\n        {\\n            // t[0....start-1] and t[end+1.......n-1]\\n            if(start==0 && end<n-1 && suffix[end+1] != -1)\\n                return true;\\n            if(start>0 && end==n-1 && prefix[start-1] != Integer.MAX_VALUE)\\n                return true;\\n            if(start>0 && end<n-1 && prefix[start-1] < suffix[end+1])\\n                return true; \\n            start++;\\n            end++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n\\n        int n=t.length();\\n\\n\\n        // prefix[i] is the min index in string \\'s\\' such that prefix[i] of string \\'t\\' is a subsequence of string \\'s\\'\\n        // suffix[i] is the min index in string \\'s\\' such that suffix[i] of string \\'t\\' is a subsequence of string \\'s\\'\\n        int[] prefix = new int[n];\\n        int[] suffix = new int[n];\\n        Arrays.fill(prefix, Integer.MAX_VALUE);\\n        Arrays.fill(suffix, -1);\\n        int j=0;\\n        for(int i=0;i<s.length();++i)\\n        {\\n            if(j<t.length() && s.charAt(i)==t.charAt(j))\\n            {\\n                prefix[j] = i; \\n                j++;\\n            }\\n        }   \\n        j=t.length()-1;\\n        for(int i=s.length()-1;i>=0;--i)\\n        {\\n            if(j>=0 && s.charAt(i)==t.charAt(j))\\n            {\\n                suffix[j] = i; \\n                j--;\\n            }\\n        }   \\n        \\n        int low=0, high=n;\\n        int ans=n;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(poss(s, t, mid, prefix, suffix))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n        \\n    }\\n    public boolean poss(String s, String t, int k, int[] prefix, int[] suffix)\\n    {\\n        int start=0, end=k-1;\\n        int n=t.length();\\n\\n        if(k>n)\\n            return true;\\n\\n        while(end<n)\\n        {\\n            // t[0....start-1] and t[end+1.......n-1]\\n            if(start==0 && end<n-1 && suffix[end+1] != -1)\\n                return true;\\n            if(start>0 && end==n-1 && prefix[start-1] != Integer.MAX_VALUE)\\n                return true;\\n            if(start>0 && end<n-1 && prefix[start-1] < suffix[end+1])\\n                return true; \\n            start++;\\n            end++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176011,
                "title": "cpp-solution-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        \\n        vector<int>v;\\n        int ans=0;\\n        \\n        int i=s.size()-1,j=t.size()-1;\\n        \\n        while(i>=0 && j>=0){\\n            if(s[i]==t[j]){v.push_back(i);j--;}\\n            i--;\\n        }\\n        \\n        reverse(v.begin(),v.end());\\n        \\n        ans=t.size()-v.size();\\n        \\n        if(ans==0)return ans;\\n        \\n        i=0,j=0;\\n        \\n                \\n        while(j<t.size()){\\n            while(i<s.size() && s[i]!=t[j])i++;\\n            if(i>=s.size())break;\\n            int u=upper_bound(v.begin(),v.end(),i)-v.begin();\\n            \\n      \\n            int m=v.size(),p=t.size();\\n            \\n            if(u>=m)ans=min(ans,p-(j+1));\\n        \\n            else ans=min(ans,p-(m-u)-(j+1));\\n            \\n            j++;\\n            i++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        \\n        vector<int>v;\\n        int ans=0;\\n        \\n        int i=s.size()-1,j=t.size()-1;\\n        \\n        while(i>=0 && j>=0){\\n            if(s[i]==t[j]){v.push_back(i);j--;}\\n            i--;\\n        }\\n        \\n        reverse(v.begin(),v.end());\\n        \\n        ans=t.size()-v.size();\\n        \\n        if(ans==0)return ans;\\n        \\n        i=0,j=0;\\n        \\n                \\n        while(j<t.size()){\\n            while(i<s.size() && s[i]!=t[j])i++;\\n            if(i>=s.size())break;\\n            int u=upper_bound(v.begin(),v.end(),i)-v.begin();\\n            \\n      \\n            int m=v.size(),p=t.size();\\n            \\n            if(u>=m)ans=min(ans,p-(j+1));\\n        \\n            else ans=min(ans,p-(m-u)-(j+1));\\n            \\n            j++;\\n            i++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175525,
                "title": "find-the-shortest-substring-of-t-match-from-right-then-left-two-pass-o-n",
                "content": "# Intuition \\nThe score `right - left + 1` equals to substring length.\\nSo to minimize the score, it means we should find a shortest substring of `t` which after we remove this substring then `t` will be a subsequence of `s`.\\n\\n# Approach\\nIf we match from first character of `t`, say `t[0:j+1]` is a subsequence of `s[0:i+1]`, then how many characters the rest of `s`, i.e. `s[i+1:]` can match `t` from t\\'s right most? We can pre-calculate this right-match-cnt of `t`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```python3 []\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        ns = len(s)\\n        nt = len(t)\\n        rcnt = [0] * (ns + 1)  # right-match-cnt\\n\\n        i = ns - 1\\n        j = nt - 1\\n        while i >= 0:\\n            if j >= 0 and s[i] == t[j]:\\n                rcnt[i] = rcnt[i + 1] + 1\\n                j -= 1\\n            else:\\n                rcnt[i] = rcnt[i + 1]\\n            i -= 1\\n\\n        if rcnt[0] >= nt:  # match all of t\\n            return 0\\n\\n        ret = nt - rcnt[0]\\n        i = j = 0\\n        while j < nt:\\n            while i < ns and s[i] != t[j]:\\n                i += 1\\n            if i >= ns:\\n                break\\n            subret = nt - (rcnt[i + 1] + j + 1)  # left matches j+1, right matches rcnt[i + 1]\\n            ret = min(ret, subret)\\n            j += 1\\n            i += 1\\n        return ret\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int ns = s.size(), nt = t.size();\\n        vector<int> rcnt(ns + 1);\\n        for (int i = ns - 1, j = nt - 1; i >= 0; --i) {\\n            if (j >= 0 && s[i] == t[j]) {\\n                rcnt[i] = rcnt[i+1] + 1;\\n                --j;\\n            } else {\\n                rcnt[i] = rcnt[i+1];\\n            }\\n        }\\n\\n        if (rcnt[0] >= nt) return 0;\\n\\n        int ret = nt - rcnt[0];\\n        for (int i = 0, j = 0; j < nt; ++j, ++i) {\\n            while (i < ns && s[i] != t[j]) ++i;\\n            if (i >= ns) break;\\n            int subret = nt - (rcnt[i + 1] + j + 1);\\n            ret = min(ret, subret);\\n        }\\n        return ret;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        int ns = s.length(), nt = t.length();\\n        int[] rcnt = new int[ns + 1];\\n        for (int i = ns - 1, j = nt - 1; i >= 0; --i) {\\n            if (j >= 0 && s.charAt(i) == t.charAt(j)) {\\n                rcnt[i] = rcnt[i + 1] + 1;\\n                --j;\\n            } else {\\n                rcnt[i] = rcnt[i + 1];\\n            }\\n        }\\n        if (rcnt[0] >= nt) return 0;\\n\\n        int ret = nt - rcnt[0];\\n        for (int i = 0, j = 0; j < nt; ++i, ++j) {\\n            while (i < ns && s.charAt(i) != t.charAt(j)) ++i;\\n            if (i >= ns) break;\\n            int subret = nt - (rcnt[i + 1] + j + 1);\\n            ret = Math.min(ret, subret);\\n        }\\n        return ret;\\n    }\\n}\\n```\\n```Go []\\nfunc minimumScore(s string, t string) int {\\n    ns, nt := len(s), len(t)\\n    rcnt := make([]int, ns + 1)\\n    for i, j := ns - 1, nt - 1; i >= 0; i-- {\\n        if (j >= 0 && s[i] == t[j]) {\\n            rcnt[i] = rcnt[i + 1] + 1\\n            j--\\n        } else {\\n            rcnt[i] = rcnt[i + 1]\\n        }\\n    }\\n    if rcnt[0] >= nt {\\n        return 0\\n    }\\n    ret := nt - rcnt[0]\\n    for i, j := 0, 0; j < nt; i, j = i + 1, j + 1 {\\n        for i < ns && s[i] != t[j] {\\n            i++\\n        }\\n        if i >= ns {\\n            break\\n        }\\n        if subret := nt - (rcnt[i + 1] + j + 1); subret < ret {\\n            ret = subret\\n        }\\n    }\\n    return ret\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Go"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        ns = len(s)\\n        nt = len(t)\\n        rcnt = [0] * (ns + 1)  # right-match-cnt\\n\\n        i = ns - 1\\n        j = nt - 1\\n        while i >= 0:\\n            if j >= 0 and s[i] == t[j]:\\n                rcnt[i] = rcnt[i + 1] + 1\\n                j -= 1\\n            else:\\n                rcnt[i] = rcnt[i + 1]\\n            i -= 1\\n\\n        if rcnt[0] >= nt:  # match all of t\\n            return 0\\n\\n        ret = nt - rcnt[0]\\n        i = j = 0\\n        while j < nt:\\n            while i < ns and s[i] != t[j]:\\n                i += 1\\n            if i >= ns:\\n                break\\n            subret = nt - (rcnt[i + 1] + j + 1)  # left matches j+1, right matches rcnt[i + 1]\\n            ret = min(ret, subret)\\n            j += 1\\n            i += 1\\n        return ret\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int ns = s.size(), nt = t.size();\\n        vector<int> rcnt(ns + 1);\\n        for (int i = ns - 1, j = nt - 1; i >= 0; --i) {\\n            if (j >= 0 && s[i] == t[j]) {\\n                rcnt[i] = rcnt[i+1] + 1;\\n                --j;\\n            } else {\\n                rcnt[i] = rcnt[i+1];\\n            }\\n        }\\n\\n        if (rcnt[0] >= nt) return 0;\\n\\n        int ret = nt - rcnt[0];\\n        for (int i = 0, j = 0; j < nt; ++j, ++i) {\\n            while (i < ns && s[i] != t[j]) ++i;\\n            if (i >= ns) break;\\n            int subret = nt - (rcnt[i + 1] + j + 1);\\n            ret = min(ret, subret);\\n        }\\n        return ret;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minimumScore(String s, String t) {\\n        int ns = s.length(), nt = t.length();\\n        int[] rcnt = new int[ns + 1];\\n        for (int i = ns - 1, j = nt - 1; i >= 0; --i) {\\n            if (j >= 0 && s.charAt(i) == t.charAt(j)) {\\n                rcnt[i] = rcnt[i + 1] + 1;\\n                --j;\\n            } else {\\n                rcnt[i] = rcnt[i + 1];\\n            }\\n        }\\n        if (rcnt[0] >= nt) return 0;\\n\\n        int ret = nt - rcnt[0];\\n        for (int i = 0, j = 0; j < nt; ++i, ++j) {\\n            while (i < ns && s.charAt(i) != t.charAt(j)) ++i;\\n            if (i >= ns) break;\\n            int subret = nt - (rcnt[i + 1] + j + 1);\\n            ret = Math.min(ret, subret);\\n        }\\n        return ret;\\n    }\\n}\\n```\n```Go []\\nfunc minimumScore(s string, t string) int {\\n    ns, nt := len(s), len(t)\\n    rcnt := make([]int, ns + 1)\\n    for i, j := ns - 1, nt - 1; i >= 0; i-- {\\n        if (j >= 0 && s[i] == t[j]) {\\n            rcnt[i] = rcnt[i + 1] + 1\\n            j--\\n        } else {\\n            rcnt[i] = rcnt[i + 1]\\n        }\\n    }\\n    if rcnt[0] >= nt {\\n        return 0\\n    }\\n    ret := nt - rcnt[0]\\n    for i, j := 0, 0; j < nt; i, j = i + 1, j + 1 {\\n        for i < ns && s[i] != t[j] {\\n            i++\\n        }\\n        if i >= ns {\\n            break\\n        }\\n        if subret := nt - (rcnt[i + 1] + j + 1); subret < ret {\\n            ret = subret\\n        }\\n    }\\n    return ret\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175168,
                "title": "c-linear-scan-o-n-beats-100",
                "content": "We want a prefix of `t` and a suffix of `t` such that when we concatenate them, it is a valid subsequence of `s`.\\n```\\nclass Solution {\\npublic:\\n  int minimumScore(string s, string t) {\\n    int left = 0, right = t.size() - 1;\\n    \\n    // Will contain the final answer.\\n    int ans = t.size();\\n    \\n    // All the indices where the left prefix matched s from the left side.\\n    vector<int> leftMatches;\\n    for (int i = 0; i < s.size(); ++i) {\\n      if (left < t.size() && s[i] == t[left]) {\\n        // The length of leftMatches always == left.\\n        leftMatches.push_back(i);\\n        ++left;\\n      }\\n    }\\n    \\n    ans = min(ans, 1 + right - left);\\n    \\n    // Start matching suffixes of t with s starting from the right side.\\n    for (int i = s.size() - 1; i >= 0; --i) {\\n      if (right >= 0 && s[i] == t[right]) {\\n        --right;\\n        \\n        // Pop the rightmost index from leftMatches by decrementing left\\n        // if we are now behind it.\\n        while ((left - 1) >= 0 && i <= leftMatches[left - 1]) {\\n          --left;\\n        }\\n        \\n        if (right < left) {\\n          // Entire t is a subsequence of s.\\n          return 0;\\n        }\\n\\n        ans = min(ans, 1 + right - left);\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int minimumScore(string s, string t) {\\n    int left = 0, right = t.size() - 1;\\n    \\n    // Will contain the final answer.\\n    int ans = t.size();\\n    \\n    // All the indices where the left prefix matched s from the left side.\\n    vector<int> leftMatches;\\n    for (int i = 0; i < s.size(); ++i) {\\n      if (left < t.size() && s[i] == t[left]) {\\n        // The length of leftMatches always == left.\\n        leftMatches.push_back(i);\\n        ++left;\\n      }\\n    }\\n    \\n    ans = min(ans, 1 + right - left);\\n    \\n    // Start matching suffixes of t with s starting from the right side.\\n    for (int i = s.size() - 1; i >= 0; --i) {\\n      if (right >= 0 && s[i] == t[right]) {\\n        --right;\\n        \\n        // Pop the rightmost index from leftMatches by decrementing left\\n        // if we are now behind it.\\n        while ((left - 1) >= 0 && i <= leftMatches[left - 1]) {\\n          --left;\\n        }\\n        \\n        if (right < left) {\\n          // Entire t is a subsequence of s.\\n          return 0;\\n        }\\n\\n        ans = min(ans, 1 + right - left);\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175120,
                "title": "simple-prefix-and-suffix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate the distance reached in t till any index in s .Both ways prefix and suffix.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n=s.length();\\n        int m=t.length();\\n        int st=0,en=m-1;\\n        vector<int> pre(n,-1),suf(n+1,-1);\\n        suf[n]=m;\\n        for(int i=0;i<n;i++){\\n            if(st<m&&s[i]==t[st]){\\n                st++;\\n            }\\n            pre[i]=st;\\n        }\\n        for(int j=n-1;j>=0;j--){\\n            if(en>=0&&s[j]==t[en]){\\n                en--;\\n            }\\n            suf[j]=en+1;\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(suf[i+1]<=pre[i])\\n                return 0;\\n            ans=min(ans,suf[i+1]-pre[i]);\\n        }\\n        ans=min(ans,suf[0]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n=s.length();\\n        int m=t.length();\\n        int st=0,en=m-1;\\n        vector<int> pre(n,-1),suf(n+1,-1);\\n        suf[n]=m;\\n        for(int i=0;i<n;i++){\\n            if(st<m&&s[i]==t[st]){\\n                st++;\\n            }\\n            pre[i]=st;\\n        }\\n        for(int j=n-1;j>=0;j--){\\n            if(en>=0&&s[j]==t[en]){\\n                en--;\\n            }\\n            suf[j]=en+1;\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(suf[i+1]<=pre[i])\\n                return 0;\\n            ans=min(ans,suf[i+1]-pre[i]);\\n        }\\n        ans=min(ans,suf[0]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175104,
                "title": "commented-explained-c-understandable-o-n",
                "content": "# Intuition\\nTo form intuition for this problem, we need to understand the problem description thoroughly. The goal is to find the minimum score of t such that t is a subsequence of s. The score is defined as the difference between the maximum and minimum indices of all removed characters in t.\\n\\nWith this in mind, we can think of the problem as finding the longest prefix and suffix of t that are substrings of s. We start by finding the suffix by iterating through s in reverse order and keeping track of the indices of characters in s that match characters in t. This creates a dp array that stores the indices in s of the corresponding characters in t.\\n\\n# Explanation\\nThe minimumScore function takes in two strings s and t and returns the minimum possible score to make t a subsequence of s. The score is calculated as described in the problem statement:\\n\\n* if no characters are removed from the string t, then the score is 0\\n* otherwise, the score is equal to the difference between the maximum index and the minimum index among all removed characters, plus 1\\n\\nThe function starts by initializing the variable ss to the length of s, st to the length of t, and k to st - 1. The dp array is initialized with st elements all equal to -1.\\n\\nThe next step is to build the suffix of t. This is done by iterating through s from the end to the beginning and checking if the current character of s is equal to the current character of t starting from the end. If they are equal, then the index of the character in s is recorded in the dp array. The k variable is decremented each time a match is found.\\n\\nAfter building the suffix, the function moves on to building the prefix of t by iterating through s from left to right. The j variable keeps track of the position of the current character of t that is being matched. The k variable is updated to the smallest index of dp that is greater than the current index i of s. The result res is then set to the minimum between res and the difference between k and j + 1.\\n\\nFinally, the function returns the res variable, which represents the minimum possible score to make t a subsequence of s.\\n\\nUPVOTE if you find helpful!\\n\\n# Complexity\\nTC: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        // initialize the length of strings `s` and `t`\\n        int ss = s.size(), st = t.size();\\n\\n        // `k` keeps track of the last matched character in t from the right\\n        int k = st - 1;\\n\\n        // initialize the dp array with all elements as -1\\n        vector<int> dp(st, -1);\\n\\n        // iterate from the end of `s` and match characters from the end of `t`\\n        for (int i = ss - 1; i >= 0 && k >= 0; --i) {\\n            // if the character at `i` in `s` matches the character at `k` in `t`, \\n            // update the `dp` array with the index `i`\\n            if (s[i] == t[k]) {\\n                dp[k--] = i;\\n            }\\n        }\\n\\n        // `res` stores the minimum score, initially set to `k + 1`\\n        int res = k + 1;\\n\\n        // iterate over `s` and `t` from the start\\n        for (int i = 0, j = 0; i < ss && j < st && res > 0; ++i) {\\n            // if the character at `i` in `s` matches the character at `j` in `t`, \\n            // increment `j`\\n            if (s[i] == t[j]) {\\n                // for each matched character, update `k` to the next character in `t` \\n                // that is yet to be matched\\n                for (; k < t.size() && dp[k] <= i; ++k);\\n                // update `res` with the minimum value of `res` and `k - (j + 1)`\\n                res = min(res, k - (++j));\\n            }\\n        }\\n\\n        // return the minimum score\\n        return res;\\n    }\\n\\n};\\n```\\n\\nThanks to @votrubac for code.\\n\\nUPVOTE if you find helpful!\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        // initialize the length of strings `s` and `t`\\n        int ss = s.size(), st = t.size();\\n\\n        // `k` keeps track of the last matched character in t from the right\\n        int k = st - 1;\\n\\n        // initialize the dp array with all elements as -1\\n        vector<int> dp(st, -1);\\n\\n        // iterate from the end of `s` and match characters from the end of `t`\\n        for (int i = ss - 1; i >= 0 && k >= 0; --i) {\\n            // if the character at `i` in `s` matches the character at `k` in `t`, \\n            // update the `dp` array with the index `i`\\n            if (s[i] == t[k]) {\\n                dp[k--] = i;\\n            }\\n        }\\n\\n        // `res` stores the minimum score, initially set to `k + 1`\\n        int res = k + 1;\\n\\n        // iterate over `s` and `t` from the start\\n        for (int i = 0, j = 0; i < ss && j < st && res > 0; ++i) {\\n            // if the character at `i` in `s` matches the character at `j` in `t`, \\n            // increment `j`\\n            if (s[i] == t[j]) {\\n                // for each matched character, update `k` to the next character in `t` \\n                // that is yet to be matched\\n                for (; k < t.size() && dp[k] <= i; ++k);\\n                // update `res` with the minimum value of `res` and `k - (j + 1)`\\n                res = min(res, k - (++j));\\n            }\\n        }\\n\\n        // return the minimum score\\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175096,
                "title": "c-super-short-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int s_sz = s.size(), t_sz = t.size(), suffix[100002]{}, res = t_sz;\\n        for(int i = s_sz-1, j = t_sz-1; i >= 0; i--) {\\n            if(j >= 0 && s[i] == t[j]) suffix[i] = t_sz - j--;\\n            else suffix[i] = suffix[i+1];\\n        }\\n        for(int i = 0, j = 0; i <= s_sz; i++) {\\n            res = min(res,  t_sz - min(t_sz, j + suffix[i]));\\n            if(i < s_sz && s[i] == t[j]) j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int s_sz = s.size(), t_sz = t.size(), suffix[100002]{}, res = t_sz;\\n        for(int i = s_sz-1, j = t_sz-1; i >= 0; i--) {\\n            if(j >= 0 && s[i] == t[j]) suffix[i] = t_sz - j--;\\n            else suffix[i] = suffix[i+1];\\n        }\\n        for(int i = 0, j = 0; i <= s_sz; i++) {\\n            res = min(res,  t_sz - min(t_sz, j + suffix[i]));\\n            if(i < s_sz && s[i] == t[j]) j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175007,
                "title": "python-sliding-window-linear-time-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can remove whole range from left to right\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry removing each range and check if remaining string form valid subsequence or not. To do this we need to precompute match indices in string s. Then using sliding window we can find minimum window size satisfying above condition.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        prefix, suffix = [len(s)] * (len(t) + 1), [-1] * (len(t) + 1)\\n        prefix[0], suffix[-1], tIdx = -1, len(s), 0\\n        for idx in range(len(s)):\\n            if tIdx >= len(t): break\\n            if s[idx] == t[tIdx]: \\n                prefix[tIdx + 1] = idx\\n                tIdx +=1\\n        tIdx = len(t) - 1\\n        for idx in reversed(range(len(s))):\\n            if tIdx < 0: break\\n            if s[idx] == t[tIdx]: \\n                suffix[tIdx] = idx\\n                tIdx -=1\\n        if prefix[-1] < len(s): return 0\\n        left, res = 0, max(len(s), len(t))\\n        for right in range(len(t)):\\n            left +=1\\n            while left <= right and prefix[left] < suffix[right + 1]: \\n                left +=1\\n            left -=1\\n            if prefix[left] < suffix[right + 1]: \\n                res = min(res, right - left + 1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```python []\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        prefix, suffix = [len(s)] * (len(t) + 1), [-1] * (len(t) + 1)\\n        prefix[0], suffix[-1], tIdx = -1, len(s), 0\\n        for idx in range(len(s)):\\n            if tIdx >= len(t): break\\n            if s[idx] == t[tIdx]: \\n                prefix[tIdx + 1] = idx\\n                tIdx +=1\\n        tIdx = len(t) - 1\\n        for idx in reversed(range(len(s))):\\n            if tIdx < 0: break\\n            if s[idx] == t[tIdx]: \\n                suffix[tIdx] = idx\\n                tIdx -=1\\n        if prefix[-1] < len(s): return 0\\n        left, res = 0, max(len(s), len(t))\\n        for right in range(len(t)):\\n            left +=1\\n            while left <= right and prefix[left] < suffix[right + 1]: \\n                left +=1\\n            left -=1\\n            if prefix[left] < suffix[right + 1]: \\n                res = min(res, right - left + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174994,
                "title": "python-left-and-right-o-n-with-detailed-explanation-and-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is adpated from https://leetcode.com/votrubac/\\'s solution.\\n\\nThe first observation is that since the number of removals doesn\\'t matter, we just need to figure out the start index on the left and the end index on the right. In other words, we want to find l and r such that t[:l] + t[r:] is a substring of s.\\n\\nIn the first pass, we find for each position in s **the largest index r of t** that would have to be removed for t be a substring s upto that index. i.e. **t[suffix[i]+1:] is a substring of s[i:] and suffix[i] is the least index such that this holds**.\\n\\nIn the second pass, we find **the largest index l of t** that is a substring of s[:i]. **The difference, (suffix[i] - l+1) would be the length that need to be removed to make t a substring of s.**\\n\\n**This way, we find the least score for such that t[:r] is a substring s[:i] and t[l+1:] is a substring of s[i:]. By taking the minimum over these scores, we find the true minimum score.**\\n\\n# Example\\n\\ns =[a,b,a,c,a,b,a], len(s) = 7\\nt = [b,z,a,a], len(t) = 4\\ninitialize suffix with -1:\\nsuffix = [-1,-1,-1,-1,-1,-1,-1], len(suffix) = 7\\n\\n---\\n**Go from left to right for both s and t in the first pass.**\\ns = [a,b,a,c,a,b,**a**], len(s) = 7, i = 6\\nt = [b,z,a,**a**], len(t) = 4, r = 3\\nfirst, set suffix[i] = r\\nsuffix = [-1,-1,-1,-1,-1,-1, **3**]\\nsince s[i] == t[r], we can decrease r by 1, to account for the fact that t[3:] is a substring of s[6:], which will be used in the second pass\\n\\n---\\ns = [a,b,a,c,a,**b**,a], len(s) = 7, i = 5\\nt = [b,z,**a**,a], len(t) = 4, r = 2\\nsince s[i] != t[r], the last index (counting from left to right) of t that is not a substring of s[5+1:] is 2, so we have\\nsuffix = [-1,-1,-1,-1,-1, **2**, 3]\\n\\n---\\ns = [a,b,a,c,**a**,b,a], len(s) = 7, i = 4\\nt = [b,z,**a**,a], len(t) = 4, r = 2\\nsimilar to the first case, we get \\nsuffix = [-1,-1,-1,-1,**2**, 2, 3] and move r to 1\\n\\n---\\ns = [a,b,a,c,a,b,a], len(s) = 7, i = 3\\nt = [b,**z**,a,a], len(t) = 4, r = 1\\nNote that now r points to z, which is not part of s. So, the pointer r will not decrease from now on. In the end,\\nsuffix = [1,1,1,1,2,2,3]\\n\\n---\\n\\n**Start from left to right for the second pass.**\\nans = r + 1 = 2 because we can remove everything including z and the rest of t (aa) would be a substring of s.\\n\\ns = [**a**,b,a,c,a,b,a], len(s) = 7, i = 0\\nt = [**b**,z,a,a], len(t) = 4, r = 0\\nsuffix = [1,1,1,1,2,2,3]\\nsince s[i]!=t[r], the substring we can form here is t[:r] + t[suffix[i]+1:] = \"\"+\"aa\" = \"aa\", and ans = min(2, 2-0) = 2.\\n\\n---\\ns = [a,**b**,a,c,a,b,a], len(s) = 7, i = 1\\nt = [**b**,z,a,a], len(t) = 4, r = 0\\nsuffix = [1,1,1,1,2,2,3]\\nsince s[i]==t[r], the substring we can form here is t[:r+1] + t[suffix[i]+1:] = \"b\"+\"aa\" = \"baa\", we update r to 1, ans = min(2, 1+1-1) = 1.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), since we pass through the array twice.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for the suffix array\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        suffix = [-1]*len(s) #last index of t that is not accounted for at i in s\\n        r = len(t)-1\\n        for i in reversed(range(len(s))): \\n            suffix[i] = r \\n            if 0 <= r and s[i] == t[r]: \\n                r -= 1\\n        # we know things after r are already a substring of s, so at most need to remove r+1 things\\n        ans = r + 1 \\n        l = 0 \\n        for i, ch in enumerate(s): \\n            # at i, on the right, we need to remove to suffix[i], on the right, we need to remove from l\\n            if l < len(t) and s[i] == t[l]: \\n                # t[l] matched with s[i], so for i+1, we don\\'t have to remove s[l]\\n                l += 1\\n            ans = min(ans, max(0, suffix[i] - l + 1))\\n        return min(ans, len(t)-l)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        suffix = [-1]*len(s) #last index of t that is not accounted for at i in s\\n        r = len(t)-1\\n        for i in reversed(range(len(s))): \\n            suffix[i] = r \\n            if 0 <= r and s[i] == t[r]: \\n                r -= 1\\n        # we know things after r are already a substring of s, so at most need to remove r+1 things\\n        ans = r + 1 \\n        l = 0 \\n        for i, ch in enumerate(s): \\n            # at i, on the right, we need to remove to suffix[i], on the right, we need to remove from l\\n            if l < len(t) and s[i] == t[l]: \\n                # t[l] matched with s[i], so for i+1, we don\\'t have to remove s[l]\\n                l += 1\\n            ans = min(ans, max(0, suffix[i] - l + 1))\\n        return min(ans, len(t)-l)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174953,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\nint minimumScore(const string&s, const string&t) {\\n    ll m=s.size(), n=t.size(), k=n-1;\\n    vi(ll)dp(n, -1);\\n    for(ll l=m-1;l>-1 && k>-1;--l){\\n        if(s[l]==t[k]){\\n            dp[k--]=l;\\n        }\\n    }\\n    if(k<0){\\n        return 0;\\n    }\\n    ll ans=k+1;\\n    for(ll i=0, j=0;i<m && j<n;++i){\\n        if(s[i]==t[j]){\\n            for(;k<n && dp[k]<=i;++k);\\n            ans=max(0LL, min(ans, k - (++j)));\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\nint minimumScore(const string&s, const string&t) {\\n    ll m=s.size(), n=t.size(), k=n-1;\\n    vi(ll)dp(n, -1);\\n    for(ll l=m-1;l>-1 && k>-1;--l){\\n        if(s[l]==t[k]){\\n            dp[k--]=l;\\n        }\\n    }\\n    if(k<0){\\n        return 0;\\n    }\\n    ll ans=k+1;\\n    for(ll i=0, j=0;i<m && j<n;++i){\\n        if(s[i]==t[j]){\\n            for(;k<n && dp[k]<=i;++k);\\n            ans=max(0LL, min(ans, k - (++j)));\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174620,
                "title": "python-sliding-window-min-100-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can remove whole range from left to right\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry removing each range and check if remaining string form valid subsequence or not.\\nTo do this we need to precompute match indices in string s.\\nThen using sliding window (or exhaustive binary search) we can find minimum window size satisfying above condition.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        ns,nt = len(s),len(t)\\n        pref = [ns]*(nt+1) # occ of char t[i] in s\\n        suff = [-1]*(nt+1) # occ of char t[i] in reversed s\\n        pref[0] = -1\\n        suff[-1] = ns\\n        ti = 0\\n        for i in range(ns):\\n            if(ti>=nt): break\\n            if(s[i]==t[ti]): \\n                pref[ti+1] = i;\\n                ti +=1\\n        ti = nt-1\\n        for i in reversed(range(ns)):\\n            if(ti<0): break\\n            if(s[i]==t[ti]): \\n                suff[ti] = i;\\n                ti -=1\\n        if(pref[-1]<ns): return 0; # whole subseq t exist in s\\n        i = 0 # sliding window to find min window size\\n        res = max(ns,nt)\\n        for j in range(nt):\\n            i +=1\\n            while(i<=j and pref[i]<suff[j+1]): i +=1\\n            i -=1\\n            if(pref[i]<suff[j+1]): \\n                res = min(res,j-i+1)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        ns,nt = len(s),len(t)\\n        pref = [ns]*(nt+1) # occ of char t[i] in s\\n        suff = [-1]*(nt+1) # occ of char t[i] in reversed s\\n        pref[0] = -1\\n        suff[-1] = ns\\n        ti = 0\\n        for i in range(ns):\\n            if(ti>=nt): break\\n            if(s[i]==t[ti]): \\n                pref[ti+1] = i;\\n                ti +=1\\n        ti = nt-1\\n        for i in reversed(range(ns)):\\n            if(ti<0): break\\n            if(s[i]==t[ti]): \\n                suff[ti] = i;\\n                ti -=1\\n        if(pref[-1]<ns): return 0; # whole subseq t exist in s\\n        i = 0 # sliding window to find min window size\\n        res = max(ns,nt)\\n        for j in range(nt):\\n            i +=1\\n            while(i<=j and pref[i]<suff[j+1]): i +=1\\n            i -=1\\n            if(pref[i]<suff[j+1]): \\n                res = min(res,j-i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174603,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minimumScore(const string &s, const string &t) {\\n    const int n_s = static_cast<int>(s.size());\\n    const int n_t = static_cast<int>(t.size());\\n    int left[n_s];\\n    memset(left, 0, sizeof(left));\\n    for (int length_t = 0, i_s = 0; i_s < n_s; ++i_s) {\\n      if (length_t < n_t && s[i_s] == t[length_t]) {\\n        ++length_t;\\n      }\\n      left[i_s] = length_t;\\n    }\\n    \\n    int right[n_s];\\n    memset(right, 0, sizeof(right));\\n    for (int length_t = 0, i_s = n_s - 1; i_s > -1; --i_s) {\\n      if (length_t < n_t && s[i_s] == t[n_t - length_t - 1]) {\\n        ++length_t;\\n      }\\n      right[i_s] = length_t;\\n    }\\n    \\n    int ret = n_t;\\n    for (int left_length = 0; left_length < n_s + 1; ++left_length) {\\n      const int l = left_length == 0 ? 0 : left[left_length - 1];\\n      const int r = left_length == n_s ? 0 : right[left_length];\\n      ret = min(ret, max(0, n_t - (l + r)));\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  int minimumScore(const string &s, const string &t) {\\n    const int n_s = static_cast<int>(s.size());\\n    const int n_t = static_cast<int>(t.size());\\n    int left[n_s];\\n    memset(left, 0, sizeof(left));\\n    for (int length_t = 0, i_s = 0; i_s < n_s; ++i_s) {\\n      if (length_t < n_t && s[i_s] == t[length_t]) {\\n        ++length_t;\\n      }\\n      left[i_s] = length_t;\\n    }\\n    \\n    int right[n_s];\\n    memset(right, 0, sizeof(right));\\n    for (int length_t = 0, i_s = n_s - 1; i_s > -1; --i_s) {\\n      if (length_t < n_t && s[i_s] == t[n_t - length_t - 1]) {\\n        ++length_t;\\n      }\\n      right[i_s] = length_t;\\n    }\\n    \\n    int ret = n_t;\\n    for (int left_length = 0; left_length < n_s + 1; ++left_length) {\\n      const int l = left_length == 0 ? 0 : left[left_length - 1];\\n      const int r = left_length == n_s ? 0 : right[left_length];\\n      ret = min(ret, max(0, n_t - (l + r)));\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174537,
                "title": "python-clean-o-n-match-prefix-and-suffix",
                "content": "# Code\\n```py\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        def scan(s, t):\\n            ans = [0]\\n            i = 0\\n            for c in s:\\n                if i < len(t) and t[i] == c:\\n                    i += 1\\n                ans.append(i)\\n            return ans\\n        r1 = scan(s, t)\\n        r2 = reversed(scan(s[::-1], t[::-1]))\\n        best = max(map(sum, zip(r1, r2)))\\n        return max(0, len(t) - best)\\n```\\n\\n# Intuition\\nMatch a prefix of `t` to a prefix of `s` and match a suffix of `t` to a suffix of `s`. We want to maximize the sum of the lengths of the prefix and suffix of `t`.\\n\\n# Approach\\n`scan(s, t)` finds, for each prefix of `s`, the longest prefix of `t` such that the prefix of `t` is a subsequence of the prefix of `s`. We scan once forwards to get `r1` and once backwards to get `r2`.\\nNow, for any index `j` we can split `s` to a prefix and a suffix. `t[:r1[j]]` is the longest prefix that matches the prefix `s[:j]` and `t[r2[j]:]` is the longest suffix that matches the suffix `s[j:]`. Then, `r1[j] + r2[j]` is the total length of prefix and suffix so `len(t) - r1[j] + r2[j]` is the best score if we split `s` at `j`.\\n\\n# Example\\n\\n```\\ns: \"abacaba\"\\nt: \"bzaa\"\\nr1: [0, 0, 1, 1, 1, 1, 1, 1]\\nr2: [2, 2, 2, 2, 2, 1, 1, 0]\\nlen(t) - r1[j] + r2[j] for each j:\\n    [2, 2, 1, 1, 1, 2, 2, 3]\\nanswer: 1\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n + m)$$ where $$n, m$$ are the lengths of `s` and `t` respectively\\n\\n- Space complexity:\\n$$O(n)$$ where $$n$$ is the length of `s`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        def scan(s, t):\\n            ans = [0]\\n            i = 0\\n            for c in s:\\n                if i < len(t) and t[i] == c:\\n                    i += 1\\n                ans.append(i)\\n            return ans\\n        r1 = scan(s, t)\\n        r2 = reversed(scan(s[::-1], t[::-1]))\\n        best = max(map(sum, zip(r1, r2)))\\n        return max(0, len(t) - best)\\n```\n```\\ns: \"abacaba\"\\nt: \"bzaa\"\\nr1: [0, 0, 1, 1, 1, 1, 1, 1]\\nr2: [2, 2, 2, 2, 2, 1, 1, 0]\\nlen(t) - r1[j] + r2[j] for each j:\\n    [2, 2, 1, 1, 1, 2, 2, 3]\\nanswer: 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174480,
                "title": "minimum-subarray-deletion-to-form-a-subsequence",
                "content": "# Intuition\\nThe problem statement mentions finding the minimum length of a subarray of one string (S) that needs to be deleted to make it a subsequence of another string (T).\\n\\nOne approach to solve this problem is to use binary search. We can start with the length of T as the upper limit and 0 as the lower limit. In each iteration of binary search, we check if a subarray of length m (the midpoint of the current lower and upper limits) can be deleted from S to make it a subsequence of T.\\n\\nTo check if a subarray of length m can be deleted, we can use two pointers to traverse both the arrays S and T. We can use the first pointer to traverse T and keep track of the positions of each character of T in S. Then, we use the second pointer to traverse S in reverse and check if the subarray of length m can be deleted such that T remains a subsequence of S.\\n\\nBased on the result of the check, we can adjust the lower and upper limits of binary search accordingly and continue the search until the lower limit is greater than the upper limit.\\n\\nThe final answer would be hi + 1, where hi is the upper limit after the binary search.\\n\\n# Approach\\nThe algorithm is a binary search solution for finding the minimum length of a subarray of one string that needs to be deleted to make it an subsequence of another string.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(n log n), where n is the length of the string T.\\n\\nThe binary search portion of the algorithm takes O(log n) time for each iteration, and the check function takes O(n) time, so the overall time complexity is O(n log n).\\n\\n- Space complexity:\\nThe space complexity of this algorithm is O(n).\\n\\nThe main source of space consumption in this algorithm is the pos array, which stores the positions of characters of T in S. The size of this array is n, where n is the length of T, so the space complexity is O(n).\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar minimumScore = function(S, T) {\\n    let s = S.split(\\'\\'), t = T.split(\\'\\');\\n    let lo = 0, hi = T.length;\\n    while (lo <= hi) {\\n        let m = Math.floor((lo + hi) / 2);\\n        if (check(s, t, m)) hi = m - 1;\\n        else lo = m + 1;\\n    }\\n    return hi + 1;\\n};\\n\\nvar check = function(s, t, len) {\\n    let t_length = t.length, n = s.length;\\n    if (len >= t_length) return true; //delete whole t array\\n    let pos = new Array(t_length).fill(1000000000); //Greedy left matching\\n    let t_left_index = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (t_left_index === t_length) break;\\n        if (t[t_left_index] === s[i]) {\\n            pos[t_left_index] = i;\\n            t_left_index++;\\n        }\\n    }\\n    if (t_left_index >= t_length - len) return true; //we can delete right subarray of length len\\n    let right_index_of_s = n - 1;\\n    for (let rp = t_length - 1; rp >= len; rp--) {\\n        while (right_index_of_s >= 0 && s[right_index_of_s] !== t[rp]) right_index_of_s--;\\n        if (right_index_of_s === -1) return false;\\n        let lp = rp - len - 1;\\n        if (lp === -1 || pos[lp] < right_index_of_s) return true;\\n        right_index_of_s--;\\n    }\\n    return false;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar minimumScore = function(S, T) {\\n    let s = S.split(\\'\\'), t = T.split(\\'\\');\\n    let lo = 0, hi = T.length;\\n    while (lo <= hi) {\\n        let m = Math.floor((lo + hi) / 2);\\n        if (check(s, t, m)) hi = m - 1;\\n        else lo = m + 1;\\n    }\\n    return hi + 1;\\n};\\n\\nvar check = function(s, t, len) {\\n    let t_length = t.length, n = s.length;\\n    if (len >= t_length) return true; //delete whole t array\\n    let pos = new Array(t_length).fill(1000000000); //Greedy left matching\\n    let t_left_index = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (t_left_index === t_length) break;\\n        if (t[t_left_index] === s[i]) {\\n            pos[t_left_index] = i;\\n            t_left_index++;\\n        }\\n    }\\n    if (t_left_index >= t_length - len) return true; //we can delete right subarray of length len\\n    let right_index_of_s = n - 1;\\n    for (let rp = t_length - 1; rp >= len; rp--) {\\n        while (right_index_of_s >= 0 && s[right_index_of_s] !== t[rp]) right_index_of_s--;\\n        if (right_index_of_s === -1) return false;\\n        let lp = rp - len - 1;\\n        if (lp === -1 || pos[lp] < right_index_of_s) return true;\\n        right_index_of_s--;\\n    }\\n    return false;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174479,
                "title": "python-3-beats-100-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be rephrased as, what is the minimum length of a contiguous substring that can be taken out to make T a generic substring of S.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumScore(self, S: str, T: str) -> int:\\n        lS,lT = len(S),len(T)\\n        setS,setT = set(S),set(T)\\n        setTMS = setT-setS\\n        \\n        s = 0\\n        listL = []\\n        for t in T:\\n            if t in setTMS:     break\\n            while s<lS and S[s]!=t:\\n                s += 1\\n            if s==len(S):       break\\n            listL.append(s)\\n            s += 1\\n        if len(listL) == lT:            return 0\\n        \\n        s = lS-1\\n        listR = []\\n        for t in T[::-1]:\\n            if t in setTMS:     break\\n            while s>=0 and S[s]!=t:\\n                s -= 1\\n            if s==-1:       break\\n            listR.append(s)\\n            s -= 1\\n        listR = listR[::-1]\\n        if listL and listR and listL[-1]<listR[0] or not listL or not listR:\\n            return lT-len(listR)-len(listL)\\n            \\n        l = len(listL)-1\\n        retV = lT - max(len(listL), len(listR))\\n        for i,r in enumerate(listR[::-1]):\\n            while l>=0 and listL[l]>=r:\\n                l -= 1\\n            if l==-1:   break\\n            retV = min(retV, lT-i-1-l-1)\\n        return retV\\n        \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumScore(self, S: str, T: str) -> int:\\n        lS,lT = len(S),len(T)\\n        setS,setT = set(S),set(T)\\n        setTMS = setT-setS\\n        \\n        s = 0\\n        listL = []\\n        for t in T:\\n            if t in setTMS:     break\\n            while s<lS and S[s]!=t:\\n                s += 1\\n            if s==len(S):       break\\n            listL.append(s)\\n            s += 1\\n        if len(listL) == lT:            return 0\\n        \\n        s = lS-1\\n        listR = []\\n        for t in T[::-1]:\\n            if t in setTMS:     break\\n            while s>=0 and S[s]!=t:\\n                s -= 1\\n            if s==-1:       break\\n            listR.append(s)\\n            s -= 1\\n        listR = listR[::-1]\\n        if listL and listR and listL[-1]<listR[0] or not listL or not listR:\\n            return lT-len(listR)-len(listL)\\n            \\n        l = len(listL)-1\\n        retV = lT - max(len(listL), len(listR))\\n        for i,r in enumerate(listR[::-1]):\\n            while l>=0 and listL[l]>=r:\\n                l -= 1\\n            if l==-1:   break\\n            retV = min(retV, lT-i-1-l-1)\\n        return retV\\n        \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174396,
                "title": "deleting-subsequence-is-same-as-deleting-substring",
                "content": "# Intuition\\n1. Deleting subsequence at indexes 3,6,9 is same as deleting the whole substring from index 3\\\\~9, they both produce the same score, and we will always choose to delete substring rather than deleting subsequence because the more char we delete, the better chance we have to make \"t\" a subsequence of \"s\".\\n2. If deleting a short substring can produce a valid result, then deleting a longer substring must also produce a valid result. Because of this, we do binary search on the length of substring to delete.\\n\\nOnce the substring length is decided, we use sliding window to try deleting all substrings of the given length in \"t\".\\nGiven the substring length and starting index in \"t\", we need to find out in O(1) time that whether or not deleting this substirng makes t a subsequence of s. \\nTo do it in O(1) time, we need to map each index in t to the index in s from left to right, and each index in t to the index in s from right to left as well.\\nIf we are deleting substring t[i~j], then the \"left-to-right\" map of t[i-1] must be smaller than the \"right-to-left\" map of t[j+1], otherwise deleting this substring won\\'t make a valid result.\\n\\nEach step in sliding window cost O(1) time, O(n) time for one iteration in binary search. Totally O(nlgn) time.\\n\\n\\n# Code\\n```python\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        l2r = defaultdict(lambda: math.inf)\\n        l2r[-1]=-1\\n        j = 0\\n        for i in range(len(t)):\\n            while j<len(s) and t[i]!=s[j]:\\n                j+=1\\n            if j==len(s):\\n                break\\n            l2r[i]=j\\n            j+=1\\n        r2l = defaultdict(lambda: -math.inf)\\n        r2l[len(t)]=len(s)\\n        j = len(s)-1\\n        for i in range(len(t)-1,-1,-1):\\n            while j>=0 and t[i]!=s[j]:\\n                j-=1\\n            if j<0:\\n                break\\n            r2l[i]=j\\n            j-=1\\n        def canPass(l):\\n            for i in range(len(t)-l+1):\\n                if l2r[i-1]<r2l[i+l]:\\n                    return True\\n            return False\\n        lo,hi = 0,len(t)\\n        while lo<=hi:\\n            mid = (lo+hi)//2\\n            if canPass(mid):\\n                hi = mid-1\\n            else:\\n                lo = mid+1\\n        return lo\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumScore(self, s: str, t: str) -> int:\\n        l2r = defaultdict(lambda: math.inf)\\n        l2r[-1]=-1\\n        j = 0\\n        for i in range(len(t)):\\n            while j<len(s) and t[i]!=s[j]:\\n                j+=1\\n            if j==len(s):\\n                break\\n            l2r[i]=j\\n            j+=1\\n        r2l = defaultdict(lambda: -math.inf)\\n        r2l[len(t)]=len(s)\\n        j = len(s)-1\\n        for i in range(len(t)-1,-1,-1):\\n            while j>=0 and t[i]!=s[j]:\\n                j-=1\\n            if j<0:\\n                break\\n            r2l[i]=j\\n            j-=1\\n        def canPass(l):\\n            for i in range(len(t)-l+1):\\n                if l2r[i-1]<r2l[i+l]:\\n                    return True\\n            return False\\n        lo,hi = 0,len(t)\\n        while lo<=hi:\\n            mid = (lo+hi)//2\\n            if canPass(mid):\\n                hi = mid-1\\n            else:\\n                lo = mid+1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174388,
                "title": "beats-100-well-detailed-explained-c-solution",
                "content": "# Intuition\\nMy first intuition was really bad but as it turns out, if you\\'ll give some honest thought then Binary search will automatically come into the mind.\\n\\n# Approach\\nConcepts required : Binary search on answer and the very basics of prefix and suffix sums\\n\\nThis is commonly known as Binary search on answer. Here we do a binary search on the answer(what we have to find, here it is the number of elements to remove)\\n\\nThe first thing to notice is that if we are removing l\\'th element and r\\'th element then it is never a bad decision to remove l+1th, l+2th, ... , r-1th elements as well.\\n\\n**Proof**:\\n Again, the proof is very intutive: When we reduce some elements to be searched in the string s, it just lowers the burden on us.\\nConsider this example: If we can find the string abc as subsequence in string s, then we can also find strings \"\", \"a\", \"ab\", \"ac\", \"b\", \"bc\", \"c\", abc\" as well.\\n\\nSo that\\'s it, this is all the thought process which was needed in this question.\\n\\n**About vectors l and r:**\\nl[i] means the length of the prefix of t which can be found in the string s by considering the indices 0,1,2,..,i-1,i.\\nr[i] means the length of the suffix of t which can be found in the string s by considering the indices i,i+1,i+2,...,n-1\\n\\n**About Ok function**\\nIn the ok function, I just check whether the m-(l[i]+r[i+1]) <= len\\nwhich means that if I ignore the indices l[i], l[i]+1, .. ,. l[i] + m-(r[i+1]+l[i])-1 then what is the length of the subsequence that I can find in s and if this is <= len for any i in range [0, n-1) then I return true.\\n\\n# Complexity\\n- Time complexity:  O(nlogm) thanks to binary search\\n\\n- Space complexity: O(n) thanks to l and r vectors\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool ok(int len, vector<int> &l, vector<int> &r, int m){\\n        int n = l.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int x = l[i];\\n            int y = ((i==n-1)?0:r[i+1]);\\n            if(m-(y+x) <= len)  return true;\\n        }\\n        if(m-r[0] <= len)   return true;\\n        return false;\\n    }\\n    \\n    int minimumScore(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<int> l(n), r(n);\\n        int idx = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            l[i] = ((i==0)?0:l[i-1]);\\n            if(idx == m)    continue;\\n            if(s[i] == t[idx]){\\n                l[i]++;\\n                ++idx;\\n            }\\n        }\\n        \\n        idx = m - 1;\\n        for(int i=n-1; i>=0; i--){\\n            r[i] = ((i==n-1)?0:r[i+1]);\\n            if(idx == -1)   continue;\\n            if(s[i] == t[idx]){\\n                r[i]++;\\n                --idx;\\n            }\\n        }\\n        \\n        int ans = m;\\n        int lo = -1, hi = m;\\n        while(lo + 1 < hi){\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if(ok(mid, l, r, m)){\\n                hi = mid;\\n            }\\n            else{\\n                lo = mid;\\n            }\\n        }\\n        \\n        ans = hi;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool ok(int len, vector<int> &l, vector<int> &r, int m){\\n        int n = l.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int x = l[i];\\n            int y = ((i==n-1)?0:r[i+1]);\\n            if(m-(y+x) <= len)  return true;\\n        }\\n        if(m-r[0] <= len)   return true;\\n        return false;\\n    }\\n    \\n    int minimumScore(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<int> l(n), r(n);\\n        int idx = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            l[i] = ((i==0)?0:l[i-1]);\\n            if(idx == m)    continue;\\n            if(s[i] == t[idx]){\\n                l[i]++;\\n                ++idx;\\n            }\\n        }\\n        \\n        idx = m - 1;\\n        for(int i=n-1; i>=0; i--){\\n            r[i] = ((i==n-1)?0:r[i+1]);\\n            if(idx == -1)   continue;\\n            if(s[i] == t[idx]){\\n                r[i]++;\\n                --idx;\\n            }\\n        }\\n        \\n        int ans = m;\\n        int lo = -1, hi = m;\\n        while(lo + 1 < hi){\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if(ok(mid, l, r, m)){\\n                hi = mid;\\n            }\\n            else{\\n                lo = mid;\\n            }\\n        }\\n        \\n        ans = hi;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174328,
                "title": "c-longest-prefix-and-longest-suffix",
                "content": "The problem has a very special \"formular\" to compute the `cost`, `right - left + 1`. The formular indicates that no matter how many and sparsely you delete elements from `t`, it\\'s equivalent to remove \"all of them\" in that range. So let\\'s just instead look for the shortest range to remove such that `t` become a subsequence of `s`. This can further be deduced to\\n\\n**Find a pair of non-overlapping prefix and suffix whose sum of lengths is longest**.\\n\\n#### Method\\nLet\\'s `dp1[i] = j` point to the index in `t` such that `t(0:j)` is the subsequence of `s(0:i)`. (the slice notation means \"inclusive\"). Similarly, let `dp2[i] = j` point to the index such that `t(j:)` is the subsequence of `s(i:)`. Then for each `i`, we have a longest prefix matched by `s(0:i)` and longest suffix matched by `s(i+1:)`. Then just get the maximum.\\n\\n#### Solution\\nTime/Space: O(N)\\n```c++\\n\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n\\t\\t// longest prefix \\n\\t\\t// longest suffix\\n\\t\\t// dp1 := longest prefix\\n\\t\\tvector<int> dp1(s.size(), -1);\\n\\t\\tint j = 0;\\n\\t\\tfor(int i = 0; i < s.size(); ++i) {\\n\\t\\t\\tif(i > 0)\\n\\t\\t\\t\\tdp1[i] = dp1[i-1];\\n\\t\\t\\tif(j < t.size() && s[i] == t[j]) {\\n\\t\\t\\t\\tdp1[i] = j;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// dp2 := longest suffix\\n\\t\\tvector<int> dp2(s.size(), t.size());\\n\\t\\tint k = t.size() - 1;\\n\\t\\tfor(int i = s.size() - 1; i >= 0; i--) {\\n\\t\\t\\tif(i < s.size() - 1)\\n\\t\\t\\t\\tdp2[i] = dp2[i + 1];\\n\\t\\t\\tif(k >= 0 && s[i] == t[k]) {\\n\\t\\t\\t\\tdp2[i] = k;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// specially handle the prefix-only case and suffix-only case.\\n\\t\\tint sum = max(dp1[s.size() - 1] + 1, (int)t.size() - dp2[0]);\\n\\t\\tfor(int i = 0; i < s.size() - 1; ++i) {\\n\\t\\t\\tint prefix = dp1[i] + 1;\\n\\t\\t\\tint suffix = t.size() - dp2[i + 1];\\n\\t\\t\\tsum = max(sum, min(prefix + suffix, (int)t.size()));\\n\\t\\t}\\n\\t\\treturn t.size() - sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n\\t\\t// longest prefix \\n\\t\\t// longest suffix\\n\\t\\t// dp1 := longest prefix\\n\\t\\tvector<int> dp1(s.size(), -1);\\n\\t\\tint j = 0;\\n\\t\\tfor(int i = 0; i < s.size(); ++i) {\\n\\t\\t\\tif(i > 0)\\n\\t\\t\\t\\tdp1[i] = dp1[i-1];\\n\\t\\t\\tif(j < t.size() && s[i] == t[j]) {\\n\\t\\t\\t\\tdp1[i] = j;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// dp2 := longest suffix\\n\\t\\tvector<int> dp2(s.size(), t.size());\\n\\t\\tint k = t.size() - 1;\\n\\t\\tfor(int i = s.size() - 1; i >= 0; i--) {\\n\\t\\t\\tif(i < s.size() - 1)\\n\\t\\t\\t\\tdp2[i] = dp2[i + 1];\\n\\t\\t\\tif(k >= 0 && s[i] == t[k]) {\\n\\t\\t\\t\\tdp2[i] = k;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// specially handle the prefix-only case and suffix-only case.\\n\\t\\tint sum = max(dp1[s.size() - 1] + 1, (int)t.size() - dp2[0]);\\n\\t\\tfor(int i = 0; i < s.size() - 1; ++i) {\\n\\t\\t\\tint prefix = dp1[i] + 1;\\n\\t\\t\\tint suffix = t.size() - dp2[i + 1];\\n\\t\\t\\tsum = max(sum, min(prefix + suffix, (int)t.size()));\\n\\t\\t}\\n\\t\\treturn t.size() - sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174248,
                "title": "c-two-pointers-binary-search",
                "content": "$$n = length(s)$$\\n$$m = length(t)$$\\n\\n# Complexity\\n- Time complexity: $$O((n + m) * log(m))$$\\n- Space complexity: $$O(m)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MinimumScore(string s, string t)\\n    {\\n        int n = s.Length;\\n        int m = t.Length;\\n            \\n        var list = FindSubsequence(s, n, t, m);\\n\\n        if (list.Count > 0 && list[list.Count - 1].Item1 == m)\\n        {\\n            return 0;\\n        }\\n\\n        int min = m;\\n            \\n        int i = n - 1;\\n        int j = m - 1;\\n        for (int right = m - 1; right >= 0; right--)\\n        {\\n            while (i >= 0 && j > right)\\n            {\\n                if (s[i] == t[j])\\n                {\\n                    j--;\\n                }\\n\\n                i--;\\n            }\\n\\n            if (j <= right)\\n            {\\n                min = Math.Min(min, right + 1);\\n\\n                if (list.Count > 0 && list[0].Item2 <= i)\\n                {\\n                    int start = 0;\\n                    int end = list.Count - 1;\\n                    \\n                    int mid;\\n                    while (start < end)\\n                    {\\n                        mid = start + (end - start + 1) / 2;\\n                        \\n                        if (list[mid].Item2 <= i)\\n                        {\\n                            start = mid;\\n                        }\\n                        else\\n                        {\\n                            end = mid - 1;\\n                        }\\n                    }\\n                    \\n                    min = Math.Min(min, right - list[start].Item1 + 1);\\n                }\\n            }\\n        }\\n            \\n        return min;\\n    }\\n\\n    private IList<(int, int)> FindSubsequence(string s, int n, string t, int m)\\n    {\\n        var result = new List<(int, int)>();\\n            \\n        int i = 0;\\n        int j = 0;\\n\\n        while (i < n && j < m)\\n        {\\n            if (s[i] == t[j])\\n            {\\n                result.Add((++j, i));\\n            }\\n\\n            i++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers",
                    "String",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumScore(string s, string t)\\n    {\\n        int n = s.Length;\\n        int m = t.Length;\\n            \\n        var list = FindSubsequence(s, n, t, m);\\n\\n        if (list.Count > 0 && list[list.Count - 1].Item1 == m)\\n        {\\n            return 0;\\n        }\\n\\n        int min = m;\\n            \\n        int i = n - 1;\\n        int j = m - 1;\\n        for (int right = m - 1; right >= 0; right--)\\n        {\\n            while (i >= 0 && j > right)\\n            {\\n                if (s[i] == t[j])\\n                {\\n                    j--;\\n                }\\n\\n                i--;\\n            }\\n\\n            if (j <= right)\\n            {\\n                min = Math.Min(min, right + 1);\\n\\n                if (list.Count > 0 && list[0].Item2 <= i)\\n                {\\n                    int start = 0;\\n                    int end = list.Count - 1;\\n                    \\n                    int mid;\\n                    while (start < end)\\n                    {\\n                        mid = start + (end - start + 1) / 2;\\n                        \\n                        if (list[mid].Item2 <= i)\\n                        {\\n                            start = mid;\\n                        }\\n                        else\\n                        {\\n                            end = mid - 1;\\n                        }\\n                    }\\n                    \\n                    min = Math.Min(min, right - list[start].Item1 + 1);\\n                }\\n            }\\n        }\\n            \\n        return min;\\n    }\\n\\n    private IList<(int, int)> FindSubsequence(string s, int n, string t, int m)\\n    {\\n        var result = new List<(int, int)>();\\n            \\n        int i = 0;\\n        int j = 0;\\n\\n        while (i < n && j < m)\\n        {\\n            if (s[i] == t[j])\\n            {\\n                result.Add((++j, i));\\n            }\\n\\n            i++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174231,
                "title": "issubsequence-right-and-left-easy-explaination",
                "content": "# Intuition\\n\\nif after removing characters at i and j , the remaining string is subsequence, then even if we remove all the characters between i and j , then also the remaining string is the subsequence\\n\\n# Approach\\n1. Traverse in string t from right and check if the right part is a subsequence , if yes then store the leftmost index it matched else store -1\\n2. Now traverse the string t from left and if part [0,i] is a subsequence then we need first k > i such that substring from [k,t.length()-1] is also a subsequence and also the leftmost character matching for that part doesn\\'t interfere the part we used for matching while we are traversing from left\\n# Complexity\\n- Time complexity:\\nO(n);\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = t.length() , m=s.length();\\n        \\n        \\n        //dp[k] = for each k in t the rightmost character that matched t[k] and the subtring from [k,t.length()-1] is a subsequence\\n        vector<int> dp(n,-1);\\n        int j=n-1;\\n        for(int i=m-1;i>=0;i--){\\n            if(j<0) break;\\n            if(s[i] == t[j]){\\n                dp[j] = i;\\n                j--;\\n            }\\n        }\\n        \\n        //find first k which is subsequence\\n        int k=0;\\n        while(k<n and dp[k]==-1) k++;\\n\\n        j=0;\\n        int ans=k;\\n        for(int i=0;i<m;i++){\\n            if(j>=n) break;\\n            if(s[i]==t[j]){\\n                //find first k on right that doesn\\'t interfere\\n                while(k<n and (k<=j or dp[k]<=i)) k++;\\n                ans = min(ans , k - j - 1);\\n                j++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = t.length() , m=s.length();\\n        \\n        \\n        //dp[k] = for each k in t the rightmost character that matched t[k] and the subtring from [k,t.length()-1] is a subsequence\\n        vector<int> dp(n,-1);\\n        int j=n-1;\\n        for(int i=m-1;i>=0;i--){\\n            if(j<0) break;\\n            if(s[i] == t[j]){\\n                dp[j] = i;\\n                j--;\\n            }\\n        }\\n        \\n        //find first k which is subsequence\\n        int k=0;\\n        while(k<n and dp[k]==-1) k++;\\n\\n        j=0;\\n        int ans=k;\\n        for(int i=0;i<m;i++){\\n            if(j>=n) break;\\n            if(s[i]==t[j]){\\n                //find first k on right that doesn\\'t interfere\\n                while(k<n and (k<=j or dp[k]<=i)) k++;\\n                ans = min(ans , k - j - 1);\\n                j++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174218,
                "title": "c-problem-reduction-to-right-and-left-with-sliding-window",
                "content": "One key observation is since the score of the string is `right-left+1`, we can reduce the problem to finding the **shortest substring** to remove from `t` so that the remaining characters are a subsequence of `s`.\\n\\nI preprocess the string `t` as follows:\\n`left[i] = leftmost endpoint in s to match t[0..i]`\\n`right[i] = rightmost endpoint to match t[i..n-1]`\\nFrom there, we can then do a sliding window, shifting the right endpoint as little as possible to keep the window valid.\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = t.size();\\n        /*\\n            left[i]: leftmost endpoint in s to match t[0..i]\\n            right[i] = rightmost endpoint to match t[i..n-1]\\n        */\\n        vector<int> left(n,-1), right(n,-1);\\n        \\n        // Process left\\n        int j=0;\\n        for(int i=0; i<n; i++){\\n            while(j<s.size() && s[j]!=t[i]){\\n                j++;\\n            }\\n            if(j>=s.size()) break;\\n            left[i] = j++;\\n        }\\n        \\n        // Process right\\n        j = s.size()-1;\\n        for(int i=n-1; i>=0; i--){\\n            while(j>=0 && s[j]!=t[i]){\\n                j--;\\n            }\\n            if(j<0) break;\\n            right[i] = j--;\\n        }\\n        \\n        int ans=n;\\n        // The case when the optimal solution is to remove the shortest rightmost substring\\n        for(int i=0; i<n; i++){\\n            if(left[i]==-1) {\\n                ans = min(ans,n-i); break;\\n            }\\n        }\\n        \\n        // The case when the optimal solution is to remove the shortest leftmost substring\\n        for(int i=n-1; i>=0; i--){\\n            if(right[i]==-1) {\\n                ans = min(ans,i+1); \\n                break;\\n            }\\n        }\\n        \\n        if(left[0]<right[0]) return 0;\\n        // Sliding window, shifting high to the right as little as possible to keep the window valid\\n        int low=0, high=0;\\n        while(high<n && low<n && left[low]!=-1){\\n            while(high<n && (right[high]==-1 || right[high]<= left[low])){\\n                high++;\\n            }\\n            ans = min(ans,high-low-1);\\n            low++;\\n            high = max(high,low+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int minimumScore(string s, string t) {\\n        int n = t.size();\\n        /*\\n            left[i]: leftmost endpoint in s to match t[0..i]\\n            right[i] = rightmost endpoint to match t[i..n-1]\\n        */\\n        vector<int> left(n,-1), right(n,-1);\\n        \\n        // Process left\\n        int j=0;\\n        for(int i=0; i<n; i++){\\n            while(j<s.size() && s[j]!=t[i]){\\n                j++;\\n            }\\n            if(j>=s.size()) break;\\n            left[i] = j++;\\n        }\\n        \\n        // Process right\\n        j = s.size()-1;\\n        for(int i=n-1; i>=0; i--){\\n            while(j>=0 && s[j]!=t[i]){\\n                j--;\\n            }\\n            if(j<0) break;\\n            right[i] = j--;\\n        }\\n        \\n        int ans=n;\\n        // The case when the optimal solution is to remove the shortest rightmost substring\\n        for(int i=0; i<n; i++){\\n            if(left[i]==-1) {\\n                ans = min(ans,n-i); break;\\n            }\\n        }\\n        \\n        // The case when the optimal solution is to remove the shortest leftmost substring\\n        for(int i=n-1; i>=0; i--){\\n            if(right[i]==-1) {\\n                ans = min(ans,i+1); \\n                break;\\n            }\\n        }\\n        \\n        if(left[0]<right[0]) return 0;\\n        // Sliding window, shifting high to the right as little as possible to keep the window valid\\n        int low=0, high=0;\\n        while(high<n && low<n && left[low]!=-1){\\n            while(high<n && (right[high]==-1 || right[high]<= left[low])){\\n                high++;\\n            }\\n            ans = min(ans,high-low-1);\\n            low++;\\n            high = max(high,low+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": []
    }
]